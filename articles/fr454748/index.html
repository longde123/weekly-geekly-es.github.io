<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏾 👩🏼‍🚒 👨‍👦‍👦 Guide de survie MongoDB 🍂 🔩 👨‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Toutes les bonnes startups meurent rapidement ou se développent à l'échelle. Nous modéliserons une telle startup, qui concerne d'abord les fonctionnal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide de survie MongoDB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/454748/">  Toutes les bonnes startups meurent rapidement ou se développent à l'échelle.  Nous modéliserons une telle startup, qui concerne d'abord les fonctionnalités, puis les performances.  Nous allons améliorer les performances avec MongoDB, une solution de stockage de données NoSQL populaire.  MongoDB est facile à démarrer et de nombreux problèmes ont des solutions prêtes à l'emploi.  Cependant, lorsque la charge augmente, un râteau sort que personne ne vous avait prévenu avant ... jusqu'à aujourd'hui! <br><br><img src="https://habrastorage.org/webt/oh/rq/ua/ohrquayfyh04hfgs-gareddfzlk.gif" alt="image"><br><br>  La modélisation est effectuée par <strong>Sergey Zagursky</strong> , responsable de l'infrastructure backend en général, et MongoDB en particulier, dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Joom</a> .  Il a également été vu dans le côté serveur du développement du MMORPG Skyforge.  Comme Sergei le décrit lui-même, il est «un preneur de cônes professionnel avec son propre front et son propre râteau».  Au microscope, un projet qui utilise une stratégie d'accumulation pour gérer la dette technique.  Dans cette version texte du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> en HighLoad ++, nous allons passer par ordre chronologique de l'occurrence du problème à la solution à l'aide de MongoDB. <br><a name="habracut"></a><br><h2>  Premières difficultés </h2><br>  Nous modélisons une startup qui bourre les bosses.  La première étape de la vie - les fonctionnalités sont lancées dans notre startup et, de manière inattendue, les utilisateurs viennent.  Notre petit-petit serveur MongoDB a une charge dont nous n'avons jamais rêvé.  Mais nous sommes dans le cloud, nous sommes une startup!  Nous faisons les choses les plus simples possibles: regardez les demandes - oh, et ici nous avons soustrait la correction entière pour chaque utilisateur, ici nous construirons les indices, nous y ajouterons le matériel, et ici nous mettrons en cache. <br>  Tout - nous vivons! <br><br><blockquote>  Si des problèmes peuvent être résolus par des moyens aussi simples, ils doivent être résolus de cette manière. </blockquote><br>  Mais la voie future d'un démarrage réussi est un retard lent et douloureux du moment de mise à l'échelle horizontale.  Je vais essayer de donner des conseils sur la façon de survivre à cette période, de passer à l'échelle et de ne pas marcher sur le râteau. <br><br><h2>  Enregistrement lent </h2><br>  C'est l'un des problèmes que vous pouvez rencontrer.  Que faire si vous la rencontrez et que les méthodes ci-dessus ne vous aident pas?  Réponse: <strong>mode de garantie de</strong> <strong>durabilité</strong> <strong>dans MongoDB par défaut</strong> .  En trois mots, cela fonctionne comme ceci: <br><br><ul><li>  Nous sommes arrivés à la ligne principale et avons dit: "Écrivez!". <br></li><li>  Réplique primaire enregistrée. <br></li><li>  Après cela, des répliques secondaires ont été lues d'elle et ils ont dit primaire: "Nous avons enregistré!" <br></li></ul><br>  Au moment où la plupart des répliques secondaires l'ont fait, la demande est considérée comme terminée et le contrôle revient au pilote dans l'application.  De telles garanties nous permettent d'être sûrs que lorsque le contrôle est revenu à l'application, la durabilité n'ira nulle part, même si MongoDB se couche, à l'exception de catastrophes absolument terribles. <br><br><blockquote>  Heureusement, MongoDB est une telle base de données qui vous permet de réduire les garanties de durabilité pour chaque demande individuelle. </blockquote><br>  Pour les demandes importantes, nous pouvons laisser les garanties de durabilité maximale par défaut, et pour certaines demandes, nous pouvons les réduire. <br><br><h3>  Classes de demande </h3><br>  La première couche de garanties que nous pouvons supprimer est de <strong>ne pas attendre la confirmation de l'enregistrement par la plupart des répliques</strong> .  Cela économise la latence, mais n'ajoute pas de bande passante.  Mais parfois, la latence est ce dont vous avez besoin, surtout si le cluster est un peu surchargé et que les répliques secondaires ne fonctionnent pas aussi vite que nous le souhaiterions. <br><br><pre><code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>}</code> </pre> <br>  Si nous écrivons des enregistrements avec de telles garanties, alors au moment où nous obtenons le contrôle dans l'application, nous ne savons plus si l'enregistrement sera vivant après une sorte d'accident.  Mais généralement, elle est toujours en vie. <br><br>  La prochaine garantie, qui affecte également la bande passante et la latence, est de <strong>désactiver la confirmation de journalisation</strong> .  Une entrée de journal est quand même écrite.  Le magazine est l'un des mécanismes fondamentaux.  Si nous désactivons la confirmation de l'écriture, nous ne faisons pas deux choses: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u><strong>fsync</strong></u></a> <strong>sur le journal</strong> et <strong>n'attendons pas qu'il se termine</strong> .  Cela peut <strong>économiser beaucoup de ressources de disque</strong> et obtenir une <strong>augmentation multiple du débit en</strong> changeant simplement la durabilité de la garantie. <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>}</code> </pre> <br>  Les garanties de durabilité les plus strictes <strong>désactivent toute reconnaissance</strong> .  Nous ne recevrons que la confirmation que la demande a atteint la réplique principale.  Cela permettra d'économiser la latence et n'augmentera en aucun cas le débit. <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>} —   .</code> </pre> <br>  Nous recevrons également diverses autres choses, par exemple, l'enregistrement a échoué en raison d'un conflit avec une clé unique. <br><br><h3>  À quelles opérations cela s'applique-t-il? </h3><br>  Je vais vous parler de l'application à la configuration dans Joom.  En plus de la charge des utilisateurs, dans laquelle il n'y a pas de concessions de durabilité, il y a une charge qui peut être décrite comme une charge de lot en arrière-plan: mise à jour, recomptage des évaluations, collecte de données analytiques. <br><br>  Ces opérations d'arrière-plan peuvent prendre des heures, mais sont conçues de telle sorte que si une interruption, par exemple, un backend se bloque, elles ne perdront pas le résultat de tout leur travail, mais reprendront à partir du point dans le passé récent.  La réduction de la garantie de durabilité est utile pour de telles tâches, d'autant plus que fsync dans le journal, comme toutes les autres opérations, augmentera également la latence pour la lecture. <br><br><h2>  Lire l'échelle </h2><br>  Le problème suivant est <strong>une bande passante de lecture insuffisante</strong> .  Rappelez-vous que dans notre cluster, il n'y a pas seulement des répliques primaires, mais aussi des répliques secondaires à <strong>partir desquelles vous pouvez lire</strong> .  Faisons-le. <br><br>  Vous pouvez lire, mais il y a des nuances.  Les données légèrement obsolètes proviendront de répliques secondaires - de 0,5 à 1 seconde.  Dans la plupart des cas, cela est normal, mais le comportement de la réplique secondaire est différent de celui des répliques principales. <br><br>  Sur le secondaire, il y a le processus d'utilisation d'oplog, qui n'est pas sur le réplica principal.  Ce processus n'est pas conçu pour une faible latence - seuls les développeurs MongoDB ne se sont pas souciés de cela.  Dans certaines conditions, le processus d'utilisation de l'oplog du primaire au secondaire peut entraîner des retards allant jusqu'à 10 s. <br><br><blockquote>  Les répliques secondaires ne conviennent pas aux requêtes des utilisateurs - les expériences des utilisateurs font un pas rapide dans le bac. </blockquote><br>  Sur les grappes non ombrées, ces pics sont moins visibles, mais toujours là.  Les clusters d'éclat souffrent car oplog est particulièrement affecté par la suppression, et la <strong>suppression fait partie du travail de l'équilibreur</strong> .  L'équilibreur supprime de manière fiable et avec goût des documents par dizaines de milliers en peu de temps. <br><br><h2>  Nombre de connexions </h2><br>  Le prochain facteur à considérer est la <strong>limite du nombre de connexions sur les instances MongoDB</strong> .  Par défaut, il n'y a pas de restrictions, à l' <strong>exception des ressources du système d'exploitation -</strong> vous pouvez vous connecter pendant que cela le permet. <br><br>  Cependant, plus les demandes simultanées sont simultanées, plus elles s'exécutent lentement.  <strong>Les performances se dégradent de façon non linéaire</strong> .  Par conséquent, si un pic de demandes nous parvient, il vaut mieux servir 80% que de ne pas servir 100%.  Le nombre de connexions doit être limité directement à MongoDB. <br><br>  Mais il y a des bugs qui peuvent causer des problèmes à cause de cela.  En particulier, le <strong>pool de connexions côté MongoDB est commun aux connexions intracluster utilisateur et service</strong> .  Si l'application "a mangé" toutes les connexions de ce pool, l'intégrité peut être violée dans le cluster. <br><br>  Nous l'avons appris lorsque nous allions reconstruire l'index, et comme nous devions supprimer l'unicité de l'index, la procédure a traversé plusieurs étapes.  Dans MongoDB, vous ne pouvez pas créer le même à côté de l'index, mais sans l'unicité.  Par conséquent, nous voulions: <br><br><ul><li>  Construire un index similaire sans unicité <br></li><li>  supprimer l'index avec unicité; <br></li><li>  Construisez un index sans unicité au lieu de distant; <br></li><li>  supprimer temporairement. <br></li></ul><br>  Lorsque l'index temporaire était encore en cours de finalisation sur le secondaire, nous avons commencé à supprimer l'index unique.  À ce stade, le MongoDB secondaire a annoncé son verrouillage.  Certaines métadonnées ont été bloquées et, dans la plupart des cas, tous les enregistrements se sont arrêtés: ils se sont accrochés dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>pool de connexions</u></a> et ont attendu qu'ils confirment que l'enregistrement était passé.  Toutes les lectures sur le secondaire se sont également arrêtées car le journal global a été capturé. <br><br>  Le cluster dans un état aussi intéressant a également perdu sa connectivité.  Parfois, il est apparu et lorsque deux remarques se sont connectées, ils ont essayé de faire un choix dans leur état qu'ils ne pouvaient pas faire, car ils ont un verrou global. <br><br><blockquote>  Morale de l'histoire: le nombre de connexions doit être surveillé. </blockquote><br>  Il y a un râteau MongoDB bien connu, qui est encore si souvent attaqué que j'ai décidé de faire une courte promenade dessus. <br><br><h2>  Ne perdez pas de documents </h2><br>  Si vous envoyez une demande par index à MongoDB, la <strong>demande peut ne pas retourner tous les documents</strong> qui remplissent la condition, et dans des cas complètement inattendus.  Cela est dû au fait que lorsque nous allons au début de l'index, le document, qui à la fin, se déplace vers le début pour les documents que nous avons passés.  Cela est uniquement dû <strong>à la mutabilité de l'indice</strong> .  Pour une itération fiable, utilisez des <strong>index sur des champs non stables</strong> et il n'y aura pas de difficultés. <br>  MongoDB a ses propres vues sur les index à utiliser.  La solution est simple - <strong>avec l'aide de $ hint, nous forçons MongoDB à utiliser l'index que nous avons spécifié</strong> . <br><br><h2>  Tailles de collection </h2><br>  Notre startup se développe, il y a beaucoup de données, mais je ne veux pas ajouter de disques - nous en avons déjà ajouté trois fois le mois dernier.  Voyons ce qui est stocké dans nos données, regardons la taille des documents.  Comment comprendre où dans la collection vous pouvez réduire la taille?  Selon deux paramètres. <br><br><ul><li>  <strong>La taille des</strong> <strong>documents spécifiques</strong> pour jouer avec leur longueur: <code>Object.bsonsize()</code> ; <br></li><li>  <strong>Selon la</strong> <strong>taille</strong> <strong>moyenne</strong> <strong>du document dans</strong> <strong>la</strong> <strong>collection</strong> : <code>db.c.stats().avgObjectSize</code> . <br></li></ul><br><h3>  Comment affecter la taille du document? </h3><br>  J'ai des réponses non spécifiques à cette question.  Tout d'abord, un <strong>nom de champ long augmente la taille du document.</strong>  Dans chaque document, tous les noms de champ sont copiés, donc si le document a un nom de champ long, la taille du nom doit être ajoutée à la taille de chaque document.  Si vous avez une collection avec un grand nombre de petits documents sur plusieurs champs, alors nommez les champs avec des noms courts: "A", "B", "CD" - un maximum de deux lettres.  <strong>Sur le disque, cela est compensé par la compression</strong> , mais tout est stocké dans le cache tel quel. <br><br>  La deuxième astuce est que parfois <strong>certains champs de faible cardinalité peuvent être placés au nom de la collection</strong> .  Par exemple, un tel champ peut être une langue.  Si nous avons une collection avec des traductions en russe, anglais, français et un champ avec des informations sur la langue stockée, la valeur de ce champ peut être mise dans le nom de la collection.  Nous allons donc <strong>réduire la taille des documents</strong> et pouvons <strong>réduire le nombre et la taille des index</strong> - de <strong>simples</strong> économies!  Cela ne peut pas toujours être fait, car il existe parfois des index dans le document qui ne fonctionneront pas si la collection est divisée en différentes collections. <br><br>  Dernier conseil sur la taille du document - <strong>utilisez le champ _id</strong> .  Si vos données ont une clé unique naturelle, mettez-la directement dans le champ id_field.  Même si la clé est composite - utilisez un identifiant composite.  Il est parfaitement indexé.  Il n'y a qu'un petit râteau - si votre marshaller change parfois l'ordre des champs, alors id avec les mêmes valeurs de champ, mais avec un ordre différent sera considéré comme un id différent en termes d'index unique dans MongoDB.  Dans certains cas, cela peut se produire dans Go. <br><br><h2>  Tailles d'index </h2><br>  <strong>L'index stocke une copie des champs qui y sont inclus</strong> .  La taille de l'index est constituée des données indexées.  Si nous essayons d'indexer de grands champs, préparez-vous à ce que la taille de l'index soit grande. <br><br>  Le deuxième moment gonfle fortement les index: les <strong>champs de tableau dans l'index multiplient les autres champs du document dans cet index</strong> .  Soyez prudent avec les grands tableaux dans les documents: ne pas indexer autre chose sur le tableau, ou jouer avec l'ordre dans lequel les champs de l'index sont répertoriés. <br><br>  <strong>L'ordre des champs est important</strong> , <strong>surtout si l'un des champs d'index est un tableau</strong> .  Si les champs diffèrent en cardinalité, et dans un champ le nombre de valeurs possibles est très différent du nombre de valeurs possibles dans un autre, alors il est logique de les construire en augmentant la cardinalité.  <strong>Vous pouvez facilement économiser 50% de la taille de l'index si vous échangez des champs avec une cardinalité différente.</strong>  La permutation des champs peut donner une réduction de taille plus importante. <br><br>  Parfois, lorsque le champ contient une grande valeur, nous n'avons pas besoin de comparer plus ou moins cette valeur, mais plutôt une comparaison claire de l'égalité.  Ensuite, l' <strong>index sur le champ avec un contenu lourd</strong> peut être <strong>remplacé par l'index sur le hachage de ce champ</strong> .  Des copies de hachage seront stockées dans l'index, pas des copies de ces champs. <br><br><h2>  Supprimer des documents </h2><br>  J'ai déjà mentionné que la suppression de documents est une opération désagréable et <strong>il vaut mieux ne pas les supprimer si possible.</strong>  Lors de la conception d'un schéma de données, essayez d'envisager de minimiser la suppression de données individuelles ou de supprimer des collections entières.  ils pourraient être supprimés avec des collections entières.  La suppression de collections est une opération bon marché et la suppression de milliers de documents individuels est une opération difficile. <br><br>  Si vous avez encore besoin de supprimer un grand nombre de documents, assurez-vous d' <strong>effectuer une limitation</strong> , sinon la suppression en masse des documents affectera la latence de lecture et sera désagréable.  C'est particulièrement mauvais pour la latence sur le secondaire. <br><br>  Cela vaut la peine de faire une sorte de «stylo» pour tourner la limitation - il est très difficile de relever le niveau la première fois.  Nous l'avons traversé tellement de fois que la limitation est devinée à partir de la troisième, quatrième fois.  Dans un premier temps, envisagez la possibilité de le resserrer. <br><br>  <strong>Si vous supprimez plus de 30% d'une grande collection, transférez des documents actifs vers la collection voisine</strong> et supprimez l'ancienne collection dans son ensemble.  Il est clair qu'il y a des nuances, car la charge est commutée de l'ancienne à la nouvelle collection, mais changez si possible. <br><br>  Une autre façon de supprimer des documents est l'index <strong>TTL</strong> , qui est un index qui indexe le champ qui contient l'horodatage Mongo, qui contient la date à laquelle le document est mort.  Le moment venu, MongoDB supprimera automatiquement ce document. <br><br>  L'index TTL est pratique, mais <strong>il n'y a pas de limitation dans l'implémentation.</strong>  MongoDB ne se soucie pas de la façon de supprimer ces suppressions.  Si vous essayez de supprimer un million de documents en même temps, vous aurez pendant quelques minutes un cluster inutilisable qui ne traite que de la suppression et rien de plus.  Pour éviter que cela ne se produise, ajoutez un <strong>caractère aléatoire</strong> , <strong>répartissez le TTL</strong> autant que votre logique métier et les effets spéciaux sur la latence le permettent.  Il est impératif d'étaler TTL si vous avez des raisons logiques commerciales naturelles qui concentrent la suppression à un moment donné. <br><br><h2>  Partage </h2><br>  Nous avons essayé de reporter ce moment, mais il est venu - nous devons encore évoluer horizontalement.  Pour MongoDB, c'est un partage. <br><br><blockquote>  Si vous doutez que vous avez besoin de partage, vous n'en avez pas besoin. </blockquote><br>  Le sharding complique la vie d'un développeur et se déroule de différentes manières.  Dans une entreprise, nous l'appelons taxe de partage.  Lorsque nous partitionnons une collection, les <strong>performances spécifiques de la collection diminuent</strong> : MongoDB nécessite un index séparé pour le partitionnement et des paramètres supplémentaires doivent être transmis à la demande afin de pouvoir être exécuté plus efficacement. <br><br>  Certaines choses tranchantes ne fonctionnent tout simplement pas bien.  Par exemple, c'est une mauvaise idée d'utiliser des requêtes avec <code>skip</code> , surtout si vous avez beaucoup de documents.  Vous donnez la commande: «Ignorer 100 000 documents». <br><br>  MongoDB pense de cette façon: «D'abord, deuxième, troisième ... cent millième, allons plus loin.  Et nous le rendrons à l'utilisateur. » <br><br>  Dans une collection non partagée, MongoDB effectuera une opération quelque part en lui-même.  En forme de tesson - elle lit vraiment et envoie tous les 100 000 documents à un proxy de partitionnement - en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>mongos</u></a> , qui déjà de son côté filtreront et élimineront les 100 000 premiers. Une caractéristique désagréable à garder à l'esprit. <br><br>  <strong>Le code deviendra certainement plus compliqué avec le partitionnement - vous devrez</strong> faire glisser la clé de partitionnement à de nombreux endroits.  Ce n'est pas toujours pratique et pas toujours possible.  Certaines requêtes iront soit en diffusion soit en multidiffusion, ce qui n'ajoute pas non plus l'évolutivité.  Venez au choix d'une clé par laquelle le sharding sera plus précis. <br><br>  <strong>Dans les collections de fragments, l'opération de <code>count</code> interrompue</strong> .  Elle commence à rendre un numéro de plus qu'en réalité - elle peut mentir 2 fois.  La raison réside dans le processus d'équilibrage, lorsque les documents sont versés d'un fragment à l'autre.  Lorsque les documents ont été versés sur le fragment voisin, mais n'ont pas encore été supprimés sur celui d'origine, le <code>count</code> quand même.  Les développeurs de MongoDB n'appellent pas cela un bug - c'est une telle fonctionnalité.  Je ne sais pas s'ils vont le réparer ou non. <br><br>  <strong>Un cluster mélangé est beaucoup plus difficile à administrer</strong> .  Devops cessera de vous accueillir, car le processus de suppression d'une sauvegarde devient radicalement plus compliqué.  Lors du partage, le besoin d'automatisation de l'infrastructure clignote comme une alarme incendie - quelque chose que vous auriez pu faire sans auparavant. <br><br><h3>  Fonctionnement du partage dans MongoDB </h3><br>  Il y a une collection, nous voulons en quelque sorte la disperser autour des éclats.  Pour ce faire, <strong>MongoDB divise la collection en morceaux</strong> à l'aide de la clé de <strong>partition</strong> , en essayant de les diviser en morceaux égaux dans l'espace de clé de partition.  Vient ensuite l'équilibreur, qui présente avec diligence <strong>ces morceaux en fonction des fragments du cluster</strong> .  De plus, l'équilibreur ne se soucie pas du poids de ces morceaux et du nombre de documents qu'ils contiennent, car l'équilibrage se fait pièce par pièce. <br><br><h2>  Clé de partitionnement </h2><br>  Décidez-vous toujours quoi tailler?  Eh bien, la première question est de savoir comment choisir une clé de partitionnement.  Une bonne clé a plusieurs paramètres: <strong>cardinalité élevée</strong> , <strong>non-stabilité</strong> et elle <strong>s'adapte bien aux demandes fréquentes</strong> . <br><br>  Le choix naturel d'une clé de partitionnement est la clé primaire - le champ id.  Si le champ id convient pour le partitionnement, il est préférable de le scinder directement dessus.  C'est un excellent choix - il a une bonne cardinalité, il n'est pas stable, mais sa capacité à répondre aux demandes fréquentes est la spécificité de votre entreprise.  Tirez parti de votre situation. <br><br>  Je vais donner un exemple d'une clé de partitionnement échouée.  J'ai déjà mentionné la collection de traductions - traductions.  Il a un champ de langue qui stocke la langue.  Par exemple, la collection prend en charge 100 langues et nous partageons la langue.  C'est mauvais - cardinalité, le nombre de valeurs possibles n'est que de 100 pièces, ce qui est petit.  Mais ce n'est pas le pire - la cardinalité suffit peut-être à ces fins.  Pire, dès que nous avons parcouru la langue, nous découvrons immédiatement que nous avons 3 fois plus d'utilisateurs anglophones que les autres.  Trois fois plus de demandes parviennent au fragment malheureux dans lequel se trouve l'anglais qu'à toutes les autres combinées. <br><br>  Par conséquent, il convient de garder à l'esprit que parfois une clé d'éclat tend naturellement vers une répartition de charge inégale. <br><br><h3>  Équilibrage </h3><br>  Nous en venons au partage lorsque le besoin a mûri pour nous - notre cluster MongoDB craque, craque avec ses disques, son processeur - avec tout ce que nous pouvons.  Où aller?  Nulle part, et nous mélangeons héroïquement les talons des collections.  Nous scindons, lançons et découvrons soudain que l' <strong>équilibrage n'est pas gratuit</strong> . <br><br>  L'équilibrage passe par plusieurs étapes.  L'équilibreur choisit des morceaux et des éclats, d'où et où il sera transféré.  Le travail se déroule en deux phases: tout d'abord, les <strong>documents sont copiés</strong> de la source vers la cible, puis les documents qui ont été copiés <strong>sont supprimés</strong> . <br><br>  Notre éclat est surchargé, il contient toutes les collections, mais la première partie de l'opération lui est facile.  Mais le second - le retrait - est assez désagréable, car il mettra un éclat sur les omoplates et souffrira déjà sous charge. <br><br>  Le problème est aggravé par le fait que si nous équilibrons beaucoup de morceaux, par exemple des milliers, puis avec les paramètres par défaut, tous ces morceaux sont d'abord copiés, puis un dissolvant entre et commence à les supprimer en bloc.  À ce stade, la procédure n'est plus affectée et vous n'avez qu'à regarder tristement ce qui se passe. <br><br>  Par conséquent, si vous approchez de l'éclatement d'un cluster surchargé, vous devez planifier, car l' <strong>équilibrage prend du temps.</strong>  Il est conseillé de prendre ce temps non pas en prime time, mais en période de faible charge.  Balancer - une pièce détachée déconnectée.  Vous pouvez aborder l'équilibrage principal en mode manuel, éteindre l'équilibreur en prime time et l'activer lorsque la charge a diminué pour vous permettre davantage. <br><br>  Si les capacités du cloud vous permettent toujours de vous adapter verticalement, il est préférable d’améliorer à l’avance la source des fragments afin de réduire légèrement tous ces effets spéciaux. <br><br>  <b>Le sharding doit être soigneusement préparé.</b> <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HighLoad ++ Siberia 2019</a> arrivera à Novossibirsk les 24 et 25 juin.  HighLoad ++ Siberia est une opportunité pour les développeurs de Sibérie d'écouter des rapports, de parler de sujets très chargés et de plonger dans l'environnement "où tout le monde a le sien", sans avoir à parcourir plus de trois mille kilomètres à Moscou ou à Saint-Pétersbourg.  Sur les 80 demandes, le Comité du programme en a approuvé 25 et nous parlons de tous les autres changements dans le programme, des annonces de rapports et d'autres nouvelles dans notre liste de diffusion.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Abonnez-vous</a> pour rester informé. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454748/">https://habr.com/ru/post/fr454748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454736/index.html">Prise en charge de Visual Studio 2019 dans PVS-Studio</a></li>
<li><a href="../fr454738/index.html">Prise en charge de Visual Studio 2019 dans PVS-Studio</a></li>
<li><a href="../fr454740/index.html">Mai 2019 Joomla Digest</a></li>
<li><a href="../fr454742/index.html">Au moins une astuce Vim que vous ne connaissiez pas</a></li>
<li><a href="../fr454744/index.html">Présentation des rapports de suivi Java de la conférence RigaDevDays</a></li>
<li><a href="../fr454750/index.html">Swift UI - galoper à travers l'Europe</a></li>
<li><a href="../fr454754/index.html">Quand vaut-il la peine de vérifier l'hypothèse d'une efficacité non moindre?</a></li>
<li><a href="../fr454756/index.html">Vérification de l'efficacité du site et des paramètres publicitaires, du coût pour attirer les clients du grossiste</a></li>
<li><a href="../fr454758/index.html">Se déplacer dans Windows Defender à moindre coût et joyeusement: masquer Mimikatz</a></li>
<li><a href="../fr454760/index.html">Mémoire Intel Optane M15 - Plus rapide que M10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>