<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèº üö° üç∞ Reactor, WebFlux, Kotlin Coroutines ou Asynchrony avec un exemple simple üë©üèº‚Äçü§ù‚Äçüë®üèΩ üßö üéà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreux services dans le monde moderne, pour la plupart, ¬´ne font rien¬ª. Leurs t√¢ches sont r√©duites aux demandes d'autres bases de donn√©es / servi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reactor, WebFlux, Kotlin Coroutines ou Asynchrony avec un exemple simple</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/477052/"><img src="https://habrastorage.org/webt/oc/vm/jy/ocvmjybd42pjwnaqjaxeyz_dxlo.png"><br><br><p>  De nombreux services dans le monde moderne, pour la plupart, ¬´ne font rien¬ª.  Leurs t√¢ches sont r√©duites aux demandes d'autres bases de donn√©es / services / caches et √† l'agr√©gation de toutes ces donn√©es selon diff√©rentes r√®gles et diff√©rentes logiques m√©tier.  Par cons√©quent, il n'est pas surprenant que des langues telles que Golang apparaissent, avec un syst√®me comp√©titif int√©gr√© pratique qui facilite l'organisation du code non bloquant. </p><br><p>  Dans le monde JVM, les choses sont un peu plus compliqu√©es.  Il existe un grand nombre de frameworks et de biblioth√®ques qui bloquent les threads lorsqu'ils sont utilis√©s.  Donc, stdlib lui-m√™me peut parfois faire la m√™me chose.  Et √† Java, il n'y a pas de m√©canisme similaire √† celui des goroutins √† Golang. </p><br><p>  N√©anmoins, la JVM se d√©veloppe activement et de nouvelles opportunit√©s int√©ressantes apparaissent.  Il y a Kotlin avec des coroutines, qui dans leur utilisation sont tr√®s similaires aux goroutines Gorang (bien qu'elles soient impl√©ment√©es d'une mani√®re compl√®tement diff√©rente).  Il y a JEP Loom, qui apportera des fibres √† la JVM √† l'avenir.  L'un des frameworks Web les plus populaires - Spring - a r√©cemment ajout√© la possibilit√© de cr√©er des services totalement non bloquants sur Webflux.  Et avec la r√©cente version de Spring boot 2.2, l'int√©gration avec Kotlin est encore meilleure. </p><br><p>  Je propose, en utilisant l'exemple d'un petit service de transfert d'argent d'une carte √† une autre, d'√©crire une application sur Spring boot 2.2 et Kotlin pour int√©gration avec plusieurs services externes. </p><a name="habracut"></a><br><p>  C'est bien si vous connaissez d√©j√† Java, Kotlin, Gradle, Spring, Spring boot 2, Reactor, Web <s>flux, Tomcat, Netty, Kotlin oroutines, Gradle Kotlin DSL ou m√™me si vous avez un doctorat.</s>  Mais sinon, cela n'a pas d'importance.  Le code sera simplifi√© au maximum, et m√™me si vous n'√™tes pas du monde JVM, j'esp√®re que vous comprendrez tout. </p><br><p>  Si vous pr√©voyez d'√©crire un service vous-m√™me, assurez-vous que tout ce dont vous avez besoin est install√©: </p><br><ul><li>  Java 8+ </li><li>  Docker et Docker Compose; </li><li>  cURL et de pr√©f√©rence <a href="https://stedolan.github.io/jq/download/">jq</a> ; </li><li>  Git </li><li>  de pr√©f√©rence un IDE pour Kotlin (Intellij Idea, Eclipse, VS, <s>vim</s> , etc.).  Mais c'est possible dans un cahier. </li></ul><br><p>  Les exemples contiendront √† la fois des blancs pour l'impl√©mentation dans le service et une impl√©mentation d√©j√† √©crite.  Tout d'abord, ex√©cutez l'installation et l'assemblage et examinez de plus pr√®s les services et leurs API. </p><br><blockquote> L'exemple des services et de l'API lui-m√™me est fourni √† des fins d'illustration uniquement; ne transf√©rez pas tous <code>AS IS</code> √† votre produit! </blockquote><p>  Tout d'abord, nous clonons le r√©f√©rentiel avec des services pour nous-m√™mes, l'int√©gration avec laquelle nous le ferons, et allons dans le r√©pertoire: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/spring-demo-services &amp;&amp; cd spring-demo-services</code> </pre> <br><p>  Dans un terminal s√©par√©, nous collectons toutes les applications en utilisant <code>gradle</code> , o√π apr√®s une construction r√©ussie, tous les services seront lanc√©s en utilisant <code>docker-compose</code> . </p><br><pre> <code class="plaintext hljs">./gradlew build &amp;&amp; docker-compose up</code> </pre> <br><p>  Pendant que tout est t√©l√©charg√© et install√©, envisagez un projet avec des services. </p><br><img src="https://habrastorage.org/webt/go/mp/mb/gompmbrgtjwsuz9pnpbaxbuksg8.png"><br><p>  Une demande avec un token, des num√©ros de carte √† transf√©rer et le montant √† transf√©rer entre les cartes sera re√ßue √† l'entr√©e du service (service de d√©monstration): </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"authToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"auth-token1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardFrom"</span></span>: <span class="hljs-string"><span class="hljs-string">"55593478"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardTo"</span></span>: <span class="hljs-string"><span class="hljs-string">"55592020"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"amount"</span></span>: <span class="hljs-string"><span class="hljs-string">"10.1"</span></span> }</code> </pre> <br><p>  Selon le jeton <code>authToken</code> , <code>authToken</code> devez acc√©der au service <code>AUTH</code> et obtenir <code>userId</code> , avec lequel vous pouvez ensuite faire une demande √† <code>USER</code> et extraire toutes les informations suppl√©mentaires sur l'utilisateur.  <code>AUTH</code> retournera √©galement des informations sur lequel des trois services nous pouvons acc√©der.  Exemple de r√©ponse de <code>AUTH</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"userId"</span></span>: <span class="hljs-number"><span class="hljs-number">158</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"paymentAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"userAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Pour transf√©rer entre les cartes, allez d'abord avec chaque num√©ro de carte dans la <code>CARD</code> .  En r√©ponse aux demandes, nous recevrons <code>cardId</code> , puis avec eux nous envoyons une demande au <code>PAYMENT</code> et effectuons un virement.  Et le dernier - une fois de plus, nous envoyons une demande au <code>PAYMENT</code> avec <code>fromCardId</code> et d√©couvrons le solde actuel. </p><br><p>  Pour √©muler un petit retard dans les services, la valeur de la variable d'environnement TIMEOUT est lanc√©e dans tous les conteneurs, dans lesquels le d√©lai de r√©ponse est d√©fini en millisecondes.  Et pour diversifier les r√©ponses de <code>AUTH</code> , il est possible de faire varier la valeur de <code>SUCCESS_RATE</code> , qui contr√¥le la probabilit√© d'une <code>true</code> r√©ponse pour le service. </p><br><p>  Fichier Docker-compose.yaml: </p><br><pre> <code class="plaintext hljs">version: '3' services: service-auth: build: service-auth image: service-auth:1.0.0 environment: - SUCCESS_RATE=1.0 - TIMEOUT=100 ports: - "8081:8080" service-card: build: service-card image: service-card:1.0.0 environment: - TIMEOUT=100 ports: - "8082:8080" service-payment: build: service-payment image: service-payment:1.0.0 environment: - TIMEOUT=100 ports: - "8083:8080" service-user: build: service-user image: service-user:1.0.0 environment: - TIMEOUT=100 ports: - "8084:8080"</code> </pre> <br><p>  Pour tous les services, la redirection de port de 8081 √† 8084 est effectu√©e pour les atteindre directement directement. </p><br><p>  Passons maintenant √† l'√©criture du <code>Demo service</code> .  Tout d'abord, essayons d'√©crire l'impl√©mentation aussi maladroite que possible, sans asynchronie et simultan√©it√©.  Pour ce faire, prenez Spring boot 2.2.1, Kotlin et un blanc pour le service.  Nous clonons le r√©f√©rentiel et passons √† la branche <code>spring-mvc-start</code> : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/demo-service &amp;&amp; cd demo-service &amp;&amp; git checkout spring-mvc-start</code> </pre> <br><p>  Acc√©dez au fichier <code>demo.Controller</code> .  Il poss√®de la seule m√©thode <code>processRequest</code> vide pour laquelle une impl√©mentation doit √™tre √©crite. </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { .. }</code> </pre> <br><p>  Une demande de virement entre cartes sera re√ßue √† l'entr√©e de la m√©thode. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceRequest</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authToken: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFrom: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardTo: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: BigDecimal )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pour ceux qui ne connaissent pas le printemps</b> <div class="spoiler_text"><p>  Spring a une DI int√©gr√©e qui fonctionne sur la base d'annotations.  Le DemoController est marqu√© avec l'annotation sp√©ciale <code>RestController</code> : en plus d'enregistrer le bean dans le DI, il ajoute √©galement son traitement en tant que contr√¥leur.  PostProcessor recherche toutes les m√©thodes marqu√©es de l'annotation <code>PostMapping</code> et les ajoute en tant que noeud final pour le service avec la m√©thode <code>POST</code> . </p><br><p>  Le gestionnaire cr√©e √©galement une classe proxy pour DemoController, dans laquelle tous les arguments n√©cessaires sont pass√©s √† la m√©thode <code>processRequest</code> .  Dans notre cas, ce n'est qu'un argument, marqu√© avec l'annotation <code>@RequestBody</code> .  Par cons√©quent, dans le proxy, cette m√©thode sera appel√©e avec le contenu JSON d√©s√©rialis√© dans la classe <code>ServiceRequest</code> . </p></div></div><br><p>  Pour vous faciliter la t√¢che, toutes les m√©thodes d'int√©gration avec d'autres services ont d√©j√† √©t√© r√©alis√©es, il vous suffit de les connecter correctement.  Il n'y a que cinq m√©thodes, une pour chaque action.  Les appels vers d'autres services eux-m√™mes sont impl√©ment√©s sur l'appel de <strong>blocage</strong> Spring <code>RestTemplate</code> . </p><br><p>  Exemple de m√©thode pour appeler <code>AUTH</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: AuthInfo { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restTemplate.getForEntity(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/{token}"</span></span>, AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">token) .body ?: throw RuntimeException</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"couldn't find user by token='</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">'"</span></span>) }</code> </pre> <br><p>  Passons √† l'impl√©mentation de la m√©thode.  Les commentaires indiquent la proc√©dure et la r√©ponse attendue en sortie: </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-comment"><span class="hljs-comment">//1) get auth info from service by token -&gt; userId //2) find user info by userId from 1. //3) 4) find cards info for each card in serviceRequest // 5) make transaction for known cards by calling sendMoney(id1, id2, amount) // 6) after payment get payment info by fromCardId TODO("return SuccessResponse") // SuccessResponse( // amount = , // userName = , // userSurname = , // userAge = // ) }</span></span></code> </pre> <br><p>  Tout d'abord, nous mettons en ≈ìuvre la m√©thode le plus simplement possible, sans tenir compte du fait <code>AUTH</code> peut nous refuser l'acc√®s √† d'autres services.  Essayez de le faire vous-m√™me.  Lorsqu'il s'av√®re (ou apr√®s le passage √† la branche <code>spring-mvc</code> ), vous pouvez v√©rifier le fonctionnement du service comme suit: </p><br><div class="spoiler">  <b class="spoiler_title">impl√©mentation √† partir de la branche spring-mvc</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = findUser(authInfo.userId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = findCardInfo(serviceRequest.cardFrom) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = findCardInfo(serviceRequest.cardTo) sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = getPaymentInfo(cardFromInfo.cardId) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  D√©marrez le service (√† partir du dossier du service de d√©monstration): </p><br><pre> <code class="plaintext hljs">./gradlew bootRun</code> </pre> <br><p>  Nous envoyons une demande au point final: </p><br><pre> <code class="plaintext hljs">./demo-request.sh</code> </pre> <br><p>  En r√©ponse, nous obtenons quelque chose comme ceci: </p><br><pre> <code class="plaintext hljs">‚ûú demo-service git:(spring-mvc) ‚úó ./demo-request.sh + curl -XPOST http://localhost:8080/ -d @demo-payment-request.json -H 'Content-Type: application/json; charset=UTF-8' + jq . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 182 0 85 100 97 20 23 0:00:04 0:00:04 --:--:-- 23 { "amount": 989.9, "userName": "Vasia", "userSurname": "Pupkin", "userAge": 18, "status": true }</code> </pre> <br><p>  Au total, vous devez effectuer 6 demandes pour mettre en ≈ìuvre le service.  Et √©tant donn√© que chacun d'eux r√©pond avec un retard de 100 ms, le temps total ne peut pas √™tre inf√©rieur √† 600 ms.  En r√©alit√©, il s'av√®re environ 700 ms, en tenant compte de tous les frais g√©n√©raux.  Jusqu'√† pr√©sent, le code est assez simple, et si nous voulons maintenant ajouter une v√©rification de r√©ponse <code>AUTH</code> pour acc√©der √† d'autres services, cela ne sera pas difficile √† faire (comme tout autre refactoring). </p><br><p>  Mais r√©fl√©chissons √† la fa√ßon dont vous pouvez acc√©l√©rer l'ex√©cution des requ√™tes.  Si vous ne prenez pas en compte la v√©rification de la r√©ponse de <code>AUTH</code> , alors nous avons 2 t√¢ches ind√©pendantes: </p><br><ul><li>  obtenir l' <code>userId</code> et demander des donn√©es √† l' <code>USER</code> ; </li><li>  recevoir <code>cardId</code> pour chaque carte, effectuer un paiement et recevoir le montant total. </li></ul><br><p>  Ces t√¢ches peuvent √™tre effectu√©es ind√©pendamment les unes des autres.  Ensuite, le temps d'ex√©cution total d√©pendra de la plus longue cha√Æne d'appels (dans ce cas, le second) et sera ex√©cut√© au total pendant 300 ms + X ms de surcharge. </p><br><p>  √âtant donn√© que les appels eux-m√™mes bloquent, la seule fa√ßon d'ex√©cuter des requ√™tes parall√®les est de les ex√©cuter sur des threads s√©par√©s.  Vous pouvez cr√©er un thread s√©par√© pour chaque appel, mais cela co√ªtera tr√®s cher.  Une autre fa√ßon consiste √† ex√©cuter des t√¢ches sur ThreadPool.  √Ä premi√®re vue, une telle solution semble appropri√©e et le temps va vraiment diminuer.  Par exemple, nous pouvons ex√©cuter des requ√™tes sur CompletableFuture.  Il vous permet d'ex√©cuter des t√¢ches en arri√®re-plan en appelant des m√©thodes avec le suffixe <code>async</code> .  Et si vous ne sp√©cifiez pas de ThreadPool sp√©cifique lors de l'appel de m√©thodes, les t√¢ches seront lanc√©es sur <code>ForkJoinPool.commonPool()</code> .  Essayez d'√©crire une impl√©mentation vous-m√™me ou acc√©dez √† la branche <code>spring-mvc-async</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation √† partir de la branche spring-mvc-async</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfoFuture = CompletableFuture.supplyAsync { getAuthInfo(serviceRequest.authToken) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoFuture = authInfoFuture.thenApplyAsync { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> waitAll = CompletableFuture.allOf(cardFromInfo, cardToInfo) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoFuture = waitAll .thenApplyAsync { sendMoney(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, cardToInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, serviceRequest.amount) } .thenApplyAsync { getPaymentInfo(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Si nous mesurons maintenant le temps de requ√™te, il sera de l'ordre de 360 ‚Äã‚Äãms.  Par rapport √† la version originale, le temps total a diminu√© de pr√®s de 2 fois.  Le code lui-m√™me est devenu un peu plus compliqu√©, mais jusqu'√† pr√©sent, il n'est toujours pas difficile de le modifier.  Et si ici nous voulons ajouter un contr√¥le de r√©ponse d' <code>AUTH</code> , alors ce n'est pas difficile. </p><br><p>  Mais que faire si nous avons un grand nombre de demandes entrantes pour le service lui-m√™me?  Dites environ 1000 demandes simultan√©es?  Avec cette approche, il s'av√®re assez rapidement que tous les threads ThreadPool sont occup√©s √† effectuer des appels de blocage.  Et nous arrivons √† la conclusion que la version actuelle ne convient pas non plus. </p><br><p>  Il ne reste plus qu'√† faire quelque chose avec les appels de service eux-m√™mes.  Vous pouvez modifier les requ√™tes et les rendre non bloquantes.  Ensuite, les m√©thodes d'appel des services renverront CompletableFuture, Flux, Observable, Deferred, Promise ou un objet similaire sur lequel construire une cha√Æne d'attentes.  Avec cette approche, nous n'avons pas besoin de faire des appels sur des flux s√©par√©s - il suffira d'en avoir un (ou au moins un petit pool s√©par√© de flux) que nous avons d√©j√† emprunt√© pour traiter les demandes. </p><br><p>  Pouvons-nous maintenant supporter la lourde charge du service?  Pour r√©pondre √† cette question, examinez de pr√®s Tomcat, qui est utilis√© dans Spring boot 2.2.1 dans le starter <code>org.springframework.boot:spring-boot-starter-web</code> .  Il est construit de sorte qu'un thread de ThreadPool est allou√© pour chaque demande entrante pour son traitement.  Et en l'absence de flux libres, les nouvelles demandes deviendront une ¬´file d'attente¬ª d'attente.  Mais notre service lui-m√™me envoie uniquement des demandes √† d'autres services.  Allouer un flux entier en dessous et le bloquer jusqu'√† ce que les r√©ponses de tout le monde arrivent, semble, pour le dire doucement, superflu. </p><br><p>  Heureusement, Spring a r√©cemment permis d'utiliser un serveur Web non bloquant bas√© sur Netty ou Undertow.  Pour ce faire, il vous suffit de remplacer le <code>spring-boot-starter-web</code> <code>spring-boot-starter-webflux</code> et de modifier l√©g√®rement la m√©thode de traitement des demandes dans laquelle la demande et la r√©ponse seront "encapsul√©es" en Mono.  Cela est d√ª au fait que Webflux est construit sur la base de Reactor, et donc maintenant dans la m√©thode dont vous avez besoin pour construire une cha√Æne de transformations mono. <br></p><p>  Essayez d'√©crire votre propre impl√©mentation non bloquante de la m√©thode.  Pour ce faire, acc√©dez √† la branche <code>spring-webflux-start</code> .  Veuillez noter que le d√©marreur de Spring Boot a chang√©, o√π la version avec Webflux est maintenant utilis√©e, et l'impl√©mentation des demandes √† d'autres services qui ont √©t√© r√©√©crites pour utiliser <code>WebClient</code> non bloquant a √©galement chang√©. </p><br><p>  Exemple de m√©thode pour appeler AUTH: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Mono&lt;AuthInfo&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebClient.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() .uri(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">"</span></span>) .retrieve() .bodyToMono(AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  L'impl√©mentation du premier exemple est ins√©r√©e dans le contenu de la m√©thode <code>processRequest</code> dans un commentaire.  Essayez de le r√©√©crire vous-m√™me sur Reactor.  Comme la derni√®re fois, faites d'abord la version sans prendre en compte les ch√®ques d' <code>AUTH</code> , puis voyez comme il est difficile de les ajouter: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-comment"><span class="hljs-comment">// val authInfo = getAuthInfo(serviceRequest.authToken) // // val userInfo = findUser(authInfo.userId) // // val cardFromInfo = findCardInfo(serviceRequest.cardFrom) // val cardToInfo = findCardInfo(serviceRequest.cardTo) // // sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) // // val paymentInfo = getPaymentInfo(cardFromInfo.cardId) // // log.info("result") // // return SuccessResponse( // amount = paymentInfo.currentAmount, // userName = userInfo.name, // userSurname = userInfo.surname, // userAge = userInfo.age // ) TODO() }</span></span></code> </pre> <br><p>  Apr√®s avoir trait√© cela, vous pouvez comparer avec mon impl√©mentation de la <code>spring-webflux</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation √† partir de la branche spring-webflux</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cacheRequest = serviceRequest.cache() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoMono = cacheRequest.flatMap { getAuthInfo(it.authToken) }.flatMap { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoMono = cacheRequest.flatMap { findCardInfo(it.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoMono = cacheRequest.flatMap { findCardInfo(it.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoMono = cardFromInfoMono.zipWith(cardToInfoMono) .flatMap { (cardFromInfo, cardToInfo) -&gt; cacheRequest.flatMap { request -&gt; sendMoney(cardFromInfo.cardId, cardToInfo.cardId, request.amount).map { cardFromInfo } } }.flatMap { getPaymentInfo(it.cardId) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userInfoMono.zipWith(paymentInfoMono) .map { (userInfo, paymentInfo) -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) } }</code> </pre> </div></div><br><p>  Convenez que l'√©criture d'une impl√©mentation (par rapport √† l'approche de blocage pr√©c√©dente) est devenue plus difficile.  Et si nous voulons ajouter des ch√®ques ¬´oubli√©s¬ª d' <code>AUTH</code> , ce ne sera pas si facile √† faire. </p><br><p>  C'est l'essence m√™me de l'approche r√©active.  Il est id√©al pour construire des cha√Ænes de transformation non ramifi√©es.  Mais si la ramification appara√Æt, le code n'est plus aussi simple. </p><br><p>  Les coroutines Kotlin, qui sont tr√®s amicales avec n'importe quel code asynchrone / r√©actif, peuvent vous aider ici.  De plus, il existe un grand nombre de wrappers √©crits pour <a href="">Reactor</a> , <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">CompletableFuture</a> , etc.  Mais m√™me si vous ne trouvez pas le bon, vous pouvez toujours l'√©crire vous-m√™me, en utilisant des <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html">constructeurs</a> sp√©ciaux. </p><br><p>  R√©√©crivons nous-m√™mes l'impl√©mentation sur les coroutines.  Pour ce faire, acc√©dez √† la branche <code>spring-webflux-coroutines-start</code> .  Les d√©pendances n√©cessaires y sont ajout√©es dans build.gradle.kts: </p><br><pre> <code class="kotlin hljs">implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-core:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactive:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactor:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Et la m√©thode <code>processRequest</code> change un <code>processRequest</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { <span class="hljs-comment"><span class="hljs-comment">//TODO() }</span></span></code> </pre> <br><p>  Il n'a plus besoin de Mono et se traduit simplement en une fonction de suspension (gr√¢ce √† l'int√©gration de Spring et Kotlin).  √âtant donn√© que nous allons cr√©er des coroutines suppl√©mentaires dans la m√©thode, nous devrons cr√©er un <code>coroutineScope</code> scout enfant (pour comprendre les raisons de la cr√©ation d'une √©tendue suppl√©mentaire, voir le post de Roman Elizarov sur <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">la concurrence structur√©e</a> ).  Veuillez noter que les autres appels de service n'ont pas chang√© du tout.  Ils renvoient le m√™me Mono sur lequel la m√©thode de <code>suspend</code> waitFirst peut √™tre appel√©e pour ¬´attendre¬ª le r√©sultat de la requ√™te. </p><br><p>  Si les coroutines sont encore un nouveau concept pour vous, alors il y a un merveilleux <a href="">guide</a> avec une description d√©taill√©e.  Essayez d'√©crire votre propre impl√©mentation de la m√©thode <code>processRequest</code> ou acc√©dez √† la branche <code>spring-webflux-coroutines</code> : </p><br><div class="spoiler">  <b class="spoiler_title">impl√©mentation √† partir de la branche spring-webflux-coroutines</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { log.info(<span class="hljs-string"><span class="hljs-string">"start"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken).awaitFirst() findUser(authInfo.userId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoDeferred = async { findCardInfo(serviceRequest.cardFrom).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoDeferred = async { findCardInfo(serviceRequest.cardTo).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = cardFromInfoDeferred.await() sendMoney(cardFromInfo.cardId, cardToInfoDeferred.await().cardId, serviceRequest.amount).awaitFirst() getPaymentInfo(cardFromInfo.cardId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoDeferred.await() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoDeferred.await() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Vous pouvez comparer le code avec l'approche r√©active.  Avec les coroutines, vous n'avez pas besoin de r√©fl√©chir √† l'avance √† tous les points de branchement.  Nous pouvons simplement appeler les m√©thodes d' <code>await</code> et d√©river les t√¢ches asynchrones dans <code>async</code> aux bons endroits.  Le code reste aussi similaire que possible √† la version originale simple, qui n'est pas du tout difficile √† modifier.  Et un facteur important est que les coroutines sont simplement int√©gr√©es dans du code r√©actif. </p><br><p>  Vous aimerez peut-√™tre m√™me davantage l'approche r√©active pour cette t√¢che, mais la plupart des personnes interrog√©es la trouvent plus difficile.  En g√©n√©ral, les deux approches r√©solvent leur probl√®me et vous pouvez utiliser celle que vous aimez.  Soit dit en passant, r√©cemment √† Kotlin, il est √©galement possible de cr√©er des coroutines ¬´froides¬ª avec Flow, qui sont tr√®s similaires √† Reactor.  Certes, ils sont encore au stade exp√©rimental, mais maintenant vous pouvez regarder l'impl√©mentation actuelle et l'essayer dans votre code. </p><br><p>  Je veux terminer ici et enfin laisser des liens utiles: </p><br><ul><li>  <a href="">Guide de voyage Coroutine</a> </li><li>  <a href="">R√©acteur Coroutines</a> </li><li>  <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">Coroutines CompletableFuture</a> </li><li>  <a href="https://www.youtube.com/results%3Fsearch_query%3D%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B2%2B%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%2B%25D0%25BA%25D0%25BE%25D1%2580%25D1%2583%25D1%2582%25D0%25B8%25D0%25BD%25D1%258B">Roman Elizarov sur les coroutines</a> </li><li>  <a href="https://medium.com/%40elizarov/kotlin-flows-and-coroutines-256260fb3bdb">Flux de Kotlin et coroutines</a> </li><li>  <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">Concurrence structur√©e</a> </li><li>  <a href="https://blog.karumi.com/spring-boot-loves-kotlin/">La botte de printemps aime Kotlin</a> </li></ul><br><p>  J'esp√®re que vous √©tiez int√©ress√© et que vous avez r√©ussi √† √©crire vous-m√™me une impl√©mentation de la m√©thode pour toutes les m√©thodes.  Et, bien s√ªr, je veux croire que vous aimez plus l'option avec les coroutines =) </p><br><p>  Merci √† tous ceux qui ont lu jusqu'au bout! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477052/">https://habr.com/ru/post/fr477052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477042/index.html">Optimisation de la strat√©gie de blackjack de Monte Carlo</a></li>
<li><a href="../fr477044/index.html">Automatisation des tests End-2-End d'un syst√®me d'information int√©gr√©. Partie 2. Technique</a></li>
<li><a href="../fr477046/index.html">Meetup .Net √† Raiffeisenbank 28/11 + Broadcast</a></li>
<li><a href="../fr477048/index.html">Pourquoi une entreprise avec une capitalisation de 55 milliards de dollars a-t-elle pens√© quitter la bourse</a></li>
<li><a href="../fr477050/index.html">Black Friday 2019 pour la vid√©osurveillance et les nuages.</a></li>
<li><a href="../fr477054/index.html">Webasto annonce un syst√®me de batterie automobile modulaire</a></li>
<li><a href="../fr477058/index.html">Enterprise Agile Russia √† Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../fr477060/index.html">DataArt accueillera une conf√©rence ouverte d'Andrei Terekhov, chef du d√©partement de programmation syst√®me, Matmekh, Universit√© d'√âtat de Saint-P√©tersbourg</a></li>
<li><a href="../fr477062/index.html">Fonctionnement du compilateur d'optimisation</a></li>
<li><a href="../fr477072/index.html">D√©veloppement client ou comment lancer un produit sans √©chec?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>