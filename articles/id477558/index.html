<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏿 🦆 👩🏼‍💼 Huawei Cloud: Berawan di PVS-Studio Hari Ini 🥂 🕺🏼 😟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini semua orang tahu tentang layanan cloud. Banyak perusahaan telah memecahkan segmen pasar ini dan menciptakan layanan cloud mereka sendiri dari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Huawei Cloud: Berawan di PVS-Studio Hari Ini</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477558/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ac/bd2/47b/2acbd247b999e7f8e9e45f77181e2f06.png" alt="Gambar 2"></div><br>  Saat ini semua orang tahu tentang layanan cloud.  Banyak perusahaan telah memecahkan segmen pasar ini dan menciptakan layanan cloud mereka sendiri dari berbagai tujuan.  Baru-baru ini tim kami juga tertarik dengan layanan ini dalam hal mengintegrasikan penganalisa kode PVS-Studio ke dalamnya.  Kemungkinannya, pembaca reguler kami sudah menebak jenis proyek apa yang akan kami periksa kali ini.  Pilihannya jatuh pada kode layanan cloud Huawei. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Jika Anda mengikuti posting tim PVS-Studio, Anda mungkin memperhatikan bahwa kami telah menggali jauh dalam teknologi cloud belakangan ini.  Kami telah menerbitkan beberapa artikel yang membahas topik ini: <br><br><ul><li>  <a href="https://www.viva64.com/en/b/0670/">PVS-Studio di Awan: Azure DevOps</a> </li><li>  <a href="https://www.viva64.com/en/b/0636/">PVS-Studio di Awan: Travis CI</a> </li><li>  <a href="https://www.viva64.com/en/b/0676/">PVS-Studio di Awan: CircleCI</a> </li><li>  <a href="https://www.viva64.com/en/b/0686/">PVS-Studio di Awan: GitLab CI / CD</a> </li></ul><br>  Tepat ketika saya sedang mencari proyek yang tidak biasa untuk artikel yang akan datang, saya mendapat email dengan tawaran pekerjaan dari <a href="https://www.huawei.com/en/">Huawei</a> .  Setelah mengumpulkan beberapa informasi tentang perusahaan ini, ternyata mereka memiliki layanan cloud sendiri, tetapi yang utama adalah bahwa kode sumber layanan ini tersedia di GitHub.  Ini adalah alasan utama untuk memilih perusahaan ini untuk artikel ini.  Seperti kata seorang bijak Tiongkok: "Kecelakaan itu bukan karena kecelakaan." <br><br>  Biarkan saya memberi Anda beberapa detail tentang analisa kami.  PVS-Studio adalah penganalisa statis untuk deteksi bug dalam kode sumber program, ditulis dalam C, C ++, C #, dan Java.  Penganalisa bekerja pada Windows, Linux, dan macOS.  Selain plugin untuk lingkungan pengembangan klasik, seperti Visual Studio atau IntelliJ IDEA, penganalisa memiliki kemampuan untuk berintegrasi ke SonarQube dan Jenkins: <br><br><ul><li>  <a href="https://www.viva64.com/en/m/0037/">Integrasi hasil analisis PVS-Studio ke SonarQube</a> </li><li>  <a href="https://www.viva64.com/en/m/0048/">PVS-Studio berjalan di Jenkins</a> </li></ul><br><h2>  Analisis proyek </h2><br>  Ketika saya sedang melakukan riset untuk artikel tersebut, saya menemukan bahwa Huawei memiliki <a href="https://developer.huaweicloud.com/en-us">pusat pengembang</a> dengan informasi, manual, dan sumber layanan cloud yang tersedia.  Berbagai macam bahasa pemrograman digunakan untuk membuat layanan ini, tetapi bahasa seperti Go, Java dan Python adalah yang paling umum. <br><br>  Sejak saya berspesialisasi di Jawa, proyek-proyek telah dipilih sesuai dengan pengetahuan dan keterampilan saya.  Anda dapat menganalisis sumber proyek dalam artikel di <a href="https://github.com/huaweicloud/">huaweicloud</a> repositori GitHub. <br><br>  Untuk menganalisis proyek, saya hanya perlu melakukan beberapa hal: <br><br><ul><li>  Dapatkan proyek dari repositori; </li><li>  Gunakan <a href="https://www.viva64.com/en/m/0044/">instruksi</a> penganalisis Java start-up dan jalankan analisis pada setiap proyek. </li></ul><br>  Setelah menganalisis proyek, kami hanya memilih tiga di antaranya, yang ingin kami perhatikan.  Karena ukuran proyek Java yang lain ternyata terlalu kecil. <br><br>  Hasil analisis proyek (jumlah peringatan dan jumlah file): <br><br><ul><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java">huaweicloud-sdk-java</a> : 31 - Tinggi, 2 - Sedang dan 16 - Rendah, 2.700+ file. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-dis-agent">huaweicloud-dis-agent</a> : 7 - Tinggi, 6 - Sedang dan 6 - Rendah, 100+ file. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java-dis">huaweicloud-sdk-java-dis</a> : 15 - Tinggi, 6 - Sedang dan 16 - Rendah, 270+ file. </li></ul><br>  Ada beberapa peringatan, yang memberi tahu kita tentang kode berkualitas tinggi, terlebih lagi karena tidak semua peringatan menunjukkan kesalahan nyata.  Ini disebabkan oleh fakta bahwa penganalisa kadang-kadang kekurangan informasi untuk membedakan kode yang benar dari kode yang salah.  Karena alasan ini, kami mengubah diagnostik penganalisa hari demi hari dengan mencari informasi dari pengguna.  Anda boleh melihat artikel " <a href="https://www.viva64.com/en/b/0488/">Cara analis statis melawan positif palsu, dan mengapa mereka melakukannya</a> ." <br><br>  Saat menganalisis proyek ini, saya hanya mengambil peringatan paling banyak, yang akan saya bicarakan di artikel ini. <br><br><h2>  Urutan inisialisasi bidang </h2><br>  Siklus inisialisasi Kelas <a href="https://www.viva64.com/en/w/v6050/">V6050</a> hadir.  Inisialisasi 'INSTANCE' muncul sebelum inisialisasi 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Jika ada pengecualian dalam konstruktor kelas <i>UntrustedSSL</i> , informasi tentang pengecualian ini dicatat di blok <i>tangkap</i> menggunakan <i>LOG</i> logger.  Namun, karena urutan inisialisasi bidang statis, pada saat inisialisasi bidang <i>INSTANCE</i> , <i>LOG</i> belum diinisialisasi.  Oleh karena itu, jika Anda mencatat informasi tentang pengecualian di konstruktor, itu akan menghasilkan <i>NullPointerException</i> .  Pengecualian ini adalah alasan untuk pengecualian lain <i>ExceptionInInitializerError</i> , yang dilemparkan jika ada pengecualian ketika bidang statis telah diinisialisasi.  Apa yang Anda butuhkan untuk menyelesaikan masalah ini adalah menempatkan inisialisasi <i>LOG</i> sebelum menginisialisasi <i>INSTANCE</i> <i>.</i> <br><br><h2>  Kesalahan ketik yang tidak mencolok </h2><br>  <a href="https://www.viva64.com/en/w/v6005/">V6005</a> Variabel 'this.metricSchema' ditugaskan untuk dirinya sendiri.  OpenTSDBSchema.java (72) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenTSDBSchema</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JsonProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"metric"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SchemaField&gt; metricSchema; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMetricsSchema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;SchemaField&gt; metricsSchema)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.metricSchema = metricSchema; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } public void setMetricSchema(List&lt;SchemaField&gt; metricSchema) { this.metricSchema = metricSchema; } .... }</span></span></code> </pre> <br>  Kedua metode mengatur bidang <i>metricSchema</i> , tetapi nama metode berbeda dengan simbol satu '.  Programmer menamai argumen metode ini sesuai dengan nama metode tersebut.  Akibatnya, di jalur yang ditunjuk oleh penganalisis, bidang metricSchema ditetapkan untuk dirinya sendiri, dan <i>argumen</i> metode <i>metricsSchema</i> tidak digunakan. <br><br>  <a href="https://www.viva64.com/en/w/v6005/">V6005</a> Variabel 'menangguhkan' ditugaskan untuk dirinya sendiri.  SuspendTransferTaskRequest.java (77) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuspendTransferTaskRequest</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> suspend; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ suspend = suspend; } .... }</code> </pre> <br>  Berikut ini adalah kesalahan sepele yang berkaitan dengan kecerobohan, oleh karena itu argumen <i>penangguhan</i> ditugaskan untuk dirinya sendiri.  Akibatnya, bidang yang <i>ditangguhkan</i> tidak akan diberi nilai argumen yang diperoleh sebagaimana tersirat.  Versi yang benar: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspend = suspend; }</code> </pre> <br><h2>  Kondisi yang ditentukan sebelumnya </h2><br>  Seperti yang sering terjadi, aturan <a href="https://www.viva64.com/en/w/v6007/">V6007</a> mendahului dalam hal jumlah peringatan. <br><br>  Ekspresi <a href="https://www.viva64.com/en/w/v6007/">V6007</a> 'firewallPolicyId == null' selalu salah.  FirewallPolicyServiceImpl.java (125) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FirewallPolicy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFirewallRuleFromPolicy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String firewallPolicyId, String firewallRuleId)</span></span></span><span class="hljs-function"> </span></span>{ checkNotNull(firewallPolicyId); checkNotNull(firewallRuleId); checkState(!(firewallPolicyId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; firewallRuleId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-string"><span class="hljs-string">"Either a Firewall Policy or Firewall Rule identifier must be set"</span></span>); .... }</code> </pre> <br>  Dalam metode ini argumen diperiksa untuk <i>null</i> oleh metode <i>checkNotNull</i> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CanIgnoreReturnValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkNotNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T reference)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reference == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre> <br>  Setelah memeriksa argumen dengan metode <i>checkNotNull</i> , Anda dapat 100% yakin bahwa argumen yang diteruskan ke metode ini tidak sama dengan <i>nol</i> .  Karena kedua argumen metode <i>removeFirewallRuleFromPolicy</i> diperiksa oleh metode <i>checkNotNull</i> , pemeriksaan lebih lanjut untuk <i>null</i> tidak masuk akal.  Namun, ekspresi, di mana argumen <i>firewallPolicyId</i> dan <i>firewallRuleId</i> diperiksa ulang untuk <i>null</i> , dilewatkan sebagai argumen pertama ke metode <i>checkState</i> . <br><br>  Peringatan serupa juga dikeluarkan untuk <i>firewallRuleId</i> : <br><br><ul><li>  Ekspresi V6007 'firewallRuleId == null' selalu salah.  FirewallPolicyServiceImpl.java (125) </li></ul><br>  Ekspresi <a href="https://www.viva64.com/en/w/v6007/">V6007</a> 'filteringParams! = Null' selalu benar.  NetworkPolicyServiceImpl.java (60) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Invocation&lt;NetworkServicePolicies&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildInvocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; filteringParams)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> servicePoliciesInvocation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return servicePoliciesInvocation; }</span></span></code> </pre> <br>  Dalam metode ini, jika argumen <i>filteringParams</i> adalah <i>nol</i> , metode mengembalikan nilai.  Inilah sebabnya pemeriksaan yang ditunjukkan oleh penganalisis akan selalu benar yang, pada gilirannya, berarti bahwa pemeriksaan ini tidak ada artinya. <br><br>  13 kelas lebih mirip: <br><br><ul><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  PolicyRuleServiceImpl.java (58) </li><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  GroupServiceImpl.java (58) </li><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  ExternalSegmentServiceImpl.java (57) </li><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  L3policyServiceImpl.java (57) </li><li>  Ekspresi V6007 'filteringParams! = Null' selalu benar.  PolicyRuleSetServiceImpl.java (58) </li><li>  dan seterusnya ... </li></ul><br><h2>  Referensi kosong </h2><br>  <a href="https://www.viva64.com/en/w/v6008/">V6008</a> Potensi null dereference dari 'm.blockDeviceMapping'.  NovaServerCreate.java (390) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServerCreateBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BlockDeviceMappingCreate blockDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blockDevice != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; m.blockDeviceMapping == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { m.blockDeviceMapping = Lists.newArrayList(); } m.blockDeviceMapping.add(blockDevice); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return this; }</span></span></code> </pre> <br>  Dalam metode ini, inisialisasi bidang referensi <i>m.blockDeviceMapping</i> tidak akan terjadi jika argumen <i>blockDevice</i> adalah <i>nol</i> .  Bidang ini diinisialisasi hanya dalam metode ini, jadi ketika memanggil metode <i>add</i> dari bidang <i>m.blockDeviceMapping</i> , <i>NullPointerException</i> akan terjadi. <br><br>  <a href="https://www.viva64.com/en/w/v6008/">V6008</a> Potensi dereferensi nol dari 'FileId.get (path)' dalam fungsi '&lt;init&gt;'.  TrackedFile.java (140), TrackedFile.java (115) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileFlow&lt;?&gt; flow, Path path)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(flow, path, FileId.get(path), ....); }</code> </pre> <br>  Konstruktor kelas <i>TrackedFile</i> menerima hasil dari metode <i>FileId.get (path)</i> statis sebagai argumen ketiga.  Tetapi metode ini dapat mengembalikan <i>nol</i> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FileId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Files.exists(file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } .... }</code> </pre> <br>  Di konstruktor, dipanggil melalui <i>ini</i> , argumen <i>id</i> tidak berubah sampai digunakan pertama kali: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., ...., FileId id, ....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... FileId newId = FileId.get(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!id.equals(newId)) { .... } }</code> </pre> <br>  Seperti yang dapat kita lihat, jika <i>nol</i> dilewatkan sebagai argumen ketiga ke metode, pengecualian akan terjadi. <br><br>  Berikut ini adalah kasus serupa lainnya: <br><br><ul><li>  V6008 Potensi null dereference dari 'buffer'.  PublishingQueue.java (518) </li></ul><br>  <a href="https://www.viva64.com/en/w/v6008/">V6008</a> Potensi null dereference dari 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return ; } } .... }</span></span></code> </pre> <br>  NPE lagi.  Sejumlah pemeriksaan di operator bersyarat memungkinkan objek <i>dataTmpFile</i> nol untuk dereferensi lebih lanjut.  Saya pikir ada dua kesalahan ketik di sini dan cek harus benar-benar terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Substring dan angka negatif </h2><br>  <a href="https://www.viva64.com/en/w/v6009/">V6009</a> Fungsi 'substring' dapat menerima nilai '-1' sementara nilai non-negatif diharapkan.  Periksa argumen: 2. RemoveVersionProjectIdFromURL.java (37) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String url)</span></span></span><span class="hljs-function"> </span></span>{ String urlRmovePojectId = url.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, url.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urlRmovePojectId.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, urlRmovePojectId.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); }</code> </pre> <br>  Implikasinya adalah bahwa metode ini mendapatkan URL sebagai string, yang tidak divalidasi dengan cara apa pun.  Kemudian, string ini terputus beberapa kali menggunakan metode <i>lastIndexOf</i> .  Jika metode <i>lastIndexOf</i> tidak menemukan kecocokan dalam string, itu akan mengembalikan -1.  Ini akan mengarah ke <i>StringIndexOutOfBoundsException</i> , karena argumen metode <i>substring</i> harus berupa angka non-negatif.  Untuk operasi metode yang benar, kita harus menambahkan validasi argumen input atau memeriksa bahwa hasil metode <i>lastIndexOf</i> adalah angka non-negatif. <br><br>  Berikut beberapa cuplikan lainnya dengan cara yang serupa: <br><br><ul><li>  V6009 Fungsi 'substring' dapat menerima nilai '-1' sementara nilai non-negatif diharapkan.  Periksa argumen: 2. RemoveProjectIdFromURL.java (37) </li><li>  V6009 Fungsi 'substring' dapat menerima nilai '-1' sementara nilai non-negatif diharapkan.  Periksa argumen: 2. RemoveVersionProjectIdFromURL.java (38) </li></ul><br><h2>  Hasil yang terlupakan </h2><br>  <a href="https://www.viva64.com/en/w/v6010/">V6010</a> Nilai kembali fungsi 'concat' diperlukan untuk dimanfaatkan.  AKSK.java (278) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildCanonicalHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(URL url)</span></span></span><span class="hljs-function"> </span></span>{ String host = url.getHost(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = url.getPort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host; }</code> </pre> <br>  Saat menulis kode ini, pembuatnya tidak memperhitungkan bahwa pemanggilan metode <i>concat</i> tidak akan mengubah string <i>host</i> karena ketidakmampuan objek tipe <i>String</i> .  Untuk operasi metode yang benar, hasil dari metode <i>concat</i> harus ditetapkan ke variabel <i>host</i> di blok <i>if</i> .  Versi yang benar: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host = host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); }</code> </pre> <br><h2>  Variabel yang tidak digunakan </h2><br>  'URL' <a href="https://www.viva64.com/en/w/v6021/">V6021</a> variabel tidak digunakan.  TriggerV2Service.java (95) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAllTriggersForFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String functionUrn)</span></span></span><span class="hljs-function"> </span></span>{ checkArgument(!Strings.isNullOrEmpty(functionUrn), ....); String url = ClientConstants.FGS_TRIGGERS_V2 + ClientConstants.URI_SEP + functionUrn; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deleteWithResponse(uri(triggersUrlFmt, functionUrn)).execute(); }</code> </pre> <br>  Dalam metode ini, variabel <i>url</i> tidak digunakan setelah inisialisasi.  Kemungkinan besar, variabel <i>url</i> harus diteruskan ke metode <i>uri</i> sebagai argumen kedua alih-alih <i>functionUrn</i> , karena variabel <i>functionUrn</i> mengambil bagian dalam inisialisasi variabel <i>url</i> . <br><br><h2>  Argumen tidak menggunakan konstruktor </h2><br>  <a href="https://www.viva64.com/en/w/v6022/">V6022</a> Parameter 'returnType' tidak digunakan di dalam tubuh konstruktor.  HttpRequest.java (68) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpReQuest</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ .... Class&lt;R&gt; returnType; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., Class&lt;R&gt; returnType)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// &lt;= { this.endpoint = endpoint; this.path = path; this.method = method; this.entity = entity; } .... public Class&lt;R&gt; getReturnType() { return returnType; } .... }</span></span></span></span></code> </pre> <br>  Dalam konstruktor ini, pemrogram lupa untuk menggunakan argumen <i>returnType</i> , dan menetapkan nilainya ke bidang <i>returnType</i> .  Itu sebabnya ketika memanggil metode <i>getReturnType</i> dari objek, dibuat oleh konstruktor ini, <i>null</i> akan dikembalikan secara default.  Tetapi kemungkinan besar, programmer bermaksud untuk mendapatkan objek, yang sebelumnya diteruskan ke konstruktor. <br><br><h2>  Fungsionalitas yang sama </h2><br>  <a href="https://www.viva64.com/en/w/v6032/">V6032</a> Aneh bahwa tubuh metode 'aktifkan' sepenuhnya setara dengan tubuh metode lain 'nonaktifkan'.  ServiceAction.java (32), ServiceAction.java (36) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String binary; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String host; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.binary = binary; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.host = host; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ServiceAction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// &lt;= return new ServiceAction(binary, host); } public static ServiceAction disable(String binary, String host) { // &lt;= return new ServiceAction(binary, host); } .... }</span></span></code> </pre> <br>  Memiliki dua metode yang identik bukanlah kesalahan, tetapi fakta bahwa dua metode melakukan tindakan yang sama setidaknya aneh.  Melihat nama-nama metode di atas, kita dapat mengasumsikan bahwa mereka harus melakukan tindakan yang berlawanan.  Faktanya, kedua metode melakukan hal yang sama - membuat dan mengembalikan objek <i>ServiceAction</i> .  Kemungkinan besar, metode <i>menonaktifkan</i> dibuat dengan menyalin kode metode <i>aktifkan</i> , tetapi tubuh metode tetap sama. <br><br><h2>  Lupa memeriksa hal utama </h2><br>  <a href="https://www.viva64.com/en/w/v6060/">V6060</a> Referensi 'params' digunakan sebelum diverifikasi terhadap nol.  DomainService.java (49), DomainService.java (46) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Domains </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_size"</span></span>), ....); Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_number"</span></span>), ....); Invocation&lt;Domains&gt; domainInvocation = get(Domains.class, uri(<span class="hljs-string"><span class="hljs-string">"/domains"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (params != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return domainInvocation.execute(this.buildExecutionOptions(Domains.class)); }</span></span></code> </pre> <br>  Dalam metode ini, penulis memutuskan untuk memeriksa isi struktur tipe <i>Peta</i> untuk <i>null</i> .  Untuk melakukan ini, metode <i>get</i> dipanggil dua kali dari argumen <i>params</i> .  Hasil dari metode <i>get</i> diteruskan ke metode <i>checkNotNull</i> .  Segalanya tampak logis, tetapi tidak seperti itu!  Argumen <i>params</i> diperiksa untuk <i>null</i> <i>jika</i> .  Setelah ini diharapkan argumen input mungkin <i>nol</i> , tetapi sebelum pemeriksaan ini, metode <i>get</i> sudah dipanggil dua kali dari <i>params.</i>  Jika <i>nol</i> dilewatkan sebagai argumen untuk metode ini, pertama kali Anda memanggil metode <i>get</i> , pengecualian akan dilemparkan. <br><br>  Situasi serupa terjadi di tiga tempat lain: <br><br><ul><li>  V6060 Referensi 'params' digunakan sebelum diverifikasi terhadap nol.  DomainService.java (389), DomainService.java (387) </li><li>  V6060 Referensi 'params' digunakan sebelum diverifikasi terhadap nol.  DomainService.java (372), DomainService.java (369) </li><li>  V6060 Referensi 'params' digunakan sebelum diverifikasi terhadap nol.  DomainService.java (353), DomainService.java (350) </li></ul><br><h2>  Kesimpulan </h2><br>  Perusahaan besar saat ini tidak dapat melakukannya tanpa penggunaan layanan cloud.  Sejumlah besar orang menggunakan layanan ini.  Dalam pandangan ini, bahkan kesalahan kecil dalam suatu layanan dapat menyebabkan masalah bagi banyak orang dan juga kerugian tambahan, yang ditimbulkan oleh perusahaan untuk memperbaiki konsekuensi negatif dari kesalahan ini.  Kelemahan manusia harus selalu diperhitungkan terutama karena cepat atau lambat semua orang melakukan kesalahan, seperti yang dijelaskan dalam artikel ini.  Fakta ini mendukung penggunaan semua alat yang mungkin untuk meningkatkan kualitas kode. <br><br>  PVS-Studio pasti akan memberi tahu perusahaan Huawei tentang hasil pemeriksaan layanan cloud mereka sehingga para pengembang Huawei dapat memikirkannya, karena satu kali penggunaan analisis kode statis yang dicakup oleh artikel ini ( <a href="https://www.viva64.com/en/b/0594/">1</a> , <a href="https://www.viva64.com/en/b/0639/">2</a> ) tidak dapat sepenuhnya menunjukkan semua kelebihannya.  Anda dapat mengunduh penganalisa PVS-Studio di <a href="https://www.viva64.com/en/pvs-studio-download/">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477558/">https://habr.com/ru/post/id477558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477544/index.html">Cara membuat game 2D dengan Python dan perpustakaan arcade</a></li>
<li><a href="../id477548/index.html">Pelajari Bootstrap dengan 10 Tips Berguna</a></li>
<li><a href="../id477550/index.html">SPS-2019 di Pusat Pameran Nuremberg</a></li>
<li><a href="../id477552/index.html">Pengujian oleh Ryzen Threadripper 3960X dan 3970X menunjukkan bahwa mereka adalah CPU yang benar-benar revolusioner</a></li>
<li><a href="../id477554/index.html">Zona domain .ORG dijual ke perusahaan swasta. Publik memanggil ICANN untuk mengakhiri kontrak</a></li>
<li><a href="../id477560/index.html">Ubah pola pikir Anda dengan SwiftUI</a></li>
<li><a href="../id477562/index.html">Desain antarmuka untuk game, menggambar paket ikon</a></li>
<li><a href="../id477564/index.html">Klien yang kompleks: bagaimana melindungi tim Anda dari mereka</a></li>
<li><a href="../id477566/index.html">Huawei Cloud: hari ini berawan di PVS-Studio</a></li>
<li><a href="../id477568/index.html">Layanan pengembalian tanpa syarat mudah. Pos Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>