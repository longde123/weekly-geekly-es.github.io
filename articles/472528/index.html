<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•§ ‚òùüèø üßëüèø‚Äçü§ù‚Äçüßëüèº Intentando precargar (PHP 7.4) y RoadRunner üëêüèæ üåÄ üò†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 A menudo escribimos y hablamos sobre el rendimiento de PHP: c√≥mo lo tratamos en general, c√≥mo ahorramos $ 1 mill√≥n al cambiar a PHP 7.0,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intentando precargar (PHP 7.4) y RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/472528/"><img src="https://habrastorage.org/webt/mu/-7/aw/mu-7awhkx6dstts3atuaodnhsm4.jpeg"><br><br>  Hola Habr! <br><br>  A menudo escribimos y hablamos sobre el rendimiento de PHP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo lo tratamos</a> en general, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo ahorramos</a> $ 1 mill√≥n al cambiar a PHP 7.0, y tambi√©n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducimos</a> varios materiales sobre este tema.  Esto se debe al hecho de que la audiencia de nuestros productos est√° creciendo y la ampliaci√≥n del backend de PHP con hierro est√° cargada de costos significativos: tenemos 600 servidores con PHP-FPM.  Por lo tanto, invertir tiempo en la optimizaci√≥n es beneficioso para nosotros. <br><br>  Antes, hablamos principalmente sobre las formas habituales y ya establecidas de trabajar con la productividad.  ¬°Pero la comunidad PHP est√° en alerta!  JIT aparecer√° en PHP 8, la precarga aparecer√° en PHP 7.4 y se desarrollar√°n marcos fuera del marco de desarrollo de PHP central, que suponen que PHP funciona como un demonio.  Es hora de experimentar con algo nuevo y ver qu√© nos puede dar. <br><br>  Dado que el lanzamiento de PHP 8 todav√≠a est√° muy lejos, y los marcos asincr√≥nicos no son adecuados para nuestras tareas (por qu√©, lo dir√© a continuaci√≥n), hoy nos centraremos en la precarga, que aparecer√° en PHP 7.4, y el marco para demonizar PHP, RoadRunner. <br><br>  Esta es la versi√≥n de texto de mi informe con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Badoo PHP Meetup # 3</a> .  Video de todos los discursos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hemos recopilado en esta publicaci√≥n</a> . <a name="habracut"></a><br><br>  PHP-FPM, Apache mod_php y formas similares de ejecutar scripts PHP y procesar solicitudes (que son ejecutadas por la gran mayor√≠a de sitios y servicios; por simplicidad, los llamar√© PHP "cl√°sico") funcionan sobre la base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nada compartido</a> en el sentido amplio del t√©rmino: <br><br><ul><li>  el estado no se revuelve entre los trabajadores de PHP; <br></li><li>  el estado no se revuelve entre varias solicitudes. <br></li></ul><br>  Considere esto con un ejemplo de un script simple: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); //   $name = $storage-&gt;getById($_COOKIE['city_id']); echo " : {$name}";</span></span></code> </pre> <br>  Para cada solicitud, el script se ejecuta desde la primera hasta la √∫ltima l√≠nea: a pesar de que la inicializaci√≥n, muy probablemente, no diferir√° de la solicitud a la solicitud y puede ejecutarse una vez (ahorrando recursos), a√∫n debe repetirla para cada solicitud.  No podemos simplemente tomar y guardar variables (por ejemplo, <code>$app</code> ) entre solicitudes debido a las peculiaridades de c√≥mo funciona el PHP "cl√°sico". <br><br>  ¬øC√≥mo ser√≠a si fu√©ramos m√°s all√° del alcance del PHP "cl√°sico"?  Por ejemplo, nuestro script podr√≠a ejecutarse independientemente de la solicitud, inicializarse y tener un ciclo de consulta dentro, dentro del cual esperar√≠a el siguiente, procesarlo y repetir el ciclo sin limpiar el entorno (en adelante llamar√© a esta soluci√≥n "PHP como demonio" "). <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $app = \App::init(); $storage = $app-&gt;getCitiesStorage(); $cities = $storage-&gt;getAll(); //    while ($req = getNextRequest()) {    $name = $cities[$req-&gt;getCookie('city_id')];    echo " : {$name}"; }</span></span></code> </pre> <br>  Pudimos no solo deshacernos de la inicializaci√≥n repetida para cada solicitud, sino tambi√©n guardar la lista de ciudades una vez en la variable <code>$cities</code> y usarla desde varias solicitudes sin acceder a ning√∫n lugar excepto a la memoria (esta es la forma m√°s r√°pida de obtener datos). <br><br>  El rendimiento de dicha soluci√≥n es potencialmente significativamente mayor que el del PHP "cl√°sico".  Pero, por lo general, el aumento de la productividad no se da de forma gratuita: debe pagar un precio por ello.  Veamos qu√© puede ser en nuestro caso. <br><br>  Para hacer esto, complicaremos un poco nuestro script y, en lugar de mostrar la variable <code>$name</code> , llenaremos la matriz: <br><br><pre> <code class="php hljs">-  $name = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)]; +  $names[] = $cities[$req-&gt;getCookie(<span class="hljs-string"><span class="hljs-string">'city_id'</span></span>)];</code> </pre><br>  En el caso de PHP "cl√°sico", no surgir√°n problemas: al final de la consulta, la variable <code>$name</code> se destruir√° y cada solicitud posterior funcionar√° como se esperaba.  En el caso de iniciar PHP como demonio, cada solicitud agregar√° otra ciudad a esta variable, lo que conducir√° a un crecimiento incontrolado de la matriz hasta que la memoria se agote en la m√°quina. <br><br>  En general, no solo puede terminar la memoria, sino que pueden producirse otros errores que conducir√°n a la muerte del proceso.  Con tales problemas, PHP "cl√°sico" maneja autom√°ticamente.  En el caso de iniciar PHP como demonio, necesitamos monitorear de alguna manera este demonio, reiniciarlo si falla. <br><br>  Los errores de este tipo son desagradables, pero existen soluciones efectivas para ellos.  Es mucho peor si, debido a un error, el script no cae, pero cambia de manera impredecible los valores de algunas variables (por ejemplo, borra la matriz <code>$cities</code> ).  En este caso, todas las solicitudes posteriores funcionar√°n con datos incorrectos. <br><br><blockquote>  Para resumir, es m√°s f√°cil escribir c√≥digo para PHP "cl√°sico" (PHP-FPM, Apache mod_php y similares): nos libera de una serie de problemas y errores.  Pero por esto pagamos con rendimiento. </blockquote><br>  De los ejemplos anteriores, vemos que en algunas partes del c√≥digo, PHP gasta recursos que no podr√≠an haberse gastado (o desperdiciado una vez) en el procesamiento de cada solicitud del "cl√°sico".  Estas son las siguientes √°reas: <br><br><ul><li>  conexi√≥n de archivo (incluir, requerir, etc.); <br></li><li>  inicializaci√≥n (framework, bibliotecas, contenedor DI, etc.); <br></li><li>  solicitar datos del almacenamiento externo (en lugar de almacenarlos en la memoria). <br></li></ul><br>  PHP ha existido durante muchos a√±os e incluso puede haberse vuelto popular gracias a este modelo de trabajo.  Durante este tiempo, se desarrollaron muchos m√©todos de diversos grados de √©xito para resolver el problema descrito.  Mencion√© algunos de ellos en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> anterior.  Hoy nos detendremos en dos soluciones bastante nuevas para la comunidad: precarga y RoadRunner. <br><br><h2>  Precarga </h2><br>  De los tres puntos enumerados anteriormente, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">precarga est√°</a> dise√±ada para ocuparse de la primera sobrecarga al conectar archivos.  A primera vista, esto puede parecer extra√±o y sin sentido, porque PHP ya tiene OPcache, que fue creado solo para este prop√≥sito.  Para comprender la esencia, perfilemos real con la ayuda de <code>perf</code> , sobre el cual OPcache est√° habilitado, con una tasa de aciertos igual al 100%. <br><br><img src="https://habrastorage.org/webt/rb/y-/jo/rby-jo2hcsjsu3ncjnjxjmbggny.png"><br><br>  A pesar de OPcache, vemos que <code>persistent_compile_file</code> toma 5.84% del tiempo de ejecuci√≥n de la consulta. <br><br>  Para entender por qu√© sucede esto, podemos ver las fuentes de <a href="">zend_accel_load_script</a> .  Se puede ver de ellos que, a pesar de la presencia de OPcache, con cada llamada a <code>include/require</code> firmas de clases y funciones se copian de la memoria compartida a la memoria del proceso de trabajo, y se realiza un trabajo auxiliar diferente.  Y este trabajo debe realizarse para cada solicitud, ya que al final se borra la memoria del proceso de trabajo. <br><br><img src="https://habrastorage.org/webt/6j/nj/zl/6jnjzlelhihw5j5fsgo5bmlluxw.png"><br><br>  Esto se ve agravado por la gran cantidad de llamadas de inclusi√≥n / solicitud que generalmente hacemos en una sola solicitud.  Por ejemplo, Symfony 4 incluye aproximadamente 310 archivos antes de ejecutar la primera l√≠nea √∫til de c√≥digo.  A veces esto sucede impl√≠citamente: para crear una instancia de clase A, que se muestra a continuaci√≥n, PHP cargar√° autom√°ticamente todas las dem√°s clases (B, C, D, E, F, G).  Y especialmente a este respecto, se destacan las dependencias de Composer que declaran funciones: para garantizar que estas funciones est√©n disponibles durante la ejecuci√≥n del c√≥digo de usuario, Composer siempre debe conectarlas independientemente del uso, ya que PHP no tiene funciones de carga autom√°tica y no pueden cargado en el momento de la llamada. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1; }</code> </pre> <br><br><h3>  C√≥mo funciona la precarga </h3><br>  Preload tiene una √∫nica configuraci√≥n principal, opcache.preload, en la que se pasa la ruta al script PHP.  Este script se ejecutar√° una vez al iniciar PHP-FPM / Apache /, etc., y todas las firmas de clases, m√©todos y funciones que se declarar√°n en este archivo estar√°n disponibles para todos los scripts que procesen solicitudes desde la primera l√≠nea de su ejecuci√≥n (importante nota: esto no se aplica a variables y constantes globales; sus valores se restablecer√°n a cero despu√©s del final de la fase de precarga).  Ya no necesita hacer llamadas de inclusi√≥n / solicitud y copiar firmas de funci√≥n / clase de la memoria compartida a la memoria de proceso: todas ellas se declaran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inmutables</a> y, debido a esto, todos los procesos pueden referirse a la misma ubicaci√≥n de memoria que las contiene. <br><br>  Por lo general, las clases y funciones que necesitamos est√°n en diferentes archivos y es inconveniente combinarlas en un script de precarga.  Pero esto no necesita hacerse: dado que la precarga es un script PHP normal, podemos usar include / require u opcache_compile_file () del script de precarga para todos los archivos que necesitamos.  Adem√°s, dado que todos estos archivos se cargar√°n una vez, PHP podr√° realizar optimizaciones adicionales que no podr√≠an realizarse mientras conectamos estos archivos por separado en el momento de la consulta.  PHP realiza optimizaciones solo dentro del marco de cada archivo separado, pero en el caso de precarga, para todo el c√≥digo cargado en la fase de precarga. <br><br><h3>  Benchmarks preload </h3><br>  Para demostrar en la pr√°ctica los beneficios de la precarga, tom√© un punto final Badoo vinculado a la CPU.  Nuestro backend generalmente se caracteriza por una carga vinculada a la CPU.  Este hecho es la respuesta a la pregunta de por qu√© no consideramos los marcos asincr√≥nicos: no ofrecen ninguna ventaja en el caso de una carga vinculada a la CPU y al mismo tiempo complican a√∫n m√°s el c√≥digo (debe escribirse de manera diferente), as√≠ como para trabajar con una red, disco, etc. Se requieren controladores asincr√≥nicos especiales. <br><br>  Para apreciar completamente los beneficios de la precarga, para el experimento descargu√© con √©l todos los archivos necesarios para el script probado en el trabajo, y lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargu√©</a> con una apariencia de carga de producci√≥n normal usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wrk2</a> , un an√°logo m√°s avanzado de Apache Benchmark, pero igual de simple. . <br><br>  Para probar la precarga, primero debe actualizar a PHP 7.4 (ahora tenemos PHP 7.2).  Med√≠ el rendimiento de PHP 7.2, PHP 7.4 sin precarga y PHP 7.4 con precarga.  El resultado es una imagen as√≠: <br><br><img src="https://habrastorage.org/webt/sm/ea/5_/smea5_e3kck5zwyk44afzp8ut9u.png"><br><br>  Por lo tanto, la transici√≥n de PHP 7.2 a PHP 7.4 da + 10% al rendimiento en nuestro punto final, y la precarga da otro 10% desde arriba. <br><br>  En el caso de la precarga, los resultados depender√°n en gran medida del n√∫mero de archivos conectados y la complejidad de la l√≥gica ejecutable: si hay muchos archivos conectados y la l√≥gica es simple, la precarga dar√° m√°s que si hay pocos archivos y la l√≥gica es compleja. <br><br><h3>  Los matices de precarga </h3><br>  Lo que aumenta la productividad generalmente tiene un inconveniente.  La precarga tiene muchos matices, que dar√© a continuaci√≥n.  Todos deben tenerse en cuenta, pero solo uno (primero) puede ser fundamental. <br><br><h4>  Cambiar - reiniciar </h4><br>  Dado que todos los archivos de precarga se compilan solo al inicio, se marcan como inmutables y no se vuelven a compilar en el futuro, la √∫nica forma de aplicar cambios a estos archivos es reiniciar (recargar o reiniciar) PHP-FPM / Apache /, etc. <br><br>  En el caso de la recarga, PHP intenta reiniciarse con la mayor precisi√≥n posible: las solicitudes de los usuarios no se interrumpir√°n, pero, sin embargo, mientras la fase de precarga est√° en progreso, todas las solicitudes nuevas esperar√°n a que se complete.  Si no hay mucho c√≥digo en la precarga, esto puede no causar problemas, pero si intentas descargar la aplicaci√≥n completa, hay un aumento significativo en el tiempo de respuesta durante un reinicio. <br><br>  Adem√°s, un reinicio (independientemente de si se trata de recargar o reiniciar) tiene una caracter√≠stica importante: como resultado de esta acci√≥n, se borra OPcache.  Es decir, todas las solicitudes posteriores funcionar√°n con un cach√© de c√≥digo de operaci√≥n en fr√≠o, lo que puede aumentar el tiempo de respuesta a√∫n m√°s. <br><br><h4>  Personajes indefinidos </h4><br>  Para que la precarga cargue una clase, todo lo que depende debe definirse hasta este punto.  Para la siguiente clase, esto significa que todas las dem√°s clases (B, C, D, E, F, G), la variable <code>$someGlobalVar</code> y la constante SOME_CONST deben estar disponibles antes de compilar esta clase.  Dado que el script de precarga es solo un c√≥digo PHP normal, podemos definir un cargador autom√°tico.  En este caso, todo lo relacionado con otras clases se cargar√° autom√°ticamente.  Pero esto no funciona con variables y constantes: nosotros mismos debemos asegurarnos de que est√©n definidos en el momento en que se declara esta clase. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> \<span class="hljs-title"><span class="hljs-title">D</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SOME_CONST = \E::E1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $someVar = \F::F1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $anotherVar = \G::G1;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $varLink = $someGlobalVar;    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $constLink = SOME_CONST; }</code> </pre> <br>  Afortunadamente, la precarga contiene suficientes herramientas para entender si obtienes algo fuera del camino o no.  En primer lugar, estos son mensajes de advertencia con informaci√≥n sobre lo que no se pudo cargar y por qu√©: <br><br><pre> <code class="plaintext hljs">PHP Warning: Can't preload class MyTestClass with unresolved initializer for constant RAND in /local/preload-internal.php on line 6 PHP Warning: Can't preload unlinked class MyTestClass: Unknown parent AnotherClass in /local/preload-internal.php on line 5</code> </pre> <br>  En segundo lugar, preload agrega una secci√≥n separada al resultado de la funci√≥n opcache_get_status (), que muestra lo que se carg√≥ correctamente en la fase de precarga: <br><br><img src="https://habrastorage.org/webt/j7/fh/6u/j7fh6u0ww7plxxrx_x8fguxcazu.png"><br><br><h4>  Campo de clase / optimizaci√≥n constante </h4><br>  Como escrib√≠ anteriormente, preload resuelve los valores de los campos / constantes de la clase y los guarda.  Esto le permite optimizar el c√≥digo: durante el procesamiento de la solicitud, los datos est√°n listos y no es necesario que se deriven de otros datos.  Pero esto puede conducir a resultados no obvios, lo que demuestra el siguiente ejemplo: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'MYTESTCONST'</span></span>, mt_rand(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>));</code> </pre> <br><pre> <code class="php hljs">preload.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestClass</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RAND = MYTESTCONST; }</code> </pre> <br><pre> <code class="php hljs">script.php: <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'const.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> MYTESTCONST, <span class="hljs-string"><span class="hljs-string">', '</span></span>, MyTestClass::RAND; <span class="hljs-comment"><span class="hljs-comment">// 32, 154</span></span></code> </pre> <br>  El resultado es una situaci√≥n contraintuitiva: parece que las constantes deber√≠an ser iguales, ya que a una de ellas se le asign√≥ el valor de la otra, pero en realidad esto no es as√≠.  Esto se debe al hecho de que las constantes globales, en contraste con las constantes / campos de clase, se borran por la fuerza despu√©s de que finaliza la fase de precarga, mientras que las constantes / campos de clase se resuelven y guardan.  Esto lleva al hecho de que durante la ejecuci√≥n de la solicitud tenemos que definir nuevamente la constante global, como resultado de lo cual puede obtener un valor diferente. <br><br><h4>  No se puede volver a declarar someFunc () </h4><br>  En el caso de las clases, la situaci√≥n es simple: generalmente no las conectamos expl√≠citamente, sino que usamos un cargador autom√°tico.  Esto significa que si una clase se define en la fase de precarga, entonces el autocargador simplemente no se ejecutar√° durante la solicitud y no intentaremos conectar esta clase por segunda vez. <br><br>  La situaci√≥n es diferente con las funciones: debemos conectarlas expl√≠citamente.  Esto puede conducir a una situaci√≥n en la que en el script de precarga conectaremos todos los archivos necesarios con funciones, y durante la solicitud intentaremos hacerlo nuevamente (un ejemplo t√≠pico es el gestor de arranque Composer: siempre intentar√° conectar todos los archivos con funciones).  En este caso, obtenemos un error: la funci√≥n ya se ha definido y no se puede redefinir. <br><br>  Este problema se puede resolver de diferentes maneras.  En el caso de Composer, puede, por ejemplo, conectar todo en la fase de precarga y no conectar nada relacionado con Composer durante las solicitudes.  Otra soluci√≥n no es conectar archivos con funciones directamente, sino hacerlo a trav√©s de un archivo proxy con una comprobaci√≥n de function_exists (), como, por ejemplo, Guzzle HTTP. <br><br><img src="https://habrastorage.org/webt/8h/4f/bd/8h4fbddjiu5zbd3xycfnwrdxrmi.png"><br><br><h4>  PHP 7.4 a√∫n no se ha lanzado oficialmente (todav√≠a) </h4><br>  Este matiz se volver√° irrelevante despu√©s de alg√∫n tiempo, pero hasta ahora la versi√≥n de PHP 7.4 a√∫n no se ha lanzado oficialmente y el equipo de PHP en las notas de la versi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escribe</a> expl√≠citamente: "NO use esta versi√≥n en producci√≥n, es una versi√≥n de prueba temprana".  Durante nuestros experimentos con precarga, nos encontramos con varios errores, los reparamos nosotros mismos e incluso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enviamos</a> algo a la parte superior.  Para evitar sorpresas, es mejor esperar el lanzamiento oficial. <br><br><h2>  Correcaminos </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RoadRunner</a> es un demonio escrito en Go, que, por un lado, crea trabajadores PHP y los monitorea (comienza / termina / reinicia seg√∫n sea necesario) y, por otro lado, acepta solicitudes y las pasa a estos trabajadores.  En este sentido, su trabajo no es diferente del trabajo de PHP-FPM (donde tambi√©n hay un proceso maestro que monitorea a los trabajadores).  Pero todav√≠a hay diferencias.  La clave es que RoadRunner no restablece el estado del script despu√©s de completar la consulta. <br><br>  Por lo tanto, si recordamos nuestra lista de los recursos que se gastan en el caso de PHP "cl√°sico", RoadRunner le permite tratar con todos los puntos (la precarga, como recordamos, es solo con el primero): <br><br><ul><li>  conexi√≥n de archivo (incluir, requerir, etc.); <br></li><li>  inicializaci√≥n (framework, bibliotecas, contenedor DI, etc.); <br></li><li>  solicitar datos del almacenamiento externo (en lugar de almacenarlos en la memoria). <br></li></ul><br>  El ejemplo de Hello World RoadRunner se parece a esto: <br><br><pre> <code class="php hljs">$relay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\Goridge\StreamRelay(STDIN, STDOUT); $psr7 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\PSR7Client(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spiral\RoadRunner\Worker($relay)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {        $resp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);        $psr7-&gt;respond($resp); }</code> </pre> <br>  Probaremos nuestro punto final actual, que probamos con precarga, para ejecutarlo en RoadRunner sin modificaciones, cargarlo y medir el rendimiento.  Sin modificaciones, porque de lo contrario el punto de referencia no ser√° completamente honesto. <br><br>  Intentemos adaptar el ejemplo de Hello World para esto. <br><br>  En primer lugar, como escrib√≠ anteriormente, no queremos que el trabajador se caiga en caso de error.  Para hacer esto, necesitamos envolver todo en un intento global ... captura.  En segundo lugar, dado que nuestro script no sabe nada sobre Zend Diactoros, para la respuesta necesitaremos convertir sus resultados.  Para esto utilizamos funciones ob_.  En tercer lugar, nuestro script no sabe nada sobre la naturaleza de la solicitud PSR-7.  La soluci√≥n es completar el entorno PHP est√°ndar desde estas entidades.  Y cuarto, nuestro script espera que la solicitud muera y se borrar√° todo el estado.  Por lo tanto, con RoadRunner necesitaremos hacer esta limpieza nosotros mismos. <br><br>  Por lo tanto, la versi√≥n inicial de Hello World se convierte en algo como esto: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($req = $psr7-&gt;acceptRequest()) {    <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {        $uri = $req-&gt;getUri();        $_COOKIE = $req-&gt;getCookieParams();        $_POST = $req-&gt;getParsedBody();        $_SERVER = [            <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; $req-&gt;getMethod(),            <span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'DOCUMENT_URI'</span></span> =&gt; $uri-&gt;getPath(),            <span class="hljs-string"><span class="hljs-string">'SERVER_NAME'</span></span> =&gt; $uri-&gt;getHost(),            <span class="hljs-string"><span class="hljs-string">'QUERY_STRING'</span></span> =&gt; $uri-&gt;getQuery(),            <span class="hljs-comment"><span class="hljs-comment">// ...        ];        ob_start();        // our logic here        $output = ob_get_contents();        ob_clean();               $resp = new \Zend\Diactoros\Response();        $resp-&gt;getBody()-&gt;write($output, 200);        $psr7-&gt;respond($resp);    } catch (\Throwable $Throwable) {        // some error handling logic here    }    \UDS\Event::flush();    \PinbaClient::sendAll();    \PinbaClient::flushAll();    \HTTP::clear();    \ViewFactory::clear();    \Logger::clearCaches();       // ... }</span></span></code> </pre> <br><br><h3>  Benchmarks RoadRunner </h3><br>  Bueno, es hora de lanzar puntos de referencia. <br><br><img src="https://habrastorage.org/webt/qs/6b/89/qs6b89wrabygtu6ea6d-8i9rk4m.png"><br><br>  Los resultados no cumplen con las expectativas: RoadRunner le permite nivelar m√°s factores que causan p√©rdidas de rendimiento que la precarga, pero los resultados son peores.  Vamos a averiguar por qu√© sucede esto, como siempre, ejecutando perf para esto. <br><br><img src="https://habrastorage.org/webt/1w/v9/ft/1wv9ftxnmcdxiu48rrkftw1phic.png"><br><br>  En los resultados de rendimiento, vemos phar_compile_file.  Esto se debe a que incluimos algunos archivos durante la ejecuci√≥n del script, y dado que OPcache no est√° activado (RoadRunner ejecuta scripts como CLI, donde OPcache est√° desactivado por defecto), estos archivos se compilan nuevamente con cada solicitud. <br><br>  Edite la configuraci√≥n de RoadRunner: habilite OPcache: <br><br><img src="https://habrastorage.org/webt/-d/zq/wn/-dzqwnysszz3zcpek82a2wtr9wy.png"><br><br><img src="https://habrastorage.org/webt/zt/tp/1w/zttp1w-bl-5xkho85gi1-7d5pek.png"><br><br>  Estos resultados ya se parecen m√°s a lo que esper√°bamos ver: RoadRunner comenz√≥ a mostrar m√°s rendimiento que precarga.  ¬°Pero quiz√°s podamos obtener a√∫n m√°s! <br><br>  Parece que no hay nada m√°s inusual con perf: echemos un vistazo al c√≥digo PHP.  La forma m√°s f√°cil de perfilarlo es usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">phpspy</a> : no requiere ninguna modificaci√≥n del c√≥digo PHP, solo necesita ejecutarlo en la consola.  Hagamos esto y construyamos un gr√°fico de llama: <br><br><img src="https://habrastorage.org/webt/60/2k/yk/602kykwmxdw1nxaudop0omr98bi.png"><br><br>  Como acordamos no modificar la l√≥gica de nuestra aplicaci√≥n para la pureza del experimento, estamos interesados ‚Äã‚Äãen la rama de la pila asociada con el trabajo de RoadRunner: <br><br><img src="https://habrastorage.org/webt/ta/ag/yz/taagyz-8en1khhrka80i_al2dry.png"><br><br>  La parte principal se reduce a llamar a fread (), casi nada se puede hacer con esto.  Pero vemos algunas otras ramas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">\ Spiral \ RoadRunner \ PSR7Client :: acceptRequest ()</a> , excepto el propio fread.  Puede entender su significado mirando el c√≥digo fuente: <br><br><pre> <code class="php hljs">   <span class="hljs-comment"><span class="hljs-comment">/**     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ServerRequestInterface|null     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">    </span></span>{        $rawRequest = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;httpClient-&gt;acceptRequest();        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rawRequest === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;        }        $_SERVER = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;configureServer($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>]);        $request = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;requestFactory-&gt;createServerRequest(            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'method'</span></span>],            $rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uri'</span></span>],            $_SERVER        );        parse_str($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'rawQuery'</span></span>], $query);        $request = $request            -&gt;withProtocolVersion(<span class="hljs-keyword"><span class="hljs-keyword">static</span></span>::fetchProtocolVersion($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'protocol'</span></span>]))            -&gt;withCookieParams($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>])            -&gt;withQueryParams($query)            -&gt;withUploadedFiles(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;wrapUploads($rawRequest[<span class="hljs-string"><span class="hljs-string">'ctx'</span></span>][<span class="hljs-string"><span class="hljs-string">'uploads'</span></span>]));</code> </pre> <br>  Queda claro que RoadRunner est√° intentando crear un objeto de solicitud compatible con PSR-7 utilizando una matriz serializada.  Si su marco de trabajo funciona con objetos de consulta PSR-7 directamente (por ejemplo, Symfony <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no funciona</a> ), entonces esto est√° completamente justificado.  En otros casos, el PSR-7 se convierte en un enlace adicional antes de que la solicitud se convierta a lo que su aplicaci√≥n puede trabajar.  Eliminemos este enlace intermedio y volvamos a ver los resultados: <br><br><img src="https://habrastorage.org/webt/jv/mr/p5/jvmrp567zwsjhft2ocuimx8jk1q.png"><br><br>  El script de prueba fue bastante f√°cil, por lo que logr√© exprimir una parte significativa del rendimiento: + 17% en comparaci√≥n con PHP puro (recuerdo que la precarga da + 10% en el mismo script). <br><br><h3>  Matices de RoadRunner </h3><br>  En general, el uso de RoadRunner es un cambio m√°s serio que solo la inclusi√≥n de precarga, por lo que los matices aqu√≠ son a√∫n m√°s significativos. <br><br> -, RoadRunner,  ,  PHP-   ,   ,     ,       :    ,   ,      . <br><br> -,      RoadRunner ,     ¬´¬ª    ‚Äî      .         /   RoadRunner  ; ,      ,        ,            ,  -   . <br><br> -,        endpoint', , ,       RoadRunner.       . <br><br><h2>  </h2><br> ,    ¬´¬ª PHP,   ,     preload       RoadRunner. <br><br> PHP  ¬´¬ª   (PHP-FPM, Apache mod_php  )       .       -    ,       .  ,         ,     preload    JIT. <br><br>   ,    , ,       RoadRunner,         . <br><br>    ,      (:           ): <br><br><ul><li> PHP 7.2 ‚Äî 845 RPS; <br></li><li> PHP 7.4 ‚Äî 931 RPS; <br></li><li> RoadRunner   ‚Äî 987 RPS; <br></li><li> PHP 7.4 + preload ‚Äî 1030 RPS; <br></li><li> RoadRunner   ‚Äî 1089 RPS. <br></li></ul><br>   Badoo      PHP 7.4       ,         (    ). <br><br> RoadRunner      ,   ,         ,      ,   . <br><br>  Gracias por su atencion! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472528/">https://habr.com/ru/post/472528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472516/index.html">Yandex.Translator para Linux en Python + GTK3</a></li>
<li><a href="../472520/index.html">Kits de capacitaci√≥n del video: de manera r√°pida y eficiente</a></li>
<li><a href="../472522/index.html">El libro "Desarrollo continuo de la API. Las decisiones correctas en un panorama tecnol√≥gico cambiante ‚Äù</a></li>
<li><a href="../472524/index.html">Espacio, cuadr√≠culas y dise√±os.</a></li>
<li><a href="../472526/index.html">3D se dispara: se ha creado un nuevo compuesto para el sector aeroespacial, que ha reducido la masa de piezas en un 20%</a></li>
<li><a href="../472530/index.html">Videovigilancia en Mosc√∫: realidades actuales y perspectivas</a></li>
<li><a href="../472532/index.html">Enlace de ayuda √∫til para vendedores</a></li>
<li><a href="../472534/index.html">¬°Se despiertan! (N.-F. novela, parte 1 de 2)</a></li>
<li><a href="../472536/index.html">Smart IdReader SDK: reconocimiento integrado en proyectos en Python y PHP</a></li>
<li><a href="../472540/index.html">¬°Se despiertan! (n.-f. historia, parte 2 y la √∫ltima)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>