<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏻 👨🏿‍⚖️ 👩 Mon magnum opus du monde du jeu mobile 👆🏿 🚬 🤴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Aujourd'hui, le 26 septembre, c'est mon anniversaire, ce qui signifie pour moi que c'est une excellente raison de déployer un article s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mon magnum opus du monde du jeu mobile</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468363/">  Bonjour, Habr!  Aujourd'hui, le 26 septembre, c'est mon anniversaire, ce qui signifie pour moi que c'est une excellente raison de déployer un article sur la suite de mon puzzle.  Je vous préviens que je suis un amateur, ce qui signifie qu'il y aura beaucoup d'erreurs dans TOUS les aspects du développement (si vous le trouvez, écrivez, j'en tiendrai volontiers compte).  Dans cet article, je voudrais tout dire (enfin, ou presque) sur la façon dont j'ai fait la suite, comment j'y suis allé et où je suis arrivé. <br><a name="habracut"></a><br>  Afin de ne pas être confus, je veux dire ici la signification des termes qui sont dans l'article: <br>  L'original est la première partie, un jeu avec un entraînement souterrain de la techno-démo.  Vous pouvez en lire plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  La suite est la deuxième partie de la série, le jeu dont il est question dans cet article. <br><br>  Je comparerai périodiquement le jeu original avec la suite pour souligner la différence entre les deux. <br><br>  <i>En bref sur le développement</i> <br><br>  J'ai commencé à travailler sur le jeu fin janvier et fin mars la partie technique était terminée (2 mois).  Après avoir repris un autre jeu et suis revenu pour continuer à développer ce jeu à la mi-mai.  J'ai fini clairement à la fin de l'été et pendant tout ce temps (3,5 mois) j'ai rempli le jeu de contenu.  Et en conséquence, la suite a été faite encore plus rapidement par moi que le jeu original (6 mois contre 5,5 mois). <br><br>  J'ai fait un jeu sur le moteur d'unité.  J'aimerais que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ces gars-là créent</a> leur propre moteur et avancent dans la programmation, mais quelque chose s'est mal passé et a quand même décidé de faire le jeu sur un standard, mais testé par moi sur un instrument. <br><br>  <i>Entre l'original et la suite</i> <br><br>  L'idée de créer une suite m'est venue un mois avant la sortie du jeu original (quelque part en août).  En voyant les erreurs que j'ai commises, j'ai voulu tout supprimer et recommencer à travailler avec succès.  Mais je n'ai pas commencé à changer quoi que ce soit car il y avait beaucoup de code problématique, tout le contenu était prêt, et j'ai juste retardé le développement.  Il fallait aller libérer. <br><br>  Après la sortie, j'ai de nouveau été tourmenté par l'idée d'une suite.  Cette fois, je n'ai pas commencé, parce que j'étais moralement paresseux, après la sortie, c'était complètement doux.  Je voulais quelque chose de nouveau et d'intéressant.  Des expériences de masse ont commencé. <br><br>  Les 3 mois suivants, j'ai essayé de mettre en œuvre n'importe quelle idée, n'importe quel paramètre, n'importe quel concept dans les jeux.  Je l'ai fait malgré l'ampleur des ambitions, les difficultés d'exécution, et aussi parfois malgré la logique et le bon sens.  En conséquence, j'ai obtenu environ 50 projets.  Ils étaient tous de genres différents: des tireurs aux stratégies, des jeux de plateforme aux jeux rpg. <br><br>  Les expériences se poursuivaient donc jusqu'à ce que je sois fatigué.  Et je suis fatigué de ne pas faire de jeux, mais le caractère incomplet des jeux que j'ai fait.  Je me suis donné un objectif: faire au moins une sorte de jeu une semaine avant la fin.  Et donc mon deuxième match est apparu. <br><br><div class="spoiler">  <b class="spoiler_title">Jeu Pro 2</b> <div class="spoiler_text">  Ce jeu est à la fois très simple et complexe.  Il est nécessaire de couper des lignes et non des graphiques.  Le sens du jeu est que chaque ligne de coupe a été divisée par 2 et un graphique est apparu en son centre.  La caractéristique du jeu était que toute la géométrie était dynamique.  Les graphiques se déplaçaient et les lignes connectaient toujours certains graphiques. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fq/ey/fc/fqeyfcevpqtzh8uxu8xvmib4h0g.jpeg" width="400"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c-/xl/-j/c-xl-jj2fecfxp1d5eiofqybahg.jpeg" width="400"></div><br></div></div><br>  Après cela, j'étais motivé (je suis motivé) et prêt pour un nouveau projet.  J'ai ressenti une poussée de force et j'ai quand même repris la suite de mon jeu. <br><br>  <i>Idée</i> <br><br>  Avant de commencer à faire quelque chose, j'ai décidé de regarder l'original dans son intégralité.  Et horrifié.  De la qualité.  Le jeu surtout fauché sous des puzzles standard: la nécessité de débloquer des niveaux, de collecter des étoiles, une minuterie, de terminer, mais tout cela a été fait sans budget et très insipide.  Les animations originales manquaient vraiment!  Bien qu'il y ait quelque chose d'original et quelque chose de probablement sincère.  Même ici, ils ont réussi à me devancer. <br><br><div class="spoiler">  <b class="spoiler_title">J'ai trouvé quelque chose de similaire</b> <div class="spoiler_text">  Il s'avère qu'il existe un jeu très similaire avec un nom presque identique.  Et elle ressemble à une variante plus réussie de mon jeu.  Je l'ai découverte grâce à cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidéo</a> . <br>  Après avoir découvert que ce jeu est un téléviseur intelligent LG exclusif.  Il a été créé par la division russe de LG R&amp;D Lab en 2014: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qs/r_/ro/qsr_rozxewpa190vstdrslntr9i.png" width="400"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h4/vt/3x/h4vt3xoolsh3l-rqqyxi7p52q7k.png" width="600"></div><br>  Il est contrôlé par les flèches "gauche" et "droite" de la télécommande.  De la même manière que dans mon jeu (2 parties de l'écran).  Que puis-je dire, l'angle d'inclinaison est le même - 30 °.  Purement technique, on peut dire que mon jeu en est plagié.  Bien que je l'ai découverte environ 2 mois après la sortie du premier jeu. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9k/8h/u6/9k8hu6sbmhqtlta1k8nnand7jkm.png" width="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/oa/dx/sdoadx3lb0kw-jx08nwmuszcewe.png" width="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/hj/b7/wchjb7a3e8pfykhr1kokfnxxslw.png" width="500"></div><br></div></div><br>  Comprenant la position très déplorable de l'original, j'ai décidé de faire revivre le jeu avec des changements radicaux, pour le rendre meilleur.  Et puis le fantasme a volé: qu'il y ait un complot et qu'il y ait un choix, il y aura des boss avec des attaques réfléchies, il y aura une production qui manquait tellement à l'original, il y aura la sensation d'une seule aventure terminée, etc.  En général, toutes les meilleures idées qui me sont venues pendant le temps entre l'original et la suite.  Et tout ce qui n'a pas fonctionné ou qui a mal fonctionné était destiné à être rejeté par la suite. <br><br>  <i>Première démo</i> <br><br>  Tout a commencé bien sûr avec lui.  J'ai décidé: "Si vous résolvez des problèmes, faites-le soigneusement."  Et la première victime de ces changements a été la gestion.  Je pourrais juste le voler dans un jeu similaire (voir ci-dessus).  C'est exactement la gestion que je voulais à l'origine, mais je ne savais pas comment le faire.  Un supplément serait assez simple: ajoutez simplement des animations de rotation à chaque fois que vous cliquez.  Mais ce n'était pas pour moi.  Au moins pour que le contrôle soit perçu aussi bien que dans un jeu similaire, il fallait faire la même caméra statique et évidemment réduire les niveaux ainsi que le rythme du jeu.  Mais je voulais de l'action, de la dynamique et de la vitesse, j'ai donc fait un développement logique du contrôle d'origine.  Maintenant, au lieu d'appuyer et de tourner d'un certain degré, il y avait un serrage et le degré de la rotation finale était déterminé par sa durée.  Il était nettement meilleur que dans l'original. <br><br>  C'est parce que je contrôlais normalement le contrôle que le bug principal de l'original a disparu et qu'il était désormais possible de rendre les niveaux BEAUCOUP plus chargés que dans l'original sans craindre les retards et les frises.  Et puis vint la partie expérimentale. <br><br>  <i>Démo graphique</i> <br><br>  Je n'ai jamais su dessiner des graphismes normaux et presque toujours il a été remplacé par la partie technologique, ou plutôt son exécution normale.  Et ce jeu ne faisait pas exception.  Au lieu de simples sprites normaux, une lumière réaliste est apparue.  C'était une illusion de lumière 2D.  En fait, c'est une lumière tridimensionnelle, contre une surface métallique, et tous les objets avaient des matériaux avec des shaders spécifiques.  Ça avait l'air plutôt bien: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xr/y4/r7/xry4r7d7f2-qgnnrzxno2cbmpea.png" width="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5s/t7/9k/5st79k9tkdwa86zq4eg9xrcesc8.png" width="500"></div><br>  Lors des tests, il a montré une stabilité de 60 ips, mais au téléphone, même sur mon Sony Xperia, il était d'environ 20 ips et a chuté à 10 ips.  Et je suis tombé sur un plafond de performance.  Je devais emprunter un chemin différent, le chemin de la destructibilité ... <br><br>  <i>Destructibilité</i> <br><br>  Au début, tout cela me semblait une mauvaise idée.  Mais j'ai décidé d'essayer et maintenant c'est mon émission de jeu principale.  Selon le plan, je souhaitais à nouveau plus de réalisme, à savoir la destruction des fragments générés, selon la direction et la force de l'impact.  Mais le plan reposait à nouveau sur le plafond, cette fois à ma connaissance.  Je devais simplifier pour un plus simple. <br><br>  Désormais, la destructibilité était basée sur un principe de fonctionnement plus simple, à savoir qu'elle créait une copie d'elle-même, uniquement à partir de fragments physiques, et l'objet d'origine supprimait les composants de SpriteRenderer, Collider2D et, s'il y en avait un, désactivait Rigidbody2D. <br><br>  Mais une autre question s'est posée - les collisionneurs.  D'une part, vous pouvez utiliser PolygonCollider2D et ne pas être tourmenté, mais d'autre part, vous devrez souffrir plus tard dans la conception et l'optimisation du jeu.  Par conséquent, tous les fragments des blocs détruits avaient BoxCollider2D (même des fragments d'objets ronds). <br><br>  De plus, une contribution significative à l'optimisation a été apportée par le réglage correct du paramètre de temps fixe (il est devenu égal à 0,0 (3) ou 30 par seconde).  Mais maintenant, à grande vitesse, l'objet a survolé, ce qui a certainement affecté la conception du jeu. <br><br>  Ces éléments ont amené l'optimisation à un niveau acceptable et maintenant il pourrait y avoir jusqu'à des centaines d'objets physiques sur la scène!  Après l'original, c'était définitivement une percée, une révolution, etc.  Réalisant que j'allais dans la bonne direction, j'ai décidé de résoudre un autre problème de jeu de longue date: le hardcore écrasant.  Afin de provoquer en quelque sorte le jeu que j'ai fait ... <br><br>  <i>Système de dommages</i> <br><br>  Pour moi, c'est la partie la plus obscure du développement, qui a été réécrite 2 fois.  Les travaux y étaient en cours.  En conséquence, un système extrêmement sophistiqué est sorti, mais il a fonctionné assez largement. <br><br>  Mais d'abord, il convient de mentionner le fonctionnement de la perception des dommages ici.  Il peut sembler que cela fonctionne sur le principe «plus vous frappez fort, plus les dégâts sont importants», mais ce n'est pas le cas.  Dans la plupart des cas, il fonctionne sur le principe "plus le contact est long - plus les dommages sont importants", où la place d'une chose aussi importante que la "force d'impact" a été remplacée par un coefficient de dommage configuré manuellement pour chaque objet qui inflige des dommages, selon la situation.  Cela est dû au fait que le temps fixé s'est avéré si important qu'un bug puissant a été créé: le jeu n'a pas réussi à traiter Enter2D.  Et cela a créé des situations comme: s'est écrasé à grande vitesse - n'a pas subi de dommages.  Pourquoi ne l'ai-je pas réparé?  Même moi, je ne peux pas dire ça. <br><br>  Alors, où le système de dégâts a-t-il commencé?  De la santé.  Le joueur a une santé égale à 1 (augmentée plus tard à 2).  Oui, cela ne suffit toujours pas et au premier contact fort avec le piège, il mourra, mais au moins à faible vitesse, il y a une chance de survivre (même plusieurs fois).  Je ne voulais pas changer l'original.  "Mais qu'est-ce qui causera des dommages au joueur?"  - J'ai pensé et trouvé les principaux pièges. <br><br>  <i>Pièges principaux</i> <br><br>  La base de mon puzzle était constituée de pièges, mais ils contredisaient le nom du jeu.  Du nom, il s'ensuit que le jeu devrait porter sur des balles qui tombent sous l'influence de la gravité.  Mais il n'y en avait pas tellement.  Au lieu de cela, il y avait plus de puzzles standard. <br><br>  Le principal et le premier était une scie.  Puzzle simple et clair.  Il n'a pas été écrit de façon très optimale, pendant la période de post-production, je l'ai corrigé. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1z/rd/12/1zrd120z2iybncavb97pa6khk_0.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script de scie</b> <div class="spoiler_text"><pre><code class="plaintext hljs">using UnityEngine; public class Saw : GlobalFunctions { public AudioClip setClip; private TypePlaying typePlaying = TypePlaying.Sound; private AudioBase audioBase; private float speed = 4f; private Transform tr; private void Awake() { audioBase = GameObject.FindWithTag("MainCamera").GetComponent&lt;AudioBase&gt;(); tr = transform; } private void Update() { float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); tr.localEulerAngles = new Vector3(0f, 0f, tr.localEulerAngles.z - speed * s); } private void OnCollisionEnter2D(Collision2D collision) { if (collision.collider.tag == "Player") { audioBase.SetSound(setClip, 1, 0.2f, typePlaying, false); } } public float GetSpeed() { return speed; } }</code> </pre> <br></div></div><br>  Ensuite, il y avait un laser qui, enfin, chargeait tout très lourdement.  Si vous mettez 40 pièces sur scène, le jeu commencera à accuser un retard important.  Mais j'avais aussi le désir d'ajouter des lois physiques de la lumière à part entière, à savoir la réflexion ou même la réfraction.  Mais il n'y avait pas de temps, je ne l'ai pas terminé.  Bien que j'optimise certaines choses, cela n'a pas beaucoup aidé. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ve/tr/yk/vetrykehlbbyyoiulruywx-ln2q.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script laser</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class Laser : MonoBehaviour { public Vector2 vector2; public bool active = true; public GameObject laserActive; public LineRenderer lr1; public Transform tr; public BoxCollider2D bcl; public Damage dmg; private void Start() { lr1.startColor = lr1.endColor = LaserColor(); } public Color LaserColor() { Color c = new Color(0f, 0f, 0f, 1f); switch (dmg.GetTypeLaser().Type2int()) { case 1: c = new Color(1f, 0f, 0f, 1f); break; case 2: c = new Color(0f, 1f, 0f, 1f); break; case 3: c = new Color(0f, 0f, 0f, 0.4901961f); break; case 4: c = new Color(1f, 0.8823529f, 0f, 1f); break; case 5: c = new Color(0.6078432f, 0.8823529f, 0f, 1f); break; case 6: c = new Color(1f, 0.2745098f, 0f, 1f); break; } return c; } private void Update() { LaserUpdate(); } private void LaserUpdate() { if (active == true) { Vector2[] act1 = Points(tr.position, -tr.up); lr1.SetPosition(0, act1[0]); lr1.SetPosition(1, act1[1]); bcl.size = new Vector2(0.1f, 0.1f); bcl.offset = act1[2]; } return; } private Vector2[] Points(Vector2 start, Vector2 end) { Vector2[] ret = new Vector2[3]; RaycastHit2D hit = Physics2D.Raycast(tr.position, -tr.up, 200f); ret[0] = tr.position; ret[1] = hit.point; vector2 = ret[1]; float distance = Vector2.Distance(tr.position, hit.point); bcl.size = new Vector2(0.1f, 0.1f); if (hit.collider == bcl) { ret[2] = new Vector2(0f, 0.5f); } else { ret[2] = new Vector2(0f, -distance - 0.2f); } return ret; } }</code> </pre><br></div></div><br><br>  La bombe était le dernier piège, et avant de l'ajouter, j'ai réécrit le système de prise de dégâts, en particulier, transféré tout ce qui concerne la santé du joueur dans un script HealthBar distinct (utile à d'autres fins).  Après que la bombe soit toujours apparue et que sa physique laisse à désirer, elle a de nouveau été terminée.  Et à la fin, cela s'est avéré à nouveau digne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zg/gn/so/zggnsolmlabdaf5gupqicjr3ih8.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script d'explosion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class Explosion : GlobalFunctions { public float power = 1f; public float radius = 5f; public float health = 20f; public float timeOffsetExplosion = 1f; public GameObject[] contacts = new GameObject[0]; public Animator expAnim; public bool writeContacs = true; public AudioClip setClip; private float timeOffsetExplosionCount; private float alphaTimer; private bool isTimerOn = false; private bool firstAPEvirtual = true; private Collider2D cl; private Rigidbody2D rb; private SpriteRenderer sr; private AudioBase audioBase; private Explosion explosion; private void Awake() { audioBase = GameObject.FindWithTag("MainCamera").GetComponent&lt;AudioBase&gt;(); cl = GetComponent&lt;Collider2D&gt;(); rb = GetComponent&lt;Rigidbody2D&gt;(); sr = GetComponent&lt;SpriteRenderer&gt;(); explosion = GetComponent&lt;Explosion&gt;(); } private void Start() { alphaTimer = sr.color.a; StartCoroutineTimerOffsetExplosion(); } private void OnCollisionEnter2D(Collision2D collision) { if (writeContacs == true) { int cont = contacts.Length; GameObject[] n = new GameObject[cont + 1]; if (cont != 0) { for (int i = 0; i &lt; cont; i++) { n[i] = contacts[i]; } } n[cont] = collision.gameObject; contacts = n; } } private void OnCollisionExit2D(Collision2D collision) { if (writeContacs == true) { int cont = contacts.Length; if (cont != 1) { int counter = 0; GameObject[] n = new GameObject[cont - 1]; for (int i = 0; i &lt; cont; i++) { if (contacts[i] != collision.gameObject) { n[counter] = contacts[i]; counter++; } } contacts = n; } else { contacts = new GameObject[0]; } } } public void ActionExplosionEmulation(GameObject obj) { float damage = 0f; if (obj.CompareTag("Laser")) { damage = obj.GetComponent&lt;Damage&gt;().senDamage; } else { damage = obj.GetComponent&lt;Power&gt;().power; } health = health - damage; StartCoroutineTimerOffsetExplosion(); return; } public void StartCoroutineTimerOffsetExplosion() { if (health &lt;= 0f &amp;&amp; isTimerOn == false) { isTimerOn = true; timeOffsetExplosionCount = timeOffsetExplosion; StartCoroutine(TimerOffsetExplosion(0.1f)); } } private IEnumerator TimerOffsetExplosion(float timeTick) { yield return new WaitForSeconds(timeTick); timeOffsetExplosionCount = timeOffsetExplosionCount - timeTick; if (timeOffsetExplosionCount &gt; 0f) { float c = timeOffsetExplosionCount / timeOffsetExplosion; sr.color = new Color(1f, c, c, alphaTimer); StartCoroutine(TimerOffsetExplosion(timeTick)); } else { ExplosionAction(); } } private void ExplosionAction() { rb.gravityScale = 0f; rb.velocity = Vector2.zero; audioBase.SetSound(setClip, 2, 1f, TypePlaying.Sound, false); Destroy(cl); CircleCollider2D c = gameObject.AddComponent&lt;CircleCollider2D&gt;(); c.isTrigger = true; c.radius = radius; tag = "Explosion"; if (PlayerPrefs.GetString("graphicsquality") != "high") { Destroy(sr); StartCoroutine(Off()); } else { expAnim.enabled = true; StartCoroutine(Off2High()); } } public IEnumerator Off() { yield return new WaitForSecondsRealtime(0.1f); gameObject.SetActive(false); } public IEnumerator OffHigh(CircleCollider2D c) { yield return new WaitForSecondsRealtime(0.1f); c.enabled = false; } public IEnumerator Off2High() { yield return new WaitForSecondsRealtime(1.5f); gameObject.SetActive(false); } public void APEvirtual() { int cont = contacts.Length; if (cont != 0 &amp;&amp; firstAPEvirtual == true) { firstAPEvirtual = false; for (int i = 0; i &lt; cont; i++) { if (contacts[i] != null) { if (contacts[i].GetComponent&lt;PhysicsEmulation&gt;()) { contacts[i].GetComponent&lt;PhysicsEmulation&gt;().ExplosionPhysicsEmulation(explosion); } } } } } public void AnimFull() { sr.color = new Color(1f, 1f, 1f, 1f); sr.size = new Vector2(3f * radius, 3f * radius); return; } }</code> </pre><br></div></div><br>  Après avoir examiné l'ensemble du système de dégâts, j'ai décidé de le réécrire à fond.  Et cette fois, Damage a mis toutes les variations de dégâts possibles dans un script Damage et a créé une méthode ActionPhysicsEmulation similaire pour les blocs destructibles (au final, pour chaque type de dommage individuel, sa propre méthode optimisée a été écrite).  De plus, l'intensité des dégâts était déterminée par l'intensité de la "force" de l'objet (le script était uniquement sur le joueur). <br><br>  Et au final, seuls ces 3 puzzles étaient un cran au dessus de l'original.  Mais ce n'était pas une raison pour arrêter: je n'ai pas non plus oublié d'expérimenter tout au long du développement.  Il est donc apparu. <br><br>  Champ de force (désactive la gravité, ralentit et tue lentement) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-d/ai/yk/-daiykfxbws9lxxsalwbop6xblg.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script VelocityField</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class VelocityField : GlobalFunctions { public float percent = 10f; public float damage = 0.01f; public float heal = 0.01f; public GameObject[] contacts = new GameObject[0]; private HealthBar hb; private void Awake() { hb = GameObject.FindWithTag("MainCamera").GetComponent&lt;Management&gt;().healthBar; } private void FixedUpdate() { if (contacts.Length != 0) { for (int i = 0; i &lt; contacts.Length; i++) { if (contacts[i] != null) { if (contacts[i].GetComponent&lt;Rigidbody2D&gt;()) { float s = Time.fixedDeltaTime / 0.03f; Vector2 vel = contacts[i].GetComponent&lt;Rigidbody2D&gt;().velocity; contacts[i].GetComponent&lt;Rigidbody2D&gt;().velocity = vel / 100f * (100f - percent * s); } } else { contacts = Remove(contacts, i); } } } } private void OnTriggerEnter2D(Collider2D collision) { if (collision.GetComponent&lt;Rigidbody2D&gt;()) { Rigidbody2D rb2 = collision.GetComponent&lt;Rigidbody2D&gt;(); if (rb2.isKinematic == false) { VelocityInput vi = collision.GetComponent&lt;VelocityInput&gt;(); vi.fields = Add(vi.fields, gameObject); rb2.gravityScale = 0f; rb2.freezeRotation = true; vi.inVelocityField = true; if (collision.GetComponent&lt;Destroy&gt;()) { collision.GetComponent&lt;Destroy&gt;().ActiveTimerDeleteChange(300f); } if (collision.tag == "Player") { hb.StartVFRad(damage); } contacts = Add(contacts, collision.gameObject); } } } public void OnTriggerExit2D(Collider2D collision) { if (collision.GetComponent&lt;Rigidbody2D&gt;()) { Rigidbody2D rb2 = collision.GetComponent&lt;Rigidbody2D&gt;(); if (rb2.isKinematic == false) { VelocityInput vi = collision.GetComponent&lt;VelocityInput&gt;(); vi.fields = Remove(vi.fields, gameObject); if (vi.fields.Length != 0) { rb2.gravityScale = 0f; rb2.freezeRotation = true; vi.inVelocityField = true; } else { rb2.gravityScale = 1f; rb2.freezeRotation = false; vi.inVelocityField = false; } if (collision.GetComponent&lt;Destroy&gt;()) { collision.GetComponent&lt;Destroy&gt;().ActiveTimerDeleteChange(60f); } if (collision.tag == "Player") { hb.EndVFRad(heal); } contacts = Remove(contacts, collision.gameObject); } } } }</code> </pre><br></div></div><br>  Stomp (il a tué les joueurs en les écrasant) <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ag/id/eu/agideu1-kir4r8z4xgmawwhcp_c.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Tramp Script</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class TrampAnim : MonoBehaviour { public float speed = 0.1f; public float speedOffset = 0.01f; public float damage = 1f; private float sc; private float maxDis; public Vector3 start; public Vector3 end; public TrampAnim ender; public bool active = true; public bool trigPlayer = false; private AudioSet audioSet; private bool audioAct; private Transform tr; private HealthBar hb; public int count = 0; public void Start() { if (active) { tr = transform; maxDis = Vector2.Distance(start, end); sc = Vector2.Distance(tr.localPosition, start) / maxDis; hb = Camera.main.GetComponent&lt;Management&gt;().healthBar; audioAct = GetComponent&lt;AudioSet&gt;(); if (audioAct) { audioSet = GetComponent&lt;AudioSet&gt;(); } } } public void Update() { if (active) { float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); if (count == 0) { tr.localPosition = Vector2.MoveTowards(tr.localPosition, end, (speed * sc + speedOffset) * s); if (tr.localPosition == end) { count = 1; if (trigPlayer &amp;&amp; ender.trigPlayer) { hb.Damage(100f, tag, Vector2.zero); } if (audioAct) { audioSet.SetMusic(); } } } else { tr.localPosition = Vector2.MoveTowards(tr.localPosition, start, (speed * sc + speedOffset) * s); if (tr.localPosition == start) { count = 0; } } sc = Vector2.Distance(tr.localPosition, start) / maxDis; } } public void OnCollisionEnter2D(Collision2D collision) { Transform trans = collision.transform; string tag = trans.tag; if (tag == "Player") { trigPlayer = true; } else if (active == false) { if (trans.GetComponent&lt;PhysicsEmulation&gt;()) { trans.GetComponent&lt;PhysicsEmulation&gt;().TrampAnimPhysicsEmulation(GetComponent&lt;TrampAnim&gt;()); } } } public void OnCollisionExit2D(Collision2D collision) { string tag = collision.transform.tag; if (tag == "Player") { trigPlayer = false; } } }</code> </pre><br></div></div><br>  Rayonnement (qui réduit lentement la santé) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/w2/mi/bzw2mi2pn0jk6lzbqiu4ze-we5u.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Rayonnement du script</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class Radiation : MonoBehaviour { public bool isActiveRadiation = false; private Management m; private HealthBar hb; private void Awake() { gameObject.SetActive(PlayerPrefs.GetString("ai") == "off"); m = GameObject.FindWithTag("MainCamera").GetComponent&lt;Management&gt;(); hb = m.healthBar; } private void Start() { StartCoroutine(RadiationDamage()); } public IEnumerator RadiationDamage() { yield return new WaitForSeconds(0.0002f); if (isActiveRadiation) { hb.StraightDamage(0.0002f, "Radiation"); } StartCoroutine(RadiationDamage()); } public void OnTriggerEnter2D(Collider2D collision) { if (collision.tag == "Player") { isActiveRadiation = true; hb.animator.SetBool("isVisible", true); } } public void OnTriggerExit2D(Collider2D collision) { if (collision.tag == "Player") { isActiveRadiation = false; hb.animator.SetBool("isVisible", false); if (hb.healthBarImage.fillAmount == 0f) { m.StartGraphics(); } } } public void OnCollisionEnter2D(Collision2D collision) { if (collision.transform.tag == "Player") { hb.animator.SetBool("isVisible", false); PlayerPrefs.SetString("ai", "on"); gameObject.SetActive(false); } } }</code> </pre><br></div></div><br>  Piège (une balle bleue qui tue lorsqu'elle est touchée, qui fait référence au jeu le plus dur du monde) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/wg/6y/ohwg6ye0n_7lvpk_gt8igkknjye.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script DeathlessScript</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class DeathlessScript : MonoBehaviour { private HealthBar hb; private void Awake() { hb = Camera.main.GetComponent&lt;Management&gt;().healthBar; } public void OnTriggerEnter2D(Collider2D collision) { if (collision.tag == "Player") { hb.Damage(10f, tag, Vector2.zero); } } }</code> </pre><br></div></div><br>  Je n'ai pas enregistré tous ces types de dommages dans le script Damage, mais ils fonctionnaient généralement bien avec des béquilles.  Après cela, des mécaniciens supplémentaires sont arrivés. <br><br>  <i>Mécanique supplémentaire</i> <br><br>  Ils étaient variés.  Il y en avait pas mal, de sorte que tous étaient intéressants et pas assez pour être fonctionnels pour l'interaction avec la plupart des mécanismes de jeu. <br><br>  Les premières mécaniques de ce type ont été les portes.  Le tout premier et le plus fonctionnel de tous.  Certainement utile dans tous les endroits où des barrières fonctionnelles étaient nécessaires.  Il a également des fonctions supplémentaires: isActive pour déterminer l'état de démarrage et isState afin de fixer la position après l'activation (les noms sont mélangés, mais quand il a été remarqué, il était trop tard pour le réparer). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1j/by/if/1jbyifik8daournyzffkwxtubxk.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Script Gate</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class Gate : MonoBehaviour { [Header("StartSet")] public Vector2 gateScale = new Vector2(1, 4); public float speed = 0.1f; public bool isReverse = false; public bool isEnd = true; public Vector2 animSetGateScale = new Vector2(); public Vector2 target = new Vector2(); [Header("SpriteEditor")] public Sprite mainSprite; [Header("Assets")] public GameObject door1; public GameObject door2; private IEnumerator fixUpdate; private void Start() { SpriteRenderer ds1 = door1.GetComponent&lt;SpriteRenderer&gt;(); SpriteRenderer ds2 = door2.GetComponent&lt;SpriteRenderer&gt;(); ds1.sprite = mainSprite; ds2.sprite = mainSprite; if (isReverse == false) { animSetGateScale = target = gateScale; } fixUpdate = FixUpdate(); SetGate(animSetGateScale); } private IEnumerator FixUpdate() { yield return new WaitForSeconds(0.03f); if (animSetGateScale != target) { float s = Time.fixedDeltaTime / 0.03f; animSetGateScale = Vector2.MoveTowards(animSetGateScale, target, speed * s); SetGate(animSetGateScale); StartCoroutine(FixUpdate()); } } private void SetGate(Vector2 scale) { SpriteRenderer ds1 = door1.GetComponent&lt;SpriteRenderer&gt;(); SpriteRenderer ds2 = door2.GetComponent&lt;SpriteRenderer&gt;(); Vector2 size = new Vector2(mainSprite.texture.width, mainSprite.texture.height); float k = size.x / size.y; ds1.size = new Vector2(gateScale.x, scale.y / 2f); ds2.size = new Vector2(gateScale.x, scale.y / 2f); BoxCollider2D d1 = door1.GetComponent&lt;BoxCollider2D&gt;(); BoxCollider2D d2 = door2.GetComponent&lt;BoxCollider2D&gt;(); d1.size = new Vector2(gateScale.x, scale.y / 2f); d2.size = new Vector2(gateScale.x, scale.y / 2f); door1.transform.localScale = new Vector3(1f, 1f, 1f); door2.transform.localScale = new Vector3(1f, 1f, 1f); door1.transform.localPosition = new Vector3(0f, (gateScale.y / 2f) - (scale.y / 4f), 0f); door2.transform.localPosition = new Vector3(0f, -(gateScale.y / 2f) + (scale.y / 4f), 0f); } public void OnTriggerEnter2D(Collider2D collision) { if (collision.CompareTag("Player")) { if (isReverse == false) { target = Vector2.zero; } else { target = gateScale; } StopCoroutine(fixUpdate); fixUpdate = FixUpdate(); StartCoroutine(fixUpdate); } } private void OnTriggerExit2D(Collider2D collision) { if (collision.CompareTag("Player") &amp;&amp; isEnd == true) { if (isReverse == false) { target = gateScale; } else { target = Vector2.zero; } StopCoroutine(fixUpdate); fixUpdate = FixUpdate(); StartCoroutine(fixUpdate); } } }</code> </pre><br></div></div><br>  Les objets physiques possédaient des fonctionnalités similaires.  Non, ce ne sont pas des objets de destruction, ce ne sont que des objets physiques (bien qu'ils puissent également être détruits, mais n'ont pas utilisé cette mécanique).  Il n'y en a pas beaucoup dans les puzzles, mais ils se combinent bien avec d'autres mécanismes.  Par exemple, avec une porte: lorsqu'un objet touche un déclencheur de porte, la porte s'ouvre. <br><br>  Depuis que j'ai appris à «posséder le pouvoir», jusqu'à trois mécaniciens le contrôlaient.  Il s'agissait de déclencheurs avec le même code pour interagir avec les objets, mais chacun effectuait des tâches à sa manière.  Le premier était un champ de force (il ralentissait l'objet, multipliant la force par un certain facteur).  La seconde force ajoutée dans la direction du point et le point avait «gravité».  Le troisième a été fait par accident: lorsque le puzzle lié à la gravité zéro n'a pas fonctionné, ce script l'a enregistré.  En lui, l'objet change la direction de la force, sans la changer elle-même, son intensité. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5t/cs/f7/5tcsf7fu4hrzrspc8fdlph14zpk.png" width="500"></div><br><div class="spoiler">  <b class="spoiler_title">Comment ça marche</b> <div class="spoiler_text">  Tout d'abord, par le théorème de Pythagore, l'hypoténuse est calculée, qui est le coefficient du vecteur et est utile pour restaurer la force.  L'angle est ensuite calculé à l'aide de la fonction Atan2.  Après cela, offsetAngle est ajouté au coin et un nouveau vecteur est construit sur la base du sinus et du cosinus, qui est multiplié par un coefficient et une direction modifiée est obtenue sans force modifiée. <br><pre> <code class="plaintext hljs">public Vector2 RotateVector(Vector2 a, float offsetAngle) { float power = Mathf.Sqrt(ax * ax + ay * ay); float angle = Mathf.Atan2(ay, ax) * Mathf.Rad2Deg - 90f + offsetAngle; return Quaternion.Euler(0, 0, angle) * Vector2.up * power; }</code> </pre><br></div></div><br>  Là-dessus, toute ma fantaisie d'extras s'est tarie.  Oui, il y avait des idées comme une bombe sur une corde, un téléphérique, etc.  Mais ensuite, l'idée normale est venue: vous devez rendre le jeu à nouveau.  Pourtant, je serai honnête avec moi-même: la grande majorité des gens jouent à des jeux mobiles, et presque aucun ne jouera à mon jeu si le jeu est insupportablement compliqué.  J'ai décidé de commencer avec des puzzles qui ont tué le joueur d'un coup, mais je ne voulais pas changer les dégâts à cause de la destructibilité.  Et puis est venue l'idée d'une mécanique supplémentaire normale: des boosters ou des modificateurs. <br><br>  Selon le concept, ils ont apporté des améliorations temporaires associées à certaines valeurs de base.  Il y avait 5 boosters: traitement, immortalité, dilatation du temps (slow mo), changement de gravité et changement de masse du joueur. <br><br>  Mais cela ressemblait à une sorte de standard: des balles de déclenchement dispersées à travers le niveau pour faciliter le passage.  Et j'ai donc ajouté ces boosters au laser.  Changé un peu la mécanique et ça a fonctionné. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rf/fe/b_/rffeb_rey0t4dhbhwupljorcyva.png" width="500"></div><br>  Désormais, le laser dispose de 5 modes d'interaction avec le joueur: dégâts et soins, immortalité, dilatation temporelle (slow mo), changement de gravité et changement de masse du joueur.  C'est la même chose, mais avec une différence: le laser agit constamment sur le lecteur et si vous quittez le laser, l'effet disparaîtra immédiatement (ou après un certain temps).  Oui, les boosters ont presque les mêmes, mais les lasers ne sont pas standard (et donc tout le jeu). <br><br>  Le thème physique du jeu a permis de créer un trampoline, qui est généralement utilisé pour disperser le joueur avec la destruction ultérieure du mur (bien qu'il s'agisse d'un simple BoxCollider2D avec PhysicsMaterial, dans lequel le paramètre de rebond a été tordu pour différentes forces de rebond). <br><br>  Et le caractère sablonneux du jeu vous a permis de créer vos propres scripts d'animation.  Fondamentalement, ils ont déplacé l'objet d'un point à un autre ou ont fait pivoter l'objet.  Auparavant, ils avaient beaucoup plus de fonctions: la possibilité d'animer (par points) la rotation d'un objet, de changer l'échelle (par points), des étiquettes plus précises pour le début et la fin d'une animation d'un objet, etc.  Mais du fait qu'il s'agissait d'atavismes, qui au total consommaient frénétiquement la productivité, j'ai dû les supprimer au nom de l'optimisation.  Le script d'animation est utilisé partout où vous avez besoin de montrer une animation simple, car comme je l'ai dit: "L'original manquait très d'animations!"  Il n'y a que deux scripts: <br><br>  BasicAnimation et PointsAnimation. <br><br><div class="spoiler">  <b class="spoiler_title">Script d'animation de base</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class BasicAnimation : GlobalFunctions { public AnimationType animationType = AnimationType.Infinity; public float speedSpeed = 0.05f; public float rotation = 0f; private bool make = true; private bool animMake = false; private bool isMoved = false; private Transform tr; private float rotationActive = 0f; public void SetPos(bool pos, float m) { rotationActive = rotation * (pos ? 1 : m); } private void Start() { tr = transform; animMake = false; switch (animationType) { case AnimationType.Infinity: make = true; isMoved = true; rotationActive = rotation; break; case AnimationType.Start: make = false; isMoved = false; break; case AnimationType.End: make = true; isMoved = true; rotationActive = rotation; break; case AnimationType.All: make = false; isMoved = false; break; } } public void TimerAnim(float timer, bool anim) { StartAnim(anim); StartCoroutine(TimerTimerAnim(timer, anim)); } private IEnumerator TimerTimerAnim(float timer, bool anim) { yield return new WaitForSeconds(timer); EndAnim(anim); } public void StartAnim(bool anim) { make = true; if (anim == true) { animMake = true; isMoved = true; } else { rotationActive = rotation; } } public void EndAnim(bool anim) { if (anim == true) { animMake = true; isMoved = false; } else { make = false; rotationActive = 0f; } } private void FixedUpdate() { if (animMake == true) { if (isMoved == true) { if (rotationActive != rotation) { rotationActive = Mathf.MoveTowards(rotationActive, rotation, speedSpeed); } else { animMake = false; isMoved = false; } } else { if (rotationActive != 0f) { rotationActive = Mathf.MoveTowards(rotationActive, 0f, speedSpeed); } else { animMake = false; isMoved = true; } } } } private void Update() { if (make == true) { float rot = tr.localEulerAngles.z; float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); tr.localEulerAngles = new Vector3(0f, 0f, rot + rotationActive * s); } } }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">PointsAnimation Script</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class PointsAnimation : GlobalFunctions { public AnimationType animationType = AnimationType.Infinity; public float speedSpeedPosition = 0.001f; public float speedPosition = 0.1f; public Vector3[] pointsPosition = new Vector3[0]; public int counterPosition = 0; private float speedPositionActive = 0f; private int pointsPositionLength = 0; private bool make = true; private bool animMake = false; private bool isMoved = false; private Transform tr; public void SetPos(bool pos, float m) { speedPositionActive = speedPosition * (pos ? 1 : m); } private void Awake() { pointsPositionLength = pointsPosition.Length; tr = transform; switch (animationType) { case AnimationType.Infinity: make = true; isMoved = true; speedPositionActive = speedPosition; break; case AnimationType.Start: make = false; isMoved = false; break; case AnimationType.End: make = true; isMoved = true; speedPositionActive = speedPosition; break; case AnimationType.All: make = false; isMoved = false; break; } } public void TimerAnim(float timer, bool anim) { StartAnim(anim); StartCoroutine(TimerTimerAnim(timer, anim)); } private IEnumerator TimerTimerAnim(float timer, bool anim) { yield return new WaitForSeconds(timer); EndAnim(anim); } public void StartAnim(bool anim) { make = true; if (anim == true) { animMake = true; isMoved = true; } else { speedPositionActive = speedPosition; } } public void EndAnim(bool anim) { if (anim == true) { animMake = true; isMoved = false; } else { make = false; speedPositionActive = 0f; } } private void FixedUpdate() { if (animMake == true) { if (isMoved == true) { if (speedPositionActive != speedPosition) { Vector2 ends = new Vector2(-speedPosition, speedPosition); speedPositionActive = Mathf.MoveTowards(speedPositionActive, speedPosition, speedSpeedPosition); } else { animMake = false; isMoved = false; } } else { if (speedPositionActive != 0f) { Vector2 ends = new Vector2(-speedPosition, speedPosition); speedPositionActive = Mathf.MoveTowards(speedPositionActive, 0f, speedSpeedPosition); } else { animMake = false; isMoved = true; } } } } private void Update() { if (make) { if (tr.localPosition == pointsPosition[counterPosition]) { counterPosition++; if (counterPosition == pointsPositionLength) { counterPosition = 0; } } else { float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); tr.localPosition = Vector3.MoveTowards(tr.localPosition, pointsPosition[counterPosition], speedPositionActive * s); } } } }</code> </pre><br></div></div><br>  <i>UI</i> <br><br>  Par rapport à l'original, c'est un véritable chef-d'œuvre. <br><br>  A titre de comparaison, voici l'original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iu/i9/lz/iui9lzqmqtypz2cvs3cqacrz644.png" width="500"></div><br>  Voici la suite: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/d9/7t/ttd97thjtgvskcddhk1qwo5zwdc.png" width="500"></div><br>  Voici l'original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9m/9n/is/9m9nisamgqedkkpx1ou8498vdqa.png" width="500"></div><br>  Voici la suite: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yx/l7/3k/yxl73kah93pbxu8hjsckduyylh0.png" width="500"></div><br>  Ici orig ... je pense que c'est clair.  Le minimalisme dans la suite que j'ai évoquée, et au lieu du bouton de pause de couleur inappropriée et du minuteur qui interfère franchement, il y a maintenant un bouton de pause lokanique, quelque peu visible dans le coin inférieur gauche.  La suite gagne toujours le menu.  Contrairement à l'original, il y a des animations partout, et l'arrière-plan est de 11 shaders que j'ai accidentellement écrit dans le Shader Graph.  La fonctionnalité s'améliore également, il y a un paramètre graphique, des paramètres audio et musicaux séparés, une console qui vous permet de modifier la sauvegarde - il n'y a rien de tout cela dans le menu d'origine. <br><br>  Cela s'est avéré si bon parce que j'ai décidé de regarder d'autres jeux.  Ici et là, en général, j'ai pris (plutôt volé) le meilleur de partout.  Et voici ce que j'ai pris de spécial: <br><br><ol><li>  Menu de lecture <br>  Tiré de l'Aventure d'Alto, seules les expériences se sont transformées en ridicule, blagues, commentaires ironiques, etc. </li><li>  Pause <br>  Également d'Alto, mais pas si fonctionnel, mais il s'intègre plus facilement et joue plus facilement. </li><li>  Paramètres <br>  Partiellement tiré du vecteur 2, à savoir la forme du menu et des curseurs de volume. <br>  Il en a pris un peu en général, mais sinon il a tout fait tout seul. </li></ol><br>  <i>La console</i> <br><br>  Tout d'abord, faites une réserve sur le fonctionnement de la conservation.  Il y a deux variables responsables de la conservation globale et locale: ce sont respectivement les chiffres de progression et d'ascenseurs.  La variable de progression est responsable de l'enregistrement entre les scènes, et la variable elevatorsave est responsable de l'enregistrement à l'intérieur de la scène.  Lorsque vous appuyez sur le bouton "Démarrer" ou "Redémarrer", le jeu transfère la progression vers la scène et fait apparaître le joueur lors de l'enregistrement sous le numéro d'ascenseur. <br><br>  La console vous permet de modifier ou de créer n'importe quelle variable.  Un outil aussi simple et puissant m'a été très utile pour tester le jeu et identifier les bogues qu'il contenait.  La console elle-même est une commande manuscrite qui imite d'autres consoles. <br><br><div class="spoiler">  <b class="spoiler_title">Script DebugConsole</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using UnityEngine.UI; using UnityEngine.SceneManagement; using System.Collections; public class DebugConsole : MonoBehaviour { public Animator animatorBlackScreen; public Language l; public InputField inputField; public Text textDebug; private bool access = false; public void AnalyzeText() { string txt = inputField.text.ToLower(); string[] output = new string[0]; string txtLoc = ""; for (int i = 0; i &lt; txt.Length; i++) { if (txt[i] == ' ') { if (txtLoc != "") { output = Add(output, txtLoc); txtLoc = ""; } } else { txtLoc = txtLoc + txt[i]; } } if (txtLoc != "") { output = Add(output, txtLoc); txtLoc = ""; } Analyze(output); } public void Analyze(string[] commands) { switch (commands[0]) { case "playerprefs": if (access == true) { if (commands.Length &lt; 2) { Log(l.ConsoleLanguage(1));//1 } else { switch (commands[1]) { case "f": case "float": float f = 0f; if (float.TryParse(commands[3], out f)) { PlayerPrefs.SetFloat(commands[2], float.Parse(commands[3])); Log(l.ConsoleLanguage(2, commands[2]));//2 } else { Log(l.ConsoleLanguage(3));//3 } break; case "i": case "int": int i = 0; if (int.TryParse(commands[3], out i)) { PlayerPrefs.SetInt(commands[2], int.Parse(commands[3])); Log(l.ConsoleLanguage(4, commands[2]));//4 } else { Log(l.ConsoleLanguage(5));//5 } break; case "s": case "string": PlayerPrefs.SetString(commands[2], commands[3]); Log(l.ConsoleLanguage(6, commands[2]));//6 break; case "clear": PlayerPrefs.DeleteAll(); SceneManager.LoadScene(0); break; default: Log(l.ConsoleLanguage(7, commands[1]));//7 break; } } } else { Log(l.ConsoleLanguage(8));//8 } break; case "next": if (access == true) { if (commands.Length &gt; 1) { switch (commands[1]) { case "level": int p = PlayerPrefs.GetInt("progress"); PlayerPrefs.SetInt("progress", p + 1); Log("ok level"); break; case "save": int s = PlayerPrefs.GetInt("elevatorsave"); PlayerPrefs.SetInt("elevatorsave", s + 1); Log("ok save"); break; case "start": PlayerPrefs.SetInt("elevatorsave", 0); Log("ok start"); break; case "end": PlayerPrefs.SetInt("elevatorsave", 1); Log("ok end"); break; } } } else { Log(l.ConsoleLanguage(8));//8 } break; case "echo": if (commands.Length == 1) { Log(l.ConsoleLanguage(9));//9 } else { switch (commands[1]) { case "vertogpro"://echo vertogpro access = true; Log(l.ConsoleLanguage(10));//10 break; default: Log(l.ConsoleLanguage(11));//11 break; } } break; case "restart": if (access == true) { SceneManager.LoadScene(0); } else { Log(l.ConsoleLanguage(12));//12 } break; case "authors": Log(l.ConsoleLanguage(13));//13 break; case "discharge": animatorBlackScreen.SetBool("isActive", true); PlayerPrefs.SetString("start", "key"); PlayerPrefs.SetString("language", "nothing"); PlayerPrefs.SetString("graphicsquality", "medium"); PlayerPrefs.SetFloat("sound", 0.5f); PlayerPrefs.SetFloat("music", 0.5f); PlayerPrefs.SetFloat("rotatenextlevel", 0f); PlayerPrefs.SetInt("elevatorsave", 0); PlayerPrefs.SetInt("progress", 1); PlayerPrefs.SetInt("deaths", 0); PlayerPrefs.SetInt("discharge", PlayerPrefs.GetInt("discharge") + 1); PlayerPrefs.SetInt("lastmenueffect", -1); PlayerPrefs.SetString("isshotmode", "false"); PlayerPrefs.SetString("boss1", "life"); PlayerPrefs.SetString("boss2", "life"); PlayerPrefs.SetString("ai", "off"); PlayerPrefs.SetString("boss3", "life"); PlayerPrefs.SetString("end", "none"); StartCoroutine(StartGame()); break; case "clear": Clear(); break; case "info": if (access == false) { Log(l.ConsoleLanguage(14));//14 } else { Log(l.ConsoleLanguage(15));//15 } break; default: Log(l.ConsoleLanguage(16, commands[0]));//16 break; } } public void Log(object message) { textDebug.text = message.ToString(); } public void Clear() { inputField.text = ""; textDebug.text = ""; } public string[] Add(string[] old, string addComponent) { string[] n = new string[old.Length + 1]; if (old.Length != 0) { for (int i = 0; i &lt; old.Length; i++) { n[i] = old[i]; } } n[old.Length] = addComponent; return n; } public IEnumerator StartGame() { yield return new WaitForSeconds(1f); SceneManager.LoadSceneAsync(0); } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et surtout pour vous, je vais y laisser une liste d'équipes liquides: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décharge - réinitialise la progression du jeu (et toutes les autres informations également) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> echo vertogpro - une équipe pour donner accès aux équipes de développement </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerprefs [type donné (string, int, float)] [nom de variable] [data] - modifie ou crée une variable. </font><font style="vertical-align: inherit;">Exemple: playerprefs int progress 14</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suivant - un sous-type pour une navigation de niveau simplifiée, avec ses propres commandes: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> start - sauvegarde au début du niveau (prochain démarrage) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> end - sauvegarde à la fin du niveau (fin suivante) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enregistrer - se téléporte à l'enregistrement suivant (enregistrement suivant) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> niveau - se téléporte au niveau suivant (niveau suivant) </font></font></li></ul></li></ol><br> <i></i> <br><br>        ,       ,    :   30 -  ,         .          ,  ,        (,   .)    -  asset store.       ,     .  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/81/ap/oz/81apoz9lyvlrkz-zr73c2y54qjo.png" width="500"></div><br>   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jz/gl/h3/jzglh35mj-d5ymacylqigsnmphw.png" width="500"></div><br> <i></i> <br><br>     ,     .     3 : <br><br><ol><li> ElevatorBase — ,     .     elevatorsave      . <br><br><div class="spoiler"> <b class="spoiler_title"> ElevatorBase</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class ElevatorBase : MonoBehaviour { public GameObject[] savers = new GameObject[0]; public float inputStartBlock = 1f; private GameUI gameUI; public void Awake() { int l = savers.Length; if (l != 0) { for (int i = 0; i &lt; l; i++) { if (savers[i] != null) { if (savers[i].GetComponent&lt;Saving&gt;()) { Saving saving = savers[i].GetComponent&lt;Saving&gt;(); saving.isFirst = false; saving.idElevatorBase = i; } else if (savers[i].GetComponent&lt;Elevator&gt;()) { savers[i].GetComponent&lt;Elevator&gt;().isFirst = false; } } } int es = PlayerPrefs.GetInt("elevatorsave"); if (savers[es] != null) { if (savers[es].GetComponent&lt;Saving&gt;()) { savers[es].GetComponent&lt;Saving&gt;().isFirst = true; } else if (savers[es].GetComponent&lt;Elevator&gt;()) { savers[es].GetComponent&lt;Elevator&gt;().isFirst = true; } } else { gameUI = GameObject.FindWithTag("Canvas").GetComponent&lt;GameUI&gt;(); StartCoroutine(BlockEnabled()); GameObject.Find("TipsInput").GetComponent&lt;TipsGamePlayInput&gt;().active = true; } } else { gameUI = GameObject.FindWithTag("Canvas").GetComponent&lt;GameUI&gt;(); gameUI.ChangeisBlocked(); } } public IEnumerator BlockEnabled() { yield return new WaitForSeconds(inputStartBlock); GameObject block = gameUI.block.gameObject; block.SetActive(false); } }</code> </pre></div></div><br></li><li> Saving — ,            ,   ,         elevatorsave  id. <br><br><div class="spoiler"> <b class="spoiler_title"> Saving</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class Saving : MonoBehaviour { public Saving[] savings; public Vector2 startPos; public float startRot; public bool isActive = true; public bool isFirst = true; public int idElevatorBase = 0; public TipsGamePlayInput tgpi; private GameObject player; private GameObject cam; private Transform trp; private GameUI gameui; private Management m; private Saving self; private void Start() { self = GetComponent&lt;Saving&gt;(); cam = GameObject.FindWithTag("MainCamera"); m = cam.GetComponent&lt;Management&gt;(); gameui = GameObject.FindWithTag("Canvas").GetComponent&lt;GameUI&gt;(); player = m.player; trp = player.GetComponent&lt;Transform&gt;(); if (isFirst) { trp.position = startPos; m.Set(startRot); OfferSaves(); } isActive = !isFirst; tgpi.SetActive(!isFirst); StartCoroutine(BlockFalse()); } public IEnumerator BlockFalse() { yield return new WaitForSeconds(1f); gameui.block.gameObject.SetActive(false); } private void OnTriggerEnter2D(Collider2D collision) { if (collision.CompareTag("Player") &amp;&amp; isActive == true) { isActive = false; PlayerPrefs.SetInt("elevatorsave", idElevatorBase); OfferSaves(); } } public void OfferSaves() { if (savings.Length != 0) { for (int i = 0; i &lt; savings.Length; i++) { savings[i].isActive = false; savings[i].tgpi.SetActive(false); } } } }</code> </pre></div></div><br></li><li> Elevator —   ,      .   :           (      ). <br><br><div class="spoiler"> <b class="spoiler_title"> Elevator</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class Elevator : GlobalFunctions { public Vector2 endPos; public Vector2 startPos; public int nextScene = 1; public int nextElevatorSave = 0; public float speed = 0.1f; public bool isFirst = true; public bool isActive = true; public bool isReverse = false; public bool isMake = false; private GameObject player; private Rigidbody2D rb; private Transform tr; private Transform trp; private GameUI gameui; private AudioBase audioBase; private Transform cam; private void Start() { audioBase = GameObject.FindWithTag("MainCamera").GetComponent&lt;AudioBase&gt;(); gameui = GameObject.FindWithTag("Canvas").GetComponent&lt;GameUI&gt;(); player = gameui.m.player; rb = player.GetComponent&lt;Rigidbody2D&gt;(); trp = player.GetComponent&lt;Transform&gt;(); tr = GetComponent&lt;Transform&gt;(); cam = gameui.m.transform; startPos = tr.position; if (isFirst) { trp.position = startPos; rb.velocity = new Vector2(); rb.gravityScale = 0f; gameui.m.Set(); } else { tr.position = endPos; isMake = true; } isActive = isFirst; isReverse = false; } private void OnTriggerEnter2D(Collider2D collision) { if (collision.CompareTag("Player") &amp;&amp; isMake == true) { isReverse = true; isActive = true; rb.velocity = new Vector2(); rb.gravityScale = 0f; gameui.block.gameObject.SetActive(true); PlayerPrefs.SetInt("elevatorsave", nextElevatorSave); gameui.animatorBlackScreenGame.SetBool("isActive", true); audioBase.LowerSound(0.05f, 16, 0, TypePlaying.Music); StartCoroutine(NumSaveRotate()); StartCoroutine(gameui.StartGame(1.5f, nextScene)); } } private IEnumerator NumSaveRotate() { yield return new WaitForSeconds(1.5f); PlayerPrefs.SetFloat("rotatenextlevel", Stable(cam.localEulerAngles.z, -180f, 180f)); } private void FixedUpdate() { if (isActive == true) { float s = Time.fixedDeltaTime / 0.03f; if (isReverse == false) { rb.velocity = new Vector2(); tr.position = Vector2.MoveTowards(tr.position, endPos, speed * s); trp.position = tr.position; if ((Vector2)tr.position == endPos) { isMake = true; isActive = false; rb.gravityScale = 1f; gameui.block.gameObject.SetActive(false); } } else if (isReverse == true) { tr.position = Vector2.MoveTowards(tr.position, startPos, speed * s); trp.position = tr.position; if (tr.position == (Vector3)startPos) { isActive = false; rb.gravityScale = 1f; } } } } }</code> </pre></div></div></li></ol><br> <i> </i> <br><br>    .        4  6 .    34 : 30 , 3   1  ().     2-3 ,   2      .     ,    : 10  =&gt; 1  =&gt; 10  =&gt; 2  =&gt; 10  =&gt; 3  =&gt;  . <br><br>     .  ,     .     ,     .     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/1y/fx/xv1yfxu-5xf9nzogz1ffuzc8wc0.png" width="350"></div><br>      ,         .         ,  ,       . ,     1000x1000 ,       : 1  = 1  =  . <br><br>      .      ,       ,        .  ,         ,     10-15  . <br><br>       : <br><br><ol><li>  ,          <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iv/hk/bo/ivhkbo6wfuraf7ccfqsafxuwz44.png" width="500"></div></li><li>   (   -  ) <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zb/6j/1v/zb6j1vbcr_ok_-dnessoj2qgdxk.png" width="500"></div></li><li>   <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ze/na/l8/zenal8v8mt8fbfxqz3ne8xdyt-e.png" width="500"></div></li><li>   <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_k/nf/8k/_knf8kp4cndzcc7u3ldbux2anqg.png" width="500"></div></li><li> ,     <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nq/bp/2v/nqbp2vgeiaca4ydxollwdcxsjk8.png" width="500"></div></li></ol><br>    ,          .     100       ,  .     : <br><br> 1     :    ,  5   .  ,    : ,    .        .      4 : 3           ,   .    . <br><br><div class="spoiler"> <b class="spoiler_title"> BossManagement1</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class BossManagement1 : GlobalFunctions { public float hp = 100f; public float speed = 0.2f; public bool startActivated = false; public bool activated = false; public bool activatedSaw = false; public bool activatedAngle = false; public bool activatedCoroutine = true; private bool active; private float maxhp; public Vector2 target; public Vector2 targetSaw1; public Vector2 targetSaw2; public Vector2 minBorder; public Vector2 maxBorder; public DeadBoss1 deadBoss; public GameObject backGround; public GameObject healthBar; public Transform tr; public Transform sawMain; public Transform saw1; public Transform saw2; public Arrow arrow; public AudioSet setStart; public AudioSet setEnd; public Transform player; public Power playerPower; private Transform bg, hb; private float targethp = 0f; private Vector2 startMove = new Vector2(-20f, 0f); public void Awake() { maxhp = hp; bg = backGround.transform; hb = healthBar.transform; } public void Start() { if (PlayerPrefs.GetString("boss1") == "death") { Dead(false); } } public void FixedUpdate() { if (startActivated &amp;&amp; !activatedCoroutine) { if ((Vector2)tr.position != startMove) { tr.position = Vector2.MoveTowards(tr.position, startMove, speed); saw1.position = Vector2.MoveTowards(saw1.position, startMove, speed); saw2.position = Vector2.MoveTowards(saw2.position, startMove, speed); } else { activatedCoroutine = true; startActivated = false; StartCoroutine(ActivatedOn()); } } if (activated) { if ((Vector2)tr.position != target) { tr.position = Vector2.MoveTowards(tr.position, target, speed); } else { activated = false; sawMain.localScale = new Vector2(0f, 0f); StartCoroutine(TargetRotate()); } } if (activatedSaw) { if ((Vector2)saw1.position != targetSaw1) { saw1.position = Vector2.MoveTowards(saw1.position, targetSaw1, speed); } else { float x = Random.Range(minBorder.x, maxBorder.x); float y = Random.Range(minBorder.y, maxBorder.y); targetSaw1 = new Vector2(x, y); } if ((Vector2)saw2.position != targetSaw2) { saw2.position = Vector2.MoveTowards(saw2.position, targetSaw2, speed); } else { float x = Random.Range(minBorder.x, maxBorder.x); float y = Random.Range(minBorder.y, maxBorder.y); targetSaw2 = new Vector2(x, y); } } if (activatedAngle) { Vector2 dir = player.position - tr.position; float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg; tr.localEulerAngles = new Vector3(0f, 0f, Mathf.LerpAngle(tr.localEulerAngles.z, angle, 0.1f)); } } public IEnumerator TargetRotate() { yield return new WaitForSeconds(3f + 3f * hp / maxhp); sawMain.localScale = new Vector2(6f, 6f); float x = Random.Range(minBorder.x, maxBorder.x); float y = Random.Range(minBorder.y, maxBorder.y); target = new Vector2(x, y); activated = true; } public IEnumerator ActivatedOn() { yield return new WaitForSeconds(3f); sawMain.localScale = new Vector2(6f, 6f); target = new Vector2(Random.Range(minBorder.x, maxBorder.x), Random.Range(minBorder.y, maxBorder.y)); targetSaw1 = new Vector2(Random.Range(minBorder.x, maxBorder.x), Random.Range(minBorder.y, maxBorder.y)); targetSaw2 = new Vector2(Random.Range(minBorder.x, maxBorder.x), Random.Range(minBorder.y, maxBorder.y)); activatedSaw = true; activated = true; arrow.isActive = true; } public IEnumerator ActivatedCoroutineOff() { yield return new WaitForSeconds(1f); activatedCoroutine = false; activatedAngle = true; } public void Update() { if (active == true) { if (hp != targethp) { float s = Time.fixedDeltaTime / 0.03f * (Time.deltaTime / 0.03f); hp = MoveToward(hp, targethp, speed * s, new Vector2(-0f, maxhp)); } else { active = false; if (targethp == 0f) { Dead(true); } } } UpdateHP(); } public void UpdateHP() { float h = hp / maxhp; bg.localScale = new Vector3(5f, 0.9f, 1f); hb.localScale = new Vector3(4.8f * h, 0.7f, 1f); hb.localPosition = new Vector3(-2.4f + 4.8f * h / 2f, 0f, 0f); } private bool oneTimeMusic = true; public void Damage(float damage) { if (oneTimeMusic == true) { oneTimeMusic = false; deadBoss.StartBoss(); deadBoss.Boom(); setStart.SetMusic(); startActivated = true; StartCoroutine(ActivatedCoroutineOff()); } if (hp != 0f) { targethp = Stable2(hp - damage, 0f, maxhp); speed = speed + damage * 0.02f; active = true; } } public void Dead(bool boom) { active = false; activated = false; activatedSaw = false; startActivated = false; activatedAngle = false; activatedCoroutine = false; backGround.SetActive(false); healthBar.SetActive(false); sawMain.gameObject.SetActive(false); saw1.gameObject.SetActive(false); saw2.gameObject.SetActive(false); setEnd.SetMusic(); arrow.obj.SetActive(false); PlayerPrefs.SetString("boss1", "death"); deadBoss.Dead(tr.position, boom); } public void OnCollisionEnter2D(Collision2D collision) { if (collision.transform.CompareTag("Player")) { Damage(playerPower.power); } } }</code> </pre><br></div></div><br> 2     ,      .    :       ,    .           .     :           : <br><br><ol><li> 2    </li><li> 2   ,     </li><li> 2    ,     </li><li> 2 ,     </li><li> 2 ,      2    </li></ol><br>       ,  :              ,      . <br><br><div class="spoiler"> <b class="spoiler_title"> BossManagement2</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; public class BossManagement2 : GlobalFunctions { public float hp = 100f; public float speed = 0.5f; public float speedRotate = 0.5f; public int stage = 1; public bool isAlive = true; public bool isActivated = false; public bool isMove = false; public bool isWorkingLaser = true; private float timeStamina = 0f; private float timeRetarget = 0f; public Vector2 region = Vector2.zero; public Vector3 target = Vector3.zero; public GameObject player; public Transform saw; public Transform laser1; public Transform laser2; public Laser laserL1; public Laser laserL2; public Transform laserOffset1; public Transform laserOffset2; public Explosion explosion; public GameObject explosionAsset; public CircleCollider2D trigStart; public BoxCollider2D laserDetected1; public BoxCollider2D laserDetected2; public GameObject saw1; public GameObject saw2; public Transform health; public Transform stamina; public SpriteRenderer srStamina; private Transform pl; private Transform tr; public Transform state; public Laser state1; public Laser state2; public Laser state3; public Laser state4; private Coroutine coroutineStamina; public SpriteRenderer bossBase; public SpriteRenderer laserD1; public SpriteRenderer laserD2; public Gate gateStart; public Gate gateEnd; public GameObject blockWin; public GameObject physicsIn; public GameObject stateLasers; public GameObject expStart; public AudioSet setStart; public AudioClip setEnd; public AudioBase audioBase; public void Awake() { bool isDeath = PlayerPrefs.GetString("boss2") == "death"; blockWin.SetActive(false); if (isDeath) { isAlive = false; gateStart.isReverse = true; gateEnd.isReverse = true; physicsIn.SetActive(false); stateLasers.SetActive(false); expStart.SetActive(false); gameObject.SetActive(false); } else { tr = transform; pl = player.transform; timeStamina = 5.4f / speedRotate / 100f; timeRetarget = 5.4f / speedRotate; saw.localScale = Vector3.zero; stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 0f); saw1.SetActive(false); saw2.SetActive(false); LaserDisable(); LaserBlockEnable(); } } public void Update() { if (isAlive) { if (isActivated == true) { switch (stage) { case 1: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw1.SetActive(true); saw2.SetActive(true); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget1()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; case 2: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw.localScale = Vector3.zero; saw1.SetActive(true); saw2.SetActive(true); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget2()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; case 3: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw.localScale = Vector3.zero; LaserEnable(); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget3()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; case 4: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw.localScale = Vector3.zero; LaserEnable(); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget4()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; case 5: if (isMove == true) { if (tr.position == target) { isMove = false; RotatePlayer(); saw.localScale = Vector3.zero; LaserEnable(); saw1.SetActive(false); saw2.SetActive(false); stamina.localScale = Vector3.zero; srStamina.color = new Color(0f, 0.5f, 1f, 1f); if (coroutineStamina != null) { StopCoroutine(coroutineStamina); } coroutineStamina = StartCoroutine(StaminaAnim(timeStamina, 100)); StartCoroutine(Retarget5()); } else { tr.position = Vector2.MoveTowards(tr.position, target, speed); } } break; } } else { if (trigStart.enabled == false) { isActivated = true; float musicValue = PlayerPrefs.GetFloat("music"); audioBase.UpSound(0.01f, 5, 0, TypePlaying.Music); explosion.health = 0f; explosion.StartCoroutineTimerOffsetExplosion(); RegionDetected(); LaserDisable(); target = Target(); } } } } public void FixedUpdate() { if (!isMove &amp;&amp; isActivated) { laserOffset1.localEulerAngles = new Vector3(0f, 0f, laserOffset1.localEulerAngles.z + speedRotate); laserOffset2.localEulerAngles = new Vector3(0f, 0f, laserOffset2.localEulerAngles.z + speedRotate); if (isWorkingLaser) { state.localEulerAngles = new Vector3(0f, 0f, state.localEulerAngles.z + speedRotate); } } } public void RotatePlayer() { Vector2 p = pl.position; float angle = Mathf.Atan2(py, px) * Mathf.Rad2Deg; laserOffset1.localEulerAngles = new Vector3(0f, 0f, angle); laserOffset2.localEulerAngles = new Vector3(0f, 0f, angle - 180f); } private Vector3[] posLasers = new Vector3[] { Vector3.zero, Vector3.zero}; public void TriggerLaserDefect(int id) { switch (id) { case 1: state1.active = false; state1.lr1.SetPositions(posLasers); break; case 2: state2.active = false; state2.lr1.SetPositions(posLasers); break; case 3: state3.active = false; state3.lr1.SetPositions(posLasers); break; case 4: state4.active = false; state4.lr1.SetPositions(posLasers); break; } if (!state1.active &amp;&amp; !state2.active &amp;&amp; !state3.active &amp;&amp; !state4.active) { isWorkingLaser = false; state1.active = false; state2.active = false; state3.active = false; state4.active = false; laserL1.active = false; laserL2.active = false; laser1.localPosition = Vector2.zero; laser2.localPosition = Vector2.zero; } } public void OnCollisionEnter2D(Collision2D collision) { if (collision.transform.tag == "Player") { hp = hp - pl.GetComponent&lt;Power&gt;().power; health.localScale = new Vector2(hp / 50f, hp / 50f); stage = 5 - (int)(hp / 25f); if (stage == 4) { LaserBlockDisable(); } if (hp &lt;= 0f &amp;&amp; isAlive == true) { audioBase.LowerSound(0.1f, 50, 0, TypePlaying.Music); audioBase.SetSound(setEnd, 0, 0.8f, TypePlaying.Music, true, 1f); GameObject deadInside = Instantiate(explosionAsset, pl.position, Quaternion.identity); deadInside.GetComponent&lt;Rigidbody2D&gt;().isKinematic = true; deadInside.transform.localScale = new Vector2(2f, 2f); Explosion exp = deadInside.GetComponent&lt;Explosion&gt;(); exp.radius = 2f; exp.health = 0f; exp.timeOffsetExplosion = 3f; exp.StartCoroutineTimerOffsetExplosion(); gateStart.OnTriggerEnter2D(player.GetComponent&lt;Collider2D&gt;()); gateEnd.OnTriggerEnter2D(player.GetComponent&lt;Collider2D&gt;()); PlayerPrefs.SetString("boss2", "death"); blockWin.SetActive(false); gameObject.SetActive(false); } } } public void OnTriggerEnter2D(Collider2D collision) { if (collision.tag == "Player") { blockWin.SetActive(true); trigStart.enabled = false; } } public void LaserEnable() { if (isWorkingLaser) { laserL1.active = true; laserL2.active = true; state1.active = false; state2.active = false; state3.active = false; state4.active = false; } laser1.localPosition = new Vector2(0f, -1f); laser2.localPosition = new Vector2(0f, -1f); return; } public void LaserDisable() { if (isWorkingLaser) { state1.active = true; state2.active = true; state3.active = true; state4.active = true; laserL1.active = false; laserL2.active = false; } laser1.localPosition = Vector2.zero; laser2.localPosition = Vector2.zero; return; } public void LaserBlockEnable() { laserDetected1.enabled = true; laserDetected2.enabled = true; } public void LaserBlockDisable() { laserDetected1.enabled = false; laserDetected2.enabled = false; } public void RegionDetected() { Vector2 result = Vector2.zero; Vector2 pos = pl.position; if (pos.x &gt; -45f &amp; pos.x &lt;= -30f) { result.x = 1; } else if (pos.x &gt; -30f &amp; pos.x &lt; -5f) { result.x = 2; } else if (pos.x &gt;= -5f &amp; pos.x &lt;= 5f) { result.x = 3; } else if (pos.x &gt; 5f &amp; pos.x &lt;= 30f) { result.x = 4; } else if (pos.x &gt;= 30f &amp; pos.x &lt; 45f) { result.x = 5; } if (pos.y &gt; -45f &amp; pos.y &lt;= -30f) { result.y = 1; } else if (pos.y &gt; -30f &amp; pos.y &lt; -5f) { result.y = 2; } else if (pos.y &gt;= -5f &amp; pos.y &lt;= 5f) { result.y = 3; } else if (pos.y &gt; 5f &amp; pos.y &lt;= 30f) { result.y = 4; } else if (pos.y &gt;= 30f &amp; pos.y &lt; 45f) { result.y = 5; } region = result; return; } private readonly Vector2[] aroundCloser = new Vector2[] { new Vector2(2, 2), new Vector2(2, 3), new Vector2(2, 4), new Vector2(3, 2), new Vector2(3, 4), new Vector2(4, 2), new Vector2(4, 3), new Vector2(4, 4) }; public Vector2 Target() { Vector2 result = Vector2.zero; if (region == new Vector2(3, 3)) { region = aroundCloser[Random.Range(0, 8)]; } switch (region.x) { case 1: result.x = Random.Range(-45f, -32f); break; case 2: result.x = Random.Range(-29f, -5f); break; case 3: result.x = Random.Range(-5f, 5f); break; case 4: result.x = Random.Range(5f, 29f); break; case 5: result.x = Random.Range(32f, 45f); break; } switch (region.y) { case 1: result.y = Random.Range(-45f, -32f); break; case 2: result.y = Random.Range(-29f, -5f); break; case 3: result.y = Random.Range(-5f, 5f); break; case 4: result.y = Random.Range(5f, 29f); break; case 5: result.y = Random.Range(32f, 45f); break; } isMove = true; return result; } public IEnumerator StaminaAnim(float time, int count) { yield return new WaitForSeconds(time); float sc = hp * (100f - count) / 5000f; stamina.localScale = new Vector2(sc, sc); if (count &gt; 1) { count = count - 1; coroutineStamina = StartCoroutine(StaminaAnim(time, count)); } } public IEnumerator Retarget1() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw1.SetActive(false); saw2.SetActive(false); RegionDetected(); target = Target(); } public IEnumerator Retarget2() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw.localScale = new Vector2(2f, 2f); saw1.SetActive(false); saw2.SetActive(false); RegionDetected(); target = Target(); } public IEnumerator Retarget3() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw.localScale = new Vector2(2f, 2f); LaserDisable(); RegionDetected(); target = Target(); } public IEnumerator Retarget4() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw.localScale = new Vector2(2f, 2f); LaserDisable(); RegionDetected(); target = Target(); } public IEnumerator Retarget5() { yield return new WaitForSeconds(timeRetarget); srStamina.color = new Color(0f, 0.5f, 1f, 0f); RotatePlayer(); saw.localScale = new Vector2(2f, 2f); saw1.SetActive(true); saw2.SetActive(true); LaserDisable(); RegionDetected(); target = Target(); } }</code> </pre><br></div></div><br> 3        !     raycast'.       ,   12 raycast',    ,        raycast'.    ,     .   raycast'    ?      ,   2    ,   raycast'  ,         ,    ,   -   .     :      (  —       )  ,    ,     .    5         3-4 .        ,          (    )    .        . <br><br>  : <br><br><ol><li>   ,         ,    . </li><li> 2 ,     Lerp     (    )       (      ,  -   ). </li><li> ,       ,   . </li><li> 2 ,          ,   . </li><li> 4 -,    </li></ol><br><div class="spoiler"> <b class="spoiler_title"> BossManagement3</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; public class BossManagement3 : MonoBehaviour { public float health = 100f; public Vector4[] boxs = new Vector4[0]; public int[] saw1Fields = new int[0]; public int[] saw2Fields = new int[0]; public int[] saw3Fields = new int[0]; public int[] laser1Fields = new int[0]; public int[] laser2Fields = new int[0]; public Transform trBoss; public SpriteRenderer srBoss; public BossTracing3 bt; public Transform saw1; public Transform saw2; public Transform saw3; public Transform laser; public Transform laser1; public Transform laser2; public Transform trap1; public Transform trap2; public Transform trap3; public Transform trap4; public LineRenderer lr1; public LineRenderer lr2; public TrailRenderer trail; public GameObject exp; public GameObject terminal1; public GameObject terminal2; public GameObject LaserTarget; public GameObject LaserMover; public GameObject TrapsMover; public GameObject SawMover; public GameObject SawsAroundMover; public Explosion explosion; public SpriteRenderer sr; public CircleCollider2D cc; public Animator animatorEnd; public bool isMove = false; public bool isMoveSaw1 = false; public bool isMoveSaw2 = false; public bool isMoveSaw3 = false; public bool isMoveLaser1 = false; public bool isMoveLaser2 = false; public bool isMoveTraps = false; public int loadScene = 35; public int fieldPlayer = 0; private bool isActive = true; private float maxHealth; private Vector2 target = Vector2.zero; private Vector2 saw1target = Vector2.zero; private Vector2 saw2target = Vector2.zero; private Vector2 saw3target = Vector2.zero; private Vector2 laser1target = Vector2.zero; private Vector2 laser2target = Vector2.zero; private Vector2 traptarget1 = Vector2.zero; private Vector2 traptarget2 = Vector2.zero; private Vector2 traptarget3 = Vector2.zero; private Vector2 traptarget4 = Vector2.zero; private Vector2 border = new Vector2(47f, 44.5f); private Vector2 borderSaw = new Vector2(46f, 43.5f); private Management m; public GameObject p { get; private set; } private HealthBar hb; private Transform tr; private Power ppl; private int lengthBoxs = 0; private bool isLife = true; public void Awake() { isActive = !(PlayerPrefs.GetString("boss1") == "life" &amp;&amp; PlayerPrefs.GetString("boss2") == "life"); terminal1.SetActive(!isActive); terminal2.SetActive(isActive); trail.enabled = PlayerPrefs.GetString("graphicsquality") != "low"; m = GameObject.FindWithTag("MainCamera").GetComponent&lt;Management&gt;(); lengthBoxs = boxs.Length; maxHealth = health; hb = m.healthBar; p = m.player; tr = p.transform; ppl = m.ppl; float c = health / maxHealth; srBoss.color = new Color(0f, 0f, c); } public void Start() { if (isActive == false) { return; } StartCoroutine(Mover()); fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[saw1Fields[fieldPlayer]]; saw1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[saw2Fields[fieldPlayer]]; saw2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[saw3Fields[fieldPlayer]]; saw3target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[laser1Fields[fieldPlayer]]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[laser2Fields[fieldPlayer]]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; saw1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[Random.Range(0, lengthBoxs)]; saw2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[Random.Range(0, lengthBoxs)]; saw3target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[Random.Range(0, lengthBoxs)]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[Random.Range(0, lengthBoxs)]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } TrapMover(); StartCoroutine(Laser1AIM()); StartCoroutine(Laser2AIM()); isMoveSaw1 = true; isMoveSaw2 = true; isMoveSaw3 = true; isMoveLaser1 = true; isMoveLaser2 = true; return; } public void SawMover1() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[saw1Fields[fieldPlayer]]; saw1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; saw1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } isMoveSaw1 = true; } public void SawMover2() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[saw2Fields[fieldPlayer]]; saw2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; saw2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } isMoveSaw2 = true; } public void SawMover3() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[saw3Fields[fieldPlayer]]; saw3target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; saw3target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } isMoveSaw3 = true; } public void LaserMover1() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[laser1Fields[fieldPlayer]]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } StartCoroutine(Laser1AIM()); isMoveLaser1 = true; } public void LaserMover2() { fieldPlayer = bt.BoxPos(tr.position); if (fieldPlayer &gt;= 0) { Vector4 r = boxs[laser2Fields[fieldPlayer]]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } else { Vector4 r = boxs[Random.Range(0, lengthBoxs)]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); } StartCoroutine(Laser2AIM()); isMoveLaser2 = true; } public void TrapMover() { traptarget1 = new Vector2(Random.Range(-border.x, border.x), Random.Range(-border.y, border.y)); traptarget2 = new Vector2(-traptarget1.x, -traptarget1.y); traptarget3 = new Vector2(-traptarget1.x, traptarget1.y); traptarget4 = new Vector2(traptarget1.x, -traptarget1.y); isMoveTraps = true; } public IEnumerator Laser1AIM() { yield return new WaitForSeconds(0.5f); Vector2 diff = tr.position; float rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg + 90f; laser1.rotation = Quaternion.Euler(0f, 0f, rot_z); } public IEnumerator Laser2AIM() { yield return new WaitForSeconds(0.5f); Vector2 diff = tr.position; float rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg + 90f; laser2.rotation = Quaternion.Euler(0f, 0f, rot_z); } public IEnumerator Mover() { yield return new WaitForSeconds(7.5f); if (isLife) { Vector2 diff = tr.position; float rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg + 90f; laser.rotation = Quaternion.Euler(0f, 0f, rot_z); target = bt.GetPosRaycast(); isMove = true; } } public void Update() { if (isActive == false) { return; } float s = Time.fixedDeltaTime / (0.03f / Time.timeScale); if (isMove) { trBoss.position = Vector2.MoveTowards(trBoss.position, target, s * 0.5f); if (trBoss.position == (Vector3)target) { isMove = false; if (isLife) { StartCoroutine(Mover()); } } } if (isMoveSaw1) { saw1.position = Vector2.MoveTowards(saw1.position, saw1target, s * 0.1f); if (saw1.position == (Vector3)saw1target) { isMoveSaw1 = false; if (isLife) { SawMover1(); } } } if (isMoveSaw2) { saw2.position = Vector2.MoveTowards(saw2.position, saw2target, s * 0.1f); if (saw2.position == (Vector3)saw2target) { isMoveSaw2 = false; if (isLife) { SawMover2(); } } } if (isMoveSaw3) { saw3.position = Vector2.MoveTowards(saw3.position, saw3target, s * 0.1f); if (saw3.position == (Vector3)saw3target) { isMoveSaw3 = false; if (isLife) { SawMover3(); } } } if (isMoveLaser1) { laser1.position = Vector2.Lerp(laser1.position, laser1target, s * 0.1f); if (laser1.position == (Vector3)laser1target) { isMoveLaser1 = false; if (isLife) { LaserMover1(); } } } if (isMoveLaser2) { laser2.position = Vector2.Lerp(laser2.position, laser2target, s * 0.1f); if (laser2.position == (Vector3)laser2target) { isMoveLaser2 = false; if (isLife) { LaserMover2(); } } } if (isMoveTraps) { trap1.position = Vector2.MoveTowards(trap1.position, traptarget1, s * 0.1f); trap2.position = Vector2.MoveTowards(trap2.position, traptarget2, s * 0.1f); trap3.position = Vector2.MoveTowards(trap3.position, traptarget3, s * 0.1f); trap4.position = Vector2.MoveTowards(trap4.position, traptarget4, s * 0.1f); lr1.SetPosition(0, trap1.position); lr1.SetPosition(1, trap2.position); lr2.SetPosition(0, trap3.position); lr2.SetPosition(1, trap4.position); if (trap1.position == (Vector3)traptarget1) { isMoveTraps = false; if (isLife) { TrapMover(); } } } } public void OnCollisionEnter2D(Collision2D collision) { if (collision.gameObject == p) { if (isActive == false) { isActive = true; Start(); } if (isMove == true) { hb.StraightDamage(10f, "Boss3"); } else { health = health - ppl.power; float c = health / maxHealth; srBoss.color = new Color(0f, 0f, c); trail.startColor = srBoss.color; if (health &lt;= 0f) { isLife = false; isMove = false; saw1target = trBoss.position; saw2target = trBoss.position; saw3target = trBoss.position; isMoveSaw1 = true; isMoveSaw2 = true; isMoveSaw3 = true; sr.enabled = false; cc.enabled = false; exp.SetActive(true); explosion.health = 0f; explosion.StartCoroutineTimerOffsetExplosion(); Vector2 diff = trBoss.position; float rot_z = Mathf.Atan2(diff.y, diff.x) * Mathf.Rad2Deg + 90f; laser.rotation = Quaternion.Euler(0f, 0f, rot_z); int fieldBoss = bt.BoxPos(trBoss.position); Vector4 r = boxs[laser1Fields[fieldBoss]]; laser1target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); r = boxs[laser2Fields[fieldBoss]]; laser2target = new Vector2(Random.Range(rz, rx), Random.Range(rw, ry)); StartCoroutine(Ended()); } } } } public void EndedCoroutine() { if (!isActive) { //Debug.Log("End"); isActive = true; StartCoroutine(Ended()); } } public IEnumerator Ended() { yield return new WaitForSeconds(6.5f); if (hb.healthBarImage.fillAmount != 0f) { animatorEnd.SetBool("isActive", true); StartCoroutine(EndedFunction()); } } public IEnumerator EndedFunction() { yield return new WaitForSeconds(1.5f); if (hb.healthBarImage.fillAmount != 0f) { PlayerPrefs.SetInt("progress", 35); SceneManager.LoadSceneAsync(loadScene); } } public void ControlDamagers(bool lt, bool lm, bool tm, bool sm, bool sam) { LaserTarget.SetActive(lt); LaserMover.SetActive(lm); TrapsMover.SetActive(tm); SawMover.SetActive(sm); SawsAroundMover.SetActive(sam); } }</code> </pre></div></div><br> <i>  </i> <br><br>      ,      ,    .           .       :  25 .     asset store.       freesound.org   . <br><br>         :    5  AudioSource   AudioBase   .       SetSound   , ,  (  )   .       (  )  IEnumerator  ,          . <br><br><div class="spoiler"> <b class="spoiler_title"> AudioBase</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using System.Collections; public class AudioBase : GlobalFunctions { public AudioSource[] layerSounds = new AudioSource[0]; public GameObject music; private float musicValue, soundValue; private int lengthLayerSounds = 0; private bool soundActive = true; private Coroutine offsetActive; private int lowerSoundCoroutineCounter = 100; private int upSoundCoroutineCounter = 0; public void Awake() { soundActive = PlayerPrefs.GetString("graphicsquality") != "low"; musicValue = PlayerPrefs.GetFloat("music"); soundValue = PlayerPrefs.GetFloat("sound"); lengthLayerSounds = layerSounds.Length; for (int i = 0; i &lt; lengthLayerSounds; i++) { layerSounds[i].enabled = false; } } public void LowerSound(float timer, int upd, int id, TypePlaying typePlaying) { lowerSoundCoroutineCounter = upd; if (typePlaying == TypePlaying.Music) { StartCoroutine(LowerSoundCoroutine(timer, upd, id, musicValue)); } else { StartCoroutine(LowerSoundCoroutine(timer, upd, id, soundValue)); } } public void UpSound(float timer, int upd, int id, TypePlaying typePlaying) { upSoundCoroutineCounter = 0; if (typePlaying == TypePlaying.Music) { StartCoroutine(UpSoundCoroutine(timer, upd, id, musicValue)); } else { StartCoroutine(UpSoundCoroutine(timer, upd, id, soundValue)); } } public IEnumerator LowerSoundCoroutine(float timer, int upd, int id, float volumeSen) { yield return new WaitForSeconds(timer); layerSounds[id].volume = Stable2((layerSounds[id].volume / volumeSen - timer) * volumeSen, 0f, 1f); if (lowerSoundCoroutineCounter &gt; 1) { StartCoroutine(LowerSoundCoroutine(timer, upd, id, volumeSen)); lowerSoundCoroutineCounter -= 1; } } public IEnumerator UpSoundCoroutine(float timer, int upd, int id, float volumeSen) { yield return new WaitForSeconds(timer); layerSounds[id].volume = Stable2((layerSounds[id].volume / volumeSen + timer) * volumeSen, 0f, 1f); if (upSoundCoroutineCounter &lt; upd) { StartCoroutine(UpSoundCoroutine(timer, upd, id, volumeSen)); upSoundCoroutineCounter += 1; } } public void UpdateSound() { if (soundActive) { float time = Time.timeScale; for (int i = 0; i &lt; lengthLayerSounds; i++) { AudioSource audioSource = layerSounds[i]; if (audioSource.enabled == true) { audioSource.pitch = time; } } } } public void SetSound(AudioClip audioClip, int layerSound, float volume, TypePlaying typePlaying, bool loop, float time) { StartCoroutine(SetSoundTime(audioClip, layerSound, volume, typePlaying, loop, time)); } public IEnumerator SetSoundTime(AudioClip audioClip, int layerSound, float volume, TypePlaying typePlaying, bool loop, float time) { yield return new WaitForSeconds(time); SetSound(audioClip, layerSound, volume, typePlaying, loop); } public void SetSound(AudioClip audioClip, int layerSound, float volume, TypePlaying typePlaying, bool loop) { if (volume == 0f) { return; } if (soundActive) { AudioSource audioSource = layerSounds[layerSound]; audioSource.enabled = true; audioSource.clip = audioClip; audioSource.loop = loop; if (typePlaying == TypePlaying.Sound) { audioSource.volume = soundValue * volume; } else { audioSource.volume = musicValue * volume; } audioSource.Play(); if (offsetActive != null) { StopCoroutine(offsetActive); offsetActive = null; } if (!loop) { offsetActive = StartCoroutine(Offet(layerSound, audioClip.length, audioSource)); } } } public IEnumerator Offet(int layerSound, float length, AudioSource audioSource) { yield return new WaitForSeconds(length); if (audioSource.clip == layerSounds[layerSound].clip) { AudioSource audioSource2 = layerSounds[layerSound]; audioSource2.Stop(); audioSource2.enabled = false; } } }</code> </pre><br></div></div><br>    Tramp ()    :      ,    ,   .                 ,      .        ,      . <br><br> <i></i> <br><br> ,     .     2 :        ,    .     (,  ,      ). <br><br>    3 :        32.     :              .    32  :   ,         (   ).        ,     3 .        ,     .  ,  . <br><br>   4: , ,   .    2 :     3 .    : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  ,  3        .     ,           (    ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ic/7y/5q/ic7y5qybvgsqkntsirrs0vo2x50.png" width="250"></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  Je vous remercie <br>     <br>      <br>       <br>     <br>   <br>   </div></div></div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  ,  3        .      («» ),         ( ). <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zg/1y/ns/zg1yns6xsbmhbqw8ecailcmj9nc.png" width="250"></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">    <br>      <br>    <br>         <br>   -1 </div></div></div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  ,  3       .            ,  ,    … <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dt/up/xp/dtupxp-eviq15ssct_eyj-926dq.png" width="250"></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  Salut <br>     <br> ,     <br>      <br>    <br>     <br>     <br>   </div></div></div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">  ,  3         .     ,     -   (!)    . ( ,    ) <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"> - <br> ,  -   <br> ,      <br>     <br> ,  ,    <br>    … <br> , , ,  ,   ... </div></div></div></div><br>      ?        - .     . ,    «  »              . <br><br> <i></i> <br><br>       ,          , , ,   :   .      ,      (    ,  ).  ,             npc.        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cp/wz/jn/cpwzjnsg2h0mgb72x1aj7hrrzu8.png" width="300"></div><br>  ,        ,       ,    .     4   ,  ,      .           . <br><br>  ,          .        (          ).     :     ,            . <br><br>      :   2-3       40-50 .        ,            2-3 ,     (   )     .           - 160   . <br><br>   :      ,           .             ,    ,      .       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors de quoi parle le script? </font><font style="vertical-align: inherit;">Si c'est très simple, alors c'est l'intrigue Portal, seulement avec une histoire ouverte du monde et des personnages légèrement modifiés (plus moroses). </font><font style="vertical-align: inherit;">Soit dit en passant, ce scénario a une caractéristique: le sexe des objets inanimés est devenu moyen malgré la logique, le bon sens ou les règles de la langue russe (et d'autres langues aussi). </font><font style="vertical-align: inherit;">Si quelqu'un s'intéresse soudainement (enfin, soudainement), je laisserai le script complet et toutes les notes de jeu ici:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le script</font></font></b> <div class="spoiler_text">  : <br> , ,   (3 ) <br>  (1 ) <br> ,  RLIS (2 ) <br><br>  : <br><br> [1]   . [3]    :   ,   ,  ,  ,    ..      . [3]       ,    ,        ,   ([2]   , ,           ).  (4) <br><br> [4]         ,   . [5]     ,      . [6]          . [6]  ,    . [7]          .  (5) <br><br> [8]            :   . [9]      (- )      . [10]        (       ). (3) <br><br> [11]     . [12]   ,     ,  ,   . [13]           . [13]    ,           . (3) <br><br> [15]       ([14] —          ,      ,      ). [15]   (     )             ([16]            ).  (4) <br><br> [17]  . [18]     «». [18]            . [19]-       .  (4) <br><br> [20]      «». [21]   ,         . [22]      ,    . (3) <br><br> [23]    . [24]          . [25]     « ». (3) <br><br> [26]    ,       . [27]        ,  -  ,   . [28]       « ». [29]      .  (4) <br><br> [30] -   ( ?)            (     ,    ). [31]      . [32] ,          ([33]    ,         ),      - ,        . [34]     . [35]          ,  . [36]      (        ):     10  (10  = 1 )   . [X]- (  )        ,     (    2   1   ?). [37]   2 . (9) <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Album de coupures</font></font></b> <div class="spoiler_text">  (): <br><br> 1) {}    «» ,      .      ,       .   -   ,       . <br><br> 2) {} RLIS (reasonable likeness in simulation) —      .     . RLIS   ( )       —     . <br><br> 3) {}  RLIS     100  : , , , ,   ..    ,   , ,    .    ,       . <br><br> 4) {} ,        .     ,     ,    ,   ,       .    magnum opus      . <br><br> 5) {ARSotLotC}        ,       .    ,           .      ,      . <br><br> 6) {} -!!! -   ,       .    ,      ,     ,     .        ,  ,       ,      .        2 :      . <br><br> 7) {}       ,    backup       ,    .         :     ,       . ,          ,         . <br><br> 8) {}    .    ,              .    ,   ,         ,         (    ). <br><br> 9) {}   ,      ,   -.            ?  .          ,   .  ,    .   … <br><br> 10) {}    -   ,         .                  .      , … <br><br> 11) {ARSotLotC}      .  ,    «»   , ,    .            ,   …              . <br><br> 12) {}      ,      «»    .  .         «»,   .          .      . <br><br> 13) {}               ,       .     ,            .      ,         .                 . <br><br> 14) {}      ,     ,       (             ).  —   ,         .   :      ,           . <br><br> 15) {}  —            .    ,         .           .        ,       ,           . <br><br> 16) {}     ?        ,          .                 . <br><br> 17) {}     .       .      ,   «».         .       ,      ,       . <br><br> 18) {}       «».  , ?    ,          ,          . <br><br> 19) {}    «»     ,      .      ,     ,   ,       ,     .     .                  . <br><br> 20) {}   ''           ''. ,   , ''      '',          ,      . <br><br> 21) {}  ''       :       ,        ''.  ,     .     . <br><br> 22) {ARSotLotC}          :    ,     .        ,         . <br><br> 23) {}       ,           .                    ' '.          ,            . <br><br> 24) {}     ,   ,      .           ,   .   ,          . <br><br> 25) {}  .         ,  -  .      ,    ,   '  '. <br><br> 26) {}  .   ,      .                 .      ' '    ! <br><br> 27) {}   ' '   ,      .              .     :    ,    ,     . <br><br> 28) {ARSotLotC} - &lt; &gt;     .             .        .  ,    . <br><br> 29) {ARSotLotC}         .   ? ,         (- ,          )    ARSotLotC (Automatic Recording System of the Logs of the Complex). <br><br> 30) {ARSotLotC}   «»  ,        .          ,     ,   .  -    ,  backup .    ,    ,         . <br><br> 31) {ARSotLotC}  :      .     ,       .           .          backup. <br><br> 32) {ARSotLotC}   .         .     ,   .           . <br><br> 33) {ARSotLotC}                  (       backup').          . <br><br> 34) {ARSotLotC}    ,      .    ,      ,     10     .      ,     . Ps:        ,           ,  . <br><br> 35.1) {}   .  .     ' '  .     ,      ,       ''.  ,          -   ,    .            ' '. <br><br> 35.2)                                                   <br></div></div><br> <i> </i> <br><br>    —  ,        .      ,      2-3  (   ,       900  ,              GetChild()  ). <br><br>        ,      .       .        ,     . ,     .     : <br><br><pre> <code class="plaintext hljs">public class VelocityRotate : MonoBehaviour { public float rotate = 0f; public bool oneTime = true; private bool active = true; public void OnTriggerEnter2D(Collider2D collision) { if (active == true) { if (oneTime == true) { active = false; } Rigidbody2D rb = collision.GetComponent&lt;Rigidbody2D&gt;(); Vector2 vel = rb.velocity; rb.velocity = RotateVector(vel, rotate); } } public Vector2 RotateVector(Vector2 a, float offsetAngle) { float power = Mathf.Sqrt(ax * ax + ay * ay); float angle = Mathf.Atan2(ay, ax) * Mathf.Rad2Deg - 90f + offsetAngle; return Quaternion.Euler(0, 0, angle) * Vector2.up * power; } }</code> </pre><br>   ,     ?     : <br><br><pre> <code class="plaintext hljs">public class VelocityRotate : MonoBehaviour { //      public float rotate = 0f;//  public bool oneTime = true;//  private bool active = true;//  public void OnTriggerEnter2D(Collider2D collision) { if (active == true) { if (oneTime == true)//   { active = false; } //   Rigidbody2D rb = collision.GetComponent&lt;Rigidbody2D&gt;(); Vector2 vel = rb.velocity; rb.velocity = RotateVector(vel, rotate); } } public Vector2 RotateVector(Vector2 a, float offsetAngle)//   { float power = Mathf.Sqrt(ax * ax + ay * ay);//  float angle = Mathf.Atan2(ay, ax) * Mathf.Rad2Deg - 90f + offsetAngle; //    offset' return Quaternion.Euler(0, 0, angle) * Vector2.up * power; //        } }</code> </pre><br>       -      !         ,         . , ,   -    .  -,        ,  -,     -              -     .      :      ,       ,            . <br><br> <i>  </i> <br><br>   . !          ().    ,          (          ): <br><br><div class="spoiler"> <b class="spoiler_title">GB2 Checklist</b> <div class="spoiler_text"> : <br> // —   <br> \ —    <br><br> //1)     ,  ,  <br> //2)   :  <br> //3)        <br> //4)     TipsGamePlay <br> //5) ( )     <br> //6) 0:      <br> //7) 1:    () <br> //8)      <br> //9) 2:  2      <br> //10)                <br> //11) 4:    <br> //12)     layer Player <br> //13) 7:    ()      <br> //14) 8:           ( 1) <br> //15) 8:      <br> \16)         (    ) <br> \17) 8:           zero <br> //18)        <br> //19) 1:        <br> //20)    ,   <br> //21)        <br> //22)    timescale=0 <br> //23) 6:         <br> //24) 0:   <br> //25)     <br> //26) 7:    <br> //27) 7:    <br> //28)  AspectRatio <br> \29)      <br> //30)    <br> //31)    &lt;EXfgpy)b&gt;    //32) 7:    -  <br> //33)   ,       <br> //34) 9:     <br> //35) 9:      <br> //36) 'loop'   <br> //37) 10:   <br> //38) 11:   () <br> //39) 11:    <br> //40) 11:      <br> //41) 11:   <br> //42) 11:      <br> //43) 11:         <br> //44)    ( ) <br> /45) 12:    <br> \46)  Raycast   <br> \47)   ( static, dynamic, kinematic) <br> //48)     (next level, next start, next end) <br> \49) 1:          elevatorsave = 0 <br> \50)   offset angle,            <br> //51) 2:       <br> //52)    <br> //53) 7:       <br> //54)  next save <br> //55)      Dynamic Graph <br> //56) 11:        (    ) <br> 57) 11:   <br> //58) 9:    () <br> //59) 11: (  )    <br> //60) 12:   (   2 .     active   ,  .         . <br> 61) :     <br> //62) :  -   <br> //63)  :        <br> 64)    <br> //65)      (. ) <br> //66)      <br> //67)     HealthBar <br> 68) 0:          <br> //69)      localposition  position <br> 70) 14:    bool isPresentation <br> //71) 17:         2  4 <br> 72)    () <br> \73)      <br> //74)        <br> //75)      layer,     <br> //76)      <br> //77) 2:      1     <br> \78)     (     ) <br> //79)          <br> //80) 3:  ,         <br> //81)           <br> //82) 6:      ,      <br> //83) 6:     1  <br> //84) 6:       <br> //85) 7:    40.      . <br> //86)        <br> //87) 9:        <br> //88) 32:      <br> //89)  offsetAngle  elevator <br> //90) 11:     <br> //91)    (  ) <br> //92)      <br> //93)    <br> //94)    <br> //95) 13:     <br> //96) 15:      <br> /97)    3            isshotmode <br> //98) 17:       <br> //99) 18:  ,         <br> //100) 19:       (   ) <br> /101) 20:          <br> \102)    Tramp <br> //103) 20:         <br> \104)         <br> //105) 11:    ui   <br> //106)   text         arial <br> \107)              <br> //108)          <br> //109) 3:           <br> //110) 3:        <br> //111) 3:      ,    <br> //112)    ,     <br> //113)     () <br> //114) 4:     <br> //115)       (    ) <br> //116)       () <br> //117)  pointsAnimation  basicAnimation <br> //118) 7:   <br> //119) 9:      <br> //120)         AudioBase <br> //121)     pointsAnimation       <br> //122)       ,   ( ) <br> //123) 13:    HealthBar <br> //124) 13:  ,      <br> //125) 14:      kinematic (. ) <br> //126) 14:     <br> //127) 14:      ,    <br> //128)    velocityField   (     ,        ) <br> //129) 16:     velocityField <br> //130) 22:      <br> //131) 22:     <br> \132) 25:       <br> //133) 26:   <br> //134) 27:   <br> \135)       (  ) <br> //136)       <br> //137) :          <br> //138)    ( ) <br> //139)            <br> //140) 8:   <br> //141)      (  1.5-2,      -oneshot' <br> \142)  lerp         <br> //143)      ,  ,        (    ,         ) <br> //144) 22:       <br> //145) 11:          <br> //146) 11:      <br> //147) 11:     <br> //148)    <br> //149)  «Home»  «Menu» <br> //150)      <br> //151)       <br> //152)       <br> \153)        (  healthEnd) <br> //154) :       <br> //155) 33:    ,      <br> //156) 15:     (   0.1) <br> //157) 15:      velocityfield          healthbar <br> //158)     <br> //159)   basicAnimation (27) <br> //160)   (18, 27) <br> //161)     <br> \162) 19: -      <br> //163)     ( trigger  collision) <br> //164) 20:     50  250 <br> //165)      shotmode <br> //166) 27:        <br> //167) 28:     <br> //168) 17:    <br> //169) tag  boss3 <br> \170)   (  ,    ) <br> //171)    35 <br> //172)  :   ,  600    «I'll come back» <br> //173) 33:        <br><br> //174)      <br> //175) HealthBar       <br> //176)     (     damage- <br> //177) 27:         <br><br>    <br><br> 0) (0) <br> 1) (2) <br> 2) (2) <br> 3) (1) <br> 4) (1) <br> 5) (1) <br> 6) (1) <br> 7) (1) <br> 8) (2) <br> 9) (1) <br> 10) (0) <br> 11) (1) <br>  (13) <br> 12) (0) <br> 13) (2) <br> 14) (2) <br> 15) (0) <br> 16) (0) <br> 17) (1) <br> 18) (1) <br> 19) (3) <br> 20) (0) <br> 21) (3) <br> 22) (1) <br>  (13) <br> 23) (1) <br> 24) (1) <br> 25) (0) <br> 26) (0) <br> 27) (0) <br> 28) (3) <br> 29) (1) <br> 30) (2) <br> 31) (0) <br> 32) (0) <br> 33) (1) <br> 34) (1) <br>  (10) <br><br></div></div><br>     ,   .   ,     ,  ,       .   ,        .    ,  ,      ,          . <br><br>       ? <br><br><ol><li>         .   ,           .    2       3-4 .     ,     ,    :               10 .        ,                  .             . </li><li>        ,    .   ,        ,     ,   ,       . </li><li>        .       ,   « »   60%     .       ,    . </li></ol><br> <i></i> <br><br> -         30 .        :    Google Translate,   .       ,     ,         .    :      18 ,        ,  google ,       10 :   ,     (       ). <br><br>   -        .  ,            : <br><br><div class="spoiler"> <b class="spoiler_title"> StringLanguageMinimize</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">[System.Serializable] public class StringLanguageMinimize { public string english = ""; public string spanish = ""; public string italian = ""; public string german = ""; public string russian = ""; public string french = ""; public string portuguese = ""; public string korean = ""; public string chinese = ""; public string japan = ""; public string GetString() { string ret = ""; switch (PlayerPrefs.GetString("language")) { case "english": ret = english; break; case "spanish": ret = spanish; break; case "italian": ret = italian; break; case "german": ret = german; break; case "russian": ret = russian; break; case "french": ret = french; break; case "portuguese": ret = portuguese; break; case "korean": ret = korean; break; case "chinese": ret = chinese; break; case "japan": ret = japan; break; } return ret; } }</code> </pre><br></div></div><br>       : <br><div class="spoiler"> <b class="spoiler_title"> Terminal</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">[System.Serializable] public class StringLanguage { [TextArea] public string english = ""; [TextArea] public string spanish = ""; [TextArea] public string italian = ""; [TextArea] public string german = ""; [TextArea] public string russian = ""; [TextArea] public string french = ""; [TextArea] public string portuguese = ""; [TextArea] public string korean = ""; [TextArea] public string chinese = ""; [TextArea] public string japan = ""; public string GetString() { string ret = ""; switch (PlayerPrefs.GetString("language")) { case "english": ret = english; break; case "spanish": ret = spanish; break; case "italian": ret = italian; break; case "german": ret = german; break; case "russian": ret = russian; break; case "french": ret = french; break; case "portuguese": ret = portuguese; break; case "korean": ret = korean; break; case "chinese": ret = chinese; break; case "japan": ret = japan; break; } return ret; } }</code> </pre><br></div></div><br>     : <br><br><div class="spoiler"> <b class="spoiler_title"> Tips Input</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; public class TipsInput : MonoBehaviour { public int idTips = 0; public bool isPress2Read = true; public bool oneTime = true; private bool active = true; public GameObject[] copys; private Data data; private Press2Read p2r; private TipsInput ti; private void Awake() { data = GameObject.FindWithTag("MainCamera").GetComponent&lt;Data&gt;(); p2r = GameObject.FindWithTag("Press2Read").GetComponent&lt;Press2Read&gt;(); ti = GetComponent&lt;TipsInput&gt;(); } public void OnCollisionEnter2D(Collision2D collision) { if (collision.transform.CompareTag("Player")) { if (isPress2Read == false &amp;&amp; active == true) { Disable(); data.SetDialoge(idTips); if (copys.Length != 0) { for (int i = 0; i &lt; copys.Length; i++) { copys[i].GetComponent&lt;TipsInput&gt;().Disable(); } } } else if (isPress2Read == true) { p2r.Active(ti); } } } public void OnCollisionExit2D(Collision2D collision) { if (isPress2Read == true) { p2r.DeActive(); } } public void Disable() { if (oneTime == true) { active = false; } return; } }</code> </pre><br></div></div><br>   Data: <br><br><div class="spoiler"> <b class="spoiler_title">Data</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using UnityEngine; using UnityEngine.UI; using System.Collections; public class Data : GlobalFunctions { public Dialoge[] dialoges; public DeadPhrases[] deadPhrases; public GamePlay[] gameplay; [Space] public Tips tips; public AudioBase audioBase; public TipsGamePlay gamePlayTips; public Image slowmobonus; public Text fpsText; public float scaleTips = 1f; public float scaleGameUI = 1f; public float scaleSlowMo = 1f; private float speed = 0f; private float target = 1f; private float timeDuration = 1f; private int updFPS = 0; public void Awake() { scaleTips = scaleGameUI = scaleSlowMo = 1f; slowmobonus.color = new Color(0f, 0f, 0f, 0f); } public void Start() { StartCoroutine(SecFPSUpdate()); } public void SetDialoge(int id) { if (dialoges.Length != 0) { tips.SetActiveTrue(dialoges[id].dialogeStrings, dialoges[id].name); } } public void FalseP2R() { tips.SetFalse(); } public string GetDeadPhrase(string typeDead) { int idType = -1; for (int i = 0; i &lt; deadPhrases.Length; i++) { if (deadPhrases[i].typeDead == typeDead) { idType = i; break; } } if (idType == -1) { return typeDead; } int rand = Random.Range(0, deadPhrases[idType].deadPhrases.Length); return deadPhrases[idType].deadPhrases[rand].GetString(); } public string GetDeadPhrase2() { string ret = ""; switch (PlayerPrefs.GetString("language")) { case "english": ret = "Tap to continue"; break; case "spanish": ret = "Pulse para continuar"; break; case "italian": ret = "Tocca per continuare"; break; case "german": ret = "Tippen Sie, um fortzufahren"; break; case "russian": ret = "  "; break; case "french": ret = "Appuyez sur pour continuer"; break; case "portuguese": ret = "Clique para continuar"; break; case "korean": ret = "계속하려면 탭하세요"; break; case "chinese": ret = "点按即可继续"; break; case "japan": ret = "タップして続行します"; break; } return ret; } public void PauseGameUI(float time) { scaleGameUI = time; Update(); audioBase.UpdateSound(); } public void SetGamePlayTips(int id) { if (id == -1) { gamePlayTips.SetActiveTrueSaved(); } else { gamePlayTips.SetActiveTrue(gameplay[id]); } } public void SlowMo(float timeDuration2, float setSlowMo, float speed2) { speed = speed2; target = setSlowMo; timeDuration = timeDuration2; Update(); audioBase.UpdateSound(); } public void SlowMo(float timeDuration2) { scaleSlowMo = 0.1f; float sb = (1f - scaleSlowMo) * 0.3921569f; slowmobonus.color = new Color(0f, 0f, 0f, sb); Update(); audioBase.UpdateSound(); } public IEnumerator EndAnim(float timeDuration) { yield return new WaitForSeconds(timeDuration); End(); } public void End() { scaleSlowMo = 1f; float sb = (1f - scaleSlowMo) * 0.3921569f; slowmobonus.color = new Color(0f, 0f, 0f, sb); Update(); audioBase.UpdateSound(); } public void End2(float timeDuration2) { if (timeDuration2 == 0) { End(); return; } StartCoroutine(EndAnim(timeDuration2)); } private void Update() { Time.timeScale = scaleTips * scaleSlowMo * scaleGameUI; Time.fixedDeltaTime = 0.03f * scaleSlowMo * scaleTips; updFPS = updFPS + 1; return; } private IEnumerator SecFPSUpdate() { yield return new WaitForSeconds(1f); fpsText.text = "FPS: " + updFPS; updFPS = 0; StartCoroutine(SecFPSUpdate()); } }</code> </pre><br></div></div><br>    Tips,    : <br><br><div class="spoiler"> <b class="spoiler_title"> Tips</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System.Collections; using UnityEngine.UI; using UnityEngine; public class Tips : GlobalFunctions { public Data data; public Press2Read p2r; public GameUI gameUI; public GameObject obj; public AudioClip setClip; public Text nameText; public Text txt; private int textID = 0; private int textsID = 0; private AudioBase audioBase; private DialogeString textActive; private DialogeString[] textsActive; private bool isMass = false; [TextArea] public string end = ""; [TextArea] public string endPast = ""; public void Start() { audioBase = GameObject.FindWithTag("MainCamera").GetComponent&lt;AudioBase&gt;(); data.scaleTips = 1f; obj.SetActive(false); txt.text = ""; } public void SetActiveTrue(DialogeString text, StringLanguageMinimize name) { data.scaleTips = 0.1f; audioBase.layerSounds[0].volume /= 10f; obj.SetActive(true); nameText.text = name.GetString(); gameUI.pauseButton.SetActive(false); textActive = text; isMass = false; StartCoroutine(TimerFalse()); } public void SetActiveTrue(DialogeString[] texts, StringLanguageMinimize name) { data.scaleTips = 0.1f; audioBase.layerSounds[0].volume /= 10f; obj.SetActive(true); nameText.text = name.GetString(); gameUI.pauseButton.SetActive(false); textsActive = texts; isMass = true; StartCoroutine(TimersFalse()); } public IEnumerator TimerFalse(float time = 0.02f) { yield return new WaitForSecondsRealtime(time); string ds = textActive.dialogeString.GetString(); if (textID &lt; ds.Length &amp;&amp; ds != end) { audioBase.SetSound(setClip, 1, 0.5f, TypePlaying.Sound, false); end = end + ds.Substring(textID, 1); txt.text = endPast + end; textID = textID + 1; if (textID + 1 != ds.Length &amp;&amp; ds != end) { if (ds.Substring(textID + 1, 1) == ",") { StartCoroutine(TimersFalse(0.1f)); } else if (ds.Substring(textID + 1, 1) == ".") { StartCoroutine(TimersFalse(0.15f)); } else if (ds.Substring(textID + 1, 1) == "?") { StartCoroutine(TimersFalse(0.15f)); } else if (ds.Substring(textID + 1, 1) == ".") { StartCoroutine(TimersFalse(0.15f)); } else { StartCoroutine(TimersFalse()); } } else { StartCoroutine(TimersFalse()); } } else { endPast = txt.text; if (textActive.isSkip) { if (textActive.skipOffset == 0f) { SetActiveFalse(); } else { IsSkip(textActive.skipOffset); } } } } public IEnumerator TimersFalse(float time = 0.02f) { yield return new WaitForSecondsRealtime(time); string ds = textsActive[textsID].dialogeString.GetString(); if (textID &lt; ds.Length &amp;&amp; ds != end) { audioBase.SetSound(setClip, 1, 0.5f, TypePlaying.Sound, false); end = end + ds.Substring(textID, 1); txt.text = endPast + end; textID = textID + 1; string ds1 = textsActive[textsID].dialogeString.GetString(); if (textID + 1 != ds1.Length &amp;&amp; ds1 != end) { if (ds1.Substring(textID + 1, 1) == ",") { StartCoroutine(TimersFalse(0.1f)); } else if (ds1.Substring(textID + 1, 1) == ".") { StartCoroutine(TimersFalse(0.15f)); } else if (ds1.Substring(textID + 1, 1) == "?") { StartCoroutine(TimersFalse(0.15f)); } else if (ds1.Substring(textID + 1, 1) == "!") { StartCoroutine(TimersFalse(0.15f)); } else { StartCoroutine(TimersFalse()); } } else { StartCoroutine(TimersFalse()); } } else { endPast = txt.text; if (textsActive[textsID].isSkip) { if (textsActive[textsID].skipOffset == 0f) { SetActiveFalse(); } else { IsSkip(textsActive[textsID].skipOffset); } } } } public IEnumerator IsSkip(float time) { yield return new WaitForSecondsRealtime(time); SetActiveFalse(); } public void SetFalse() { obj.SetActive(false); gameUI.pauseButton.SetActive(true); end = ""; endPast = ""; txt.text = ""; textID = textsID = 0; data.scaleTips = 1f; audioBase.layerSounds[0].volume *= 10f; } public void SetActiveFalse() { if (isMass == false) { if (textActive.dialogeString.GetString() != end) { end = textActive.dialogeString.GetString(); if (textActive.isSkip) { SetActiveFalse(); } } else { obj.SetActive(false); gameUI.pauseButton.SetActive(true); end = ""; data.scaleTips = 1f; audioBase.layerSounds[0].volume *= 10f; } } else { if (textsActive[textsID].dialogeString.GetString() != end) { if (textsActive[textsID].isStep == true) { txt.text = end = textsActive[textsID].dialogeString.GetString(); if (textsActive[textsID].isSkip) { SetActiveFalse(); } } else { end = textsActive[textsID].dialogeString.GetString(); txt.text = endPast + end; } } else { if (textsID != textsActive.Length - 1) { textsID = textsID + 1; textID = 0; end = ""; if (textsActive[textsID].isStep == true) { endPast = ""; } StartCoroutine(TimersFalse()); } else { obj.SetActive(false); gameUI.pauseButton.SetActive(true); p2r.UnTap(); end = ""; endPast = ""; txt.text = ""; textID = textsID = 0; data.scaleTips = 1f; audioBase.layerSounds[0].volume *= 10f; } } } } }</code> </pre><br></div></div><br>  ,        ,     IEnumerator      (      ). <br><br> <i></i> <br><br>        1 .     :    ,    4    (     ),       .  ,    7 ,      -   .     ,   «»      . <br><br>      ,    ,      ,    .    :     ,    Reddit,       ,       ..     : <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kj/u-/dd/kju-ddrnggd-val9oytmh3b9-pi.jpeg" width="400"></div><br><br> <i></i> <br><br> ,    ,     ,    IT  3 !     16- ,    ,    13 ,    :      .      -    . <br><br>     ?   . , ,    -         ,    .        ,   ,      .                   .     ,        <br><br>        .     ,      .         ,    .   ,        ,     :         unity. <br><br>    - .       , ,  . <br><br> PS:   - : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/cm/se/iacmseb355qijfw6g2lsexdrtow.png" width="300"></div><br>      : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Whsn9B5t6Hc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468363/">https://habr.com/ru/post/fr468363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468341/index.html">Azure Cloud Shell sur Windows Terminal</a></li>
<li><a href="../fr468343/index.html">Jeff Bezos: «Aller dans l'espace pour le bien de la Terre»</a></li>
<li><a href="../fr468345/index.html">GitHub lance ses tentacules dans la gestion des CI / CD et des artefacts</a></li>
<li><a href="../fr468347/index.html">MetricKit. Analyse des performances des applications iOS</a></li>
<li><a href="../fr468351/index.html">Microstructure du marché et sélection adverse</a></li>
<li><a href="../fr468367/index.html">Amazon annonce un plan de réchauffement climatique</a></li>
<li><a href="../fr468369/index.html">Comment j'ai créé «WildMAN» - une parodie de nombreux jeux 8 bits et que j'ai récemment porté sur Android</a></li>
<li><a href="../fr468371/index.html">La conception du jeu à la vie. Téléchargement transparent ou immersion complète dans God of War 4</a></li>
<li><a href="../fr468377/index.html">8 histoires sur la Chine intérieure. Ce qui n'est pas montré aux étrangers</a></li>
<li><a href="../fr468379/index.html">Intelligence artificielle à usage général. ST, état actuel, perspectives</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>