<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèª ‚ú≥Ô∏è üßôüèº La API RESTful JSON m√°s simple en Elixir üßùüèª üë≥üèø üé¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øC√≥mo implementar el punto final de la API JSON en Elixir sin ning√∫n marco? 


 Del traductor: 
 El art√≠culo proporciona un ejemplo de una aplicaci√≥n ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La API RESTful JSON m√°s simple en Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444554/"><p>  <strong>¬øC√≥mo implementar el punto final de la API JSON en Elixir sin ning√∫n marco?</strong> </p><br><p>  <em>Del traductor:</em> <em><br></em>  <em>El art√≠culo proporciona un ejemplo de una aplicaci√≥n web muy simple que se puede considerar como Hello, World!</em>  <em>en crear la API m√°s simple en Elixir.</em> <em><br></em>  <em>El c√≥digo de muestra se modifica ligeramente para que coincida con las versiones actuales de las bibliotecas.</em> <em><br></em>  <em>El c√≥digo de muestra completo con los cambios se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/vheathen/elixir-">ver en GitHub</a> .</em> </p><br><p><img src="https://habrastorage.org/webt/4u/ez/x7/4uezx7-azvbu2fk6bbbkj1veqdw.jpeg"></p><br><h2 id="problemy-novogo-yazyka">  Nuevos desaf√≠os ling√º√≠sticos </h2><br><p>  Muchos desarrolladores vienen a Elixir desde el <strong>mundo de Ruby.</strong>  <strong>Este es un entorno muy maduro</strong> en t√©rminos de la cantidad de bibliotecas y marcos disponibles.  Y tal madurez a veces no es suficiente para m√≠ en Elixir.  Cuando necesito un servicio de terceros, el resultado de una b√∫squeda adecuada puede ser el siguiente: </p><a name="habracut"></a><br><ul><li>  hay una biblioteca oficial bien respaldada (muy rara); </li><li>  hay una biblioteca oficial, pero desactualizada o con errores (a veces sucede); </li><li>  Hay una biblioteca bien apoyada desarrollada por alguien de la comunidad (a veces de vez en cuando); </li><li>  hay una biblioteca desarrollada por alguien de la comunidad, pero ya no es compatible (un caso muy com√∫n); </li><li>  hay varias bibliotecas, cada una de las cuales est√° escrita por alguien para sus propias necesidades, y carece de las caracter√≠sticas necesarias (la opci√≥n m√°s popular); </li><li>  existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi propia</a> biblioteca, que combina todo lo mejor de lo anterior ... (se encuentra con demasiada frecuencia). </li></ul><br><h2 id="prostoe-json-api-na-eliksire">  API JSON simple en Elixir </h2><br><p><img src="https://habrastorage.org/webt/3k/3b/7u/3k3b7ugydkdw_7bcsz_hk3-ytdq.jpeg"></p><br><p>  Puede que se sorprenda, pero <strong>Ruby no siempre est√° <em>en el</em> carril</strong> ( <em>Ruby on Rails, ¬ørecuerda? - Nota del traductor</em> ).  No siempre se requiere comunicaci√≥n con la web para asistir.  Aunque en este caso particular, hablemos de la web. </p><br><p>  Cuando se trata de implementar un √∫nico punto final RESTful, generalmente hay muchas opciones: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicaci√≥n de rack</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hanami</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sinatra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uva</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rieles :: API</a> </li></ul><br><p>  Estos son ejemplos de herramientas que utilic√© personalmente.  Mis colegas son usuarios satisfechos de Sinatra.  Se las arreglaron para probar Hanami.  Puedo elegir cualquier opci√≥n que me convenga, incluso dependiendo de mi estado de √°nimo actual. </p><br><p>  Pero cuando cambi√© a Elixir, result√≥ que la elecci√≥n era limitada.  Aunque hay varios "marcos" alternativos (cuyos nombres por razones obvias no mencionar√© aqu√≠), ¬°es casi imposible usarlos! </p><br><p>  Pas√© todo el d√≠a clasificando todas las bibliotecas mencionadas en Internet.  Actuando como un bot de Slack, trat√© de <strong>implementar un servidor HTTP2 simple en Heroku</strong> , pero al final del d√≠a me di por vencido.  Literalmente, ninguna de las opciones que encontr√© fue capaz de implementar los requisitos b√°sicos. </p><br><h2 id="ne-vsegda-reshenie---phoenix">  No siempre es una soluci√≥n - Phoenix </h2><br><p>  <strong>Phoenix es mi marco web favorito, es solo que a veces es redundante.</strong>  No quer√≠a usarlo, arrastrando todo el marco al proyecto solo por un punto final;  y no importa que sea muy simple. </p><br><p>  Tampoco pod√≠a usar bibliotecas listas porque, como ya dije, todas las bibliotecas encontradas no satisfac√≠an mis necesidades (se requer√≠a enrutamiento b√°sico y soporte JSON), o no eran lo suficientemente convenientes para una implementaci√≥n f√°cil y r√°pida en Heroku.  Da un paso atr√°s, pens√©. </p><br><p><img src="https://habrastorage.org/webt/jf/qg/yl/jfqgylkj7urywy09ic2tqtmlnic.jpeg"></p><br><p>  Pero en realidad, Phoenix en s√≠ est√° construido sobre la base <em>de algo</em> , ¬øno? </p><br><h2 id="plug--cowboy-prihodyat-na-pomosch">  Plug &amp; Cowboy vienen al rescate </h2><br><p> Si necesita crear un servidor verdaderamente minimalista en Ruby, simplemente puede usar el <code>rack</code> , una interfaz modular para servidores web Ruby. </p><br><p>  Afortunadamente, algo similar est√° disponible en Elixir.  En este caso, utilizaremos los siguientes elementos: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cowboy</a> es un servidor HTTP peque√±o y r√°pido para Erlang / OTP que implementa la pila y el enrutamiento HTTP completos, optimizado para minimizar la latencia y el uso de memoria; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plug</a> : un conjunto de adaptadores para varios servidores web que se ejecutan en Erlang VM;  cada adaptador proporciona una interfaz directa al servidor web ubicado detr√°s de √©l; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">poison</a> es una biblioteca para procesar JSON en Elixir. </li></ul><br><h1 id="realizaciya">  Implementaci√≥n </h1><br><p>  Quiero implementar componentes como Endpoint (endpoint), Router (enrutador) y JSON Parser (controlador JSON).  Luego me gustar√≠a implementar el resultado en Heroku y poder procesar las solicitudes entrantes.  Veamos c√≥mo se puede lograr esto. </p><br><h2 id="prilozhenie">  App </h2><br><p>  Aseg√∫rese de que su proyecto Elixir contenga un supervisor.  Para hacer esto, cree un proyecto como este: </p><br><pre> <code class="plaintext hljs">mix new minimal_server --sup</code> </pre> <br><p>  Aseg√∫rese de que mix.exs contenga: </p><br><pre> <code class="plaintext hljs">def application do [ extra_applications: [:logger], mod: {MinimalServer.Application, []} ] end</code> </pre> <br><p>  y cree el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo</a> <code>lib/minimal_server/application.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do use Application def start(_type, _args), do: Supervisor.start_link(children(), opts()) defp children do [] end defp opts do [ strategy: :one_for_one, name: MinimalServer.Supervisor ] end end</code> </pre> <br><h2 id="biblioteki">  Bibliotecas </h2><br><p>  Las siguientes bibliotecas deben especificarse en <code>mix.exs</code> : </p><br><pre> <code class="plaintext hljs">defp deps do [ {:poison, "~&gt; 4.0"}, {:plug, "~&gt; 1.7"}, {:cowboy, "~&gt; 2.5"}, {:plug_cowboy, "~&gt; 2.0"} ] end</code> </pre> <br><p>  Luego descargue y compile las dependencias: </p><br><pre> <code class="plaintext hljs">mix do deps.get, deps.compile, compile</code> </pre> <br><h2 id="endpoint">  Punto final </h2><br><p>  Ahora todo est√° listo para crear un punto de entrada al servidor.  <code>lib/minimal_server/endpoint.ex</code> archivo <code>lib/minimal_server/endpoint.ex</code> con los siguientes contenidos: </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do use Plug.Router plug(:match) plug(Plug.Parsers, parsers: [:json], pass: ["application/json"], json_decoder: Poison ) plug(:dispatch) match _ do send_resp(conn, 404, "Requested page not found!") end end</code> </pre> <br><p>  El m√≥dulo <code>Plug</code> contiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Plug.Router</code></a> para redirigir las solicitudes entrantes seg√∫n la ruta utilizada y el m√©todo HTTP.  Al recibir la solicitud, el enrutador llamar√° al m√≥dulo <code>:match</code> , representado por la funci√≥n <code>match/2</code> , que es responsable de encontrar la ruta correspondiente, y luego lo redirigir√° al m√≥dulo <code>:dispatch</code> , que ejecutar√° el c√≥digo correspondiente. </p><br><p>  Dado que queremos que nuestra API sea compatible con JSON, necesitamos implementar <code>Plug.Parsers</code> .  Como procesa las <code>application/json</code> con el dado <code>:json_decoder</code> , lo usaremos para analizar el cuerpo de la solicitud. </p><br><p>  Como resultado, creamos una ruta temporal "cualquier solicitud" que coincide con todas las solicitudes y responde con el c√≥digo HTTP no encontrado (404). </p><br><h2 id="marshrutizator">  Enrutador </h2><br><p>  La implementaci√≥n de un enrutador ser√° el √∫ltimo paso para crear nuestra aplicaci√≥n.  Este es el √∫ltimo elemento de toda la canalizaci√≥n que creamos: comenzando con la recepci√≥n de una solicitud de un navegador web y terminando con la formaci√≥n de una respuesta. </p><br><p>  El enrutador procesar√° la solicitud entrante del cliente y enviar√° alg√∫n mensaje en el formato deseado ( <em>agregue el c√≥digo anterior al archivo <code>lib/minimal_server/router.ex</code> - nota del traductor</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Router do use Plug.Router plug(:match) plug(:dispatch) get "/" do conn |&gt; put_resp_content_type("application/json") |&gt; send_resp(200, Poison.encode!(message())) end defp message do %{ response_type: "in_channel", text: "Hello from BOT :)" } end end</code> </pre> <br><p>  En el m√≥dulo de <code>Router</code> anterior, la solicitud se procesar√° solo si se env√≠a por el m√©todo <code>GET</code> y se env√≠a a lo largo de la ruta <code>/</code> .  El m√≥dulo Router responder√° con un encabezado <code>Content-Type</code> contiene <code>application/json</code> y body: </p><br><pre> <code class="plaintext hljs">{ "response_type": "in_channel", "text": "Hello from BOT :)" }</code> </pre> <br><h2 id="soberyom-vsyo-vmeste">  Poniendo todo junto </h2><br><p>  Ahora es el momento de cambiar el m√≥dulo <code>Endpoint</code> para reenviar solicitudes al enrutador y modificar la <code>Application</code> para iniciar el m√≥dulo <code>Endpoint</code> . </p><br><p>  Lo primero se puede hacer agregando a <code>MinimalServer.Endpoint</code> [ <em>antes de la regla <code>match _ do ... end</code> - aprox.</em>  <em>traductor</em> ] cadena </p><br><pre> <code class="plaintext hljs">forward("/bot", to: MinimalServer.Router)</code> </pre> <br><p>  Esto garantiza que todas las solicitudes a <code>/bot</code> ser√°n enrutadas y procesadas por el m√≥dulo <code>Router</code> . </p><br><p>  El segundo puede implementarse agregando las funciones <code>child_spec/1</code> y <code>start_link/1</code> archivo <code>endpoint.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... def child_spec(opts) do %{ id: __MODULE__, start: {__MODULE__, :start_link, [opts]} } end def start_link(_opts), do: Plug.Cowboy.http(__MODULE__, []) end</code> </pre> <br><p>  Ahora puede modificar <code>application.ex</code> agregando <code>MinimalServer.Endpoint</code> a la lista devuelta por la funci√≥n <code>children/0</code> . </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do # ... defp children do [ MinimalServer.Endpoint ] end end</code> </pre> <br><p>  Para iniciar el servidor, solo haz: </p><br><pre> <code class="plaintext hljs">mix run --no-halt</code> </pre> <br><p>  Finalmente puede visitar la direcci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 4000 / bot</a> y ver nuestro mensaje :) </p><br><h1 id="razvertyvanie">  Despliegue </h1><br><p><img src="https://habrastorage.org/webt/kf/8j/cb/kf8jcbh1srxmbcpbxl_9yhnkckg.jpeg"></p><br><h2 id="konfig">  Config </h2><br><p>  Con mayor frecuencia, en un entorno local y para la operaci√≥n, el servidor est√° configurado de manera diferente.  Por lo tanto, necesitamos ingresar configuraciones separadas para cada uno de estos modos.  En primer lugar, <code>config.exs</code> nuestro <code>config.exs</code> agregando: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: 4000</code> </pre> <br><p>  En este caso, cuando la aplicaci√≥n se inicia en modo de <code>test</code> , <code>prod</code> y desarrollo, recibir√° el puerto 4000 si no se cambia esta configuraci√≥n. </p><br><div class="spoiler">  <b class="spoiler_title">Del traductor</b> <div class="spoiler_text"><p>  En este punto, el autor del texto original olvid√≥ mencionar c√≥mo modificar config.exs para que pueda usar diferentes opciones para diferentes modos.  Para hacer esto, agregue <code>import_config "#{Mix.env()}.exs"</code> ; en la √∫ltima l√≠nea en <code>config/config.exs</code> ;  el resultado es algo como: </p><br><pre> <code class="plaintext hljs">use Mix.Config config :minimal_server, MinimalServer.Endpoint, port: 4000 import_config "#{Mix.env()}.exs"</code> </pre> <br><p>  Despu√©s de eso, cree los archivos <code>prod.exs</code> , <code>test.exs</code> , <code>dev.exs</code> en el directorio de <code>config</code> coloc√°ndolo en cada l√≠nea: </p><br><pre> <code class="plaintext hljs">use Mix.Config</code> </pre> </div></div><br><p>  En producci√≥n, generalmente no queremos establecer el n√∫mero de puerto de forma r√≠gida, sino que dependemos de alguna variable de entorno del sistema, por ejemplo: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: "PORT" |&gt; System.get_env() |&gt; String.to_integer()</code> </pre> <br><p>  <em>Agregue el texto anterior al final de <code>config/prod.exs</code> - aprox.</em>  <em>traductor</em> </p><br><p>  Despu√©s de eso, se usar√° un valor fijo localmente y, en la operaci√≥n operativa, una configuraci√≥n de variables de entorno. </p><br><p>  Implementemos este esquema en <code>endpoint.ex</code> , ( <em>reemplazando la funci√≥n start_link / 1 - comentario del traductor</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... require Logger def start_link(_opts) do with {:ok, [port: port] = config} &lt;- Application.fetch_env(:minimal_server, __MODULE__) do Logger.info("Starting server at http://localhost:#{port}/") Plug.Adapters.Cowboy2.http(__MODULE__, [], config) end end end</code> </pre> <br><h2 id="heroku">  Heroku </h2><br><p>  Heroku ofrece la implementaci√≥n m√°s simple con un clic sin ninguna configuraci√≥n complicada.  Para implementar nuestro proyecto <strong>, necesita preparar un par de archivos simples y crear una aplicaci√≥n remota</strong> . </p><br><p><img src="https://habrastorage.org/webt/ro/x_/dh/rox_dhu_pwqqvdetmn-hwtjasb0.png"></p><br><p>  Despu√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instalar Heroku CLI,</a> puede crear una nueva aplicaci√≥n de la siguiente manera: </p><br><pre> <code class="plaintext hljs">$ heroku create minimal-server-habr Creating ‚¨¢ minimal-server-habr... done https://minimal-server-habr.herokuapp.com/ | https://git.heroku.com/minimal-server-habr.git</code> </pre> <br><p>  Ahora agregue el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elixir Build Kit</a> a su aplicaci√≥n: </p><br><pre> <code class="plaintext hljs">heroku buildpacks:set \ https://github.com/HashNuke/heroku-buildpack-elixir.git</code> </pre> <br><p>  En el momento de esta traducci√≥n, las versiones actuales de Elixir y Erlang son (m√°s o menos): </p><br><pre> <code class="plaintext hljs">erlang_version=21.1 elixir_version=1.8.1</code> </pre> <br><p>  Para configurar el kit de construcci√≥n en s√≠, agregue las l√≠neas anteriores al archivo <code>elixir_buildpack.config</code> . </p><br><p>  El √∫ltimo paso es crear un Procfile y, de nuevo, es muy simple: </p><br><pre> <code class="plaintext hljs">web: mix run --no-halt</code> </pre> <br><p>  <em>Nota del traductor: para evitar un error durante la compilaci√≥n en Heroku, debe establecer el valor de las variables de entorno que se utilizan en la aplicaci√≥n:</em> </p><br><pre> <code class="plaintext hljs">$ heroku config:set PORT=4000 Setting PORT and restarting ‚¨¢ minimal-server-habr... done, v5 PORT: 4000</code> </pre> <br><p>  Tan pronto como confirme nuevos archivos [ <em>usando git - aprox.</em>  <em>traductor</em> ], puedes subirlos a Heroku: </p><br><pre> <code class="plaintext hljs">$ git push heroku master Initializing repository, done. updating 'refs/heads/master' ...</code> </pre> <br><p>  ¬°Y eso es todo!  La aplicaci√≥n est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://minimal-server-habr.herokuapp.com</a> . </p><br><h1 id="rezyume">  Resumen </h1><br><p>  En este punto, ya entendi√≥ c√≥mo <strong>implementar la API JSON RESTful m√°s simple y el servidor HTTP en Elixir</strong> sin usar ning√∫n marco, usando solo 3 bibliotecas ( <em>4 - traductor aprox.</em> ). </p><br><p>  Cuando necesita proporcionar acceso a puntos finales simples, no necesita usar Phoenix cada vez, no importa cu√°n genial sea, as√≠ como cualquier otro marco. </p><br><p>  ¬øCurioso por qu√© no hay marcos confiables, bien probados y compatibles en alg√∫n lugar entre <code>plug</code> + <code>cowboy</code> y Phoenix?  ¬øQuiz√°s no hay una necesidad real de implementar cosas simples?  ¬øQuiz√°s cada compa√±√≠a usa su propia biblioteca?  ¬øO tal vez todos usan Phoenix o el enfoque presentado? </p><br><p><img src="https://habrastorage.org/webt/lr/bb/w-/lrbbw-w-ulfd0eatm5yabyl-sma.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/KamilLelonek/elixir-">El repositorio</a> , como siempre, est√° disponible en mi GitHub. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444554/">https://habr.com/ru/post/444554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444544/index.html">Algo sobre centros de datos distribuidos para empresas</a></li>
<li><a href="../444546/index.html">¬øC√≥mo y por qu√© trabajar m√°s lento? El m√©todo de Sergey Korolev</a></li>
<li><a href="../444548/index.html">Experiencia personal: c√≥mo participamos en la promoci√≥n de startups hispanas en Am√©rica Latina</a></li>
<li><a href="../444550/index.html">A la cuesti√≥n de la divisi√≥n</a></li>
<li><a href="../444552/index.html">TDMS Fairway. Trabaja con experiencia</a></li>
<li><a href="../444556/index.html">El color de la luna y el sol desde el espacio en los valores de RGB y temperatura de color.</a></li>
<li><a href="../444558/index.html">¬øQu√© hay de nuevo en CUBA 7?</a></li>
<li><a href="../444560/index.html">Te invitamos a la conferencia "Nubes. Tendencias de la moda ‚Äù26 de marzo de 2019</a></li>
<li><a href="../444562/index.html">Modernizaci√≥n de GHIDRA. Cargador para ron Sega Mega Drive</a></li>
<li><a href="../444564/index.html">Desarrollo de productos digitales con modelos mentales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>