<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩 💝 🙇🏽 Développement de l'IA en utilisant l'exemple du jeu Dicey Dungeons 👩🏻‍🤝‍👨🏽 🍧 🤚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendant environ un mois, je résolvais l'un des problèmes techniques les plus difficiles de mon nouveau jeu, Dicey Dungeons - une IA améliorée pour la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Développement de l'IA en utilisant l'exemple du jeu Dicey Dungeons</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432062/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/295/2a6/391/2952a639197eaa3a64690bd53e3fd0bd.jpg"></div><br>  Pendant environ un mois, je résolvais l'un des problèmes techniques les plus difficiles de mon nouveau jeu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dicey Dungeons</a> - une IA améliorée pour la version finale du jeu.  C'était un travail assez intéressant, et une grande partie était nouveau pour moi, alors j'ai décidé d'écrire un peu à ce sujet. <br><br>  Pour commencer, je vais vous expliquer: je ne suis pas un expert en théorie des ordinateurs, mais juste un de ceux qui ont suffisamment étudié la programmation pour créer des jeux vidéo, après quoi j'ai terminé mes études en ne saisissant que ce dont j'avais besoin.  Habituellement, je peux résoudre mes problèmes par moi-même, mais un vrai programmeur n'approuverait probablement pas mes décisions. <br><br>  J'ai essayé d'écrire un article à un niveau d'abstraction suffisamment élevé pour que les idées de base soient claires même pour les non-programmeurs.  Mais je ne suis pas un expert dans de telles choses, donc mes explications de la théorie peuvent être erronées.  Écrivez-moi à ce sujet dans les commentaires de l'original, je serai heureux de faire des changements! <br><br>  Eh bien, commençons par expliquer la tâche! <br><a name="habracut"></a><br><h2>  Défi </h2><br>  Si vous n'avez pas joué à Dicey Dungeons, je vais vous parler brièvement du jeu: il s'agit d'un RPG avec construction de deck, dans lequel chaque ennemi dispose d'un ensemble de cartes d'armes qui effectuent différentes actions.  De plus, ils lancent des dés!  Ensuite, ils mettent ces dés en armement pour infliger des dégâts, ou créer divers effets de statut, ou guérir, ou se défendre contre les dommages, etc.  Voici un exemple simple de la façon dont une petite grenouille utilise une grosse épée et un petit bouclier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/db8/48a/908db848a06270e8398e67313f9e16c7.gif"></div><br>  Un exemple plus compliqué: ce Jack de tous les métiers a une clé, ce qui vous permet de mettre deux dés ensemble (c'est-à-dire que 3 + 2 donneront 5 et 4 + 5 donneront 6 et 3).  Il a également un marteau (Hammer), qui impose un effet de «choc» au joueur, si vous lui en appliquez six, et un tireur de pois (Pea Shooter), qui fait peu de dégâts, mais il a un «compte à rebours», puis là, il est valable pour plusieurs mouvements. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/691/1d0/391/6911d0391f12dc6af58dd978907a6df3.gif"></div><br>  Autre complication importante: le jeu a des effets de statut qui modifient les capacités des adversaires.  Le plus important d'entre eux est Shock, qui désactive aléatoirement les armes;  le choc peut être supprimé en utilisant un cube supplémentaire dessus, et "Burn", qui met le feu aux cubes.  Pendant que les cubes brûlent, ils peuvent être utilisés, mais chaque utilisation coûtera 2 points de vie.  C'est ce qu'un bricoleur intelligent fait quand je mets le choc et la brûlure sur toutes ses armes et cubes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f92/36c/aae/f9236caaee860e0c026e31bd4390d6e3.gif"></div><br>  Bien sûr, il y a beaucoup plus dans le jeu, mais pour avoir une idée générale, cela suffit. <br><br>  Alors, notre tâche: comment amener l'IA à choisir la meilleure action pour son mouvement?  Comment peut-il savoir lequel des cubes brûlants éteindre, quel cube utiliser pour soulager les chocs et lequel conserver pour les armes importantes? <br><br><h2>  Comme avant </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/bac/9ef/dfbbac9efb2cad316eb7dd82aab379c5.png"></div><br>  Pendant longtemps, l'IA dans Dicey Dungeons n'avait qu'une seule règle: il a regardé toutes les armes de gauche à droite, a déterminé le meilleur cube qui pouvait être utilisé sur lui, puis l'a utilisé.  Cela a très bien fonctionné, mais il y avait des exceptions.  J'ai donc ajouté de nouvelles règles. <br><br>  Par exemple, j'ai surmonté le choc en examinant toutes les armes qui n'étaient pas soumises au choc, et en choisissant le cube que j'utiliserais dessus lorsque le choc a été retiré, puis j'ai marqué ce cube comme «réservé» pour l'avenir.  J'ai travaillé avec des cubes en train de brûler comme ceci: j'ai vérifié si j'avais assez de santé pour les éteindre, et j'ai choisi aléatoirement de le faire. <br><br>  J'ai ajouté règle par règle pour tout ce que je pouvais imaginer, et en conséquence j'ai eu une IA qui semblait fonctionner!  En fait, il est étonnant de constater à quel point cette imbrication de différentes règles s'est révélée - l'IA dans Dicey Dungeons peut ne pas toujours prendre la bonne décision, mais elle a toujours été au moins acceptable.  Du moins pour un jeu encore en développement. <br><br>  Mais au fil du temps, le système consistant à ajouter constamment de nouvelles règles a commencé à se fissurer.  Les gens ont découvert des exploits qui ont fait que l'IA se comporte bêtement.  Par exemple, avec la bonne approche, vous pourriez déjouer l'un des boss afin qu'il n'attaque jamais le joueur.  Plus j'ai ajouté de règles pour corriger la situation, plus des choses étranges ont commencé à se produire - certaines règles sont entrées en conflit avec d'autres, des cas limites ont commencé à apparaître. <br><br>  Bien sûr, l'une des solutions consistait à ajouter de nouvelles règles, à considérer chaque tâche une par une et à créer de nouvelles constructions if pour les traiter.  Mais je pense que de cette manière, j'ai simplement écarté la vraie solution au problème.  La limitation du système était qu'il n'inquiétait qu'une seule question: "Quel sera mon <b>prochain</b> déménagement?"  Elle n'a jamais regardé vers l'avenir et n'a pas essayé de suggérer ce qui <i>pourrait</i> venir d'une combinaison intelligente particulière. <br><br>  J'ai donc décidé de recommencer. <br><br><h2>  Solution classique </h2><br>  Essayez de rechercher des informations sur l'IA pour les jeux, et probablement la première chose que vous rencontrerez une solution classique - la création d'un algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">minimax</a> .  Voici une vidéo sur son utilisation dans le développement de l'IA pour les échecs: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/DZfv0YgLJ2Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  L'implémentation de minimax est la suivante: <br><br>  Tout d'abord, nous créons la version la plus simple et abstraite de notre jeu, dans laquelle il y a toutes les informations nécessaires pour un moment précis du jeu.  Nous l'appellerons un <b>tableau</b> .  Dans le cas des échecs, ce sont les positions actuelles de toutes les pièces.  Dans le cas de Dicey Dungeons, il s'agit d'une liste de dés, d'armes et d'effets de statut. <br><br>  Ensuite, nous créons <i>une fonction de valeur</i> qui mesure la <i>qualité</i> du jeu pour une configuration de jeu spécifique, c'est-à-dire pour un <i>plateau</i> particulier.  Par exemple, aux échecs, une planche sur laquelle les pièces sont situées dans leur position d'origine est évaluée à 0 point.  Le plateau sur lequel vous avez mangé le pion de votre adversaire a une valeur de 1 points, et le plateau sur lequel vous avez perdu votre propre pion a une valeur de -1 points.  Et le plateau sur lequel nous avons maté l'adversaire sera évalué à un nombre infini de points, ou quelque chose comme ça! <br><br>  Ensuite, à partir de ce tableau abstrait, nous simulons tous les mouvements possibles que nous pouvons faire, ce qui nous donne de nouveaux tableaux abstraits.  Ensuite, nous simulons l'achèvement de tous les mouvements possibles sur <i>ces</i> tableaux, et ainsi de suite, autant d'étapes que vous le souhaitez.  Voici une excellente illustration d'une solution similaire de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">freecodecamp.org</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/905/fa7/323905fa7062bd302e0b97afd1b81d40.png"></div><br>  Nous créons un graphique de tous les mouvements possibles que les deux joueurs peuvent effectuer et nous leur appliquons une fonction de valeur pour évaluer le déroulement du jeu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf9/487/181/bf948718169b06d15fdfbf816839d6a4.jpg"></div><br>  Et en cela, Dicey Dungeons diffère de minimax: minimax est issu de la théorie mathématique des jeux, il est conçu pour trouver la meilleure série de coups au monde où l'adversaire cherche à maximiser son score.  L'algorithme est appelé ainsi car il minimise les pertes du joueur lorsque l'adversaire joue afin de maximiser ses gains. <br><br>  Mais que se passe-t-il dans les donjons Dicey?  En fait, je me fiche de ce que fait mon adversaire.  Pour que le jeu soit passionnant, il suffit que l'intelligence artificielle fasse des mouvements logiques - pour déterminer la meilleure façon d'appliquer les dés aux armes, afin que la bataille soit juste.  En d'autres termes, seul "max" est important pour moi, sans "mini". <br><br>  Autrement dit, pour que les donjons AI Dicey fassent un bon mouvement, il me suffit de créer ce graphique des mouvements possibles et de trouver le tableau qui a le score le plus élevé, puis d'effectuer les mouvements menant à ce point. <br><br><h2>  Le mouvement facile de l'ennemi </h2><br>  Eh bien, passons aux exemples!  Regardons à nouveau la grenouille.  Comment peut-elle <b>décider</b> quoi faire ensuite?  Comment sait-elle que l'action choisie est la meilleure? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/db8/48a/908db848a06270e8398e67313f9e16c7.gif"></div><br>  En fait, elle n'a que deux options.  Placez 1 sur l'épée large et 3 sur le bouclier, ou faites le contraire.  Elle décide évidemment qu'il vaut mieux mettre 3 au lieu de 1. Mais pourquoi?  Parce qu'elle a étudié tous les résultats possibles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/429/44c/85b/42944c85becf5fc79d0868de96b2dbd6.png"></div><br>  Si vous mettez 1 sur l'épée, nous obtiendrons 438 points.  Si vous en mettez 3, nous obtenons 558 points.  Super!  Donc, j'obtiens plus de points en plaçant sur l'épée 3, le problème est résolu. <br><br>  D'où viennent ces lunettes?  Le système d'évaluation de Dicey Dungeons prend actuellement en compte les aspects suivants: <br><br><ul><li>  <strong>Dégâts: Le</strong> facteur le plus important est de 100 points pour chaque point de dégâts infligés. </li><li>  <strong>Poison: un</strong> effet de statut important que l'IA considère presque aussi important que les dégâts - 90 pour chaque poison. </li><li>  <strong>Création d'autres effets d'état:</strong> par exemple, choc, brûlure, affaiblissement, etc.  Chacun d'eux coûte 50 points. </li><li>  <strong>Effets de statut bonus:</strong> ajouter au joueur lui-même des effets de statut positifs, tels que la défense et autres, coûte 40 points chacun. </li><li>  <strong>Utilisation d'armes: l'</strong> utilisation de tout type d'arme coûte 10 points, car si rien d'autre ne réussit, l'IA doit simplement essayer de tout utiliser. </li><li>  <strong>Réduction du compte à rebours:</strong> pour activer certains types d'armes (par exemple, pour Pea Shooter), le montant total sur les dés est juste suffisant.  Par conséquent, l'IA reçoit 10 points pour chaque point de compte à rebours qu'elle réduit. </li><li>  <strong>Points sur les dés: l'</strong> IA obtient 5 points pour chaque point inutilisé sur les dés, soit 1 coûte 5 points et 6 coûte 30 points.  Ceci est fait pour que l'IA préfère ne pas utiliser de cubes que vous n'avez pas besoin d'utiliser, de sorte que ses mouvements deviennent très similaires aux humains. </li><li>  <strong>Durée: l'</strong> IA perd 1 point par tour, donc les mouvements longs ont légèrement moins de valeur que les mouvements courts.  Ceci est fait de sorte qu'en présence de deux mouvements qui sont par ailleurs de valeur égale, l'IA choisit le plus court. </li><li>  <strong>Traitement:</strong> il ne coûte qu'un point pour un point de santé restauré, car même si je veux que l'IA considère cela comme important, je n'ai pas vraiment surveillé ma santé.  Il y a toujours des choses à faire et surtout! </li><li>  <strong>Points bonus:</strong> ils peuvent être ajoutés à n'importe quel mouvement pour forcer l'IA à faire quelque chose qu'il n'aurait jamais fait autrement.  Utilisé très modérément. </li></ul><br>  Et enfin, il y a deux cas particuliers - si la cible attaquée manque de santé, cela coûte un million de points.  Si la santé se termine avec l'IA, cela coûte moins un million de points.  Cela signifie que l'IA ne se tuera jamais accidentellement (par exemple, en payant le dé avec une santé très faible), ou qu'elle ne manquera jamais un mouvement dans lequel elle peut tuer le joueur. <br><br>  Ces chiffres ne sont pas idéaux - prenez, par exemple, les problèmes ouverts actuels: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">640</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">642</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">649</a> , mais ce n'est pas très important.  Même des chiffres approximativement précis suffisent pour stimuler l'IA à faire plus ou moins correctement. <br><br><h2>  Mouvements plus difficiles de l'ennemi </h2><br>  Le cas de la grenouille est si simple que même mon terrible code peut comprendre toutes les options en seulement 0,017 seconde.  Mais alors la situation devient plus compliquée.  Regardons à nouveau l'exemple de Jack of all trades. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f92/36c/aae/f9236caaee860e0c026e31bd4390d6e3.gif"></div><br>  Son arbre de décision est «un peu» plus délicat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f7/f79/49a/8f7f7949aed6051ea06e4139bc76fd06.gif"></div><br>  Malheureusement, même dans des cas relativement simples, une explosion de complexité se produit assez rapidement.  Dans ce cas, dans notre graphique, nous obtenons 2 670 nœuds qui doivent être examinés, et cela prend beaucoup plus de temps que dans le cas d'une grenouille - peut-être une ou deux secondes. <br><br>  Cela est largement dû à la complexité combinatoire - par exemple, peu importe laquelle des deux nous utilisons pour soulager le choc initialement, l'algorithme considère cela comme deux solutions distinctes et crée un arbre complet de solutions de branchement pour chacune.  En conséquence, nous obtenons une branche dont la duplication est complètement inutile.  Il existe également des problèmes de combinaison similaires lors du choix des blocs à échanger, pour éliminer les chocs des armes et la procédure pour leur utilisation. <br><br>  Mais même si nous trouvons et optimisons de telles branches inutiles (ce que je fais dans une certaine mesure), il y aura toujours un point où la complexité de toutes les permutations possibles de solutions conduira à des arbres de décision énormes et lents, dont l'évaluation prendra un temps infini.  C'est donc le premier problème sérieux de cette approche.  En voici un autre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/0f0/29b/9d50f029bd3cededbc248022f19a83a6.png"></div><br>  <i>Clé principale.</i>  <i>Divise le cube en deux.</i> <br><br>  Ce type important d'armes (et similaires) provoque des problèmes d'IA car le résultat de son utilisation est <i>incertain</i> .  Si j'en mets six, je peux en obtenir cinq et un, ou quatre et deux, ou peut-être deux triplets.  Je ne le saurai pas avant de le faire, il est donc très difficile de créer un plan qui en tiendra compte. <br><br>  Heureusement, Dicey Dungeons a une excellente solution à ces deux problèmes! <br><br><h2>  Solution moderne </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La</a> méthode Monte Carlo Tree Search (MCTS) est un algorithme probabiliste de prise de décision.  Ci-dessous, une vidéo un peu étrange, qui explique néanmoins très bien le principe de la prise de décision basée sur la méthode de Monte Carlo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BfS2H1y6tzQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  En fait, au lieu d'ajouter tous les mouvements possibles au graphique, les SCTM vérifient les séquences de mouvements aléatoires, puis suivent ceux qui se sont avérés meilleurs.  Grâce à une formule appelée Upper Confidence Bound, il peut par magie déterminer quelles branches de l'arbre de décision sont les «plus prometteuses»: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f38/1aa/c26/f381aac265ea58ab792166af30d64dca.png"></div><br>  Au fait, j'ai pris cette formule d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article très utile sur la recherche d'arbres en utilisant la méthode Monte Carlo</a> .  Ne me demandez pas comment ça marche! <br><br>  Ce qui est étonnant avec les SCTM, c'est que pour trouver la meilleure solution, nous n'avons généralement pas besoin de faire une recherche stupide de tout, et nous pouvons utiliser le même système de simulation de plateau / déplacement abstrait que dans minimax.  Autrement dit, nous utilisons en quelque sorte les deux algorithmes.  C'est exactement le schéma que j'ai utilisé dans Dicey Dungeons.  Tout d'abord, elle essaie de terminer un déploiement complet de l'arbre de décision, ce qui ne prend généralement pas beaucoup de temps et conduit au meilleur résultat.  Mais si l'arbre semble trop grand, nous recommençons à utiliser les SCTM. <br><br>  MCTS a deux fonctionnalités très intéressantes qui sont parfaites pour Dicey Dungeons: <br><br>  Premièrement, la méthode fonctionne idéalement avec incertitude.  Puisqu'elle est effectuée encore et encore, en collectant des données de chaque exécution, je la laisse simplement simuler des mouvements non définis, par exemple, en utilisant une clé principale, de manière naturelle, et après de nombreuses exécutions, la méthode crée une plage de points assez correcte obtenue à la suite de ce mouvement. <br><br>  Deuxièmement, il peut me donner une solution partielle.  En fait, lorsque vous travaillez avec les SCTM, vous pouvez effectuer autant de simulations que vous le souhaitez.  Théoriquement, si elle est effectuée à l'infini, elle convergera exactement vers les mêmes résultats que minimax.  Cependant, ce qui est plus important pour moi, c'est que je peux utiliser les SCTM pour obtenir une bonne solution en un temps de réflexion limité.  Plus nous effectuons de recherches, meilleure sera la «solution», mais dans le cas de Dicey Dungeons, souvent quelques centaines de recherches suffisent, ce qui prend une petite fraction de seconde. <br><br><h2>  Sujets connexes intéressants </h2><br>  C'est ainsi que les ennemis de Dicey Dungeons décident comment vous tuer!  Je veux ajouter ce système à la prochaine version du jeu v0.15! <br><br>  D'où viennent les graphiques que j'ai montrés, y compris sur Twitter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/95d/85c/96995d85c59364cde7cd4df0609da6c4.png"></div><br>  Je les ai créés en écrivant un exportateur pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GraphML</a> , un format de fichier graphique open source qui peut être lu par de nombreux outils différents.  (J'ai utilisé l'excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YEd</a> , que je recommande fortement.) <br><br>  Une partie de la solution à ce problème était de permettre à l'IA de simuler des mouvements, ce qui en soi est un puzzle intéressant.  En conséquence, j'ai implémenté un système de script d'action.  Maintenant que les adversaires utilisent différents types d'armes.  ils exécutent ces petits scripts: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/d3e/f6b/1c5d3ef6bdbfe755699cd588c89dc54f.png"></div><br>  Ces petits scripts sont exécutés par l'analyseur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hscript</a> et l'interpréteur d'expression basé sur haxe.  Cette partie était difficile à mettre en œuvre, mais l'effort a porté ses fruits: cela rendait le jeu super pratique pour créer des mods.  J'espère qu'après la sortie du jeu, les gens pourront utiliser ce système pour développer leurs propres armes, c'est-à-dire qu'ils pourront ajouter au jeu presque tout ce qu'ils peuvent imaginer.  De plus, comme l'IA est suffisamment intelligente pour évaluer toute action qui lui est transférée, les ennemis seront en mesure de comprendre comment utiliser les armes modifiées que les joueurs créeront! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432062/">https://habr.com/ru/post/fr432062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432052/index.html">"Vous êtes un développeur sympa, allez demander plus d'argent" - nous dirons aux managers comment le monde fonctionne</a></li>
<li><a href="../fr432054/index.html">Ce qui rend BeOS et HaikuOS uniques</a></li>
<li><a href="../fr432056/index.html">Vérification photo au détail avec vision par ordinateur</a></li>
<li><a href="../fr432058/index.html">Nouveautés d'AppCode 2018.3</a></li>
<li><a href="../fr432060/index.html">Les meilleures façons de mémoriser des mots anglais</a></li>
<li><a href="../fr432064/index.html">Comment échapper aux "lièvres". Instruction UV</a></li>
<li><a href="../fr432068/index.html">Comment faciliter l'étude de l'anglais: 5 services utiles</a></li>
<li><a href="../fr432070/index.html">En bref sur les chaînes redux-saga</a></li>
<li><a href="../fr432072/index.html">Trois types de fuites de mémoire</a></li>
<li><a href="../fr432074/index.html">Comment les joueurs déchirent le tissu de réalité Spelunky avec des fusils de chasse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>