<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèø ü§∏üèª ü¶Å Das Buch "Wettbewerbsf√§higkeit und Parallelit√§t auf der .NET-Plattform. Effektive Designmuster ‚Äú üê™ üç± üë©‚Äçüë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Das Buch von Riccardo Terrell enth√§lt Anleitungen zur Erstellung wettbewerbsf√§higer und skalierbarer Programme in .NET, in denen d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Wettbewerbsf√§higkeit und Parallelit√§t auf der .NET-Plattform. Effektive Designmuster ‚Äú</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/453804/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/xh/fk/az/xhfkazyaueuwhx3c7cjwt5ohyea.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  Das Buch von Riccardo Terrell enth√§lt Anleitungen zur Erstellung wettbewerbsf√§higer und skalierbarer Programme in .NET, in denen die Vorteile eines funktionalen Paradigmas hervorgehoben und die geeigneten Tools und Prinzipien bereitgestellt werden, um den Wettbewerb wettbewerbsf√§hig und einfach zu halten.  Als Ergebnis erhalten Sie mit neuen F√§higkeiten das Wissen, das Sie ben√∂tigen, um ein Experte f√ºr die Bereitstellung erfolgreicher Hochleistungsl√∂sungen zu werden. <br><br>  Wenn Sie Multithread-Code in .NET schreiben, kann Ihnen dieses Buch helfen.  Wenn Sie ein Funktionsparadigma verwenden m√∂chten, um die wettbewerbsf√§hige Programmierung zu vereinfachen und die Anwendungsleistung zu maximieren, ist dieses Buch ein wichtiger Leitfaden f√ºr Sie.  Dies kommt jedem .NET-Entwickler zugute, der wettbewerbsf√§hige, reaktive und asynchrone Anwendungen schreiben m√∂chte, die skaliert und sich automatisch an verf√ºgbare Hardwareressourcen anpassen, wo immer solche Programme funktionieren. <br><a name="habracut"></a><br><h3>  Publikationsstruktur: Roadmap </h3><br>  Die vierzehn Kapitel dieses Buches sind in drei Teile unterteilt.  Teil I stellt die funktionalen Konzepte der Wettbewerbsprogrammierung vor und beschreibt die F√§higkeiten, die erforderlich sind, um die funktionalen Aspekte des Schreibens von Multithread-Programmen zu verstehen. <br><br><ul><li>  Kapitel 1 beschreibt die grundlegenden Konzepte und Ziele der wettbewerbsf√§higen Programmierung sowie die Gr√ºnde f√ºr die Verwendung der funktionalen Programmierung zum Schreiben von Multithread-Anwendungen. </li><li>  In Kapitel 2 werden verschiedene funktionale Programmiertechnologien untersucht, um die Leistung von Multithread-Anwendungen zu verbessern.  Der Zweck dieses Kapitels ist es, dem Leser die im Rest des Buches verwendeten Konzepte zu vermitteln und kraftvolle Ideen vorzustellen, die sich aus einem funktionalen Paradigma ergeben. </li><li>  Kapitel 3 gibt einen √úberblick √ºber das Funktionskonzept der Unver√§nderlichkeit.  Es wird erkl√§rt, wie Unver√§nderlichkeit verwendet wird, um vorhersehbare und korrekte Wettbewerbsprogramme zu schreiben und funktionale Datenstrukturen zu implementieren, die threadsicher sind. </li></ul><br>  In Teil II werden verschiedene Modelle der Wettbewerbsprogrammierung in einem Funktionsparadigma eingehend untersucht.  Wir werden Themen wie die Task Parallel Library (TPL) untersuchen und parallele Muster wie Fork / Join, Divide and Conquer und MapReduce implementieren.  In diesem Abschnitt werden auch das deklarative Layout, allgemeine Abstraktionen bei asynchronen Operationen, die Agentenprogrammierung und die Semantik der Nachrichten√ºbertragung erl√§utert. <br><br><ul><li>  Kapitel 4 beschreibt die Grundlagen der parallelen Verarbeitung gro√üer Datenmengen, einschlie√ülich Vorlagen wie Fork / Join. </li><li>  In Kapitel 5 werden komplexere Methoden f√ºr die parallele Verarbeitung gro√üer Informationsmengen vorgestellt, z. B. parallele Aggregation, Datenreduktion und Implementierung einer parallelen MapReduce-Vorlage. </li><li>  Kapitel 6 enth√§lt detaillierte Informationen zu den Funktionsmethoden f√ºr die Verarbeitung von Ereignisstr√∂men (Datenstr√∂men) in Echtzeit mithilfe der Funktionsoperatoren h√∂herer Ordnung in .NET Reactive Extensions zur Bildung asynchroner Ereigniskombinatoren.  Die untersuchten Methoden werden dann verwendet, um eine wettbewerbsf√§hige reaktive Vorlage f√ºr Publisher und Abonnenten zu implementieren. </li><li> Kapitel 7 enth√§lt eine Erl√§uterung des aufgabenbasierten Programmiermodells f√ºr die funktionale Programmierung zur Implementierung wettbewerbsf√§higer Operationen unter Verwendung der Monadic-Vorlage.  Diese Methode wird dann verwendet, um eine wettbewerbsf√§hige Pipeline basierend auf einem funktionalen Programmierparadigma aufzubauen. </li><li>  Kapitel 8 befasst sich mit der Implementierung von unbegrenztem parallelem Rechnen unter Verwendung des asynchronen C # -Programmiermodells.  In diesem Kapitel werden auch Fehlerbehandlungsmethoden und Methoden zum Erstellen asynchroner Operationen erl√§utert. </li><li>  Kapitel 9 beschreibt den asynchronen Workflow in F #.  Es zeigt, wie eine verz√∂gerte und explizite Bewertung in diesem Modell eine h√∂here Kompositionssemantik erm√∂glicht.  Anschlie√üend lernen wir, wie benutzerdefinierte Berechnungsausdr√ºcke implementiert werden, um den Abstraktionsgrad f√ºr die deklarative Programmierung zu erh√∂hen. </li><li>  Kapitel 10 zeigt, wie basierend auf den in den vorherigen Kapiteln gewonnenen Erkenntnissen Kombinatoren und Vorlagen wie Functor, Monad und Applicative implementiert werden k√∂nnen, um mehrere asynchrone Operationen zu erstellen und auszuf√ºhren und Fehler ohne Nebenwirkungen zu behandeln. </li><li>  Kapitel 11 analysiert die reaktive Programmierung mithilfe eines Software-Messaging-Modells.  Es zeigt das Konzept der nat√ºrlichen Isolation als eine Technologie, die die Unver√§nderlichkeit erg√§nzt und die Erstellung wettbewerbsf√§higer Programme erm√∂glicht.  Dieses Kapitel konzentriert sich auf die MailboxProcessor-Klasse, die in F # zum Verteilen paralleler Arbeit mithilfe der Agentenprogrammierung und eines ressourcenfreien Ansatzes verwendet wird. </li><li>  Kapitel 12 beschreibt die Agentenprogrammierung mithilfe der TPL-Datenflussbibliothek aus .NET anhand von Beispielen in C #.  Es wird gezeigt, wie zustandslose und statusbehaftete Agenten in C # implementiert werden und wie mehrere Berechnungen parallel durchgef√ºhrt werden, die Daten miteinander austauschen, indem Nachrichten im Stil einer Pipeline gesendet werden. </li></ul><br>  Teil III zeigt, wie alle in den vorhergehenden Kapiteln untersuchten funktionalen Methoden der Wettbewerbsprogrammierung in die Praxis umgesetzt werden k√∂nnen. <br><br><ul><li>  Kapitel 13 enth√§lt eine Reihe n√ºtzlicher Rezepte zur L√∂sung komplexer Wettbewerbsprobleme aus der Praxis.  Diese Rezepte verwenden alle in diesem Buch beschriebenen Funktionsmuster. </li><li>  Kapitel 14 beschreibt eine vollwertige Anwendung, die unter Verwendung der in diesem Buch erlernten funktionalen Wettbewerbsvorlagen und -methoden entwickelt und implementiert wurde.  Sie erstellen eine hoch skalierbare, reaktionsschnelle Serveranwendung und ein reaktionsschnelles Clientprogramm.  Das Buch enth√§lt zwei Versionen: eine f√ºr iOS (iPad), die mit Xamarin Visual Studio erstellt wurde, und die zweite, die mit Windows Presentation Foundation (WPF) erstellt wurde.  Um maximale Skalierbarkeit in der Serveranwendung sicherzustellen, wird eine Kombination verschiedener Programmiermodelle wie asynchron, agent und reaktiv verwendet. </li></ul><br>  Das Buch enth√§lt auch drei Anwendungen. <br><br><ul><li>  Anhang A beschreibt kurz die grundlegenden Konzepte der funktionalen Programmierung und stellt die grundlegende Theorie der in diesem Buch verwendeten funktionalen Methoden vor. </li><li>  Anhang B enth√§lt die Grundkonzepte der F # -Sprache.  Dies ist eine grundlegende √úberpr√ºfung von F #, mit der Sie sich mit dieser Sprache vertraut machen und sich beim Lesen eines Buches wohler f√ºhlen k√∂nnen. </li><li>  Anhang B zeigt verschiedene Methoden, die die Interaktion zwischen einem asynchronen Workflow in F # und einer .NET-Task in C # vereinfachen. </li></ul><br><h3>  Auszug.  11.6.  F # MailboxProcessor: 10.000 Agenten f√ºr Game of Life </h3><br>  Im Vergleich zu Threads ist MailboxProcessor in Kombination mit asynchronen Workflows eine einfache Recheneinheit (primitiv).  Agenten k√∂nnen mit minimalen Kosten erscheinen und zerst√∂rt werden.  Sie k√∂nnen die Arbeit auf mehrere MailboxProcessor-Objekte auf dieselbe Weise verteilen, wie Sie Threads verwenden k√∂nnen, ohne den zus√§tzlichen Aufwand f√ºr das Erstellen eines neuen Threads.  Dank dessen ist es durchaus m√∂glich, Anwendungen zu erstellen, die aus Hunderttausenden von Agenten bestehen, die parallel arbeiten, wobei die Computerressourcen minimal belastet werden. <br><br>  In diesem Abschnitt werden wir mehrere Instanzen von MailboxProcessor verwenden, um das Spiel Game of Life (das Spiel "Life") ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiki-eng</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiki-rus</a> ) zu implementieren.  Laut Wikipedia ist das Spiel des Lebens in einfachen Worten ein zellularer Automat.  Dies ist ein Spiel ohne Spieler - mit anderen Worten, wenn ein Spiel mit einer zuf√§lligen Anfangskonfiguration beginnt, wird es ohne weitere Eingaben ausgef√ºhrt.  Das Spiel besteht aus einer Reihe von Zellen, die ein Gitter bilden.  In jeder Zelle sind mehrere mathematische Regeln erf√ºllt.  Zellen k√∂nnen leben, sterben und sich vermehren.  Jede Zelle interagiert mit acht Nachbarn (Nachbarzellen).  Um Zellen gem√§√ü diesen Regeln zu verschieben, muss der neue Zustand des Gitters st√§ndig berechnet werden. <br><br>  Game of Life hat folgende Regeln: <br><br><ul><li>  Wenn eine Zelle nur einen Nachbarn oder keine Nachbarn hat, stirbt sie "an Einsamkeit". </li><li>  Wenn vier oder mehr Nachbarn einer Zelle sterben, stirbt sie ‚Äûaufgrund von √úberbev√∂lkerung‚Äú. </li><li>  Wenn die Zelle zwei oder drei Nachbarn hat, bleibt sie zu leben. </li><li>  Wenn eine Zelle drei Nachbarn hat, multipliziert sie sich. </li></ul><br>  Abh√§ngig von den Anfangsbedingungen bilden die Zellen w√§hrend des Spiels charakteristische Strukturen.  Durch wiederholte Anwendung der Regeln werden die folgenden Generationen von Zellen erzeugt, bis die Zellen einen stabilen Zustand erreichen (Abb. 11.12). <br><br>  Listing 11.9 zeigt die Implementierung der Game of Life AgentCell-Zelle basierend auf den F # -Typen von MailboxProcessor.  Jede Agentenzelle interagiert √ºber asynchrones Messaging mit benachbarten Zellen und erstellt so ein vollst√§ndig parallelisiertes Spiel des Lebens.  Der K√ºrze halber habe ich einige Teile des Codes weggelassen, da sie nicht mit dem Hauptthema des Beispiels zusammenh√§ngen.  Die vollst√§ndige Implementierung finden Sie im Quellcode f√ºr dieses Buch, der auf der Website des Herausgebers ver√∂ffentlicht ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/qb/jp/siqbjpp_zc4oqi7dgpk032_8xe8.png" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2d/j9/u2/2dj9u2y7qplsftitwupamkmaji0.png" alt="Bild"></div><br>  AgentCell beschreibt eine Zelle im Game of Life-Raster.  Das Grundkonzept besteht darin, dass jeder Agent durch asynchrones Messaging Informationen mit benachbarten Zellen √ºber seinen aktuellen Status austauscht.  Diese Vorlage erstellt eine Kette miteinander verbundener paralleler Kommunikation, bei der alle Zellen ihren aktualisierten Status an den MailboxProcessor updateAgent senden.  Nach Erhalt dieser Daten aktualisiert updateAgent die Grafiken in der Benutzeroberfl√§che (Listing 11.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/qy/j2/1aqyj2_ar1ua7a4mjylo8gxdqgg.png" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wr/jx/l4wrjxuth4-3quliytnseqegjw8.png" alt="Bild"></div><br>  updateAgent aktualisiert, wie der Name schon sagt, den Status jedes Pixels gem√§√ü dem in der Aktualisierungsnachricht empfangenen Zellenwert.  Der Agent beh√§lt den Status der Pixel bei und erstellt daraus ein neues Bild, wenn alle Zellen ihren neuen Status weitergeben.  UpdateAgent aktualisiert dann die WPF-GUI mithilfe dieses neuen Bildes, das dem aktuellen Game of Life-Raster entspricht: <br><br><pre><code class="plaintext hljs">do! Async.SwitchToContext ctx image.Source &lt;- createImage pixels do! Async.SwitchToThreadPool()</code> </pre> <br>  Es ist wichtig zu beachten, dass der updateAgent den aktuellen Synchronisationskontext verwendet, um den WPF-Controller korrekt zu aktualisieren.  Der aktuelle Thread wird mit der Funktion Async.SwitchToContext (beschrieben in Kapitel 9) auf den Benutzeroberfl√§chenthread umgeschaltet. <br><br>  Der letzte Code, der Game of Life ausf√ºhrt, generiert ein Raster, das als Spielplatz f√ºr die Zellen dient. Anschlie√üend benachrichtigt der Timer die Zellen √ºber die Notwendigkeit einer Aktualisierung (Listing 11.11).  In diesem Beispiel ist das Raster ein Quadrat aus 100 √ó 100 Zellen, insgesamt 10.000 Zellen (MailboxProcessor-Objekte), die alle 50 ms parallel zu einem Timer berechnet werden, wie in Abb.  11.13.  Zehntausend MailboxProcessor-Objekte interagieren und aktualisieren die Benutzeroberfl√§che 20 Mal pro Sekunde (der Code, auf den Sie achten sollten, ist fett gedruckt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/px/jw/uepxjwb4re6grfx1wqbmp4rx6pq.png" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/cg/tx/eqcgtxipd3wr4kipmnbpqj0-rjm.png" alt="Bild"></div><br>  Benachrichtigungen an alle Zellen (Agenten) werden parallel mit PLINQ gesendet.  Zellen sind F # -Sequenzen, die als .NET IEnumerable behandelt werden, wodurch LINQ / PLINQ einfach zu integrieren ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/9u/wl/rc9uwlhsymr64zmqrffpte7gqcc.png" alt="Bild"></div><br>  Wenn der Code ausgef√ºhrt wird, generiert das Programm in weniger als 1 ms 10.000 F # -Objekte vom Typ MailboxProcessor, w√§hrend die Agenten weniger als 25 MB Speicher belegen.  Beeindruckend! <br><br><h3>  Zusammenfassung </h3><br><ul><li>  Das agentenbasierte Programmiermodell bietet nat√ºrlich Unver√§nderlichkeit und Isolation beim Schreiben wettbewerbsf√§higer Systeme, was die Diskussion komplexer Systeme noch einfacher macht, da Agenten in aktiven Objekten eingekapselt sind. </li><li>  Ein reaktives Manifest definiert die Eigenschaften f√ºr die Implementierung eines reaktiven Systems, das flexibel, lose gekoppelt und skalierbar ist. </li><li>  Nat√ºrliche Isolation ist wichtig, um wettbewerbsf√§higen Code zu schreiben, ohne ihn zu blockieren.  In einem Multithread-Programm l√∂st die Isolation das Problem gemeinsamer Zust√§nde, indem jedem Thread ein kopiertes Datenelement zur Verf√ºgung gestellt wird, um lokale Berechnungen durchzuf√ºhren.  Bei Verwendung der Isolierung gibt es keine Rennbedingung. </li><li>  Da Agenten asynchron sind, sind sie einfach, da sie keine Threads blockieren, w√§hrend sie auf Nachrichten warten.  Infolgedessen k√∂nnen Sie Hunderttausende von Agenten in einer Anwendung verwenden, ohne die Speicherkapazit√§t wesentlich zu beeinflussen. </li><li>  Ein MailboxProcessor F # -Objekt bietet eine bidirektionale Kommunikation: Ein Agent kann einen asynchronen Kanal verwenden, um das Ergebnis der Berechnung an das aufrufende Objekt zur√ºckzugeben (zu beantworten). </li><li>  Das Agentenprogrammiermodell in F # √ºber MailboxProcessor ist ein hervorragendes Tool zum Beheben von Engp√§ssen in Anwendungen, z. B. bei gleichzeitigem Datenbankzugriff.  Mithilfe von Agenten k√∂nnen Sie die Anwendung erheblich beschleunigen und gleichzeitig die Reaktionsf√§higkeit des Servers gew√§hrleisten. </li><li>  In anderen .NET-Programmiersprachen k√∂nnen Sie den MailboxProcessor vom Typ F # verwenden und Methoden mithilfe des praktischen TPL-Programmiermodells bereitstellen, das auf Aufgaben basiert. </li></ul><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  20% Rabatt auf Gutschein f√ºr H√§ndler - <b>Parallelit√§t in .NET</b> <br><br>  Nach Zahlung der Papierversion des Buches wird eine elektronische Version des Buches per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453804/">https://habr.com/ru/post/de453804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453788/index.html">Neuronale Netze bevorzugen Texturen und wie man damit umgeht.</a></li>
<li><a href="../de453790/index.html">"Der Kunde ist weg - ist es f√ºr immer?" Wie man die Kundenabwanderung in SaaS z√§hlt und was mit grundlegenden Metriken nicht stimmt</a></li>
<li><a href="../de453792/index.html">Empfehlungssysteme: Ideen, Ans√§tze, Aufgaben</a></li>
<li><a href="../de453796/index.html">Brauchen die Leute Mathe?</a></li>
<li><a href="../de453800/index.html">Wie man "Minesweeper" l√∂st (und es besser macht)</a></li>
<li><a href="../de453806/index.html">Fehlerbehandlung in Go</a></li>
<li><a href="../de453808/index.html">Wir zerlegen das Gesch√§ftsmodell der Wikinger</a></li>
<li><a href="../de453810/index.html">Biometrisches Feedback</a></li>
<li><a href="../de453812/index.html">Themen, Stile und andere</a></li>
<li><a href="../de453816/index.html">Durch Zecken √ºbertragene Enzephalitis: eine vernachl√§ssigte Gefahr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>