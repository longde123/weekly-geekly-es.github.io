<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛑️ 📦 👾 该代码是活的还是死的。 第三部分。 文字编码 👶🏼 👍🏻 🤙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="要与该程序一起使用，您必须阅读代码，并且执行起来越容易，它看起来就越像自然语言-然后您就可以快速深入并专注于主要内容。 


在最后两篇文章中，我展示了精心选择的单词有助于更好地理解所写内容的本质，但仅思考它们是不够的，因为每个单词都以两种形式存在：本身和作为句子的一部分。 直到我们在Thread....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>该代码是活的还是死的。 第三部分。 文字编码</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447830/"><p> 要与该程序一起使用，您必须阅读代码，并且执行起来越容易，它看起来就越像自然语言-然后您就可以快速深入并专注于主要内容。 </p><br><p>在最后两篇文章中，我展示了精心选择的单词有助于更好地理解所写内容的本质，但<em>仅</em>思考它们是不够的，因为每个单词都以两种形式存在：本身和作为句子的一部分。 直到我们在<code>Thread.CurrentThread</code>的上下文中<em>读取</em> <code>CurrentThread</code>之前，它都不会重复。 </p><br><p> 因此，在音符和简单旋律的指导下，我们现在将了解什么是音乐。 </p><a name="habracut"></a><br><h2 id="oglavlenie-cikla"> 循环目录 </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">动作和属性</a> </li><li> 文字编码 </li></ol><br><h2 id="kod-kak-tekst"> 文字编码 </h2><br><p> 大多数<em>流畅的</em>界面在设计时都侧重于外部而不是内部，因此它们非常易于阅读。 当然，这不是免费的：从某种意义上说，内容正在减弱。 假设，在<code>FluentAssertions</code>包中， <code>FluentAssertions</code>可以编写： <code>(2 + 2).Should().Be(4, because: "2 + 2 is 4!")</code>并且，相对于阅读， <code>because</code>看起来很优雅，但是在<code>Be()</code> ， <code>errorMessage</code>使用<code>error</code>或<code>errorMessage</code>参数。 </p><br><p> 我认为，这种豁免并不重要。 当我们同意代码是文本时，其组成部分不再属于自己：它们现在是某种通用的<em>“以太”的一部分</em> 。 </p><br><p> 我将通过示例展示如何将这些考虑变为经验。 </p><br><h3 id="interlocked"> <code>Interlocked</code> </h3> <br><p> 让我想起您<code>Interlocked.CompareExchange(ref x, newX, oldX)</code>的<code>Interlocked</code>情况，我们将<code>Interlocked.CompareExchange(ref x, newX, oldX)</code>转换为<code>Interlocked.CompareExchange(ref x, newX, oldX)</code> <code>Atomically.Change(ref x, from: oldX, to: newX)</code> ，使用明确的方法和参数名称。 </p><br><h3 id="exceptwith"> <code>ExceptWith</code> </h3> <br><p>  <code>ISet&lt;&gt;</code>类型具有一个名为<code>ExceptWith</code>的方法。 如果您查看类似于<code>items.ExceptWith(other)</code>的呼叫，您将不会立即意识到发生了什么。 但是，您只需编写： <code>items.Exclude(other)</code> ，一切都准备就绪。 </p><br><h3 id="getvalueordefault"> <code>GetValueOrDefault</code> </h3> <br><p> 使用<code>Nullable&lt;T&gt;</code>如果<code>x</code>为<code>null</code> <code>Nullable&lt;T&gt;</code>调用<code>x.Value</code>将引发异常。 如果仍然需要获取<code>Value</code> ，请使用<code>x.GetValueOrDefault</code> ：它是<code>Value</code>或默认值。 大块头 </p><br><p> 表达式<em>“或x或默认值”</em>与简短的<code>x.OrDefault</code>匹配。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = x.GetValueOrDefault(); <span class="hljs-comment"><span class="hljs-comment">// ,  .  . var b = x.OrDefault(); //  —  ,   . var c = x.Or(10); //     .</span></span></code> </pre> <br><p> 使用<code>OrDefault</code>和<code>Or</code> ，需要记住一件事：与运算符一起使用时<code>.?</code> 您不能编写类似<code>x?.IsEnabled.Or(false)</code> ，只能编写<code>(x?.IsEnabled).Or(false)</code> （换句话说，如果左侧为<code>null</code> ，则<code>.?</code>运算符将取消<em>整个</em>右侧）。 </p><br><p> 使用<code>IEnumerable&lt;T&gt;</code>时可以应用模板： </p><br><pre> <code class="cs hljs">IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// . var x = numbers ?? Enumerable.Empty&lt;int&gt;(); //   . var x = numbers.OrEmpty();</span></span></code> </pre> <br><h3 id="mathmin-i-mathmax">  <code>Math.Min</code>和<code>Math.Max</code> </h3><br><p> 带有<code>Or</code>的想法可以发展为数字类型。 假设您要从<code>a</code>和<code>b</code>取最大数。 然后我们写： <code>Math.Max(a, b)</code>或<code>a &gt; b ? a : b</code>  <code>a &gt; b ? a : b</code> 。 这两个选项看起来都很熟悉，但是看起来却不是自然语言。 </p><br><p> 您可以将其替换为： <code>a</code> <em>或</em> <code>a.Or(b).IfLess()</code> - <em>如果</em> <code>a</code> <em>小于</em> <em>则</em> <em>取</em> <code>a</code> <em>或</em> <code>b</code> 。 适用于以下情况： </p><br><pre> <code class="cs hljs">Creature creature = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> damage = ...; <span class="hljs-comment"><span class="hljs-comment">//   . creature.Health = Math.Max(creature.Health - damage, 0); // Fluent. creature.Health = (creature.Health - damage).Or(0).IfGreater(); //   : creature.Health = (creature.Health - damage).ButNotLess(than: 0);</span></span></code> </pre> <br><h3 id="stringjoin"> <code>string.Join</code> </h3> <br><p> 有时您需要将序列组装成字符串，并用空格或逗号分隔元素。 为此，例如，使用<code>string.Join</code> ，例如： <code>string.Join(", ", new [] { 1, 2, 3 }); //  "1, 2, 3".</code> <code>string.Join(", ", new [] { 1, 2, 3 }); //  "1, 2, 3".</code>  。 </p><br><p> 一个简单的<em>“将逗号分隔”</em>可能突然变成<em>“将逗号添加到列表中的每个数字”</em> –这当然不是文本代码。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ""    —  . var x = string.Join(", ", numbers); //    — ! var x = numbers.Separated(with: ", ");</span></span></code> </pre> <br><h3 id="regex"> <code>Regex</code> </h3> <br><p> 但是，与有时不正确地使用<code>Regex</code>以及将其用于其他目的相比， <code>string.Join</code>完全没有害处。 可以通过简单易读的文本获得帮助的地方，出于某种原因，首选过于复杂的条目。 </p><br><p> 让我们从一个简单的开始-确定一个字符串代表一组数字： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> id = ...; <span class="hljs-comment"><span class="hljs-comment">// ,  . var x = Regex.IsMatch(id, "^[0-9]*$"); // . var x = id.All(x =&gt; x.IsDigit()); // ! var x = id.IsNumer();</span></span></code> </pre> <br><p> 另一种情况是从序列中找出字符串中是否至少有一个字符： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = ...; <span class="hljs-comment"><span class="hljs-comment">//   . var x = Regex.IsMatch(text, @"["&lt;&gt;[]'"); //   . ( .) var x = text.ContainsAnyOf('"', '&lt;', '&gt;', '[', ']', '\''); //  . var x = text.ContainsAny(charOf: @"["&lt;&gt;[]'");</span></span></code> </pre> <br><p> 任务越复杂，解决方案“模式”就越困难：将<code>"HelloWorld"</code>的记录拆分为几个词<code>"Hello World"</code> ，则有人会用一种简单的算法来代替怪物： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = ...; <span class="hljs-comment"><span class="hljs-comment">//   -   . var x = Regex.Replace(text, "([az](?=[AZ])|[AZ](?=[AZ][az]))", "$1 "); //  . var x = text.PascalCaseWords().Separated(with: " "); //   . var x = text.AsWords(eachStartsWith: x =&gt; x.IsUpper()).Separated(with: " ");</span></span></code> </pre> <br><p> 毫无疑问，正则表达式是有效且通用的，但是我想一眼就知道发生了什么。 </p><br><h3 id="substring-i-remove">  <code>Substring</code>并<code>Remove</code> </h3><br><p> 碰巧您需要从行的开头或结尾删除部分内容，例如，从<code>path</code> -扩展名<code>.txt</code> （如果有）中删除。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = ...; <span class="hljs-comment"><span class="hljs-comment">//    . var x = path.EndsWith(".txt") ? path.Remove(path.Length - "txt".Length) : path; //   . var x = path.Without(".exe").AtEnd;</span></span></code> </pre> <br><p> 同样， <em>操作</em>和<em>算法也</em>消失了， <em>只剩下了一行，结尾没有.exe扩展名</em> 。 </p><br><p> 由于<code>Without</code>方法应该返回特定的<code>WithoutExpression</code> ，因此它们会请求另一个： <code>path.Without("_").AtStart</code>和<code>path.Without("Something").Anywhere</code> 。 同样有趣的是，可以使用相同的单词构造另一个表达式： <code>name.Without(charAt: 1)</code> -删除索引1处的字符并返回新行（在计算排列中很有用）。 而且可读性强！ </p><br><h3 id="typegetmethods"> <code>Type.GetMethods</code> </h3> <br><p> 要使用反射获取某种类型的方法，请使用： </p><br><pre> <code class="cs hljs">Type type = ...; <span class="hljs-comment"><span class="hljs-comment">//   `Get` ,   `|`.     . var x = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); // ,  . `Or`   , . var x = type.Methods(_ =&gt; _.Instance.Public.Or.NonPublic);</span></span></code> </pre> <br><p>  （对于<code>GetFields</code>和<code>GetProperties</code> 。） </p><br><h3 id="directorycopy"> <code>Directory.Copy</code> </h3> <br><p> 文件夹和文件的所有操作通常被概括为<code>DirectoryUtils</code> ， <code>FileSystemHelper</code> 。 它们实现文件系统旁路，清理，复制等。 但是在这里您可以提出更好的建议！ </p><br><p> 我们将文本<em>“将所有文件从'D：\ Source'复制到'D：\ Target'”显示</em>为代码<code>"D:\\Source".AsDirectory().Copy().Files.To("D:\\Target")</code>  <code>AsDirectory()</code> -从<code>string</code>返回<code>DirectoryInfo</code> ，而<code>Copy()</code> -创建一个<code>CopyExpression</code>实例，该实例描述用于构造表达式的唯一API（例如，您不能调用<code>Copy().Files.Files</code> ）。 然后机会打开了，不是复制所有文件，而是<code>Copy().Files.Where(x =&gt; x.IsNotEmpty)</code>一些文件： <code>Copy().Files.Where(x =&gt; x.IsNotEmpty)</code> 。 </p><br><h3 id="getorderbyid"> <code>GetOrderById</code> </h3> <br><p> 在第二篇文章中，我写道<code>IUsersRepository.GetUser(int id)</code>是多余的，更好的是<code>IUsersRepository.User(int id)</code> 。 因此，在类似的<code>IOrdersRepository</code>我们没有<code>IOrdersRepository</code> <code>GetOrderById(int id)</code> ，而是<code>Order(int id)</code> 。 但是，在另一个示例中，建议将此类存储库的变量称为<code>_ordersRepository</code>而不是<code>_orders</code> 。 </p><br><p> 两种更改本身都很好，但是它们在阅读上下文中并没有加在一起：调用<code>_orders.Order(id)</code>看起来很冗长。  <code>_orders.Get(id)</code>是可能的，但是订单失败，我们只想指定<em>一个具有这样的标识符</em>的订单。 因此， <em>一个</em>为<code>One</code> ： </p><br><pre> <code class="cs hljs">IOrdersRepository orders = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = ...; <span class="hljs-comment"><span class="hljs-comment">//   . var x = orders.GetOrderById(id); //      : var x = orders.Order(id); //     ,    . var x = orders.One(id); //    : var x = orders.One(with: id);</span></span></code> </pre> <br><h3 id="getorders"> <code>GetOrders</code> </h3> <br><p> 在诸如<code>IOrdersRepository</code>对象中，经常发现其他方法： <code>AddOrder</code> ， <code>RemoveOrder</code> 。 前两个重复消失，并获得<code>Add</code>和<code>Remove</code> （具有相应的条目<code>_orders.Add(order)</code>和<code>_orders.Remove(order)</code> ）。 使用<code>GetOrders</code>更难以重命名<code>Orders</code> 。 让我们看看： </p><br><pre> <code class="cs hljs">IOrdersRepository orders = ...; <span class="hljs-comment"><span class="hljs-comment">//   . var x = orders.GetOrders(); //  `Get`,  . var x = orders.Orders(); // ! var x = orders.All();</span></span></code> </pre> <br><p> 应该注意的是，使用旧的<code>_ordersRepository</code>或<code>GetOrderById</code>调用中的重复并不是那么明显，因为我们正在使用存储库！ </p><br><p> 诸如<code>One</code> ， <code>All</code>类的名称适用于表示许多接口的许多接口。 说，在GitHub API的著名实现中<code>octokit</code>获取所有用户存储库看起来像<code>gitHub.Repository.GetAllForUser("John")</code> ，尽管更合乎逻辑<code>gitHub.Users.One("John").Repositories.All</code> 。 在这种情况下，获得<em>一个</em>存储库分别是<code>gitHub.Repository.Get("John", "Repo")</code>而不是明显的<code>gitHub.Users.One("John").Repositories.One("Repo")</code> 。 第二种情况看起来更长，但是在内部是一致的，反映了平台。 另外，使用扩展方法，可以将其缩短为<code>gitHub.User("John").Repository("Repo")</code> 。 </p><br><h3 id="dictionarytrygetvalue"> <code>Dictionary.TryGetValue</code> </h3> <br><p> 从字典中获取值分为几种情况，仅在找不到密钥的情况下需要做的事情不同： </p><br><ul><li> 抛出错误（ <code>dictionary[key]</code> ）； </li><li> 返回默认值（未实现，但通常写<code>GetValueOrDefault</code>或<code>TryGetValue</code> ）； </li><li> 返回其他内容（未实现，但我希望<code>GetValueOrOther</code> ）； </li><li> 将指定的值写入字典并返回（未实现，但<code>GetOrAdd</code> ）。 </li></ul><br><p> 表达式收敛于“ <em>取一些X，如果不取X则取Y</em> ”。 另外，与<code>_ordersRepository</code> ，我们将字典变量<code>itemsDictionary</code>而不是<code>itemsDictionary</code> 。 </p><br><p> 然后对于<em>“带一些X”部分</em> ，调用表<code>items.One(withKey: X)</code>理想的，返回一个带有四个<em>结尾</em>的结构： </p><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Item&gt; items = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = ...; <span class="hljs-comment"><span class="hljs-comment">//  ,   : var x = items.GetValueOrDefault(id); var x = items[id]; var x = items.GetOrAdd(id, () =&gt; new Item()); //    : var x = items.One(with: id).OrDefault(); var x = items.One(with: id).Or(Item.Empty); var x = items.One(with: id).OrThrow(withMessage: $"Couldn't find item with '{id}' id."); var x = items.One(with: id).OrNew(() =&gt; new Item());</span></span></code> </pre> <br><h3 id="assemblygettypes"> <code>Assembly.GetTypes</code> </h3> <br><p> 让我们看一下如何在程序集中创建所有现有的类型<code>T</code>实例： </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// . var x = Assembly .GetAssembly(typeof(T)) .GetTypes() .Where(...) .Select(Activator.CreateInstance); // "" . var x = TypesHelper.GetAllInstancesOf&lt;T&gt;(); // . var x = Instances.Of&lt;T&gt;();</span></span></code> </pre> <br><p> 因此，有时，静态类的名称是表达式的<em>开头</em> 。 </p><br><p> 在NUnit中可以找到类似的内容： <code>Assert.That(2 + 2, Is.EqualTo(4))</code> - <code>Is</code>并且不被认为是自给自足的类型。 </p><br><h3 id="argumentthrowifnull"> <code>Argument.ThrowIfNull</code> </h3> <br><p> 现在让我们看一下前提条件检查： </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  . Argument.ThrowIfNull(x); Guard.CheckAgainstNull(x); // . x.Should().BeNotNull(); // ,  ...  ? Ensure(that: x).NotNull();</span></span></code> </pre> <br><p>  <code>Ensure.NotNull(argument)</code> -不错，但英语不太好。 另一件事是上面编写的<code>Ensure(that: x).NotNull()</code> 。 如果只有... </p><br><p> 顺便说一句，你可以！ 我们编写<code>Contract.Ensure(that: argument).IsNotNull()</code>并<code>using static</code>导入<code>Contract</code>的类型。 这样就获得了<code>Ensure(that: type).Implements&lt;T&gt;()</code>的<code>Ensure(that: type).Implements&lt;T&gt;()</code> ， <code>Ensure(that: number).InRange(from: 5, to: 10)</code>等。 </p><br><p> 静态导入的想法打开了许多门。 出于以下原因的一个美丽示例：代替<code>items.Remove(x)</code>编写<code>Remove(x, from: items)</code> 。 但是令人好奇的是减少了返回函数的<code>enum</code>和属性。 </p><br><pre> <code class="cs hljs">IItems items = ...; <span class="hljs-comment"><span class="hljs-comment">// . var x = items.All(where: x =&gt; x.IsWeapon); //  . // `ItemsThatAre.Weapons`  `Predicate&lt;bool&gt;`. var x = items.All(ItemsThatAre.Weapons); // `using static`  !  . var x = items.All(Weapons);</span></span></code> </pre> <br><h3 id="ekzoticheskiy-find"> 异国<code>Find</code> </h3><br><p> 在C＃7.1和更高版本中，您不能写<code>Find(1, @in: items)</code> ，而不能写<code>Find(1, in items)</code> ，其中<code>Find</code>定义为<code>Find&lt;T&gt;(T item, in IEnumerable&lt;T&gt; items)</code> 。 这个例子是不切实际的，但是表明在努力提高可读性方面，所有手段都是好的。 </p><br><h2 id="itogo"> 合计 </h2><br><p> 在这一部分中，我研究了提高代码可读性的几种方法。 所有这些都可以概括为： </p><br><ul><li>  <strong>作为表达式一部分的命名参数为</strong> <code>Should().Be(4, because: "")</code> ， <code>Atomically.Change(ref x, from: oldX, to: newX)</code> 。 </li><li>  <strong>一个简单的名称而不是技术详细信息</strong>是<code>Separated(with: ", ")</code> ， <code>Exclude</code> 。 </li><li>  <strong>作为变量一部分的方法</strong>是<code>x.OrDefault()</code> ， <code>x.Or(b).IfLess()</code> ， <code>x.Or(b).IfLess()</code> <code>orders.One(with: id)</code> ， <code>orders.All</code> 。 </li><li>  <strong>作为表达式一部分的方法</strong>是<code>path.Without(".exe").AtEnd</code> 。 </li><li>  <strong>作为表达式一部分的类型</strong>是<code>Instances.Of</code> ， <code>Is.EqualTo</code> 。 </li><li>  <strong>作为表达式一部分的方法（ <code>using static</code> ）</strong>是<code>Ensure(that: x)</code> ， <code>items.All(Weapons)</code> 。 </li></ul><br><p> 因此，外部的和预期的成为最重要的。 首先考虑一下，然后考虑其特定的形式，只要代码被读为文本，就没有那么重要了。 由此可见，法官与其说是<em>语言，</em>不如说是他的品味-他确定<code>item.GetValueOrDefault</code>和<code>item.OrDefault</code>之间的区别。 </p><br><h2 id="epilog"> 结语 </h2><br><p> 哪个更好，更清楚，但不是可行的方法，或者是可行的，却难以理解？ 没有家具和房间的雪白城堡，还是路易十四风格的带沙发棚？ 没有引擎或or吟的驳船以及没有人能使用的量子计算机的豪华游艇？ </p><br><p> 极地答案不适合，但也<em>“在中间的某个地方”</em> 。 </p><br><p> 我认为，这两个概念是密不可分的：仔细选择书籍的封面，我们会怀疑文本中的错误，反之亦然。 我不希望<em>甲壳虫乐队</em>播放低质量的音乐，但也<em>应将</em>它们称为<em>MusicHelper</em> 。 </p><br><p> 另一件事是，在开发过程中处理单词是一件被低估的，不寻常的事情，因此仍然需要某种极端的判断力。 这个周期是形式和图片的极限。 </p><br><p> 谢谢大家的关注！ </p><br><h2 id="ssylki"> 参考文献 </h2><br><p> 任何有兴趣查看更多示例的人都可以在我的GitHub上找到，例如，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Pocket.Common</code></a>库中。  <em>（不适用于全球和通用）</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447830/">https://habr.com/ru/post/zh-CN447830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447818/index.html">敏捷日2019</a></li>
<li><a href="../zh-CN447820/index.html">将3D模型导入Unity和陷阱</a></li>
<li><a href="../zh-CN447822/index.html">几乎被解雇了。 我如何建立Yandex分析部门</a></li>
<li><a href="../zh-CN447826/index.html">招聘人员必须能够出售</a></li>
<li><a href="../zh-CN447828/index.html">我们如何为Rostelecom中的人们提供IT服务</a></li>
<li><a href="../zh-CN447832/index.html">不久前</a></li>
<li><a href="../zh-CN447834/index.html">在9秒钟内销毁。 未知算法如何破坏IPO BATS</a></li>
<li><a href="../zh-CN447836/index.html">试驾nanoCAD SPDS Metalwork 1.2。 第一部分</a></li>
<li><a href="../zh-CN447838/index.html">物联网技术将在未来10年改变世界</a></li>
<li><a href="../zh-CN447842/index.html">微生物群。 这是什么器官，为什么我们需要它</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>