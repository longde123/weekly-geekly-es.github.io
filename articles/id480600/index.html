<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏕️ 💃🏽 😜 Enum lebih cepat ♦️ 🧘🏽 👩🏼‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="tl; dr 
 github.com/QratorLabs/fastenum 


pip install fast-enum  
 Apa itu enum? 
 (Jika Anda pikir Anda tahu itu - gulir ke bawah ke bagian "Enums i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enum lebih cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/480600/"><h4>  tl; dr </h4><br>  <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> <br><pre><code class="bash hljs">pip install fast-enum</code> </pre> <br><h3>  Apa itu enum? </h3><br>  (Jika Anda pikir Anda tahu itu - gulir ke bawah ke bagian "Enums in Standard Library"). <br><br>  Bayangkan Anda perlu mendeskripsikan sekumpulan keadaan yang memungkinkan untuk entitas dalam model database Anda.  Anda mungkin akan menggunakan banyak konstanta yang didefinisikan sebagai atribut tingkat modul: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># /path/to/package/static.py: INITIAL = 0 PROCESSING = 1 PROCESSED = 2 DECLINED = 3 RETURNED = 4 ...</span></span></code> </pre> <br>  ... atau sebagai atribut level-kelas yang didefinisikan di kelas mereka sendiri: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = <span class="hljs-number"><span class="hljs-number">0</span></span> PROCESSING = <span class="hljs-number"><span class="hljs-number">1</span></span> PROCESSED = <span class="hljs-number"><span class="hljs-number">2</span></span> DECLINED = <span class="hljs-number"><span class="hljs-number">3</span></span> RETURNED = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Itu membantu Anda merujuk negara-negara tersebut dengan nama mnemoniknya, sementara mereka tetap berada di penyimpanan Anda sebagai bilangan bulat sederhana.  Dengan ini, Anda menyingkirkan angka ajaib yang tersebar melalui kode Anda dan membuatnya lebih mudah dibaca dan deskriptif diri. <br><br>  Tapi, baik konstanta level modul dan kelas dengan atribut statis menderita dari sifat inheren objek python: mereka semua bisa berubah.  Anda dapat secara tidak sengaja memberikan nilai pada konstanta saat runtime, dan itu adalah kekacauan untuk debug dan mengembalikan entitas yang rusak.  Jadi, Anda mungkin ingin membuat rangkaian konstanta Anda tidak berubah, yang berarti jumlah konstanta yang dideklarasikan dan nilai-nilai yang dipetakan tidak boleh dimodifikasi saat runtime. <br><a name="habracut"></a><br>  Untuk tujuan ini, Anda dapat mencoba mengaturnya menjadi nama tupel dengan <code>namedtuple()</code> , sebagai contoh: <br><pre> <code class="python hljs">MyModelStates = namedtuple(<span class="hljs-string"><span class="hljs-string">'MyModelStates'</span></span>, (<span class="hljs-string"><span class="hljs-string">'INITIAL'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSING'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSED'</span></span>, <span class="hljs-string"><span class="hljs-string">'DECLINED'</span></span>, <span class="hljs-string"><span class="hljs-string">'RETURNED'</span></span>)) EntityStates = MyModelStates(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  Namun, ini masih tidak terlihat terlalu dimengerti: di samping itu, objek <code>namedtuple</code> tidak benar-benar dapat diperpanjang.  Katakanlah Anda memiliki UI yang menampilkan semua status ini.  Anda kemudian dapat menggunakan konstanta berbasis modul, kelas Anda dengan atribut, atau menamai tuple untuk merendernya (dua yang terakhir lebih mudah untuk di-render, sementara kami melakukannya).  Tetapi kode Anda tidak memberikan peluang apa pun untuk memberi pengguna deskripsi yang memadai untuk setiap negara yang telah Anda tetapkan.  Selain itu, jika Anda berencana untuk mengimplementasikan dukungan multi-bahasa dan i18n di UI Anda, Anda akan menemukan bahwa mengisi semua terjemahan untuk deskripsi ini menjadi tugas yang sangat melelahkan.  Nilai-nilai negara yang cocok mungkin tidak harus memiliki deskripsi yang cocok yang berarti bahwa Anda tidak bisa hanya memetakan semua status <code>INITIAL</code> Anda ke deskripsi yang sama di <code>gettext</code> .  Alih-alih, konstanta Anda menjadi ini: <br><pre> <code class="python hljs">INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'My_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Kelas Anda kemudian menjadi ini: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Dan akhirnya, namamu yang <code>namedtuple</code> menjadi ini: <br><pre> <code class="python hljs">EntityStates = MyModelStates((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>), ...)</code> </pre><br>  Baiklah, cukup bagus, sekarang memastikan nilai status dan stub terjemahan dipetakan ke bahasa yang didukung oleh UI Anda.  Tetapi sekarang Anda mungkin memperhatikan bahwa kode yang menggunakan pemetaan itu telah berubah menjadi berantakan.  Setiap kali Anda mencoba untuk menetapkan nilai pada entitas Anda, Anda juga tidak perlu lupa untuk mengekstraksi nilai pada indeks 0 dari pemetaan yang Anda gunakan: <br><br><pre> <code class="python hljs">my_entity.state = INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  atau <pre> <code class="python hljs">my_entity.state = MyModelStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  atau <pre> <code class="python hljs">my_entity.state = EntityStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Dan sebagainya.  Perlu diingat bahwa dua pendekatan pertama yang menggunakan atribut konstanta dan kelas, masing-masing, masih mengalami mutabilitas. <br><br><h4>  Dan kemudian Enums muncul di panggung </h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEntityStates</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val, description)</span></span></span><span class="hljs-function">:</span></span> self.val = val self.description = description INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>) PROCESSING = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_BEING_PROCESSED_STATE'</span></span>) PROCESSED = (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_PROCESSED_STATE'</span></span>) DECLINED = (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_DECLINED_STATE'</span></span>) RETURNED = (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_RETURNED_STATE'</span></span>)</code> </pre> <br>  Itu dia.  Sekarang Anda dapat dengan mudah mengulangi enum di renderer Anda (sintaks Jinja2): <br><pre> <code class="python hljs">{% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> MyEntityState %} &lt;option value=”{{ state.val }}”&gt;{{ _(state.description) }}&lt;/option&gt; {% endfor %}</code> </pre> <br>  Enum tidak dapat diubah untuk kedua set anggota (Anda tidak dapat menentukan anggota baru saat runtime, Anda juga tidak dapat menghapus anggota yang sudah ditentukan) dan nilai anggota yang mereka pertahankan (Anda tidak dapat menetapkan kembali nilai atribut apa pun atau menghapus atribut). <br><br>  Dalam kode Anda, Anda hanya menetapkan nilai untuk entitas Anda seperti ini: <br><pre> <code class="python hljs">my_entity.state = MyEntityStates.INITIAL.val</code> </pre> <br>  Cukup jelas.  Cukup deskriptif.  Cukup diperpanjang.  Untuk itulah kami menggunakan Enums. <br><br><h3>  Kenapa lebih cepat? </h3><br>  Tetapi ENUM default agak lambat jadi kami bertanya pada diri sendiri - bisakah kami membuatnya lebih cepat? <br>  Ternyata, kita bisa.  Yaitu, dimungkinkan untuk membuatnya: <br><br><ul><li>  3 kali lebih cepat pada akses anggota </li><li>  ~ 8,5 kali lebih cepat pada akses atribut ( <code>name</code> , <code>value</code> ) </li><li>  3 kali lebih cepat pada akses enum dengan nilai (panggilan pada kelas enum <code>MyEnum(value)</code> ) </li><li>  1,5 kali lebih cepat pada akses enum dengan nama (seperti <code>MyEnum[name]</code> seperti dict) </li></ul><br>  Jenis dan objek bersifat dinamis dengan Python.  Tapi Python memiliki alat untuk membatasi sifat dinamis objek.  Dengan bantuan mereka, seseorang dapat memperoleh peningkatan kinerja yang signifikan menggunakan <code>__slots__</code> serta menghindari menggunakan Deskriptor Data jika memungkinkan tanpa pertumbuhan kompleksitas yang signifikan atau jika Anda bisa mendapatkan keuntungan dalam kecepatan. <br><br><h4>  Slot </h4><br>  Sebagai contoh, seseorang dapat menggunakan deklarasi kelas dengan <code>__slots__</code> - dalam kasus ini, instance kelas hanya akan memiliki sekumpulan atribut terbatas: atribut yang dideklarasikan dalam <code>__slots__</code> dan semua <code>__slots__</code> dari kelas induk. <br><br><h4>  Penjelas </h4><br>  Secara default, juru bahasa Python mengembalikan nilai atribut suatu objek secara langsung: <br><pre> <code class="python hljs">value = my_obj.attribute <span class="hljs-comment"><span class="hljs-comment"># this is a direct access to the attribute value by the pointer that the object holds for that attribute</span></span></code> </pre> <br>  Menurut model data Python, jika nilai atribut suatu objek itu sendiri merupakan objek yang mengimplementasikan Protokol Penjelasan Data, itu berarti bahwa ketika Anda mencoba untuk mendapatkan nilai itu, Anda pertama-tama mendapatkan atribut sebagai objek dan kemudian metode khusus <code>__get__</code> adalah dipanggil pada atribut-objek yang melewati objek penjaga itu sendiri sebagai argumen: <br><pre> <code class="python hljs">obj_attribute = my_obj.attribute obj_attribute_value = obj_attribute.__get__(my_obj)</code> </pre> <br><h4>  Enum di Perpustakaan Standar </h4><br>  Setidaknya <code>name</code> dan <code>value</code> atribut dari implementasi Enum standar dinyatakan sebagai <code>types.DynamicClassAttribute</code> .  Itu berarti bahwa ketika Anda mencoba untuk mendapatkan <code>name</code> (atau <code>value</code> ) anggota, alurnya mengikuti: <br><br><pre> <code class="python hljs">one_value = StdEnum.ONE.value <span class="hljs-comment"><span class="hljs-comment"># that is what you write in your code one_value_attribute = StdEnum.ONE.value one_value = one_value_attribute.__get__(StdEnum.ONE)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># and this is what really __get__ does (python 3.7 implementation): def __get__(self, instance, ownerclass=None): if instance is None: if self.__isabstractmethod__: return self raise AttributeError() elif self.fget is None: raise AttributeError("unreadable attribute") return self.fget(instance)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># since DynamicClassAttribute is a decorator on Enum methods `name` and `value` the final row of __get__() ends up with: @DynamicClassAttribute def name(self): """The name of the Enum member.""" return self._name_ @DynamicClassAttribute def value(self): """The value of the Enum member.""" return self._value_</span></span></code> </pre> <br>  Jadi, aliran lengkap dapat direpresentasikan sebagai pseudo-code berikut: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(enum_member, attrname)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># this is also a __dict__ lookup so hash + hashtable scan also occur return getattr(enum_member, f'_{attrnme}_') def get_name_value(enum_member): name_descriptor = get_descriptor(enum_member, 'name') if enum_member is None: if name_descriptor.__isabstractmethod__: return name_descriptor raise AttributeError() elif name_descriptor.fget is None: raise AttributeError("unreadable attribute") return get_func(enum_member, 'name')</span></span></code> </pre> <br>  Kami telah membuat skrip sederhana yang menunjukkan kesimpulan di atas: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Enum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StdEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value, description)</span></span></span><span class="hljs-function">:</span></span> self.v = value self.description = description A = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'One'</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'Two'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StdEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'stdenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  Dan setelah kita menjalankan skrip, ia menciptakan gambar ini untuk kita: <br><img src="https://habrastorage.org/webt/op/ff/m7/opffm7k3v2rgako7xufgkgqtcek.png"><br><br>  Ini membuktikan bahwa setiap kali Anda mengakses <code>name</code> atribut stdlib enum dan <code>value</code> itu panggilan descriptor.  Deskriptor itu pada akhirnya berakhir dengan panggilan ke properti <code>def name(self)</code> stdlib enum <code>def name(self)</code> didekorasi dengan deskriptor. <br><br>  Nah, Anda dapat membandingkan ini dengan FastEnum kami: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fast_enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FastEnum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyNewEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> A = <span class="hljs-number"><span class="hljs-number">1</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyNewEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'fastenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  Yang menampilkan gambar ini: <br><img src="https://habrastorage.org/webt/le/ck/td/lecktd3dtx71oi3dmlyax7qyogu.png"><br><br>  Itulah yang benar-benar dilakukan di dalam implementasi Enum standar setiap kali Anda mengakses atribut <code>name</code> dan <code>value</code> anggota Enum Anda.  Dan itulah mengapa implementasi kami lebih cepat. <br><br>  <b>Implementasi kelas Enum oleh Python Standard Library menggunakan banyak panggilan protokol descriptor.</b>  Ketika kami mencoba menggunakan enum standar dalam proyek kami, kami telah memperhatikan berapa banyak protokol deskriptor yang memanggil atribut <code>name</code> dan <code>value</code> dari anggota <code>Enum</code> yang dipanggil.  Dan karena pencacahan digunakan secara berlebihan di seluruh kode, kinerja yang dihasilkan buruk. <br><br>  Selain itu, kelas enum standar berisi beberapa atribut pembantu "terlindungi": <br><ul><li>  <code>_member_names_</code> - daftar yang berisi semua nama anggota enum; </li><li>  <code>_member_map_</code> - sebuah OrderedDict yang memetakan nama anggota enum untuk anggota itu sendiri; </li><li>  <code>_value2member_map_</code> - kamus terbalik yang memetakan nilai anggota enum ke anggota enum yang sesuai. </li></ul><br>  Kamus pencarian lambat karena masing-masing mengarah ke perhitungan hash dan pencarian tabel hash, membuat kamus-kamus itu struktur dasar tidak optimal untuk kelas enum.  Bahkan pengambilan anggota itu sendiri (seperti dalam <code>StdEnum.MEMBER</code> ) adalah pencarian kamus. <br><br><h4>  Jalan kita </h4><br>  Saat mengembangkan implementasi Enum kami, kami mengingat enumerasi C-language yang cantik dan Java Enum yang dapat diperluas.  Fitur utama yang kami inginkan dalam implementasi kami: <br><br><ul><li>  sebuah Enum harus se-statis mungkin;  yang kami maksud dengan "statis" adalah: Jika sesuatu dapat dihitung sekali dan pada waktu deklarasi, itu harus; </li><li>  sebuah Enum tidak dapat disubklasifikasi (harus menjadi kelas "final") jika sebuah subkelas mendefinisikan anggota enum baru - ini berlaku untuk implementasi perpustakaan standar, dengan pengecualian bahwa subklasifikasi dilarang bahkan jika tidak ada anggota baru yang ditetapkan; </li><li>  sebuah Enum harus memiliki kemungkinan luas untuk ekstensi (atribut tambahan, metode, dan sebagainya). </li></ul><br>  Satu-satunya waktu kami menggunakan pencarian kamus adalah dalam <code>value</code> pemetaan terbalik untuk anggota Enum.  Semua perhitungan lain dilakukan hanya sekali selama deklarasi kelas (di mana kait metaclasses digunakan untuk mengkustomisasi pembuatan tipe). <br>  Berbeda dengan implementasi perpustakaan standar, kami memperlakukan nilai pertama setelah <code>=</code> tanda dalam deklarasi kelas sebagai nilai anggota: <br>  <code>A = 1, 'One'</code> di pustaka standar dengan seluruh tuple <code>1, "One"</code> diperlakukan sebagai <code>value</code> <br>  <code>A: 'MyEnum' = 1, 'One'</code> dalam implementasi kami, hanya <code>1</code> yang dianggap sebagai <code>value</code> <br><br>  <code>__slots__</code> lebih lanjut diperoleh dengan menggunakan <code>__slots__</code> kapan pun memungkinkan.  Dalam model data Python, kelas yang dideklarasikan dengan <code>__slots__</code> tidak memiliki atribut <code>__dict__</code> yang menyimpan atribut instance (jadi Anda tidak dapat menetapkan atribut apa pun yang tidak disebutkan dalam <code>__slots__</code> ).  Selain itu, atribut yang didefinisikan dalam <code>__slots__</code> diakses pada offset konstan ke pointer objek level-C.  Itu adalah akses atribut kecepatan tinggi karena ia menghindari perhitungan hash dan pemindaian hashtable. <br><br><h3>  Apa fasilitas tambahannya? </h3><br>  FastEnum tidak kompatibel dengan versi Python sebelum 3.6, karena terlalu banyak menggunakan modul <code>typing</code> yang diperkenalkan di Python 3.6;  Orang bisa berasumsi bahwa menginstal modul <code>typing</code> backport dari PyPI akan membantu.  Jawabannya adalah: tidak.  Implementasi menggunakan PEP-484 untuk beberapa argumen fungsi dan metode dan mengisyaratkan tipe nilai kembali, sehingga versi apa pun sebelum Python 3.5 tidak didukung karena ketidakcocokan sintaksis.  Tapi sekali lagi, baris pertama kode di <code>__new__</code> dari metaclass menggunakan sintaks PEP-526 untuk mengisyaratkan tipe variabel.  Jadi Python 3.5 tidak akan melakukan keduanya.  Dimungkinkan untuk port implementasi ke versi yang lebih lama, meskipun kami di Qrator Labs cenderung menggunakan petunjuk tipe bila memungkinkan karena sangat membantu mengembangkan proyek yang kompleks.  Dan hei!  Anda tidak ingin tetap menggunakan python sebelum 3.6 karena tidak ada yang tidak kompatibel dengan kode Anda yang ada (dengan asumsi Anda tidak menggunakan Python 2) meskipun banyak pekerjaan yang dilakukan di asyncio dibandingkan dengan 3,5. <br><br>  Itu, pada gilirannya, membuat impor khusus seperti <code>auto</code> tidak perlu, tidak seperti di perpustakaan standar.  Anda mengetik-isyarat semua anggota Enum Anda dengan nama kelas Enum Anda, tidak memberikan nilai sama sekali - dan nilai akan dihasilkan untuk Anda secara otomatis.  Meskipun python 3.6 sudah cukup untuk bekerja dengan FastEnum, perlu diingat bahwa urutan kamus standar dari pernyataan deklarasi diperkenalkan hanya dalam python 3.7.  Kami tidak tahu peralatan apa pun yang bermanfaat di mana urutan nilai yang dihasilkan secara otomatis penting (karena kami menganggap nilai yang dihasilkan itu sendiri bukanlah nilai yang dipedulikan oleh programmer).  Meskipun demikian, anggap diri Anda diperingatkan jika Anda masih menggunakan python 3.6; <br><br>  Mereka yang membutuhkan enum mereka mulai dari 0 (nol) daripada default 1 dapat melakukan ini dengan atribut deklarasi enum khusus <code>_ZERO_VALUED</code> , atribut itu "dihapus" dari kelas Enum yang dihasilkan; <br><br>  Namun ada beberapa batasan: semua nama anggota enum harus dikapitalisasi atau mereka tidak akan diambil oleh metaclass dan tidak akan diperlakukan sebagai anggota enum; <br><br>  Namun, Anda bisa mendeklarasikan kelas dasar untuk enum Anda (perlu diingat bahwa kelas dasar dapat menggunakan enum metaclass itu sendiri, sehingga Anda tidak perlu memberikan metaclass ke semua subclass): Anda dapat menentukan logika umum (atribut dan metode) dalam hal ini kelas, tetapi mungkin tidak mendefinisikan anggota enum (sehingga kelas tidak akan "diselesaikan").  Anda kemudian dapat subkelas kelas itu dalam deklarasi enum sebanyak yang Anda inginkan dan itu akan memberi Anda semua logika umum; <br><br>  Alias  Kami akan menjelaskannya dalam topik terpisah (diterapkan pada 1.2.5) <br><br><h3>  Alias ​​dan bagaimana mereka bisa membantu </h3><br>  Misalkan Anda memiliki kode yang menggunakan: <br><pre> <code class="python hljs">package_a.some_lib_enum.MyEnum</code> </pre> <br>  Dan MyEnum dinyatakan seperti ini: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> ONE: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span> TWO: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span></code> </pre> <br>  Sekarang, Anda memutuskan untuk membuat refactoring dan ingin memindahkan enum Anda ke paket lain.  Anda membuat sesuatu seperti ini: <br><pre> <code class="python hljs">package_b.some_lib_enum.MyMovedEnum</code> </pre> <br>  Di mana MyMovedEnum dinyatakan seperti ini: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyMovedEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MyEnum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br>  Sekarang  Anda siap untuk memulai tahap "penghentian" untuk semua kode yang menggunakan enum Anda.  Anda mengalihkan penggunaan langsung <code>MyEnum</code> untuk menggunakan <code>MyMovedEnum</code> (yang terakhir memiliki semua anggotanya diproksi ke dalam <code>MyEnum</code> ).  Anda menyatakan dalam dokumen proyek Anda bahwa <code>MyEnum</code> sudah usang dan akan dihapus dari kode di beberapa titik di masa depan.  Misalnya, dalam rilis berikutnya.  Pertimbangkan kode Anda menyimpan objek Anda dengan atribut enum menggunakan acar.  Pada titik ini, Anda menggunakan <code>MyMovedEnum</code> dalam kode Anda, tetapi secara internal semua anggota enum Anda masih merupakan instance <code>MyEnum</code> .  Langkah Anda berikutnya adalah dengan menukar deklarasi <code>MyEnum</code> dan <code>MyMovedEnum</code> sehingga <code>MyMovedEnum</code> sekarang tidak akan menjadi subkelas dari <code>MyEnum</code> dan mendeklarasikan semua anggotanya sendiri;  <code>MyEnum</code> , di sisi lain, tidak akan mendeklarasikan anggota tetapi menjadi hanya alias (subkelas) dari <code>MyMovedEnum</code> . <br><br>  Dan itu menyimpulkannya.  Saat memulai kembali runtime Anda pada tahap unpickle, semua nilai enum Anda akan dialihkan ke <code>MyMovedEnum</code> dan menjadi terikat kembali ke kelas baru itu.  Saat Anda yakin semua objek acar Anda telah tidak (kembali) diasapi dengan struktur organisasi kelas ini, Anda bebas untuk membuat rilis baru, di mana sebelumnya ditandai sebagai <code>MyEnum</code> Anda yang sudah usang dapat dinyatakan usang dan dilenyapkan dari basis kode Anda. <br><br>  Kami mendorong Anda untuk mencobanya!  <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> , <a href="https://pypi.org/project/fast-enum/">pypi.org/project/fast-enum</a> .  Semua kredit dikirim ke penulis <a href="https://habr.com/en/users/santjagocorkez/" class="user_link">FastEnum, santjagocorkez</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480600/">https://habr.com/ru/post/id480600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480582/index.html">Security Week 51: kerentanan dalam prosesor iOS dan Intel</a></li>
<li><a href="../id480584/index.html">C ++ Rusia: masa lalu, sekarang dan masa depan</a></li>
<li><a href="../id480594/index.html">Sebelum dan Sesudah: Evolusi Visual dari Video Game Terkenal</a></li>
<li><a href="../id480596/index.html">Apa yang menanti Anda dalam sistem operasi jaringan inovatif ArubaOS-CX</a></li>
<li><a href="../id480598/index.html">Dasar dari setiap pemrograman pada ... puzzle</a></li>
<li><a href="../id480606/index.html">Lima ide lagi tentang cara meningkatkan keterampilan Anda sebagai pengembang front-end (Desember 2019)</a></li>
<li><a href="../id480608/index.html">Rust Mengungguli C ++ dengan Hasil Game Benchmark</a></li>
<li><a href="../id480612/index.html">Buat perubahan ini untuk memenuhi standar aksesibilitas desain web.</a></li>
<li><a href="../id480614/index.html">ENUM cepat</a></li>
<li><a href="../id480618/index.html">Permainan elektronik Tic Tac Toe. Apa yang telah saya lakukan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>