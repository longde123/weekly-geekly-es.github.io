<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå•Ô∏è üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø ‚ôâÔ∏è Creaci√≥n de una arquitectura de microservicios en Golang y gRPC, parte 2 (acoplador) üë©üèø üë®üèæ‚Äçüî¨ ü§∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es hora de abordar los contenedores. 
 En primer lugar, utilizamos la √∫ltima imagen de Linux Alpine. Linux Alpine es una distribuci√≥n liviana de Linux...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creaci√≥n de una arquitectura de microservicios en Golang y gRPC, parte 2 (acoplador)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455812/"><h3>  Es hora de abordar los contenedores. </h3><br>  En primer lugar, utilizamos la √∫ltima imagen de Linux Alpine.  Linux Alpine es una distribuci√≥n liviana de Linux dise√±ada y optimizada para ejecutar aplicaciones web en Docker.  En otras palabras, Linux Alpine tiene suficientes dependencias y funcionalidades para ejecutar la mayor√≠a de las aplicaciones.  ¬°Esto significa que el tama√±o de la imagen es de aproximadamente 8 MB! <br><br>  En comparaci√≥n con, digamos ... una m√°quina virtual Ubuntu con una capacidad de aproximadamente 1 GB, es por eso que las im√°genes de Docker se han vuelto m√°s naturales para los microservicios y la computaci√≥n en la nube. <br><br>  Entonces, ahora espero que vea valor en la contenedorizaci√≥n, y podamos comenzar a "Dockerising" nuestro primer servicio.  Creemos un Dockerfile <b>$ touch</b> consignment <b>-service / Dockerfile</b> . <br><br><img src="https://habrastorage.org/webt/xf/a7/ex/xfa7exynloocyeogmno3p3le27m.jpeg"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera parte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dep√≥sito original de EwanValentine</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo original</a> <br><br>  En el Dockerfile, agregue lo siguiente: <br><br><pre><code class="plaintext hljs">FROM alpine:latest RUN mkdir /app WORKDIR /app ADD consignment-service /app/consignment-service CMD ["./consignment-service"]</code> </pre> <br>  Luego creamos un nuevo directorio para alojar nuestra aplicaci√≥n.  Luego agregamos nuestro binario compilado a nuestro contenedor Docker y lo ejecutamos. <br><br>  Ahora, vamos a actualizar el registro de compilaci√≥n de nuestro Makefile para crear una imagen Docker. <br><br><pre> <code class="plaintext hljs">build: ... GOOS=linux GOARCH=amd64 go build docker build -t consignment .</code> </pre><br>  Agregamos dos pasos m√°s, y me gustar√≠a explicarlos con m√°s detalle.  En primer lugar, creamos nuestro binario Go.  Sin embargo, notar√° dos variables de entorno antes de ejecutar $ go build.  GOOS y GOARCH le permiten compilar su binario para otro sistema operativo.  Como estoy desarrollando un Macbook, no puedo compilar el ejecutable go y luego ejecutarlo en un contenedor Docker que usa Linux.  El binario no tendr√° ning√∫n significado en su contenedor Docker y arrojar√° un error. <br><br>  El segundo paso que agregu√© es el proceso de construcci√≥n de Docker.  Docker leer√° su Dockerfile y crear√° una imagen llamada consign-service, el punto indica la ruta del directorio, por lo que aqu√≠ solo queremos que el proceso de compilaci√≥n mire el directorio actual. <br><br>  Voy a agregar una nueva entrada a nuestro Makefile: <br><br><pre> <code class="plaintext hljs">run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Aqu√≠ lanzamos nuestra imagen docker abriendo el puerto 50051. Dado que Docker opera en una capa de red separada, debe redirigir el puerto.  Por ejemplo, si desea iniciar este servicio en el puerto 8080, debe cambiar el argumento -p a 8080: 50051.  Tambi√©n puede ejecutar el contenedor en segundo plano incluyendo la bandera -d.  Por ejemplo, <b>docker run -d -p 50051: 50051 consignaci√≥n-servicio</b> . <br><br>  Ejecute <b>$ make run</b> , luego en un panel de terminal separado nuevamente <b>$ go run main.go</b> y verifique que todav√≠a funcione. <br><br>  Cuando ejecuta $ docker build, incrusta su c√≥digo y tiempo de ejecuci√≥n en la imagen.  Las im√°genes de Docker son im√°genes port√°tiles de su entorno y sus dependencias.  Puede compartir im√°genes de Docker public√°ndolas en Docker Hub.  Que es similar a npm o al repositorio de yum para im√°genes de docker.  Cuando define FROM en su Dockerfile, le dice a Docker que extraiga esta imagen del repositorio de Docker para usarla como base.  Luego puede expandir y redefinir partes de este archivo base, redefini√©ndolas como desee.  No publicaremos nuestras im√°genes de docker, pero si√©ntase libre de navegar por el repositorio de docker y tenga en cuenta que casi cualquier software ya ha sido empaquetado en contenedores.  Algunas cosas realmente maravillosas fueron atracadas. <br><br>  Cada anuncio en Dockerfile se almacena en cach√© la primera vez que se crea.  Esto elimina la necesidad de reconstruir todo el tiempo de ejecuci√≥n cada vez que realiza cambios.  La ventana acoplable es lo suficientemente inteligente como para descubrir qu√© detalles han cambiado y cu√°les deben reconstruirse.  Esto hace que el proceso de construcci√≥n sea incre√≠blemente r√°pido. <br><br>  Suficiente sobre los contenedores!  Volvamos a nuestro c√≥digo. <br><br>  Al crear el servicio gRPC, hay una gran cantidad de c√≥digo est√°ndar para crear conexiones, y debe codificar la ubicaci√≥n de la direcci√≥n del servicio en el cliente u otro servicio para que pueda conectarse a √©l.  Esto es dif√≠cil porque cuando inicia servicios en la nube, es posible que no usen el mismo host o que la direcci√≥n o la direcci√≥n IP puedan cambiar despu√©s de que el servicio se vuelva a implementar. <br><br>  Aqu√≠ es donde entra en juego el servicio de descubrimiento.  El servicio de descubrimiento actualiza el directorio de todos sus servicios y sus ubicaciones.  Cada servicio se registra en tiempo de ejecuci√≥n y se anula el registro al cierre.  A cada servicio se le asigna un nombre o identificador.  Por lo tanto, incluso si puede tener una nueva direcci√≥n IP o una direcci√≥n de host, siempre que el nombre del servicio permanezca igual, no necesita actualizar las llamadas a este servicio desde otros servicios. <br><br>  Como regla, hay muchos enfoques para este problema, pero, como la mayor√≠a de las cosas en la programaci√≥n, si alguien ya ha solucionado este problema, no tiene sentido reinventar la rueda.  @Chuhnk (Asim Aslam), el creador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Go-micro</a> , resuelve estos problemas con una claridad y facilidad de uso fant√°sticas.  √âl solo produce un software fant√°stico.  ¬°Por favor considera ayudarlo si te gusta lo que ves! <br><br><h3>  Ir micro </h3><br>  Go-micro es un potente marco de microservicios escrito en Go, para su uso, en su mayor parte, con Go.  Sin embargo, puede usar Sidecar para interactuar con otros idiomas. <br><br>  Go-micro tiene caracter√≠sticas √∫tiles para crear microservicios en Go.  Pero comenzaremos con quiz√°s el problema m√°s com√∫n que resuelve, y este es el descubrimiento de un servicio. <br><br>  Tendremos que hacer varias actualizaciones a nuestro servicio para poder trabajar con go-micro.  Go-micro se integra como un complemento de Protocolos, en este caso reemplaza el complemento est√°ndar de gRPC que estamos utilizando actualmente.  Entonces, comencemos reemplazando esto en nuestro Makefile. <br><br>  Aseg√∫rese de instalar las dependencias go-micro: <br><br><pre> <code class="plaintext hljs">go get -u github.com/micro/protobuf/{proto,protoc-gen-go}</code> </pre> <br>  Actualice nuestro Makefile para usar el complemento go-micro en lugar del complemento gRPC: <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Ahora necesitamos actualizar nuestro shippy-service-consignment / main.go para usar go-micro.  Esto resume la mayor parte de nuestro c√≥digo gRPC anterior.  Procesa f√°cilmente el registro y acelera la escritura de un servicio. <br><br><div class="spoiler">  <b class="spoiler_title">shippy-service-consignment / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// shippy-service-consignment/main.go package main import ( "fmt" //  protobuf  pb "github.com/EwanValentine/shippy/consignment-service/proto/consignment" "github.com/micro/go-micro" "context" ) //repository -   type repository interface { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } // Repository -    , //       type Repository struct { consignments []*pb.Consignment } func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //           . type service struct { repo repository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { // Save our consignment consignment, err := s.repo.Create(req) if err != nil { return err } // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { repo := &amp;Repository{} //     Go-micro srv := micro.NewService( //           proto micro.Name("shippy.service.consignment"), ) // Init will parse the command line flags. srv.Init() //   pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo}) //   log.Println(" ") if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  El cambio principal aqu√≠ es la forma en que creamos nuestro servidor gRPC, que ha sido cuidadosamente abstra√≠do de mico.NewService (), que maneja el registro de nuestro servicio.  Y finalmente, la funci√≥n service.Run (), que procesa la conexi√≥n en s√≠.  Como antes, registramos nuestra implementaci√≥n, pero esta vez con un m√©todo ligeramente diferente. <br><br>  El segundo cambio m√°s importante se refiere a los m√©todos de servicio en s√≠: los argumentos y los tipos de respuestas se modifican ligeramente para aceptar las estructuras de solicitud y respuesta como argumentos, y ahora solo devuelven un error.  En nuestros m√©todos, establecemos la respuesta que van los procesos micro. <br><br>  Finalmente, ya no programamos el puerto.  Go-micro debe configurarse utilizando variables de entorno o argumentos de l√≠nea de comandos.  Para establecer la direcci√≥n, use MICRO_SERVER_ADDRESS =: 50051.  De manera predeterminada, Micro usa mdns (dns de multidifusi√≥n) como agente de descubrimiento de servicios para uso local.  Por lo general, no utiliza mdns para descubrir servicios en un entorno de producci√≥n, pero queremos evitar tener que ejecutar algo como Consul o etcd localmente para realizar pruebas.  M√°s sobre esto m√°s tarde. <br><br>  Actualicemos nuestro Makefile para reflejar esto. <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 \ -e MICRO_SERVER_ADDRESS=:50051 \ shippy-service-consignment</code> </pre><br>  -e es el indicador de la variable de entorno, le permite pasar variables de entorno a su contenedor Docker.  Debe tener un indicador para cada variable, por ejemplo -e ENV = puesta en escena -e DB_HOST = localhost, etc. <br><br>  Ahora, si ejecuta $ make run, tendr√° un servicio Dockerised con descubrimiento de servicio.  Entonces, actualice nuestra herramienta Cli para usar esto. <br><br><div class="spoiler">  <b class="spoiler_title">consignaci√≥n-cli</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> micro <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pb.Consignment, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consignment *pb.Consignment data, err := ioutil.ReadFile(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } json.Unmarshal(data, &amp;consignment) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> consignment, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service := micro.NewService(micro.Name(<span class="hljs-string"><span class="hljs-string">"shippy.cli.consignment"</span></span>)) service.Init() client := pb.NewShippingServiceClient(<span class="hljs-string"><span class="hljs-string">"shippy.service.consignment"</span></span>, service.Client()) <span class="hljs-comment"><span class="hljs-comment">// Contact the server and print out its response. file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("Could not parse file: %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("Could not greet: %v", err) } log.Printf("Created: %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pb.GetRequest{}) if err != nil { log.Fatalf("Could not list consignments: %v", err) } for _, v := range getAll.Consignments { log.Println(v) } }</span></span></code> </pre><br></div></div><br>  Aqu√≠, importamos las bibliotecas go-micro para crear clientes y reemplazamos el c√≥digo de conexi√≥n existente con el c√≥digo de cliente go-micro, que utiliza el permiso del servicio en lugar de conectarse directamente a la direcci√≥n. <br><br>  Sin embargo, si ejecuta esto, no funcionar√°.  Esto se debe a que ahora estamos lanzando nuestro servicio en el contenedor Docker, que tiene sus propios mdns, separados del host mdns que estamos utilizando actualmente.  La forma m√°s f√°cil de solucionar esto es asegurarse de que tanto el servicio como el cliente se est√©n ejecutando en Dockerland, de modo que ambos trabajen en el mismo host y usen la misma capa de red.  Entonces, creemos make consignment-cli / Makefile y creemos algunas entradas. <br><br><pre> <code class="plaintext hljs">build: GOOS=linux GOARCH=amd64 go build docker build -t shippy-cli-consignment . run: docker run shippy-cli-consignment</code> </pre><br>  Como antes, queremos construir nuestro binario para Linux.  Cuando lanzamos nuestra imagen docker, queremos pasar una variable de entorno para dar el comando go-micro para usar mdns. <br><br>  Ahora creemos un Dockerfile para nuestra herramienta CLI: <br><br><pre> <code class="plaintext hljs">FROM alpine:latest RUN mkdir -p /app WORKDIR /app ADD consignment.json /app/consignment.json ADD consignment-cli /app/consignment-cli CMD ["./shippy-cli-consignment"]</code> </pre><br>  Esto es muy similar a nuestro servicio Dockerfile, excepto que tambi√©n extrae nuestro archivo de datos json. <br><br>  Ahora, cuando ejecute $ make run en su env√≠o shippy-cli, deber√≠a ver Creado: verdadero, como antes. <br><br>  Ahora, parece hora de echar un vistazo a la nueva funci√≥n Docker: compilaciones de varias etapas.  Esto nos permite usar m√∫ltiples im√°genes Docker en un Dockerfile. <br><br>  Esto es especialmente √∫til en nuestro caso, ya que podemos usar una imagen para crear nuestro archivo binario con todas las dependencias correctas.  Y luego usa la segunda imagen para iniciarlo.  Probemos esto, dejar√© comentarios detallados junto con el c√≥digo: <br><div class="spoiler">  <b class="spoiler_title">consignaci√≥n-servicio / Dockerfile</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># consignment-service/Dockerfile #     golang,    #     .    `as builder`, #     ,      . FROM golang:alpine as builder RUN apk --no-cache add git #         gopath WORKDIR /app/shippy-service-consignment #       COPY . . RUN go mod download #     ,   #       Alpine. RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-consignment #      FROM, #   Docker        . FROM alpine:latest # ,    -     RUN apk --no-cache add ca-certificates #   ,     . RUN mkdir /app WORKDIR /app #   ,       , #         `builder` #       , #    ,    , #      . ! COPY --from=builder /app/shippy-service-consignment/shippy-service-consignment . #     !        #        # run time . CMD ["./shippy-service-consignment"]</code> </pre><br></div></div><br>  Ahora pasar√© a otros archivos Docker y adoptar√© este nuevo enfoque.  ¬°Ah, y no olvides eliminar $ go build de tus Makefiles! <br><br><h3>  Servicio de env√≠o </h3><br>  Creemos un segundo servicio.  Tenemos un servicio (env√≠o-servicio-env√≠o), que se ocupa de la coordinaci√≥n del lote de contenedores con el barco, que es el m√°s adecuado para este lote.  Para que coincida con nuestro lote, debemos enviar el peso y la cantidad de contenedores a nuestro nuevo servicio de env√≠o, que luego encontrar√° un buque capaz de manejar este lote. <br><br>  Cree un nuevo directorio en su directorio ra√≠z <b>$ mkdir vessel-service</b> , ahora cree un subdirectorio para nuestra nueva definici√≥n de servicios protobuf, <b>$ mkdir -p shippy-service-vessel / proto / vessel</b> .  Ahora creemos un nuevo archivo de protobuf, <b>$ touch shippy-service-vessel / proto / vessel / vessel.proto</b> . <br><br>  Dado que la definici√≥n de protobuf es de hecho el n√∫cleo de nuestro dise√±o de software, comencemos con ella. <br><br><div class="spoiler">  <b class="spoiler_title">buque / buque.proto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// shippy-service-vessel/proto/vessel/vessel.proto syntax = "proto3"; package vessel; service VesselService { rpc FindAvailable(Specification) returns (Response) {} } message Vessel { string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6; } message Specification { int32 capacity = 1; int32 max_weight = 2; } message Response { Vessel vessel = 1; repeated Vessel vessels = 2; }</code> </pre><br></div></div><br>  Como puede ver, esto es muy similar a nuestro primer servicio.  Creamos un servicio con un m√©todo rpc llamado FindAvailable.  Esto toma un tipo de especificaci√≥n y devuelve un tipo de respuesta.  El tipo de respuesta devuelve el tipo de embarcaci√≥n o m√∫ltiples embarcaciones utilizando un campo repetitivo. <br><br>  Ahora necesitamos crear un Makefile para manejar nuestra l√≥gica de compilaci√≥n y nuestro script de inicio.  <b>$ touch shippy-service-vessel / Makefile</b> .  Abra este archivo y agregue lo siguiente: <br><br><pre> <code class="plaintext hljs">// vessel-service/Makefile build: protoc -I. --go_out=plugins=micro:. \ proto/vessel/vessel.proto docker build -t shippy-service-vessel . run: docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 shippy-service-vessel</code> </pre><br>  Esto es casi id√©ntico al primer Makefile que creamos para nuestro servicio de env√≠o, sin embargo, tenga en cuenta que los nombres de los servicios y puertos han cambiado un poco.  No podemos ejecutar dos contenedores de acoplamiento en el mismo puerto, por lo que utilizamos el reenv√≠o de puertos Dockers para que este servicio redirija de 50051 a 50052 en la red host. <br><br>  Ahora necesitamos un Dockerfile usando nuestro nuevo formato de etapas m√∫ltiples: <br><br><pre> <code class="plaintext hljs"># vessel-service/Dockerfile FROM golang:alpine as builder RUN apk --no-cache add git WORKDIR /app/shippy-service-vessel COPY . . RUN go mod download RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-vessel FROM alpine:latest RUN apk --no-cache add ca-certificates RUN mkdir /app WORKDIR /app COPY --from=builder /app/shippy-service-vessel . CMD ["./shippy-service-vessel"]</code> </pre><br>  Finalmente, podemos escribir nuestra implementaci√≥n: <br><br><div class="spoiler">  <b class="spoiler_title">servicio-buque / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// vessel-service/main.go package main import ( "context" "errors" "fmt" pb "github.com/EwanValentine/shippy/vessel-service/proto/vessel" "github.com/micro/go-micro" ) type Repository interface { FindAvailable(*pb.Specification) (*pb.Vessel, error) } type VesselRepository struct { vessels []*pb.Vessel } // FindAvailable -     , //           , //      . func (repo *VesselRepository) FindAvailable(spec *pb.Specification) (*pb.Vessel, error) { for _, vessel := range repo.vessels { if spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight { return vessel, nil } } //     return nil, errors.New("     ") } //    grpc type service struct { repo repository } func (s *service) FindAvailable(ctx context.Context, req *pb.Specification, res *pb.Response) error { //     vessel, err := s.repo.FindAvailable(req) if err != nil { return err } //       res.Vessel = vessel return nil } func main() { vessels := []*pb.Vessel{ &amp;pb.Vessel{Id: "vessel001", Name: "Boaty McBoatface", MaxWeight: 200000, Capacity: 500}, } repo := &amp;VesselRepository{vessels} srv := micro.NewService( micro.Name("shippy.service.vessel"), ) srv.Init() //    pb.RegisterVesselServiceHandler(srv.Server(), &amp;service{repo}) if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Ahora pasemos a la parte interesante.  Cuando creamos un env√≠o, necesitamos cambiar nuestro servicio de manejo de carga para contactar al servicio de b√∫squeda de barcos, encontrar el barco y actualizar el par√°metro ship_id en el env√≠o creado: <br><br><div class="spoiler">  <b class="spoiler_title">shippy / consignment-service / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> vesselProto <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-vessel/proto/vessel"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( port = <span class="hljs-string"><span class="hljs-string">":50051"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> repository <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } <span class="hljs-comment"><span class="hljs-comment">// Repository -    , //       type Repository struct { mu sync.RWMutex consignments []*pb.Consignment } //Create -     func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { repo.mu.Lock() updated := append(repo.consignments, consignment) repo.consignments = updated repo.mu.Unlock() return consignment, nil } //GetAll -       func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //            type service struct { repo repository vesselClient vesselProto.VesselServiceClient } // CreateConsignment -         create, //     ,     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { //         , //    vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification{ MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), }) log.Printf(" : %s \n", vesselResponse.Vessel.Name) if err != nil { return err } //     id  req.VesselId = vesselResponse.Vessel.Id //      consignment, err := s.repo.Create(req) if err != nil { return err } res.Created = true res.Consignment = consignment return nil } // GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { //   repo := &amp;Repository{} //  micro srv := micro.NewService( micro.Name("shippy.service.consignment"), ) srv.Init() vesselClient := vesselProto.NewVesselServiceClient("shippy.service.vessel", srv.Client()) //      gRPC. pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo, vesselClient}) //   if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Aqu√≠ creamos una instancia de cliente para nuestro servicio de env√≠o, que nos permite usar el nombre del servicio, es decir,  shipy.service.vessel para llamar al servicio del barco como cliente e interactuar con sus m√©todos.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, solo un m√©todo (FindAvailable). Enviamos el peso del lote junto con el n√∫mero de contenedores que queremos enviar como una especificaci√≥n para el servicio del barco. Lo que nos devuelve el recipiente correspondiente a esta especificaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualice el archivo consignment-cli / consignment.json, elimine el ship_id codificado, porque queremos confirmar que nuestro servicio de b√∫squeda de buques est√° funcionando. Adem√°s, agreguemos algunos contenedores m√°s y aumentemos el peso.</font></font> Por ejemplo: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">55000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"--"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_002"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_003"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora ejecute </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ make build &amp;&amp; make run</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en consignment-cli. </font><font style="vertical-align: inherit;">Deber√≠a ver una respuesta con una lista de los productos creados. </font><font style="vertical-align: inherit;">En sus fiestas, deber√≠a ver que el par√°metro vessel_id est√° configurado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Entonces, tenemos dos microservicios interconectados y una interfaz de l√≠nea de comando! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la siguiente parte de esta serie, consideraremos guardar algunos de estos datos con MongoDB. </font><font style="vertical-align: inherit;">Tambi√©n agregaremos un tercer servicio y usaremos docker-compose para administrar localmente nuestro creciente ecosistema de contenedores. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte I </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dep√≥sito original de EwanValentine</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455812/">https://habr.com/ru/post/455812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455796/index.html">Programaci√≥n orientada a objetos en Java y Python: similitudes y diferencias</a></li>
<li><a href="../455800/index.html">Matrix 1.0 - Lanzamiento del protocolo de mensajer√≠a descentralizada</a></li>
<li><a href="../455802/index.html">C√≥mo armar los Juegos Ol√≠mpicos a trav√©s de boletines electr√≥nicos. Estuche Black Star</a></li>
<li><a href="../455806/index.html">Nacimiento y muerte de un √°lbum: entendemos c√≥mo los formatos de m√∫sica han cambiado en los √∫ltimos 100 a√±os.</a></li>
<li><a href="../455808/index.html">Obtenga extractos del registro en el sitio web de FTS usando python</a></li>
<li><a href="../455816/index.html">C√≥mo crear una acci√≥n genial para el Asistente de Google. Lifehacks de Just AI</a></li>
<li><a href="../455820/index.html">An√°lisis de rendimiento de VM en VMware vSphere. Parte 2: memoria</a></li>
<li><a href="../455826/index.html">Riego autom√°tico controlado a distancia</a></li>
<li><a href="../455828/index.html">Los cient√≠ficos han descubierto nuevas formas ex√≥ticas de sincronizaci√≥n</a></li>
<li><a href="../455832/index.html">Historia de una sola investigaci√≥n SQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>