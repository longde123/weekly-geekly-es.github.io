<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòê üõåüèª üè† Prix ‚Äã‚ÄãJavaScript 2019 üë©üèø‚Äçü§ù‚Äçüë©üèΩ ‚õ∏Ô∏è üö¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours des derni√®res ann√©es, ce qu'on appelle le ¬´ prix JavaScript ¬ª a connu des changements positifs majeurs en raison de la vitesse d'analyse accr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prix ‚Äã‚ÄãJavaScript 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459296/">  Au cours des derni√®res ann√©es, ce qu'on appelle le ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prix JavaScript</a> ¬ª a connu des changements positifs majeurs en raison de la vitesse d'analyse accrue et de la compilation de scripts par le navigateur.  Maintenant, en 2019, les principaux composants de la charge sur les syst√®mes cr√©√©s par JavaScript sont le temps de chargement des scripts et leur temps d'ex√©cution. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/7x/g6/g_/7xg6g_poas_6_4qwu5u4clgjxrs.jpeg"></a> <br><br>  L'interaction de l'utilisateur avec le site peut √™tre temporairement interrompue si le navigateur est occup√© √† ex√©cuter du code JavaScript.  En cons√©quence, nous pouvons dire que l'optimisation des goulots d'√©tranglement associ√©s au chargement et √† l'ex√©cution de scripts peut avoir un fort impact positif sur les performances du site Web. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Directives pratiques g√©n√©rales pour l'optimisation de sites Web</font> </h2><br>  Que signifie ce qui pr√©c√®de pour les d√©veloppeurs Web?  Le point ici est que le co√ªt des ressources pour l'analyse (analyse, analyse) et la compilation de scripts ne sont pas aussi graves qu'auparavant.  Par cons√©quent, lors de l'analyse et de l'optimisation des bundles JavaScript, les d√©veloppeurs doivent prendre en compte les trois recommandations suivantes: <br><br><ol><li>  Essayez de r√©duire le temps requis pour t√©l√©charger les scripts. <br><br><ul><li>  Essayez de garder vos bundles JS petits.  Ceci est particuli√®rement important pour les sites con√ßus pour les appareils mobiles.  L'utilisation de petits ensembles am√©liore le temps de chargement du code, r√©duit le niveau d'utilisation de la m√©moire et r√©duit la charge du processeur. </li><li>  Essayez d'emp√™cher que tout le code du projet soit pr√©sent√© comme un seul gros paquet.  Si la taille du paquet d√©passe environ 50 √† 100 Ko - divisez-le en fragments s√©par√©s de petite taille.  Gr√¢ce au multiplexage HTTP / 2, plusieurs demandes de serveur et plusieurs r√©ponses peuvent √™tre trait√©es simultan√©ment.  Cela r√©duit la charge sur le syst√®me associ√©e √† la n√©cessit√© de r√©pondre √† des demandes suppl√©mentaires de chargement de donn√©es. </li><li>  Si vous travaillez sur un projet mobile, essayez de garder le code aussi petit que possible.  Cette recommandation est associ√©e √† de faibles d√©bits de donn√©es sur les r√©seaux mobiles.  De plus, efforcez-vous d'utiliser √©conomiquement la m√©moire. </li></ul></li><li>  Essayez de r√©duire le temps n√©cessaire √† l'ex√©cution des scripts. <br><br><ul><li> √âvitez d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des t√¢ches longues</a> qui peuvent charger le thread principal pendant une longue p√©riode et augmenter le temps n√©cessaire pour que les pages soient dans un √©tat dans lequel les utilisateurs peuvent interagir avec eux.  Dans l'environnement actuel, les scripts qui s'ex√©cutent apr√®s leur chargement apportent une contribution majeure au ¬´prix de JavaScript¬ª. </li></ul></li><li>  N'int√©grez pas d'extraits de code volumineux dans les pages. <br><br><ul><li>  La r√®gle suivante doit √™tre respect√©e ici: si la taille du script d√©passe 1 Ko, essayez de ne pas l'int√©grer dans le code de la page.  L'une des raisons de cette recommandation est le fait que 1 Ko est la limite apr√®s laquelle la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mise en cache</a> du code de script externe commence √† fonctionner dans Chrome.  Gardez √©galement √† l'esprit que l'analyse et la compilation de scripts int√©gr√©s sont toujours en cours d'ex√©cution dans le thread principal. </li></ul></li></ol><br><h2>  <font color="#3AC1EF">Pourquoi est-il si important de charger et d'ex√©cuter des scripts?</font> </h2><br>  Pourquoi est-il important d'optimiser le temps de chargement et d'ex√©cution des scripts dans des conditions modernes?  Les temps de chargement des scripts sont extr√™mement importants dans les situations o√π les sites sont accessibles via des r√©seaux lents.  Malgr√© le fait que les r√©seaux 4G (et m√™me 5G) se r√©pandent de plus en plus, la propri√©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NetworkInformation.effectiveType</a> dans de nombreux cas d'utilisation de connexions Internet mobiles affiche des indicateurs qui se situent au niveau des r√©seaux 3G ou m√™me √† des niveaux inf√©rieurs. <br><br>  Le temps requis pour ex√©cuter le code JS est important pour les appareils mobiles avec des processeurs lents.  En raison du fait que les appareils mobiles utilisent des CPU et GPU diff√©rents, du fait que lorsque les appareils surchauffent, afin de les prot√©ger, les performances de leurs composants diminuent, vous pouvez observer un √©cart important entre les performances des t√©l√©phones et tablettes chers et bon march√©.  Cela affecte consid√©rablement les performances du code JavaScript, car la capacit√© √† ex√©cuter ce code par un p√©riph√©rique est limit√©e par les capacit√©s du processeur de ce p√©riph√©rique. <br><br>  En fait, si nous analysons le temps total consacr√© au chargement et √† la pr√©paration de la page pour le travail dans un navigateur comme Chrome, environ 30% de ce temps peut √™tre consacr√© √† l'ex√©cution du code JS.  Vous trouverez ci-dessous une analyse du chargement d'une page Web tr√®s typique (reddit.com) sur un ordinateur de bureau hautes performances. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f6/af0/31d8f6af06d7158ecc9bd17710d216bb.png"></div><br>  <i><font color="#999999">Dans le processus de chargement de la page, environ 10 √† 30% du temps est consacr√© √† l'ex√©cution de code √† l'aide de V8</font></i> <br><br>  Si nous parlons d'appareils mobiles, alors sur un t√©l√©phone moyen (Moto G4), il faut 3 √† 4 fois plus de temps pour ex√©cuter reddit.com sur un code JS que sur un appareil de haut niveau (Pixel 3).  Sur un appareil faible (Alcatel 1X co√ªtant moins de 100 $), r√©soudre le m√™me probl√®me n√©cessite au moins 6 fois plus de temps que quelque chose comme Pixel 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/4f0/3a9/71a4f03a9f7d673740c6917f30cee360.png"></div><br>  <i><font color="#999999">Le temps requis pour traiter le code JS sur des appareils mobiles de diff√©rentes classes</font></i> <br><br>  Veuillez noter que les versions mobile et bureau de reddit.com sont diff√©rentes.  Par cons√©quent, vous ne pouvez pas comparer les r√©sultats des appareils mobiles et, par exemple, du MacBook Pro. <br><br>  Lorsque vous essayez d'optimiser le temps d'ex√©cution du code JavaScript, faites attention aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√¢ches longues</a> qui peuvent capturer le flux d'interface utilisateur pendant une longue p√©riode.  Ces t√¢ches peuvent entraver l'ex√©cution d'autres t√¢ches extr√™mement importantes, m√™me lorsque l'apparence de la page semble compl√®tement pr√™te pour le travail.  Les t√¢ches √† long terme doivent √™tre d√©compos√©es en t√¢ches plus petites.  En divisant le code en parties et en contr√¥lant l'ordre de chargement de ces parties, vous pouvez obtenir le fait que les pages atteindront un √©tat interactif plus rapidement.  Esp√©rons que cela conduira les utilisateurs √† moins d'inconv√©nients √† interagir avec les pages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/002/eef/32b/002eef32b869be9ae677bc41b41c86c2.png"></div><br>  <i><font color="#999999">Les t√¢ches de longue dur√©e capturent le thread principal.</font></i>  <i><font color="#999999">Ils doivent √™tre bris√©s en morceaux</font></i> <br><br><h2>  <font color="#3AC1EF">Comment les am√©liorations V8 acc√©l√®rent-elles l'analyse et la compilation des scripts?</font> </h2><br>  La vitesse d'analyse du code JS source dans la V8, depuis l'√©poque de Chrome 60, a √©t√© multipli√©e par 2.  Dans le m√™me temps, l'analyse et la compilation contribuent d√©sormais moins au ¬´prix JavaScript¬ª.  Cela est d√ª √† d'autres efforts d'optimisation de Chrome menant √† la parall√©lisation de ces t√¢ches. <br><br>  Dans la V8, la quantit√© de travail sur l'analyse et la compilation de code produite dans le thread principal est r√©duite en moyenne de 40%.  Par exemple, pour Facebook, l'am√©lioration de cet indicateur √©tait de 46%, pour Pinterest - 62%.  Le r√©sultat le plus √©lev√©, 81%, a √©t√© obtenu pour YouTube.  Ces r√©sultats sont possibles du fait que l'analyse et la compilation sont d√©plac√©es vers un flux distinct.  Et cela s'ajoute aux am√©liorations existantes concernant la solution de streaming des m√™mes t√¢ches en dehors du flux principal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a7/41e/24c/4a741e24c05a9149d98ee568be74b564.png"></div><br>  <i><font color="#999999">Temps d'analyse JS dans diff√©rentes versions de Chrome</font></i> <br><br>  Vous pouvez √©galement visualiser comment les optimisations V8 produites dans diff√©rentes versions de Chrome affectent le temps processeur requis pour traiter le code.  En m√™me temps que Chrome 61 devait analyser le code Facebook JS, Chrome 75 peut d√©sormais analyser le code Facebook JS et, en outre, analyser le code Twitter 6 fois. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6b/000/0e0/c6b0000e0b2bb98087ff12f8a9eb0d97.png"></div><br>  <i><font color="#999999">Pendant que Chrome 61 avait besoin de traiter le code Facebook JS, Chrome 75 peut traiter √† la fois le code Facebook et six fois la quantit√© de code Twitter.</font></i> <br><br>  Parlons de la fa√ßon dont ces am√©liorations ont √©t√© r√©alis√©es.  En r√©sum√©, les ressources de script peuvent √™tre analys√©es et compil√©es en mode streaming dans le workflow.  Cela signifie ce qui suit: <br><br><ul><li>  V8 peut analyser et compiler du code JS sans bloquer le thread principal. </li><li> Le traitement de flux du script d√©marre lorsque l'analyseur HTML universel rencontre la <code>&lt;script&gt;</code> .  Un analyseur HTML g√®re les scripts qui bloquent l'analyse des pages.  Rencontre avec des scripts asynchrones, il continue de travailler. </li><li>  Dans la plupart des sc√©narios du monde r√©el, caract√©ris√©s par certaines vitesses de connexion r√©seau, le V8 analyse le code plus rapidement qu'il ne peut le charger.  En cons√©quence, V8 termine les t√¢ches d'analyse et de compilation du code quelques millisecondes apr√®s le chargement des derniers octets du script. </li></ul><br>  Si vous en parlez un peu plus en d√©tail, le point ici est le suivant.  Dans les versions beaucoup plus anciennes de Chrome, le script devait √™tre t√©l√©charg√© dans son int√©gralit√© avant de l'analyser.  Cette approche est simple et compr√©hensible, mais lorsqu'elle est utilis√©e, les ressources du processeur sont utilis√©es de mani√®re irrationnelle.  Chrome, entre les versions 41 et 68, commence l'analyse en mode asynchrone, imm√©diatement apr√®s le chargement du script, effectuant cette t√¢che dans un thread distinct. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/574/43a/4fd/57443a4fd274a348de26652d006941c3.png"></div><br>  <i><font color="#999999">Les scripts sont envoy√©s au navigateur en fragments.</font></i>  <i><font color="#999999">La V8 d√©marre le traitement des donn√©es en continu apr√®s avoir au moins 30 Ko de code.</font></i> <br><br>  Dans Chrome 71, nous sommes pass√©s √† un syst√®me bas√© sur les t√¢ches.  Ici, le planificateur peut d√©marrer simultan√©ment plusieurs sessions de traitement de script asynchrones / retard√©es.  En raison de ce changement, la charge cr√©√©e par l'analyse du thread principal a diminu√© d'environ 20%.  Cela a conduit √† une am√©lioration d'environ 2% des scores TTI / FID obtenus sur des sites r√©els. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/161/863/a3f16186348f3773a04f7caccc185592.png"></div><br>  <i><font color="#999999">Chrome 71 utilise un syst√®me de traitement de code bas√© sur les t√¢ches.</font></i>  <i><font color="#999999">Avec cette approche, le planificateur peut traiter plusieurs scripts asynchrones / en attente en m√™me temps.</font></i> <br><br>  Dans Chrome 72, nous avons fait du traitement en streaming le principal moyen d'analyser les scripts.  D√©sormais, m√™me les scripts synchrones r√©guliers sont g√©r√©s de cette fa√ßon (bien que cela ne s'applique pas aux scripts int√©gr√©s).  De plus, nous avons cess√© d'annuler les op√©rations d'analyse bas√©e sur les t√¢ches si le thread principal avait besoin de code analys√©.  Cela est d√ª au fait que cela conduit √† la n√©cessit√© de r√©ex√©cuter une partie du travail d√©j√† effectu√©. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La version pr√©c√©dente de Chrome</a> √©tait compatible avec l'analyse en continu et la compilation en continu de code.  Ensuite, le script t√©l√©charg√© √† partir du r√©seau doit d'abord entrer dans le flux principal, puis il sera redirig√© vers le syst√®me de traitement de script de streaming. <br><br>  Cela a souvent conduit l'analyseur de flux √† attendre des donn√©es d√©j√† t√©l√©charg√©es depuis le r√©seau mais pas encore redirig√©es par le flux principal vers le traitement de flux.  Cela est d√ª au fait que le thread principal peut √™tre occup√© par d'autres t√¢ches (telles que l'analyse HTML, la cr√©ation d'une mise en page ou l'ex√©cution de code JS). <br><br>  Maintenant, nous essayons de commencer √† analyser le code lors du pr√©chargement des pages.  Auparavant, la mise en ≈ìuvre d'un tel m√©canisme √©tait entrav√©e par la n√©cessit√© d'utiliser les ressources du thread principal pour transf√©rer des t√¢ches vers l'analyseur de streaming.  Des d√©tails sur l'analyse du code JS qui s'ex√©cute ¬´instantan√©ment¬ª peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">Comment les am√©liorations ont-elles affect√© ce qui peut √™tre vu dans les outils du d√©veloppeur?</font> </h2><br>  En plus de ce qui pr√©c√®de, on peut noter qu'il y avait un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me</a> dans les outils de d√©veloppement auparavant.  Cela consistait dans le fait que les informations sur la t√¢che d'analyse √©taient affich√©es comme si elles bloquaient compl√®tement le thread principal.  Cependant, l'analyseur a effectu√© des op√©rations bloquant le thread principal uniquement lorsqu'il avait besoin de nouvelles donn√©es.  Depuis que nous sommes pass√©s du sch√©ma d'utilisation d'un flux unique pour le traitement en continu des donn√©es au sch√©ma dans lequel les t√¢ches de traitement en streaming sont appliqu√©es, cela est devenu assez √©vident.  Voici ce que vous pouvez voir dans Chrome 69. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/b4c/ab0/87cb4cab05a3c00e7b21dfc25524a9c8.png"></div><br>  <i><font color="#999999">Le probl√®me r√©side dans les outils de d√©veloppement, en raison desquels les informations sur l'analyse des scripts ont √©t√© affich√©es comme si elles bloquaient compl√®tement le thread principal</font></i> <br><br>  Ici, vous pouvez voir que la t√¢che d'analyse du script prend 1,08 seconde.  Mais l'analyse de JavaScript n'est en fait pas si lente!  La plupart du temps, rien d'utile n'est effectu√©, √† part attendre les donn√©es du thread principal. <br>  Dans Chrome 76, vous pouvez d√©j√† voir une image compl√®tement diff√©rente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/874/e37/ef8874e37664a31f03c822c71feb0fa8.png"></div><br>  <i><font color="#999999">Dans Chrome 76, l'analyse est divis√©e en de nombreuses petites t√¢ches</font></i> <br><br>  En g√©n√©ral, on peut noter que l'onglet Performances des outils de d√©veloppement est id√©al pour voir l'image globale de ce qui se passe sur la page.  Afin d'obtenir des informations plus d√©taill√©es qui refl√®tent les fonctionnalit√©s de la V8, telles que le temps d'analyse et le temps de compilation, vous pouvez utiliser le suivi de Chrome avec la prise en charge RCS (Runtime Call Stats).  Dans les donn√©es RCS re√ßues, vous pouvez trouver les indicateurs Parse-Background et Compile-Background.  Ils peuvent signaler le temps qu'il a fallu pour analyser et compiler le code JS en dehors du thread principal.  Les mesures Parse et Compile indiquent combien de temps a √©t√© consacr√© √† des activit√©s connexes dans le thread principal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a4/200/d26/3a4200d269fe47bedac1d84c27722a2b.png"></div><br>  <i><font color="#999999">Analyse des donn√©es RCS √† l'aide de Google Tracing</font></i> <br><br><h2>  <font color="#3AC1EF">Comment les changements ont-ils affect√© le travail avec des sites r√©els?</font> </h2><br>  Examinons quelques exemples de la fa√ßon dont le traitement de script en continu a influenc√© la navigation sur des sites r√©els. <br><br><h3>  <font color="#3AC1EF">‚ñçReddit</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/4ba/270/d774ba2709a772bbcfb26294b67ab385.png"></div><br>  <i><font color="#999999">Affichez reddit.com sur un MacBook Pro.</font></i>  <i><font color="#999999">Temps d'analyse et de compilation du code JS pass√© dans les threads principal et de travail</font></i> <br><br>  Il existe plusieurs bundles JS sur le site reddit.com, dont chacun d√©passe 100 Ko.  Ils sont envelopp√©s dans des fonctions externes, ce qui conduit √† l'ex√©cution de gros volumes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compilation "paresseux"</a> dans le thread principal.  Le temps n√©cessaire pour traiter les scripts dans le thread principal est crucial dans le diagramme ci-dessus.  Cela est d√ª au fait qu'une charge importante sur le thread principal peut augmenter le temps n√©cessaire pour que la page passe en mode interactif.  Lors du traitement du code du site reddit.com, la plupart du temps est consacr√© au thread principal et les ressources du thread de travail / arri√®re-plan sont utilis√©es au minimum. <br><br>  Vous pouvez optimiser ce site en divisant certains gros paquets en parties (environ 50 Ko chacun) et sans encapsuler le code dans une fonction.  Cela maximiserait le traitement parall√®le des scripts.  En cons√©quence, les bundles pouvaient √™tre analys√©s et compil√©s en m√™me temps en mode streaming.  Cela r√©duirait la charge sur le thread principal lors de la pr√©paration de la page pour le travail. <br><br><h3>  <font color="#3AC1EF">‚ñçFacebook</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/d83/a53/bc2d83a53f5b73658168e3dba70c9a85.png"></div><br>  <i><font color="#999999">Affichez facebook.com sur votre MacBook Pro.</font></i>  <i><font color="#999999">Temps d'analyse et de compilation du code JS pass√© dans les threads principal et de travail</font></i> <br><br>  Nous pouvons √©galement envisager un site comme facebook.com, qui utilise environ 6 Mo de code JS compress√©.  Ce code est charg√© √† l'aide d'environ 292 requ√™tes.  Certains d'entre eux sont asynchrones, certains visent √† pr√©charger des donn√©es, certains ont une faible priorit√©.  La plupart des scripts Facebook sont de petite taille et √† focalisation √©troite.  Cela peut avoir un bon effet sur le traitement parall√®le des donn√©es au moyen de flux d'arri√®re-plan / de travail.  Le fait est que de nombreux petits scripts peuvent √™tre analys√©s et compil√©s en m√™me temps au moyen d'un traitement de script en continu. <br><br>  Veuillez noter que votre site est probablement diff√©rent du site Facebook.  Vous n'avez probablement pas d'applications qui restent ouvertes pendant longtemps (comme ce qu'est un site Facebook ou l'interface Gmail), et lorsque vous travaillez avec elles, le t√©l√©chargement de volumes de scripts aussi s√©rieux avec un navigateur de bureau peut √™tre justifi√©.  Mais, malgr√© cela, nous pouvons donner une recommandation g√©n√©rale qui soit juste pour tous les projets.  Cela r√©side dans le fait qu'il vaut la peine de diviser le code d'application en paquets modestes et que vous ne devez t√©l√©charger ces paquets qu'en cas de besoin. <br><br>  Bien que la plupart du travail d'analyse et de compilation du code JS puisse √™tre effectu√© √† l'aide d'outils de streaming dans un thread d'arri√®re-plan, certaines op√©rations n√©cessitent toujours un thread principal.  Lorsque le thread principal est occup√© par quelque chose, la page ne peut pas r√©pondre √† l'interaction de l'utilisateur.  Par cons√©quent, il est recommand√© de pr√™ter attention √† l'impact sur les sites UX du chargement et de l'ex√©cution du code JS. <br><br>  Gardez √† l'esprit que tous les moteurs et navigateurs JavaScript ne diffusent plus de scripts et optimisent leur chargement.  Mais malgr√© cela, nous esp√©rons que les principes g√©n√©raux d'optimisation d√©crits ci-dessus peuvent am√©liorer l'exp√©rience utilisateur de travailler avec des sites consult√©s dans l'un des navigateurs existants. <br><br><h2>  <font color="#3AC1EF">Prix ‚Äã‚Äãd'analyse JSON</font> </h2><br>  L'analyse du code JSON peut √™tre beaucoup plus efficace que l'analyse du code JavaScript.  Le fait est que la grammaire JSON est beaucoup plus simple que la grammaire JavaScript.  Ces connaissances peuvent √™tre appliqu√©es afin d'am√©liorer la vitesse de pr√©paration pour le travail des applications Web qui utilisent de gros objets de configuration (tels que les r√©f√©rentiels Redux), dont la structure ressemble au code JSON.  Par cons√©quent, il s'av√®re qu'au lieu de pr√©senter les donn√©es comme des litt√©raux d'objet incorpor√©s dans le code, vous pouvez les repr√©senter comme des cha√Ænes d'objets JSON et analyser ces objets lors de l'ex√©cution. <br><br>  La premi√®re approche, utilisant des objets JS, ressemble √† ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-number"><span class="hljs-number">1337</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  La deuxi√®me approche, utilisant des cha√Ænes JSON, implique l'utilisation de telles constructions: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'{"foo":42,"bar":1337}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Comme vous n'avez besoin d'ex√©cuter le traitement de cha√Æne JSON qu'une seule fois, l'approche qui utilise <code>JSON.parse</code> est beaucoup plus rapide que l'utilisation de litt√©raux d'objet JavaScript.  Surtout - lors du chargement de page "√† froid".  Il est recommand√© d'utiliser des cha√Ænes JSON pour repr√©senter les objets commen√ßant √† 10 Ko.  Cependant, comme pour tout conseil de performance, ce conseil ne doit pas √™tre suivi sans r√©fl√©chir.  Avant d'appliquer cette technique de pr√©sentation des donn√©es en production, il est n√©cessaire de faire des mesures et d'√©valuer son impact r√©el sur le projet. <br><br>  L'utilisation de litt√©raux d'objets comme stockage pour de grandes quantit√©s de donn√©es constitue une autre menace.  Le fait est qu'il existe un risque que ces litt√©raux puissent √™tre trait√©s deux fois: <br><br><ol><li>  La premi√®re passe de traitement est effectu√©e avec une analyse pr√©liminaire du litt√©ral. </li><li>  La deuxi√®me approche est effectu√©e lors de l'analyse "paresseuse" du litt√©ral. </li></ol><br>  Vous ne pouvez pas vous d√©barrasser de la premi√®re passe de traitement des litt√©raux d'objet.  Mais, heureusement, la deuxi√®me passe peut √™tre √©vit√©e en pla√ßant les litt√©raux d'objet au niveau sup√©rieur ou √† l'int√©rieur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PIFE</a> . <br><br><h2>  <font color="#3AC1EF">Qu'en est-il de l'analyse et de la compilation de code lors de visites r√©p√©t√©es sur des sites?</font> </h2><br>  Il est possible d'optimiser les performances du site dans les cas o√π les utilisateurs les visitent plusieurs fois, gr√¢ce aux capacit√©s V8 de mise en cache du code et du bytecode.  Lorsqu'un script est demand√© au serveur pour la premi√®re fois, Chrome le t√©l√©charge et passe la V8 pour la compilation.  Le navigateur enregistre en outre le fichier de ce script dans son cache disque.  Lorsque la deuxi√®me demande de t√©l√©chargement du m√™me fichier JS est ex√©cut√©e, Chrome le prend dans le cache du navigateur et passe √† nouveau V8 pour la compilation.  Cette fois, cependant, le code compil√© est s√©rialis√© et attach√© au fichier de script mis en cache en tant que m√©tadonn√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/216/702/b7821670255f45c9ec4a08217b495153.png"></div><br>  <i><font color="#999999">Syst√®me de mise en cache de code dans V8</font></i> <br><br>  Lorsque le script est demand√© pour la troisi√®me fois, Chrome prend le fichier et ses m√©tadonn√©es du cache, puis transf√®re le V8 √† la fois.  La V8 d√©s√©rialise les m√©tadonn√©es et, par cons√©quent, peut ignorer l'√©tape de compilation.  La mise en cache du code est d√©clench√©e si les visites sur le site sont effectu√©es dans les 72 heures.  Chrome utilise √©galement la strat√©gie de mise en cache de code gourmande lorsqu'un employ√© de service est utilis√© pour mettre en cache des scripts.  Des d√©tails sur la mise en cache du code peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  En 2019, les principaux goulots d'√©tranglement des performances des pages Web sont le chargement et l'ex√©cution de scripts.  Afin d'am√©liorer la situation, efforcez-vous d'utiliser des scripts synchrones (int√©gr√©s) de petites tailles, qui sont n√©cessaires pour organiser l'interaction de l'utilisateur avec la partie de la page qui lui est visible imm√©diatement apr√®s le chargement.  Il est recommand√© de charger les scripts utilis√©s pour traiter d'autres parties des pages en mode diff√©r√©.  Brisez les gros paquets en petits morceaux.  Cela facilitera la mise en ≈ìuvre d'une strat√©gie pour travailler avec du code, dans l'application duquel le code n'est charg√© que lorsqu'il est n√©cessaire, et uniquement l√† o√π il est n√©cessaire.  Cela maximisera les capacit√©s de V8, visant √† un traitement parall√®le du code. <br><br>  Si vous d√©veloppez des projets mobiles, vous devez vous assurer qu'ils utilisent le moins de code JS possible.  Cette recommandation d√©coule du fait que les appareils mobiles fonctionnent g√©n√©ralement dans des r√©seaux assez lents.  De tels p√©riph√©riques, en outre, peuvent √™tre limit√©s en termes de RAM disponible et de ressources processeur disponibles.  Essayez de trouver un √©quilibre entre le temps requis pour pr√©parer les scripts t√©l√©charg√©s depuis le r√©seau et l'utilisation du cache.  Cela maximisera la quantit√© d'analyse et de compilation de code effectu√©e en dehors du thread principal. <br><br>  <b>Chers lecteurs!</b>  Optimisez-vous vos projets web en tenant compte des particularit√©s du traitement de code JS par les navigateurs modernes? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459296/">https://habr.com/ru/post/fr459296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459284/index.html">Br√®ve introduction √† la strat√©gie produit et √† la hi√©rarchisation des fonctionnalit√©s</a></li>
<li><a href="../fr459286/index.html">Tellurure de tungst√®ne semi-m√©tallique - le couteau suisse de la journ√©e des nanotechnologies</a></li>
<li><a href="../fr459288/index.html">Impl√©mentation native de la biblioth√®que ECS</a></li>
<li><a href="../fr459292/index.html">Automatisation des tests d'applications mobiles: comparaison d'outils</a></li>
<li><a href="../fr459294/index.html">Quoi de plus important: conna√Ætre un langage de programmation ou √™tre capable de r√©soudre un probl√®me m√©tier?</a></li>
<li><a href="../fr459298/index.html">Angulaire: statut en 2019</a></li>
<li><a href="../fr459300/index.html">Quasar 1.0: un nouvel outil utile pour les d√©veloppeurs de Vue et pas seulement pour eux</a></li>
<li><a href="../fr459302/index.html">Nouvelle tentative de requ√™tes HTTP ayant √©chou√© dans Angular</a></li>
<li><a href="../fr459304/index.html">Contournement angulaire de l'√©cueil et gain de temps</a></li>
<li><a href="../fr459306/index.html">Rendu de serveur dans un environnement sans serveur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>