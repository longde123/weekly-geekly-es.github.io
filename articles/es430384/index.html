<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüë¶ ‚Ñ¢Ô∏è üöÜ Crear mapas a partir de caracter√≠sticas de ruido üë©üèª‚Äçüé® üë©üèΩ‚Äçüè≠ üö¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uno de los art√≠culos m√°s populares en mi sitio est√° dedicado a la generaci√≥n de mapas poligonales ( traducci√≥n en Habr√©). Crear esas tarjetas requiere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crear mapas a partir de caracter√≠sticas de ruido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430384/">  Uno de los art√≠culos m√°s populares en mi sitio est√° dedicado a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generaci√≥n de mapas poligonales</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> en Habr√©).  Crear esas tarjetas requiere mucho esfuerzo.  Pero no comenc√© con esto, sino con una tarea <em>mucho</em> m√°s simple, que describir√© aqu√≠.  Esta t√©cnica simple le permite crear esas tarjetas en menos de 50 l√≠neas de c√≥digo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br>  No explicar√© c√≥mo <em>dibujar</em> esas tarjetas: depende del idioma, la biblioteca de gr√°ficos, la plataforma, etc.  Simplemente explicar√© c√≥mo <em>llenar la matriz</em> con datos del mapa. <br><br><h2>  El ruido </h2><br>  Una forma est√°ndar de generar mapas 2D es utilizar el ruido con una banda de frecuencia limitada como bloque de construcci√≥n, como el ruido Perlin o el ruido simplex.  As√≠ es como se ve la funci√≥n de ruido: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="imagen"></div><br>  Asignamos un n√∫mero de 0.0 a 1.0 a cada punto en el mapa.  En esta imagen, 0.0 es negro y 1.0 es blanco. <a name="habracut"></a>  Aqu√≠ se explica c√≥mo configurar el color de cada punto de la cuadr√≠cula en la sintaxis de un lenguaje tipo C: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br>  El bucle funcionar√° de la misma manera en Javascript, Python, Haxe, C ++, C #, Java y la mayor√≠a de los otros lenguajes populares, por lo que lo mostrar√© en una sintaxis tipo C para que pueda convertirlo al idioma que necesita.  En el resto del tutorial, mostrar√© c√≥mo cambia el cuerpo del bucle ( <code>value[y][x]=‚Ä¶</code> l√≠nea <code>value[y][x]=‚Ä¶</code> ) al agregar nuevas funciones.  La demostraci√≥n mostrar√° un ejemplo completo. <br><br>  En algunas bibliotecas, ser√° necesario cambiar o multiplicar los valores resultantes para devolverlos en el rango de 0.0 a 1.0. <br><br><h2>  Altura </h2><br>  El ruido en s√≠ mismo es solo una colecci√≥n de n√∫meros.  Necesitamos darle <em>significado</em> .  Lo primero en lo que puede pensar es vincular el valor de ruido a la altura (esto se llama un "mapa de altura").  Tomemos el ruido que se muestra arriba y dibuj√©moslo como altura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br>  El c√≥digo se mantuvo casi igual, con la excepci√≥n del bucle interno.  Ahora se ve as√≠: <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br>  S√≠, y eso es todo.  Los datos del mapa permanecieron igual, pero ahora los llamar√© <code>elevation</code> (altura), no <code>value</code> . <br><br>  Tenemos muchas colinas, pero nada m√°s.  Que esta mal <br><br><h3>  Frecuencia </h3><br>  Se puede generar ruido a cualquier <em>frecuencia</em> .  Hasta ahora he elegido solo una frecuencia.  Veamos c√≥mo afecta. <br><br>  <strong>Intente cambiar el valor con el control deslizante</strong> (en el art√≠culo original) y vea qu√© sucede a diferentes frecuencias: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br>  Simplemente cambia la escala.  Al principio esto no parece muy √∫til, pero no lo es.  Tengo un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tutorial</a> m√°s ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> en Habr√©), que explica la <em>teor√≠a</em> : conceptos como frecuencia, amplitud, octavas, ruido rosa y azul, etc. <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br>  A veces tambi√©n es √∫til recordar la <em>longitud de onda</em> , que es el rec√≠proco de la magnitud.  Cuando la frecuencia se duplica, el tama√±o solo se reduce a la mitad.  Doblar la longitud de onda todos los dobles.  La longitud de onda es la distancia medida en p√≠xeles / mosaicos / metros o cualquier otra unidad que haya seleccionado para los mapas.  Est√° relacionado con la frecuencia: <code>wavelength = map_size / frequency</code> . <br><br><h3>  Octavas </h3><br>  Para hacer que el mapa de altura sea m√°s interesante, <em>agregaremos ruido con diferentes frecuencias</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br>  Mezclemos grandes colinas de baja frecuencia con peque√±as colinas de alta frecuencia en un mapa.  <strong>Mueva el control deslizante</strong> (en el art√≠culo original) para agregar peque√±as colinas a la mezcla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br>  ¬°Ahora se parece mucho m√°s al alivio fractal que necesitamos!  Podemos obtener colinas y monta√±as escarpadas, pero a√∫n no tenemos llanuras planas.  Para hacer esto, necesitas algo m√°s. <br><br><h3>  Redistribuci√≥n </h3><br>  La funci√≥n de ruido nos da valores entre 0 y 1 (o de -1 a +1, dependiendo de la biblioteca).  Para crear llanuras planas, podemos <em>elevar la altura a una potencia</em> .  <strong>Mueva el control deslizante</strong> (en el art√≠culo original) para obtener diferentes grados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  Los valores altos <em>reducen las alturas promedio a las llanuras</em> , y los valores bajos elevan las alturas promedio hacia los picos de las monta√±as.  Necesitamos omitirlos.  Uso las funciones de potencia porque son m√°s simples, pero puedes usar cualquier curva;  Tengo una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">demo</a> m√°s complicada. <br><br>  Ahora que tenemos un mapa de elevaci√≥n realista, ¬°agreguemos biomas! <br><br><h2>  Biomas </h2><br>  El ruido da n√∫meros, pero necesitamos un mapa con bosques, desiertos y oc√©anos.  Lo primero que puede hacer es convertir peque√±as alturas en agua: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br>  ¬°Vaya, esto ya se est√° convirtiendo en un mundo generado por procedimientos!  Tenemos agua, hierba y nieve.  Pero, ¬øy si necesitamos m√°s?  Hagamos una secuencia de agua, arena, hierba, bosque, sabana, desierto y nieve: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>Alivio basado en la altura</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br>  Wow, eso se ve genial!  Para tu juego, puedes cambiar los valores y los biomas.  Crysis tendr√° mucha m√°s jungla;  Skyrim tiene mucho m√°s hielo y nieve.  Pero no importa c√≥mo cambie los n√∫meros, este enfoque es bastante limitado.  Los tipos de relieve corresponden a las alturas, por lo tanto, forman tiras.  Para hacerlos m√°s interesantes, necesitamos elegir biomas basados ‚Äã‚Äãen otra cosa.  Creemos un <em>segundo</em> mapa de ruido para la humedad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>Arriba est√° el ruido de las alturas;</i>  <i>fondo - ruido de humedad</i> <br><br>  Ahora usemos altura y humedad <em>juntos</em> .  En la primera imagen que se muestra a continuaci√≥n, el eje y es la altura (tomada de la imagen de arriba) y el eje x es la humedad (la segunda imagen es m√°s alta).  Esto nos da un mapa convincente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>Alivio basado en dos valores de ruido</i> <br><br>  Las peque√±as alturas son oc√©anos y costas.  Grandes alturas son rocosas y nevadas.  En el medio, obtenemos una amplia gama de biomas.  El c√≥digo se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br>  Si es necesario, puedes cambiar todos estos valores de acuerdo con los requisitos de tu juego. <br><br>  Si no necesitamos biomas, los gradientes suaves (vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo</a> ) pueden crear colores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br>  Tanto para los biomas como para los gradientes, un solo valor de ruido no proporciona suficiente variabilidad, pero dos es suficiente. <br><br><h2>  Clima </h2><br>  En la secci√≥n anterior, us√© la <em>altitud</em> como un sustituto de la <em>temperatura</em> .  Cuanto mayor sea la altura, menor ser√° la temperatura.  Sin embargo, la latitud geogr√°fica tambi√©n afecta las temperaturas.  Usemos la altura y la latitud para controlar la temperatura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br>  Cerca de los polos (grandes latitudes) el clima es m√°s fr√≠o, y en las cimas de las monta√±as (grandes alturas) el clima tambi√©n es m√°s fr√≠o.  Hasta ahora no he trabajado mucho: para el enfoque correcto de estos par√°metros, necesita una gran cantidad de configuraciones sutiles. <br><br>  Tambi√©n hay cambio clim√°tico <em>estacional</em> .  En verano e invierno, los hemisferios norte y sur se vuelven m√°s c√°lidos y fr√≠os, pero en el ecuador la situaci√≥n no cambia mucho.  Aqu√≠ tambi√©n se puede hacer mucho, por ejemplo, uno puede simular los vientos y las corrientes oce√°nicas predominantes, el efecto de los biomas en el clima y el efecto promedio de los oc√©anos en las temperaturas. <br><br><h2>  Las islas </h2><br>  En algunos proyectos, necesitaba que los bordes del mapa fueran agua.  Esto convierte el mundo en una o m√°s islas.  Hay muchas maneras de hacer esto, pero utilic√© una soluci√≥n bastante simple en mi generador de mapas poligonales: cambi√© la altura como <code>e = e + a - b*d^c</code> , donde <code>d</code> es la distancia desde el centro (en una escala de 0-1).  Otra opci√≥n es cambiar <code>e = (e + a) * (1 - b*d^c)</code> .  La constante <code>a</code> eleva todo hacia arriba, <code>b</code> baja los bordes hacia abajo <code>c</code> controla la tasa de disminuci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>No estoy completamente satisfecho con esto</em> y queda mucho por explorar.  ¬øDeber√≠a ser Manhattan o la distancia euclidiana?  ¬øDeber√≠a depender de la distancia al centro o de la distancia al borde?  ¬øDeber√≠a la distancia ser cuadrada, lineal o tener alg√∫n otro grado?  ¬øDeber√≠a ser suma / resta, o multiplicaci√≥n / divisi√≥n, o algo m√°s?  En el art√≠culo original, <b>intente</b> Agregar, a = 0.1, b = 0.3, c = 2.0, o <b>intente</b> Multiplicar, a = 0.05, b = 1.00, c = 1.5.  Las opciones que m√°s le convengan dependen de su proyecto. <br><br>  ¬øPor qu√© apegarse a las funciones matem√°ticas est√°ndar?  Como dije en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre el da√±o en RPG</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> en Habr√©), todos (incluy√©ndome a m√≠) usan funciones matem√°ticas, como polinomios, distribuciones exponenciales, etc., pero en la computadora no podemos limitarnos a ellas.  Podemos tomar <em>cualquier</em> funci√≥n de formaci√≥n y usarla aqu√≠, usando la tabla de b√∫squeda <code>e = e + height_adjust[d]</code> .  Hasta ahora no he estudiado este tema. <br><br><h2>  Ruido de punta </h2><br>  En lugar de elevar la altura a una potencia, podemos usar el valor absoluto para crear picos agudos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br>  Para agregar octavas, podemos variar las amplitudes de las frecuencias altas para que solo las monta√±as reciban el ruido adicional: <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br>  No tengo mucha experiencia con esta t√©cnica, as√≠ que necesito experimentar para aprender a usarla bien.  Tambi√©n puede ser interesante mezclar ruido puntiagudo de baja frecuencia con ruido no puntiagudo de alta frecuencia. <br><br><h2>  Terrazas </h2><br>  Si redondeamos la altura a los siguientes n niveles, obtenemos terrazas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br>  Este es el resultado de aplicar la funci√≥n de redistribuci√≥n de altura en la forma <code>e = f(e)</code> .  Arriba, usamos <code>e = Math.pow(e, exponent)</code> para agudizar los picos de las monta√±as;  aqu√≠ usamos <code>e = Math.round(e * n) / n</code> para crear terrazas.  Si utiliza una funci√≥n que no sea de paso, las terrazas se pueden redondear o aparecer solo a ciertas alturas. <br><br><h2>  Colocaci√≥n de √°rboles </h2><br>  Usualmente usamos ruido fractal para la altura y la humedad, pero tambi√©n se puede usar para colocar objetos espaciados de manera desigual, como √°rboles y piedras.  Para la altura usamos amplitudes altas con frecuencias bajas ("ruido rojo").  Para colocar objetos necesita usar amplitudes altas con frecuencias altas ("ruido azul").  A la izquierda hay un patr√≥n de ruido azul;  a la derecha hay lugares donde el ruido es mayor que los valores adyacentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br>  Al elegir diferentes R para cada bioma, podemos obtener una densidad variable de √°rboles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br>  Es genial que ese ruido se pueda usar para colocar √°rboles, pero otros algoritmos a menudo son m√°s efectivos y crean una distribuci√≥n m√°s uniforme: manchas Poisson, mosaicos Van o tramado gr√°fico. <br><br><h2>  Hasta el infinito y m√°s all√° </h2><br>  Los c√°lculos del bioma en la posici√≥n (x, y) son independientes de los c√°lculos de todas las dem√°s posiciones.  Este <strong>c√°lculo local</strong> tiene dos propiedades convenientes: se puede calcular en paralelo y se puede usar para terrenos infinitos.  <strong>Coloque el cursor del mouse en el minimapa</strong> (en el art√≠culo original) a la izquierda para generar el mapa a la derecha.  Puede generar cualquier parte de la tarjeta sin generar (e incluso sin almacenar) la tarjeta completa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2>  Implementaci√≥n </h2><br>  El uso de ruido para generar terreno es una soluci√≥n popular, y en Internet puede encontrar tutoriales para muchos idiomas y plataformas diferentes.  El c√≥digo para generar tarjetas en diferentes idiomas es aproximadamente el mismo.  Aqu√≠ est√° el bucle m√°s simple en tres idiomas diferentes: <br><br><ul><li>  <b>Javascript:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python:</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br>  Todas las bibliotecas de ruido son muy parecidas.  Pruebe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">opensimplex para Python</a> , o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libnoise para C ++</a> , o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">simplex-noise</a> para Javascript.  Para los idiomas m√°s populares, hay muchas bibliotecas de ruido.  O puede aprender c√≥mo funciona el ruido Perlin o darse cuenta usted mismo del ruido.  <em>No lo hice</em> <br><br>  En diferentes bibliotecas de ruido para su idioma, los detalles de la aplicaci√≥n pueden variar ligeramente (algunos n√∫meros de retorno en el rango de 0.0 a 1.0, otros en el rango de -1.0 a +1.0), pero la idea b√°sica es la misma.  Para un proyecto real, es posible que necesite ajustar la funci√≥n de <code>noise</code> y el objeto <code>gen</code> en una clase, pero estos detalles son irrelevantes, por lo que los hice globales. <br><br>  Para un proyecto tan simple, no importa qu√© ruido use: ruido Perlin, ruido simplex, ruido OpenSimplex, ruido de valor, compensaci√≥n de punto medio, algoritmo de diamante o la transformaci√≥n inversa de Fourier.  Cada uno de ellos tiene sus pros y sus contras, pero para un generador de tarjetas similar, todos crean m√°s o menos los mismos valores de salida. <br><br>  <em>La representaci√≥n del</em> mapa depende de la plataforma y el juego, por lo que no lo implement√©;  Este c√≥digo solo es necesario para generar alturas y biomas, cuya representaci√≥n depende del estilo utilizado en el juego.  Puede copiar, portar y usarlo en sus proyectos. <br><br><h2>  Los experimentos </h2><br>  Observ√© mezclar octavas, elevar grados a una potencia y combinar alturas con humedad para crear un bioma.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puede estudiar un gr√°fico interactivo que le permite experimentar con todos estos par√°metros, que muestra en qu√© consiste el c√≥digo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br>  Aqu√≠ hay un c√≥digo de muestra: <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br>  Hay una dificultad: para el ruido de las alturas y la humedad, es necesario usar una semilla diferente, de lo contrario resultar√°n iguales, y las tarjetas no se ver√°n tan interesantes.  En Javascript, uso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca prng-parkmiller</a> ;  en C ++, puede usar dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objetos</a> independientes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">linear_congruential_engine</a> ;  en Python, puede crear dos instancias separadas de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase random.Random</a> . <br><br><h2>  Pensamientos </h2><br>  Me gusta este enfoque para la generaci√≥n de mapas por su <b>simplicidad</b> .  Es r√°pido y requiere muy poco c√≥digo para producir resultados decentes. <br><br>  No me gustan sus limitaciones en este enfoque.  Los c√°lculos locales significan que cada punto es independiente de todos los dem√°s.  Las diferentes √°reas del mapa <em>no</em> est√°n <em>conectadas entre s√≠</em> .  Cada lugar en el mapa "parece" lo mismo.  No hay restricciones globales, por ejemplo, "deber√≠a haber de 3 a 5 lagos en el mapa" o caracter√≠sticas globales, como un r√≠o que fluye desde la cima del pico m√°s alto hacia el oc√©ano.  Adem√°s, no me gusta el hecho de que para obtener una buena imagen es necesario configurar los par√°metros durante mucho tiempo. <br><br>  ¬øPor qu√© lo recomiendo?  Creo que este es un buen punto de partida, especialmente para juegos independientes y jams de juegos.  Dos de mis amigos escribieron la versi√≥n inicial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Realm of the Mad God en</a> solo 30 d√≠as para un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">concurso de juegos</a> .  Me pidieron que ayudara a crear mapas.  Utilic√© esta t√©cnica (adem√°s de algunas caracter√≠sticas m√°s que resultaron no ser muy √∫tiles) e hice un mapa para ellas.  Unos meses m√°s tarde, despu√©s de recibir comentarios de los jugadores y estudiar cuidadosamente el dise√±o del juego, creamos un generador de mapas m√°s avanzado basado en pol√≠gonos Voronoi, descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> en Habr√©).  Este generador de tarjetas no utiliza las t√©cnicas descritas en este art√≠culo.  Utiliza el ruido para crear mapas de una manera completamente diferente. <br><br><h2>  Informaci√≥n adicional </h2><br>  Hay <em>muchas</em> cosas interesantes que puedes hacer con las funciones de ruido.  Si busca en Internet, puede encontrar opciones tales como turbulencia, ondulaci√≥n, multifractal acanalado, amortiguaci√≥n de amplitud, en terrazas, ruido voronoi, derivados anal√≠ticos, deformaci√≥n de dominios y otros.  Puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta p√°gina</a> como fuente de inspiraci√≥n.  No los considero aqu√≠; mi art√≠culo se centra en la simplicidad. <br><br>  Este proyecto fue influenciado por mis proyectos de generaci√≥n de mapas anteriores: <br><br><ul><li>  Us√© el ruido general de Perlin para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi primer generador de cartas del Reino del Dios Loco</a> .  Lo usamos durante los primeros seis meses de prueba alfa, y luego lo reemplazamos con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un generador de mapas en pol√≠gonos Voronoi</a> , especialmente creado para los requisitos de juego que determinamos durante la prueba alfa.  Los biomas y sus colores para el art√≠culo se toman de estos proyectos. </li><li>  Al estudiar el procesamiento de se√±ales de audio, escrib√≠ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tutorial de ruido</a> que explica conceptos como frecuencia, amplitud, octavas y el "color" del ruido.  Los mismos conceptos que funcionan para el sonido tambi√©n se aplican a la generaci√≥n de tarjetas basadas en ruido.  En ese momento, cre√© una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generaci√≥n de socorro de demostraci√≥n en</a> bruto, pero no los termin√©. </li><li>  A veces experimento para encontrar l√≠mites.  Quer√≠a saber cu√°nto c√≥digo se necesita m√≠nimamente para crear mapas atractivos.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este mini proyecto,</a> llegu√© a <b>cero</b> l√≠neas de c√≥digo: todo se hace con filtros de imagen (turbulencia, umbrales, gradientes de color).  Esto me hizo feliz y triste.  ¬øEn qu√© medida se puede realizar la generaci√≥n de mapas mediante filtros de imagen?  En lo suficientemente grande.  Todo lo descrito anteriormente sobre el "esquema de gradientes de color suaves" se toma de este experimento.  La capa de ruido es un filtro de imagen de turbulencia;  las octavas son im√°genes superpuestas entre s√≠;  La herramienta de grado se llama "correcci√≥n de curva" en Photoshop. </li></ul><br>  Lo que me molesta un poco es que la mayor√≠a del c√≥digo que escriben los desarrolladores de juegos para la generaci√≥n de terreno basada en el ruido (incluido el desplazamiento del punto medio) resulta ser el mismo que en los filtros de sonido e imagen.  Por otro lado, crea resultados bastante decentes en solo unas pocas l√≠neas de c√≥digo, por eso escrib√≠ este art√≠culo.  Este es un <em>punto de referencia r√°pido y f√°cil</em> .  Por lo general, no uso esas tarjetas durante mucho tiempo, pero las reemplazo con un generador de mapas m√°s complejo tan pronto como descubro qu√© tipos de tarjetas se adaptan mejor al dise√±o del juego.  Este es un patr√≥n est√°ndar para m√≠: comenzar con algo extremadamente simple y luego reemplazarlo solo despu√©s de comprender mejor el sistema con el que estoy trabajando. <br><br>  Hay <em>muchas</em> m√°s cosas que se pueden hacer con el ruido, en el art√≠culo que mencion√© solo algunas.  Pruebe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Noise Studio</a> para probar de forma interactiva varias funciones. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430384/">https://habr.com/ru/post/es430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430374/index.html">Ingenier√≠a de datos y m√°s: graba videos y diapositivas de la reuni√≥n</a></li>
<li><a href="../es430376/index.html">Gu√≠a de JavaScript Parte 6: Excepciones, punto y coma, plantillas literales</a></li>
<li><a href="../es430378/index.html">J2CL - Mejor tarde que nunca</a></li>
<li><a href="../es430380/index.html">Gu√≠a de JavaScript, parte 5: matrices y bucles</a></li>
<li><a href="../es430382/index.html">Gu√≠a de JavaScript Parte 4: Caracter√≠sticas</a></li>
<li><a href="../es430386/index.html">Planta de energ√≠a de almacenamiento de estado s√≥lido que se construir√° en India</a></li>
<li><a href="../es430388/index.html">Desconferencia de cumbre web</a></li>
<li><a href="../es430392/index.html">C√≥mo desarrollo y pruebo las API con mi "bicicleta" PieceofScript</a></li>
<li><a href="../es430394/index.html">Implementando b√∫squeda instant√°nea en Android usando RxJava</a></li>
<li><a href="../es430396/index.html">Replicaci√≥n en cadena: construir un repositorio KV efectivo (parte 1/2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>