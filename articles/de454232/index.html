<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 🕖 💂🏼 OOP in grafischen Programmiersprachen. Teil 2 MOS und OOP 💛 🏏 🎅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil habe ich versucht zu zeigen, dass eine schwarze OOP-Katze in einem dunklen Raum grafischer Sprachen existiert, auch wenn es sich nicht ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP in grafischen Programmiersprachen. Teil 2 MOS und OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454232/"><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil habe</a> ich versucht zu zeigen, dass eine schwarze OOP-Katze in einem dunklen Raum grafischer Sprachen existiert, auch wenn es sich nicht um eine Katze handelt, sondern um eine halbtote Katze des Schrödinger-Flayers, das heißt, es ist keine.  Ein Beispiel für die Implementierung der Methodik der objektorientierten Programmierung wurde gezeigt, wenn ein Programm kein C ++ - oder Java-Code ist, sondern ein Simulink-, SimInTech-, SimulationX- oder SCADE-Esterel-Diagramm - eine beliebige grafische Notation der Algorithmusbeschreibung. </p><br><p> In Werbematerialien verwendet Matlab Simulink häufig den Begriff MOS - Model-based Design.  In vielen Texten betonen sie, dass das grafische Diagramm des Algorithmus ein Modell ist, was natürlich wahr ist.  In der anfänglichen Definition von MOS ist das Modell jedoch hauptsächlich das Modell des Objekts, für das das Steuerungssystem entwickelt wurde, einschließlich der Steuerungssoftware.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere MOS-Methoden werden hier beschrieben.</a>  Daher ist es bei der Entwicklung eines Steuerungssystems gemäß der MOS-Methodik möglich und notwendig, die OOP-Methodik für die Entwicklung von Verwaltungssoftware zu verwenden.  Und um das Problem mit den Modellen vollständig zu schließen, hier ein Bild mit den Unterschieden zwischen den beiden.  Wenn alles klar ist, können Sie nicht mehr lesen. </p><br><p><img width="700" src="https://habrastorage.org/webt/6q/lp/ti/6qlptikqb67uqw2kui8ejgydl7s.png"></p><br><a name="habracut"></a><br><p>  Kehren wir zu den Grafiksprachen und OOP zurück, die für Steuerungsprogramme für die Industrie gelten.  Die grafische Programmiersprache liefert einen Programmdatensatz in Form eines Diagramms aus einer Reihe von Blöcken, die durch Kommunikationsleitungen verbunden sind.  In der industriellen Programmierung wird in der Regel von einem automatischen Codegenerator aus einer Grafikschaltung ein Code für den Compiler und das anschließende Laden in das Zielgerät erstellt. </p><br><p>  Als Teil meiner Spezialität musste ich mich mit der Verwaltung von Software für Kernkraftwerke befassen, bei der es verboten ist, C ++ mit Sicherheitsstandards zu verwenden, nur reines C und in einigen Fällen nicht einmal C, sondern „Eisen“ -Logik, bei der die Algorithmen als elektronische Schaltungen auf Transistoren und Transistoren implementiert sind Relais.  Und die Einhaltung von Standards wird von strengen Aufsichtspersonen überwacht. </p><br><p><img width="700" src="https://habrastorage.org/webt/kt/cu/i1/ktcui1vz0x-4bn3uce7zntd40i0.jpeg"></p><br><p>  Egal wie überraschend es auch klingen mag, die Entwicklung verwendet immer noch die OOP-Methodik.  Denn wenn Sie OOP nicht verwenden können, es aber wirklich wollen, können Sie es.  Richtig, dann muss alles zurückgegeben werden, und das wäre aus Sicherheitsgründen und über alles Standards kein C ++ und der endgültige Code.  Wie sie sagen, einen Fisch zu essen und sich nicht wegen Verstößen hinzusetzen. </p><br><p>  Um ein reales Objekt durch die Definition von OOP zu erstellen, binden wir Datenstrukturen und Verarbeitungsschemata in ein einziges Objekt. Dies wird als Kapselung bezeichnet.  Und da wir C ++ nicht für zuverlässige KKW-Systeme verwenden können, müssen wir dies alles beim Generieren des Codes analysieren.  Wie in den Kommentaren zum vorherigen Artikel erläutert, funktionierte der erste C ++ Front-Compiler auf die gleiche Weise und übersetzte OOP C ++ - Code in reines C. </p><br><p>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Version der Implementierung von OOP</a> in einer grafischen Sprache haben wir einen speziellen Block erstellt, der ein grafisches Berechnungsschema enthält.  Während der Initialisierung band dieser Block das Klassenschema (die Methode) an eine bestimmte „Klasseninstanz“ - eine Reihe von Variablen, die auf besondere Weise benannt wurden. </p><br><p>  Betrachten Sie die zweite Ausführungsform der OOP-Methodik in grafischen Programmiersprachen.  Abbildung 1 zeigt die Funktionsweise des Sensorverarbeitungsalgorithmus. </p><br><p><img width="700" src="https://habrastorage.org/webt/zi/ci/3_/zici3_ssrtr7--y2enbtoa6flts.png"><br>  <i><font color="#999999">Abbildung 1. Sensorverarbeitungsprogramm.</font></i> </p><br><p>  Dies ist eine Klassenmethode.  Es entspricht seiner eigenen Kategorie <b>"Sensoren"</b> in der Datenbank - einer abstrakten Klasse mit einem bestimmten Satz von Feldern und einer Instanz des klassenspezifischen Sensors <b>KBA31CFO1</b> .  Für diesen Sensor haben die Felder bestimmte Werte, einige der Felder werden vom Benutzer festgelegt, einige der Felder werden während der Ausführung des Programms berechnet.  siehe Bild  2 </p><br><p><img width="700" src="https://habrastorage.org/webt/ht/ei/ct/hteict0a86fegqyvxgqhcllfebc.png"><br>  <i><font color="#999999">Abbildung 2. Die Signaldatenbank mit der offenen Kategorie „Sensor“.</font></i> </p><br><p>  Bisher ist alles wie in der ersten Ausführungsform, in der wir die Bindung des Entwurfsschemas an einen bestimmten Sensor bei der Installation der Einheit in der Schaltung hergestellt haben.  "Wo ist der Unterschied?"  - Du fragst.  Und der Unterschied liegt im Block.  Wenn in der ersten Version ein Entwurfsdiagramm vorhanden war, das bei jeder Installation des Blocks kopiert wurde, sieht das Innere in dieser Version ungefähr so ​​aus: </p><br><p><img width="700" src="https://habrastorage.org/webt/7x/nx/hu/7xnxhufgyyih-wha7hqii0szr7o.png"><br>  <i><font color="#999999">Abbildung 3. Die Innenräume einer Blockinstanz einer Klasseninstanz.</font></i> </p><br><p>  Anstelle des Entwurfsschemas werden nur Datenübertragung und -empfang innerhalb des Blocks "angezeigt". <br>  Die Berechnung selbst findet an einer anderen Stelle statt, im Diagramm aus Abbildung 1. In einigen Fällen ist es möglich, im Berechnungsdiagramm überhaupt keine Blöcke zu verwenden. Es reicht aus, Instanzen der Sensorklasse in der Singles-Datenbank zu haben.  Dies ist die zweite Möglichkeit, die Kapselung in Grafiksprachen zu implementieren.  Der Trick besteht darin, dass alle Blöcke in dem Diagramm von 1 vektoriell sind und nicht ein Signal verarbeiten, sondern einen Vektor von Signalen von allen Sensoren dieses Typs im Berechnungsschema.  Wenn Sie den Modus zum Anzeigen der Ergebnisse auf der Kommunikationsleitung aktivieren, sehen wir, dass jede Kommunikationsleitung nicht eine Ziffer, sondern einen Vektor mit 4 Zahlen enthält (entsprechend der Anzahl der Sensoren in der Datenbank). </p><br><p><img width="700" src="https://habrastorage.org/webt/rt/2k/ml/rt2kmlwmldjmc8n4aqsorxtxqyc.png"><br>  <i><font color="#999999">Abbildung 4. Diagramm zur Verarbeitung des Signals von Sensoren im Modus zum Anzeigen von Werten.</font></i> </p><br><p>  Somit implementiert ein Verarbeitungsschema die Verarbeitung aller Sensoren im Projekt, und jeder Sensor wird mit seinen eigenen Parametern verarbeitet, die in der Datenbank als Merkmale einer bestimmten Instanz der Klasse angegeben sind.  Beispielsweise nimmt der Begrenzer den Maximalwert aus der Datenbank, der für die ersten drei Sensoren gleich eingestellt ist und sich für den vierten unterscheidet.  (siehe Abb. 5) </p><br><p><img width="450" src="https://habrastorage.org/webt/zf/fk/q_/zffkq_axhvogvctwlxrqfsat2cg.png"><br>  <i><font color="#999999">Abbildung 5. Parameter des Begrenzerblocks im Berechnungsschema.</font></i> </p><br><p>  Und was ist mit dem resultierenden Code, der automatisch nach diesem wunderbaren Schema generiert wird? Wie schaffen Sie es, OOP-Artefakte zu vermeiden?  Es ist ganz einfach: kein Schummeln und kein OOP, reines C im Code.  Für jeden Block des Vektorverarbeitungsschemas wird ein Zyklus gebildet, der so viele Berechnungen liefert, wie Klasseninstanzen im Projekt vorhanden sind.  In unserem Fall gibt es 4 Sensoren, daher bilden wir zuerst Arrays der Dimension „4“, indem wir die Signale von den Sensoren lesen: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=104 UID=104 GeneratorClassName=TSignalReader Name=buz1.sensor.Macro6.Macro3.Macro157.SignalReader3 Type=    */</span></span> }; state_vars-&gt;kbastdv104_out_0_[<span class="hljs-number"><span class="hljs-number">0</span></span>] = kba31cf001_mf_type; state_vars-&gt;kbastdv104_out_0_[<span class="hljs-number"><span class="hljs-number">1</span></span>] = kba32cf001_mf_type; state_vars-&gt;kbastdv104_out_0_[<span class="hljs-number"><span class="hljs-number">2</span></span>] = kba33cf001_mf_type; state_vars-&gt;kbastdv104_out_0_[<span class="hljs-number"><span class="hljs-number">3</span></span>] = uf40y329084320_mf_type</code> </pre> <br><p>  Dann sortieren wir alle Blöcke der Reihe nach und führen sie in einer Schleife aus.  Für jedes Element eines Array vom Typ wird jeder Berechnungsblock für alle Sensoren durchgeführt. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=211 UID=211 GeneratorClassName=TAndSrc Name=buz1.sensor.Macro6.And61 Type=  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>;i++){ locals-&gt;v211_out_0_[i] = state_vars-&gt;kbastdv125_out_0_[i] &amp;&amp; (!(locals-&gt;v191_out_7_[i] &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* Index=212 UID=212 GeneratorClassName=TMulDbl Name=buz1.sensor.Macro6.Mul_oper1 Type= */</span></span> locals-&gt;v209_out_2_[i] = consts-&gt;kbastdv121_a_[i]*state_vars-&gt;kbastdv127_out_0_[i]; <span class="hljs-comment"><span class="hljs-comment">/* Index=213 UID=213 GeneratorClassName=TSumSrc Name=buz1.sensor.Macro6.Add_oper1 Type= */</span></span> locals-&gt;v209_out_3_[i] = (<span class="hljs-number"><span class="hljs-number">1</span></span>)*consts-&gt;kbastdv122_a_[i]+(<span class="hljs-number"><span class="hljs-number">1</span></span>)*locals-&gt;v209_out_2_[i]; … }</code> </pre><br>  Nach der Berechnung zeichnen wir die Signale für jede Instanz der Klasse auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=776 UID=776 GeneratorClassName=TSignalWriter Name=buz1.sensor.Macro6.Macro3.SignalWriter4 Type=    */</span></span> kba31cf001_mf_xb01 = state_vars-&gt;kbastdv207_out_0_[<span class="hljs-number"><span class="hljs-number">0</span></span>]; kba32cf001_mf_xb01 = state_vars-&gt;kbastdv207_out_0_[<span class="hljs-number"><span class="hljs-number">1</span></span>]; kba33cf001_mf_xb01 = state_vars-&gt;kbastdv207_out_0_[<span class="hljs-number"><span class="hljs-number">2</span></span>]; uf40y329084320_mf_xb01 = state_vars-&gt;kbastdv207_out_0_[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre><br><p>  Wie Sie sehen können, enthält der endgültige Code keine Objekte.  Sauber, unschuldig und sicher SI.  Im obigen Beispiel, der Implementierung von OOP in einer Grafiksprache, berechnet eine Vektorschaltung alle Sensoren des gleichen Typs.  Mit dieser Technik können Sie ein Schema ändern, um die Verarbeitung aller Sensoren zu ändern. </p><br><p>  Ein weiterer zusätzlicher Vorteil dieses Ansatzes ist die Fehlerversicherung.  Stellen Sie sich vor: Sie fügen manuell einen Sensor hinzu und haben an einer Stelle vergessen, die Anzahl der Wiederholungen während der Verarbeitung in einem Zyklus zu erhöhen.  Kein statischer Code-Analysator kann diesen Fehler erkennen, der Code ist korrekt.  Und selbst bei der Arbeit wirkt sich dies möglicherweise nicht sofort und auf offensichtliche Weise aus. </p><br><p>  Nun, am Ende der versprochene Polymorphismus und Vererbung.  Bei der ersten Methode erhielt der Benutzer viele identische Schemata, die er nach der Installation des Untermodellblocks bearbeiten und dadurch einen Polymorphismus ausführen konnte, wodurch das Verhalten einer bestimmten Instanz der Klasse geändert wurde.  Ich denke, jeder hat vermutet, dass es möglich ist, das Verarbeitungsschema für einen bestimmten Sensor zu ändern, und wir werden eine neue Klasse erhalten, die dieselben Felder hat, aber die Methoden sind unterschiedlich.  Sie können auch neue Felder hinzufügen und eine neue Klasse mit verschiedenen Feldern abrufen, die alle Felder des übergeordneten Elements und die Methoden des übergeordneten Elements enthalten. </p><br><p>  Abbildung 6 zeigt ein Beispiel für zwei Blöcke der Klassen „Eltern“ und „Erbe“.  Innerhalb des Blocks wird das Berechnungsschema der übergeordneten Klasse gespeichert.  Alle Daten gehen zu einem gemeinsamen Vektorblock, ähnlich dem Block in Fig. 1.  4. Die übergeordnete Klassenmethode wird vollständig wiederholt.  Und dann hat die Nachfolgeklasse ein zusätzliches Feld <b>Yatm</b> und eine zusätzliche Neuberechnung des Wertes unter Verwendung des linearen Interpolationsblocks. </p><br><p>  Somit bleibt es möglich, die Verarbeitungsmethoden des Elternteils zu ändern, die sich in allen Klassenerben ändern, sowie das Verhalten des Erben individuell anzupassen. </p><br><p><img width="700" src="https://habrastorage.org/webt/cj/uf/fl/cjufflnh6w6vxom0ihlevs34vf0.png"><br>  <i><font color="#999999">Abbildung 6. Polymorphismus bei Klassenerben.</font></i> </p><br><p>  Zusammenfassend können wir argumentieren, dass die OOP-Methodik verwendet werden kann, um Software in grafischen Programmiersprachen zu erstellen.  Abstraktion, Kapselung, Vererbung, Polymorphismus - all diese Prinzipien lassen sich mit den richtigen Entwicklungswerkzeugen einfach und natürlich umsetzen.  Es ist wichtig zu beachten, dass der endgültige Code nach der automatischen Generierung aus einer Grafiksprache rein sicheres C ohne OOP bleibt </p><br><p>  In einigen Fällen ist das Ergebnis der Entwicklung von Steuerungssoftware in grafischer Form nicht der C-Code zum Laden in die Steuerungen, sondern der Schaltplan "Eisenlogik", aber die oben beschriebene Technik OOP funktioniert auch einwandfrei. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454232/">https://habr.com/ru/post/de454232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454216/index.html">Es wurden Beweise dafür gefunden, dass alle Änderungen eine Mischung aus Ordnung und Zufall sind</a></li>
<li><a href="../de454220/index.html">Zweistelliges Thermometer</a></li>
<li><a href="../de454222/index.html">Aktualisieren Sie das Festplattensubsystem des alten Servers mit dem PCIe 1.0 - 2.0-Bus</a></li>
<li><a href="../de454224/index.html">Empfehlungen in Okko: Wie man Hunderte von Millionen verdient, indem man ein paar Matrizen multipliziert</a></li>
<li><a href="../de454226/index.html">Speicher auf zylindrischen magnetischen Domänen. Teil 1. Arbeitsprinzip</a></li>
<li><a href="../de454236/index.html">Zwei Geschichten darüber, wie ANKI Ihnen helfen kann, eine Fremdsprache zu lernen und sich auf ein Interview vorzubereiten</a></li>
<li><a href="../de454240/index.html">Wavelet-Analyse. Teil 3</a></li>
<li><a href="../de454242/index.html">"Schau, was für ein Jetpack ich habe!" "Ha, schau was für eine Rakete ich habe!" (Notizen von der Raketenmeisterschaft)</a></li>
<li><a href="../de454246/index.html">Verschiedene Koordinaten, die in der Unity3d-Benutzeroberfläche verwendet werden</a></li>
<li><a href="../de454248/index.html">Leibeigene im Zeitalter der künstlichen Intelligenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>