<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé® üìÑ ‚ôâÔ∏è Bausteine ‚Äã‚Äãverteilter Anwendungen. Zweite Ann√§herung ‚ô®Ô∏è üëç ü§∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ank√ºndigung 


 Kolleginnen und Kollegen, ich plane, mitten im Sommer eine weitere Artikelserie zum Design von Warteschlangensystemen zu ver√∂ffentlich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bausteine ‚Äã‚Äãverteilter Anwendungen. Zweite Ann√§herung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446344/"><p>  <strong>Ank√ºndigung</strong> </p><br><p>  <em>Kolleginnen und Kollegen, ich plane, mitten im Sommer eine weitere Artikelserie zum Design von Warteschlangensystemen zu ver√∂ffentlichen: ‚ÄûVTrade Experiment‚Äú - ein Versuch, ein Framework f√ºr Handelssysteme zu schreiben.</em>  <em>Der Zyklus analysiert die Theorie und Praxis des Aufbaus einer B√∂rse, einer Auktion und eines Gesch√§fts.</em>  <em>Am Ende des Artikels schlage ich vor, f√ºr die Themen zu stimmen, die Sie am meisten interessieren.</em> <em><br></em> </p><br><p><img src="https://habrastorage.org/webt/ee/vo/mu/eevomuwv9mtkcyoawxhqzjjj9iu.jpeg"></p><br><p> Dies ist der letzte Artikel im verteilten reaktiven Anwendungszyklus von Erlang / Elixir.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> finden Sie die theoretischen Grundlagen der reaktiven Architektur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der zweite Artikel</a> veranschaulicht die grundlegenden Muster und Mechanismen zum Aufbau solcher Systeme. </p><br><p>  Heute werden wir Fragen zur Entwicklung der Codebasis und der Projekte im Allgemeinen aufwerfen. </p><a name="habracut"></a><br><h2 id="organizaciya-servisov">  Serviceorganisation </h2><br><p>  Im wirklichen Leben m√ºssen Sie bei der Entwicklung eines Dienstes h√§ufig mehrere Interaktionsmuster in einem Controller kombinieren.  Beispielsweise muss der Benutzerdienst, der die Aufgaben zum Verwalten von Benutzerprofilen f√ºr ein Projekt l√∂st, auf Anforderungsanforderungen antworten und Profilaktualisierungen √ºber pub-sub melden.  Dieser Fall ist ganz einfach: Hinter Messaging befindet sich ein Controller, der die Logik des Dienstes implementiert und Aktualisierungen ver√∂ffentlicht. </p><br><p>  Die Situation ist kompliziert, wenn wir einen fehlertoleranten verteilten Dienst implementieren m√ºssen.  Angenommen, die Benutzeranforderungen haben sich ge√§ndert: </p><br><ol><li>  Jetzt sollte der Dienst Anforderungen auf 5 Knoten des Clusters verarbeiten. </li><li>  in der Lage sein, Hintergrundverarbeitungsaufgaben auszuf√ºhren, </li><li>  und in der Lage sein, Ihre Profilaktualisierungs-Abonnementlisten dynamisch zu verwalten. </li></ol><br><p>  <em>Hinweis:</em> Das Problem der konsistenten Speicherung und Replikation von Daten wird nicht ber√ºcksichtigt.  Angenommen, diese Probleme wurden fr√ºher behoben und das System verf√ºgt bereits √ºber eine zuverl√§ssige und skalierbare Speicherschicht, und die Handler verf√ºgen √ºber Mechanismen zur Interaktion mit ihr. </p><br><p>  Die formale Beschreibung des Benutzerdienstes ist komplizierter geworden.  Aus Sicht eines Programmierers ist die Verwendung von Messaging-√Ñnderungen minimal.  Um die erste Anforderung zu erf√ºllen, m√ºssen wir den Ausgleich am erforderlichen Austauschpunkt anpassen. </p><br><p>  Die Anforderung, Hintergrundaufgaben zu erledigen, entsteht h√§ufig.  Bei Benutzern kann dies das √úberpr√ºfen von Benutzerdokumenten, das Verarbeiten heruntergeladener Multimedia-Inhalte oder das Synchronisieren von Daten mit sozialen Diensten sein.  Netzwerke.  Diese Aufgaben m√ºssen irgendwie innerhalb des Clusters verteilt sein und den Fortschritt steuern.  Daher haben wir zwei L√∂sungen: Verwenden Sie entweder die Aufgabenverteilungsvorlage aus dem vorherigen Artikel oder schreiben Sie, falls dies nicht passt, einen benutzerdefinierten Aufgabenplaner, der f√ºr die Verwaltung des Pools von Handlern erforderlich ist. </p><br><p>  Punkt 3 erfordert eine Erweiterung der Pub-Sub-Vorlage.  Und f√ºr die Implementierung m√ºssen wir nach dem Erstellen des Pub-Sub-Austauschpunkts zus√§tzlich den Controller dieses Punkts als Teil unseres Service starten.  Daher scheinen wir die Logik der Verarbeitung von Abonnements und der Abmeldung von der Messaging-Schicht in die Benutzerimplementierung zu √ºbernehmen. </p><br><p>  Als Ergebnis zeigte die Zerlegung der Aufgabe, dass wir zur Erf√ºllung der Anforderungen 5 Dienstinstanzen auf verschiedenen Knoten ausf√ºhren und eine zus√§tzliche Entit√§t erstellen m√ºssen - den Pub-Sub-Controller, der f√ºr das Abonnieren verantwortlich ist. <br>  Um 5 Handler auszuf√ºhren, m√ºssen Sie den Servicecode nicht √§ndern.  Die einzige zus√§tzliche Aktion besteht darin, am Austauschpunkt Ausgleichsregeln einzurichten, √ºber die wir etwas sp√§ter sprechen werden. <br>  Es gab auch zus√§tzliche Komplexit√§t: Der Pub-Sub-Controller und der benutzerdefinierte Taskplaner sollten in einer einzigen Kopie arbeiten.  Auch hier sollte der Nachrichtendienst als grundlegender Mechanismus einen Mechanismus zur Auswahl eines Leiters bereitstellen. </p><br><h3 id="vybor-lidera">  Wahl des F√ºhrers </h3><br><p>  In verteilten Systemen ist die Wahl eines Leiters der Prozess der Ernennung des einzigen Prozesses, der f√ºr die Planung der verteilten Verarbeitung einer Last verantwortlich ist. </p><br><p>  In Systemen, die nicht zur Zentralisierung neigen, werden universelle Konsensalgorithmen wie Paxos oder Flo√ü verwendet. <br>  Da Messaging ein Makler und ein zentrales Element ist, kennt er alle Service-Controller - Kandidaten f√ºr die F√ºhrung.  Messaging kann einen Leiter ohne Abstimmung ernennen. </p><br><p> Nach dem Starten und <code>#'$leader'{exchange = ?EXCHANGE, pid = LeaderPid, servers = Servers}</code> Verbindung zum Austauschpunkt erhalten alle Dienste die Systemmeldung <code>#'$leader'{exchange = ?EXCHANGE, pid = LeaderPid, servers = Servers}</code> .  Wenn <code>LeaderPid</code> mit der <code>pid</code> aktuellen Prozesses <code>LeaderPid</code> , wird sie als Leader zugewiesen, und die <code>Servers</code> enth√§lt alle Knoten und ihre Parameter. <br>  Wenn ein neuer Clusterknoten angezeigt wird und die Verbindung getrennt wird, erhalten alle Service-Controller die <code>#'$slave_up'{exchange = ?EXCHANGE, pid = SlavePid, options = SlaveOpts}</code> und <code>#'$slave_down'{exchange = ?EXCHANGE, pid = SlavePid, options = SlaveOpts}</code> . </p><br><p>  Somit sind alle Komponenten √ºber alle √Ñnderungen informiert, und im Cluster ist zu jedem Zeitpunkt ein Leiter garantiert. </p><br><h2 id="posredniki">  Vermittler </h2><br><p>  F√ºr die Implementierung komplexer verteilter Verarbeitungsprozesse sowie f√ºr die Optimierung einer vorhandenen Architektur ist es zweckm√§√üig, Vermittler einzusetzen. <br>  Um den Code der Dienste nicht zu √§ndern und beispielsweise die Aufgaben der zus√§tzlichen Verarbeitung, Weiterleitung oder Protokollierung von Nachrichten zu l√∂sen, k√∂nnen Sie vor dem Dienst einen Proxy-Prozessor aktivieren, der alle zus√§tzlichen Arbeiten ausf√ºhrt. </p><br><p>  Ein klassisches Beispiel f√ºr die Pub-Sub-Optimierung ist eine verteilte Anwendung mit einem Business-Kernel, der Aktualisierungsereignisse generiert, z. B. eine √Ñnderung des Marktpreises, und einer Zugriffsebene - N-Server, die Websocket-APIs f√ºr Webclients bereitstellen. <br>  Wenn Sie sich f√ºr "Stirn" entscheiden, ist der Kundenservice wie folgt: </p><br><ul><li>  Der Client stellt Verbindungen zur Plattform her.  Auf der Serverseite wird der Prozess, der diese Verbindung bedient, gestartet, indem der Datenverkehr beendet wird. </li><li>  Im Rahmen des Serviceprozesses erfolgt die Autorisierung und das Abonnement von Updates.  Der Prozess ruft die Abonnementmethode f√ºr Themen auf. </li><li>  Nachdem das Ereignis im Kernel generiert wurde, wird es an die Prozesse √ºbermittelt, die die Verbindungen bedienen. </li></ul><br><p>  Stellen Sie sich vor, wir haben 50.000 Abonnenten f√ºr das Thema "Nachrichten".  Abonnenten sind gleichm√§√üig auf 5 Server verteilt.  Infolgedessen wird jedes Update, das am Austauschpunkt eintrifft, 50.000 Mal repliziert: 10.000 Mal auf jeden Server, je nach Anzahl der Abonnenten.  Nicht ganz ein effektives Schema, oder? <br>  Um die Situation zu verbessern, f√ºhren wir einen gleichnamigen Proxy mit dem Austauschpunkt ein.  Der globale Namensregistrator sollte in der Lage sein, den n√§chstgelegenen Prozess namentlich zur√ºckzugeben. Dies ist wichtig. </p><br><p>  F√ºhren Sie diesen Proxy auf den Servern der Zugriffsschicht aus, und alle unsere Prozesse, die die Websocket-API bedienen, abonnieren ihn und nicht den urspr√ºnglichen Pub-Sub-Austauschpunkt im Kernel.  Der Proxy abonniert den Kernel nur im Fall eines eindeutigen Abonnements und repliziert die eingehende Nachricht an alle seine Abonnenten. <br>  Infolgedessen werden 5 Nachrichten anstelle von 50.000 Nachrichten zwischen dem Kernel und den Zugriffsservern gesendet. </p><br><h2 id="marshrutizaciya-i-balansirovka">  Routing und Balancing </h2><br><h3 id="req-resp">  Req-resp </h3><br><p>  In der aktuellen Messaging-Implementierung gibt es 7 Strategien zur Verteilung von Abfragen: </p><br><ul><li>  <code>default</code> .  Die Anfrage wird an alle Controller weitergeleitet. </li><li>  <code>round-robin</code> .  Durchl√§uft und verteilt Anforderungen zyklisch zwischen Controllern. </li><li>  <code>consensus</code> .  Die Controller, die den Dienst bedienen, sind in Leiter und Anh√§nger unterteilt.  Anfragen werden nur an den Leiter weitergeleitet. </li><li>  <code>consensus &amp; round-robin</code> .  Es gibt einen Leiter in der Gruppe, aber Anfragen werden unter allen Mitgliedern verteilt. </li><li>  <code>sticky</code> .  Die Hash-Funktion wird berechnet und einem bestimmten Handler zugewiesen.  Nachfolgende Anforderungen mit dieser Signatur gehen an denselben Handler. </li><li>  <code>sticky-fun</code> .  Bei der Initialisierung des Austauschpunktes wird zus√§tzlich die Hash-Berechnungsfunktion f√ºr den <code>sticky</code> Balancing √ºbertragen. </li><li>  <code>fun</code> .  Es ist √§hnlich wie Sticky-Fun, nur k√∂nnen Sie es zus√§tzlich umleiten, ablehnen oder vorverarbeiten. </li></ul><br><p>  Die Verteilungsstrategie wird festgelegt, wenn der Austauschpunkt initialisiert wird. </p><br><p>  Zus√§tzlich zum Ausgleich von Messaging k√∂nnen Sie Entit√§ten mit Tags versehen.  Betrachten Sie die Arten von Tags im System: </p><br><ul><li>  Verbindungs-Tag.  Erm√∂glicht es Ihnen zu verstehen, durch welche Verbindung die Ereignisse kamen.  Wird verwendet, wenn der Controller-Prozess eine Verbindung zum gleichen Vermittlungspunkt herstellt, jedoch mit unterschiedlichen Routing-Schl√ºsseln. </li><li>  Service-Tag.  Erm√∂glicht einem einzelnen Dienst das Gruppieren von Prozessoren und das Erweitern der Routing- und Ausgleichsfunktionen.  F√ºr das Anforderungsmuster ist das Routing linear.  Wir senden eine Anfrage an die Vermittlungsstelle und leiten sie dann an den Service weiter.  Wenn wir die Handler jedoch in logische Gruppen aufteilen m√ºssen, erfolgt die Aufteilung mithilfe von Tags.  Wenn Sie ein Tag angeben, wird die Anforderung an eine bestimmte Gruppe von Controllern weitergeleitet. </li><li>  Tag anfordern.  Erm√∂glicht die Unterscheidung von Antworten.  Da unser System asynchron ist, m√ºssen Sie beim Verarbeiten einer Anfrage einen RequestTag angeben k√∂nnen, um Serviceantworten verarbeiten zu k√∂nnen.  Daraus k√∂nnen wir die Antwort verstehen, auf die die Anfrage zu uns kam. </li></ul><br><h3 id="pub-sub">  Pub sub </h3><br><p>  F√ºr Pub-Sub sind die Dinge etwas einfacher.  Wir haben einen Austauschpunkt, f√ºr den Nachrichten ver√∂ffentlicht werden.  Der Austauschpunkt verteilt Nachrichten zwischen Teilnehmern, die die ben√∂tigten Routing-Schl√ºssel abonnieren (wir k√∂nnen sagen, dass dies analog zu diesen ist). </p><br><h2 id="masshtabiruemost-i-otkazoustoychivost">  Skalierbarkeit und Ausfallsicherheit </h2><br><p>  Die Skalierbarkeit des Gesamtsystems h√§ngt vom Grad der Skalierbarkeit der Schichten und Komponenten des Systems ab: </p><br><ul><li>  Services werden skaliert, indem dem Cluster zus√§tzliche Knoten mit Handlern f√ºr diesen Service hinzugef√ºgt werden.  W√§hrend des Testbetriebs k√∂nnen Sie die optimale Ausgleichsrichtlinie ausw√§hlen. </li><li>  Der Messaging-Dienst selbst innerhalb eines einzelnen Clusters wird im Allgemeinen entweder durch Verschieben speziell geladener Austauschpunkte auf einzelne Clusterknoten oder durch Hinzuf√ºgen von Proxy-Prozessen zu speziell geladenen Zonen des Clusters vergr√∂√üert. </li><li>  Die Skalierbarkeit des gesamten Systems als Merkmal h√§ngt von der Flexibilit√§t der Architektur und der M√∂glichkeit ab, einzelne Cluster zu einer gemeinsamen logischen Einheit zu kombinieren. </li></ul><br><p>  Die Einfachheit und Geschwindigkeit der Skalierung bestimmt h√§ufig den Erfolg eines Projekts.  Das Messaging in seiner aktuellen Leistung w√§chst mit der Anwendung.  Selbst wenn uns eine Gruppe von 50-60 Autos fehlt, k√∂nnen wir auf den Verband zur√ºckgreifen.  Leider geht das Thema F√∂deration √ºber den Rahmen dieses Artikels hinaus. </p><br><h2 id="rezervirovanie">  Reservierung </h2><br><p>  In der Analyse des Lastausgleichs haben wir bereits die Reservierung von Service-Controllern er√∂rtert.  Nachrichten sollten jedoch auch reserviert werden.  Im Falle eines Knoten- oder Maschinenabsturzes sollte das Messaging automatisch und so bald wie m√∂glich wiederhergestellt werden. </p><br><p>  In meinen Projekten verwende ich zus√§tzliche Knoten, die im Falle eines Sturzes die Last aufnehmen.  Erlang verf√ºgt √ºber eine Standardimplementierung im verteilten Modus f√ºr OTP-Anwendungen.  Der verteilte Modus f√ºhrt tats√§chlich eine Wiederherstellung im Falle eines Fehlers durch, indem die abgest√ºrzte Anwendung auf einem anderen zuvor gestarteten Knoten gestartet wird.  Der Prozess ist transparent. Nach einem Fehler wird die Anwendung automatisch auf den Failover-Knoten verschoben.  Weitere Informationen zu dieser Funktionalit√§t finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h2 id="proizvoditelnost">  Leistung </h2><br><p>  Versuchen wir, die Leistung von rabbitmq und unseren benutzerdefinierten Nachrichten zumindest ann√§hernd zu vergleichen. <br>  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle</a> Rabbitmq-Testergebnisse vom Openstack-Team gefunden. </p><br><p>  In Abschnitt 6.14.1.2.1.2.2.  Das Originaldokument enth√§lt das Ergebnis von RPC CAST: <br><img src="https://habrastorage.org/webt/bz/qq/us/bzqqussv9flqi-wvzhgj8i43wcw.png"></p><br><p>  Bisher werden keine zus√§tzlichen Einstellungen f√ºr den Betriebssystemkernel oder die erlang-VM vorgenommen.  Testbedingungen: </p><br><ul><li>  erl w√§hlt: + A1 + sbtu. </li><li>  Der Test innerhalb eines einzelnen erlang-Knotens l√§uft auf einem Laptop mit einem alten i7 in mobiler Leistung. </li><li>  Clustertests finden auf Servern mit einem 10G-Netzwerk statt. </li><li>  Der Code funktioniert in Docker-Containern.  Netzwerk im NAT-Modus. </li></ul><br><p>  Testcode: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">req_resp_bench</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function"> -&gt;</span></span> W = perftest:comprehensive(<span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span>() -&gt; messaging:request(?EXCHANGE, default, ping, self()), <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> #'$msg'{message = pong} -&gt; ok <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> -&gt; throw(timeout) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ), <span class="hljs-literal"><span class="hljs-literal">true</span></span> = lists:any(<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span>(E) -&gt; E &gt;= <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, W), ok.</code> </pre> <br><p>  <em>Szenario 1:</em> Der Test wird auf einem Laptop mit einer alten mobilen i7-Ausf√ºhrung ausgef√ºhrt.  Test, Messaging und Service werden auf einem Knoten in einem Docker-Container ausgef√ºhrt: </p><br><pre> <code class="plaintext hljs">Sequential 10000 cycles in ~0 seconds (26987 cycles/s) Sequential 20000 cycles in ~1 seconds (26915 cycles/s) Sequential 100000 cycles in ~4 seconds (26957 cycles/s) Parallel 2 100000 cycles in ~2 seconds (44240 cycles/s) Parallel 4 100000 cycles in ~2 seconds (53459 cycles/s) Parallel 10 100000 cycles in ~2 seconds (52283 cycles/s) Parallel 100 100000 cycles in ~3 seconds (49317 cycles/s)</code> </pre> <br><p>  <em>Szenario 2</em> : 3 Knoten, die auf verschiedenen Computern unter Docker (NAT) ausgef√ºhrt werden. </p><br><pre> <code class="plaintext hljs">Sequential 10000 cycles in ~1 seconds (8684 cycles/s) Sequential 20000 cycles in ~2 seconds (8424 cycles/s) Sequential 100000 cycles in ~12 seconds (8655 cycles/s) Parallel 2 100000 cycles in ~7 seconds (15160 cycles/s) Parallel 4 100000 cycles in ~5 seconds (19133 cycles/s) Parallel 10 100000 cycles in ~4 seconds (24399 cycles/s) Parallel 100 100000 cycles in ~3 seconds (34517 cycles/s)</code> </pre> <br><p>  In allen F√§llen √ºberschritt die CPU-Auslastung 250% nicht </p><br><h2 id="itogi">  Zusammenfassung </h2><br><p>  Ich hoffe, dieser Zyklus sieht nicht wie eine Bewusstseinsdeponie aus, und meine Erfahrung wird sowohl Forschern verteilter Systeme als auch Praktikern, die am Anfang des Aufbaus verteilter Architekturen f√ºr ihre Gesch√§ftssysteme stehen und Erlang / Elixir mit Interesse betrachten, aber Zweifel haben, echte Vorteile bringen ist es das wert ... </p><br><p>  Foto von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@chuttersnap</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446344/">https://habr.com/ru/post/de446344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446334/index.html">√úberlegungen zu einer Karriere in der IT und Tipps f√ºr Anf√§nger</a></li>
<li><a href="../de446336/index.html">Wie man Standardkennw√∂rter verbietet und alle dazu bringt, dich zu hassen</a></li>
<li><a href="../de446338/index.html">SVG 3D: Erstellen, Drehen und Animieren</a></li>
<li><a href="../de446340/index.html">Betriebssysteme: Drei einfache Teile. Teil 1: Intro (√úbersetzung)</a></li>
<li><a href="../de446342/index.html">Der Einfluss transparenter gro√üer Seiten auf die Systemleistung</a></li>
<li><a href="../de446346/index.html">Das Entwickeln von Anwendungen f√ºr Android ist wie ein (d√§monisiertes) YouTube</a></li>
<li><a href="../de446348/index.html">Einfache JSON-RPC-√§hnliche API in PHP</a></li>
<li><a href="../de446350/index.html">Was letztendlich AirPower get√∂tet hat</a></li>
<li><a href="../de446352/index.html">Schutz ohne Schutz</a></li>
<li><a href="../de446354/index.html">Sicherheitswoche 14: ShadowHammer und Lieferkette</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>