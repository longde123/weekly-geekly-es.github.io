<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ ğŸ™ ğŸ¤£ Buku "Layanan Mikro. Pengembangan dan pola refactoring Â» ğŸ§šğŸ¾ ğŸš­ â›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Jika untuk waktu yang lama tampaknya bagi Anda bahwa semua pengembangan dan penyebaran di perusahaan Anda telah melambat ke puncak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku "Layanan Mikro. Pengembangan dan pola refactoring Â»</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/462519/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ek/1w/6p/ek1w6pyygmendtlfezucuvzecai.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Jika untuk waktu yang lama tampaknya bagi Anda bahwa semua pengembangan dan penyebaran di perusahaan Anda telah melambat ke puncak - pergi ke arsitektur microservice.  Ini menyediakan pengembangan berkelanjutan, pengiriman dan penyebaran aplikasi dari segala kompleksitas. <br><br>  Buku ini, ditujukan untuk para pengembang dan arsitek dari perusahaan besar, menceritakan bagaimana merancang dan menulis aplikasi dalam semangat arsitektur layanan-mikro.  Ini juga menjelaskan bagaimana cara memperbaiki aplikasi besar - dan monolith berubah menjadi seperangkat layanan microser. <br><br>  Kami menawarkan Anda untuk membiasakan diri dengan bagian "Manajemen Transaksi dalam Arsitektur Layanan Mikro" <br><a name="habracut"></a><br>  Hampir setiap permintaan yang diproses oleh aplikasi industri dijalankan sebagai bagian dari transaksi basis data.  Pengembang aplikasi semacam itu menggunakan kerangka kerja dan perpustakaan yang menyederhanakan bekerja dengan transaksi.  Beberapa alat menyediakan API keharusan untuk memulai, melakukan, dan memutar kembali transaksi secara manual.  Dan kerangka kerja seperti Spring memiliki mekanisme deklaratif.  Spring mendukung anotasi @Transaksional, yang secara otomatis memanggil metode dalam transaksi.  Berkat ini, menulis logika bisnis transaksional menjadi sangat sederhana. <br><br>  Untuk lebih tepatnya, mengelola transaksi sederhana dalam aplikasi monolitik yang mengakses satu basis data.  Jika aplikasi menggunakan beberapa database dan pialang pesan, proses ini menjadi lebih sulit.  Nah, dalam arsitektur microservice, transaksi mencakup beberapa layanan, yang masing-masing memiliki database sendiri.  Dalam keadaan seperti itu, aplikasi harus menggunakan mekanisme transaksi yang lebih canggih.  Seperti yang akan segera Anda lihat, pendekatan tradisional untuk transaksi terdistribusi tidak layak dalam aplikasi modern.  Sistem berbasis microservice harus menggunakan mendongeng sebagai gantinya. <br><br>  Tetapi sebelum beralih ke narasi, mari kita lihat mengapa manajemen transaksi menciptakan begitu banyak kompleksitas dalam arsitektur layanan-mikro. <br><br><h3>  4.1.1.  Arsitektur microservice dan kebutuhan untuk transaksi terdistribusi </h3><br>  Bayangkan Anda adalah pengembang di FTGO dan bertanggung jawab untuk mengimplementasikan operasi sistem createOrder ().  Seperti yang dijelaskan dalam Bab 2, operasi ini harus memastikan bahwa pelanggan dapat melakukan pemesanan, memeriksa detail pesanan, mengotorisasi kartu bank pelanggan, dan membuat catatan pesanan dalam database.  Implementasi dari tindakan ini akan relatif sederhana dalam aplikasi monolitik.  Semua data yang diperlukan untuk memverifikasi pesanan sudah siap dan tersedia.  Selain itu, transaksi ACID dapat digunakan untuk memastikan konsistensi data.  Anda cukup menentukan anotasi @Transaksional untuk metode layanan createOrder (). <br><br>  Namun, melakukan operasi ini dalam arsitektur layanan mikro jauh lebih sulit.  Seperti yang dapat dilihat pada gambar.  4.1, data yang diperlukan oleh operasi createOrder () tersebar di beberapa layanan.  createOrder () membaca informasi dari layanan Konsumen dan memperbarui konten dari layanan Order, Kitchen, dan Accounting. <br><br>  Karena setiap layanan memiliki database sendiri, Anda harus menggunakan mekanisme untuk mengoordinasikan data di antara mereka. <br><br><h3>  4.1.2.  Masalah Transaksi Terdistribusi </h3><br>  Pendekatan tradisional untuk memastikan konsistensi data antara beberapa layanan, database, atau pialang pesan adalah penggunaan transaksi yang didistribusikan.  Standar de facto untuk manajemen transaksi terdistribusi adalah X / Open XA (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">en.wikipedia.org/wiki/XA</a> ).  Model XA menggunakan komitmen dua fase (2PC) untuk memastikan bahwa semua perubahan transaksi disimpan atau dibatalkan.  Ini membutuhkan basis data, pialang pesan, penggerak basis data, dan API perpesanan untuk mematuhi standar XA, dan mekanisme komunikasi antarproses yang mendistribusikan pengidentifikasi transaksi XA global juga diperlukan.  Sebagian besar basis data relasional kompatibel dengan XA, seperti halnya beberapa broker pesan.  Misalnya, aplikasi berbasis Java EE dapat melakukan transaksi terdistribusi menggunakan JTA. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ff/wu/yn/ffwuynn5jzi8tq1syefgykvayi0.png" alt="gambar"></div><br>  Terlepas dari kesederhanaannya, transaksi yang didistribusikan memiliki sejumlah masalah.  Banyak teknologi modern, termasuk basis data NoSQL seperti MongoDB dan Cassandra, tidak mendukungnya.  Transaksi yang didistribusikan tidak didukung oleh beberapa broker pesan modern seperti RabbitMQ dan Apache Kafka.  Jadi, jika Anda memutuskan untuk menggunakan transaksi terdistribusi, banyak alat modern tidak akan tersedia untuk Anda. <br><br>  Masalah lain dengan transaksi terdistribusi adalah bahwa mereka adalah bentuk IPC sinkron, yang mengganggu ketersediaan.  Agar transaksi yang didistribusikan dilakukan, semua layanan yang terlibat di dalamnya harus dapat diakses.  Seperti dijelaskan dalam Bab 3, aksesibilitas sistem adalah produk dari aksesibilitas semua peserta transaksi.  Jika dua layanan dengan ketersediaan 99,5% berpartisipasi dalam transaksi terdistribusi, ketersediaan keseluruhan akan menjadi 99%, yang jauh lebih sedikit.  Setiap layanan tambahan menurunkan tingkat ketersediaan.  Eric Brewer merumuskan teorema CAP, yang menyatakan bahwa sistem hanya dapat memiliki dua dari tiga properti berikut: konsistensi, aksesibilitas, dan resistensi partisi (en.wikipedia.org/wiki/CAP_ Theorem).  Saat ini, arsitek menyukai sistem yang terjangkau, mengorbankan konsistensi. <br><br>  Sekilas, transaksi yang didistribusikan mungkin tampak menarik.  Dari sudut pandang pengembang, mereka memiliki model perangkat lunak yang sama dengan transaksi lokal.  Tetapi karena masalah yang dijelaskan sebelumnya, teknologi ini tidak dapat digunakan dalam aplikasi modern.  Bab 3 menunjukkan cara mengirim pesan sebagai bagian dari transaksi basis data tanpa menggunakan transaksi terdistribusi.  Untuk memecahkan masalah yang lebih kompleks dalam memastikan konsistensi data dalam arsitektur layanan mikro, aplikasi harus menggunakan mekanisme yang berbeda berdasarkan konsep layanan asinkron yang digabungkan secara longgar.  Dan di sini narasinya sangat berguna. <br><br><h3>  4.1.3.  Gunakan template Storytelling untuk menjaga konsistensi data </h3><br>  Mendongeng adalah mekanisme yang memastikan konsistensi data dalam arsitektur layanan mikro tanpa menggunakan transaksi yang didistribusikan.  Narasi dibuat untuk setiap tim sistem yang perlu memperbarui data di beberapa layanan.  Ini adalah urutan transaksi lokal, yang masing-masing memperbarui data dalam satu layanan, menggunakan kerangka kerja dan pustaka yang dikenal untuk transaksi ACID yang disebutkan sebelumnya. <br><br><blockquote>  <b>Templat Mendongeng</b> <br><br>  Memastikan konsistensi data antara layanan menggunakan urutan transaksi lokal yang dikoordinasikan menggunakan pesan asinkron.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">microservices.io/patterns/data/saga.html</a> . </blockquote><br>  Operasi sistem memulai tahap pertama dari narasi.  Penyelesaian satu transaksi lokal mengarah ke yang berikut ini.  Di bagian 4.2, Anda akan melihat bagaimana koordinasi langkah-langkah ini dicapai menggunakan pesan asinkron.  Keuntungan penting dari pesan asinkron adalah memastikan semua tahap narasi selesai, bahkan jika satu atau lebih peserta tidak dapat diakses. <br><br>  Narasi memiliki beberapa perbedaan penting dari transaksi ACID.  Pertama-tama, mereka tidak memiliki isolasi (untuk lebih lanjut tentang ini, lihat Bagian 4.3).  Selain itu, karena setiap transaksi lokal menangkap perubahannya, untuk memutar kembali cerita, Anda harus menggunakan transaksi kompensasi, yang akan kita bahas nanti di bagian ini.  Pertimbangkan contoh mendongeng. <br><br><h3>  Contoh Naratif: Membuat Pesanan </h3><br>  Dalam bab ini, kami menggunakan narasi Buat Pesanan sebagai contoh (Gbr. 4.2).  Ini mengimplementasikan operasi createOrder ().  Transaksi lokal pertama dipicu oleh permintaan pembuatan pesanan eksternal.  Lima transaksi yang tersisa dipicu satu demi satu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uz/fb/t7/uzfbt7k9fnld4hszv9_t3knnbr0.png" alt="gambar"></div><br>  Narasi ini terdiri dari transaksi lokal berikut. <br><br>  1. Layanan pemesanan.  Membuat pesanan dengan status APPROVAL_PENDING. <br><br>  2. Layanan Konsumen.  Cek apakah pelanggan dapat memesan. <br><br>  3. Layanan dapur.  Periksa detail pesanan dan buat permintaan dengan status CREATE_PENDING. <br><br>  4. Layanan akuntansi.  Memberi otorisasi kartu bank pelanggan. <br><br>  5. Layanan dapur.  Mengubah status aplikasi menjadi AWAITING_ACCEPTANCE. <br><br>  6. Pesanan Layanan.  Mengubah status pesanan menjadi DISETUJUI. <br><br>  Di Bagian 4.2, saya akan menunjukkan bagaimana layanan yang terlibat dalam cerita berinteraksi satu sama lain menggunakan pesan asinkron.  Layanan menerbitkan pesan setelah menyelesaikan transaksi lokal.  Ini memulai tahap narasi berikutnya dan memungkinkan tidak hanya untuk mencapai kohesi yang lemah dari para peserta, tetapi juga untuk menjamin implementasi narasi sepenuhnya.  Bahkan jika penerima tidak tersedia untuk sementara waktu, broker memberikan pesan sampai dapat dikirimkan. <br><br>  Narasi tampak sederhana, tetapi penggunaannya dikaitkan dengan beberapa kesulitan, terutama dengan kurangnya isolasi di antara mereka.  Solusi untuk masalah ini dijelaskan pada bagian 4.3.  Aspek non-sepele lainnya adalah kemunduran perubahan saat terjadi kesalahan.  Mari kita lihat bagaimana ini dilakukan. <br><br><h3>  Naratif menggunakan transaksi penyeimbangan untuk mengembalikan perubahan </h3><br>  Transaksi ACID tradisional memiliki satu fitur hebat: logika bisnis dapat dengan mudah mengembalikan transaksi jika pelanggaran aturan bisnis terdeteksi.  Itu hanya menjalankan perintah ROLLBACK, dan database membatalkan semua perubahan yang dibuat sejauh ini.  Sayangnya, cerita tidak dapat diputar kembali secara otomatis, karena pada setiap tahap menangkap perubahan dalam database lokal.  Ini, misalnya, berarti bahwa dalam hal terjadi kegagalan otorisasi kartu bank pada tahap keempat dari narasi Buat Pesanan, aplikasi FTGO harus secara manual membatalkan perubahan yang dibuat dalam tiga tahap sebelumnya.  Anda harus menulis apa yang disebut transaksi offset. <br><br>  Misalkan transaksi (n +1) dalam cerita gagal.  Hal ini diperlukan untuk menetralisir konsekuensi dari transaksi sebelumnya.  Pada tingkat konseptual, masing-masing tahap Ti ini memiliki transaksi kompensasi Ci sendiri, yang membatalkan efek Ti.  Untuk mengkompensasi efek dari n tahap pertama, narasi harus mengeksekusi setiap transaksi Ci dalam urutan terbalik.  Urutannya terlihat seperti ini: T1 ... Tn, Cn ... C1 (Gbr. 4.3).  Dalam contoh ini, langkah Tn + 1 gagal, yang membutuhkan pembatalan langkah T1 ... Tn. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ko/87/cx/ko87cx4krtvrrtmlmubc1a2ldsg.png" alt="gambar"></div><br>  Narasi melakukan transaksi kompensasi dalam urutan terbalik dengan yang asli: Cn ... C1.  Di sini, mekanisme eksekusi sekuensial yang sama beroperasi seperti dalam kasus Ti.  Pengakhiran Ci harus memulai Ci - 1. <br><br>  Ambil, misalnya, narasi dari Create Order.  Mungkin gagal karena berbagai alasan. <br><br>  1. Informasi yang salah tentang pelanggan, atau pelanggan tidak diizinkan untuk membuat pesanan. <br><br>  2. Informasi yang salah tentang restoran, atau restoran tidak dapat menerima pesanan. <br><br>  3. Ketidakmampuan untuk mengotorisasi kartu bank pelanggan. <br><br>  Dalam hal terjadi kegagalan dalam transaksi lokal, mekanisme koordinasi mendongeng harus melakukan langkah-langkah kompensasi yang menolak pesanan dan mungkin pesanan.  Di atas meja.  4.1 transaksi kompensasi dikumpulkan untuk setiap tahap narasi Buat Pesanan.  Perlu dicatat bahwa tidak setiap tahap membutuhkan transaksi kompensasi.  Ini berlaku, misalnya, untuk membaca operasi, seperti memverifikasiConsumerDetails (), atau operasi authorizeCreditCard (), semua langkah setelah itu selalu berhasil. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/xw/6i/shxw6ir8i54rjtwehje5qrp8ckw.png" alt="gambar"></div><br>  Di Bagian 4.3, Anda akan menemukan bahwa tiga tahap pertama dari narasi Buat Pesanan disebut transaksi yang tersedia untuk kompensasi, karena langkah-langkah berikut mereka mungkin gagal.  Langkah keempat disebut transaksi balik karena langkah selanjutnya tidak pernah gagal.  Dua langkah terakhir disebut transaksi berulang, karena selalu berakhir dengan sukses. <br><br>  Untuk memahami bagaimana transaksi kompensasi digunakan, bayangkan situasi di mana otorisasi kartu bank pelanggan gagal.  Dalam hal ini, narasi melakukan transaksi lokal berikut. <br><br>  1. Layanan pemesanan.  Membuat pesanan dengan status APPROVAL_PENDING. <br><br>  2. Layanan Konsumen.  Cek apakah pelanggan dapat memesan. <br><br>  3. Layanan dapur.  Periksa detail pesanan dan buat permintaan dengan status CREATE_PENDING. <br><br>  4. Layanan akuntansi.  Melakukan upaya yang gagal untuk mengotorisasi kartu bank pelanggan. <br><br>  5. Layanan dapur.  Mengubah status aplikasi menjadi CREATE_REJECTED. <br><br>  6. Pesanan Layanan.  Mengubah status pesanan menjadi DITOLAK. <br><br>  Tahap kelima dan keenam mengkompensasi transaksi yang membatalkan pembaruan yang dibuat oleh layanan Dapur dan, dengan demikian, Memesan.  Logika naratif yang terkoordinasi bertanggung jawab atas urutan transaksi langsung dan penyeimbangan.  Mari kita lihat cara kerjanya. <br><br><h3>  Tentang penulis </h3><br>  <b>Chris Richardson</b> adalah pengembang, arsitek, dan penulis POJO in Action (Manning, 2006), yang menjelaskan cara membangun aplikasi Java tingkat perusahaan menggunakan kerangka kerja Spring dan Hibernate.  Ia menyandang gelar kehormatan Java Champion dan JavaOne Rock Star. <br><br>  Chris mengembangkan versi asli CloudFoundry.com, implementasi awal platform Java PaaS untuk Amazon EC2. <br><br>  Sekarang ia dianggap sebagai pemimpin ideologis yang diakui di dunia layanan-mikro dan secara teratur berbicara di konferensi internasional.  Chris menciptakan microservices.io, yang berisi pola desain microservice.  Dia juga melakukan konsultasi dan pelatihan di seluruh dunia untuk organisasi yang beralih ke arsitektur layanan mikro.  Chris saat ini sedang mengerjakan startup ketiga, Eventuate.io.  Ini adalah platform perangkat lunak untuk mengembangkan layanan transaksional microser. <br><br>  Â»Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 25% untuk penjaja - <b>Pola Layanan Mikro</b> <br>  Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462519/">https://habr.com/ru/post/id462519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462507/index.html">Saat pengiriman surat: melawan hilangnya pemberitahuan push di iOS</a></li>
<li><a href="../id462509/index.html">Product Fest - konferensi manajemen produk TI yang ingin Anda kunjungi</a></li>
<li><a href="../id462511/index.html">Google Play Instan. Refactoring seumur hidup</a></li>
<li><a href="../id462513/index.html">Relokasi: persiapan, pemilihan, pengembangan wilayah</a></li>
<li><a href="../id462515/index.html">Bug saat bekerja dengan keyboard sistem</a></li>
<li><a href="../id462523/index.html">Server Otorisasi Dua-faktor LinOTP</a></li>
<li><a href="../id462525/index.html">3CX Meluncurkan Softphones SIP Baru untuk iOS dan Android dengan Enkripsi Suara ujung ke ujung</a></li>
<li><a href="../id462527/index.html">Bagaimana SincNet Neural Network Mengalokasikan Frekuensi Signifikan dalam Suara melalui Propagasi Belakang</a></li>
<li><a href="../id462529/index.html">Ide Stasiun Lunar NASA Buruk dan Bagus</a></li>
<li><a href="../id462533/index.html">IntelliJ IDEA 2019.2: Java 13 Pratinjau dukungan, alat profil, jendela layanan baru dan banyak lagi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>