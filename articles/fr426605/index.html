<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêê ‚§µÔ∏è üóûÔ∏è Analyse statique du code PHP en utilisant PHPStan, Phan et Psalm comme exemples üìã ü§∑ ü•ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo existe depuis plus de 12 ans. Nous avons beaucoup de code PHP (des millions de lignes) et probablement m√™me des lignes √©crites il y a 12 ans ont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse statique du code PHP en utilisant PHPStan, Phan et Psalm comme exemples</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/426605/"><img src="https://habrastorage.org/webt/yj/nq/4_/yjnq4_9tdzj0noyiimybxjpoctk.jpeg"><br><br>  Badoo existe depuis plus de 12 ans.  Nous avons beaucoup de code PHP (des millions de lignes) et probablement m√™me des lignes √©crites il y a 12 ans ont √©t√© conserv√©es.  Nous avons du code √©crit √† l'√©poque de PHP 4 et PHP 5. Nous t√©l√©chargeons le code deux fois par jour, et chaque mise en page contient environ 10-20 t√¢ches.  De plus, les programmeurs peuvent publier des correctifs urgents - de petits changements.  Et le jour de tels patchs, nous en gagnons quelques dizaines.  En g√©n√©ral, notre code √©volue tr√®s activement. <br><br>  Nous recherchons constamment des opportunit√©s pour acc√©l√©rer le d√©veloppement et am√©liorer la qualit√© du code.  Nous avons donc d√©cid√© un jour d'impl√©menter l'analyse de code statique.  Ce qui en est sorti, lu sous la coupe. <br><a name="habracut"></a><br><h1>  Types stricts: pourquoi nous ne l'utilisons pas encore </h1><br>  Une fois, une discussion a commenc√© dans notre chat PHP d'entreprise.  L'un des nouveaux employ√©s a expliqu√© comment, sur le lieu de travail pr√©c√©dent, ils avaient introduit les conseils obligatoires de type strict_types + scalaire pour l'ensemble du code - et cela a consid√©rablement r√©duit le nombre de bogues en production. <br><br>  La plupart des anciens bavardeurs √©taient contre une telle innovation.  La principale raison √©tait que PHP n'a pas de compilateur qui v√©rifie tous les types dans le code au moment de la compilation, et si vous n'avez pas une couverture √† 100% du code avec des tests, alors il y a toujours un risque que des erreurs apparaissent lors de la production, ce que nous n'avons pas veulent permettre. <br><br>  Bien s√ªr, strict_types trouvera un certain pourcentage de bogues caus√©s par une incompatibilit√© de type et comment PHP convertit "silencieusement" les types.  Mais de nombreux programmeurs PHP exp√©riment√©s savent d√©j√† comment fonctionne le syst√®me de type en PHP, par quelles r√®gles la conversion de type se produit, et dans la plupart des cas, ils √©crivent du code de travail correct. <br><br>  Mais l'id√©e d'avoir un certain syst√®me montrant o√π dans le code il y a une incompatibilit√© de type, nous avons aim√©.  Nous avons pens√© √† des alternatives √† strict_types. <br><br>  Au d√©but, nous voulions m√™me patcher PHP.  Nous voulions que si la fonction prend une sorte de type scalaire (disons int), et qu'un autre type scalaire (comme float) entre, alors TypeError (qui est une exception en soi) ne serait pas lev√©e, mais une conversion de type se produirait, ainsi que la journalisation de cet √©v√©nement dans error.log.  Cela nous permettrait de trouver tous les endroits o√π nos hypoth√®ses sur les types sont incorrectes.  Mais un tel correctif nous a sembl√© risqu√©, et m√™me il pourrait y avoir des probl√®mes de d√©pendances externes, pas pr√™ts pour un tel comportement. <br><br>  Nous avons abandonn√© l'id√©e de patcher PHP, mais avec le temps, tout a co√Øncid√© avec les premi√®res versions de l'analyseur statique Phan, les premiers commits ayant √©t√© effectu√©s par Rasmus Lerdorf lui-m√™me.  Nous avons donc eu l'id√©e d'essayer des analyseurs de code statique. <br><br><h1>  Qu'est-ce que l'analyse de code statique? </h1><br>  Les analyseurs de code statique lisent simplement le code et essaient d'y trouver des erreurs.  Ils peuvent effectuer des v√©rifications tr√®s simples et √©videntes (par exemple, pour l'existence de classes, de m√©thodes et de fonctions et d'autres plus d√©licates (par exemple, rechercher des incoh√©rences de types, des conditions de concurrence ou des vuln√©rabilit√©s dans le code). La cl√© est que les analyseurs n'ex√©cutent pas de code - ils analyser le texte du programme et le v√©rifier pour des erreurs typiques (et pas si). <br><br>  L'exemple le plus √©vident d'un analyseur de code PHP statique est les inspections dans PHPStorm: lorsque vous √©crivez du code, il met en √©vidence des appels incorrects aux fonctions, m√©thodes, incompatibilit√©s de types de param√®tres, etc. Cependant, PHPStorm n'ex√©cute pas votre code PHP - il ne fait que l'analyser. <br><br>  Je note que dans cet article, nous parlons d'analyseurs qui recherchent des erreurs dans le code.  Il existe une autre classe d'analyseurs - ils v√©rifient le style d'√©criture du code, la complexit√© cyclomatique, la taille des m√©thodes, la longueur des lignes, etc. Nous ne consid√©rons pas de tels analyseurs ici. <br><br>  Bien que tout ce que les analyseurs que nous envisageons ne trouve pas est pr√©cis√©ment une erreur.  Par erreur, je veux dire le code que Fatal cr√©era en production.  Tr√®s souvent, ce que les analyseurs trouvent est plus probablement une inexactitude.  Par exemple, un type de param√®tre incorrect peut √™tre sp√©cifi√© dans PHPDoc.  Cette impr√©cision n'affecte pas le fonctionnement du code, mais par la suite le code √©voluera - un autre programmeur peut faire une erreur. <br><br><h1>  Analyseurs de code PHP existants </h1><br>  Il existe trois analyseurs de code PHP populaires: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHPStan</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Psaume</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Phan</a> . <br></li></ol><br>  Et il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exakat</a> , que nous n'avons pas essay√©. <br><br>  C√¥t√© utilisateur, les trois analyseurs sont identiques: vous les installez (tr√®s probablement via Composer), vous les configurez, apr√®s quoi vous pouvez d√©marrer l'analyse de l'ensemble du projet ou du groupe de fichiers.  En r√®gle g√©n√©rale, l'analyseur peut magnifiquement afficher les r√©sultats dans la console.  Vous pouvez √©galement g√©n√©rer les r√©sultats au format JSON et les utiliser dans CI. <br><br>  Les trois projets se d√©veloppent d√©sormais activement.  Leurs responsables sont tr√®s actifs pour r√©pondre aux probl√®mes sur GitHub.  Souvent, le premier jour apr√®s avoir cr√©√© un ticket, ils y r√©agissent au moins (commenter ou mettre une balise comme bug / am√©lioration).  De nombreux bugs que nous avons trouv√©s ont √©t√© corrig√©s en quelques jours.  Mais j'aime particuli√®rement le fait que les responsables de projet communiquent activement entre eux, se signalent des bogues et envoient des demandes de tirage. <br><br>  Nous avons impl√©ment√© et utilis√© les trois analyseurs.  Chacun a ses propres nuances, ses propres bugs.  Mais l'utilisation de trois analyseurs en m√™me temps permet de mieux comprendre o√π se situe le vrai probl√®me et o√π se trouve le faux positif. <br><br><h2>  Ce que les analyseurs peuvent faire </h2><br>  Les analyseurs ont de nombreuses fonctionnalit√©s communes, nous allons donc d'abord voir ce qu'ils peuvent tous faire, puis passer aux fonctionnalit√©s de chacun d'eux. <br><br><h3>  Ch√®ques standard </h3><br>  Bien s√ªr, les analyseurs effectuent toutes les v√©rifications de code standard pour le fait que: <br><br><ul><li>  Le code ne contient pas d'erreurs de syntaxe; <br></li><li>  toutes les classes, m√©thodes, fonctions, constantes existent; <br></li><li>  des variables existent; <br></li><li>  en PHPDoc, les indices sont vrais. <br></li></ul><br>  En outre, les analyseurs v√©rifient le code pour les arguments et les variables inutilis√©s.  Beaucoup de ces erreurs conduisent √† de vrais fatals dans le code. <br><br>  √Ä premi√®re vue, il peut sembler que les bons programmeurs ne commettent pas de telles erreurs, mais parfois nous sommes press√©s, parfois copier-coller, parfois nous sommes simplement inattentifs.  Et dans de tels cas, ces contr√¥les √©conomisent beaucoup. <br><br><h3>  V√©rifications des types de donn√©es </h3><br>  Bien entendu, les analyseurs statiques effectuent √©galement des contr√¥les standard concernant les types de donn√©es.  S'il est √©crit dans le code que la fonction accepte, disons int, alors l'analyseur v√©rifiera s'il y a des endroits o√π un objet est pass√© √† cette fonction.  Pour la plupart des analyseurs, vous pouvez configurer la gravit√© du test et simuler strict_types: v√©rifiez qu'aucune cha√Æne ou bool√©en n'est transmis √† cette fonction. <br><br>  En plus des contr√¥les standard, les analyseurs ont encore beaucoup √† faire. <br><br>  <b>Types d'unions</b> <br><br>  Tous les analyseurs prennent en charge le concept de types Union.  Supposons que vous ayez une fonction comme: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_bool($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no;     } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> (is_numeric($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;     } }</code> </pre> <br>  Son contenu n'est pas tr√®s important - le type de la <code>string|int|bool</code> param√®tre d'entr√©e <code>string|int|bool</code> est important.  Autrement dit, la variable <code>$yes_or_no</code> est soit une cha√Æne, soit un entier, soit un <code>Boolean</code> . <br><br>  En utilisant PHP, ce type de param√®tre de fonction ne peut pas √™tre d√©crit.  Mais en PHPDoc, c'est possible, et de nombreux √©diteurs (comme PHPStorm) le comprennent. <br><br>  Dans les analyseurs statiques, ce type est appel√© <b>type d'union</b> et ils sont tr√®s bons pour v√©rifier ces types de donn√©es.  Par exemple, si nous √©crivions la fonction ci-dessus comme ceci (sans v√©rifier le <code>Boolean</code> ): <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_numeric($yes_or_no)) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;    } }</code> </pre> <br>  les analyseurs verraient qu'une cha√Æne ou un bool√©en pourrait arriver √† strtoupper et retourner une erreur - vous ne pouvez pas passer un bool√©en √† strtoupper. <br><br>  Ce type de v√©rification aide les programmeurs √† g√©rer correctement les erreurs ou les situations o√π une fonction ne peut pas renvoyer de donn√©es.  Nous √©crivons souvent des fonctions qui peuvent renvoyer certaines donn√©es ou <code>null</code> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load()  null   \User $User = UserLoader::load($user_id); $User-&gt;getName();</span></span></code> </pre> <br>  Dans le cas d'un tel code, l'analyseur vous dira que la variable <code>$User</code> ici peut √™tre <code>null</code> et que ce code peut entra√Æner la mort. <br><br>  <b>Tapez false</b> <br><br>  Dans le langage PHP lui-m√™me, il existe de nombreuses fonctions qui peuvent renvoyer une valeur ou une valeur fausse.  Si nous devions √©crire une telle fonction, comment documenterions-nous son type? <br><br><pre> <code class="php hljs">         <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> resource|bool */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{       ‚Ä¶ }</code> </pre> <br>  Formellement, tout semble √™tre vrai ici: fopen renvoie soit une ressource soit une <code>false</code> (qui est de type <code>Boolean</code> ).  Mais lorsque nous disons qu'une fonction renvoie une sorte de type de donn√©es, cela signifie qu'elle peut renvoyer <b>n'importe quelle</b> valeur d'un ensemble appartenant √† ce type de donn√©es.  Dans notre exemple, pour l'analyseur, cela signifie que <code>fopen()</code> peut retourner <code>true</code> .  Et, par exemple, dans le cas d'un tel code: <br><br><pre> <code class="php hljs">$fp = fopen(<span class="hljs-string"><span class="hljs-string">'some.file'</span></span>,<span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($fp === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } fwrite($fp, <span class="hljs-string"><span class="hljs-string">"some string"</span></span>);</code> </pre> <br>  les analyseurs se plaindraient que <code>fwrite</code> accepte la premi√®re ressource de param√®tre, et nous lui passons <code>bool</code> (car l'analyseur voit qu'une vraie option est possible).  Pour cette raison, tous les analyseurs <code>@return false|resource</code> un type de donn√©es ¬´artificiel¬ª comme <code>false</code> , et dans notre exemple, nous pouvons √©crire <code>@return false|resource</code> .  PHPStorm comprend √©galement cette description de type. <br><br>  <b>Formes de tableau</b> <br><br>  Tr√®s souvent, les tableaux en PHP sont utilis√©s comme type d' <code>record</code> - une structure avec une liste claire de champs, o√π chaque champ a son propre type.  Bien s√ªr, de nombreux programmeurs utilisent d√©j√† des classes pour cela.  Mais nous avons beaucoup de code h√©rit√© dans Badoo, et les tableaux y sont activement utilis√©s.  Et il arrive √©galement que les programmeurs soient trop paresseux pour cr√©er une classe distincte pour une structure unique, et dans de tels endroits, les tableaux sont √©galement souvent utilis√©s. <br><br>  Le probl√®me avec de tels tableaux est qu'il n'y a pas de description claire de cette structure (une liste de champs et leurs types) dans le code.  Les programmeurs peuvent commettre des erreurs lorsqu'ils travaillent avec une telle structure: oubliez les champs obligatoires ou ajoutez des touches ¬´gauche¬ª, ce qui rend le code encore plus confus. <br><br>  Les analyseurs vous permettent d'entrer une description de ces structures: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Dans cet exemple, nous avons d√©crit un tableau avec trois champs de cha√Æne: <code>scheme, host</code> et <code>path</code> .  Si √† l'int√©rieur de la fonction nous nous tournons vers un autre champ, l'analyseur affichera une erreur. <br><br>  Si vous ne d√©crivez pas les types, les analyseurs essaieront de ¬´deviner¬ª la structure du tableau, mais, comme le montre la pratique, ils ne r√©ussissent pas vraiment avec notre code.  :) <br><br>  Cette approche pr√©sente un inconv√©nient.  Supposons que vous ayez une structure activement utilis√©e dans le code.  Vous ne pouvez pas d√©clarer un pseudotype en un seul endroit et l'utiliser ensuite partout.  Vous devrez enregistrer PHPDoc avec la description du tableau partout dans le code, ce qui est tr√®s g√™nant, surtout s'il y a beaucoup de champs dans le tableau.  Il sera √©galement probl√©matique de modifier ce type ult√©rieurement (ajouter et supprimer des champs). <br><br>  <b>Description des types de cl√©s de tableau</b> <br><br>  En PHP, les cl√©s de tableau peuvent √™tre des entiers et des cha√Ænes.  Les types peuvent parfois √™tre importants pour l'analyse statique (et pour les programmeurs √©galement).  Les analyseurs statiques vous permettent de d√©crire les cl√©s de tableau en PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;int, \User&gt; $users */</span></span> $users = UserLoaders::loadUsers($user_ids);</code> </pre> <br>  Dans cet exemple, en utilisant PHPDoc, nous avons ajout√© un indice selon lequel dans le tableau <code>$users</code> les cl√©s sont des entiers et les valeurs sont des objets de la classe <code>\User</code> .  Nous pourrions d√©crire le type comme \ User [].  Cela indiquerait √† l'analyseur qu'il y a des objets dans la classe <code>\User</code> du tableau, mais ne nous dirait rien sur le type de cl√©s. <br><br>  PHPStorm prend en charge ce format pour d√©crire les tableaux √† partir de la version 2018.3. <br><br>  <b>Votre espace de noms en PHPDoc</b> <br><br>  PHPStorm (et d'autres √©diteurs) et les analyseurs statiques peuvent comprendre PHPDoc diff√©remment.  Par exemple, les analyseurs prennent en charge ce format: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Mais PHPStorm ne le comprend pas.  Mais nous pouvons √©crire comme ceci: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@phan</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Dans ce cas, les analyseurs et PHPStorm seront satisfaits.  PHPStorm utilisera <code>@param</code> et les analyseurs utiliseront leurs propres balises PHPDoc. <br><br><h3>  V√©rifications des fonctionnalit√©s PHP </h3><br>  Ce type de test est mieux illustr√© par l'exemple. <br><br>  Savons-nous tous ce que la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">explode ()</a> peut renvoyer?  Si vous regardez la documentation, il semble qu'elle renvoie un tableau.  Mais si vous l'examinez plus attentivement, nous verrons qu'il peut aussi retourner faux.  En fait, il peut renvoyer √† la fois null et une erreur si vous lui transmettez les mauvais types, mais passer la mauvaise valeur avec le mauvais type de donn√©es est d√©j√† une erreur, donc cette option n'est plus int√©ressante pour nous maintenant. <br><br>  Formellement, du point de vue de l'analyseur, si une fonction peut retourner false ou un tableau, alors, tr√®s probablement, le code devrait v√©rifier false.  Mais la fonction explode () ne renvoie false que si le d√©limiteur (premier param√®tre) est √©gal √† une cha√Æne vide.  Souvent, il est explicitement √©crit dans le code, et les analyseurs peuvent v√©rifier qu'il n'est pas vide, ce qui signifie qu'√† cet endroit la fonction explode () renvoie avec pr√©cision un tableau et qu'une fausse v√©rification n'est pas n√©cessaire. <br><br>  PHP a quelques fonctionnalit√©s.  Les analyseurs ajoutent progressivement des v√©rifications appropri√©es ou les am√©liorent, et nous, les programmeurs, n'avons plus besoin de m√©moriser toutes ces fonctionnalit√©s. <br><br>  Nous passons √† la description d'analyseurs sp√©cifiques. <br><br><h2>  PHPStan </h2><br>  D√©veloppement d'un certain Ond≈ôej Mirtes de la R√©publique tch√®que.  D√©velopp√© activement depuis fin 2016. <br><br>  Pour commencer √† utiliser PHPStan, vous devez: <br><br><ol><li>  Installez-le (la fa√ßon la plus simple de le faire est via Composer). <br></li><li>  (facultatif) Configurez. <br></li><li>  Dans le cas le plus simple, lancez simplement: <br></li></ol><br> <code>vendor/bin/phpstan analyse ./src</code> <br> <br>  (au lieu de <code>src</code> peut <code>src</code> avoir une liste de fichiers sp√©cifiques que vous souhaitez v√©rifier). <br><br>  PHPStan lira le code PHP des fichiers transf√©r√©s.  S'il rencontre des classes inconnues, il essaiera de les charger avec le chargement automatique et par r√©flexion pour comprendre leur interface.  Vous pouvez √©galement transf√©rer le chemin d'acc√®s au fichier <code>Bootstrap</code> √† travers lequel vous configurez le chargement automatique et joindre des fichiers suppl√©mentaires pour simplifier l'analyse PHPStan. <br><br>  Caract√©ristiques cl√©s: <br><br><ol><li>  Il est possible d'analyser non pas la totalit√© de la base de code, mais seulement une partie - des classes inconnues PHPStan tentera de charger le chargement automatique. <br></li><li>  Si, pour une raison quelconque, certaines de vos classes ne sont pas dans le chargement automatique, PHPStan ne pourra pas les trouver et donnera une erreur. <br></li><li>  Si vous utilisez activement des m√©thodes magiques via <code>__call / __get / __set</code> , vous pouvez √©crire un plugin pour PHPStan.  Des plugins pour Symfony, Doctrine, Laravel, Mockery, etc. existent d√©j√†. <br></li><li>  En fait, PHPStan effectue le chargement automatique non seulement pour les classes inconnues, mais en g√©n√©ral pour tout le monde.  Nous avons beaucoup d'ancien code √©crit avant l'apparition des classes anonymes, lorsque nous cr√©ons une classe dans un fichier, puis l'instancions instantan√©ment et, √©ventuellement, appelons m√™me certaines m√©thodes.  Le chargement automatique ( <code>include</code> ) de ces fichiers entra√Æne des erreurs, car le code n'est pas ex√©cut√© dans un environnement normal. <br></li><li>  Configs au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n√©on</a> (je n'ai jamais entendu dire qu'un tel format √©tait utilis√© ailleurs). <br></li><li>  Il n'y a pas de support pour leurs balises PHPDoc comme <code>@phpstan-var, @phpstan-return</code> , etc. <br></li></ol><br>  Une autre caract√©ristique est que les erreurs ont du texte, mais il n'y a pas de type.  Autrement dit, le texte d'erreur vous est renvoy√©, par exemple: <br><br><ul><li> <code>Method \SomeClass::getAge() should return int but returns int|null</code> <br> </li><li> <code>Method \SomeOtherClass::getName() should return string but returns string|null</code> <br> </li></ul><br>  Dans cet exemple, les deux erreurs concernent essentiellement la m√™me chose: la m√©thode doit renvoyer un type, mais en r√©alit√©, elle renvoie l'autre.  Mais les textes des erreurs sont diff√©rents, bien que similaires.  Par cons√©quent, si vous souhaitez filtrer les erreurs dans PHPStan, ne le faites que par le biais d'expressions r√©guli√®res. <br><br>  √Ä titre de comparaison, dans d'autres analyseurs, les erreurs ont un type.  Par exemple, dans Phan, une telle erreur est de type <code>PhanPossiblyNullTypeReturn</code> , et vous pouvez sp√©cifier dans la configuration que vous n'avez pas besoin de v√©rifier ces erreurs.  De plus, ayant le type d'erreur, il est possible, par exemple, de collecter facilement des statistiques sur les erreurs. <br><br>  Comme nous n'utilisons pas Laravel, Symfony, Doctrine et des solutions similaires, et que nous utilisons rarement des m√©thodes magiques dans notre code, la principale caract√©ristique de PHPStan s'est av√©r√©e non r√©clam√©e pour nous.  ; (De plus, du fait que PHPStan inclut <b>toutes</b> les classes en cours de v√©rification, parfois son analyse ne fonctionne tout simplement pas sur notre base de code. <br><br>  Cependant, PHPStan nous reste utile: <br><br><ul><li>  Si vous devez v√©rifier plusieurs fichiers, PHPStan est sensiblement plus rapide que Phan et un peu (20-50%) plus rapide que Psalm. <br></li><li>  Les rapports PHPStan facilitent la recherche de <code>false-positive</code> dans d'autres analyseurs.  Habituellement, s'il y a un <code>fatal</code> explicite dans le code, il est affich√© par tous les analyseurs (ou au moins deux des trois). <br></li></ul><br><br>  <b>Mise √† jour:</b> <br>  L'auteur de PHPStan Ond≈ôej Mirtes a √©galement lu notre article et nous a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit</a> que PhpStan, comme Psaume, a un site Web avec un ¬´bac √† sable¬ª: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://phpstan.org/</a> .  C'est tr√®s pratique pour les rapports de bogues: vous reproduisez l'erreur dans et donnez un lien dans GitHub. <br><br><h2>  Phan </h2><br>  D√©velopp√© par Etsy.  Commet d'abord de Rasmus Lerdorf. <br><br>  Des trois en question, Phan est le seul <b>v√©ritable</b> analyseur statique (dans le sens o√π il n'ex√©cute aucun de vos fichiers - il analyse l' <b>int√©gralit√© de</b> votre base de code, puis analyse ce que vous dites).  M√™me pour analyser plusieurs fichiers dans notre base de code, il a besoin d'environ 6 Go de RAM, et ce processus prend de quatre √† cinq minutes.  Mais une analyse compl√®te de la base de code enti√®re prend environ six √† sept minutes.  A titre de comparaison, le Psaume l'analyse en quelques dizaines de minutes.  Et √† partir de PHPStan, nous n'avons pas √©t√© en mesure de r√©aliser une analyse compl√®te de l'int√©gralit√© de la base de code car elle comprend des classes d'inclusion. <br><br>  L'exp√©rience Phan est double.  D'une part, c'est l'analyseur le plus stable et de haute qualit√©, il en trouve beaucoup et il y a moins de probl√®mes avec lui quand il est n√©cessaire d'analyser toute la base de code.  En revanche, il pr√©sente deux caract√©ristiques d√©sagr√©ables. <br><br>  Sous le capot, Phan utilise l'extension php-ast.  Apparemment, c'est l'une des raisons pour lesquelles l'analyse de la base de code enti√®re est relativement rapide.  Mais php-ast montre la repr√©sentation interne de l'arbre AST telle qu'elle appara√Æt en PHP lui-m√™me.  Et en PHP lui-m√™me, l'arborescence AST ne contient pas d'informations sur les commentaires qui se trouvent √† l'int√©rieur de la fonction.  Autrement dit, si vous avez √©crit quelque chose comme: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $type */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($type)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \My\Object $obj **/</span></span>   $obj = MyFactory::createObjectByType($type);   ‚Ä¶ }</code> </pre> <br>  puis √† l'int√©rieur de l'arborescence AST, il y a des informations sur le PHPDoc externe pour la fonction <code>doSomething()</code> , mais il n'y a aucune information d'aide PHPDoc √† l'int√©rieur de la fonction.  Et, en cons√©quence, Phan ne sait rien d'elle non plus.  Il s'agit de la cause la plus courante de <code>false-positive</code> √† Phan.  Il existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quelques recommandations</a> sur la fa√ßon d'ins√©rer des info-bulles (via des cha√Ænes ou des assert-s), mais, malheureusement, elles sont tr√®s diff√©rentes de ce √† quoi nos programmeurs sont habitu√©s.  En partie, nous avons r√©solu ce probl√®me en √©crivant un plugin pour Phan.  Mais les plugins seront discut√©s ci-dessous. <br><br>  La deuxi√®me caract√©ristique d√©sagr√©able est que Phan n'analyse pas bien les propri√©t√©s des objets.  Voici un exemple: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|null */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $a = null)</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a = $a; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a &amp;&amp; strpos(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) === <span class="hljs-number"><span class="hljs-number">0</span></span>) {          var_dump(<span class="hljs-string"><span class="hljs-string">"test1"</span></span>);      } } }</code> </pre> <br>  Dans cet exemple, Phan vous dira qu'en strpos, vous pouvez passer null.  Vous pouvez en savoir plus sur ce probl√®me ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/phan/phan/issues/204</a> . <br><br>  R√©sum√©  Malgr√© quelques difficult√©s, Phan est un d√©veloppement tr√®s cool et utile.  En plus de ces deux types de <code>false-positive</code> , il ne fait presque pas d'erreurs, ou fait des erreurs, mais sur un code vraiment complexe.  Nous avons √©galement aim√© que la configuration soit dans un fichier PHP - cela donne une certaine flexibilit√©.  Phan sait √©galement travailler en tant que serveur de langue, mais nous n'avons pas utilis√© cette fonctionnalit√©, car PHPStorm nous suffit. <br><br><h3>  Plugins </h3><br>  Phan poss√®de une API de d√©veloppement de plugins bien d√©velopp√©e.  Vous pouvez ajouter vos propres v√©rifications, am√©liorer l'inf√©rence de type pour votre code.  Cette API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contient de la documentation</a> , mais c'est particuli√®rement cool qu'il y ait d√©j√† des plugins qui fonctionnent et qui peuvent √™tre utilis√©s comme exemples. <br><br>  Nous avons r√©ussi √† √©crire deux plugins.  Le premier √©tait destin√© √† un contr√¥le unique.  Nous voulions √©valuer dans quelle mesure notre code est pr√™t pour PHP 7.3 (en particulier, pour savoir s'il a <code>case-insensitive</code> constantes <code>case-insensitive</code> √† la <code>case-insensitive</code> ).  Nous √©tions presque s√ªrs qu'il n'y avait pas de telles constantes, mais tout pouvait arriver en 12 ans - cela devrait √™tre v√©rifi√©.  Et nous avons √©crit un plugin pour Phan qui jurerait si le troisi√®me param√®tre √©tait utilis√© dans <code>define()</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Le plugin est tr√®s simple</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span>(strict_types=<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">AST</span></span>\<span class="hljs-title"><span class="hljs-title">ContextNode</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">CodeBase</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Element</span></span>\<span class="hljs-title"><span class="hljs-title">Func</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>\<span class="hljs-title"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">ast</span></span>\<span class="hljs-title"><span class="hljs-title">Node</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefineThirdParamTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PluginV2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnalyzeFunctionCallClosures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $code_base)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{   $define_callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       CodeBase $code_base,                  Context $context,                  Func $function,                  array $args    )</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($args) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }       <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emitIssue(       $code_base,      $context,      <span class="hljs-string"><span class="hljs-string">'PhanDefineCaseInsensitiv'</span></span>,      <span class="hljs-string"><span class="hljs-string">'Define with 3 arguments'</span></span>,      []      );    };    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [          <span class="hljs-string"><span class="hljs-string">'define'</span></span> =&gt; $define_callback,    ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefineThirdParamTrue();</code> </pre> <br></div></div><br><br>  Dans Phan, diff√©rents plugins peuvent √™tre suspendus sur diff√©rents √©v√©nements.  En particulier, les plugins avec l'interface <code>AnalyzeFunctionCallCapability</code> d√©clench√©s lorsqu'un appel de fonction est analys√©.  Dans ce plugin, nous avons fait en sorte que lorsque nous appelons la fonction <code>define()</code> , notre fonction anonyme soit appel√©e, qui v√©rifie que <code>define()</code> pas plus de deux arguments.  Ensuite, nous avons juste commenc√© Phan, trouv√© tous les endroits o√π <code>define()</code> √©t√© appel√© avec trois arguments, et nous nous sommes assur√©s que nous n'avions pas de <code>case-insensitive-</code> . <br><br>  En utilisant le plugin, nous avons √©galement partiellement r√©solu le probl√®me des <code>false-positive</code> lorsque Phan ne voit pas d'indices PHPDoc dans le code. <br><br>  Nous utilisons souvent des m√©thodes d'usine qui prennent une constante en entr√©e et en cr√©ent un objet.  Souvent, le code ressemble √† ceci: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Objects\Controllers\My $Object */</span></span> $Object = \Objects\Factory::create(\Objects\Config::MY_CONTROLLER);</code> </pre> <br>  Phan ne comprend pas ces conseils PHPDoc, mais dans ce code, la classe d'objet peut √™tre obtenue √† partir du nom de la constante pass√©e √† la m√©thode <code>create()</code> .  Phan vous permet d'√©crire un plugin qui se d√©clenche lorsqu'il analyse la valeur de retour d'une fonction.  Et avec ce plugin, vous pouvez dire √† l'analyseur quel type la fonction retourne dans cet appel. <br><br>  Un exemple de ce plugin est plus complexe.  Mais il y a un bon exemple dans le code Phan dans <code>vendor/phan/phan/src/Phan/Plugin/Internal/DependentReturnTypeOverridePlugin.php.</code> <br><br>  Dans l'ensemble, nous sommes tr√®s satisfaits de l'analyseur Phan.  Les <code>false-positive</code> list√©s ci-dessus nous ont partiellement appris (dans des cas simples, avec du code simple) √† filtrer.  Apr√®s cela, Phan est devenu un analyseur presque de r√©f√©rence.  Cependant, la n√©cessit√© d'analyser imm√©diatement toute la base de code (temps et beaucoup de m√©moire) complique toujours le processus de sa mise en ≈ìuvre. <br><br><h2>  Psaume </h2><br>  Psalm est un d√©veloppement de Vimeo.  Honn√™tement, je ne savais m√™me pas que Vimeo utilise PHP avant d'avoir vu Psaume. <br><br>  Cet analyseur est le plus jeune de nos trois.  Quand j'ai lu la nouvelle que Vimeo avait sorti Psalm, j'√©tais perplexe: "Pourquoi investir dans Psalm si vous avez d√©j√† Phan et PHPStan?"  Mais il s'est av√©r√© que le Psaume a ses propres caract√©ristiques utiles. <br><br>  Le psaume a suivi les traces de PHPStan: vous pouvez √©galement lui donner une liste de fichiers √† analyser, et il les analysera, et connectera les classes qui ne sont pas trouv√©es avec un chargement automatique.  Dans le m√™me temps, il <b>ne</b> connecte que les classes qui n'ont pas √©t√© trouv√©es, et les fichiers que nous avons demand√©s pour l'analyse ne seront pas inclus (c'est diff√©rent de PHPStan).  La configuration est stock√©e dans un fichier XML (pour nous, c'est probablement un inconv√©nient, mais pas tr√®s critique). <br><br>  Psaume a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site en</a> bac √† sable o√π vous pouvez √©crire du code PHP et l'analyser.  C'est tr√®s pratique pour les rapports de bugs: vous reproduisez l'erreur sur le site et donnez le lien dans GitHub.  Et d'ailleurs, le site d√©crit tous les types d'erreurs possibles.  A titre de comparaison: dans PHPStan, les erreurs n'ont pas de types, et dans Phan elles le sont, mais il n'y a pas de liste unique qui puisse √™tre trouv√©e. <br><br>  Nous avons √©galement aim√© que lors de la sortie des erreurs, Psaume affiche imm√©diatement les lignes de code o√π elles ont √©t√© trouv√©es.  Cela simplifie <b>consid√©rablement la</b> lecture des rapports. <br><br>  Mais la caract√©ristique la plus int√©ressante de Psalm est peut-√™tre ses balises PHPDoc personnalis√©es, qui vous permettent d'am√©liorer l'analyse (en particulier la d√©finition des types).  Nous listons les plus int√©ressants d'entre eux. <br><br><h3>  @ psalm-ignore-nullable-return </h3><br>  Il arrive que formellement une m√©thode puisse retourner <code>null</code> , mais le code est d√©j√† organis√© de telle mani√®re que cela n'arrive jamais.  Dans ce cas, il est tr√®s pratique que vous puissiez ajouter un tel indice PHPDoc √† la m√©thode / fonction - et Psaume consid√©rera que <code>null</code> pas retourn√©. <br><br>  Un indice similaire existe pour false: <code>@psalm-ignore-falsable-return</code> . <br><br><h3>  Types de fermeture </h3><br>  Si vous vous √™tes d√©j√† int√©ress√© √† la programmation fonctionnelle, vous avez peut-√™tre remarqu√© qu'une fonction peut souvent renvoyer une autre fonction ou prendre une fonction en param√®tre.  En PHP, ce style peut √™tre tr√®s d√©routant pour vos coll√®gues, et l'une des raisons est que PHP n'a pas de normes pour documenter de telles fonctions.  Par exemple: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Comment un programmeur peut-il comprendre l'interface de la fonction dans le deuxi√®me param√®tre?  Quels param√®tres faut-il prendre?  Que doit-elle retourner? <br><br>  Psaume prend en charge la syntaxe pour d√©crire les fonctions en PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $ar * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param Closure(int):bool $func */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Avec une telle description, il est d√©j√† clair que vous devez passer une fonction anonyme √† <code>my_filter</code> , qui acceptera un int et renverra bool.  Et, bien s√ªr, le Psaume v√©rifiera que vous avez exactement une telle fonction pass√©e dans votre code. <br><br><h3>  Enums </h3><br>  Supposons que vous ayez une fonction qui accepte un param√®tre de cha√Æne et que vous ne puissiez y passer que certaines cha√Ænes: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{     $yes_or_no = strtolower($yes_or_no)     <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>($yes_or_no)  {           <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'yes'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;          <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'no'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;           <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:                <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \InvalidArgumentException(‚Ä¶);     } }</code> </pre><br>  Le psaume vous permet de d√©crire le param√®tre de cette fonction comme ceci: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param 'Yes'|'No' $yes_or_no **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Dans ce cas, le Psaume essaiera de comprendre quelles valeurs sp√©cifiques sont transmises √† cette fonction et g√©n√©rera des erreurs s'il existe des valeurs autres que <code>Yes</code> et <code>No</code> <br><br>  En savoir plus sur enum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  Tapez les alias </h3><br>  Plus t√¥t dans la description des <code>array shapes</code> de <code>array shapes</code> j'ai mentionn√© que bien que les analyseurs vous permettent de d√©crire la structure des tableaux, il n'est pas tr√®s pratique de l'utiliser, car la description du tableau doit √™tre copi√©e √† diff√©rents endroits.  La bonne solution, bien s√ªr, consiste √† utiliser des classes au lieu de tableaux.  Mais dans le cas de nombreuses ann√©es d'h√©ritage, ce n'est pas toujours possible. <br><br>   ,      ,    ,    : <br><br><ul><li> ; <br></li><li> closure; <br></li><li> union- (,       ); <br></li><li> enum. <br></li></ul><br>   ,      ,    PHPDoc    , ,  .   Psalm      .    alias      PHPDoc   <code>alias</code> .  ,  :      PHP-.      . ,   Psalm. <br><br><h3> Generics aka templates </h3><br>     . ,     : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $x; }</code> </pre> <br>     ?      ?   ? <br><br> , ,    , ‚Äî <code>mixed</code> ,             . <br><br>     <code>mixed</code> ‚Äî  .  ,            .    ,   <code>identity()</code>  /  ,    :     ,   .       -.  ,   : <br><br><pre> <code class="php hljs">$i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int $y = identity($i);</span></span></code> </pre> <br>       <code>(int)</code> ,  ,      <code>$y</code> ( <code>int</code> ). <br><br>       ?  Psalm     PHPDoc-: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param T $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return T */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ $return $x; }</code> </pre> <br>   templates   Psalm   ,  /     . <br><br>  Psalm      templates: <br><br> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericFunctions.php</a> ; <br> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericClasses.php</a> . <br><br>      Phan,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/phan/phan/wiki/Generic-Types</a> . <br><br>  ,  Psalm  . ,    ¬´¬ª              .   ,  Psalm    ,    ,       Phan  PHPStan.     . <br><br><h2>    PHPStorm </h2><br>      :          ,   .    ,      ,    . <br><br>             .     Phan,    language server.    PHPStorm, ,   . <br><br> ,  ,  PHPStorm     ( ),       .         ‚Äî Php Inspections (EA Extended).     ‚Äî   ,   ,         .  ,      . ,      scopes     -   scopes. <br><br>     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deep-assoc-completion</a> .         . <br><br><h1>    Badoo </h1><br>     ? <br><br>       ,         . <br><br>     ,   .  ,     ,    <code>git diff</code>      / ,       ,     () .       ,    . <br><br> ,     :      -    <code>git diff</code> .     .             ,    .         . , ,  ,          ,    . <br><br>     ,     ,       : <br><br><img src="https://habrastorage.org/webt/zj/e2/rt/zje2rtxhy1nkwsamex4umguv4yw.png"><br><br>           <code>false-positive</code> . ,  ,   Phan        ,   ,     . ,   -    Phan      ,     ,      . <br><br><h1>     QA </h1><br>        : <br><br><ul><li>     ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code review</a> ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . <br></li></ul><br><br>   ‚Äî ,  ,      ,     .      : <br><br><ul><li>    100%  (   ,        ); <br></li><li>     ,      code review; <br></li><li>      ,        . <br></li></ul><br>         <code>strict types</code> .          ,  <code>strict types</code> ,    : <br><br><ul><li>     ,     <code>strict types</code> ,   ; <br></li><li>     ,     (,    ,        ); <br></li><li>        ,    PHP (,   <code>union types</code> ,    PHP); <br></li><li>       <code>strict types</code> ,        . <br></li></ul><br><h1>  :   </h1><br>  ,        .   . <br><br> -,     , ,      -  ,    . <br><br> -,     ,     ‚Äî  , ,     PHPDoc.        ‚Äî   . <br><br> -,     .  ,     -  ,            PHPDoc.  :) <br><br>  ,  ,     .    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426605/">https://habr.com/ru/post/fr426605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426591/index.html">Posture Master: Restez en vie</a></li>
<li><a href="../fr426593/index.html">DJI Phantom 4 RTK: cartographie de nouvelle g√©n√©ration</a></li>
<li><a href="../fr426595/index.html">Richard Hamming ¬´Chapitre inexistant¬ª: Comme nous savons ce que nous savons (1-10 minutes sur 40)</a></li>
<li><a href="../fr426597/index.html">Madrobots √† l'IFA 2018. Partie 2 - Projecteurs intelligents: de XGIMI √† Anker</a></li>
<li><a href="../fr426603/index.html">Spirale en rotation: math√©matiques et hallucinations</a></li>
<li><a href="../fr426609/index.html">Office 365 et d'autres produits MS ajouteront des E / S vocales pour les dyslexiques</a></li>
<li><a href="../fr426611/index.html">Int√©gration avec SAP ERP, en utilisant Django-python comme exemple, en utilisant le protocole oData (rest)</a></li>
<li><a href="../fr426613/index.html">Ne laissez pas l'imprimante 3D paresseuse</a></li>
<li><a href="../fr426615/index.html">√âcriture d'une CLI sur NodeJS</a></li>
<li><a href="../fr426617/index.html">Permis de conduire une voiture ou pourquoi les applications doivent √™tre √† activit√© unique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>