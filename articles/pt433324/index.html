<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🚒 👨🏾‍🎤 🀄️ Coletando o pacote de sonhos com o Webpack 👎🏾 👩🏿‍⚖️ 🌒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplicativos JS, sites e outros recursos estão se tornando mais complexos e as ferramentas de construção são a realidade do desenvolvimento da web. Os ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Coletando o pacote de sonhos com o Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433324/">  Aplicativos JS, sites e outros recursos estão se tornando mais complexos e as ferramentas de construção são a realidade do desenvolvimento da web.  Os empacotadores ajudam a empacotar, compilar e organizar bibliotecas.  Uma das ferramentas de código aberto poderosas e flexíveis que podem ser perfeitamente personalizadas para criar o aplicativo cliente é o Webpack. <br><br>  Maxim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Sosnov</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">crazymax11</a> ) - O líder de front-end no N1.RU introduziu o Webpack em vários projetos grandes que anteriormente tinham sua própria criação personalizada e contribuiu com vários projetos.  Maxim sabe como criar um pacote de sonhos com o Webpack, fazê-lo rapidamente e configurá-lo para que a configuração permaneça limpa, mantida e modular. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4ClK_0fxsVM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A interpretação é diferente do relatório - é uma versão bastante aprimorada dos links de prof.  Ao longo da transcrição, os ovos de Páscoa são espalhados em artigos, plugins, minifiers, opções, transpilers e provas das palavras do orador, links para os quais simplesmente não podem ser colocados em um discurso.  Se você coletar tudo, o nível de bônus no Webpack será aberto :-) <br><a name="habracut"></a><br><h2>  Integração do Webpack em um projeto típico </h2><br>  Geralmente, o procedimento de implementação é o seguinte: o desenvolvedor, em algum lugar, lê um artigo sobre o Webpack, decide conectá-lo, começa a construí-lo, de alguma forma funciona, tudo começa e por algum tempo o webpack-config funciona - por seis meses, um ano, dois.  Localmente, está tudo bem - o sol, o arco-íris e as borboletas.  E então usuários reais vêm: <br><br>  <em>- Em dispositivos móveis, seu site não carrega.</em> <em><br></em>  <em>- Tudo funciona para nós.</em>  <em>Localmente, está tudo bem!</em> <br><br>  Por precaução, o desenvolvedor analisa tudo e vê que, para dispositivos móveis, o <strong>pacote pesa 7 MB e leva 30 segundos para carregar</strong> .  Isso não combina com ninguém e o desenvolvedor começa a procurar como resolver o problema - ele pode conectar um carregador ou encontrar um plug-in mágico que resolverá todos os problemas.  Milagrosamente, esse plug-in está localizado.  Nosso desenvolvedor acessa o webpack-config, tenta instalar, mas a linha de código interfere: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { config.module.rules[<span class="hljs-number"><span class="hljs-number">7</span></span>].options.magic = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  A linha é traduzida da seguinte forma: "Se a configuração estiver sendo montada para produção, siga a sétima regra e coloque a opção <code>magic = true</code> ".  O desenvolvedor não sabe o que fazer com isso e como resolvê-lo.  Esta é uma situação em que você precisa de um pacote de sonhos. <br><br><h2>  Como coletar um pacote de sonhos? </h2><br>  Primeiro, vamos definir o que é.  Primeiro de tudo, o pacote dos sonhos tem duas características principais: <br><br><ul><li>  <strong>Pesa um pouco</strong> .  Quanto menor o peso - mais rápido o usuário obterá um aplicativo funcional.  Você não deseja que seu site seja aberto por 15 segundos. </li><li>  O usuário <strong>baixa apenas o que precisa ser</strong> baixado para exibir a página atual do site, e não mais um byte! </li></ul><br>  E para reduzir o tamanho do pacote configurável, você deve primeiro avaliar seu tamanho. <br><br><h3>  Avaliar tamanho do pacote </h3><br>  A solução mais popular é o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WebpackBundleAnalyzer</a> .  Ele coleta estatísticas de criação de aplicativos e renderiza uma página interativa onde você pode ver a localização e o peso de cada módulo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27a/803/6b9/27a8036b994a09b7371c567b6df6cd82.png" alt="imagem"><br><br>  Se isso não for suficiente, você pode criar um <strong>gráfico de dependência</strong> usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outro plug-in</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/900/24a/7c390024a9d902ca99e3d00c0d8081b3.png" alt="imagem"><br><br>  Ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um gráfico de pizza</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/14a/ec4/35014aec45623d06972bca310b3f8edf.png" alt="imagem"><br><br>  Se isso não for suficiente, e você quiser vender o Webpack para profissionais de marketing, poderá <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criar um universo inteiro em</a> que cada ponto seja um módulo, como uma estrela no Universo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a6e/2d2/45ba6e2d2daff144c69df2a43e8ef53a.png" alt="imagem"><br><br>  Existem muitas ferramentas que avaliam o tamanho do pacote e o monitoram.  Há <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma opção na configuração do Webpack</a> que trava a montagem se o pacote pesar muito, por exemplo.  Existe um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-in duplicado-pacote-verificador-webpack-plugin</a> que impedirá a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criação de um</a> pacote se você tiver pacotes de 2 npm de versões diferentes, por exemplo, Lodash 4.15 e Lodash 4.14. <br><br><h3>  Como reduzir o pacote </h3><br><ul><li>  O mais óbvio é conectar o <strong>UglifyJS</strong> para <strong>reduzir</strong> o JavaScript. </li><li>  Use <strong>carregadores e plug-ins especiais</strong> que compactam e otimizam um recurso específico.  Por exemplo, <strong>css-nano</strong> para css ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SVGO</a> , que otimiza o SVG. </li><li>  Compacte todos os arquivos diretamente no Webpack através de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plugins gzip / brotli</a> . </li><li>  Outras ferramentas </li></ul><br>  Agora vamos entender como jogar o excesso do pacote. <br><br><h3>  Jogue fora o excesso </h3><br>  Considere isso em um exemplo popular com <strong>moment.js</strong> : <code>import moment from 'moment'</code> .  Se você pegar um aplicativo vazio, importe moment.js e <strong>ReactDOM</strong> para ele e passe-o pelo <strong>WebpackBundleAnalyzer</strong> , você verá a seguinte imagem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/e0f/833/105e0f8334a83c529077c693fda3d3de.png" alt="imagem"><br><br>  Acontece que quando você adiciona um dia, uma hora a uma data ou apenas deseja colocar o link "em 15 minutos" usando moment.js, você conecta <strong>230 Kbytes de código</strong> !  Por que isso está acontecendo e como é resolvido? <br><br><h4>  Carregamento de local no momento </h4><br>  Há uma função no momento.js que define os códigos de idioma: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> localePath = <span class="hljs-string"><span class="hljs-string">'locale/'</span></span> + locale + <span class="hljs-string"><span class="hljs-string">'.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentLocale = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(localePath); }</code> </pre><br>  Pode ser visto a partir do código que o código do idioma é carregado ao longo do caminho dinâmico, ou seja,  calculado em tempo de execução.  O Webpack age de maneira inteligente e tenta garantir que seu pacote não trava durante a execução do código: ele encontra todos os locais possíveis no projeto e os agrupa.  Portanto, o aplicativo pesa muito. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/4cc/b3f/a034ccb3fc36dd03b916b0bc28acb057.png" alt="imagem"><br><br>  A solução é muito simples - pegamos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">in padrão</a> do Webpack e dizemos: "Se você vê que alguém quer fazer o download de muitos locais, porque não pode determinar qual deles, basta usar o russo!" <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/fe6/e38/587fe6e38333e8b482fed615e3c00ee1.png" alt="imagem"><br><br>  O Webpack aceita apenas o russo e o WebpackBundleAnalyzer mostra 54 Kb, o que já é 200 Kb mais fácil. <br><br><h3>  Eliminação de código morto </h3><br>  A próxima otimização que nos interessa é a <strong>eliminação do código morto</strong> .  Considere o seguinte código. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cond) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; someFunction(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  A maioria das linhas desse código não é necessária no pacote final - o bloco com a condição não será executado, a função após o retorno também.  Tudo que você precisa é <code>return true</code> .  É exatamente isso que a eliminação do código morto é: a ferramenta de construção detecta o código que não pode ser executado e o corta.  Há um recurso interessante que o UglifyJS pode fazer isso. <br><br>  Agora vamos para a mais avançada eliminação de código morto - <strong>método de agitação de árvore</strong> . <br><br><h3>  Árvore tremendo </h3><br>  Digamos que temos um aplicativo que usa o <strong>Lodash</strong> .  Duvido muito que alguém esteja usando o Lodash inteiro.  Provavelmente, várias funções como <strong>get</strong> , <strong>IsEmpty</strong> , <strong>unionBy</strong> ou similares são <strong>exploradas</strong> . <br><br>  Quando fazemos o tremor em árvore, queremos que o Webpack “agite” os módulos desnecessários e jogue-os fora, e só temos os necessários.  Esta é a árvore tremendo. <br><br><h4>  Como o tremido de árvore funciona no Webpack </h4><br>  Digamos que você tenha um código como este: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { a } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./a.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a);</code> </pre><br>  O código é muito simples: de algum módulo, importe a variável a e faça a saída.  Mas existem duas variáveis ​​neste módulo: <strong>a</strong> e <strong>b</strong> .  Não precisamos da variável <b>be</b> queremos removê-la. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Quando o Webpack chega, ele converte o código de importação para isso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(d[<span class="hljs-string"><span class="hljs-string">"a"</span></span>]);</code> </pre><br>  Nossa <code>import</code> transformou em <code>require</code> , mas o <code>console.log</code> não mudou. <br><br>  A dependência do Webpack é convertida no seguinte código: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports[<span class="hljs-string"><span class="hljs-string">"a«] = a; /* unused harmony export b */ var b = 4;</span></span></code> </pre><br><br>  O Webpack saiu da exportação da variável <b>a</b> e removeu a exportação da variável <b>b</b> , mas deixou a própria variável, marcando-a com um comentário especial.  No código convertido, a variável <b>b</b> não <b>é</b> usada e o UglifyJS pode excluí-la. <br><br><blockquote>  A agitação da árvore do Webpack funciona apenas se você tiver algum tipo de minificador de código, como UglifyJS ou <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">babel-minify</a></b> . </blockquote><br>  Vamos considerar casos mais interessantes - quando o tremor em árvore não funciona. <br><br><h4>  Quando Tree Shaking não funciona </h4><br>  Caso nº 1. Você escreve o código: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Execute o código no Webpack e ele permanece o mesmo.  Isso ocorre porque o bundler organiza a agitação da árvore somente se você usar os módulos ES6.  Se você usar os módulos CommonJS, o Tree shake não funcionará. <br><br>  Caso No. 2. Você escreve código com módulos ES6 e nomeou exportações. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Se o seu código for executado através do Babel e você não definiu a opção de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulos como false</a> , o Babel levará seus módulos para o CommonJS e o Webpack não poderá executar novamente o agitação da árvore, porque ele funciona apenas com os módulos ES6. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Portanto, precisamos ter certeza de que ninguém em nosso plano de montagem transsipará os módulos ES6. <br><br>  Caso nº 3. Suponha que tenhamos uma classe tão inútil que não faça nada: <code>export class ShakeMe {}</code> .  Além disso, ainda não o usamos.  Quando o Webpack passa pela importação e exportação, o Babel transforma a classe em uma função e o bundler observa que a função não é usada: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony e[port b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Parece que tudo deve ficar bem, mas se dermos uma olhada mais de perto, veremos que dentro dessa função existe uma variável global <code>babelHelpers</code> , da qual alguma função é chamada.  Este é um <b>efeito colateral</b> : o UglifyJS vê que alguma função global está sendo chamada e não corta o código, porque tem medo de que algo seja interrompido. <br><br>  Quando você escreve classes e as executa no Babel, elas nunca são cortadas.  Como isso é corrigido?  Existe um hack padronizado - adicione um comentário <code>/*#__PURE__*/</code> antes da função: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony export b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-comment"><span class="hljs-comment">/*#__PURE__*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Então o UglifyJS acreditará na palavra que a próxima função é pura.  Felizmente, o <b><a href="">Babel 7</a></b> está fazendo isso agora e, no Babel 6, nada foi removido até o momento. <br><br><blockquote>  Regra: se você tiver um efeito colateral em algum lugar, o UglifyJS não fará nada. </blockquote><br>  Para resumir: <br><br><ul><li>  <b>A trepidação de árvores não funciona para a maioria das bibliotecas do npm</b> , porque todas elas são do CommonJS e são construídas pelo antigo Babel. </li><li>  Provavelmente, o <b>tremor em árvore funcionará adequadamente para as bibliotecas que já estão preparadas para isso</b> , por exemplo, Lodash-es, Date-fns e seu código ou bibliotecas. </li><li>  O UglifyJS está envolvido na montagem. </li><li>  Módulos ES6 usados. </li><li>  Sem efeitos colaterais. </li></ul><br>  Nós descobrimos como reduzir o peso do pacote e agora vamos ensiná-lo a carregar apenas a funcionalidade necessária. <br><br><h3>  Carregamos apenas a funcionalidade necessária </h3><br>  Dividimos essa parte em duas.  Na primeira parte, <b>apenas o código exigido pelo usuário é carregado</b> : se o usuário visitar a página principal do seu site, ele não carregará as páginas da conta pessoal.  No segundo, as <b>alterações no código levam ao menor recarregamento possível de recursos</b> . <br><br><h4>  Carregamos apenas o código necessário </h4><br>  Considere a estrutura de um aplicativo imaginário.  Tem: <br><br><ul><li>  Ponto de entrada - APP. </li><li>  Três páginas: home, pesquisa e cartão. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/872/142/14e/87214214e5fc6514a1a72cb20f6be4b2.png" alt="imagem"><br><br>  O primeiro problema que queremos resolver é <b>emitir um código comum</b> .  Vamos denotar o código vermelho como o código comum para todas as páginas, o círculo verde para a página principal e a página de pesquisa.  Os números restantes não são particularmente importantes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/ec8/80f/854ec880feff7813d267ca834209db71.png" alt="imagem"><br><br>  Quando o usuário acessa a pesquisa na página principal, ele recarrega a caixa e o círculo uma segunda vez, embora ele já os possua.  Idealmente, gostaríamos de ver algo assim. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b75/290/36d/b7529036de4cf6923a279666d00ca297.png" alt="imagem"><br><br>  É bom que o Webpack 4 já tenha um plug-in embutido que faça isso por nós - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SplitChunksPlugin</a> .  O plug-in retira o código do aplicativo ou o código dos módulos do nó, que é usado por vários trechos em um trecho separado, garantindo que o trecho com o código comum seja superior a 30 Kb e para carregar a página, é necessário fazer o download de não mais que 5 trechos.  A estratégia é ideal: carregar blocos muito pequenos não é rentável, e carregar muitos blocos é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://engineering.khanacademy.org/posts/js-packaging-">longo e não é tão eficiente</a> quanto fazer o download de menos blocos, mesmo no http2.  Para repetir esse comportamento em 2 ou 3 versões do Webpack, tive que escrever 20 a 30 linhas com recursos não documentados.  Agora isso está sendo resolvido em uma linha. <br><br><h4>  Takeaway de CSS </h4><br>  Seria ótimo se ainda retirássemos o CSS para cada bloco em um arquivo separado.  Existe uma solução pronta para isso - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mini-Css-Extract-Plugin</a></b> .  O plug-in apareceu apenas no Webpack 4 e, antes dele, não havia soluções adequadas para essa tarefa - apenas hacks, dor e ferimentos nas pernas.  O plug-in <b>remove o CSS de partes assíncronas</b> e foi criado <b>especificamente para esta tarefa</b> , que executa perfeitamente. <br><br><h4>  Recarga mínima possível de recursos </h4><br>  Vamos descobrir como garantir que, ao liberar, por exemplo, um novo bloco promocional na página principal, o usuário <b>recarregue a menor parte possível do código</b> . <br><br>  Se tivéssemos versionamento, tudo ficaria bem.  Aqui temos a página principal da versão N e após o lançamento do bloco promocional - versão N + 1.  O Webpack fornece um mecanismo semelhante imediatamente, usando hash.  Depois que o Webpack coleta todos os ativos, nesse caso, app.js, ele calcula o hash do conteúdo e o adiciona ao nome do arquivo para obter o app. [Hash] .js.  Este é o <b>controle de versão</b> que precisamos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd1/3f2/1a9/fd13f21a9daeddd3a1af9083b8134257.png" alt="imagem"><br><br>  Vamos verificar como funciona.  Ligue os hashes, faça alterações na página principal e veja se o código da página principal realmente mudou.Vamos ver que dois arquivos foram alterados: main e app.js. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a2/bc0/b44/2a2bc0b447b7baf927ac729e28ace633.png" alt="imagem"><br><br>  Por que isso aconteceu, porque é ilógico?  Para entender o porquê, vamos dar uma <b>olhada no app.js.</b>  Consiste em três partes: <br><br><ul><li>  código da aplicação </li><li>  tempo de execução do webpack; </li><li>  links para pedaços assíncronos. </li></ul><br>  Quando alteramos o código principal, o conteúdo e o hash são alterados, o que significa que o <b>link</b> para ele também muda no aplicativo.  O aplicativo em si também mudará e precisa ser reiniciado.  A solução para esse problema é <b>dividir o</b> app.js em dois trechos: código do aplicativo e tempo de execução do webpack e links para trechos assíncronos.  O Webpack 4 faz tudo por nós com uma opção <b>runtimeChunk</b> , que pesa muito pouco - menos de 2 KB em gzip.  A reinicialização para o usuário é praticamente inútil.  RuntimeChunk está ativado com apenas uma opção: <br><br><pre> <code class="javascript hljs">optimization: { <span class="hljs-attr"><span class="hljs-attr">runtimeChunk</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  No Webpack 3 e 2, escreveríamos 5-6 linhas, em vez de uma.  Isso não é muito mais, mas ainda é um inconveniente desnecessário. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e4/125/5d8/6e41255d837ac2a5c4bb8a6e9b74f686.png" alt="imagem"><br><br>  Tudo está ótimo, aprendemos a criar links e tempo de execução!  Vamos escrever um novo módulo no main, liberá-lo e - op!  - agora, em geral, tudo reinicia. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/8f6/a5f/cc78f6a5f6ffcd8b2da956d5463fefc8.png" alt="imagem"><br><br>  Porque  Vamos ver como os módulos funcionam no webpack. <br><br><h4>  Módulos Webpack </h4><br>  Suponha que exista um código no qual você adicione os módulos <b>a</b> , <b>b</b> , <b>d</b> e <b>e</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  O Webpack converte as importações para exigir: <b>a</b> , <b>b</b> , <b>d</b> e <b>e são</b> substituídos por require (0), require (1), require (2) e requere (3). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Imagine uma imagem que acontece com muita frequência: você escreve um novo módulo c <code>import c from 'c';</code>  e cole em algum lugar no meio: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Quando o Webpack processa tudo, converte a importação do novo módulo em require (2): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Os módulos <b>d</b> e <b>e</b> , que eram 2 e 3, receberão os números 3 e 4 - o novo ID.  Uma conclusão simples é a seguinte: usar números de série como id é um pouco tolo, mas o Webpack faz isso. <br><br><blockquote>  Não use o número de série como identificação exclusiva </blockquote><br>  Para corrigir o problema, existe uma solução interna do Webpack - <b>HashedModuleIdsPlugin</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.HashedModuleIdsPlugin({ <span class="hljs-attr"><span class="hljs-attr">hashFunction</span></span>: <span class="hljs-string"><span class="hljs-string">'md4′, hashDigest:'</span></span>base64′, <span class="hljs-attr"><span class="hljs-attr">hashDigestLength</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, }),</code> </pre><br>  Este plug-in usa 4 caracteres de <b>hash md4 em</b> vez de identificação digital do caminho absoluto para o arquivo.  Com isso, nossa exigência se tornará: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'YmRl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'N2Fl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'OWE4′); var d = require('</span></span>NWQz<span class="hljs-string"><span class="hljs-string">'); var e = require('</span></span>YWVj<span class="hljs-string"><span class="hljs-string">');</span></span></code> </pre><br>  Em vez de números, as letras apareceram.  Obviamente, há um problema oculto - é uma <b>colisão de hashes</b> .  Nós deparamos com isso uma vez e podemos aconselhá-lo a usar 8 caracteres em vez de 4. Depois de configurar os hashes corretamente, tudo funcionará da maneira que originalmente queríamos. <br><br>  Agora sabemos como coletar pacotes de sonhos. <br><br><ul><li>  <b>Minify</b> . </li><li>  <b>Use a divisão de código</b> . </li><li>  <b>Configure hashes</b> . </li></ul><br>  Aprendemos a colecionar e agora trabalharemos com velocidade. <br><br><h2>  Como montar um pacote de sonho <b>rapidamente</b> ? </h2><br>  Em nosso N1.RU, o maior aplicativo consiste em 10.000 módulos e, sem otimizações, leva 28 minutos.  Conseguimos acelerar a montagem para dois minutos!  Como fizemos isso?  Existem três maneiras de acelerar qualquer cálculo, e todas as três são aplicáveis ​​ao Webpack. <br><br><h3>  Paralelização de montagem </h3><br>  A primeira coisa que fizemos foi <b>paralelizar a assembléia</b> .  Para isso, temos: <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O HappyPackPlugin</a></b> , que envolve seus carregadores em outros carregadores, e realiza todos os cálculos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">agrupados</a></b> em processos separados.  Isso permite, por exemplo, paralelizar Babel e node-sass. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregador de linha</a></b> .  Executa aproximadamente o mesmo que o HappyPackPlugin, usa não apenas processos, mas o conjunto de encadeamentos.  Alternar para um encadeamento separado é uma operação dispendiosa, use-a com cuidado e somente se você desejar agrupar operações pesadas e que consomem muitos recursos, como babel ou node-sass.  Para carregar o json, por exemplo, a paralelização não é necessária, porque carrega rapidamente. </li><li>  Os plug-ins e carregadores que você usa provavelmente já possuem <b>ferramentas de paralelização integradas</b> - basta olhar.  Por exemplo, esta opção está no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UglifyJS</a> . </li></ul><br><h3>  Armazenando em cache os resultados da construção </h3><br>  <b>O armazenamento em cache dos resultados da montagem</b> é a maneira mais eficiente de acelerar a montagem do Webpack. <br><br>  A primeira solução que temos é o <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cache-loader</a></b> .  Este é um carregador que entra em uma cadeia de carregadores e salva o resultado da construção de um arquivo específico para uma cadeia específica de carregadores no sistema de arquivos.  Na próxima montagem do pacote configurável, se esse arquivo estiver no sistema de arquivos e já tiver sido processado com essa cadeia, o cache-loader receberá os resultados e não chamará os carregadores que estão por trás deles, por exemplo, Babel-loader ou node-sass. <br><br>  O gráfico mostra o tempo de montagem.  Barra azul - 100% de tempo de compilação, sem cache-loader e com ela - 7% mais lento.  Isso ocorre porque o carregador de cache gasta um tempo extra salvando caches no sistema de arquivos.  Já na segunda montagem, recebemos um lucro tangível - a montagem foi duas vezes mais rápida. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bc/e73/210/6bce732104fda8263464528d91d1a8a1.png" alt="imagem"><br><br>  A segunda solução é mais <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sofisticada</a></b> - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HardSourcePlugin</a></b> .  A principal diferença: o cache-loader é apenas um carregador que pode operar apenas em uma cadeia de carregadores com código ou arquivos, e o HardSourcePlugin tem acesso quase total ao ecossistema Webpack, pode operar com outros plugins e carregadores e amplia o ecossistema para armazenar um pouco em cache.  O gráfico acima mostra que, no primeiro lançamento, o tempo de criação aumentou 37%, mas no segundo lançamento com todos os caches, aceleramos 5 vezes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb6/acf/d36/cb6acfd36adbaaadffd68af19889f960.png" alt="imagem"><br><br>  A melhor parte é que você pode usar as duas soluções juntas, o que fazemos no N1.RU.  Tenha cuidado, porque há problemas com caches, que discutirei um pouco mais adiante. <br><br>  Os plugins / carregadores que você já usa podem ter <b>mecanismos de cache internos</b> .  Por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">babel-loader possui um</a> sistema de cache muito eficiente, mas por algum motivo está desativado por padrão.  A mesma funcionalidade está no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregador de scripts do tipo impressionante</a> .  O plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UglifyJS</a> também possui armazenamento em cache, o que funciona muito bem.  Ele nos acelerou por vários minutos. <br><br>  E agora os problemas. <br><br><h4>  Problemas de armazenamento em cache </h4><br><ul><li>  O cache pode <b>não ser validado corretamente</b> . </li><li>  As soluções aplicadas podem <b>não funcionar com plug-ins, carregadores, seu código ou entre si</b> .  Nesse sentido, o cache-loader é uma solução simples e sem complicações.  Mas com o HardSourcePlugin, você precisa ter mais cuidado. </li><li>  <b>É difícil estrear se tudo estiver quebrado</b> .  Quando o cache não funciona corretamente e ocorre um erro incompreensível, será muito difícil descobrir qual é o problema. </li></ul><br><h3>  Como economizar na produção? </h3><br>  A última maneira de acelerar um processo é não fazer parte do processo.  Vamos pensar em como você pode economizar na produção?  O que não podemos fazer?  A resposta é curta - <b>não podemos fazer nada</b> !  Não temos o direito de recusar algo na produção, mas podemos economizar muito no desenvolvimento. <br><br>  Em que economizar: <br><br><ul><li>  <b>Não colete o mapa de origem</b> até precisarmos deles. </li><li>  <b>Use o style-loader em</b> vez de um esquema interessante com remoção e processamento de css através de css loaders.  O carregador de estilos em si é muito rápido, porque pega a linha css e a empurra para uma função que insere essa linha na marca de estilo. </li><li>  <b>Você pode deixar na lista de navegadores apenas o navegador usado especificamente - provavelmente este é o último chrome</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Isso irá acelerar bastante</a> . </li><li>  Abandone <b>completamente qualquer otimização de recursos</b> : de UglifyJS, css-nano, gzip / brotli. </li></ul><br><blockquote>  A aceleração de compilação é paralelização, armazenamento em cache e recusa de cálculos.  Seguindo estas três etapas simples, você pode acelerar muito. </blockquote><br><h2>  Como configurar o webpack? </h2><br>  Nós descobrimos como montar um pacote de sonhos e como montá-lo rapidamente, e agora vamos descobrir como configurar o Webpack para não nos dar um tiro na perna toda vez que você alterar a configuração. <br><br><h3>  Configuração da evolução no projeto </h3><br>  Um caminho típico do webpack-config em um projeto começa com uma configuração <b>simples</b> .  Inicialmente, basta inserir o Webpack, o Babel-loader, o sass-loader e tudo está bem.  Inesperadamente, algumas <b>condições</b> aparecem <b>em process.env</b> e você as insere.  Um, segundo, terceiro, mais e mais, até que uma condição com uma opção "mágica" seja adicionada.  Você entende que tudo já está muito ruim, e é melhor <b>duplicar as configurações</b> para dev e produção e fazer as correções duas vezes.  Tudo ficará mais claro.  Se você pensou: “Algo está errado aqui?”, O único conselho de trabalho é <b>manter a configuração em ordem</b> .  Vou te dizer como fazemos. <br><br><h3>  Mantenha a configuração em ordem </h3><br>  Usamos o pacote <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webpack-merge</a></b> .  Este é um pacote npm criado para combinar várias configurações em uma.  Se você não estiver familiarizado com a estratégia de mesclagem padrão, poderá personalizá-la. <br><br><h3>     </h3><br>    4  : <br><br><ul><li> Loaders. </li><li> Plugins. </li><li> Presets. </li><li> Parts. </li></ul><br>    . <br><br><h4> Plugin/Loader </h4><br>  ,        ,       API,  ,      . <br><br>  Parece algo como isto: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  JSdoc * @param {Object} options * @see    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plugin(options); };</code> </pre><br>  ,   ,   ,   .    ,       url-loader  : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * url-loader    file-loader.        * * @example * -   some-image.png.     url-loader,  url-loader    * 1.    ,  url-loader    base64  * 2. , url-loader    outputPath + name     ,     . *    some-image.png,     outputPath/images/some-image.12345678hash.png,  url-loader  * publicPath/images/some-image.12345678hash.png * * @param {string} prefix    * @param {number} limit    ,    * @return {Object} loader   * @see https://www.npmjs.com/package/url-loader */</span></span></code> </pre><br>     ,   ,  , ,    ,   ,     .  ,  ,   ,  ,   url-loader.    : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlLoader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'assets'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'url-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { limit, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">/[name].[hash].[ext]`</span></span> } }; };</code> </pre><br>         .    ,   Loader         . <br><br><h4> Preset </h4><br>    webpack.     ,      ,    ,   webpack,    .    —  ,  ,    scss-: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.scss$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [cssLoader, postCssLoader, scssLoader] }</code> </pre><br>     . <br><br><h4> Part </h4><br>  —  ,      .        ,       ,   .  ,       : <br><br><pre> <code class="javascript hljs">entry: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/Frontend/app.js'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">publicPath</span></span>: <span class="hljs-string"><span class="hljs-string">'/static/cabinet/app/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'www/static/app'</span></span>) },</code> </pre><br>     : <br><br><ul><li> <b> </b> ,   ,   , json,     , , splitChunks. </li><li> <b>  dev</b> ,  ,    js/css     </li><li> <b>Part</b> ,   output, publicPath, entry-point    , ,    source map. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/20f/fa6/7ee20ffa6f453c35f11d92e3583d8caf.png" alt="imagem"><br><br> <b>Webpack-merge</b>     .          ,     .  webpack-merge     3-7 ,    Babel-loader,            .    ,   . <br><br><h3>   </h3><br>  . <b>  </b> ,    . <b> </b> ,   webpack       —     . <b>  </b> ,  . <br><br>   ,    ! <br><br><blockquote>   —     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Frontend Conf</a> . ,    —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Frontend Conf ++</a>  . <br><br>    -      ?    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FrontenConf ++</a> ,   27  28   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>  27 ,   15          .     — ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433324/">https://habr.com/ru/post/pt433324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433308/index.html">Transferindo a configuração do PBX para o serviço 3CX PBX Express</a></li>
<li><a href="../pt433316/index.html">Resumo do projeto: integração, feedback, busca de idéias e tomada de decisão</a></li>
<li><a href="../pt433318/index.html">garbage.collect ()</a></li>
<li><a href="../pt433320/index.html">Layout da grade como base dos layouts modernos</a></li>
<li><a href="../pt433322/index.html">API JSON - trabalhamos de acordo com a especificação</a></li>
<li><a href="../pt433326/index.html">Qualidade do código</a></li>
<li><a href="../pt433328/index.html">Melhor perder um dia</a></li>
<li><a href="../pt433330/index.html">Resolver palavras cruzadas em japonês com o SAT Solver</a></li>
<li><a href="../pt433332/index.html">Suporte de Python nas funções do Azure</a></li>
<li><a href="../pt433334/index.html">Comportamentos XAML para WPF agora é Open Source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>