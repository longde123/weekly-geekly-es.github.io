<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏼 🎬 🛥️ 初学者3D游戏着色器 🤰🏽 🧕🏾 🚣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="是否想了解如何在3D游戏中添加纹理，光照，阴影，法线贴图，发光物体，环境光遮挡和其他效果？ 太好了！ 本文介绍了一组可将游戏图形级别提高到新高度的着色技术。 我将以一种您可以在任何工具堆栈（无论是Godot，Unity还是其他工具）上应用/移植此信息的方式来解释每种技术。 

 作为着色器之间的“胶...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>初学者3D游戏着色器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="图片"></div><br> 是否想了解如何在3D游戏中添加纹理，光照，阴影，法线贴图，发光物体，环境光遮挡和其他效果？ 太好了！ 本文介绍了一组可将游戏图形级别提高到新高度的着色技术。 我将以一种您可以在任何工具堆栈（无论是Godot，Unity还是其他工具）上应用/移植此信息的方式来解释每种技术。 <br><br> 作为着色器之间的“胶水”，我决定使用出色的游戏引擎Panda3D和OpenGL着色语言（GLSL）。 如果使用相同的堆栈，则将获得额外的优势-您将学习如何在Panda3D和OpenGL中专门使用着色技术。 <br><a name="habracut"></a><br><h2> 准备工作 </h2><br> 下面是我用来开发和测试示例代码的系统。 <br><br><h3> 星期三 </h3><br> 示例代码是在以下环境中开发和测试的： <br><br><ul><li>  Linux manjaro 4.9.135-1-MANJARO </li><li>  OpenGL渲染器字符串：GeForce GTX 970 / PCIe / SSE2 </li><li>  OpenGL版本字符串：4.6.0 NVIDIA 410.73 </li><li>  g ++（GCC）8.2.1 20180831 </li><li> 熊猫3D 1.10.1-1 </li></ul><br><h3> 用料 </h3><br> 用于创建<code>mill-scene.egg</code>每种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Blender</a>材料都有两个纹理。 <br><br> 第一个纹理是法线贴图，第二个纹理是漫反射贴图。 如果对象使用其顶点的法线，则使用“纯蓝色”法线贴图。 由于所有模型在相同位置具有相同的卡，因此可以将着色器通用化并将其应用于场景图的根节点。 <br><br> 请注意，场景图是Panda3D引擎<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">实现的功能</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br> 这是仅包含颜色<code>[red = 128, green = 128, blue = 255]</code>的单色法线贴图。 <br><br> 该颜色表示单位法线，沿z轴<code>[0, 0, 1]</code>的正方向指示。 <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br> 在这里，我们看到单位法线<code>[0, 0, 1]</code>转换为纯蓝色<code>[128, 128, 255]</code> ，而实心蓝色转换为单位法线。 <br><br> 有关法线贴图技术的部分将对此进行详细说明。 <br><br><h3> 熊猫3d </h3><br> 在此代码示例中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Panda3D</a>用作着色器之间的“胶水”。 这不会影响下面介绍的技术，也就是说，您可以在任何选定的堆栈或游戏引擎中使用此处研究的信息。  Panda3D提供了某些便利设施。 在我谈论它们的文章中，因此您可以在堆栈中找到它们的对应对象，或者如果它们不在堆栈中，则可以自己重新创建它们。 <br><br> 值得考虑的是，在<code>config.prc</code>中添加了<code>gl-coordinate-system default</code> ， <code>textures-power-2 down</code>和<code>textures-auto-power-2 1</code>的添加。 它们不包含在标准<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Panda3D配置中</a> 。 <br><br> 默认情况下，Panda3D使用带有向上z轴的右手坐标系，而OpenGL使用带有带有y向上轴的右手​​坐标系。 <br><br>  <code>gl-coordinate-system default</code>可让您摆脱着色器内部两个坐标系之间的变换。 <br><br> 如果系统支持， <code>textures-auto-power-2 1</code>允许我们使用不是2的幂的纹理大小。 <br><br> 当执行SSAO或在屏幕/窗口内实现其他技术时，这很方便，因为屏幕/窗口大小通常不是2的幂。 <br><br> 如果系统仅支持大小等于<code>textures-power-2 down</code>会将纹理的大小减小为2的幂。 <br><br><h2> 构建示例代码 </h2><br> 如果要运行示例代码，则必须首先对其进行构建。 <br><br>  Panda3D可在Linux，Mac和Windows上运行。 <br><br><h3> 的Linux </h3><br> 首先， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">安装</a>要分发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Panda3D SDK</a> 。 <br><br> 查找Panda3D标头和库的位置。 它们最有可能分别位于<code>/usr/include/panda3d/</code>和<code>/usr/lib/panda3d/</code> 。 <br><br> 然后克隆此存储库并导航到其目录。 <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br> 现在将源代码编译成输出文件。 <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br> 创建输出文件后，通过将输出文件与其依赖项相关联来创建可执行文件。 <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br> 有关更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Panda3D手册</a> 。 <br><br><h3>  Mac电脑 </h3><br> 首先安装Mac版<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Panda3D SDK</a> 。 <br><br> 查找Panda3D的标头和库在哪里。 <br><br> 然后克隆存储库并导航到其目录。 <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br> 现在将源代码编译成输出文件。 您需要找到包含目录在Python 2.7和Panda3D中的位置。 <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br> 创建输出文件后，通过将输出文件与其依赖项相关联来创建可执行文件。 <br><br> 您需要找到Panda3D库所在的位置。 <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br> 有关更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Panda3D手册</a> 。 <br><br><h3> 窗户 </h3><br> 首先<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">安装</a>适用于Windows <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Panda3D SDK</a> 。 <br><br> 查找Panda3D标头和库的位置。 <br><br> 克隆此存储库并导航到其目录。 <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br> 有关更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Panda3D手册</a> 。 <br><br><h2> 启动演示 </h2><br> 构建示例代码后，您可以运行可执行文件或演示。 这就是它们在Linux或Mac上运行的方式。 <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br> 因此它们在Windows上运行： <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3> 键盘控制 </h3><br> 该演示具有键盘控制，可让您移动相机并切换各种效果的状态。 <br><br><h3> 机芯 </h3><br><ul><li>  <code>w</code>深入场景。 </li><li>  a-顺时针旋转场景。 </li><li>  <code>s</code>远离场景。 </li><li>  <code>d</code>逆时针旋转场景。 </li></ul><br><h3> 切换效果 </h3><br><ul><li>  <code>y</code>启用S​​SAO。 </li><li>  <code>Shift</code> + <code>y</code>禁用SSAO。 </li><li>  <code>u</code>包含电路。 </li><li>  <code>Shift</code> + <code>u</code>禁用轮廓。 </li><li>  <code>i</code> -启用绽放。 </li><li>  <code>Shift</code> + <code>i</code>禁用绽放。 </li><li>  <code>o</code>启用法线贴图。 </li><li>  <code>Shift</code> + <code>o</code>禁用法线贴图。 </li><li>  <code>p</code>包含雾。 </li><li>  <code>Shift</code> + <code>p</code>关闭雾。 </li><li>  <code>h</code>景深的包含。 </li><li>  <code>Shift</code> + <code>h</code>禁用景深。 </li><li>  <code>j</code>启用后代化。 </li><li>  <code>Shift</code> + J-禁用后代化 </li><li>  <code>k</code>启用像素化。 </li><li>  <code>Shift</code> + <code>k</code>禁用像素化。 </li><li>  <code>l</code>锐化。 </li><li>  <code>Shift</code> + <code>l</code>禁用清晰度。 </li><li>  <code>n</code>包含薄膜颗粒。 </li><li>  <code>Shift</code> + <code>n</code>禁用胶片颗粒。 </li></ul><br><h2> 参考系统 </h2><br> 在开始编写着色器之前，您需要熟悉以下参考系统或坐标系。 所有这些都归结为从<code>(0, 0, 0)</code>中获取参考原点的当前坐标的内容。 一旦发现，就可以使用某种矩阵或其他向量空间对其进行转换。 通常，如果着色器的输出看起来不正确，则原因是坐标系统混乱。 <br><br><h3> 型号 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br> 模型或对象的坐标系相对于模型的原点。 在三维建模程序中，例如在Blender中，通常将其放置在模型的中心。 <br><br><h3> 世界 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br> 世界空间是相对于您创建的场景/关卡/宇宙的原点的。 <br><br><h3> 复习 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br> 视图的坐标空间是相对于活动摄像机的位置的。 <br><br><h3> 剪裁 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br> 相对于相机框架中心的剪切空间。 其中的所有坐标都是均匀的，并且在<code>(-1, 1)</code>区间内。  X和y平行于相机胶卷，z坐标为深度。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br> 不在可见度金字塔范围内或相机可见度范围内的所有顶点都将被切除或丢弃。 我们将看到这种情况是如何发生的，一个立方体在相机远处的平面后面被截断，一个立方体在侧面。 <br><br><h3> 萤幕 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br> 屏幕空间（通常）相对于屏幕的左下角。  X从零变为屏幕的宽度。  Y从零变为屏幕高度。 <br><br><h2>  GLSL </h2><br> 与其使用固定功能的流水线，不如使用可编程的GPU渲染流水线。 由于它是可编程的，因此我们自己必须以着色器的形式将其传递给程序代码。 着色器是一个（通常很小的）程序，使用类似于C语言的语法创建。 不同类型的着色器包括顶点着色器，曲面细分着色器，几何着色器，片段着色器和计算着色器。 要使用本文中描述的技术，对于我们来说，使用顶点和片段就足够了 <br> 阶段。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br> 这是最小的GLSL着色器，由GLSL版本号和主要功能组成。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br> 这是截断的顶点着色器GLSL，它将输入的顶点转换为剪切空间，并将此新位置显示为统一的顶点位置。 <br><br>  <code>main</code>过程什么也不返回，因为它是<code>void</code> ，并且<code>gl_Position</code>变量是内联输出。 <br><br> 值得一提的两个关键词是： <code>uniform</code>和<code>in</code> 。 <br><br>  <code>uniform</code>关键字表示此全局变量对于所有顶点都是相同的。  Panda3D本身会设置<code>p3d_ModelViewProjectionMatrix</code>并且对于每个顶点，它都是相同的矩阵。 <br><br>  <code>in</code>关键字意味着将该全局变量传递给着色器。 顶点着色器获取几何组成的每个顶点，顶点着色器将附加到该顶点。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br> 这是修剪的GLSL片段着色器，显示不透明的绿色作为片段的颜色。 <br><br> 不要忘记一个片段仅影响一个屏幕像素，但是几个片段可以影响一个像素。 <br><br> 注意out关键字。 <br><br>  <code>out</code>关键字表示此全局变量由着色器设置。 <br><br> 名称<code>fragColor</code>可选的，因此您可以选择其他任何名称。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br> 这是上面显示的两个着色器的输出。 <br><br><h2> 纹理渲染 </h2><br> 该示例代码不是直接在屏幕上渲染/绘制，而是使用一种技术 <br> 名称“渲染到纹理”（渲染到纹理）。 要渲染到纹理，您需要配置帧缓冲区并将纹理绑定到它。 您可以将多个纹理绑定到单个帧缓冲区。 <br><br> 绑定到帧缓冲区的纹理存储片段着色器返回的向量。 通常，这些向量是颜色向量<code>(r, g, b, a)</code> ，但它们可以是位置向量或法线向量<code>(x, y, z, w)</code> 。 对于每个绑定纹理，片段着色器可以输出单独的矢量。 例如，我们可以一遍推导顶点的位置和法线。 <br><br> 与Panda3D一起使用的大部分示例代码与设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">帧缓冲区纹理有关</a> 。 为简单起见，示例代码中的每个片段着色器只有一个输出。 但是，为了确保高帧速率（FPS），我们需要在每个渲染过程中输出尽可能多的信息。 <br><br> 这是示例代码中帧缓冲区的两个纹理结构。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br> 第一种结构使用各种顶点和片段着色器将水车场景渲染为帧缓冲区纹理。 该结构通过磨机穿过舞台的每个顶点并沿着相应的片段。 <br><br> 在这种结构中，示例代码如下工作。 <br><br><ul><li> 保存几何数据（例如，位置或顶点法线）以备将来使用。 </li><li> 保存材料数据（例如漫反射颜色）以备将来使用。 </li><li> 创建不同纹理（漫射，法线贴图，阴影贴图等）的UV绑定。 </li><li> 计算环境，漫射，反射和发射的光照。 </li><li> 渲染雾。 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br> 第二结构是瞄准屏幕形状的矩形的正交相机。 <br> 该结构仅穿过四个峰及其相应的片段。 <br><br> 在第二个结构中，示例代码执行以下操作： <br><br><ul><li> 处理另一个帧缓冲区纹理的输出。 </li><li> 将不同的帧缓冲区纹理合并为一个。 </li></ul><br> 在代码示例中，我们可以看到一帧缓冲区纹理的输出，将相应的帧设置为true，将所有其他帧设置为false。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2> 纹理化 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br> 纹理化是使用UV坐标将颜色或某些其他矢量与片段结合。  U和V的值从零到一变化。 每个顶点接收一个UV坐标，并显示在顶点着色器中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br> 片段着色器获取插值的UV坐标。 插值表示片段的UV坐标在组成三角形面的顶点的UV坐标之间。 <br><br><h3> 顶点着色器 </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br> 在这里，我们看到顶点着色器将纹理的坐标输出到片段着色器。 请注意，这是一个二维向量：U的一个值和V的一个值。 <br><br><h3> 片段着色器 </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br> 在这里，我们看到片段着色器在其UV坐标中搜索颜色并将其显示为片段的颜色。 <br><br><h4> 屏幕填充纹理 </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br> 渲染为纹理时，网格是具有与屏幕相同的纵横比的扁平矩形。 因此，我们可以计算UV坐标，仅知道 <br><br>  A）使用UV坐标将纹理的宽度和高度与屏幕尺寸叠加在矩形上，以及 <br>  B）片段的x和y坐标。 <br><br> 要将x绑定到U，您需要将x除以传入纹理的宽度。 同样，要将y绑定到V，您需要将y除以传入纹理的高度。 您将看到在示例代码中使用了此技术。 <br><br><h2> 灯饰 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br> 为了确定照明，有必要计算并组合环境照明，漫射照明，反射照明和发射照明的各个方面。 示例代码使用Phong照明。 <br><br><h3> 顶点着色器 </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br> 对于每种光源，除了环境光之外，Panda3D都为我们提供了方便的结构，可用于顶点着色器和片段着色器。 最方便的是阴影贴图和用于查看阴影的矩阵，以将顶点转换为阴影或照明空间。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br> 从顶点着色器开始，我们必须将顶点从观察空间变换和移除，变成场景中每个光源的阴影或照明空间。 将来，这对于片段着色器渲染阴影会派上用场。 阴影或照明空间是每个坐标都相对于光源位置（原点是光源）的空间。 <br><br><h3> 片段着色器 </h3><br> 片段着色器执行大部分光照计算。 <br><br><h4> 材质 </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  Panda3D为我们当前正在渲染的网格或模型提供了材料（以结构形式）。 <br><br><h4> 多种光源 </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br> 在研究场景的照明源之前，我们将创建一个包含漫反射和反射颜色的驱动器。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br> 现在，我们可以循环移动光源，计算每种光源的漫反射和反射颜色。 <br><br><h4> 照明相关矢量图 </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br> 这是计算每个光源引入的漫反射和反射颜色所需的四个基本向量。 照明方向矢量是指向光源的蓝色箭头。 法线向量是垂直向上指向的绿色箭头。 反射向量是反映光的方向向量的蓝色箭头。 眼睛或视野矢量是指向相机的橙色箭头。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br> 照明方向是从顶点位置到光源位置的向量。 <br><br> 如果这是定向照明，则Panda3D <code>p3d_LightSource[i].position.w</code>为零。 定向照明没有位置，只有方向。 因此，如果这是定向照明，则照明方向将是与光源相反或相反的方向，因为对于定向照明，Panda3D将<code>p3d_LightSource[i].position.xyz</code>设置为<code>p3d_LightSource[i].position.xyz</code> 。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br> 顶点的法线必须是单位向量。 单位向量的值等于1。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br> 接下来，我们需要另外三个向量。 <br><br> 我们需要具有照明方向参与的标量产品，因此最好对其进行标准化。 这给了我们等于单位（单位矢量）的距离或大小。 <br><br> 视线方向与顶点/片段的位置相反，因为顶点/片段的位置相对于摄影机的位置。 不要忘记顶点/片段的位置在查看空间中。 因此，我们从顶点/片段移动到相机（眼睛），而不是从相机（眼睛）移动到顶点/片段。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">反射矢量</a>是垂直于表面的照明方向的反射。 当“光线”接触表面时，它以与落下时相同的角度反射。 照明的方向向量与法线之间的角度称为“入射角”。 反射矢量和法线之间的角度称为“反射角度”。 <br><br> 您需要更改反射光矢量的符号，因为它应指向与眼睛矢量相同的方向。 别忘了眼睛的方向是从顶部/片段到照相机的位置。 我们将使用反射向量来计算反射光的亮度。 <br><br><h4> 漫射照明 </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br> 漫射照明的亮度是表面法线和单个矢量的照明方向的标量积。 标量积的范围为负一到一。 如果两个向量都指向同一方向，则亮度为1。 在所有其他情况下，它将小于统一。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br> 如果照度矢量接近与法线相同的方向，则漫射照度的亮度趋于统一。 <br><br> 如果漫射照明的亮度小于或等于零，则需要转到下一个光源。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br> 现在，我们可以计算此源引入的漫反射颜色。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果漫射照明的亮度等于1，则漫射颜色将是漫射纹理的颜色和照明颜色的混合。</font><font style="vertical-align: inherit;">在任何其他亮度下，漫反射颜色将更暗。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，我限制了漫反射颜色，以使其不比漫反射纹理的颜色更亮。</font><font style="vertical-align: inherit;">这样可以防止场景过度曝光。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 反射光 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 漫射照明后，将计算反射。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反射光的亮度是眼睛向量和反射向量之间的标量积。</font><font style="vertical-align: inherit;">与漫射照明的亮度一样，如果两个向量指向同一方向，则反射照明的亮度等于1。</font><font style="vertical-align: inherit;">任何其他亮度将减少此光源引入的反射颜色量。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">材料的光泽决定了反射光的照明将被散射多少。</font><font style="vertical-align: inherit;">通常，它是在模拟程序中设置的，例如在Blender中。</font><font style="vertical-align: inherit;">在Blender中，它称为镜面硬度。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 聚光灯 </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此代码不允许照明影响聚光灯锥或金字塔外部的碎片。</font><font style="vertical-align: inherit;">幸运的是，Panda3D中可以</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作有方向性和射灯。</font><font style="vertical-align: inherit;">聚光灯既有位置又有方向。</font><font style="vertical-align: inherit;">但是，定向照明仅具有方向，而点光源仅具有位置。</font><font style="vertical-align: inherit;">但是，此代码可用于所有三种类型的照明，而无需混淆if语句。</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在投影照明的情况下，矢量``照明的片段源''与投影仪的方向矢量的标量乘积小于投影仪视场角的一半的余弦值</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则着色器不会考虑该源的影响。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，您必须更改符号</font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从片段到探照灯，我们需要从探照灯移到片段，因为它</font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接到达探照灯金字塔的中心，且距离探照灯的位置一定距离。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在定向照明和点光源的情况下，Panda3D将该</font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">设置</font><font style="vertical-align: inherit;">为-1。回想一下，标量积在-1到1的范围内变化。因此，它的大小无关紧要</font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它始终大于或等于-1。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像代码一样</font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该代码也适用于所有三种类型的光源。</font><font style="vertical-align: inherit;">对于聚光灯，当它接近聚光灯金字塔的中心时，它将使片段变亮。</font><font style="vertical-align: inherit;">对于定向和点光源，光源</font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为零。</font><font style="vertical-align: inherit;">回想一下，零幂的任何值都等于1，所以漫反射颜色等于其自身乘以1，即不变。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 暗影 </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D简化了阴影的使用，因为它为场景中的每个光源创建了一个阴影贴图和阴影变换矩阵。要自己创建转换矩阵，您需要收集一个矩阵，该矩阵将查看空间的坐标转换为照明空间（坐标相对于光源的位置）。要自己创建阴影贴图，您需要从光源的角度将场景渲染到帧缓冲区纹理中。帧缓冲区纹理应包含从光源到片段的距离。这称为“深度图”。最后，您需要将自己的深度图</font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和阴影转换矩阵分别</font><font style="vertical-align: inherit;">手动传输到着色器</font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，我们将重新创建Panda3D为我们自动执行的操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用了所示的代码段</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该代码段</font><font style="vertical-align: inherit;">与上面显示的功能不同</font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一分歧</font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，她使用它</font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来查找存储在阴影贴图中的深度。然后，她使用</font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来比较顶部的深度和中的阴影贴图的深度</font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果比较成功，则</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回1。否则，它返回零。零表示此顶点/片段在阴影中，而一表示该顶点/片段不在阴影中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它也可以返回从零到一的值，具体取决于阴影贴图的配置方式。在这个例子中</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据相邻深度执行多次深度测试，并返回加权平均值。</font><font style="vertical-align: inherit;">该加权平均值可以使阴影平滑。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 衰减度 </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到光源的距离只是照明方向矢量的大小或长度。</font><font style="vertical-align: inherit;">请注意，我们不使用归一化的照明方向，因为这样的距离将等于1。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到光源的距离对于计算衰减是必需的。</font><font style="vertical-align: inherit;">衰减意味着远离光源的光的影响减小。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以指定任意值。</font><font style="vertical-align: inherit;">它应该下手</font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用这些参数，在光源的位置它等于1，并且在远离光源时趋于零。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最终色彩照明 </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要计算照明的最终颜色，您需要添加漫反射和反射颜色。</font><font style="vertical-align: inherit;">有必要在绕过场景中的光源的周期中将其添加到驱动器中。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 周围环境 </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照明模型中的环境照明组件基于材质的环境颜色，环境照明的颜色以及漫反射纹理的颜色。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与每个光源累积的漫反射和反射颜色的计算相比，周围的光源绝不能超过一个，因此该计算应该只执行一次。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，执行SSAO时，环境光的颜色会派上用场。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 全部放在一起 </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最终颜色是环境颜色，漫反射颜色，反射颜色和发射颜色的总和。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源代码 </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本片段</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 法线贴图 </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用法线贴图可以将新零件添加到曲面，而无需其他几何图形。</font><font style="vertical-align: inherit;">通常，在3D建模程序中工作时，会创建网格的高多边形版本和低多边形版本。</font><font style="vertical-align: inherit;">然后从高多边形网格获取顶点的法线并将其烘焙到纹理中。</font><font style="vertical-align: inherit;">此纹理是法线贴图。</font><font style="vertical-align: inherit;">然后，在片段着色器内部，用烘焙到法线贴图中的高多边形网格的法线替换低多边形网格的顶点的法线。</font><font style="vertical-align: inherit;">因此，在照亮网格时，看起来它的多边形比实际更多。</font><font style="vertical-align: inherit;">这样，您可以保持较高的FPS，同时传输高多边形版本的大多数详细信息。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这里，我们看到了从高多边形模型到低多边形模型的过渡，然后是具有法线贴图叠加的低多边形模型的过渡。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，不要忘记覆盖法线贴图只是一种幻想。</font><font style="vertical-align: inherit;">在某个角度下，表面再次开始变得平坦。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 顶点着色器 </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从顶点着色器开始，我们需要将法线向量，双法线向量和切线向量输出到片段着色器。</font><font style="vertical-align: inherit;">这些向量在片段着色器中用于将法线贴图的法线从切线空间转换为可视空间。</font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将顶点，双法线和切线向量的法线向量转换为视图空间。</font><font style="vertical-align: inherit;">请不要忘记，在查看空间中所有坐标都相对于摄像机的位置。</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix]是ModelViewMatrix的顶部3x3反向转置元素。</font><font style="vertical-align: inherit;">此结构用于将法线向量转换为查看空间的坐标。</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">来源</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们还需要将法线贴图的UV坐标输出到片段着色器。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 片段着色器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回想一下，顶点法线用于计算光照。</font><font style="vertical-align: inherit;">但是，要计算光照，法线贴图会为我们提供其他法线。</font><font style="vertical-align: inherit;">在片段着色器中，我们需要将顶点的法线替换为法线贴图中的法线。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用由顶点着色器传输的法线贴图的坐标，我们从贴图中提取相应的法线。 </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面，我展示了如何将法线转换为颜色以创建法线贴图。</font><font style="vertical-align: inherit;">现在我们需要逆转此过程，以便可以将原始法线烘焙到地图上。</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是从法线贴图中解开法线的过程。 </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从法线贴图获得的法线通常在切线空间中。</font><font style="vertical-align: inherit;">但是，它们可以在另一个空间中。</font><font style="vertical-align: inherit;">例如，Blender允许您在切线空间，对象空间，世界空间和摄影机空间中烘焙法线。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要将法线贴图的法线从切线空间转移到查看空间，请基于切线向量，双法线向量和顶点法线创建3x3矩阵。</font><font style="vertical-align: inherit;">将法线乘以该矩阵并将其标准化。</font><font style="vertical-align: inherit;">这就是我们以法线结束的地方。</font><font style="vertical-align: inherit;">所有其他照明计算仍在执行。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源代码 </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本片段</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453300/">https://habr.com/ru/post/zh-CN453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453290/index.html">数据科学文摘（2019年5月）</a></li>
<li><a href="../zh-CN453292/index.html">“关于黑洞的小书”</a></li>
<li><a href="../zh-CN453294/index.html">反应 延迟加载</a></li>
<li><a href="../zh-CN453296/index.html">在PHP中管理异步：从承诺到协程</a></li>
<li><a href="../zh-CN453298/index.html">夏天：升级时间...自己</a></li>
<li><a href="../zh-CN453302/index.html">Yandex.Module生命的第一个小时</a></li>
<li><a href="../zh-CN453304/index.html">Zextras PowerStore的主要优点</a></li>
<li><a href="../zh-CN453306/index.html">Kubernetes将接管世界。 什么时候以及如何？</a></li>
<li><a href="../zh-CN453310/index.html">使用RxJS库在React组件之间交换数据</a></li>
<li><a href="../zh-CN453312/index.html">基于XML数据的PDF商业电子邮件生成器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>