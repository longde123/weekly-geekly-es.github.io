<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍💻 👨🏼‍🚀 🔊 Ktor en tant que client HTTP pour Android 😉 🗽 ♌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'aime Retrofit2 en tant que développeur Android, mais qu'en est-il d'essayer d'obtenir la qualité du client HTTP Ktor? À mon avis, pour le développem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ktor en tant que client HTTP pour Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432310/"> J'aime Retrofit2 en tant que développeur Android, mais qu'en est-il d'essayer d'obtenir la qualité du client HTTP Ktor?  À mon avis, pour le développement Android, ce n'est ni pire ni meilleur, juste l'une des options, bien que si vous envelopper un peu tout, cela puisse très bien se passer.  J'examinerai les fonctionnalités de base avec lesquelles il sera possible de commencer à utiliser Ktor en tant que client HTTP - création de différents types de demandes, réception de réponses brutes et de réponses sous forme de texte, désérialisation de json en classes via des convertisseurs et journalisation. <br><br><img src="https://habrastorage.org/webt/o1/m6/fm/o1m6fmsauhb_r4wzrnyvuuc3rg0.png"><br><a name="habracut"></a><br>  En général, Ktor est un framework qui peut agir comme un client HTTP.  Je vais le considérer du côté du développement pour Android.  Il est peu probable que vous voyiez ci-dessous des cas d'utilisation très complexes, mais les fonctionnalités de base sont précises.  Le code des exemples ci-dessous peut être consulté sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  Ktor utilise les coroutines de Kotlin 1.3, une liste des artefacts disponibles peut être trouvée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , la version actuelle est <code>1.0.1</code> . <br>  Pour les requêtes, j'utiliserai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://">HttpBin</a> . <br><br><h4>  Utilisation simple </h4><br>  Pour commencer, vous aurez besoin de dépendances de base pour le client Android: <br><br><pre> <code class="plaintext hljs">implementation "io.ktor:ktor-client-core:1.0.1" implementation "io.ktor:ktor-client-android:1.0.1"</code> </pre><br>  N'oubliez pas d'ajouter au manifeste que vous utilisez Internet. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uses-permission</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.INTERNET"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre><br>  Essayons d'obtenir la réponse du serveur sous forme de chaîne, quoi de plus simple? <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> BASE_URL = <span class="hljs-string"><span class="hljs-string">"https://httpbin.org"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> GET_UUID = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_URL</span></span></span><span class="hljs-string">/uuid"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = HttpClient() GlobalScope.launch(Dispatchers.IO) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = client.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;String&gt;(GET_UUID) Log.i(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_TAG</span></span></span><span class="hljs-string"> Simple case "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre><br>  Vous pouvez créer un client sans paramètres, il suffit de créer une instance de <code>HttpClient()</code> .  Dans ce cas, Ktor sélectionnera le moteur souhaité et l'utilisera avec les paramètres par défaut (nous avons un moteur connecté - Android, mais il y en a d'autres, par exemple, OkHttp). <br>  Pourquoi les coroutines?  Parce que <code>get()</code> est une fonction de <code>suspend</code> . <br><br>  Que faire ensuite?  Vous avez déjà des données du serveur sous forme de chaîne, il suffit de les analyser et d'obtenir des classes avec lesquelles vous pouvez déjà travailler.  Il semble être simple et rapide dans ce cas d'utilisation. <br><br><h4>  Nous obtenons une réponse brute </h4><br>  Parfois, il peut être nécessaire d'obtenir un ensemble d'octets au lieu d'une chaîne.  En même temps, expérimentez l'asynchronie. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performAllCases</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { GlobalScope.launch(Dispatchers.IO) { simpleCase() bytesCase() } } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = HttpClient() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = client.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;String&gt;(GET_UUID) Log.i(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_TAG</span></span></span><span class="hljs-string"> Simple case"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bytesCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = HttpClient() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = client.call(GET_UUID).response.readBytes() Log.i(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_TAG</span></span></span><span class="hljs-string"> Bytes case"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.joinToString(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"["</span></span>, <span class="hljs-string"><span class="hljs-string">"]"</span></span>) { it.toString(<span class="hljs-number"><span class="hljs-number">16</span></span>).toUpperCase() }) }</code> </pre><br>  Aux endroits où les méthodes <code>HttpClient</code> sont <code>HttpClient</code> , comme <code>call()</code> et <code>get()</code> , <code>await()</code> sera appelé sous le capot.  Dans ce cas, les appels à <code>simpleCase()</code> et <code>bytesCase()</code> seront donc toujours séquentiels.  Vous en avez besoin en parallèle - il suffit d'envelopper chaque appel dans une coroutine distincte.  Dans cet exemple, de nouvelles méthodes sont apparues.  L'appel <code>call(GET_UUID)</code> retournera un objet à partir duquel nous pouvons obtenir des informations sur la demande, sa configuration, sa réponse et son client.  L'objet contient de nombreuses informations utiles - du code de réponse et de la version du protocole au canal avec les mêmes octets. <br><br><h4>  Avez-vous besoin de le fermer d'une manière ou d'une autre? </h4><br>  Les développeurs indiquent que pour que le moteur HTTP s'arrête correctement, vous devez appeler la méthode <code>close()</code> sur le client.  Si vous devez effectuer un appel et fermer immédiatement le client, vous pouvez utiliser la méthode <code>use{}</code> , car <code>HttpClient</code> implémente l'interface <code>Closable</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closableSimpleCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { HttpClient().use { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: String = it.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(GET_UUID) Log.i(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_TAG</span></span></span><span class="hljs-string"> Closable case"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre><br><h4>  Exemples en plus de GET </h4><br>  Dans mon travail, la deuxième méthode la plus populaire est le <code>POST</code> .  Prenons l'exemple de la définition des paramètres, des en-têtes et du corps de la demande. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHeadersCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: String = client.post(POST_TEST) { fillHeadersCaseParameters() } Log.i(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_TAG</span></span></span><span class="hljs-string"> Post case"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> HttpRequestBuilder.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillHeadersCaseParameters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { parameter(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Andrei"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// +     url.parameters.appendAll( parametersOf( "ducks" to listOf("White duck", "Grey duck"), // +      "fish" to listOf("Goldfish") // +     ) ) header("Ktor", "https://ktor.io") // +  headers /*       */ { append("Kotlin", "https://kotl.in") } headers.append("Planet", "Mars") // +  headers.appendMissing("Planet", listOf("Mars", "Earth")) // +   , "Mars"   headers.appendAll("Pilot", listOf("Starman")) //     body = FormDataContent( //  ,     form Parameters.build { append("Low-level", "C") append("High-level", "Java") } ) }</span></span></code> </pre><br>  En fait, dans le dernier paramètre de la <code>post()</code> , vous avez accès à <code>HttpRequestBuilder</code> , avec lequel vous pouvez former n'importe quelle demande. <br>  La méthode <code>post()</code> analyse simplement la chaîne, la convertit en URL, définit explicitement le type de la méthode et fait une demande. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rawPostHeadersCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: String = client.call { url.takeFrom(POST_TEST) method = HttpMethod.Post fillHeadersCaseParameters() } .response .readText() Log.i(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_TAG</span></span></span><span class="hljs-string"> Raw post case"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) }</code> </pre><br>  Si vous exécutez le code des deux dernières méthodes, le résultat sera similaire.  La différence n'est pas grande, mais l'utilisation de wrappers est plus pratique.  La situation est similaire pour <code>put()</code> , <code>delete()</code> , <code>patch()</code> , <code>head()</code> et <code>options()</code> , nous ne les considérerons donc pas. <br><br>  Cependant, si vous regardez attentivement, vous pouvez voir qu'il y a une différence de frappe.  Lorsque vous appelez <code>call()</code> vous obtenez une réponse de bas niveau et vous devez lire les données vous-même, mais qu'en est-il de la saisie automatique?  Après tout, nous sommes tous habitués à connecter un convertisseur (tel que <code>Gson</code> ) dans Retrofit2 et à indiquer le type de retour en tant que classe spécifique.  Nous parlerons de la conversion en classes plus tard, mais la méthode <code>request</code> aidera à taper le résultat sans se lier à une méthode HTTP spécifique. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typedRawPostHeadersCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = client.request&lt;String&gt;() { url.takeFrom(POST_TEST) method = HttpMethod.Post fillHeadersCaseParameters() } Log.i(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_TAG</span></span></span><span class="hljs-string"> Typed raw post"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) }</code> </pre><br><h4>  Soumettre les données du formulaire </h4><br>  Habituellement, vous devez passer des paramètres dans la chaîne de requête ou dans le corps.  Dans l'exemple ci-dessus, nous avons déjà examiné comment procéder à l'aide de <code>HttpRequestBuilder</code> .  Mais cela peut être plus simple. <br><br>  La fonction <code>submitForm</code> accepte l'url en tant que chaîne, les paramètres de la demande et un indicateur booléen qui indique comment transmettre les paramètres - dans la ligne de demande ou sous forme de paires dans le formulaire. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submitFormCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> params = Parameters.build { append(<span class="hljs-string"><span class="hljs-string">"Star"</span></span>, <span class="hljs-string"><span class="hljs-string">"Sun"</span></span>) append(<span class="hljs-string"><span class="hljs-string">"Planet"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mercury"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> getData: String = client.submitForm(GET_TEST, params, encodeInQuery = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     val postData: String = client.submitForm(POST_TEST, params, encodeInQuery = false) //   form Log.i("$BASE_TAG Submit form get", getData) Log.i("$BASE_TAG Submit form post", postData) }</span></span></code> </pre><br><h4>  Mais qu'en est-il des multipart / form-data? </h4><br>  En plus des paires de chaînes, vous pouvez passer comme paramètres des numéros de demande POST, des tableaux d'octets et divers flux d'entrée.  Différences dans la formation des fonctions et des paramètres.  Nous ressemblons à: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submitFormBinaryCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inputStream = ByteArrayInputStream(byteArrayOf(<span class="hljs-number"><span class="hljs-number">77</span></span>, <span class="hljs-number"><span class="hljs-number">78</span></span>, <span class="hljs-number"><span class="hljs-number">79</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> formData = formData { append(<span class="hljs-string"><span class="hljs-string">"String value"</span></span>, <span class="hljs-string"><span class="hljs-string">"My name is"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   append("Number value", 179) //  append("Bytes value", byteArrayOf(12, 74, 98)) //   append("Input value", inputStream.asInput(), headersOf("Stream header", "Stream header value")) //    } val data: String = client.submitFormWithBinaryData(POST_TEST, formData) Log.i("$BASE_TAG Submit binary case", data) }</span></span></code> </pre><br>  Comme vous l'avez peut-être remarqué - vous pouvez également attacher un ensemble d'en-têtes à chaque paramètre. <br><br><h4>  Désérialiser la réponse à la classe </h4><br>  Vous devez obtenir certaines données de la demande, pas sous forme de chaîne ou d'octets, mais immédiatement converties en classe.  Pour commencer, dans la documentation, nous recommandons de connecter une fonctionnalité pour travailler avec json, mais je veux faire une réservation pour que jvm ait besoin d'une dépendance spécifique et sans kotlinx-sérialisation, tout cela ne décollera pas.  Je suggère d'utiliser Gson comme convertisseur (il y a des liens vers d'autres bibliothèques prises en charge dans la documentation, des liens vers la documentation seront à la fin de l'article). <br><br>  niveau du projet build.gradle: <br><br><pre> <code class="plaintext hljs">buildscript { dependencies { classpath "org.jetbrains.kotlin:kotlin-serialization:$kotlin_version" } } allprojects { repositories { maven { url "https://kotlin.bintray.com/kotlinx" } } }</code> </pre><br>  Niveau d'application build.gradle: <br><br><pre> <code class="plaintext hljs">apply plugin: 'kotlinx-serialization' dependencies { implementation "io.ktor:ktor-client-json-jvm:1.0.1" implementation "io.ktor:ktor-client-gson:1.0.1" }</code> </pre><br>  Exécutez maintenant la demande.  De la nouvelle, il n'y aura qu'une connexion de la fonctionnalité de travailler avec Json lors de la création du client.  J'utiliserai l'API Open Weather.  Pour être complet, je vais montrer le modèle de données. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weather</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consolidated_weather: List&lt;ConsolidatedWeather&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> time: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sun_rise: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sun_set: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timezone_name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parent: Parent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sources: List&lt;Source&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> location_type: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> woeid: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> latt_long: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timezone: String ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Source</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> slug: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> crawl_rate: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConsolidatedWeather</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> weather_state_name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> weather_state_abbr: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wind_direction_compass: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> created: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicable_date: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> min_temp: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> max_temp: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> the_temp: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wind_speed: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wind_direction: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> air_pressure: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> humidity: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> visibility: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> predictability: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> location_type: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> woeid: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> latt_long: String ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> SF_WEATHER_URL = <span class="hljs-string"><span class="hljs-string">"https://www.metaweather.com/api/location/2487956/"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAndPrintWeather</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = HttpClient(Android) { install(JsonFeature) { serializer = GsonSerializer() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> weather: Weather = client.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(SF_WEATHER_URL) Log.i(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BASE_TAG</span></span></span><span class="hljs-string"> Serialization"</span></span>, weather.toString()) }</code> </pre><br><h4>  Et quoi d'autre peut </h4><br>  Par exemple, le serveur renvoie une erreur et vous disposez du code comme dans l'exemple précédent.  Dans ce cas, vous recevrez une erreur de sérialisation, mais vous pouvez configurer le client de sorte qu'une erreur <code>BadResponseStatus</code> soit levée lorsque le code de réponse est &lt;300.  Il suffit de définir <code>expectSuccess</code> sur <code>true</code> lors de la création du client. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = HttpClient(Android) { install(JsonFeature) { serializer = GsonSerializer() } expectSuccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Lors du débogage, la journalisation peut être utile.  Ajoutez simplement une dépendance et configurez le client. <br><br><pre> <code class="plaintext hljs">implementation "io.ktor:ktor-client-logging-jvm:1.0.1"</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client = HttpClient(Android) { install(Logging) { logger = Logger.DEFAULT level = LogLevel.ALL } }</code> </pre><br>  Nous spécifions l'enregistreur PAR DÉFAUT et tout ira à LogCat, mais vous pouvez redéfinir l'interface et créer votre propre enregistreur si vous le souhaitez (bien que je n'y ai pas vu de grandes opportunités, il n'y a qu'un message à l'entrée, mais il n'y a pas de niveau de journal).  Nous indiquons également le niveau de journaux à refléter. <br><br>  Références: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La documentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation d'implémentation client</a> </li></ul><br>  Ce qui n'est pas considéré: <br><br><ul><li>  Travailler avec le moteur OkHttp </li><li>  Paramètres du moteur </li><li>  Moteur simulé et tests </li><li>  Module d'autorisation </li><li>  Fonctionnalités distinctes telles que le stockage des cookies entre les demandes, etc. </li><li>  Tout ce qui ne s'applique pas au client HTTP pour Android (autres plates-formes, travail via des sockets, implémentation de serveur, etc. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432310/">https://habr.com/ru/post/fr432310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432300/index.html">Support, service, mal de tête et tout-tout</a></li>
<li><a href="../fr432302/index.html">Modèles de séquence à séquence, partie 2</a></li>
<li><a href="../fr432304/index.html">Un neuroscientifique brillant qui peut avoir une clé pour créer une véritable intelligence artificielle</a></li>
<li><a href="../fr432306/index.html">Mémoire de classe de stockage dans le stockage - si vous en avez besoin encore plus rapidement</a></li>
<li><a href="../fr432308/index.html">Niveau Sci-Fi modulaire UE4: inspiré par Nostromo et Serenity</a></li>
<li><a href="../fr432312/index.html">Créer une carte de forme de la carte RF dans Power BI</a></li>
<li><a href="../fr432314/index.html">Roskachestvo a publié une liste des meilleurs smartphones de 2018</a></li>
<li><a href="../fr432316/index.html">Russian AI Cup 2018: CodeBall. Compétition 3D spectaculaire</a></li>
<li><a href="../fr432318/index.html">Solution de tâche Spring Boot avec ManyToMany</a></li>
<li><a href="../fr432320/index.html">RAM avec simulation de cache à mappage direct simple sur FPGA dans Verilog</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>