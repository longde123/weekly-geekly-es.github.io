<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🍳 🆕 💾 C ++中的复制语义和资源管理 🏛️ 👧 👨🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在C ++中，程序员必须决定如何释放使用的资源；没有像垃圾收集器这样的自动工具。 本文讨论了该问题的可能解决方案，详细研究了潜在问题以及许多相关问题。 
 

 目录 
 目录 

 引言 
 1.基本的副本所有权策略 
 1.1。 禁止复制策略 
 1.2。 独家所有权策略 
 1.3。 深层复制...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++中的复制语义和资源管理</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>在C ++中，程序员必须决定如何释放使用的资源；没有像垃圾收集器这样的自动工具。</i>  <i>本文讨论了该问题的可能解决方案，详细研究了潜在问题以及许多相关问题。</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1> 目录 </h1><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.基本的副本所有权策略</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">禁止复制策略</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">独家所有权策略</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深层复制策略</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">共同所有权策略</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.深度复制策略-问题与解决方案</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复制记录</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">定义类的状态交换函数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译器删除中间副本</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">置换语义的实现</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.5。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">住宿与</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插入</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.6。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">总结</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.实施共享所有权策略的选项</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.专有所有权策略和移动语义</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.复制禁止策略-快速入门</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.资源和资源所有者对象的生命周期</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">初始化时捕获资源</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高级资源生命周期管理选项</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.2.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">延长资源生命周期</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.2.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单一资源捕获</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.2.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">间接增加</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">共同所有权</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.总结</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">应用领域</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">附录A.右值链接</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">附录B.位移语义</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考文献</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1> 引言 </h1><br><p>资源管理是C ++程序员必须始终执行的工作。 资源包括内存块，OS内核对象，多线程锁，网络连接，数据库连接，以及在动态内存中创建的任何对象。 对资源的访问是通过描述符进行的，描述符的类型通常是指针或其别名之一（ <code>HANDLE</code>等），有时甚至是整个别名（UNIX文件描述符）。 使用资源后，必须释放它，否则迟早不释放资源的应用程序（可能还有其他应用程序）将耗尽资源。 这个问题非常严重，可以说.NET，Java和其他几个平台的关键功能之一是基于垃圾回收的统一资源管理系统。 </p><br><p>  C ++的面向对象功能自然导致以下解决方案：管理资源的类包含资源描述符作为成员，在捕获资源时初始化描述符，并在析构函数中释放资源。 但是经过一番思考（或经验）之后，人们才意识到它并不是那么简单。 而主要的问题是复制的语义。 如果管理资源的类使用默认编译器生成的复制构造函数，则在复制对象后，我们将获得同一资源句柄的两个副本。 如果一个对象释放了资源，那么第二个对象将能够尝试使用或释放​​已经释放的资源，这在任何情况下都是不正确的，并且可能导致所谓的未定义行为，即可能发生任何事情，例如程序异常终止。 </p><br><p> 幸运的是，在C ++中，程序员可以通过自己定义复制构造函数和复制赋值运算符来完全控制复制过程，这使我们通常可以以多种方式解决上述问题。 复制的实现应与释放资源的机制紧密联系，我们将其统称为复制所有权策略。 所谓的“三巨头规则”是众所周知的，它指出，如果程序员定义了三个操作（复制构造函数，复制赋值运算符或析构函数）中的至少一个，则他必须定义所有三个操作。 复制所有权策略仅指定如何执行此操作。 有四种基本的副本所有权策略。 </p><br><a name="id-1"></a><br><h1>  1.基本的副本所有权策略 </h1><br><p> 在捕获资源之前或之后，描述符必须具有一个特殊值，该值指示该资源与资源无关。 通常为零，有时为-1，强制转换为描述符类型。 无论如何，这样的描述符将被称为零。 在这种情况下，管理资源的类必须识别空描述符，并且不要尝试使用或释放​​资源。 </p><br><a name="id-1-1"></a><br><h2>  1.1。 禁止复制策略 </h2><br><p> 这是最简单的策略。 在这种情况下，完全禁止复制和分配类实例。 析构函数释放捕获的资源。 在C ++中，要禁止复制并不困难，该类必须声明但不定义封闭的复制构造函数和复制赋值运算符。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p> 编译和链接器阻止了复制尝试。 </p><br><p>  C ++ 11标准针对这种情况提供了一种特殊的语法： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p> 尝试复制时，此语法更直观，并向编译器提供更多可理解的消息。 </p><br><p> 在标准库的早期版本（C ++ 98）中，输入/输出流的类（ <code>std::fstream</code>等）使用了复制禁止策略，而在Windows上，则使用了MFC中的许多类（ <code>CFile</code> ， <code>CEvent</code> ， <code>CMutex</code>等）。 在C ++ 11标准库中，某些类使用此策略来支持多线程同步。 </p><br><a name="id-1-2"></a><br><h2>  1.2。 独家所有权策略 </h2><br><p> 在这种情况下，实现复制和分配时，资源描述符从源对象移动到目标对象，也就是说，它保留在单个副本中。 复制或分配后，源对象具有空描述符，并且无法使用资源。 析构函数释放捕获的资源。 此策略也使用专有或严格所有权[Josuttis]； Andrei Alexandrescu使用破坏性复制一词。 在C ++ 11中，此操作如下进行：以上述方式禁止常规复制和复制分配，并实现了移动语义，即，定义了移动构造函数和移动分配运算符。  （稍后会详细介绍运动的语义。） </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p> 因此，排他性所有权策略可以被视为对复制禁止策略的扩展。 </p><br><p> 在C ++ 11标准库中，此策略使用智能指针<code>std::unique_ptr&lt;&gt;</code>和其他一些类，例如： <code>std::thread</code> ， <code>std::unique_lock&lt;&gt;</code>以及以前使用过复制禁止策略的类（ <code>std::fstream</code>等）。 在Windows上，以前使用了复制禁止策略的MFC类也开始使用排他所有权策略（ <code>CFile</code> ， <code>CEvent</code> ， <code>CMutex</code>等）。 </p><br><a name="id-1-3"></a><br><h2>  1.3。 深层复制策略 </h2><br><p> 在这种情况下，您可以复制和分配类实例。 必须定义复制构造函数和复制赋值运算符，以便目标对象将资源从源对象复制到自身。 之后，每个对象都拥有其资源副本，可以独立使用，修改和释放资源。 析构函数释放捕获的资源。 有时，对于使用深度复制策略的对象，使用值对象。 </p><br><p> 此策略不适用于所有资源。 可以将其应用于与内存缓冲区关联的资源（例如字符串），但是还不清楚如何将其应用于OS内核的对象（例如文件，互斥对象等）。 </p><br><p> 深度复制策略可用于所有类型的对象字符串， <code>std::vector&lt;&gt;</code>和标准库的其他容器中。 </p><br><a name="id-1-4"></a><br><h2>  1.4。 共同所有权策略 </h2><br><p> 在这种情况下，您可以复制和分配类实例。 您必须定义复制构造函数和复制赋值运算符，在其中复制资源描述符（以及其他数据），但不能复制资源本身。 之后，每个对象都有其自己的描述符副本，可以使用，修改但不能释放资源，只要至少有一个拥有描述符副本的对象即可。 拥有句柄副本的最后一个对象超出范围后，将释放资源。 下面描述如何实现。 </p><br><p> 共同所有权策略通常由智能指针使用，并且将它们用于不可变资源也是很自然的。  <code>std::shared_ptr&lt;&gt;</code>智能指针在C ++ 11标准库中实现了此策略。 </p><br><a name="id-2"></a><br><h1>  2.深度复制策略-问题与解决方案 </h1><br><p> 考虑一个模板，用于C ++ 98标准库中类型<code>T</code>的对象的状态交换功能。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p> 如果类型<code>T</code>拥有资源并使用深度复制策略，则我们有三个操作来分配新资源，三个复制操作和三个操作来释放资源。 尽管在大多数情况下可以执行此操作而无需分配新资源和完全不进行复制，但是对象交换内部数据（包括资源描述符）就足够了。 当您必须创建资源的临时副本并立即释放它们时，有许多类似的示例。 日常操作的这种无效实施刺激了对解决方案进行优化的寻找。 让我们考虑主要选项。 </p><br><a name="id-2-1"></a><br><h2>  2.1。 复制记录 </h2><br><p> 写时复制（COW）也称为延迟复制，可以看作是尝试结合使用深层复制策略和共享所有权策略。 最初，在复制对象时，将复制资源描述符，而没有资源本身，并且对于所有者，资源变为共享和只读的，但是一旦某些所有者需要修改共享资源，便会立即复制资源，然后该所有者使用其资源副本。 实施COW解决了状态交换的问题：不会发生额外的资源分配和复制。 在实现字符串时，非常流行使用COW；例如， <code>CString</code> （MFC，ATL）。 在[Meyers1]，[Sutter]中可以找到实施COW和新兴问题的可能方法的讨论。  [Guntheroth]提出了使用<code>std::shared_ptr&lt;&gt;</code>的COW实现。 在多线程环境中实现COW时会出现问题，这就是为什么在标准C ++ 11库中禁止对字符串使用COW的原因，请参见[Josuttis]，[Guntheroth]。 </p><br><p>  COW想法的发展导致以下资源管理方案：资源是不可变的，并使用共享所有权策略由对象管理，如有必要，更改资源，创建新的，经过适当修改的资源，并返回新的所有者对象。 此架构用于.NET和Java平台上的字符串和其他不可变对象。 在函数式编程中，它用于更复杂的数据结构。 </p><br><a name="id-2-2"></a><br><h2>  2.2。 定义类的状态交换函数 </h2><br><p> 上面显示了通过复制和分配以简单的方式实现状态交换功能的效率如何低下。 而且它使用非常广泛，例如，它被标准库的许多算法所使用。 为了使算法不使用另一个<code>std::swap()</code> ，而是使用专门为该类定义的另一个函数，必须执行两个步骤。 </p><br><p>  1.在类中定义实现状态<code>Swap()</code>的成员函数<code>Swap()</code> （名称不重要）。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p> 您必须确保该函数不会引发异常；在C ++ 11中，此类函数必须声明为<code>noexcept</code> 。 </p><br><p>  2.在与类<code>X</code>相同的名称空间中（通常在同一头文件中），如下定义自由（非成员） <code>swap()</code>函数（名称和签名是基本的）： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p> 之后，标准库的算法将使用它，而不是<code>std::swap()</code> 。 这提供了一种称为自变量依赖查找（ADL）的机制。 有关ADL的更多信息，请参见[Dewhurst1]。 </p><br><p> 在C ++标准库中，所有容器，智能指针以及其他类都实现了如上所述的状态交换功能。 </p><br><p>  <code>Swap()</code>成员函数通常很容易定义：如果数据库和成员支持，则必须顺序地对数据库和成员应用状态交换操作，否则，必须对<code>std::swap()</code>进行状态交换操作。 </p><br><p> 上面的描述有些简化，可以在[Meyers2]中找到更详细的描述。 关于状态交换功能的问题的讨论也可以在[Sutter / Alexandrescu]中找到。 </p><br><p> 状态交换功能可以归因于该类的基本操作之一。 使用它，您可以优雅地定义其他操作。 例如，复制分配运算符通过copy和<code>Swap()</code>定义如下： </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p> 此模板称为复制和交换惯用语或Herb Sutter惯用语，有关更多详细信息，请参见[Sutter]，[Sutter / Alexandrescu]，[Meyers2]。 它的修改可以应用于实现位移的语义，请参见第2.4、2.6.1节。 </p><br><a name="id-2-3"></a><br><h2>  2.3。 编译器删除中间副本 </h2><br><p> 考虑上课 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p> 和功能 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p> 通过简单的方法，通过复制<code>X</code>的实例来实现<code>Foo()</code>函数的返回<code>X</code> 但是编译器能够从代码中删除复制操作，直接在调用点创建对象。 这称为返回值优化（RVO）。  RVO已被编译器开发人员使用了相当长的一段时间，目前已在C ++ 11标准中得到修复。 尽管有关RVO的决定是由编译器决定的，但程序员仍可以根据其用途编写代码。 为此，希望函数具有一个返回点，并且返回表达式的类型与函数的返回值的类型匹配。 在某些情况下，建议定义一个特殊的封闭构造函数，称为“计算构造函数”，有关更多详细信息，请参见[Dewhurst2]。 在[Meyers3]和[Guntheroth]中也讨论了RVO。 </p><br><p> 在其他情况下，编译器可以删除中间副本。 </p><br><a name="id-2-4"></a><br><h2>  2.4。 置换语义的实现 </h2><br><p> 移动语义的实现包括定义一个移动构造函数，该构造函数具有对源的rvalue-reference类型的参数和具有相同参数的移动赋值运算符。 </p><br><p> 在C ++ 11标准库中，状态交换功能模板定义如下： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p> 根据解决具有右值引用类型参数的函数重载的规则（请参见附录A），如果类型<code>T</code>具有移动构造函数和移动赋值运算符，则将使用它们，并且不会分配临时资源和进行复制。 否则，将使用复制构造函数和复制分配运算符。 </p><br><p> 使用重定位的语义避免了在比上述状态交换功能更广泛的上下文中创建临时副本。 运动语义适用于任何右值，即临时的未命名值，以及函数的返回值（如果该函数是在本地创建的（包括左值）且未应用RVO）。 在所有这些情况下，都可以保证在移动之后不能以任何方式使用源对象。  move语义也适用于将<code>std::move()</code>转换应用到的左值。 但是在这种情况下，程序员负责移动之后如何使用源对象（示例<code>std::swap()</code> ）。 </p><br><p> 考虑到运动的语义，对标准的C ++ 11库进行了重新设计。 许多类都添加了带有rvalue类型引用参数的move构造函数和move赋值运算符以及其他成员函数。 例如， <code>std::vector&lt;T&gt;</code>具有<code>void push_back(T&amp;&amp; src)</code>的重载版本。 所有这些在许多情况下都可以避免创建临时副本。 </p><br><p> 实现移动语义不会取消类的状态交换功能的定义。 专门定义的状态交换函数比标准<code>std::swap()</code>更有效。 而且，使用以下状态交换的成员函数（复制和交换惯用语的变体）非常容易地定义move构造函数和move赋值运算符： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  move构造函数和move赋值运算符是那些成员函数，非常需要确保它们不引发异常，并因此将其声明为<code>noexcept</code> 。 这使您可以优化标准库容器的某些操作，而不会违反对异常安全性的严格保证；有关更多详细信息，请参见[Meyers3]和[Guntheroth]。 提议的模板提供了这样的保证，条件是默认构造函数和状态交换的成员函数不引发异常。 </p><br><p>  C ++ 11标准为编译器提供了自动生成移动构造函数和移动赋值运算符的方法，为此，必须使用<code>"=default"</code>构造进行声明。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p> 通过将移动操作顺序地应用于类的基类和成员（如果它们支持移动），然后复制操作，来实现这些操作。 显然，这种选择远非总是可以接受的。 原始描述符不会移动，但是通常无法复制它们。 在某些条件下，编译器可以独立生成类似的移动构造函数和移动赋值运算符，但最好不要利用此机会，这些条件很容易混淆，并且在精炼类时很容易更改。 有关详细信息，请参见[Meyers3]。 </p><br><p> 通常，位移语义的实现和使用是一件“轻巧的事情”。 编译器可以在程序员希望移动的地方应用复制。 这里有一些规则可以消除或至少减少这种情况的可能性。 </p><br><ol><li> 如果可能，请使用禁止复制。 </li><li> 声明move构造函数并将move赋值运算符声明为<code>noexcept</code> 。 </li><li> 为基类和成员实现运动语义。 </li><li> 将<code>std::move()</code>转换应用于右值引用类型的函数的参数。 </li></ol><br><p> 上面讨论了规则2。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则4是由于命名的右值链接是左值的事实（另请参见附录A）。</font><font style="vertical-align: inherit;">这可以通过移动构造函数的定义示例来说明。</font></font></p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在定义移动分配运算符时，上面给出了此规则的另一个示例。</font><font style="vertical-align: inherit;">在6.2.1节中还将讨论位移语义的实现。</font></font></p><br><a name="id-2-5"></a><br><h2>  2.5。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">住宿与 </font><font style="vertical-align: inherit;">插入</font></font></h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      —   (variadic templates),         .  ,      C++11 —     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6。 总结 </h2><br><p>     ,    ,     .               -  .                   .   —     :    ,    .     ,       ,     ,  .      :     ,     ,  «»   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    —   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    —   .     6. </p><br><p>   ,     -  -,  «  »,   -     .         -    . ,   ,     ,     ,    -       .      «». </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          «   » (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      «» RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2> 6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     «  »,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  «» RAII,   —          .      ,     ,    . 3.       .    «»,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        —    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1> 应用领域 </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue. 一个例子： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- —      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         —    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1> 参考文献 </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: . 来自英语  -M .: LLC“ I.D. », 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: . 来自英语 — .:  «-», 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: . 来自英语  -M .: LLC“ I.D. », 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: . 来自英语 — .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: . 来自英语 — .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: . 来自英语 — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: . 来自英语 — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: . 来自英语  -M .: LLC“ I.D. », 2016. </p><br><p> [Sutter] <br> , .     C++.: . 来自英语 — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: . 来自英语  -M .: LLC“ I.D. », 2015. </p><br><p> [Schildt] <br> , .    C++.: . 来自英语 — .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: . 来自英语 — .:  « «», 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425837/">https://habr.com/ru/post/zh-CN425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425827/index.html">Google+课程：项目需要确保在线尊重现实生活中用户利益之间的界限</a></li>
<li><a href="../zh-CN425829/index.html">我们与Roskomnadzor的战斗方式以及结果</a></li>
<li><a href="../zh-CN425831/index.html">RKN Alert-浏览器中的Roskomnadzor数据库</a></li>
<li><a href="../zh-CN425833/index.html">一种可帮助您为产品选择最佳创意的工具。</a></li>
<li><a href="../zh-CN425835/index.html">Sberbank中的“ Buging Bugs”：如何解决每天七天的错误率</a></li>
<li><a href="../zh-CN425839/index.html">Atlassian会议回顾</a></li>
<li><a href="../zh-CN425843/index.html">面向儿童的Python：选择教程</a></li>
<li><a href="../zh-CN425845/index.html">自动锁定Google Play上的应用</a></li>
<li><a href="../zh-CN425847/index.html">使用Microsoft Flow或如何给妻子送花的示例</a></li>
<li><a href="../zh-CN425849/index.html">亚马逊放弃并提高了员工薪水</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>