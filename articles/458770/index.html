<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó≥Ô∏è üèÆ üìç Toda la verdad sobre RTOS. Art√≠culo # 29. Interrupciones en el n√∫cleo SE üõµ üíà üí§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos los microprocesadores y microcontroladores modernos contienen alg√∫n tipo de mecanismo de interrupci√≥n. Estos mecanismos son necesarios para prop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo # 29. Interrupciones en el n√∫cleo SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/"> Todos los microprocesadores y microcontroladores modernos contienen alg√∫n tipo de mecanismo de interrupci√≥n.  Estos mecanismos son necesarios para proporcionar la capacidad de respuesta requerida por muchas aplicaciones.  Por supuesto, la capacidad de respuesta y la previsibilidad son el objetivo principal cuando se usa RTOS, pero al mismo tiempo se oponen entre s√≠.  El uso de interrupciones puede alterar la integridad del sistema operativo en tiempo real.  Este problema y su soluci√≥n se mencionaron en uno de los art√≠culos anteriores (# 4 y # 6).  En este art√≠culo, veremos la estrategia de manejo de interrupciones utilizada en Nucleus SE.  En todos los casos, Nucleus SE NO controla las interrupciones: se procesan cuando ocurren seg√∫n la prioridad y los vectores de la manera habitual.  Su tiempo de ejecuci√≥n es simplemente "robado" del tiempo disponible en el c√≥digo de la aplicaci√≥n principal y el programador.  Obviamente, se deduce que todos los manejadores de interrupciones deben ser simples, cortos y r√°pidos. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Art√≠culos anteriores de la serie:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Temporizadores de software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hora del sistema</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Canales: servicios auxiliares y estructuras de datos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Canales de datos: introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: servicios auxiliares y estructuras de datos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se√±ales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Particiones de memoria: servicios y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Secciones de memoria: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de datos de tareas y llamadas de API no compatibles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuraci√≥n e introducci√≥n a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservaci√≥n del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise√±o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫cleo SE: Introducci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <br></div></div><br><h2>  Interrupciones regulares y controladas </h2><br>  Nucleus SE ofrece dos formas de manejar las interrupciones: "nativa" o "regular" (nativa), en la que las interrupciones no son nada especial y, en cierta medida, tienen una interacci√≥n limitada con el sistema operativo (al menos cuando se utiliza el programador prioritario) y " Gestionado, en el que puede acceder a un n√∫mero mucho mayor de llamadas API desde el controlador de interrupciones. <br><br>  Usando las macros de E / S, el controlador de interrupci√≥n Nucleus SE se puede usar en modo est√°ndar o administrado. <br><br><h3>  Interrupciones del personal </h3><br>  Las interrupciones de personal de Nucleus SE son el controlador de interrupciones est√°ndar y pueden considerarse "no administradas".  Por lo general, se usan cuando la interrupci√≥n puede ocurrir con una frecuencia alta y requiere procesamiento con un bajo uso de recursos inform√°ticos.  Es muy probable que dicho controlador est√© escrito en C, ya que muchos compiladores integrados modernos admiten el desarrollo de controladores de interrupciones utilizando la palabra clave interrupt.  Solo se almacena la informaci√≥n contextual que el compilador considera necesaria.  Esto lleva a limitaciones significativas sobre lo que pueden hacer los manejadores de interrupciones est√°ndar, que pronto veremos. <br><br>  Para crear un controlador de interrupci√≥n regular en Nucleus SE, es suficiente simplemente escribir un controlador de interrupci√≥n regular, incluyendo llamar a la macro <b>NUSE_NISR_Enter ()</b> al principio y llamar a <b>NUSE_NISR_Exit ()</b> al final.  Estas macros se definen en el archivo <b>nuse_types.</b>  h y establezca la variable global <b>NUSE_Task_State</b> en <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Interrupciones guiadas </h3><br>  Si necesita m√°s flexibilidad para las operaciones de manejo de interrupciones, las interrupciones administradas de Nucleus SE pueden ser la soluci√≥n.  La diferencia clave de la interrupci√≥n est√°ndar es mantener el contexto.  En lugar de permitir que el compilador guarde varios registros en la pila, una interrupci√≥n controlada guarda todo el contexto de la tarea (en su propio bloque de contexto) en la entrada.  Luego, el contexto de la tarea actual se restaura desde el bloque de contexto en la salida.  Esto proporciona la capacidad de cambiar la tarea actual mediante el trabajo del c√≥digo del controlador de interrupciones, que es posible cuando se utiliza el planificador prioritario.  En un art√≠culo anterior ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 10</a> ) se proporcion√≥ una descripci√≥n completa de la preservaci√≥n y restauraci√≥n del contexto en Nucleus SE. <br><br>  Obviamente, la preservaci√≥n completa del contexto implica un aumento en el uso de los recursos inform√°ticos en comparaci√≥n con el almacenamiento de varios registros en la pila, que ocurre durante una interrupci√≥n est√°ndar.  Este precio debe pagarse por una flexibilidad adicional, y esta es la raz√≥n por la cual se proporciona una opci√≥n de enfoque de manejo de interrupciones. <br><br>  Una interrupci√≥n administrada se <b>genera</b> utilizando la macro <b>NUSE_MANAGED_ISR ()</b> descrita en <b>nuse_types.h</b> .  Esta macro crea una funci√≥n que contiene las siguientes acciones: <br><br><ul><li>  mantener el contexto de la tarea; </li><li>  Asignaci√≥n de <b>NUSE_Task_State a</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li>  c√≥digo de funci√≥n del controlador de interrupciones proporcionado por el usuario; </li><li>  restaurar <b>NUSE_Task_State</b> a su estado anterior; </li><li>  restaurar el contexto de la tarea. </li></ul><br>  La macro toma dos par√°metros: el nombre de interrupci√≥n utilizado como el nombre de la funci√≥n para el controlador generado, y el nombre de la funci√≥n que contiene la l√≥gica de usuario para el controlador de interrupci√≥n. <br><br><h3>  Llamadas API desde el controlador de interrupciones </h3><br>  El conjunto de funciones API a las que se puede llamar desde un controlador de interrupciones est√°ndar o administrado depende del programador que se use.  En t√©rminos generales, el uso del planificador prioritario proporciona muchas opciones para acceder al planificador a trav√©s de una llamada a la funci√≥n API, lo cual es dif√≠cil cuando se utiliza el controlador de interrupci√≥n est√°ndar. <br><br>  <b><i>Llamadas API al manejador de interrupciones est√°ndar cuando se usa el planificador prioritario</i></b> <br><br>  Cuando se utiliza el planificador prioritario, se permite un n√∫mero limitado de llamadas a funciones API desde el controlador de interrupciones est√°ndar.  Esta limitaci√≥n es el resultado de la flexibilidad de la API de Nucleus SE: muchas llamadas pueden hacer que la tarea est√© lista y el programador de interrupciones est√°ndar no puede llamar al programador (ya que el contexto de la tarea no se guarda).  Desactivar los bloqueos de tareas proporciona a√∫n m√°s flexibilidad. <br><br>  Las siguientes llamadas a la API siempre est√°n permitidas: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Sin embargo, solo <b>NUSE_Signals_Send ()</b> es √∫til para ellos, ya que proporciona una manera conveniente de indicar a la tarea que se requiere alguna acci√≥n. <br><br>  Si el bloqueo est√° deshabilitado, es decir, muchas tareas de API no pueden poner las tareas listas, las llamadas de API adicionales estar√°n disponibles: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Algunas llamadas de API son siempre inaccesibles para los manejadores de interrupciones est√°ndar, ya que inevitablemente requerir√°n el trabajo de un planificador: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>Las llamadas de API al manejador de interrupciones administrado o al manejador de interrupciones est√°ndar cuando se utiliza cualquier planificador que no sea el planificador prioritario</i></b> <br><br>  Se pueden invocar muchas m√°s funciones API desde el controlador de interrupciones cuando se utilizan los programadores Run to Completion, Round Robin o Time Slice.  Si se utiliza un planificador prioritario, los manejadores de interrupciones administrados tienen un conjunto similar de funciones.  Esto se debe a que se permiten llamadas, lo que puede llevar a programar otra tarea.  Esta funci√≥n es proporcionada por el c√≥digo <b>NUSE_Reschedule ()</b> , que detecta el contexto de la llamada en el controlador de interrupciones y suprime el cambio de contexto (permitiendo que ocurra al final del controlador de interrupciones).  Un an√°lisis completo del trabajo del planificador se dio en uno de los art√≠culos anteriores ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 9</a> ). <br><br>  El requisito clave es que las llamadas a la API dentro del controlador de interrupciones no deber√≠an conducir a la suspensi√≥n de la tarea actual, por ejemplo, esperar para liberar un recurso. <br><br>  En otras palabras, tales llamadas deben hacerse con la <b>opci√≥n de</b> pausa <b>NUSE_NO_SUSPEND</b> . <br><br>  Con esto en mente, se pueden usar las siguientes llamadas a la API: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Algunas llamadas siempre est√°n prohibidas, ya que se relacionan directamente con la tarea actual: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Manejador de interrupci√≥n de reloj en tiempo real </h2><br>  El controlador de interrupci√≥n del reloj de tiempo real (RTC) es el √∫nico controlador de interrupci√≥n completo en Nucleus SE.  Adem√°s de proporcionar toda la funcionalidad necesaria para la gesti√≥n del tiempo en Nucleus SE, tambi√©n sirve como ejemplo de escritura de un manejador de interrupciones administrado. <br><br><h3>  Operaciones de manejo de interrupciones de RTC </h3><br>  Las funciones proporcionadas por el controlador de interrupciones RTC se enumeraron en uno de los art√≠culos anteriores, que trataban el amplio tema del tiempo del sistema en Nucleus SE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 27</a> ).  La funcionalidad descrita es opcional dependiendo de la configuraci√≥n de la aplicaci√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">El siguiente es el c√≥digo completo del controlador de interrupciones RTC.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  A continuaci√≥n, observamos cuatro √°reas principales de funcionalidad para el controlador de interrupciones RTC. <br><br>  <b><i>Temporizadores</i></b> <br>  Si los temporizadores de aplicaci√≥n est√°n configurados, el controlador de interrupciones entra en un bucle para procesar cada temporizador disminuyendo su contador en 1. Si el temporizador finaliza el conteo (es decir, el contador llega a 0), son posibles dos acciones: <br><br><ul><li>  si el controlador de finalizaci√≥n del temporizador est√° configurado y el temporizador tiene un puntero de funci√≥n correcto (no <b>NULL</b> ) (en <b>NUSE_Timer_Expiration_Routine_Address []</b> ), el controlador se ejecuta tomando un par√°metro de <b>NUSE_Timer_Expiration_Routine_Parameter []</b> ; </li><li>  si el temporizador est√° configurado para inicializarse despu√©s de la finalizaci√≥n (es decir, <b>NUSE_Timer_Reschedule_Time []</b> tiene un valor distinto de cero), el temporizador se recarga con este valor. </li></ul><br>  Los temporizadores de aplicaci√≥n se describieron en detalle en un art√≠culo anterior (# 28). <br><br>  <b><i>Reloj del sistema</i></b> <br>  Si se configura un temporizador del sistema, el valor de <b>NUSE_Tick_Cloc</b> k simplemente aumenta en 1. Se puede encontrar m√°s informaci√≥n en el art√≠culo # 28. <br><br>  <b><i>Suspender una tarea (Tarea de suspensi√≥n)</i></b> <br>  Si el soporte para las tareas de pausa est√° habilitado (es decir, la llamada API <b>NUSE_Task_Sleep ()</b> est√° configurada), el contador de tiempo de espera de cada tarea (el valor en <b>NUSE_Task_Timeout_Counter []</b> ) est√° marcado, y si no es igual a cero, disminuye en 1. Si llega a cero, se reanuda la tarea correspondiente . <br><br>  <b><i>Programaci√≥n de segmentos de tiempo</i></b> <br>  Si se utiliza un planificador de Time Slice, el contador del planificador ( <b>NUSE_Time_Slice_Ticks</b> ) disminuye.  Si llega a cero, se llama al planificador.  La llamada a <b>NUSE_Reschedule ()</b> es responsable de restablecer el contador. <br><br><h3>  Interrupci√≥n controlada </h3><br>  Es necesario explicar por qu√© el manejador de interrupciones RTC es controlable, ya que bajo ciertas circunstancias el usuario puede decidir reescribirlo como una interrupci√≥n est√°ndar para reducir el uso de recursos inform√°ticos.  Por ejemplo, si solo se usa una funci√≥n de tiempo del sistema (es decir, no hay temporizadores de aplicaci√≥n, no hay suspensi√≥n de tareas y no hay un programador de Time Slice), funcionar√° una interrupci√≥n regular.  Se requiere interrupci√≥n guiada en los siguientes casos: <br><br><ul><li>  si se utilizan temporizadores y se configuran los controladores para su finalizaci√≥n, ya que estos controladores pueden realizar llamadas API (desde el contexto de interrupci√≥n), lo que provocar√° una nueva programaci√≥n.  Tienen las mismas limitaciones que las llamadas a la API realizadas desde los controladores de interrupciones (consulte anteriormente en este art√≠culo); </li><li>  si se utiliza un planificador prioritario, completar una suspensi√≥n de tarea puede requerir activar una tarea con una prioridad m√°s alta; </li><li>  Si se utiliza el planificador Time Slice, se llamar√° desde el controlador de interrupciones RTC, por lo tanto, se requiere una interrupci√≥n controlada. </li></ul><br><h2>  Nucleus RTOS Compatible </h2><br>  Dado que la implementaci√≥n de las interrupciones de Nucleus SE es muy diferente de Nucleus RTOS, no debe esperar compatibilidad al respecto.  Nucleus RTOS tiene un esquema de interrupci√≥n est√°ndar / de bajo nivel / alto nivel, que es un poco como el esquema de interrupci√≥n est√°ndar / controlado en Nucleus SE. <br><br><h3>  Manejadores de interrupciones de bajo y alto nivel </h3><br>  <b><i>Manejadores de interrupci√≥n de bajo nivel</i></b> <br>  Una rutina de servicio de interrupci√≥n de bajo nivel (LISR) se realiza de la misma manera que un controlador regular, incluido el uso de la pila actual.  Nucleus RTOS mantiene el contexto hasta que se llama al manejador de interrupciones de bajo nivel y restaura el contexto una vez que se completa el manejador.  Por lo tanto, un controlador de interrupciones de bajo nivel puede escribirse en C y puede llamar a otros controladores en C. Sin embargo, solo unos pocos servicios Nucleus RTOS est√°n disponibles para el controlador de bajo nivel.  Si el manejo de interrupciones requiere servicios adicionales de Nucleus RTOS, debe activar un controlador de interrupciones de alto nivel.  Nucleus RTOS admite el uso de varios manejadores de interrupciones de bajo nivel. <br><br>  <b><i>Manejador de interrupciones de alto nivel</i></b> <br>  La rutina de servicio de interrupci√≥n de alto nivel (HISR) se crea y elimina din√°micamente.  Cada procesador de alto nivel tiene su propio espacio de pila y su propia unidad de control.  La memoria es asignada por la aplicaci√≥n.  Y, por supuesto, se debe crear un controlador de interrupciones de alto nivel antes de que un controlador de interrupciones de bajo nivel pueda activarlo. <br><br>  Dado que el controlador de interrupciones de alto nivel tiene su propia pila y unidad de control, puede bloquearse temporalmente si intenta acceder a la estructura de datos Nucleus RTOS que est√° actualmente en uso. <br><br>  Hay tres niveles de prioridad disponibles para un controlador de interrupciones de alto nivel.  Si se activa un controlador de nivel superior con una prioridad m√°s alta durante el trabajo de un controlador con una prioridad m√°s baja, se ejecutar√° un controlador con una prioridad m√°s baja a medida que se complete la tarea.  Los manejadores de interrupciones de alto nivel con la misma prioridad se ejecutan en el orden en que se activan.  Todos los manejadores de interrupciones de alto nivel activados deben completarse antes de continuar programando tareas en modo normal. <br><br><h3>  La utilidad API Nucleus RTOS requiere interrupci√≥n </h3><br>  Nucleus RTOS tiene varias llamadas API para admitir interrupciones.  Ninguno de ellos se implementa en Nucleus SE. <br><br>  Para las interrupciones est√°ndar, las llamadas a la API proporcionan las siguientes funciones: <br><br><ul><li>  control (activaci√≥n / desactivaci√≥n) de interrupci√≥n (local y global); </li><li>  establecer el vector de interrupci√≥n. </li></ul><br>  Para interrupciones de bajo nivel: <br><br><ul><li>  registrar un controlador de interrupciones de bajo nivel en el kernel. </li></ul><br>  Para interrupciones de alto nivel: <br><br><ul><li>  creaci√≥n / eliminaci√≥n de interrupciones de alto nivel; </li><li>  activaci√≥n de interrupci√≥n de alto nivel; </li><li>  obtener el n√∫mero de interrupciones de alto nivel en la aplicaci√≥n (en este momento); </li><li>  obtener punteros para controlar las unidades de todas las interrupciones de alto nivel; </li><li>  obtener punteros para controlar las unidades de la interrupci√≥n actual de alto nivel; </li><li>  Obteniendo informaci√≥n de interrupci√≥n de alto nivel. </li></ul><br>  <b><i>Control global de interrupciones</i></b> <br><br>  Esta llamada activa o desactiva las interrupciones independientemente de la tarea.  Por lo tanto, la interrupci√≥n desactivada por esta llamada permanecer√° as√≠ hasta que se active reutilizando esta llamada. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Par√°metros: <br><br>  <b>new_level</b> : un nuevo nivel de interrupci√≥n para el sistema.  Siempre puede tomar los valores <b>NU_DISABLE_INTERRUPTS</b> (desactiva todas las interrupciones) y <b>NU_ENABLE_INTERRUPTS</b> (activa todas las interrupciones).  Otros valores pueden estar disponibles dependiendo de la arquitectura. <br><br>  Valor de retorno: <br><br>  Esta llamada de servicio devuelve el nivel anterior de interrupciones activadas. <br><br>  <b><i>Control local de interrupciones</i></b> <br><br>  Esta llamada de servicio le permite activar o desactivar interrupciones dependiendo de la tarea.  Esta llamada cambia el registro de estado al valor especificado.  El registro de estado volver√° al valor especificado por la √∫ltima llamada a <b>NU_Control_Interrupts () la</b> pr√≥xima vez que se cambie el contexto. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Par√°metros: <br><br>  <b>new_level</b> : un nuevo nivel de interrupci√≥n para la tarea actual.  Siempre puede tomar los valores <b>NU_DISABLE_INTERRUPTS</b> (desactiva todas las interrupciones) y <b>NU_ENABLE_INTERRUPTS</b> (activa todas las interrupciones).  Otros valores pueden estar disponibles dependiendo de la arquitectura. <br><br>  Valor de retorno: <br>  Esta llamada de servicio devuelve el nivel anterior de interrupciones activadas. <br><br>  <b><i>Establecer el vector de interrupci√≥n</i></b> <br><br>  Esta sobrecarga reemplaza el vector de interrupci√≥n especificado por el vector controlado por el controlador de interrupci√≥n. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Par√°metros: <br><br>  <b>vector</b> : <b>vector de</b> interrupci√≥n para el cual se registrar√° la interrupci√≥n; <br>  <b>nuevo</b> es el controlador de interrupci√≥n escrito para el vector. <br><br>  Valor de retorno: <br><br>  Esta llamada de utilidad devuelve un puntero al controlador de interrupciones previamente registrado para el vector de interrupci√≥n. <br><br>  <b><i>Registro de interrupci√≥n de bajo nivel</i></b> <br><br>  Esta sobrecarga llama a la funci√≥n del manejador de interrupciones de bajo nivel con el vector de interrupci√≥n.  El contexto del sistema se guarda autom√°ticamente antes de que se llame al controlador de interrupciones de bajo nivel especificado y se restablezca una vez que se completa el controlador de interrupciones. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Par√°metros: <br><br>  <b>vector</b> : <b>vector de</b> interrupci√≥n para el cual se registrar√° la interrupci√≥n; <br>  <b>lisr_entry</b> : la funci√≥n que se registrar√° para el vector, el valor <b>NU_NULL</b> borrar√° el vector; <br>  <b>old_lisr</b> es una funci√≥n registrada previamente para el vector especificado. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_VECTOR</b> - vector inv√°lido; <br>  <b>NU_NOT_Rector</b> : en este momento el vector no est√° registrado, ya que la <b>desregistro</b> se especific√≥ en l <b>isr_entry</b> ; <br>  <b>NO_MORE_LISRS</b> : se ha alcanzado el n√∫mero m√°ximo de manejadores de interrupciones de bajo nivel registrados. <br><br>  <b><i>Crear un manejador de interrupciones de alto nivel</i></b> <br>  Esta llamada de utilidad crea un controlador de interrupciones de alto nivel. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Par√°metros: <br><br>  <b>hisr</b> : un puntero a un bloque de control suministrado por el usuario para un manejador de interrupciones de alto nivel; <br>  <b>nombre</b> : puntero a un nombre de 7 caracteres para un controlador de interrupciones de alto nivel con un cero final; <br>  <b>hisr_entry</b> : el punto de entrada de la funci√≥n de manejo de interrupciones de alto nivel; <br>  <b>prioridad</b> : hay tres prioridades para los manejadores de interrupciones de alto nivel (0-2);  la prioridad 0 es la m√°s alta; <br>  <b>stack_pointer</b> : puntero al √°rea de la pila del controlador de interrupciones de alto nivel; <br>  <b>stack_size</b> : el n√∫mero de bytes en la pila del controlador de interrupciones de alto nivel. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_HISR</b> : un puntero nulo a la unidad de control del controlador de interrupciones de alto nivel ( <b>NULL</b> ) o la unidad de control ya est√° en uso; <br>  <b>NU_INVALID_ENTRY</b> : un puntero nulo al punto de entrada de un controlador de interrupciones de alto nivel ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> : prioridad incorrecta para un controlador de interrupciones de alto nivel; <br>  <b>NU_INVALID_MEMORY</b> : puntero de pila no v√°lido; <br>  <b>NU_INVALID_SIZE</b> : el tama√±o de la pila es demasiado peque√±o. <br><br>  <b><i>Eliminar un manejador de interrupciones de alto nivel</i></b> <br>  Esta llamada de utilidad elimina el controlador de interrupciones de alto nivel creado anteriormente. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Par√°metros: <br><br>  <b>hisr</b> es un puntero al bloque de control del controlador de interrupciones de alto nivel proporcionado por el usuario. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_HISR</b> : puntero <b>no v√°lido</b> a un controlador de interrupciones de alto nivel. <br><br>  <b><i>Activar un manejador de interrupciones de alto nivel</i></b> <br><br>  Esta llamada de utilidad activa un controlador de interrupciones de alto nivel.  Si el controlador de interrupci√≥n de alto nivel especificado se est√° ejecutando actualmente, la solicitud de activaci√≥n no se ejecuta hasta que el controlador deja de funcionar.  Se ejecuta un controlador de interrupciones de alto nivel una vez para cada solicitud de activaci√≥n. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Par√°metros: <br><br>  <b>hisr</b> es un puntero al bloque de control de un controlador de interrupciones de alto nivel. <br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_HISR</b> : puntero no v√°lido a la unidad de control de un controlador de interrupciones de alto nivel. <br><br>  <b><i>Obtener el n√∫mero de manejadores de interrupciones de alto nivel en un sistema</i></b> <br>  Esta llamada de utilidad devuelve el n√∫mero de manejadores de interrupciones de alto nivel instalados.  Todos los manejadores de interrupciones de alto nivel creados se consideran instalados.  Los controladores de interrupci√≥n de alto nivel remotos no se consideran instalados. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Par√°metros: <br>  Est√°n ausentes <br><br>  Valor de retorno: <br>  Esta llamada de utilidad devuelve el n√∫mero de controladores de interrupciones de alto nivel instalados en el sistema. <br><br>  <b><i>Obtener punteros para controlar bloques de manejadores de interrupciones de alto nivel</i></b> <br><br>  Esta llamada de servicio forma una lista secuencial de punteros a todos los manejadores de interrupciones de alto nivel instalados en el sistema. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Par√°metros: <br><br>  <b>pointer_list</b> : puntero a una matriz de punteros <b>NU_HISR</b> ;  esta matriz se llenar√° con punteros a los manejadores de interrupciones de alto nivel instalados en el sistema; <br>  <b>maximum_pointers</b> : el n√∫mero m√°ximo de punteros <b>NU_HISR</b> que se pueden colocar en la matriz;  generalmente es igual al tama√±o de la matriz <b>pointer_list</b> . <br><br>  Valor de retorno: <br>  Esta llamada de utilidad devuelve el n√∫mero de manejadores de interrupciones de alto nivel activos en el sistema. <br><br>  <b><i>Obtener un puntero al controlador de interrupciones de alto nivel actual</i></b> <br>  Esta llamada de utilidad devuelve un puntero al controlador de interrupci√≥n de alto nivel que se est√° ejecutando actualmente. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Par√°metros: <br>  Est√°n ausentes <br><br>  Valor de retorno: <br>  Esta llamada de servicio devuelve un puntero a la unidad de control del manejador de interrupciones de alto nivel que se est√° ejecutando actualmente.  Si un controlador de interrupciones de nivel no alto llama a esta funci√≥n, <b>se</b> devuelve <b>NU_NULL</b> . <br><br>  <b><i>Obtener informaci√≥n sobre un manejador de interrupciones de alto nivel</i></b> <br>  Esta llamada de utilidad devuelve informaci√≥n diversa sobre el controlador de interrupci√≥n de alto nivel especificado. <br><br>  Prototipo de llamada de servicio: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Par√°metros: <br><br>  <b>hisr</b> - un puntero a un manejador de interrupciones de alto nivel; <br>  <b>nombre</b> : puntero a la regi√≥n de 8 caracteres para el nombre del controlador de interrupciones de alto nivel, incluido el cero final; <br>  <b>programada_cuenta</b> : puntero a una variable para el n√∫mero total de veces que se program√≥ este controlador de interrupciones de alto nivel; <br>  <b>prioridad</b> : un puntero a una variable para almacenar la prioridad de un controlador de interrupciones de alto nivel; <br>  <b>stack_base</b> : puntero a un puntero para almacenar el puntero original en la pila;  este es el mismo puntero que se pas√≥ al crear el controlador de interrupciones de alto nivel; <br>  <b>stack_size</b> : un puntero a una variable para almacenar el tama√±o total de la pila de un controlador de interrupciones de alto nivel; <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimum_stack</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : un puntero a una variable para almacenar la cantidad m√≠nima de espacio de pila disponible detectado durante la ejecuci√≥n de un controlador de interrupciones de alto nivel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor de retorno: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la llamada se complet√≥ correctamente; </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : puntero </font><b><font style="vertical-align: inherit;">no v√°lido</font></b><font style="vertical-align: inherit;"> a un controlador de interrupciones de alto nivel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llamadas API desde manejadores de interrupciones </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamada API desde manejadores de interrupciones de bajo nivel Un manejador de interrupciones de bajo nivel</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solo puede usar las siguientes funciones de Nucleus RTOS:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamadas de servicio API desde manejadores de interrupciones de alto nivel Los manejadores de interrupciones de</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alto nivel tienen acceso a la mayor√≠a de las funciones de Nucleus RTOS, excepto las funciones de pausa autom√°tica, ya que un manejador de interrupciones de alto nivel no puede suspender la funci√≥n Nucleus RTOS, el par√°metro siempre debe ser</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente art√≠culo de esta serie cubrir√° los procedimientos de inicializaci√≥n y arranque de Nucleus SE.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobre el autor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls ha trabajado en la industria electr√≥nica durante m√°s de treinta a√±os, dedicando la mayor parte de su tiempo al firmware. </font><font style="vertical-align: inherit;">Ahora es ingeniero de firmware en Mentor Embedded (una divisi√≥n de Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art√≠culos t√©cnicos y dos libros sobre firmware. </font><font style="vertical-align: inherit;">Vive en el Reino Unido. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> profesional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">de Colin</font></a><font style="vertical-align: inherit;"> , correo electr√≥nico: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458770/">https://habr.com/ru/post/458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458758/index.html">El esplendor y la pobreza de la literatura traducida.</a></li>
<li><a href="../458760/index.html">La exposici√≥n de Las Vegas es para desarrolladores de electr√≥nica, no para consumidores. Un informe de la conferencia de automatizaci√≥n de dise√±o</a></li>
<li><a href="../458764/index.html">Pr√°cticas √°giles b√°sicas para equipos t√©cnicos y no t√©cnicos en 2019</a></li>
<li><a href="../458766/index.html">IronPython del lado del mal: c√≥mo descubrimos un ciberataque a los servicios p√∫blicos en un pa√≠s europeo</a></li>
<li><a href="../458768/index.html">5-6 razones para venir a GolangConf</a></li>
<li><a href="../458774/index.html">DBMS funcional</a></li>
<li><a href="../458778/index.html">Satellite 6.5 Reporting Engine: qu√© y por qu√©</a></li>
<li><a href="../458782/index.html">Adaptaci√≥n de programas para ZX Spectrum a TR-DOS por medios modernos. Parte 3</a></li>
<li><a href="../458784/index.html">Transmita proyectos y bibliotecas de Altium Designer a PADS Professional</a></li>
<li><a href="../458786/index.html">Los guardianes de los videojuegos mantienen la cultura del juego paso a paso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>