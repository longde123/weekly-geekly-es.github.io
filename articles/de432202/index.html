<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚ÄçüöÄ ü§ú üíù Charaktertypen im laufenden Betrieb generieren (oder verr√ºckt nach Rust) ü•© üëßüèø üò†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir uns √ºber die Programmiersprache Rust und insbesondere √ºber Merkmalsobjekte lustig machen. 


 Als ich Rust kennenlernte, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Charaktertypen im laufenden Betrieb generieren (oder verr√ºckt nach Rust)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432202/"><p>  In diesem Artikel werden wir uns √ºber die Programmiersprache Rust und insbesondere √ºber Merkmalsobjekte lustig machen. </p><br><p>  Als ich Rust kennenlernte, erschien mir eines der Details der Implementierung von Typobjekten interessant.  Die Tatsache, dass sich die virtuelle Funktionstabelle nicht in den Daten selbst befindet, sondern im "dicken" Zeiger darauf.  Jeder Zeiger auf ein Typobjekt enth√§lt einen Zeiger auf die Daten selbst sowie eine Verkn√ºpfung zu einer virtuellen Tabelle, in der sich die Adressen von Funktionen befinden, die dieses Typobjekt f√ºr eine bestimmte Struktur implementieren (da dies jedoch ein Implementierungsdetail ist, kann sich das Verhalten √§ndern. </p><a name="habracut"></a><br><p>  Beginnen wir mit einem einfachen Beispiel, das dicke Zeiger demonstriert.  Der folgende Code wird auf der 64-Bit-Architektur 8 und 16 ausgegeben: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = &amp;<span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disp: &amp;std::fmt::Display = v; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, std::mem::size_of_val(&amp;v)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   -: {}"</span></span>, std::mem::size_of_val(&amp;disp)); }</code> </pre> <br><p>  Warum ist das interessant?  Als ich mich mit Enterprise Java besch√§ftigte, war eine der Aufgaben, die ziemlich regelm√§√üig auftraten, die Anpassung vorhandener Objekte an bestimmte Schnittstellen.  Das hei√üt, das Objekt ist bereits vorhanden und wird als Link ausgegeben. Es muss jedoch an die angegebene Schnittstelle angepasst werden.  Und Sie k√∂nnen das Eingabeobjekt nicht √§ndern, es ist das, was es ist. </p><br><p>  Ich musste so etwas tun: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adapt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Json value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...- , , ,  "value"  //   Person return new PersonJsonAdapter(value); }</span></span></code> </pre> <br><p>  Bei diesem Ansatz gab es verschiedene Probleme.  Wenn sich beispielsweise dasselbe Objekt zweimal "anpasst", erhalten wir zwei verschiedene <code>Person</code> (aus Sicht des Linkvergleichs).  Und die Tatsache, dass Sie jedes Mal neue Objekte erstellen m√ºssen, ist irgendwie h√§sslich. </p><br><p>  Als ich in Rust Typobjekte sah, kam mir die Idee, dass es in Rust viel eleganter gemacht werden k√∂nnte!  Sie k√∂nnen den Daten auch eine andere virtuelle Tabelle zuweisen und ein neues Merkmalsobjekt erhalten!  Und weisen Sie nicht jeder Instanz Speicher zu.  Gleichzeitig bleibt die gesamte Logik des "Ausleihens" bestehen - unsere Anpassungsfunktion sieht aus wie <code>fn adapt&lt;'a&gt;(value: &amp;'a Json) -&gt; &amp;'a Person</code> (das hei√üt, wir leihen uns aus) Quelldaten). </p><br><p>  Dar√ºber hinaus k√∂nnen Sie denselben Typ (z. B. <code>String</code> ) zwingen, unser Typobjekt mehrmals mit unterschiedlichem Verhalten zu implementieren.  Warum?  Aber Sie wissen nie, was im Unternehmen ben√∂tigt werden kann ?! </p><br><p>  Versuchen wir dies umzusetzen. </p><br><h2 id="postanovka-zadachi">  Erkl√§rung des Problems </h2><br><p>  Wir setzen die Aufgabe folgenderma√üen: Erstellen Sie die <code>annotate</code> Funktion, die dem regul√§ren <code>String</code> Typ das folgende <code>annotate</code> "zuweist": </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; }</code> </pre> <br><p>  Und die <code>annotate</code> Funktion selbst: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///    - `Object`,   , ///   "" -- ,    `type_name`. fn annotate&lt;'a&gt;(input: &amp;'a String, type_name: &amp;str) -&gt; &amp;'a dyn Object { // ... }</span></span></code> </pre> <br><p>  Schreiben wir gleich einen Test.  Stellen Sie zun√§chst sicher, dass der "zugewiesene" Typ mit dem erwarteten √ºbereinstimmt.  Zweitens stellen wir sicher, dass wir die urspr√ºngliche Linie erhalten k√∂nnen und es sich um dieselbe Linie handelt (aus Sicht der Zeiger): </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated1 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Widget"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated2 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Gadget"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -   ,    assert_eq!("Widget", annotated1.type_name()); assert_eq!("Gadget", annotated2.type_name()); let unwrapped1 = annotated1.as_string(); let unwrapped2 = annotated2.as_string(); //       --   assert_eq!(unwrapped1 as *const String, &amp;input as *const String); assert_eq!(unwrapped2 as *const String, &amp;input as *const String); }</span></span></code> </pre> <br><h2 id="podhod-1-a-posle-nas-hot-potop">  Ansatz Nummer 1: und nach uns zumindest eine Flut! </h2><br><p>  Versuchen wir zun√§chst, eine v√∂llig naive Implementierung durchzuf√ºhren.  Wickeln Sie unsere Daten einfach in einen "Wrapper", der zus√§tzlich <code>type_name</code> enth√§lt: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { value: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value } }</code> </pre> <br><p>  Noch nichts Besonderes.  Alles ist wie in Java.  Aber wir haben keinen M√ºllsammler. Wo werden wir diesen Wrapper aufbewahren?  Wir m√ºssen den Link zur√ºckgeben, damit er nach dem Aufrufen der <code>annotate</code> Funktion g√ºltig bleibt.  Wir werden etwas Unheimliches in die <code>Box</code> legen, damit der <code>Wrapper</code> auf dem Haufen hervorgehoben wird.  Und dann werden wir den Link dazu zur√ºckgeben.  Und damit der Wrapper nach dem Aufrufen der <code>annotate</code> Funktion am Leben bleibt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"lecken"</a> wir diese Box: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(Wrapper { value: input, type_name: type_name.into(), }); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::leak(b) }</code> </pre> <br><p>  ... und der Test besteht! </p><br><p>  Dies ist jedoch eine zweifelhafte Entscheidung.  Wir weisen nicht nur immer noch Speicher f√ºr jede "Annotation" zu, so dass der Speicher <code>Box::leak</code> ( <code>Box::leak</code> gibt einen Link zu den auf dem Heap gespeicherten Daten zur√ºck, sondern "vergisst" gleichzeitig die Box selbst, dh es erfolgt keine automatische Freigabe ) </p><br><h2 id="podhod-2-arena">  Ansatz 2: Arena! </h2><br><p>  Lassen Sie uns zun√§chst versuchen, diese Wrapper irgendwo zu speichern, damit sie dennoch irgendwann freigegeben werden.  Gleichzeitig bleibt jedoch die <code>annotate</code> unver√§ndert.  Das hei√üt, die R√ºckgabe eines Links mit Referenzz√§hlung (z. B. <code>Rc&lt;Wrapper&gt;</code> ) funktioniert nicht. </p><br><p>  Die einfachste M√∂glichkeit besteht darin, eine Hilfsstruktur zu erstellen, ein "Typsystem", das f√ºr die Speicherung dieser Wrapper verantwortlich ist.  Und wenn wir fertig sind, werden wir diese Struktur und alle Wrapper damit freigeben. </p><br><p>  Irgendwie so.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>typed-arena</code></a> Bibliothek wird zum Speichern von Wrappern verwendet, aber Sie k√∂nnten mit dem <code>Vec&lt;Box&lt;Wrapper&gt;&gt;</code> auskommen. Die Hauptsache ist, sicherzustellen, dass sich <code>Wrapper</code> nirgendwo bewegt (in Night Rust k√∂nnen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pin-API</a> daf√ºr verwenden): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { wrappers: typed_arena::Arena&lt;Wrapper&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { wrappers: typed_arena::Arena::new(), } } <span class="hljs-comment"><span class="hljs-comment">///     `input`,      , ///    (  ,    , ///        )! pub fn annotate&lt;'a: 'b, 'b&gt;( &amp;'a self, input: &amp;'b String, type_name: &amp;str ) -&gt; &amp;'b dyn Object { self.wrappers.alloc(Wrapper { value: input, type_name: type_name.into(), }) } }</span></span></code> </pre> <br><p>  Aber wohin ging der Parameter, der f√ºr die Lebensdauer des Links f√ºr den <code>Wrapper</code> Typ verantwortlich ist?  Wir mussten es loswerden, da wir dem Typ <code>typed_arena::Arena&lt;Wrapper&lt;'?&gt;&gt;</code> feste Lebensdauer nicht <code>typed_arena::Arena&lt;Wrapper&lt;'?&gt;&gt;</code> .  Jeder Wrapper hat je nach <code>input</code> einen eindeutigen Parameter! </p><br><p>  Stattdessen streuen wir etwas unsicheren Rost dar√ºber, um den Parameter f√ºr die Lebensdauer zu entfernen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span> { value: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-comment"><span class="hljs-comment">///   -- ,     (  /// `annotate`),     (    - /// `&amp;Object`)  ,      (`String`). fn as_string(&amp;self) -&gt; &amp;String { unsafe { &amp;*self.value } } }</span></span></code> </pre> <br><p>  Und die Tests bestehen erneut und geben uns Vertrauen in die Richtigkeit der Entscheidung.  Zus√§tzlich dazu, dass Sie sich mit <code>unsafe</code> Material unwohl f√ºhlen (wie es sein sollte, ist es besser, nicht mit unsicherem Rost zu scherzen!). </p><br><p>  Was ist jedoch mit der versprochenen Option, f√ºr die keine zus√§tzlichen Speicherzuweisungen f√ºr Wrapper erforderlich sind? </p><br><h2 id="podhod-3-da-razverznutsya-vrata-ada">  Ansatz 3: Lass die Tore der H√∂lle √∂ffnen </h2><br><p>  Idee.  F√ºr jeden eindeutigen "Typ" ("Widget", "Gadget") erstellen wir eine virtuelle Tabelle.  H√§nde w√§hrend der Ausf√ºhrung des Programms.  Und wir weisen es dem Link zu, der uns von den Daten selbst gegeben wird (was, wie wir uns erinnern, einfach <code>String</code> ). </p><br><p>  Zun√§chst eine kurze Beschreibung dessen, was wir bekommen m√ºssen.  Wie ist ein Verweis auf ein Typobjekt angeordnet?  Tats√§chlich sind dies nur zwei Zeiger, einer auf die Daten selbst und der andere auf die virtuelle Tabelle.  Also schreiben wir: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TraitObject</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> data: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vtable: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), }</code> </pre> <br><p>  ( <code>#[repr(C)]</code> wir m√ºssen den korrekten Speicherort im Speicher garantieren). </p><br><p>  Es scheint, dass alles einfach ist, wir werden eine neue Tabelle f√ºr die angegebenen Parameter generieren und einen Link zum Typobjekt "sammeln"!  Aber woraus besteht diese Tabelle? </p><br><p>  Die richtige Antwort auf diese Frage w√§re "Dies ist ein Implementierungsdetail."  Aber wir werden es tun;  Erstellen Sie eine <code>rust-toolchain</code> Datei im Stammverzeichnis unseres Projekts und schreiben Sie sie dort: <code>nightly-2018-12-01</code> .  Eine feste Baugruppe kann doch als stabil angesehen werden, oder? </p><br><p>  Nachdem wir die Rust-Version repariert haben (tats√§chlich ben√∂tigen wir die n√§chtliche Assembly f√ºr eine der folgenden Bibliotheken). </p><br><p>  Nach einiger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suche im Internet stellen</a> wir fest, dass das Tabellenformat einfach ist: Zuerst gibt es eine Verkn√ºpfung zum Destruktor, dann zwei Felder, die der Speicherzuweisung zugeordnet sind (Typgr√∂√üe und Ausrichtung), und dann werden Funktionen nacheinander ausgef√ºhrt (die Reihenfolge liegt im Ermessen des Compilers, aber wir haben nur zwei Funktionen, daher ist die Wahrscheinlichkeit des Raten ziemlich hoch (50%). </p><br><p>  Also schreiben wir: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Copy)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VirtualTableHeader</span></span></span></span> { destructor_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ()), size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, align: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectVirtualTable</span></span></span></span> { header: VirtualTableHeader, type_name_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, as_string_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  In √§hnlicher Weise wird <code>#[repr(C)]</code> ben√∂tigt, um die korrekte Position im Speicher zu gew√§hrleisten.  Ich habe mich in zwei Strukturen aufgeteilt, wenig sp√§ter wird es uns n√ºtzlich sein. </p><br><p>  Versuchen wir nun, unser Typsystem zu schreiben, das die <code>annotate</code> Funktion bereitstellt.  Wir m√ºssen die generierten Tabellen zwischenspeichern, also holen wir uns den Cache: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeInfo</span></span></span></span> { vtable: ObjectVirtualTable, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Default)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { infos: RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, TypeInfo&gt;&gt;, }</code> </pre> <br><p>  Wir verwenden den internen Status von <code>RefCell</code> damit unsere <code>TypeSystem::annotate</code> Funktion <code>&amp;self</code> als gemeinsamen Link empfangen kann.  Dies ist wichtig, da wir uns von <code>TypeSystem</code> ‚Äûausleihen‚Äú, um sicherzustellen, dass die von uns generierten virtuellen Tabellen l√§nger leben als der Verweis auf das <code>TypeSystem</code> , das wir von <code>annotate</code> . </p><br><p>  Da wir in der Lage sein m√∂chten, viele Instanzen mit Anmerkungen zu versehen, k√∂nnen wir uns nicht als ver√§nderbare Verbindung ausleihen <code>&amp;mut self</code> . </p><br><p>  Und wir skizzieren diesen Code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;( &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> infos = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.infos.borrow_mut(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imp = infos.entry(type_name).or_insert_with(|| <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,  ? let vtable = unimplemented!(); TypeInfo { vtable } }); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; //       - unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } } }</span></span></code> </pre> <br><p>  Woher bekommen wir diesen Tisch?  Die ersten drei Eintr√§ge stimmen mit den Eintr√§gen f√ºr jede andere virtuelle Tabelle f√ºr den angegebenen Typ √ºberein.  Nehmen Sie sie daher einfach und kopieren Sie sie.  Lassen Sie uns zuerst diesen Typ erhalten: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Whatever</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Whatever <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> T {}</code> </pre> <br><p>  Es ist n√ºtzlich f√ºr uns, diese "jede andere virtuelle Tabelle" zu erhalten.  Und dann kopieren wir diese drei Eintr√§ge von ihm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever = input <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Whatever; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_vtable_header = whatever_obj.vtable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VirtualTableHeader; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vtable = ObjectVirtualTable { <span class="hljs-comment"><span class="hljs-comment">//  ! header: *whatever_vtable_header, type_name_fn: unimplemented!(), as_string_fn: unimplemented!(), }; TypeInfo { vtable }</span></span></code> </pre> <br><p>  Im Prinzip k√∂nnten wir die Gr√∂√üe und Ausrichtung durch <code>std::mem::size_of::&lt;String&gt;()</code> und <code>std::mem::align_of::&lt;String&gt;()</code> .  Aber wo sonst kann der Destruktor "gestohlen" werden, wei√ü ich nicht. </p><br><p>  Ok, aber woher bekommen wir die Adressen dieser Funktionen, <code>type_name_fn</code> und <code>as_string_fn</code> ?  M√∂glicherweise stellen Sie fest, dass <code>as_string_fn</code> im Allgemeinen nicht ben√∂tigt wird. Der Datenzeiger wird immer als erster Datensatz in der Darstellung des <code>as_string_fn</code> .  Das hei√üt, diese Funktion ist immer dieselbe: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... fn as_string(&amp;self) -&gt; String { self } }</span></span></code> </pre> <br><p>  Aber mit der zweiten Funktion ist es nicht so einfach!  Es h√§ngt auch von unserem Namen "Typ", <code>type_name</code> . </p><br><p>  Es spielt keine Rolle, wir k√∂nnen diese Funktion nur zur Laufzeit generieren.  Nehmen wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>dynasm</code></a> Bibliothek daf√ºr (im Moment erfordert es Rust Nightly Build).  Lesen Sie √ºber <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsaufrufkonventionen</a> . </p><br><p>  Nehmen wir zur Vereinfachung an, wir interessieren uns nur f√ºr Mac OS und Linux (nach all diesen lustigen Transformationen st√∂rt uns die Kompatibilit√§t nicht mehr wirklich, oder?).  Und nat√ºrlich ausschlie√ülich x86-64. </p><br><p>  Die zweite Funktion, <code>as_string</code> , ist einfach zu implementieren.  Wir werden versprochen, dass der erste Parameter im <code>RDI</code> Register sein wird.  Und geben Sie den Wert an <code>RAX</code> .  Das hei√üt, der Funktionscode lautet ungef√§hr so: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, rdi ; ret );</code> </pre> <br><p>  Die erste Funktion ist jedoch etwas kniffliger.  Zuerst m√ºssen wir <code>&amp;str</code> , was ein dicker Zeiger ist.  Der erste Teil ist ein Zeiger auf eine Zeichenfolge, und der zweite Teil ist die L√§nge des Zeichenfolgenabschnitts.  Gl√ºcklicherweise k√∂nnen Sie mit der obigen Konvention 128-Bit-Ergebnisse mithilfe des <code>EDX</code> Registers f√ºr den zweiten Teil zur√ºckgeben. </p><br><p>  Es bleibt noch irgendwo ein Link zu einem String-Slice, der unseren String- <code>type_name</code> enth√§lt.  Wir m√∂chten uns nicht auf <code>type_name</code> (obwohl wir durch lebenslange Anmerkungen garantieren k√∂nnen, dass <code>type_name</code> l√§nger als der zur√ºckgegebene Wert lebt). </p><br><p>  Aber wir haben eine Kopie dieser Zeile, die wir in die Hash-Tabelle einf√ºgen.  Wenn wir die Daumen <code>String::as_str</code> , gehen wir davon aus, dass sich die Position des String-Slice, den <code>String::as_str</code> nicht <code>String::as_str</code> , nicht durch Verschieben des <code>String::as_str</code> <code>String</code> √§ndert (und <code>String</code> wird sich beim √Ñndern der Gr√∂√üe der <code>HashMap</code> in der dieser String vom Schl√ºssel gespeichert wird).  Ich wei√ü nicht, ob die Standardbibliothek dieses Verhalten garantiert, aber spielen wir es einfach? </p><br><p>  Wir bekommen die notwendigen Komponenten: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_ptr = type_name.as_str().as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_len = type_name.as_str().len();</code> </pre> <br><p>  Und schreibe diese Funktion: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, QWORD type_name_ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; mov rdx, QWORD type_name_len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; ret );</code> </pre> <br><p>  Und schlie√ülich der letzte <code>annotate</code> Code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-comment"><span class="hljs-comment">//       let type_name_ptr = type_name.as_str().as_ptr(); let type_name_len = type_name.as_str().len(); let mut infos = self.infos.borrow_mut(); let imp = infos.entry(type_name).or_insert_with(|| unsafe { let mut ops = dynasmrt::x64::Assembler::new().unwrap(); //     `type_name` let type_name_offset = ops.offset(); dynasm!(ops ; mov rax, QWORD type_name_ptr as i64 ; mov rdx, QWORD type_name_len as i64 ; ret ); //     `as_string` let as_string_offset = ops.offset(); dynasm!(ops ; mov rax, rdi ; ret ); let buffer = ops.finalize().unwrap(); //      let whatever = input as &amp;dyn Whatever; let whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); let whatever_vtable_header = whatever_obj.vtable as *const VirtualTableHeader; let vtable = ObjectVirtualTable { header: *whatever_vtable_header, type_name_fn: std::mem::transmute(buffer.ptr(type_name_offset)), as_string_fn: std::mem::transmute(buffer.ptr(as_string_offset)), }; TypeInfo { vtable, buffer } }); assert_eq!(imp.vtable.header.size, std::mem::size_of::&lt;String&gt;()); assert_eq!(imp.vtable.header.align, std::mem::align_of::&lt;String&gt;()); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } }</span></span></code> </pre> <br><p>  F√ºr <code>dynasm</code> wir auch das <code>buffer</code> zu unserer <code>TypeInfo</code> Struktur <code>TypeInfo</code> .  Dieses Feld steuert den Speicher, in dem der Code unserer generierten Funktionen gespeichert ist: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused)]</span></span> buffer: dynasmrt::ExecutableBuffer,</code> </pre> <br><p>  Und alle Tests bestehen! </p><br><h2 id="gotovo-master">  Fertig, Meister! </h2><br><p>  So einfach und nat√ºrlich k√∂nnen Sie Ihre eigene Implementierung von Typobjekten in Rust-Code generieren! </p><br><p>  Die letztere L√∂sung st√ºtzt sich aktiv auf Implementierungsdetails und wird daher nicht zur Verwendung empfohlen.  Aber in Wirklichkeit muss man tun, was man muss.  Verzweifelte Zeiten erfordern verzweifelte Ma√ünahmen! </p><br><p>  Es gibt jedoch eine (mehrere) Funktion, auf die ich mich hier verlasse.  Das hei√üt, dass es sicher ist, den von der Tabelle virtuell belegten Speicher freizugeben, nachdem keine Verweise auf das Typobjekt vorhanden sind, das sie verwendet.  Einerseits ist es logisch, dass Sie eine virtuelle Tabelle nur durch Verweise auf Typobjekte verwenden k√∂nnen.  Auf der anderen Seite haben von Rust bereitgestellte Tabellen eine <code>'static</code> Lebensdauer.  Es ist durchaus m√∂glich, einen Code anzunehmen, der die Tabelle f√ºr einige ihrer Zwecke vom Link trennt (Sie wissen zum Beispiel f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige seiner schmutzigen Tricks nie</a> ). </p><br><p>  Quellcode finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432202/">https://habr.com/ru/post/de432202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432190/index.html">Client-seitige Physikvorhersage in Unity</a></li>
<li><a href="../de432192/index.html">4 Anzeichen daf√ºr, dass Sie nicht bereit sind, eine Projektmanagementl√∂sung zu implementieren</a></li>
<li><a href="../de432196/index.html">Informationen zur Funktionszusammensetzung in JavaScript</a></li>
<li><a href="../de432198/index.html">Delivery Manager - Eine neue Rolle in der agilen Welt</a></li>
<li><a href="../de432200/index.html">Wie Ivan die Standumwandlung untersuchte</a></li>
<li><a href="../de432204/index.html">Seminar ‚Äû20 kleine Dinge, die die Arbeit im Rechenzentrum wirklich komfortabel machen‚Äú, 13. Dezember, Moskau</a></li>
<li><a href="../de432206/index.html">Eine detaillierte Analyse dessen, was Google auf der FlutterLive-Konferenz gezeigt hat (und was es f√ºr Dart und die Welt bedeutet)</a></li>
<li><a href="../de432208/index.html">Kubernetes 1.13: √úberblick √ºber wichtige Innovationen</a></li>
<li><a href="../de432210/index.html">Qualcomm stellte die Snapdragon 855-Plattform mit 5G-Unterst√ºtzung vor</a></li>
<li><a href="../de432212/index.html">7 Jahre Bildungsprojekte Mail.Ru Group: Erfahrungsaustausch in den Hauptbereichen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>