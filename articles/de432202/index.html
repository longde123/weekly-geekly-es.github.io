<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚀 🤜 💝 Charaktertypen im laufenden Betrieb generieren (oder verrückt nach Rust) 🥩 👧🏿 😠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir uns über die Programmiersprache Rust und insbesondere über Merkmalsobjekte lustig machen. 


 Als ich Rust kennenlernte, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Charaktertypen im laufenden Betrieb generieren (oder verrückt nach Rust)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432202/"><p>  In diesem Artikel werden wir uns über die Programmiersprache Rust und insbesondere über Merkmalsobjekte lustig machen. </p><br><p>  Als ich Rust kennenlernte, erschien mir eines der Details der Implementierung von Typobjekten interessant.  Die Tatsache, dass sich die virtuelle Funktionstabelle nicht in den Daten selbst befindet, sondern im "dicken" Zeiger darauf.  Jeder Zeiger auf ein Typobjekt enthält einen Zeiger auf die Daten selbst sowie eine Verknüpfung zu einer virtuellen Tabelle, in der sich die Adressen von Funktionen befinden, die dieses Typobjekt für eine bestimmte Struktur implementieren (da dies jedoch ein Implementierungsdetail ist, kann sich das Verhalten ändern. </p><a name="habracut"></a><br><p>  Beginnen wir mit einem einfachen Beispiel, das dicke Zeiger demonstriert.  Der folgende Code wird auf der 64-Bit-Architektur 8 und 16 ausgegeben: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = &amp;<span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disp: &amp;std::fmt::Display = v; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, std::mem::size_of_val(&amp;v)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   -: {}"</span></span>, std::mem::size_of_val(&amp;disp)); }</code> </pre> <br><p>  Warum ist das interessant?  Als ich mich mit Enterprise Java beschäftigte, war eine der Aufgaben, die ziemlich regelmäßig auftraten, die Anpassung vorhandener Objekte an bestimmte Schnittstellen.  Das heißt, das Objekt ist bereits vorhanden und wird als Link ausgegeben. Es muss jedoch an die angegebene Schnittstelle angepasst werden.  Und Sie können das Eingabeobjekt nicht ändern, es ist das, was es ist. </p><br><p>  Ich musste so etwas tun: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adapt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Json value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...- , , ,  "value"  //   Person return new PersonJsonAdapter(value); }</span></span></code> </pre> <br><p>  Bei diesem Ansatz gab es verschiedene Probleme.  Wenn sich beispielsweise dasselbe Objekt zweimal "anpasst", erhalten wir zwei verschiedene <code>Person</code> (aus Sicht des Linkvergleichs).  Und die Tatsache, dass Sie jedes Mal neue Objekte erstellen müssen, ist irgendwie hässlich. </p><br><p>  Als ich in Rust Typobjekte sah, kam mir die Idee, dass es in Rust viel eleganter gemacht werden könnte!  Sie können den Daten auch eine andere virtuelle Tabelle zuweisen und ein neues Merkmalsobjekt erhalten!  Und weisen Sie nicht jeder Instanz Speicher zu.  Gleichzeitig bleibt die gesamte Logik des "Ausleihens" bestehen - unsere Anpassungsfunktion sieht aus wie <code>fn adapt&lt;'a&gt;(value: &amp;'a Json) -&gt; &amp;'a Person</code> (das heißt, wir leihen uns aus) Quelldaten). </p><br><p>  Darüber hinaus können Sie denselben Typ (z. B. <code>String</code> ) zwingen, unser Typobjekt mehrmals mit unterschiedlichem Verhalten zu implementieren.  Warum?  Aber Sie wissen nie, was im Unternehmen benötigt werden kann ?! </p><br><p>  Versuchen wir dies umzusetzen. </p><br><h2 id="postanovka-zadachi">  Erklärung des Problems </h2><br><p>  Wir setzen die Aufgabe folgendermaßen: Erstellen Sie die <code>annotate</code> Funktion, die dem regulären <code>String</code> Typ das folgende <code>annotate</code> "zuweist": </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; }</code> </pre> <br><p>  Und die <code>annotate</code> Funktion selbst: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///    - `Object`,   , ///   "" -- ,    `type_name`. fn annotate&lt;'a&gt;(input: &amp;'a String, type_name: &amp;str) -&gt; &amp;'a dyn Object { // ... }</span></span></code> </pre> <br><p>  Schreiben wir gleich einen Test.  Stellen Sie zunächst sicher, dass der "zugewiesene" Typ mit dem erwarteten übereinstimmt.  Zweitens stellen wir sicher, dass wir die ursprüngliche Linie erhalten können und es sich um dieselbe Linie handelt (aus Sicht der Zeiger): </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated1 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Widget"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated2 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Gadget"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -   ,    assert_eq!("Widget", annotated1.type_name()); assert_eq!("Gadget", annotated2.type_name()); let unwrapped1 = annotated1.as_string(); let unwrapped2 = annotated2.as_string(); //       --   assert_eq!(unwrapped1 as *const String, &amp;input as *const String); assert_eq!(unwrapped2 as *const String, &amp;input as *const String); }</span></span></code> </pre> <br><h2 id="podhod-1-a-posle-nas-hot-potop">  Ansatz Nummer 1: und nach uns zumindest eine Flut! </h2><br><p>  Versuchen wir zunächst, eine völlig naive Implementierung durchzuführen.  Wickeln Sie unsere Daten einfach in einen "Wrapper", der zusätzlich <code>type_name</code> enthält: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { value: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value } }</code> </pre> <br><p>  Noch nichts Besonderes.  Alles ist wie in Java.  Aber wir haben keinen Müllsammler. Wo werden wir diesen Wrapper aufbewahren?  Wir müssen den Link zurückgeben, damit er nach dem Aufrufen der <code>annotate</code> Funktion gültig bleibt.  Wir werden etwas Unheimliches in die <code>Box</code> legen, damit der <code>Wrapper</code> auf dem Haufen hervorgehoben wird.  Und dann werden wir den Link dazu zurückgeben.  Und damit der Wrapper nach dem Aufrufen der <code>annotate</code> Funktion am Leben bleibt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"lecken"</a> wir diese Box: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(Wrapper { value: input, type_name: type_name.into(), }); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::leak(b) }</code> </pre> <br><p>  ... und der Test besteht! </p><br><p>  Dies ist jedoch eine zweifelhafte Entscheidung.  Wir weisen nicht nur immer noch Speicher für jede "Annotation" zu, so dass der Speicher <code>Box::leak</code> ( <code>Box::leak</code> gibt einen Link zu den auf dem Heap gespeicherten Daten zurück, sondern "vergisst" gleichzeitig die Box selbst, dh es erfolgt keine automatische Freigabe ) </p><br><h2 id="podhod-2-arena">  Ansatz 2: Arena! </h2><br><p>  Lassen Sie uns zunächst versuchen, diese Wrapper irgendwo zu speichern, damit sie dennoch irgendwann freigegeben werden.  Gleichzeitig bleibt jedoch die <code>annotate</code> unverändert.  Das heißt, die Rückgabe eines Links mit Referenzzählung (z. B. <code>Rc&lt;Wrapper&gt;</code> ) funktioniert nicht. </p><br><p>  Die einfachste Möglichkeit besteht darin, eine Hilfsstruktur zu erstellen, ein "Typsystem", das für die Speicherung dieser Wrapper verantwortlich ist.  Und wenn wir fertig sind, werden wir diese Struktur und alle Wrapper damit freigeben. </p><br><p>  Irgendwie so.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>typed-arena</code></a> Bibliothek wird zum Speichern von Wrappern verwendet, aber Sie könnten mit dem <code>Vec&lt;Box&lt;Wrapper&gt;&gt;</code> auskommen. Die Hauptsache ist, sicherzustellen, dass sich <code>Wrapper</code> nirgendwo bewegt (in Night Rust können Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pin-API</a> dafür verwenden): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { wrappers: typed_arena::Arena&lt;Wrapper&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { wrappers: typed_arena::Arena::new(), } } <span class="hljs-comment"><span class="hljs-comment">///     `input`,      , ///    (  ,    , ///        )! pub fn annotate&lt;'a: 'b, 'b&gt;( &amp;'a self, input: &amp;'b String, type_name: &amp;str ) -&gt; &amp;'b dyn Object { self.wrappers.alloc(Wrapper { value: input, type_name: type_name.into(), }) } }</span></span></code> </pre> <br><p>  Aber wohin ging der Parameter, der für die Lebensdauer des Links für den <code>Wrapper</code> Typ verantwortlich ist?  Wir mussten es loswerden, da wir dem Typ <code>typed_arena::Arena&lt;Wrapper&lt;'?&gt;&gt;</code> feste Lebensdauer nicht <code>typed_arena::Arena&lt;Wrapper&lt;'?&gt;&gt;</code> .  Jeder Wrapper hat je nach <code>input</code> einen eindeutigen Parameter! </p><br><p>  Stattdessen streuen wir etwas unsicheren Rost darüber, um den Parameter für die Lebensdauer zu entfernen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span> { value: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-comment"><span class="hljs-comment">///   -- ,     (  /// `annotate`),     (    - /// `&amp;Object`)  ,      (`String`). fn as_string(&amp;self) -&gt; &amp;String { unsafe { &amp;*self.value } } }</span></span></code> </pre> <br><p>  Und die Tests bestehen erneut und geben uns Vertrauen in die Richtigkeit der Entscheidung.  Zusätzlich dazu, dass Sie sich mit <code>unsafe</code> Material unwohl fühlen (wie es sein sollte, ist es besser, nicht mit unsicherem Rost zu scherzen!). </p><br><p>  Was ist jedoch mit der versprochenen Option, für die keine zusätzlichen Speicherzuweisungen für Wrapper erforderlich sind? </p><br><h2 id="podhod-3-da-razverznutsya-vrata-ada">  Ansatz 3: Lass die Tore der Hölle öffnen </h2><br><p>  Idee.  Für jeden eindeutigen "Typ" ("Widget", "Gadget") erstellen wir eine virtuelle Tabelle.  Hände während der Ausführung des Programms.  Und wir weisen es dem Link zu, der uns von den Daten selbst gegeben wird (was, wie wir uns erinnern, einfach <code>String</code> ). </p><br><p>  Zunächst eine kurze Beschreibung dessen, was wir bekommen müssen.  Wie ist ein Verweis auf ein Typobjekt angeordnet?  Tatsächlich sind dies nur zwei Zeiger, einer auf die Daten selbst und der andere auf die virtuelle Tabelle.  Also schreiben wir: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TraitObject</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> data: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vtable: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), }</code> </pre> <br><p>  ( <code>#[repr(C)]</code> wir müssen den korrekten Speicherort im Speicher garantieren). </p><br><p>  Es scheint, dass alles einfach ist, wir werden eine neue Tabelle für die angegebenen Parameter generieren und einen Link zum Typobjekt "sammeln"!  Aber woraus besteht diese Tabelle? </p><br><p>  Die richtige Antwort auf diese Frage wäre "Dies ist ein Implementierungsdetail."  Aber wir werden es tun;  Erstellen Sie eine <code>rust-toolchain</code> Datei im Stammverzeichnis unseres Projekts und schreiben Sie sie dort: <code>nightly-2018-12-01</code> .  Eine feste Baugruppe kann doch als stabil angesehen werden, oder? </p><br><p>  Nachdem wir die Rust-Version repariert haben (tatsächlich benötigen wir die nächtliche Assembly für eine der folgenden Bibliotheken). </p><br><p>  Nach einiger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suche im Internet stellen</a> wir fest, dass das Tabellenformat einfach ist: Zuerst gibt es eine Verknüpfung zum Destruktor, dann zwei Felder, die der Speicherzuweisung zugeordnet sind (Typgröße und Ausrichtung), und dann werden Funktionen nacheinander ausgeführt (die Reihenfolge liegt im Ermessen des Compilers, aber wir haben nur zwei Funktionen, daher ist die Wahrscheinlichkeit des Raten ziemlich hoch (50%). </p><br><p>  Also schreiben wir: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Copy)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VirtualTableHeader</span></span></span></span> { destructor_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ()), size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, align: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectVirtualTable</span></span></span></span> { header: VirtualTableHeader, type_name_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, as_string_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  In ähnlicher Weise wird <code>#[repr(C)]</code> benötigt, um die korrekte Position im Speicher zu gewährleisten.  Ich habe mich in zwei Strukturen aufgeteilt, wenig später wird es uns nützlich sein. </p><br><p>  Versuchen wir nun, unser Typsystem zu schreiben, das die <code>annotate</code> Funktion bereitstellt.  Wir müssen die generierten Tabellen zwischenspeichern, also holen wir uns den Cache: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeInfo</span></span></span></span> { vtable: ObjectVirtualTable, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Default)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { infos: RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, TypeInfo&gt;&gt;, }</code> </pre> <br><p>  Wir verwenden den internen Status von <code>RefCell</code> damit unsere <code>TypeSystem::annotate</code> Funktion <code>&amp;self</code> als gemeinsamen Link empfangen kann.  Dies ist wichtig, da wir uns von <code>TypeSystem</code> „ausleihen“, um sicherzustellen, dass die von uns generierten virtuellen Tabellen länger leben als der Verweis auf das <code>TypeSystem</code> , das wir von <code>annotate</code> . </p><br><p>  Da wir in der Lage sein möchten, viele Instanzen mit Anmerkungen zu versehen, können wir uns nicht als veränderbare Verbindung ausleihen <code>&amp;mut self</code> . </p><br><p>  Und wir skizzieren diesen Code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;( &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> infos = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.infos.borrow_mut(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imp = infos.entry(type_name).or_insert_with(|| <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,  ? let vtable = unimplemented!(); TypeInfo { vtable } }); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; //       - unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } } }</span></span></code> </pre> <br><p>  Woher bekommen wir diesen Tisch?  Die ersten drei Einträge stimmen mit den Einträgen für jede andere virtuelle Tabelle für den angegebenen Typ überein.  Nehmen Sie sie daher einfach und kopieren Sie sie.  Lassen Sie uns zuerst diesen Typ erhalten: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Whatever</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Whatever <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> T {}</code> </pre> <br><p>  Es ist nützlich für uns, diese "jede andere virtuelle Tabelle" zu erhalten.  Und dann kopieren wir diese drei Einträge von ihm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever = input <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Whatever; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_vtable_header = whatever_obj.vtable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VirtualTableHeader; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vtable = ObjectVirtualTable { <span class="hljs-comment"><span class="hljs-comment">//  ! header: *whatever_vtable_header, type_name_fn: unimplemented!(), as_string_fn: unimplemented!(), }; TypeInfo { vtable }</span></span></code> </pre> <br><p>  Im Prinzip könnten wir die Größe und Ausrichtung durch <code>std::mem::size_of::&lt;String&gt;()</code> und <code>std::mem::align_of::&lt;String&gt;()</code> .  Aber wo sonst kann der Destruktor "gestohlen" werden, weiß ich nicht. </p><br><p>  Ok, aber woher bekommen wir die Adressen dieser Funktionen, <code>type_name_fn</code> und <code>as_string_fn</code> ?  Möglicherweise stellen Sie fest, dass <code>as_string_fn</code> im Allgemeinen nicht benötigt wird. Der Datenzeiger wird immer als erster Datensatz in der Darstellung des <code>as_string_fn</code> .  Das heißt, diese Funktion ist immer dieselbe: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... fn as_string(&amp;self) -&gt; String { self } }</span></span></code> </pre> <br><p>  Aber mit der zweiten Funktion ist es nicht so einfach!  Es hängt auch von unserem Namen "Typ", <code>type_name</code> . </p><br><p>  Es spielt keine Rolle, wir können diese Funktion nur zur Laufzeit generieren.  Nehmen wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>dynasm</code></a> Bibliothek dafür (im Moment erfordert es Rust Nightly Build).  Lesen Sie über <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsaufrufkonventionen</a> . </p><br><p>  Nehmen wir zur Vereinfachung an, wir interessieren uns nur für Mac OS und Linux (nach all diesen lustigen Transformationen stört uns die Kompatibilität nicht mehr wirklich, oder?).  Und natürlich ausschließlich x86-64. </p><br><p>  Die zweite Funktion, <code>as_string</code> , ist einfach zu implementieren.  Wir werden versprochen, dass der erste Parameter im <code>RDI</code> Register sein wird.  Und geben Sie den Wert an <code>RAX</code> .  Das heißt, der Funktionscode lautet ungefähr so: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, rdi ; ret );</code> </pre> <br><p>  Die erste Funktion ist jedoch etwas kniffliger.  Zuerst müssen wir <code>&amp;str</code> , was ein dicker Zeiger ist.  Der erste Teil ist ein Zeiger auf eine Zeichenfolge, und der zweite Teil ist die Länge des Zeichenfolgenabschnitts.  Glücklicherweise können Sie mit der obigen Konvention 128-Bit-Ergebnisse mithilfe des <code>EDX</code> Registers für den zweiten Teil zurückgeben. </p><br><p>  Es bleibt noch irgendwo ein Link zu einem String-Slice, der unseren String- <code>type_name</code> enthält.  Wir möchten uns nicht auf <code>type_name</code> (obwohl wir durch lebenslange Anmerkungen garantieren können, dass <code>type_name</code> länger als der zurückgegebene Wert lebt). </p><br><p>  Aber wir haben eine Kopie dieser Zeile, die wir in die Hash-Tabelle einfügen.  Wenn wir die Daumen <code>String::as_str</code> , gehen wir davon aus, dass sich die Position des String-Slice, den <code>String::as_str</code> nicht <code>String::as_str</code> , nicht durch Verschieben des <code>String::as_str</code> <code>String</code> ändert (und <code>String</code> wird sich beim Ändern der Größe der <code>HashMap</code> in der dieser String vom Schlüssel gespeichert wird).  Ich weiß nicht, ob die Standardbibliothek dieses Verhalten garantiert, aber spielen wir es einfach? </p><br><p>  Wir bekommen die notwendigen Komponenten: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_ptr = type_name.as_str().as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_len = type_name.as_str().len();</code> </pre> <br><p>  Und schreibe diese Funktion: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, QWORD type_name_ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; mov rdx, QWORD type_name_len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; ret );</code> </pre> <br><p>  Und schließlich der letzte <code>annotate</code> Code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-comment"><span class="hljs-comment">//       let type_name_ptr = type_name.as_str().as_ptr(); let type_name_len = type_name.as_str().len(); let mut infos = self.infos.borrow_mut(); let imp = infos.entry(type_name).or_insert_with(|| unsafe { let mut ops = dynasmrt::x64::Assembler::new().unwrap(); //     `type_name` let type_name_offset = ops.offset(); dynasm!(ops ; mov rax, QWORD type_name_ptr as i64 ; mov rdx, QWORD type_name_len as i64 ; ret ); //     `as_string` let as_string_offset = ops.offset(); dynasm!(ops ; mov rax, rdi ; ret ); let buffer = ops.finalize().unwrap(); //      let whatever = input as &amp;dyn Whatever; let whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); let whatever_vtable_header = whatever_obj.vtable as *const VirtualTableHeader; let vtable = ObjectVirtualTable { header: *whatever_vtable_header, type_name_fn: std::mem::transmute(buffer.ptr(type_name_offset)), as_string_fn: std::mem::transmute(buffer.ptr(as_string_offset)), }; TypeInfo { vtable, buffer } }); assert_eq!(imp.vtable.header.size, std::mem::size_of::&lt;String&gt;()); assert_eq!(imp.vtable.header.align, std::mem::align_of::&lt;String&gt;()); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } }</span></span></code> </pre> <br><p>  Für <code>dynasm</code> wir auch das <code>buffer</code> zu unserer <code>TypeInfo</code> Struktur <code>TypeInfo</code> .  Dieses Feld steuert den Speicher, in dem der Code unserer generierten Funktionen gespeichert ist: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused)]</span></span> buffer: dynasmrt::ExecutableBuffer,</code> </pre> <br><p>  Und alle Tests bestehen! </p><br><h2 id="gotovo-master">  Fertig, Meister! </h2><br><p>  So einfach und natürlich können Sie Ihre eigene Implementierung von Typobjekten in Rust-Code generieren! </p><br><p>  Die letztere Lösung stützt sich aktiv auf Implementierungsdetails und wird daher nicht zur Verwendung empfohlen.  Aber in Wirklichkeit muss man tun, was man muss.  Verzweifelte Zeiten erfordern verzweifelte Maßnahmen! </p><br><p>  Es gibt jedoch eine (mehrere) Funktion, auf die ich mich hier verlasse.  Das heißt, dass es sicher ist, den von der Tabelle virtuell belegten Speicher freizugeben, nachdem keine Verweise auf das Typobjekt vorhanden sind, das sie verwendet.  Einerseits ist es logisch, dass Sie eine virtuelle Tabelle nur durch Verweise auf Typobjekte verwenden können.  Auf der anderen Seite haben von Rust bereitgestellte Tabellen eine <code>'static</code> Lebensdauer.  Es ist durchaus möglich, einen Code anzunehmen, der die Tabelle für einige ihrer Zwecke vom Link trennt (Sie wissen zum Beispiel für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige seiner schmutzigen Tricks nie</a> ). </p><br><p>  Quellcode finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432202/">https://habr.com/ru/post/de432202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432190/index.html">Client-seitige Physikvorhersage in Unity</a></li>
<li><a href="../de432192/index.html">4 Anzeichen dafür, dass Sie nicht bereit sind, eine Projektmanagementlösung zu implementieren</a></li>
<li><a href="../de432196/index.html">Informationen zur Funktionszusammensetzung in JavaScript</a></li>
<li><a href="../de432198/index.html">Delivery Manager - Eine neue Rolle in der agilen Welt</a></li>
<li><a href="../de432200/index.html">Wie Ivan die Standumwandlung untersuchte</a></li>
<li><a href="../de432204/index.html">Seminar „20 kleine Dinge, die die Arbeit im Rechenzentrum wirklich komfortabel machen“, 13. Dezember, Moskau</a></li>
<li><a href="../de432206/index.html">Eine detaillierte Analyse dessen, was Google auf der FlutterLive-Konferenz gezeigt hat (und was es für Dart und die Welt bedeutet)</a></li>
<li><a href="../de432208/index.html">Kubernetes 1.13: Überblick über wichtige Innovationen</a></li>
<li><a href="../de432210/index.html">Qualcomm stellte die Snapdragon 855-Plattform mit 5G-Unterstützung vor</a></li>
<li><a href="../de432212/index.html">7 Jahre Bildungsprojekte Mail.Ru Group: Erfahrungsaustausch in den Hauptbereichen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>