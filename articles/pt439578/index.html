<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¶ üè´ ‚ò£Ô∏è √Ä quest√£o das transforma√ß√µes e outras opera√ß√µes üç• üíé üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lagarta Azul: Bem, voc√™ n√£o vai nos derrubar. Sentamo-nos, sabemos: eles est√£o esperando nossa transforma√ß√£o. O que? Mas nada! Sentamos, fumamos, espe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Ä quest√£o das transforma√ß√µes e outras opera√ß√µes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439578/"><h4>  Lagarta Azul: Bem, voc√™ n√£o vai nos derrubar.  Sentamo-nos, sabemos: eles est√£o esperando nossa transforma√ß√£o.  O que?  Mas nada!  Sentamos, fumamos, esperamos ... <br>  Boneca Alice: O que? <br>  Lagarta Azul: O qu√™, por qu√™!  De transforma√ß√µes.  A casa em fuma√ßa, a fuma√ßa em uma dama, e a dama em uma m√£e.  L√° vai voc√™.  N√£o interfira, n√£o pule para a frente, caso contr√°rio voc√™ mesmo se transformar√° prematuramente em algum tipo de borboleta. </h4><br>  Examinando o c√≥digo em um dos f√≥runs dedicados ao Arduino, encontrei uma maneira divertida de trabalhar com um n√∫mero de ponto flutuante (PT).  O segundo nome comum para n√∫meros nesse formato √© ponto flutuante, mas a abrevia√ß√£o (PP) que surge nesse caso pessoalmente causa associa√ß√µes completamente diferentes para mim; portanto, usaremos essa op√ß√£o.  A primeira impress√£o (do c√≥digo que vi) √© que tipo de lixo est√° escrito aqui (devo dizer que o segundo √© o mesmo, embora haja nuances, mas mais sobre isso depois), mas surge a pergunta - como √© realmente necess√°rio - a resposta dada em texto adicional. <br><br><h4>  Parte Um - Questionando </h4><br>  Formulamos o problema - precisamos imprimir no console (transformar em uma representa√ß√£o simb√≥lica) um n√∫mero de ponto flutuante, sem usar as op√ß√µes de impress√£o destinadas a esse fim.  Por que queremos fazer isso sozinhos - <br><br><ol><li>  o uso do formato% f implica conectar a biblioteca para trabalhar com um ponto flutuante e uma vers√£o estendida da fun√ß√£o prntf (ou melhor, torna imposs√≠vel o uso da vers√£o truncada), o que leva a um aumento significativo no tamanho do m√≥dulo execut√°vel, </li><li>  uma solu√ß√£o padr√£o requer um tempo consider√°vel (sempre funciona com um n√∫mero de precis√£o duplo), o que pode ser inaceit√°vel nessa situa√ß√£o espec√≠fica, </li><li>  Bem (por √∫ltimo, mas n√£o menos importante), √© apenas interessante. </li></ol><br><a name="habracut"></a><br>  Para come√ßar, considere a op√ß√£o proposta no material acima, algo como: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Power10=<span class="hljs-number"><span class="hljs-number">10000.0</span></span>; Power10&gt;<span class="hljs-number"><span class="hljs-number">0.1</span></span>; Power10/=<span class="hljs-number"><span class="hljs-number">10.0</span></span>; ) {<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Fdata/Power10); Fdata -=Power10*c; };</code> </pre> <br>  e concordamos que ele resolve completamente o problema.  Al√©m disso, essa n√£o √© uma op√ß√£o ruim, pois sua velocidade pode ser bastante aceit√°vel.  Vamos dar uma olhada mais de perto neste momento - vemos a divis√£o dos n√∫meros PT, mas se aprofundarmos na ess√™ncia da quest√£o, acontece que √© quase t√£o r√°pido quanto a divis√£o de n√∫meros inteiros da profundidade de bits correspondente.  De fato, antes de avaliar o desempenho do algoritmo, voc√™ deve avaliar o desempenho de v√°rias opera√ß√µes elementares, o que faremos. <br><br><h4>  Parte Dois - Avalia√ß√£o de Desempenho de Opera√ß√µes Elementares </h4><br>  A primeira opera√ß√£o interessante √© a adi√ß√£o (subtra√ß√£o, no sentido de tempo gasto, eles s√£o equivalentes) de n√∫meros inteiros e podemos assumir que leva uma unidade de tempo (ciclo do rel√≥gio) com a seguinte ressalva - isso √© verdade apenas para dados "nativos".  Por exemplo, para a s√©rie MK AVR, √© uma palavra de 8 bits, para MSP430 √© uma palavra de 16 bits (e, √© claro, menor em tamanho), para Cortex-M √© uma palavra de 32 bits e assim por diante.  Ent√£o, a opera√ß√£o de adicionar n√∫meros com um comprimento de H vezes mais do que o nativo pode ser estimada como ciclos de H.  H√° exce√ß√µes, por exemplo, AddW em controladores AVR, mas n√£o cancela a regra. <br><br>  A pr√≥xima opera√ß√£o √© a multiplica√ß√£o de n√∫meros inteiros (mas n√£o a divis√£o, difere em termos de velocidade) e, para ele, nem tudo √© t√£o simples.  Em primeiro lugar, a multiplica√ß√£o pode ser implementada em hardware e, por exemplo, no AVR MEGA, s√£o necess√°rios 2 ciclos de clock e, nos 51 aprimorados, at√© 6 (para multiplicar n√∫meros nativos). <br><br>  Mas considere o caso em que n√£o h√° implementa√ß√£o de hardware e precisamos implementar a multiplica√ß√£o na forma de uma sub-rotina.  Como ao multiplicar n√∫meros de bits H, um produto de 2H √© obtido, a estimativa da vers√£o cl√°ssica com turnos pode ser encontrada da seguinte forma: precisamos de turnos H do fator com 1 ciclo de clock por turno, turnos H do segundo fator com um comprimento de 2 H com 2 ciclos de clock por turno, ent√£o H tomar√° decis√µes e , em m√©dia, N / 2 adi√ß√µes de n√∫meros com dura√ß√£o de 2H, em conclus√£o, a organiza√ß√£o de um ciclo de 2 medidas.  Total de  + 2 +  + 2 / 2 + 2 = 7 ticks, e realmente executar opera√ß√µes aritm√©ticas a partir deles leva apenas N ticks (uau efici√™ncia, embora tenhamos conseguido contornar o motor). <br><br>  Ou seja, para multiplicar dois n√∫meros 8p por 8p MK, s√£o necess√°rios 56 ciclos e para multiplicar n√∫meros 16p j√° existem 112 ciclos (um pouco menos, mas negligenciamos o valor exato) ciclos, o que √© um pouco mais do que quer√≠amos.  Felizmente, a dire√ß√£o dos turnos pode ser modificada e existe uma maneira √∫nica de multiplica√ß√£o, que exigir√° apenas turnos H do n√∫mero de d√≠gitos 2H e adi√ß√µes H / 2 de n√∫meros nativos, o que melhora o tempo de opera√ß√£o do algoritmo de multiplica√ß√£o para 0 + 2 + 1 + 1/2 + 2 = 5,5 - √© claro, n√£o pode ser comparado com a implementa√ß√£o de hardware, mas pelo menos algum ganho sem perda de funcionalidade.  H√° melhorias nesse algoritmo, por exemplo, a an√°lise de 2 bits por ciclo, mas eles n√£o alteram drasticamente a situa√ß√£o - o tempo de multiplica√ß√£o por ordens de grandeza excede o tempo de adi√ß√£o. <br><br>  Mas com a divis√£o, a situa√ß√£o √© pior - at√© a divis√£o implementada por hardware perde quase o dobro da multiplica√ß√£o, e existem MKs com multiplica√ß√£o de hardware, mas sem divis√£o de hardware.  Sob certas condi√ß√µes, a divis√£o pode ser substitu√≠da pela multiplica√ß√£o pela rec√≠proca, mas essas condi√ß√µes s√£o espec√≠ficas e d√£o um resultado semelhante - s√£o necess√°rias duas itera√ß√µes de multiplica√ß√£o seguidas da soma, portanto a perda √© 2 vezes.  Se implementarmos a divis√£o como um subprograma, H muda do divisor 2H de comprimento, H subtra√ß√µes do divis√≠vel 2H de comprimento, H muda do resultado, √© necess√°ria a organiza√ß√£o do ciclo 2H, mas tudo isso √© precedido pelo alinhamento, que levar√° mais 5H ciclos, portanto, o n√∫mero total √© 2 + 2 + 1 + 2 + 5 = 12, que √© cerca de 2 vezes pior que a multiplica√ß√£o. <br><br>  Bem, agora vamos considerar as opera√ß√µes de PT, e aqui a situa√ß√£o √© um pouco paradoxal - a opera√ß√£o de multiplica√ß√£o requer quase tanto tempo quanto os n√∫meros inteiros (correspondendo √† capacidade de bits, via de regra, 24 bits), pois precisamos multiplicar a mantissa e apenas adicionar as ordens, a normaliza√ß√£o n√£o necess√°rio.  Com a divis√£o tamb√©m √© boa, divida a mantissa e subtraia as ordens, a normaliza√ß√£o novamente n√£o √© necess√°ria.  Portanto, para essas duas opera√ß√µes, a perda comparada aos n√∫meros inteiros n√£o √© muito significativa, embora tenha um lugar. <br><br>  Mas a opera√ß√£o de adi√ß√£o e subtra√ß√£o requer, antes de tudo, o alinhamento das ordens (e essas s√£o mudan√ßas e podem haver muitas, embora haja nuances), depois as pr√≥prias opera√ß√µes e (ao subtrair) a normaliza√ß√£o (ao adicionar tamb√©m, mas n√£o √© necess√°rio mais do que 1 mudan√ßa) ), o que √© um desperd√≠cio de tempo; portanto, as opera√ß√µes dessa classe para PT s√£o muito mais lentas que para n√∫meros inteiros, especialmente em termos relativos. <br><br>  Vamos voltar √†s nossas ovelhas e concordar que, com base nas estimativas anteriores, o m√©todo proposto pode n√£o ser muito longo, especialmente porque fornece o resultado imediatamente, mas tem uma limita√ß√£o significativa - √© aplic√°vel a uma faixa muito limitada de valores de PT de entrada.  Portanto, buscar√° uma solu√ß√£o universal (mais ou menos). <br><br>  Imediatamente, fa√ßa uma reserva de que nossa solu√ß√£o n√£o deve usar opera√ß√µes de ponto flutuante em geral (a partir da palavra) para enfatizar o m√©rito de nossa op√ß√£o.  E para a pergunta perplexa de como um n√∫mero desse tipo aparecer√° se as opera√ß√µes n√£o estiverem dispon√≠veis, respondemos - pode aparecer, por exemplo, ao ler informa√ß√µes de um sensor de luz (como no exemplo original), que produz dados no formato PT. <br><br>  Como exatamente o n√∫mero de PTs √© organizado, voc√™ pode encontrar facilmente em v√°rios sites, houve um artigo recente sobre Habr√©, n√£o deve haver nenhum problema com isso.  No entanto, v√°rias quest√µes s√£o de interesse para o formato PT no estilo ‚Äúse eu fosse o diretor‚Äù - por que isso √© assim e n√£o o contr√°rio.  Vou dar respostas a algumas delas, se algu√©m souber mais, por favor, comente. <br><br>  A primeira pergunta √© por que a mantissa √© armazenada em c√≥digo direto e n√£o em c√≥digo adicional?  Minha resposta √© porque √© mais f√°cil trabalhar com uma mantissa normalizada com um bit oculto (opcional). <br><br>  A segunda pergunta √© por que o pedido √© armazenado com um deslocamento, e n√£o o contr√°rio?  Minha resposta √© que, neste caso, √© f√°cil comparar os m√≥dulos de dois PTs como n√∫meros inteiros, com outros m√©todos √© mais complicado. <br><br>  A terceira pergunta √© por que o sinal negativo √© codificado por um em vez de zero, porque ent√£o seria poss√≠vel simplesmente comparar os dois pontos como n√∫meros inteiros?  Minha resposta √© que eu n√£o sei, √© apenas "√© t√£o aceito aqui". <br><br><h4>  Parte Tr√™s - Explica√ß√µes Exigidas </h4><br>  No par√°grafo anterior, eu poderia fornecer termos incompreens√≠veis, um pouco sobre a representa√ß√£o de n√∫meros.  Claro, eles s√£o diferentes, caso contr√°rio n√£o haveria necessidade de discuti-los.  Imediatamente, observamos que na mem√≥ria do MK (o mesmo se aplica aos computadores, embora eu n√£o seja t√£o categ√≥rico quanto √†s arquiteturas mais modernas - elas s√£o t√£o complicadas que tudo pode ser esperado), n√£o h√° n√∫meros, existem apenas unidades de armazenamento elementares - bits agrupados em bytes e mais em palavras.  Quando falamos sobre a representa√ß√£o de um n√∫mero, significa que interpretamos um conjunto de bits de um comprimento espec√≠fico de uma maneira ou de outra, ou seja, estabelecemos uma lei pela qual podemos encontrar um determinado n√∫mero correspondente a um determinado conjunto de bits e nada mais. <br><br>  In√∫meras leis podem ser inventadas, mas algumas delas ter√£o v√°rias propriedades √∫teis em termos de realiza√ß√£o de v√°rias opera√ß√µes, de modo que ser√£o aplicadas com mais frequ√™ncia na pr√°tica.  Uma dessas propriedades, implicitamente impl√≠cita, por exemplo, √© o determinismo, e a outra √© a independ√™ncia do ambiente - propriedades que, √† primeira vista, s√£o √≥bvias, embora haja nuances.  Outras propriedades do tipo de correspond√™ncia um-para-um j√° s√£o objeto de discuss√£o e nem sempre ocorrem em uma representa√ß√£o concreta.  O t√≥pico de representar n√∫meros em si √© extraordinariamente fascinante; para Knut (no Volume Dois), ele √© totalmente divulgado, de modo que vai al√©m das profundezas, e n√≥s atravessamos a superf√≠cie. <br><br>  Supondo que o conjunto de bits tenha um comprimento n (n√≥s os numeramos em uma linha de 0 a n-1) e seja ponderado uniformemente com uma etapa de 2 e o bit menos significativo (com o n√∫mero 0) tenha um peso de 1 (que, de um modo geral, n√£o √© necess√°rio, apenas N√≥s nos acostumamos a essas coisas, e elas parecem √≥bvias para n√≥s), obtemos uma representa√ß√£o bin√°ria do n√∫mero, na qual a f√≥rmula de redu√ß√£o √© assim: o n√∫mero exibido pelo conjunto de bits <code>(2) = (0)*2^0 + (1)*2^1 + ... + (-1)*2^(-1)</code> ou em forma de cascata <code>2() = (0)+2*((1)+2*(...+2*((-1))..)))</code> , a seguir, B (k) denota um pouco com o n√∫mero k. Observe que em  uma vis√£o diferente n√£o imp√µe restri√ß√µes √† localiza√ß√£o do n√∫mero de bytes na mem√≥ria, mas seria mais l√≥gico colocar o byte baixo nos endere√ßos mais baixos (√© assim que f√°cil e naturalmente eu resolvi o "argumento eterno dos eslavos entre si" sobre qual extremidade √© mais conveniente para quebrar um ovo). <br><br>  Com esta interpreta√ß√£o de um conjunto de bits de comprimento n (= 8), obtemos uma representa√ß√£o para n√∫meros de 0 a (2 ^ n) -1 (= 255) (daqui em diante, entre par√™nteses, haver√° um valor espec√≠fico para um conjunto de 8 bits), que possui v√°rias not√°veis e propriedades √∫teis, raz√£o pela qual se tornou generalizada.  Infelizmente, ele tamb√©m tem v√°rias desvantagens, uma das quais √© que n√£o podemos representar n√∫meros negativos em um registro como esse em princ√≠pio. <br><br>  Voc√™ pode oferecer uma variedade de solu√ß√µes para esse problema (a representa√ß√£o de n√∫meros negativos), entre as quais tamb√©m h√° import√¢ncia pr√°tica, elas est√£o listadas abaixo. <br><br>  Uma representa√ß√£o com um deslocamento √© descrita pela f√≥rmula H = N2 (n) - deslocamento (C), onde N2 √© o n√∫mero obtido em nota√ß√£o bin√°ria com n bits e C √© um valor pr√©-selecionado.  Em seguida, representamos n√∫meros de 0-C a 2 ^ (n) -1-C, e se escolhermos C = 2 ^ (n-1) -1 (= 127) (isso √© totalmente opcional, mas muito conveniente), ent√£o obtemos o intervalo de 0- (2 ^ (n-1) -1) (= - 127) a 2 ^ (n-1) (= 128).  A principal vantagem dessa representa√ß√£o √© a monotonia (al√©m disso, aumento) ao longo de todo o intervalo, tamb√©m existem desvantagens, dentre as quais destacamos a assimetria (existem outras relacionadas √† complexidade de executar opera√ß√µes no n√∫mero nessa representa√ß√£o), mas os desenvolvedores do padr√£o IEEE 457 (este √© o padr√£o para O PT) transformou essa falha em virtude (usando um valor extra para codificar a situa√ß√£o nan), que mais uma vez enfatiza a fidelidade do ditado legal: ‚ÄúSe voc√™ √© superior ao oponente, essa √© sua vantagem.  Se o advers√°rio √© mais alto que voc√™, essa tamb√©m √© sua vantagem. <br><br>  Observe que, como o n√∫mero total de combina√ß√µes poss√≠veis de qualquer n√∫mero de bits √© par (se voc√™ n√£o tiver combina√ß√µes proibidas por raz√µes religiosas), a simetria entre n√∫meros represent√°veis ‚Äã‚Äãpositivos e negativos √© fundamentalmente inating√≠vel (ou melhor, alcan√ß√°vel, mas sob certas condi√ß√µes adicionais, sobre as quais ainda mais) . <br><br>  Representa√ß√£o na forma de um c√≥digo direto quando um dos bits (mais significativo) representa o sinal codificado do n√∫mero H = (-1) ^ B (n-1) * P2 (n-1) tem um intervalo de 0- (2 ^ (n-1) -1) (= -127) a 2 ^ (n-1) -1 (= 127).  √â interessante notar que acabei de declarar a impossibilidade fundamental de simetria, e aqui est√° claramente: o n√∫mero positivo m√°ximo represent√°vel √© igual ao m√≥dulo do n√∫mero negativo m√≠nimo represent√°vel.  Esse resultado √© alcan√ßado tendo duas representa√ß√µes para zero (00 ... 00 e 10 ... 00), o que geralmente √© considerado a principal desvantagem desse m√©todo.  Isso √© realmente uma desvantagem, mas n√£o t√£o terr√≠vel quanto se acredita, j√° que existem outras mais significativas que limitaram seu uso. <br><br>  A representa√ß√£o do c√≥digo inverso, quando na representa√ß√£o direta invertemos todos os bits do valor para n√∫meros negativos H = (1-B (n-1)) * P2 (n-1) + B (n-1) * (2 ^ (n -1) -CH2 (n-1)) - isto √© da defini√ß√£o, voc√™ pode fazer uma f√≥rmula muito mais compreens√≠vel H = Ch2 (n-1) -B (n-1) * (2 ^ (n-1) -1), o que nos permite representar n√∫meros de 0-2 ^ (n-1) +1 (= - 127) a 2 ^ (n-1) -1 (= 127).  Pode-se ver que essa representa√ß√£o √© deslocada, mas o deslocamento muda gradualmente, o que torna essa representa√ß√£o n√£o monot√¥nica.  Novamente, temos dois zeros, o que n√£o √© muito assustador, a ocorr√™ncia de transfer√™ncia circular durante a adi√ß√£o √© muito pior, o que cria certos problemas na implementa√ß√£o da ALU. <br><br>  Para eliminar a √∫ltima desvantagem da representa√ß√£o anterior, √© extraordinariamente simples, basta alterar o deslocamento por um, obtemos = = 22 (n-1) -B (n-1) * 2 ^ (n-1) e podemos representar n√∫meros de 0-2 ^ ( n-1) (= - 128) a 2 ^ (n-1) -1 (= 127).  √â f√°cil ver que a representa√ß√£o √© assim√©trica, mas zero √© √∫nico.  Significativamente mais interessante √© a propriedade a seguir, ‚Äú√© completamente √≥bvio que‚Äù a transfer√™ncia de anel n√£o ocorre para uma opera√ß√£o do tipo adi√ß√£o, que √© a raz√£o (junto com outros recursos agrad√°veis) da distribui√ß√£o universal desse m√©todo espec√≠fico de codifica√ß√£o de n√∫meros negativos. <br><br>  Vamos elaborar uma tabela de valores interessantes para v√°rios m√©todos de codifica√ß√£o de n√∫meros, denotando por H o ‚Äã‚Äãvalor 2 ^ (n-1) (128) <br><table><tbody><tr><th>  Bits </th><th>  00..00 </th><th>  11/01 </th><th>  10..00 </th><th>  11.11 </th></tr><tr><td>  H (n) </td><td>  0 0 </td><td>  H-1 (127) </td><td>  H (128) </td><td>  2 * H-1 (255) </td></tr><tr><td>  H (n-1) </td><td>  0 0 </td><td>  H-1 (127) </td><td>  0 0 </td><td>  H-1 (127) </td></tr><tr><td>  Deslocamento.  N </td><td>  -H + 1 (-127) </td><td>  0 0 </td><td>  1 </td><td>  H (128) </td></tr><tr><td>  Direto </td><td>  0 0 </td><td>  H-1 (127) </td><td>  0 0 </td><td>  -H + 1 (-127) </td></tr><tr><td>  Reverse </td><td>  0 0 </td><td>  H-1 (127) </td><td>  -H + 1 (-127) </td><td>  0 0 </td></tr><tr><td>  Adi√ß√£o </td><td>  0 0 </td><td>  H-1 (127) </td><td>  -H (-128) </td><td>  -1 </td></tr></tbody></table><br>  Bem, para concluir o t√≥pico, fornecemos gr√°ficos para as representa√ß√µes listadas, a partir das quais suas vantagens e desvantagens s√£o imediatamente vis√≠veis (√© claro, nem tudo o que faz lembrar o ditado interessante "A vantagem da apresenta√ß√£o gr√°fica da informa√ß√£o √© visual, n√£o tem outras vantagens"). <br><br><h4>  Parte Quatro - Realmente resolvendo o problema original (antes tarde do que nunca). <br><br>  Pequena digress√£o </h4><br>  Para come√ßar, eu queria imprimir o PT em formato hexadecimal (e finalmente o fiz), mas de maneira inesperada / completamente inesperada (necess√°rio substituir), me deparei com o seguinte resultado.  O que voc√™ acha que ser√° impresso como resultado da execu√ß√£o dos operadores: <br><br><pre> <code class="plaintext hljs">printf("%f %x", 1.0,1.0); printf("%f %x",2.0,2.0); printf("%x %d",1.0,1.0); printf("%x %d",2.0,2.0);</code> </pre> <br>  , preste aten√ß√£o tamb√©m √† seguinte constru√ß√£o e seu resultado: <br><br><pre> <code class="plaintext hljs">printf("%x %x %f",1.0,1.0);</code> </pre> <br>  N√£o darei explica√ß√µes para esse fen√¥meno "suficientemente inteligente". <br><br>  No entanto, como imprimimos corretamente a representa√ß√£o hexadecimal de PT?  A primeira solu√ß√£o √© √≥bvia - uni√£o, mas a segunda √© para os f√£s de linha √∫nica printf ("% x", * ((int *) (&amp; f)));  (Pe√ßo desculpas se algu√©m se ofendeu com colchetes extras, mas eu nunca, e nunca pretendi, lembrar as prioridades das opera√ß√µes, principalmente considerando que os par√™nteses n√£o geram c√≥digo, ent√£o continuarei fazendo o mesmo).  E aqui est√°, a solu√ß√£o da tarefa - vemos uma s√©rie de caracteres, 0x45678, que determinam exclusivamente o n√∫mero desejado para n√≥s, mas de forma que n√≥s (eu n√£o conhe√ßo voc√™, definitivamente) n√£o podemos dizer nada intelig√≠vel sobre esse n√∫mero.  Eu acho que o acad√™mico Karnal, que poderia ter apontado um erro na fita perfurada com o c√≥digo-fonte, teria lidado com essa tarefa, mas nem todos s√£o t√£o avan√ßados, ent√£o continuaremos. <br><br>  Vamos tentar obter informa√ß√µes de uma forma mais compreens√≠vel. <br><br>  Para fazer isso, retornamos ao formato do PT (daqui em diante, considero apenas float), que √© um conjunto de bits dos quais voc√™ pode extrair (por certas regras) tr√™s conjuntos de bits para representar tr√™s n√∫meros - sinal (es), mantissa (m) e ordem (p), e o n√∫mero desejado codificado por esses n√∫meros ser√° determinado pela seguinte f√≥rmula: Cs * Chm * Chn.  Aqui, os s√≠mbolos designam os n√∫meros representados pelo conjunto correspondente de bits; portanto, para encontrar o n√∫mero desejado, precisamos conhecer as leis pelas quais extra√≠mos esses tr√™s conjuntos do conjunto original de bits, bem como o tipo de codifica√ß√£o para cada um deles. <br><br>  Para resolver esse problema, recorremos ao padr√£o IEEE e descobrimos que o sinal √© um bit (s√™nior) do conjunto original e a f√≥rmula para codificar Cs = (- 1) ^ B (0).  A ordem ocupa os pr√≥ximos 8 bits mais significativos, √© escrita em c√≥digo com um deslocamento de 127 e representa uma pot√™ncia de dois, ent√£o Cn = 2 ^ (C2 (8) -127).  Mantissa recebe a pr√≥xima ordem de 23 d√≠gitos e representa o n√∫mero Chm = 1 + Ch2 (23) / 2 ^ 23. <br><br>  Agora temos todos os dados necess√°rios e podemos resolver completamente a tarefa - criar uma string com caracteres, que com uma certa leitura representem um n√∫mero igual ao codificado em PT.  Para fazer isso, devemos, atrav√©s de opera√ß√µes simples, extrair os n√∫meros acima e imprimi-los, fornecendo os atributos necess√°rios.  Assumimos que somos capazes de converter um n√∫mero inteiro com n√£o mais de 32 bits em uma cadeia de caracteres; isso √© completamente descomplicado. <br><br>  Infelizmente, estamos apenas no in√≠cio da jornada, uma vez que poucos leitores deste post no registro ‚Äú+ 1.625 * 2 ^ 3‚Äù reconhecem o n√∫mero azarado, codificado pelo decimal mais comum ‚Äú13‚Äù e adivinham no registro ‚Äú1.953125 * 2 ^ 9 ‚Äùo simples‚Äú 1E3 ‚Äùou‚Äú 1 * 10 ^ 3 ‚Äùou o muito familiar‚Äú 1000 ‚Äùs√£o capazes de unidades de pessoas em geral, eu definitivamente n√£o perten√ßo a elas.  √â estranho como isso aconteceu, porque conclu√≠mos a tarefa inicial, que demonstra mais uma vez com que cuidado voc√™ deve tratar as formula√ß√µes.  E o ponto n√£o √© que a nota√ß√£o decimal seja melhor ou pior que o bin√°rio (neste caso, o deuce √© baseado no grau), mas que estamos acostumados a decimais desde a inf√¢ncia e refazer as pessoas √© muito mais dif√≠cil que o programa, portanto, daremos nosso entrada para o mais familiar. <br><br>  Do ponto de vista da matem√°tica, temos uma opera√ß√£o simples - existe um registro PT = (- 1) ^ s * m * 2 ^ n e precisamos convert√™-lo para a forma PT = (-1) s '* m' * 10 ^ n '.  Equacionamos, transformamos e obtemos (uma das op√ß√µes poss√≠veis) solu√ß√µes s '= s', m '= m, n' = n * log (2).  Se deixarmos de fora os colchetes, a necessidade de multiplicar por um n√∫mero explicitamente irracional (isso pode ser feito se o n√∫mero for racionalizado, mas falaremos sobre isso mais tarde), ent√£o o problema parece estar resolvido at√© que possamos ver a resposta, porque se o registro √© como ‚Äú+1.953125 * 2 ^ 9 "nos parece obscuro, o registro" + 1.953125 * 10 ^ 2.70927 "√© ainda menos aceit√°vel, embora parecesse que n√£o havia lugar pior. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuamos a melhorar a solu√ß√£o e encontramos a seguinte solu√ß√£o - as equa√ß√µes de redu√ß√£o para o grau base 10 m '= m * 10 ^ {n * log (2)}, n' = [n * log (2)], onde os colchetes e os encaracolados indicam o fracion√°rio e a parte inteira de um determinado n√∫mero, respectivamente. </font><font style="vertical-align: inherit;">Ent√£o, para o exemplo em quest√£o, obtemos (1.953125 * 10 ^ 0.7 0927) * 10 ^ 2 = "10 * 10 ^ 2", que √© muito mais aceit√°vel, embora n√£o seja perfeito, mas j√° pode ser implementado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A coisa √© pequena, precisamos aprender:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> multiplique o n√∫mero inteiro (n) pelo irracional anteriormente conhecido (log (2)) (isso n√£o √© dif√≠cil com certas restri√ß√µes na precis√£o do resultado); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pegue a parte inteira e fracion√°ria de um n√∫mero de ponto fixo (isso √© f√°cil); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elevar um todo conhecido (10) a um grau irracional (hmm ...); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> multiplique o todo por um irracional arbitr√°rio ("simplificaremos os c√°lculos, disseram eles ..."). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, tentaremos avan√ßar nessa dire√ß√£o e considerar o que n√£o √© dif√≠cil de fazer, ou seja, o ponto 1. Observamos imediatamente que esse problema √© fundamentalmente insol√∫vel e n√£o podemos calcular n * log (2), n√£o podemos da palavra ‚Äúcompletamente‚Äù, exceto o caso trivial n = 0 (bem, e o caso √≥bvio n = k / log (10)). Uma afirma√ß√£o interessante, especialmente ap√≥s a afirma√ß√£o "n√£o √© dif√≠cil", mas a aparente contradi√ß√£o √© removida pela frase "com certa precis√£o". Ou seja, ainda podemos calcular o produto de um n√∫mero inteiro arbitr√°rio com um irracional conhecido e isso n√£o √© dif√≠cil para o resultado com uma certa precis√£o. Por exemplo, se estivermos interessados ‚Äã‚Äãno resultado com uma precis√£o de um por cento, apresentando o resultado desejado n '= n * log (2) na forma n * [log (2) * 256 + 1/2] / 256, obtemos o valor com a precis√£o necess√°ria ,pois o poss√≠vel erro relativo n√£o pode exceder 1/2/77 = 1/144, o que √© claramente melhor que o 1/100 necess√°rio. Uma considera√ß√£o importante deve ser levada em considera√ß√£o - o pequeno valor do desvio relativo n√£o diz absolutamente nada sobre o comportamento da fun√ß√£o quando uma transforma√ß√£o n√£o linear √© aplicada a ela, e a opera√ß√£o de tirar a parte inteira √© obviamente n√£o linear. Damos um exemplo simples [4.501] = 5 e [4.499] = 4 e, apesar do desvio relativo nos dados de origem ser de 0,002 / 4,5 = 0,04%, o desvio do resultado ser√° de 1/4 = 25%. Infelizmente, em geral, o problema n√£o √© resolvido, usando qualquer algoritmo de arredondamento. Voc√™ pode resolver apenas um caso especial quando os dados de entrada s√£o limitados e, al√©m disso, adotar um conjunto fixo de valores. Ao escolher o deslocamento inicial e o √¢ngulo de inclina√ß√£o, voc√™ pode obter uma precis√£o absoluta,no sentido de arredondamento, aproxima√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para o nosso caso, essa aproxima√ß√£o ideal ser√° a fun√ß√£o n '= n * 77/256. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de continuar com o design do algoritmo, devemos avaliar a precis√£o de que precisamos. Como a mantissa √© de 24 bits, o n√∫mero representado tem um erro relativo de 2 ^ -24 = 2 ^ -4 * 2 ^ -20 = 16 ^ -1 * (2 ^ 10) ^ - 2 ~ (10) ^ - 1 * (10 ^ 3) ^ - 2 = 10 ^ -7, o que significa 7 d√≠gitos decimais exatos. Multiplicar dois n√∫meros de 24 bits ser√° suficiente para manter a precis√£o nesse intervalo (bem, quase o suficiente). Observe que a transi√ß√£o para n√∫meros de 32 bits (ambos os fatores) reduz o erro relativo em mais de 100 (256) vezes, esse fato ser√° √∫til mais tarde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A f√≥rmula mais desagrad√°vel em termos de precis√£o calcula uma nova mantissa e se parece com </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m '= m * 10 ^ {n * log (2)}</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que √© o mais desagrad√°vel - 1) cont√©m uma cadeia de c√°lculos com rela√ß√£o a n e o erro se acumula; 2) possui uma opera√ß√£o extremamente ruim do ponto de vista da precis√£o, e isso n√£o √© a parte fracion√°ria, porque se voc√™ fizer isso simultaneamente com a parte inteira, tudo n√£o √© t√£o ruim, mas um expoente. Se as opera√ß√µes restantes s√£o multiplica√ß√µes e os erros relativos s√£o simplesmente somados, eles s√£o previs√≠veis e dependem apenas do comprimento da grade de bits da representa√ß√£o do operando, ent√£o tudo √© extremamente ruim para o expoente e √© √≥bvio que o erro relativo ser√° muito grande com grandes valores do argumento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Bem, sim, √© √≥bvio que" </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">q (10 ^ x) = Œî (10 ^ x) / 10 ^ x = (10 ^ (x + Œîx) - 10 ^ x) / 10 ^ x = 10 ^ Œîx -1 = 10 ^ (x * qx) -1,</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 ^ (x * qx)&gt; ~ 10 ^ (x * 0) + (10 ^ (x * 0)) '* qx = 1 + x * ln (10) * 10 ^ (0) * qx = 1 + x * ln (10) * qx, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daqui temos</font></font><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>q</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mn>10</mn><mi>x</mi></msup><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>x</mi><mo>&amp;#x2217;</mo><mi>l</mi><mi>n</mi><mo stretchy=&quot;false&quot;>(</mo><mn>10</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mi>q</mi><mi>x</mi><mo>.</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="24.462ex" height="2.66ex" viewBox="0 -832 10532.3 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMATHI-71" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-28" x="460" y="0"></use><g transform="translate(850,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMATHI-78" x="1415" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-29" x="2355" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-3D" x="3023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMATHI-78" x="4079" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-2217" x="4874" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMATHI-6C" x="5596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMATHI-6E" x="5895" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-28" x="6495" y="0"></use><g transform="translate(6885,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-30" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-29" x="7886" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-2217" x="8498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMATHI-71" x="9220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMATHI-78" x="9681" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjzsaqCPOExJCO61zMfIseW9-Q_0w#MJMAIN-2E" x="10253" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mi>x</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>‚àó</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>‚àó</mo><mi>q</mi><mi>x</mi><mo>.</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1">q(10^x) = x*ln(10)*qx.</script></p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que essa express√£o significa √© que, na extremidade do intervalo de valores, com n = 127, o erro relativo aumentar√° 292 vezes e, para manter a precis√£o do resultado no limite necess√°rio, precisamos aumentar significativamente a precis√£o do argumento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que a transi√ß√£o de 24 para 32 bits nos fornece o aumento necess√°rio na precis√£o (n√£o exatamente, mas muito pr√≥ximo), entendemos que a primeira multiplica√ß√£o (n * log (2)) deve ser realizada com operandos de 32 bits, ou seja, com tanta precis√£o o logaritmo de dois deve ser expresso, ent√£o ser√° igual a 1'292'914'005 / 2 ^ 32. Observe que no c√≥digo o numerador dessa constante deve ser escrito como (int) ((log (2) * float (2 ^ 32)) + 0,5), mas em nenhum caso como um misterioso 0x4d104d42, mesmo com um coment√°rio sobre ele computa√ß√£o, porque o c√≥digo bem escrito √© auto-documentado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos de toda a parte do resultado, isso n√£o √© dif√≠cil, pois sabemos exatamente a posi√ß√£o do ponto decimal nos dois fatores e, como resultado, como resultado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas ent√£o temos que calcular 10 com a pot√™ncia de 0 a 1, e aqui usaremos um pequeno truque para obter a precis√£o necess√°ria. Como, de acordo com a f√≥rmula do erro, a precis√£o na borda direita do intervalo cai em mais de dois, se representarmos o valor do argumento como a soma do logaritmo dos dois decimais e algum restante, n '' = log (2) * i + (n '' - log ( 2) * i), ent√£o o primeiro membro da soma multiplicar√° por 2 no grau apropriado, o que √© f√°cil de implementar com erro zero (at√© que ocorra um estouro), e o restante ser√° limitado pelo valor do log (2) e n√£o perderemos a precis√£o no c√°lculo 10 ^ n '' (sujeito a subtra√ß√£o adequada).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, a fun√ß√£o exponencial para o argumento limitado pelo valor lg (2) ainda ter√° que ser calculada e a √∫nica maneira que vejo √© a expans√£o na s√©rie de Taylor. Infelizmente, ele n√£o converge muito rapidamente em nosso intervalo e, por exemplo, para obter uma precis√£o de 10E-7, precisamos de 9 membros da soma, o que leva √† necessidade de realizar multiplica√ß√µes 1 + 9 * 2 = 19 de n√∫meros inteiros de 32 bits, o que √© um pouco excede o desempenho desejado. Ainda h√° vagas d√∫vidas sobre nossa capacidade de calcular n '= n * log (2) com tanta precis√£o que √© suficiente para o valor m√°ximo de n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, o algoritmo acabou sendo bastante funcional e precisamos apenas de multiplica√ß√£o de 32 bits para obter o resultado na quantidade de 1 + 19 + 1 = 21 opera√ß√µes que determinam a complexidade computacional do algoritmo</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â poss√≠vel reduzir a complexidade computacional de nossa transforma√ß√£o - parece que n√£o, todos calculamos cuidadosamente -, mas de repente acontece que ainda √© poss√≠vel. Uma declara√ß√£o um tanto inesperada, a chave para entender essa possibilidade est√° na natureza da ordem do PT - √© preciso um conjunto fixo (e relativamente pequeno) de valores, e voc√™ e eu n√£o levamos isso em considera√ß√£o ao transformar f√≥rmulas de convers√£o, mas trabalhamos implicitamente com um valor cont√≠nuo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A solu√ß√£o mais simples - altere a mem√≥ria por um tempo - calcule antecipadamente todos os expoentes poss√≠veis (2 ^ 8 = 256) nos valores correspondentes [n '] (o expoente mais adequado 10) e {n'} (o fator corretivo da mantissa), insira-os na tabela e em diante √© f√°cil de usar no processo de c√°lculo. A f√≥rmula acaba sendo bastante simples - PT = m * 2 ^ n = m * 10 ^ n '* (2 ^ n / 10 ^ n') = (m * (2 ^ n / 10 ^ n ')) * 10 ^ n '.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso mais simples, precisamos de 256 * 3 (um fator de corre√ß√£o de 24 bits, n√£o √© mais necess√°rio) + 256 * 1 (√© garantido que a ordem na base 10 seja menor que a ordem na base 2) = constantes de 1 kbyte. Nesse caso, resta apenas fazer uma multiplica√ß√£o de 24 * 24 bits (provavelmente ser√° 32 * 32), o que acelera significativamente o trabalho em compara√ß√£o com a vers√£o deste c√°lculo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos ver o que pode ser feito do ponto de vista da economia de mem√≥ria (nesse caso, novamente temos que pagar tempo, portanto, estamos procurando um compromisso razo√°vel). Primeiro, se levarmos em conta o sinal do pedido separadamente, poderemos gerenciar apenas metade da mem√≥ria necess√°ria (de 256 bytes para o pedido 10) e inverter o resultado, se necess√°rio. Infelizmente, com o fator de corre√ß√£o, n√£o ser√° t√£o f√°cil, porque</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 ^ -n / 10 ^ -n '= 1 / (2 ^ n / 10 ^ n')! = 2 ^ n / 10 ^ n ',</font></font><br><br>  uma pena.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos que deixar uma mesa longa ou, para indicadores negativos, dividir por uma constante para indicadores positivos. √â claro que a divis√£o n√£o √© de 18 multiplica√ß√µes, mas, mesmo assim, em velocidade, √© exatamente equivalente a duas multiplica√ß√µes; portanto, o tempo definitivamente dobrar√° para economizar mem√≥ria duas vezes, at√© 512 bytes. Vale a pena - a quest√£o n√£o √© simples, mas, felizmente, temos uma maneira muito mais bonita que nos permite livrar-nos do sofrimento da escolha. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse m√©todo geralmente √© chamado de aproxima√ß√£o linear por partes e consiste em definir constantes n√£o para cada ponto do valor inicial, mas apenas para algumas e calcular os valores ausentes (com a precis√£o necess√°ria) usando os valores fornecidos usando uma f√≥rmula simples. Em rela√ß√£o ao nosso problema, verifica-se (sem considerar o sinal)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PT = m * 2 ^ n = m * 2 ^ (n0 + n1) = m * 10 ^ n '* (2 ^ (n0 + n1) / 10 ^ n') = m * (2 ^ n0 / 10 ^ n ') * 2 ^ n1 * 10 ^ n', </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde n0 √© algum valor de refer√™ncia e n1 = n-n0. Em seguida, a nova mantissa √© calculada multiplicando dois n√∫meros por um ponto fixo, seguido de uma mudan√ßa no resultado, o que n√£o prejudica a precis√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surge ent√£o uma pergunta leg√≠tima - por que precisamos de uma tabela, porque voc√™ pode pegar o indicador m√≠nimo como n0 e conviver com apenas um valor do fator de corre√ß√£o? Infelizmente, essa abordagem √© contraproducente devido a duas circunst√¢ncias complementares - a necessidade de obter o expoente mais adequado de 10 e o aparecimento de turnos muito longos com essa abordagem. A √∫ltima circunst√¢ncia sugere os limites de aplicabilidade desse m√©todo - se realizarmos a multiplica√ß√£o 32 * 32, e a mantissa inicial tiver 24 d√≠gitos, um deslocamento de 8 d√≠gitos n√£o levar√° ao estouro e precisaremos de um ponto de refer√™ncia por 8 valores bin√°rios.A quantidade total de mem√≥ria necess√°ria ser√° 256/8 * 4 = 32 * 4 = 128 bytes - boa economia de mem√≥ria ao custo do tempo de execu√ß√£o devido √† necessidade de alterar todo o resultado do trabalho em no m√°ximo 8 bits.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode reduzir um pouco mais a quantidade de constantes devido √† simetria do expoente em rela√ß√£o a 0, que mencionei anteriormente, mas a economia ser√° de 32/2 = 16 bytes, n√£o tenho certeza de que isso justifique a complica√ß√£o (e o aumento do tamanho do c√≥digo) do pr√≥prio programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ali√°s, recentemente observei o c√≥digo da biblioteca adafruit, amplamente conhecido em c√≠rculos estreitos, e fiquei um pouco surpreso com o seguinte fragmento de c√≥digo</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UINT8 Bits[] = {<span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-number"><span class="hljs-number">0x08</span></span>, <span class="hljs-number"><span class="hljs-number">0x10</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, <span class="hljs-number"><span class="hljs-number">0x80</span></span>}; ... data = data | Bits[n];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um coment√°rio de que a opera√ß√£o 1 &lt;&lt; n no AVR demora muito tempo. No meu post, eu j√° mostrei quais milagres o compilador faz com um par√¢metro constante, mas esse n√£o √© o caso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pareceu-me duvidoso que tirar uma m√°scara de bits de uma matriz fosse mais r√°pido do que realizar as opera√ß√µes de turno diretamente e subsequente an√°lise de c√≥digo (usando o site godbolt, embora seja extremamente improv√°vel que seu criador lesse o Habr, no entanto, mais uma vez, trago-lhe meu sincero gratid√£o) mostrou que realmente √© assim. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo gerado pelo compilador para as duas op√ß√µes (aqui est√° a op√ß√£o correta com turnos, levando em considera√ß√£o os recursos da tarefa, porque precisamos apenas de 1 bit)</font></font><br><br><pre> <code class="cpp hljs"> ldi r18,lo8(<span class="hljs-number"><span class="hljs-number">4</span></span>) sbrs r25,<span class="hljs-number"><span class="hljs-number">1</span></span> ldi r18,lo8(<span class="hljs-number"><span class="hljs-number">1</span></span>) sbrc r25,<span class="hljs-number"><span class="hljs-number">0</span></span> lsl r18 sbrs r25,<span class="hljs-number"><span class="hljs-number">2</span></span> swap r18</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocupou exatamente o mesmo lugar na mem√≥ria e, se tudo for feito com cuidado no assembler, a op√ß√£o com o √≠ndice avan√ßa 8: 7 devido aos 8 bytes extras do programa (√© claro, se n√£o levarmos a s√©rio uma solu√ß√£o realmente deliciosa com armazenamento separado da m√°scara invertida, o que custar√° 16 bytes - e a TI √© usada em todos os lugares - ‚Äúeu sabia que seria ruim, mas n√£o sabia que seria t√£o cedo‚Äù). Bem, o pacote mencionado geralmente √© uma m√∫sica separada, descrita da melhor maneira poss√≠vel pela seguinte cita√ß√£o de um livro maravilhoso: ‚ÄúEste castelo solicitou uma capa de fortifica√ß√£o com a legenda‚Äú Como n√£o construir castelos ou encontrar 12 erros ‚Äù(‚Äú The Last Ringman ‚Äù, se quem n√£o leu, eu recomendo.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos voltar aos carneiros de ponto flutuante e criar a f√≥rmula resultante</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PT = m * 2 ^ n = (m * pc [n / 8]) * 2 ^ (n% 8) * 10 ^ nn [n / 8], </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde colchetes significam tomar um elemento de matrizes corre√ß√£o pc do indicador e nn- ordem do indicador. A complexidade computacional do algoritmo √© imediatamente vis√≠vel, que √© determinada pela multiplica√ß√£o de 32 * 32 (24 * 24) e turnos subsequentes. Al√©m disso, voc√™ pode levar em conta a possibilidade de combinar um expoente de 10 e um fator de corre√ß√£o em uma palavra de 32 bits; isso √© deixado para a parte de um leitor curioso (e paciente, afinal, ele leu at√© o final) deste post. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫nica observa√ß√£o no final √© quando criaremos uma tabela de constantes. Em nenhum caso, podemos faz√™-lo no seguinte estilo </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint32_t Data [32] PROGMEM = {0xF82345, ...}</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o ponto, √© claro, n√£o est√° nos atributos da descri√ß√£o da matriz, mas nos pr√≥prios dados na forma de n√∫meros m√°gicos. </font><font style="vertical-align: inherit;">Como os autores observaram com raz√£o, definitivamente n√£o √© mais burro do que eu, um c√≥digo bem escrito √© auto-documentado e, se escrevermos a constante acima (e o restante) na forma</font></font><br><br><pre> <code class="plaintext hljs">#define POWROUD(pow) ((uint8_t)((pow &amp; 0x07)*log(2)+0.5)) #define MULT(pow) (2^pow / 10^POWROUND(pow)) #define MULTRAW(pow) (uint32_t((MULT(pow) &lt;&lt; 24) +0.5)) #define BYTEMASK 0xFF #define POWDATA(pow) ((POWROUND(pow) &amp; BYTEMASK)| (MULTRAW(pow) &amp; (~BYTEMASK))) const uint32_t Data[(BYTEMASK/8)+1] = { POWDATA(0x00),POWDATA(0x08), ..POWDATA(0xF8)}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ningu√©m nos enviar√° perguntas perplexas e, se algu√©m nos enviar, definitivamente n√£o podemos respond√™-las, ainda ser√° in√∫til. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos propor uma modifica√ß√£o desse m√©todo em que uma pot√™ncia adequada de dez ser√° calculada n√£o para a borda direita do segmento, mas para a esquerda e, em seguida, o resultado n√£o ser√° desviado para a direita para levar em conta a pot√™ncia de dois, mas para a esquerda. </font><font style="vertical-align: inherit;">Do ponto de vista da matem√°tica, os m√©todos s√£o absolutamente equivalentes. </font><font style="vertical-align: inherit;">Vejamos o resultado: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.953125 * 2 ^ 9 = 1.953125 * 2 ^ (8 + 1) = 1.953125 * 42949673/256/256/256 (2.56) * 2 * 10 ^ 2 = 10 * 10 ^ 2</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j√° √© muito f√°cil encontrar 1000 aqui. Claro, tamb√©m precisar√≠amos converter a mantissa obtida e a ordem em seq√º√™ncias de caracteres, arredondar cuidadosamente, ajustar o resultado ao formato necess√°rio, adicionar um personagem, levar em conta casos especiais e assim por diante, mas isso n√£o √© mais t√£o interessante, a parte principal transforma√ß√µes que realizamos. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439578/">https://habr.com/ru/post/pt439578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439568/index.html">SSDs baseados em QLC - um assassino de disco r√≠gido? Realmente n√£o</a></li>
<li><a href="../pt439570/index.html">Magia IPython para editar tags de c√©lulas Jupyter</a></li>
<li><a href="../pt439572/index.html">Projeto assistido por computador de equipamentos eletr√¥nicos</a></li>
<li><a href="../pt439574/index.html">Protocolo SmartCard I2C. Comandos do Exchange APDU via interface I2C</a></li>
<li><a href="../pt439576/index.html">Uma ampla vis√£o geral das entrevistas em Python. Dicas e truques</a></li>
<li><a href="../pt439580/index.html">Fazendo o Git for Windows funcionar no ReactOS</a></li>
<li><a href="../pt439584/index.html">Projeto Lenergy como repensar fontes de alimenta√ß√£o port√°teis</a></li>
<li><a href="../pt439586/index.html">Protocolo SPBm como base do Extreme Automated Campus</a></li>
<li><a href="../pt439588/index.html">A ESET descobriu novas vers√µes do Trojan DanaBot</a></li>
<li><a href="../pt439590/index.html">Qualidades: CTF nacional de seguran√ßa cibern√©tica da Ar√°bia Saudita e Om√£ em 2019. WriteUp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>