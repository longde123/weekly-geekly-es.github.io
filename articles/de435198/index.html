<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏾 🤦🏿 👇🏻 Arduin und LED, oder wie man den Kinderdesigner aufwertet 🖖🏻 🕉️ 🎻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Sohn war fest mit dem Magnetkonstruktor Magformers verbunden . Nachdem das Kind eine Reihe von Fixiks durchgesehen hatte, in denen derselbe Konst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduin und LED, oder wie man den Kinderdesigner aufwertet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435198/"><img src="https://habrastorage.org/webt/wp/c4/ox/wpc4oxeubxh_dsoa07dy5wfccoa.jpeg"><br><br>  Mein Sohn war fest mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Magnetkonstruktor Magformers verbunden</a> .  Nachdem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> Kind eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Fixiks durchgesehen hatte, in denen derselbe Konstruktor vorgestellt wurde,</a> fragte es: "Dad, warum haben Fixics Details, die glänzen, aber wir nicht?" <br><br>  Es stellte sich heraus, dass es wirklich ein „Magformers Neon LED Set“ gibt, bei dem es neben den üblichen Bausteinen auch ein Element mit einer LED gibt.  Da wir zu diesem Zeitpunkt bereits eine ganze Schachtel Magnete in allen möglichen Formen und Größen gesammelt hatten (was mich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">betrifft,</a> sind die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chinesischen Magformer</a> dem Original überhaupt nicht unterlegen), wollte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">irgendwie</a> kein weiteres Set nur für eine Glühbirne kaufen.  Darüber hinaus kostete dieses Set deutlich mehr als ein ähnliches Set ohne Hintergrundbeleuchtung. <br><br>  Nachdem ich geschätzt hatte, dass die Komponenten nur ein paar Dollar enthalten, von denen ich die meisten bereits hatte, beschloss ich, meine Morgulka abzuholen.  Ja, und mit Effekten, die das Original nicht hatte. <br><br>  Unter der Katze finden Sie die Option eines Blinkers am ATTiny85 und des LED-Panels an den WS8212-LEDs.  Ich werde über Schaltkreise sprechen, wie ich das Ganze mit der Batterie betrieben habe, sowie über die nicht offensichtlichen Probleme, die ich auf dem Weg gemacht habe.  Ich werde auch ausführlich über die Softwarekomponente des Projekts sprechen. <br><a name="habracut"></a><br><h2>  Erste Schritte </h2><br>  Es schien mir, dass das Leuchten einer normalen LED (sogar RGB) langweilig und banal ist.  Aber so etwas wie WS8212 zu fühlen, schien interessant.  Auf ebee wurden sowohl einzelne LEDs als auch Matrizen mit einer Größe von bis zu 16 x 16 angeboten.  Nachdem ich verschiedene Module gekauft hatte, entschied ich mich für eine 4x4 Matrix.  Es gibt viele LEDs, um verschiedene visuelle Effekte zu erzielen, während das Modul in seiner Größe mit dem Fenster des quadratischen Blocks des Designers vergleichbar ist. <br><br><img src="https://habrastorage.org/webt/f8/wj/kv/f8wjkvhcyj5zvrzyp81xb0zslu4.jpeg"><br><br>  Zur Steuerung der LED-Matrix reicht nur ein Pin des Mikrocontrollers aus, sodass selbst der Arduino Nano wie eine Büste aussieht (außerdem passt er nicht in das Gehäuse).  Der Digispark-Klon auf dem ATTiny85-Controller erwies sich jedoch als genau richtig - er verfügt nicht über viel Speicher und Pins, ist aber mehr als genug für den LED-Blinker.  Das Modul lässt sich perfekt in die Arduino IDE integrieren und verfügt über einen USB-Bootloader an Bord, sodass die Programmierung dieses Moduls sehr einfach und komfortabel ist.  Ich wollte es schon lange versuchen. <br><br>  Begonnen mit dem einfachsten Schema. <br><br><img src="https://habrastorage.org/webt/-8/yx/5b/-8yx5b02f2dxtqaps1tw6aoj_io.png"><br><br>  In dieser Form war es möglich, alle Glow / Blink-Algorithmen (dazu weiter unten) schnell zu debuggen.  Ein drahtgebundenes Spielzeug ist jedoch nicht der Fall - Sie müssen über die Batterieleistung nachdenken.  Darüber hinaus wurde beschlossen, Lithium zu verwenden, um nicht mit Fingerbatterien bankrott zu gehen (die außerdem nicht in den Umschlag passen).  Und da es eine Lithiumbatterie gibt, müssen Sie sich überlegen, wie Sie sie aufladen sollen.  In den Behältern haben wir gerade einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„beliebten“ Laderegler auf dem TP4056-Chip gefunden,</a> der bei dieser Gelegenheit gekauft wurde. <br><br>  Aber es hat nicht sofort funktioniert.  Die Schaltung des Digispark ATTiny85-Moduls ist nicht sehr dafür ausgelegt - sie wird entweder über USB mit Strom versorgt, aber der Strom wird direkt an den Mikrocontroller (über den + 5-Bus) oder über den VIN-Eingang geliefert, aber dann geht der Strom über den linearen Stabilisator 7805. Option, wenn das Lithium-Lademodul Das Einstecken in die Lücke zwischen dem USB-Anschluss und dem Mikrocontroller ist nicht vorgesehen.  Ich musste die Schaltung ein wenig modifizieren und die zusätzlichen Details entfernen. <br><br><img src="https://habrastorage.org/webt/99/ta/ab/99taabsud7cdoakqixa8ah4ee0y.png"><br><br>  Jetzt wird der VIN-Pin mit USB-Strom versorgt und geht dann zum Ladegerät-Eingang.  Der Ladegerätausgang (tatsächlich ist der Akku direkt angeschlossen) geht über den 5-V-Fuß zurück in die Platine.  Und obwohl es tatsächlich 3 bis 4,2 V (Batteriespannung) geben wird, ist dies ganz normal - der Betriebsspannungsbereich des Mikrocontrollers beträgt 1,8 bis 5,5 V.  Und selbst das LED-Modul arbeitet normal ab 2,7 V, obwohl unter 3,2 V die blaue LED etwas fehlt und die Farben ein wenig in Gelb „schweben“. <br><br>  Um Energie zu sparen, verschwand auch die ständig leuchtende D2-LED.  Das allgemeine Schema sieht jetzt so aus <br><br><img src="https://habrastorage.org/webt/pr/d_/fq/prd_fqhsjwulccuuw-1aissl52k.png"><br><br>  Es wäre möglich, den Stromkreis über den USB-Anschluss im Ladegerät zu speisen, aber dann würde die Möglichkeit, Firmware über den USB-Anschluss auf der Controller-Karte hochzuladen, verloren gehen.  Es wäre möglich, zwei USB-Anschlüsse für verschiedene Zwecke zu belassen - einen zum Aufladen und einen für die Firmware, aber das ist irgendwie falsch. <br><br>  Ich habe bei ebay einen Akku der Größe 6x25x35 gekauft, der sich jedoch als defekt herausstellte oder durch einen Kurzschluss oder einen großen Ladestrom abgeschaltet wurde (standardmäßig ist der Ladestrom auf 1A eingestellt und Sie müssen einen Widerstand löten, um den Strom zu reduzieren).  In jedem Fall fiel die Spannung an der Batterie auf 1 V ab, wenn die Last angeschlossen wurde, selbst bei 10 mA.  Zum Zeitpunkt des Tests habe ich von einem kleinen Quadrocopter auf einen halb leeren LiPo-Akku umgestellt.  Wenig später bestellte ich die Batterie bei einem anderen Verkäufer und es stellte sich heraus, dass sie gut war. <br><br>  Im Prinzip wäre es möglich, hier anzuhalten, die Verbindungsdrähte zu löten und alles vorsichtig in eine Art Gehäuse zu schieben, aber ich entschied mich, den Verbrauch der Schaltung zu messen.  Und dann habe ich geweint.  Nun, im funktionierenden Zustand (wenn die Glühbirnen voll leuchten) frisst dieses Ding bis zu 130 mA, also beträgt der Verbrauch in Ruhe mehr als 25 mA!  Das heißt,  Dieser Blinker verbraucht meine 600mAh Batterie in weniger als einem Tag! <br><br>  Es stellte sich heraus, dass etwa 10 mA LEDs verbrauchen.  Auch wenn sie nicht aufleuchten, arbeitet in jedem ein Mikrocontroller und wartet auf einen Befehl.  Das heißt,  Sie müssen eine Ausschaltschaltung für die LEDs erstellen. <br><br>  Die restlichen 15 mA werden vom Mikrocontroller verbraucht.  Ja, es kann ins Bett gebracht werden und laut Datenblatt wird der Verbrauch mit Mikroampere gemessen, aber tatsächlich war es nicht möglich, weniger als 1 mA zu erhalten.  Ich schaltete den ADC aus und übersetzte die Pins in Eingang.  Es scheint, dass irgendwo in der Schaltung eine Art Leck vorhanden ist, aber meine bescheidenen Kenntnisse der Elektronik reichen nicht aus, um es zu finden und zu verstehen. <br><br><h2>  Wir erschweren das Schema </h2><br>  Dann erinnerte ich mich, dass ich einen PT1502-Chip für einen Test gekauft hatte.  Dieser Chip ist ein Lithium-Batterieladecontroller mit einem Netzteil mit mehreren Steuereingängen.  Die einzige Schwierigkeit besteht darin, dass die Mikroschaltung in einem 4x4 mm QFN20-Gehäuse geliefert wird und einige Umreifungen erfordert.  Das Löten zu Hause ist schwierig, aber möglich.  Die Gebühr ist für eine reguläre LUT schwierig und muss bei den Chinesen bestellt werden.  Aber wir haben keine Angst vor Schwierigkeiten, oder? <br><br>  In mehreren Feldern kann das Schema wie folgt beschrieben werden. <br><br><img src="https://habrastorage.org/webt/t9/c5/rg/t9c5rgauskpsz1momglwordnf0o.png"><br><br>  Im ausgeschalteten Zustand werden die Steuerung und die LEDs nicht mit Strom versorgt.  Das Gerät verfügt über eine Ein- / Aus-Taste, die den Blinker einschaltet (es wechselt auch den Modus).  Die LED leuchtet beispielsweise eine Minute lang, und wenn keine Benutzeraktivität vorliegt (niemand drückt eine Taste), schaltet sich das Gerät aus.  Das heißt,  Es geht nicht nur schlafen, sondern schaltet sich durch das Power Hold-Signal aus.  Und es schaltet alles auf einmal aus - sowohl den Mikrocontroller als auch die LEDs.  Die Ein- und Ausschaltfunktion ist im PT1502-Chip implementiert <br><br>  Sie müssen nur noch einen Schaltplan zeichnen und eine Leiterplatte erstellen.  Die Schaltung besteht größtenteils aus dem Datenblatt PT1502 sowie dem Digispark ATTiny85-Modul.  Die Mikroschaltung des Leistungsreglers PT1502 ist funktional in mehrere Teile unterteilt, daher ist sie in Blöcke in der Schaltung unterteilt. <br><br><img src="https://habrastorage.org/webt/fc/s6/qu/fcs6qu4zqgfja5p4hjacywrds8k.png"><br><br>  Dies ist in der Tat ein Lithium-Batterieladecontroller mit einem eigenen Kabelbaum.  LED1 zeigt den Ladezustand an - dann ist die Ladung eingeschaltet.  Der Widerstand R6 stellt den Ladestrom auf 470 mA ein.  Da ich eine 600-mAh-Batterie habe, können Sie im Prinzip den Strom erhöhen und einen Widerstand bei 780-800 Ohm bis zu 600 mA einstellen.  Ich bin mir jedoch nicht sicher über die besondere Qualität meines Akkus - es ist besser, langsamer zu laden, aber es hält länger. <br><br>  Betrachten Sie einen Energieplan <br><br><img src="https://habrastorage.org/webt/z1/rb/_a/z1rb_a2zu2a95pvxzk629o1tsjm.png"><br><br>  Die SW1-Taste startet das gesamte System - der PT1502-Chip wacht von selbst auf und startet dann alle Stromquellen (von denen er 3 hat).  Wenn die Stromversorgung installiert ist, startet die Mikroschaltung den Mikrocontroller, indem sie das RESET-Signal freigibt.  Zur Vereinfachung des Debuggens habe ich außerdem eine separate Schaltfläche zum Zurücksetzen hinzugefügt. <br><br>  Das HOLD-Signal wird verwendet, um das gesamte System auszuschalten.  Wenn der Mikrocontroller startet, sollte er das Gerät auf diese Leitung stellen.  Wenn es Zeit zum Abrunden ist, setzt der Mikrocontroller auf der HOLD-Leitung Null und der PT1502-Leistungschip stoppt alle Stromquellen. <br><br>  Es wäre möglich, die niedrige Batterieladung mithilfe des BAT_LOW-Ausgangs zu verfolgen, aber in diesem Artikel habe ich sie bewertet. Sie müssen keine Daten speichern, und nichts explodiert, wenn Sie nicht rechtzeitig eine leere Batterie bemerken.  Stirbt so stirbt.  Aber nur für den Fall, dass der Vorstand den Kontakt für dieses Geschäft bereitstellte. <br><br>  Kehren wir für eine Sekunde zur SW1-Taste zurück.  Ich habe beschlossen, keine 2 separaten Tasten zum Einschalten und Steuern zu erstellen.  Daher ist dieselbe Taste auch mit dem ATTiny85 verbunden und schaltet während des Betriebs die Blinkmodi um.  Die Werte des Teilers R7-R8 werden so gewählt, dass der Port des PB2-Mikrocontrollers nicht verbrannt wird.  Für alle Batteriespannungsbereiche (3,3 - 4,2 V) wird die Spannung innerhalb der angegebenen Datenblattgrenzen (0,7 * VCC - VCC + 0,5 V) an den Fuß des Controllers geliefert. <br><br>  Betrachten Sie eine Stromquelle <br><br><img src="https://habrastorage.org/webt/u1/3q/kf/u13qkfyn6g7gffo_qb8j9licy4w.png"><br><br>  Dies ist ein gepulster DC-DC-Wandler.  Die Ausgangsspannung wird durch die Widerstände R10-R11 eingestellt und gemäß der Formel aus dem Datenblatt auf 3,3 V eingestellt.  Alles andere ist ein einfaches Umschnallen. <br><br>  Eine solche ausgetrickste Stromquelle wird für immer nicht wirklich benötigt - es wäre möglich, den Mikrocontroller im Allgemeinen direkt über die Batterie mit Strom zu versorgen.  Es ist nur so, dass diese Quelle bereits im PT1502-Chip implementiert ist und bei Bedarf ein- und ausgeschaltet werden kann - warum nicht? <br><br><img src="https://habrastorage.org/webt/ad/8w/0z/ad8w0zewrcux0hdetprifertqss.png"><br><br>  Der Chip hat auch 2 lineare Stabilisatoren, aber ich werde sie nicht verwenden.  Wie sich herausstellte, ist es leider immer noch notwendig, die Eingangsspannung an diese Quelle zu liefern, andernfalls glaubt die Mikroschaltung, dass die Leistung immer noch nicht stabil genug ist und startet den Mikrocontroller nicht (dieses Wissen wurde mir durch eine Woche Löten der Testplatine hin und her vermittelt - ich konnte nicht verstehen, warum es nicht funktioniert ) <br><br>  Kommen wir zum logischen Teil. <br><br><img src="https://habrastorage.org/webt/sq/su/xj/sqsuxjeblb7507pz8ej2h1t3yui.png"><br><br>  Das USB-Kabel wird unverändert von der Digispark-Karte geläppt.  Dies ist erforderlich, um die USB-Spannung (die 3,3 V beträgt) und die Signale des Mikrocontrollers (der im Original mit 5 V betrieben wird) zu koordinieren.  Da in meinem Fall der Mikrocontroller auch mit 3,3 V betrieben wird, könnte die Schaltung vereinfacht werden, aber nur für den Fall, dass ich die ursprüngliche Schaltung auf der Platine geschieden habe. <br><br><img src="https://habrastorage.org/webt/qe/q8/xr/qeq8xr1bwr-ux0jnsk5na1p6eaw.png"><br><br>  An der Bindung des Mikrocontrollers ist nichts Interessantes. <br><br>  Der letzte Schliff ist der Stecker <br><br><img src="https://habrastorage.org/webt/ic/vt/ey/icvtey-cwulcyqozyphkmglv-0m.png"><br><br>  Tatsächlich habe ich mir auf ATTiny85 mit USB-Unterstützung und einem Leistungsregler mit Lithiumbatterie ein solches Debugging-Board besorgt.  Daher habe ich mich nicht darauf beschränkt, nur die Leitung an die LED auszugeben.  Stattdessen habe ich alle Leitungen des Mikrocontrollers zum Kamm gebracht - gleichzeitig ist es bequem, eine Verbindung zum Programmierer herzustellen. <br><br>  Und lassen Sie in Zukunft fast alle Leitungen fest an eine bestimmte Funktionalität gebunden sein (PB1 - Leitung halten, PB2 - Netzschalter, PB3 / PB4 - USB, PB5 - Zurücksetzen), wird es möglich sein, einige Grenzen zu umgehen.  Löten Sie beispielsweise das USB-Kabel nicht und lassen Sie die PB3 / PB4-Leitungen los.  Oder lehnen Sie beispielsweise einen Reset ab und geben Sie PB5 frei.  In der Zwischenzeit bleibt nur PB0 frei - und schließen Sie unsere LED daran an. <br><br>  Wir gehen an die Tafel.  Angesichts der Einschränkungen hinsichtlich der Größe der Platine in 40 x 40 mm, der Anzahl der Komponenten und des QFN20-Gehäuses des PT1502-Chips habe ich nicht einmal daran gedacht, die Platine zu Hause herzustellen.  Deshalb habe ich sofort angefangen, das kompakteste Zweischichtbrett zu züchten.  Das habe ich bekommen <br><br><img src="https://habrastorage.org/webt/yt/6q/wh/yt6qwhfd9zkia64yyejpjx9litu.png"><br><br>  Zur Vereinfachung der Verwendung habe ich auf der Rückseite alle möglichen Ausgabefunktionen signiert (die Idee kam vom Digispark-Board). <br><br><img src="https://habrastorage.org/webt/q-/on/8t/q-on8tdmxq_bvht8egr5ilipb4s.png"><br><br>  Ich habe das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Board</a> bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JLCPCB bestellt</a> .  Um ehrlich zu sein, bin ich mit der Qualität nicht sehr zufrieden. Wenn Sie den Chip mehrmals löten, ist die Maske in der Nähe der kleinen Kontakte des PT1502 etwas getrübt.  Nun, kleine Inschriften schwebten ein wenig.  Wenn jedoch beim ersten Mal alles gelötet wird, dann die Normen. <br><br>  Zum Löten von QFN20 benötigen Sie einen Lötkolben, alles andere kann mit einem bestimmten Lötkolben mit einer bestimmten Fähigkeit gelötet werden.  So sieht die gelötete Platine aus <br><br><img src="https://habrastorage.org/webt/ct/km/4g/ctkm4gs_myfjjfeoukwn4ijuuc4.jpeg"><br><br><h2>  Gehäuse </h2><br>  Es ist Zeit, zum Rumpf überzugehen.  Ich habe es auf einem 3D-Drucker gedruckt.  Schnörkelloses Design - Box und Knopf.  An der Box sind spezielle Haken vorgesehen, um die Glühwürmchen im quadratischen Standardmodul des Designers zu installieren. <br><br><img src="https://habrastorage.org/webt/g9/bz/yd/g9bzydcnm7bwonoo6rhe-1hby7k.png"><br><br>  Die Hauptplatine und der Akku befinden sich im Gehäuse. <br><br><img src="https://habrastorage.org/webt/zp/4u/x-/zp4ux-vaqurrmg9yqe3jb3jkry8.jpeg"><br><br><img src="https://habrastorage.org/webt/4f/oa/dw/4foadwyytzwav_lfiyvqrl5lcxs.jpeg"><br><br>  Das LED-Panel ist auf der Abdeckung montiert, die wiederum mit Schrauben an der Hauptbox angeschraubt wird <br><br>  Zuerst dachte ich daran, das LED-Panel mit Schrauben an der Abdeckung festzuschrauben, aber am Ende klebte ich es einfach auf ein doppelseitiges Klebeband.  Es stellte sich so heraus <br><br><img src="https://habrastorage.org/webt/vy/ks/y2/vyksy2ccuvrwcrjmxgvzolhlia0.jpeg"><br><br>  In dieser Form kann das Gerät bereits verwendet werden, sieht aber trotzdem hässlich aus - es ist nicht genügend Diffusor vorhanden. <br><br>  Ich habe versucht, die erste Version des Diffusors mit der Technologie des Schrumpfens von PET-Flaschen mit einem Bau-Haartrockner herzustellen (siehe Flugzeugmodelle). <br><br>  Also, zuerst brauchst du ein Leerzeichen.  Ich habe es aus Gips gemacht, den ich in eine Form gegossen habe, die ich auf einem 3D-Drucker gedruckt habe.  In der ersten Version war die Form einteilig und ich konnte die gegossene Scheibe nie herausziehen.  Deshalb musste ich eine zweiteilige Form machen. <br><br><img src="https://habrastorage.org/webt/gb/x0/0i/gbx00iokd8ea_lfquvmbbfebed4.jpeg"><br><br>  Die Idee der Methode ist wie folgt.  Sie stellen eine Flasche Babyjoghurt auf einen Rohling und setzen sie mit einem Haartrockner auf.  Hier sind nur Teile von 20 verschiedenen Behältern unter unterschiedlicher Milch wiedergegeben. Ich habe es nie geschafft, dieses Ding schön zu platzieren, ohne Falten und Blasen.  Anscheinend müssen Sie eine Art Vakuuminstallation und Sitzplastikfolie umzäunen.  Im Allgemeinen stellte sich heraus, dass es für ein solches Fahrzeug zu schwierig war. <br><br>  Nachdem ich durch die Gophers gemurrt hatte, fand ich ein paar Meter Verbatim PET Transparent Plastiksonde.  Ich beschloss, den Diffusor nur zum Drucken auszuprobieren.  Und obwohl der Kunststoff am Eingang zum Drucker kristallklar erscheint, ist der Realteil langweilig.  Dies liegt wahrscheinlich an der internen Struktur, wie  Schichten füllen das Volumen nicht vollständig aus, sondern überlappen sich mit Lücken und Lücken.  Wenn Sie versuchen, das Teil mit Sandpapier für eine glattere Oberfläche zu verarbeiten, erhalten wir außerdem noch mehr Mattierung.  Dies ist jedoch genau das, was ich brauchte. <br><br>  Ich war zu faul, um mich mit der Halterung für den Diffusor zu beschäftigen, also fügte ich sie dem Heißkleber hinzu.  Mein Design ist jetzt bedingt zusammenklappbar.  Ich könnte mit der Erfindung einer Art Riegel verwechselt werden, aber mir ist bereits die transparente Kunststoffsonde ausgegangen.  Also lass es heiß schmelzen. <br><br><img src="https://habrastorage.org/webt/xb/vy/49/xbvy49czm3mqdgjrexvvrcsm25m.jpeg"><br><br><img src="https://habrastorage.org/webt/fz/tx/tx/fztxtxljbgq0uwqnhlne0-mvcdc.jpeg"><br><br><h2>  Firmware </h2><br>  Bei LED-Blinkern müssen Sie nicht besonders in die Peripherie des Mikrocontrollers eintauchen - nur ein paar Funktionen für die Arbeit mit GPIO reichen aus.  Da das Modul jedoch an die Arduino-Plattform angedockt ist, können Sie dies nutzen. <br><br>  Zunächst einige Definitionen und Konstanten <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Number of total LEDs on the board. Mine has 4x4 LEDs #define NUM_HW_PIXELS 16 // Pin number where LED data pin is attached #define DATA_PIN 0 // Pin number where mode switch button is attached #define BUTTON_PIN 2 // Power Enabled pin #define POWER_EN_PIN 1 // Max brightness (dimming the light for debugging) #define MAX_VAL 255</span></span></code> </pre> <br>  Dies bestimmt die Anzahl der Pixel in meiner Matrix, die Pin-Nummern und die maximale Helligkeit der LEDs (während des Debuggens war es zweckmäßig, sie auf 50 einzustellen, damit meine Augen nicht geblendet werden). <br><br>  Die LEDs in meiner Matrix sind nicht offensichtlich angeordnet - im Zickzack.  Daher musste ich für verschiedene Effekte neu nummerieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// LED indexes for different patterns uint8_t circleLEDIndexes[] = {0, 1, 2, 3, 4, 11, 12, 13, 14, 15, 8, 7}; uint8_t beaconLEDIndexes[] = {6, 5, 10, 9}; uint8_t policeLEDIndexes[] = {7, 6, 10, 11, 4, 5, 9, 8};</span></span></code> </pre> <br>  Um die LEDs zu steuern, habe ich das Rad nicht neu erfunden und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigte Bibliothek für die Arbeit mit WS8211-LEDs genommen</a> .  Die Bibliotheksoberfläche ist leicht weiß getüncht.  Einige Zusatzfunktionen (z. B. die Konvertierung von HSV in RGB) blieben ebenfalls hängen. <br><br>  Zunächst müssen die Karte und die WS8211-Bibliothek initialisiert werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Driver Ai_WS2811 ws2811; void setup() { // Set up power pinMode(POWER_EN_PIN, OUTPUT); digitalWrite(POWER_EN_PIN, HIGH); // initialize LED data pin pinMode(LED_PIN, OUTPUT); // Initialize button pin pinMode(BUTTON_PIN, INPUT); // Initialize WS8211 library static CRGB ledsBuf[NUM_HW_PIXELS]; ws2811.init(DATA_PIN, NUM_HW_PIXELS, ledsBuf); // Set the watchdog timer to 2 sec wdt_enable(WDTO_2S); }</span></span></code> </pre> <br>  Zunächst müssen Sie das POWER HOLD-Signal auf Eins setzen. Dies ist ein Signal an den PT1502-Chip, dass der Mikrocontroller aufgewickelt wurde und ordnungsgemäß funktioniert.  Die Mikroschaltung wiederum versorgt den Mikrocontroller und die LEDs regelmäßig mit Strom, solange das HOLD-Signal auf Eins eingestellt ist. <br><br>  Als nächstes werden die Beine zur Steuerung der LED am Ausgang und die Tasten am Eingang konfiguriert.  Danach können Sie die WS8211-Bibliothek initialisieren. <br><br>  Da dies ein ziemlich autonomes Gerät ist, kann man nicht zulassen, dass der Mikrocontroller in einem unverständlichen Zustand bleibt und die gesamte Batterie verschlingt.  Dazu starte ich den Watchdog-Timer für 2 Sekunden.  Der Timer wird in der Hauptprogrammschleife neu gestartet. <br><br>  Jetzt müssen Sie einige Hilfsfunktionen definieren.  Die WS8211-Bibliothek speichert einen Puffer mit den Farbwerten jeder LED.  Das direkte Arbeiten mit dem Puffer ist nicht sehr praktisch, da ich eine einfache Funktion zum Schreiben von RGB-Werten auf eine bestimmte LED geschrieben habe <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRgb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ CRGB * leds = ws2811.getRGBData(); leds[led_idx].r = r; leds[led_idx].g = g; leds[led_idx].b = b; }</code> </pre> <br>  In den meisten Fällen ist das Zählen von Farben im RGB-Farbmodell jedoch nicht sehr bequem oder sogar unmöglich.  Wenn Sie beispielsweise einen Regenbogen zeichnen, ist es bequemer, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem HSV-Farbmodell zu arbeiten</a> .  Die Farbe jedes Pixels wird durch den Wert des Farbtons und der Helligkeit festgelegt.  Die Sättigung wird der Einfachheit halber weggelassen (Maximum wird verwendet).  Die Farbtonwerte werden auf einen Bereich von 0 bis 255 reduziert (anstelle des Standards 0 bis 359). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * HVS to RGB conversion (simplified to the range 0-255) **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> brightness)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//this is the algorithm to convert from RGB to HSV double r = 0; double g = 0; double b = 0; double hf = hue/42.6; // Not /60 as range is _not_ 0-360 int i=(int)floor(hue/42.6); double f = hue/42.6 - i; double qv = 1 - f; double tv = f; switch (i) { case 0: r = 1; g = tv; break; case 1: r = qv; g = 1; break; case 2: g = 1; b = tv; break; case 3: g = qv; b = 1; break; case 4: r = tv; b = 1; break; case 5: r = 1; b = qv; break; } brightness = constrain(brightness, 0, MAX_VAL); setRgb(led_idx, constrain(brightness*r, 0, MAX_VAL), constrain(brightness*g, 0, MAX_VAL), constrain(brightness*b, 0, MAX_VAL) ); }</span></span></code> </pre><br>  Die Funktion wurde aus der Ai_WS8211-Bibliothek übernommen und leicht abgelegt.  In der Originalversion dieser Funktion aus der Bibliothek gab es einige Fehler, aufgrund derer die Farbe auf den Regenbogen mit Rucken angezeigt wurde. <br><br>  Kommen wir zur Implementierung verschiedener Effekte.  Jede Funktion wird von der Hauptschleife aufgerufen, um einen „Frame“ zu zeichnen.  Da jeder Effekt zwischen den Aufrufen mit unterschiedlichen Parametern arbeitet, werden sie in statischen Variablen gespeichert. <br><br>  Dies ist der einfachste Effekt - alle LEDs sind mit einer Farbe gefüllt, die sich reibungslos ändert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> hue = <span class="hljs-number"><span class="hljs-number">0</span></span>; hue++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, hue, MAX_VAL); ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Der nächste Effekt ist interessanter: Er zeigt einen Regenbogen entlang der Kontur der Matrix an und die Farben im Regenbogen verschieben sich allmählich in einem Kreis. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slidingRainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hue = (pos + led*<span class="hljs-number"><span class="hljs-number">256</span></span>/ARRAY_SIZE(circleLEDIndexes)) % <span class="hljs-number"><span class="hljs-number">256</span></span>; setHue(circleLEDIndexes[led], hue, MAX_VAL); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  Und dieser Effekt füllt die gesamte Matrix mit einer zufälligen Farbe, die zuerst sanft aufleuchtet und dann auch glatt erlischt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomColorsFadeInOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !goesUp) { color = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; goesUp = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == MAX_VAL &amp;&amp; goesUp) { goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, color, curLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(goesUp) curLevel++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curLevel--; ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  Die nächste Gruppe von Effekten zeichnet verschiedene blinkende Leuchtfeuer.  So baut zum Beispiel ein Kind gerne einen Bulldozer aus Magneten und ein orangefarbener Blinker ist dort sehr nützlich. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orangeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ORANGE_HUE = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos+=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(circleLEDIndexes), <span class="hljs-number"><span class="hljs-number">70</span></span>); setHue(circleLEDIndexes[led], ORANGE_HUE, brightness); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Technisch gesehen sieht der Effekt wie ein heller Punkt aus, der sich entlang der Matrix bewegt.  Damit es jedoch schön aussieht, verschwinden benachbarte LEDs allmählich, wenn Sie sich vom Hauptpunkt entfernen.  Daher brauchte ich eine Funktion, die dieselbe Helligkeit berechnet. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightnessByPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ledPos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pos - ledPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(diff &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-diff); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = MAX_VAL - constrain(MAX_VAL*diff/delta, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brightness; }</code> </pre><br>  Pos ist eine bestimmte bedingte Position des Lichthelligkeitspunkts, die auf einen Loopback-Bereich von 0 bis 255 abgebildet wird.  ledPos ist die Position der LED (im selben Bereich angezeigt), deren Helligkeit Sie berechnen müssen.  Wenn der Positionsunterschied größer als Delta ist, leuchtet die LED nicht auf und je näher an der Position, desto heller leuchtet sie. <br><br>  Oder zum Beispiel ein rot-blaues Blinklicht der Polizei <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">policeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RED_HUE = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BLUE_HUE = <span class="hljs-number"><span class="hljs-number">170</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(policeLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ledPos = led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(policeLEDIndexes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], RED_HUE, brightness); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brightness == <span class="hljs-number"><span class="hljs-number">0</span></span>) { brightness = brightnessByPos((pos+<span class="hljs-number"><span class="hljs-number">100</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], BLUE_HUE, brightness); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Da es sich um Autos handelt, ist die Ampel hier kein Problem zu implementieren. <br><br>  Dies sind Funktionen, die verschiedene Verkehrssignale an verschiedenen Positionen enthalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPixels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;NUM_HW_PIXELS; i++) { setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) setRgb(i, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellowTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">4</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; i++) setRgb(i, MAX_VAL, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greenTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">8</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; i++) setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); }</code> </pre> <br>  Es ist Zeit, es wiederzubeleben.  Die Ampel arbeitet nach einem speziellen Programm, das in einer Art Bytecode definiert ist.  Die Platte beschreibt den Modus und die Zeit, für die dieser Modus eingeschaltet werden muss. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TRAFFIC_LIGHTS { NONE, RED, YELLOW, GREEN }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trafficLightState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> duration; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trafficLightState trafficLightStates[] = { {NONE, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// clear yellow {RED, 7000}, // red {YELLOW, 2000}, // red + yellow {NONE, 1}, // clear red+yellow {GREEN, 7000}, // green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 1}, // clear green {YELLOW, 2000}, // yellow };</span></span></code> </pre> <br>  Eigentlich die Funktion, die alles verarbeitet <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curStateIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> curStateTimeStamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Switch to a new state when time comes if(millis() - curStateTimeStamp &gt; (unsigned long)trafficLightStates[curStateIdx].duration) { curStateIdx++; curStateIdx %= ARRAY_SIZE(trafficLightStates); curStateTimeStamp = millis(); } switch(trafficLightStates[curStateIdx].state) { case NONE: clearPixels(); ws2811.sendLedData(); break; case RED: redTrafficLights(); break; case YELLOW: yellowTrafficLights(); break; case GREEN: greenTrafficLights(); break; default: break; } // Just waiting delay(10); }</span></span></code> </pre><br>  Bei Erreichen des angegebenen Zeitintervalls wird der nächste Ampelmodus eingeschaltet und der Countdown erneut gestartet. <br><br>  Der letzte Effekt, bei dem meine Vorstellungskraft ausreichte, sind Sternchen.  5 zufällige LEDs leuchten mit zufälliger Helligkeit und schalten sich dann sanft aus.  Wenn ein Stern ausgeht, leuchtet ein anderer an einer zufälligen Stelle auf. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> numleds = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledIndexes[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numleds; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ledIndexes[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = rand() % (NUM_HW_PIXELS+<span class="hljs-number"><span class="hljs-number">1</span></span>); CRGB * leds = ws2811.getRGBData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(leds[led].r == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ledIndexes[i] = led; maxVal[i] = rand() % (MAX_VAL<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; curVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = ledIndexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] &lt; maxVal[i]) curVal[i]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == maxVal[i]) maxVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span> || --curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ledIndexes[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; setRgb(led<span class="hljs-number"><span class="hljs-number">-1</span></span>, curVal[i], curVal[i], curVal[i]); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Irgendwo hier hat sich ein böser Käfer eingeschlichen.  Manchmal leuchten die Sterne scharf auf oder umgekehrt gehen sie plötzlich aus.  Aber um ehrlich zu sein, war ich zu faul, um es herauszufinden - es sieht ganz normal aus. <br><br>  Es ist Zeit, über das Sparen von Batterie nachzudenken.  Ich habe bereits die Verbrauchswerte dieser ganzen Sache angegeben.  Wenn Sie nicht daran denken, den Strom auszuschalten, verbrauchen die LEDs den Akku in ein paar Stunden.  Diese Funktion ist für das Ausschalten der Stromversorgung nach 90 Sekunden Inaktivität verantwortlich.  Anfangs waren es 60 Sekunden, aber mit einem echten Spiel war das nicht genug und 2 Minuten waren irgendwie lang. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdownOnTimeOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resetTimer = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(periodStartTime == <span class="hljs-number"><span class="hljs-number">0</span></span> || resetTimer) { periodStartTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(millis() - periodStartTime &gt;= <span class="hljs-number"><span class="hljs-number">90000U</span></span>L) { periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; shutDown(); } }</code> </pre> <br>  Tatsächlich erfolgt das Ausschalten wie folgt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clearPixels(); ws2811.sendLedData(); wdt_disable(); digitalWrite(POWER_EN_PIN, LOW); <span class="hljs-comment"><span class="hljs-comment">// No power after this point while(true) ; }</span></span></code> </pre> <br>  Wenn der Benutzer die Tasten drückt, wird der Timer zurückgesetzt.  Nach Ablauf der eingestellten Zeit setzt die Funktion das HOLD-Signal auf Null. Dies ist ein PT1502-Befehl zum Ausschalten der Stromversorgung.  Watchdog muss übrigens auch gestoppt werden, sonst weckt es nach 2 Sekunden das System und schaltet den Strom wieder ein. <br><br>  Endlich die Hauptschleife, die alles startet <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// List of pointers to functions that serve different modes void (*Modes[])() = { rainbow, slidingRainbow, orangeBeacon, policeBeacon, trafficLights, stars, randomColorsFadeInOut }; void loop() { static uint8_t mode = eeprom_read_byte( (uint8_t*) 10 ); static bool waitingForBtnUp = false; static long btnPressTimeStamp; // Button switches mode if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; !waitingForBtnUp) { delay(20); if(digitalRead(BUTTON_PIN) == HIGH) { mode++; mode %= ARRAY_SIZE(Modes); // num modes clearPixels(); ws2811.sendLedData(); delay(1); eeprom_write_byte( (uint8_t*) 10, mode ); waitingForBtnUp = true; btnPressTimeStamp = millis(); shutdownOnTimeOut(true); } } // Shut down on long press over 5s if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; waitingForBtnUp &amp;&amp; millis() - btnPressTimeStamp &gt; 5000) shutDown(); // Detect button release if(digitalRead(BUTTON_PIN) == LOW &amp;&amp; waitingForBtnUp) waitingForBtnUp = false; // display LEDs according to current mode Modes[mode](); // pong shutdown timer shutdownOnTimeOut(); // Yes, we still alive wdt_reset(); }</span></span></code> </pre><br>  Durch Drücken der Taste werden die Modi umgeschaltet und der Auto-Off-Timer zurückgesetzt.  Abhängig vom aktuellen Modus wird eine der Effektfunktionen aus der Liste Modi gestartet.  Bei jedem Zyklus wird auch der Watchdog zurückgesetzt. <br><br>  Wenn beispielsweise ein Kind ein Polizeiauto gespielt hat und nach 1,5 Minuten das Notlicht ausgeschaltet wurde, möchte der Sohn höchstwahrscheinlich nach einem zweiten Einschalten das Polizeiauto weiter spielen.  Dazu wird der ausgewählte Modus im EEPROM gespeichert (Zellennummer 10 wird vom Bulldozer ausgewählt). <br><br>  Hier ist ein Video, das zeigt, wie alles funktioniert. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5MLX1hc8Jz4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bootloader </h2><br>  Fast alles ist fertig.  Aber es gibt noch eine Sache, die abgelegt werden muss - einen Bootloader.  Tatsache ist, dass der Standard-Bootloader nicht zu uns passt. <br><br>  Erstens, wenn Sie das Gerät einschalten, wartet es bis zu 6 Sekunden - möglicherweise fließt die Firmware hinein.  Erst danach wird die Steuerung auf die Hauptfirmware übertragen.  Dies ist in der Entwicklungsphase praktisch, im fertigen Gerät jedoch ärgerlich. <br><br>  Und zweitens weiß der Standard-Bootloader nichts über den PT1502-Chip, was schön wäre, ein HOLD-Signal zu geben.  Ohne dieses Signal glaubt die Mikroschaltung, dass der Mikrocontroller entweder nicht gestartet wurde oder sich im Gegenteil ausschalten möchte.  In diesem Fall unterbricht der PT1502 nach einigen Millisekunden die Stromversorgung des gesamten Stromkreises. <br><br>  Der Vorteil der Behebung beider Probleme ist nicht schwierig.  Der Digispark ATTiny85 verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Mikronukleus-Bootloader</a> .  Dieser Bootloader ist einfach genug, um für unsere Bedürfnisse zu archivieren.  Es ist nur erforderlich, die entsprechenden Definitionen in der Konfigurationsdatei zu korrigieren. <br><br>  Zunächst habe ich die Standardkonfiguration Firmware \ configuration \ t85_default in mein eigenes Verzeichnis kopiert und bereits alle Änderungen daran vorgenommen.  In diesem Fall ist es einfach, zum ursprünglichen Bootloader zurückzukehren. <br><br>  In der Datei bootloaderconfig.h können Sie den Bootloader aufrufen.  Von dem, was sofort angeboten wird, passt nichts zu uns, aber die nächstgelegene Option ist ENTRY_JUMPER.  Bei dieser Option wird nur dann auf den Bootloader zugegriffen, wenn an einem bestimmten Pin eine bestimmte Ebene angezeigt wird (der Jumper ist auf der Platine geschlossen). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTRYMODE ENTRY_JUMPER</span></span></code> </pre> <br>  Wir haben keinen Jumper, aber am Fuß von PB2 befindet sich ein Knopf.  Lassen Sie den Bootloader eintreten, wenn die Taste beim Einschalten 5-7 Sekunden lang gedrückt gehalten wird.  Wenn jedoch gedrückt und losgelassen wird, erfolgt der Übergang zur Hauptfirmware sofort. <br><br>  Wir müssen 3 Funktionen definieren - Initialisierung, Deinitialisierung und tatsächliche Überprüfung, ob es Zeit ist, den Bootloader aufzurufen.  Im Original sind sie alle einfach und mit Makros implementiert.  Nur die ersten 2 werden einfach sein <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOLD_PIN PB1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PIN PB2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_INP PINB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderInit() {JUMPER_DDR &amp;= ~_BV(JUMPER_PIN); JUMPER_DDR |= _BV(HOLD_PIN); JUMPER_PORT &amp;= ~_BV(JUMPER_PIN); JUMPER_PORT |= _BV(HOLD_PIN); _delay_ms(1);} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderExit() {;}</span></span></code> </pre> <br>  bootLoaderInit () konfiguriert den Button-Pin (JUMPER_PIN) für den Eingang und schaltet den Hosenträger darauf aus.  Wir haben bereits einen Klimmzug auf dem Brett und auf dem Boden, und wenn Sie einen Knopf auf dem Stift drücken, wird es im Gegenteil einen geben.  Gleichzeitig können Sie das HOLD-Signal sofort für die Ausgabe konfigurieren und das Gerät darauf einstellen ... <br><br>  Eine Erklärung der Bit-Arithmetik finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . Ein Verständnis der GPIO-Setup-Register in AVR-Controllern kann beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus gewonnen werden</a> . <br><br>  Die Funktion bootLoaderExit () ist leer, weil  Die exponierte Konfiguration eignet sich gut für den anschließenden Übergang zur Hauptfirmware <br><br>  Die Funktion bootLoaderStartCondition (), die für die Eingabe des Bootloaders im Makroformat verantwortlich ist, passt nicht hinein und ist daher zu einer vollwertigen Funktion geworden <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ASSEMBLER__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Bootloader condition is to hold the button for 5 seconds inline unsigned char bootLoaderStartCondition() { long int i; for(i=0; i&lt;10000000; i++) if( !(JUMPER_INP &amp; _BV(JUMPER_PIN))) return 0; return 1; } #endif</span></span></span></span></code> </pre> <br>  Die Funktion überprüft innerhalb weniger Sekunden (tatsächlich ca. 6-7) den Status der Taste.  Wenn die Schaltfläche früher losgelassen wurde, müssen wir den Bootloader nicht aufrufen.  Geduldig und hartnäckig dürfen Sie den Bootloader betreten. <br><br>  Wie sich herausstellte, ist die Datei bootloaderconfig.h an der Kompilierung von Assembler-Dateien beteiligt, und der Code in dieser Datei verursacht Fehler.  Ich musste die Funktion in den Block #ifndef __ASSEMBLER__ einfügen <br><br>  Ein weiterer Parameter, den ich optimiert habe, teilt dem Bootloader mit, was zu tun ist, wenn er nicht an USB angeschlossen ist. Beenden Sie ihn nach einer Sekunde.  Tatsache ist, dass der Sohn während des Einbruchs oft den Knopf drückte und versehentlich in den Bootloader ging.  Ich weiß nicht, wie wunderbar es ist, aber wenn der Bootloader die USB-Verbindung nicht sieht, kann er versehentlich einige Speicherseiten überschreiben.  Wenn keine Verbindung besteht, kehren wir einfach zum Hauptprogramm zurück. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Define bootloader timeout value. * * The bootloader will only time out if a user program was loaded. * * AUTO_EXIT_NO_USB_MS The bootloader will exit after this delay if no USB is connected. * Set to 0 to disable * Adds ~6 bytes. * (This will wait for an USB SE0 reset from the host) * * All values are approx. in milliseconds */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTO_EXIT_NO_USB_MS 1000</span></span></code> </pre> <br>  Wir kompilieren ... und es wird eine Fehlermeldung angezeigt, dass der Code nicht in den ihm zugewiesenen Bootloader-Speicherplatz passt.  Da der Flash-Speicher im Controller sehr klein ist, wird der Bootloader maximal gedrückt, um mehr Platz für das Hauptprogramm zu lassen.  Dies lässt sich jedoch leicht in der Datei Makefile.inc beheben, indem Sie den Anweisungen folgen. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hexadecimal address for bootloader section to begin. To calculate the best value: # - make clean; make main.hex; ### output will list data: 2124 (or something like that) # - for the size of your device (8kb = 1024 * 8 = 8192) subtract above value 2124... = 6068 # - How many pages in is that? 6068 / 64 (tiny85 page size in bytes) = 94.8125 # - round that down to 94 - our new bootloader address is 94 * 64 = 6016, in hex = 1780 BOOTLOADER_ADDRESS = 1940</span></span></code> </pre> <br>  Dann habe ich nur die Startadresse des Bootloaders auf eine Seite (64 Byte) reduziert und dadurch den Speicherplatz des Bootloaders vergrößert. <br><br>  Andernfalls war das Kompilieren und Hochladen des Bootloaders mit dem USBAsp-Programmierer kein Problem. <br><br><h2>  Fazit </h2><br>  Es war ein sehr interessanter Weg von einem Prototyp auf einem Steckbrett zu einem fertigen Gerät.  Es scheint wie ein gewöhnlicher Blinker aus einer Arduino-Lektion, aber tatsächlich musste ich während der Arbeit eine ganze Reihe interessanter Probleme lösen - hier sind der Kampf mit dem Verbrauch, die Wahl der Elementbasis und das Design des Gehäuses und das Erinnern an die Firmware mit dem Bootloader.  Ich hoffe aufrichtig, dass meine Erfahrung jemandem nützlich sein wird. <br><br>  Könnte es einfacher gewesen sein?  Natürlich kannst du.  Ich denke, alles könnte mit einem Transistor gemacht werden.  Leider habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> gelesen, nachdem ich die Platine gelötet habe.  Ich würde den Artikel früher sehen - ich würde alles auf dem gleichen beliebten TP4056 machen - es ist einfacher, ihn zu löten.  Der DC-DC-Wandler, der sich in diesem Gerät im PT1502 befindet, wird auf keinen Fall benötigt.  Eine praktische Untersuchung des PT1502-Mikroschaltkreises ist für mich jedoch nützlich für mein anderes Projekt sowie für die Fähigkeit, Mikroschaltkreise im QFN20-Gehäuse zu löten. <br><br>  Zum Schluss hier die Links zu meinem Projekt: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Firmware-Code</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schaltung und Platine</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gehäuse- und Diffusormodell</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereit STL-Modelle zum Drucken</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435198/">https://habr.com/ru/post/de435198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435184/index.html">Künstliche Intelligenz lernte 6 Jahre vor der Diagnose, die Alzheimer-Krankheit im Gehirn zu finden</a></li>
<li><a href="../de435186/index.html">Rolls-Royce entwickelt das schnellste Elektroflugzeug der Welt</a></li>
<li><a href="../de435190/index.html">Google hat es geschafft, über Irland und Bermuda Steuern von 22,7 Milliarden US-Dollar abzuziehen</a></li>
<li><a href="../de435194/index.html">Vereinfachen Sie das Schreiben eines Lebenslaufs eines Entwicklers</a></li>
<li><a href="../de435196/index.html">Forscher geben ReCAPTCHA über Google-Dienste weiter</a></li>
<li><a href="../de435202/index.html">Wir schreiben unsere Programmiersprache, Teil 1: Wir schreiben eine Sprach-VM</a></li>
<li><a href="../de435204/index.html">Empfang für Entwickler zur Überwindung des Aufschubs</a></li>
<li><a href="../de435206/index.html">Europa genehmigt Urheberrechtsrichtlinie - warum Streaming-Plattformen dagegen sind</a></li>
<li><a href="../de435208/index.html">Internet der Dinge ... die nach einer guten UI / UX schreien</a></li>
<li><a href="../de435210/index.html">Xamarins Arbeit mit dem C SDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>