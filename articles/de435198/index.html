<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèæ ü§¶üèø üëáüèª Arduin und LED, oder wie man den Kinderdesigner aufwertet üññüèª üïâÔ∏è üéª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Sohn war fest mit dem Magnetkonstruktor Magformers verbunden . Nachdem das Kind eine Reihe von Fixiks durchgesehen hatte, in denen derselbe Konst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduin und LED, oder wie man den Kinderdesigner aufwertet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435198/"><img src="https://habrastorage.org/webt/wp/c4/ox/wpc4oxeubxh_dsoa07dy5wfccoa.jpeg"><br><br>  Mein Sohn war fest mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Magnetkonstruktor Magformers verbunden</a> .  Nachdem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> Kind eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Fixiks durchgesehen hatte, in denen derselbe Konstruktor vorgestellt wurde,</a> fragte es: "Dad, warum haben Fixics Details, die gl√§nzen, aber wir nicht?" <br><br>  Es stellte sich heraus, dass es wirklich ein ‚ÄûMagformers Neon LED Set‚Äú gibt, bei dem es neben den √ºblichen Bausteinen auch ein Element mit einer LED gibt.  Da wir zu diesem Zeitpunkt bereits eine ganze Schachtel Magnete in allen m√∂glichen Formen und Gr√∂√üen gesammelt hatten (was mich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">betrifft,</a> sind die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chinesischen Magformer</a> dem Original √ºberhaupt nicht unterlegen), wollte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">irgendwie</a> kein weiteres Set nur f√ºr eine Gl√ºhbirne kaufen.  Dar√ºber hinaus kostete dieses Set deutlich mehr als ein √§hnliches Set ohne Hintergrundbeleuchtung. <br><br>  Nachdem ich gesch√§tzt hatte, dass die Komponenten nur ein paar Dollar enthalten, von denen ich die meisten bereits hatte, beschloss ich, meine Morgulka abzuholen.  Ja, und mit Effekten, die das Original nicht hatte. <br><br>  Unter der Katze finden Sie die Option eines Blinkers am ATTiny85 und des LED-Panels an den WS8212-LEDs.  Ich werde √ºber Schaltkreise sprechen, wie ich das Ganze mit der Batterie betrieben habe, sowie √ºber die nicht offensichtlichen Probleme, die ich auf dem Weg gemacht habe.  Ich werde auch ausf√ºhrlich √ºber die Softwarekomponente des Projekts sprechen. <br><a name="habracut"></a><br><h2>  Erste Schritte </h2><br>  Es schien mir, dass das Leuchten einer normalen LED (sogar RGB) langweilig und banal ist.  Aber so etwas wie WS8212 zu f√ºhlen, schien interessant.  Auf ebee wurden sowohl einzelne LEDs als auch Matrizen mit einer Gr√∂√üe von bis zu 16 x 16 angeboten.  Nachdem ich verschiedene Module gekauft hatte, entschied ich mich f√ºr eine 4x4 Matrix.  Es gibt viele LEDs, um verschiedene visuelle Effekte zu erzielen, w√§hrend das Modul in seiner Gr√∂√üe mit dem Fenster des quadratischen Blocks des Designers vergleichbar ist. <br><br><img src="https://habrastorage.org/webt/f8/wj/kv/f8wjkvhcyj5zvrzyp81xb0zslu4.jpeg"><br><br>  Zur Steuerung der LED-Matrix reicht nur ein Pin des Mikrocontrollers aus, sodass selbst der Arduino Nano wie eine B√ºste aussieht (au√üerdem passt er nicht in das Geh√§use).  Der Digispark-Klon auf dem ATTiny85-Controller erwies sich jedoch als genau richtig - er verf√ºgt nicht √ºber viel Speicher und Pins, ist aber mehr als genug f√ºr den LED-Blinker.  Das Modul l√§sst sich perfekt in die Arduino IDE integrieren und verf√ºgt √ºber einen USB-Bootloader an Bord, sodass die Programmierung dieses Moduls sehr einfach und komfortabel ist.  Ich wollte es schon lange versuchen. <br><br>  Begonnen mit dem einfachsten Schema. <br><br><img src="https://habrastorage.org/webt/-8/yx/5b/-8yx5b02f2dxtqaps1tw6aoj_io.png"><br><br>  In dieser Form war es m√∂glich, alle Glow / Blink-Algorithmen (dazu weiter unten) schnell zu debuggen.  Ein drahtgebundenes Spielzeug ist jedoch nicht der Fall - Sie m√ºssen √ºber die Batterieleistung nachdenken.  Dar√ºber hinaus wurde beschlossen, Lithium zu verwenden, um nicht mit Fingerbatterien bankrott zu gehen (die au√üerdem nicht in den Umschlag passen).  Und da es eine Lithiumbatterie gibt, m√ºssen Sie sich √ºberlegen, wie Sie sie aufladen sollen.  In den Beh√§ltern haben wir gerade einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äûbeliebten‚Äú Laderegler auf dem TP4056-Chip gefunden,</a> der bei dieser Gelegenheit gekauft wurde. <br><br>  Aber es hat nicht sofort funktioniert.  Die Schaltung des Digispark ATTiny85-Moduls ist nicht sehr daf√ºr ausgelegt - sie wird entweder √ºber USB mit Strom versorgt, aber der Strom wird direkt an den Mikrocontroller (√ºber den + 5-Bus) oder √ºber den VIN-Eingang geliefert, aber dann geht der Strom √ºber den linearen Stabilisator 7805. Option, wenn das Lithium-Lademodul Das Einstecken in die L√ºcke zwischen dem USB-Anschluss und dem Mikrocontroller ist nicht vorgesehen.  Ich musste die Schaltung ein wenig modifizieren und die zus√§tzlichen Details entfernen. <br><br><img src="https://habrastorage.org/webt/99/ta/ab/99taabsud7cdoakqixa8ah4ee0y.png"><br><br>  Jetzt wird der VIN-Pin mit USB-Strom versorgt und geht dann zum Ladeger√§t-Eingang.  Der Ladeger√§tausgang (tats√§chlich ist der Akku direkt angeschlossen) geht √ºber den 5-V-Fu√ü zur√ºck in die Platine.  Und obwohl es tats√§chlich 3 bis 4,2 V (Batteriespannung) geben wird, ist dies ganz normal - der Betriebsspannungsbereich des Mikrocontrollers betr√§gt 1,8 bis 5,5 V.  Und selbst das LED-Modul arbeitet normal ab 2,7 V, obwohl unter 3,2 V die blaue LED etwas fehlt und die Farben ein wenig in Gelb ‚Äûschweben‚Äú. <br><br>  Um Energie zu sparen, verschwand auch die st√§ndig leuchtende D2-LED.  Das allgemeine Schema sieht jetzt so aus <br><br><img src="https://habrastorage.org/webt/pr/d_/fq/prd_fqhsjwulccuuw-1aissl52k.png"><br><br>  Es w√§re m√∂glich, den Stromkreis √ºber den USB-Anschluss im Ladeger√§t zu speisen, aber dann w√ºrde die M√∂glichkeit, Firmware √ºber den USB-Anschluss auf der Controller-Karte hochzuladen, verloren gehen.  Es w√§re m√∂glich, zwei USB-Anschl√ºsse f√ºr verschiedene Zwecke zu belassen - einen zum Aufladen und einen f√ºr die Firmware, aber das ist irgendwie falsch. <br><br>  Ich habe bei ebay einen Akku der Gr√∂√üe 6x25x35 gekauft, der sich jedoch als defekt herausstellte oder durch einen Kurzschluss oder einen gro√üen Ladestrom abgeschaltet wurde (standardm√§√üig ist der Ladestrom auf 1A eingestellt und Sie m√ºssen einen Widerstand l√∂ten, um den Strom zu reduzieren).  In jedem Fall fiel die Spannung an der Batterie auf 1 V ab, wenn die Last angeschlossen wurde, selbst bei 10 mA.  Zum Zeitpunkt des Tests habe ich von einem kleinen Quadrocopter auf einen halb leeren LiPo-Akku umgestellt.  Wenig sp√§ter bestellte ich die Batterie bei einem anderen Verk√§ufer und es stellte sich heraus, dass sie gut war. <br><br>  Im Prinzip w√§re es m√∂glich, hier anzuhalten, die Verbindungsdr√§hte zu l√∂ten und alles vorsichtig in eine Art Geh√§use zu schieben, aber ich entschied mich, den Verbrauch der Schaltung zu messen.  Und dann habe ich geweint.  Nun, im funktionierenden Zustand (wenn die Gl√ºhbirnen voll leuchten) frisst dieses Ding bis zu 130 mA, also betr√§gt der Verbrauch in Ruhe mehr als 25 mA!  Das hei√üt,  Dieser Blinker verbraucht meine 600mAh Batterie in weniger als einem Tag! <br><br>  Es stellte sich heraus, dass etwa 10 mA LEDs verbrauchen.  Auch wenn sie nicht aufleuchten, arbeitet in jedem ein Mikrocontroller und wartet auf einen Befehl.  Das hei√üt,  Sie m√ºssen eine Ausschaltschaltung f√ºr die LEDs erstellen. <br><br>  Die restlichen 15 mA werden vom Mikrocontroller verbraucht.  Ja, es kann ins Bett gebracht werden und laut Datenblatt wird der Verbrauch mit Mikroampere gemessen, aber tats√§chlich war es nicht m√∂glich, weniger als 1 mA zu erhalten.  Ich schaltete den ADC aus und √ºbersetzte die Pins in Eingang.  Es scheint, dass irgendwo in der Schaltung eine Art Leck vorhanden ist, aber meine bescheidenen Kenntnisse der Elektronik reichen nicht aus, um es zu finden und zu verstehen. <br><br><h2>  Wir erschweren das Schema </h2><br>  Dann erinnerte ich mich, dass ich einen PT1502-Chip f√ºr einen Test gekauft hatte.  Dieser Chip ist ein Lithium-Batterieladecontroller mit einem Netzteil mit mehreren Steuereing√§ngen.  Die einzige Schwierigkeit besteht darin, dass die Mikroschaltung in einem 4x4 mm QFN20-Geh√§use geliefert wird und einige Umreifungen erfordert.  Das L√∂ten zu Hause ist schwierig, aber m√∂glich.  Die Geb√ºhr ist f√ºr eine regul√§re LUT schwierig und muss bei den Chinesen bestellt werden.  Aber wir haben keine Angst vor Schwierigkeiten, oder? <br><br>  In mehreren Feldern kann das Schema wie folgt beschrieben werden. <br><br><img src="https://habrastorage.org/webt/t9/c5/rg/t9c5rgauskpsz1momglwordnf0o.png"><br><br>  Im ausgeschalteten Zustand werden die Steuerung und die LEDs nicht mit Strom versorgt.  Das Ger√§t verf√ºgt √ºber eine Ein- / Aus-Taste, die den Blinker einschaltet (es wechselt auch den Modus).  Die LED leuchtet beispielsweise eine Minute lang, und wenn keine Benutzeraktivit√§t vorliegt (niemand dr√ºckt eine Taste), schaltet sich das Ger√§t aus.  Das hei√üt,  Es geht nicht nur schlafen, sondern schaltet sich durch das Power Hold-Signal aus.  Und es schaltet alles auf einmal aus - sowohl den Mikrocontroller als auch die LEDs.  Die Ein- und Ausschaltfunktion ist im PT1502-Chip implementiert <br><br>  Sie m√ºssen nur noch einen Schaltplan zeichnen und eine Leiterplatte erstellen.  Die Schaltung besteht gr√∂√ütenteils aus dem Datenblatt PT1502 sowie dem Digispark ATTiny85-Modul.  Die Mikroschaltung des Leistungsreglers PT1502 ist funktional in mehrere Teile unterteilt, daher ist sie in Bl√∂cke in der Schaltung unterteilt. <br><br><img src="https://habrastorage.org/webt/fc/s6/qu/fcs6qu4zqgfja5p4hjacywrds8k.png"><br><br>  Dies ist in der Tat ein Lithium-Batterieladecontroller mit einem eigenen Kabelbaum.  LED1 zeigt den Ladezustand an - dann ist die Ladung eingeschaltet.  Der Widerstand R6 stellt den Ladestrom auf 470 mA ein.  Da ich eine 600-mAh-Batterie habe, k√∂nnen Sie im Prinzip den Strom erh√∂hen und einen Widerstand bei 780-800 Ohm bis zu 600 mA einstellen.  Ich bin mir jedoch nicht sicher √ºber die besondere Qualit√§t meines Akkus - es ist besser, langsamer zu laden, aber es h√§lt l√§nger. <br><br>  Betrachten Sie einen Energieplan <br><br><img src="https://habrastorage.org/webt/z1/rb/_a/z1rb_a2zu2a95pvxzk629o1tsjm.png"><br><br>  Die SW1-Taste startet das gesamte System - der PT1502-Chip wacht von selbst auf und startet dann alle Stromquellen (von denen er 3 hat).  Wenn die Stromversorgung installiert ist, startet die Mikroschaltung den Mikrocontroller, indem sie das RESET-Signal freigibt.  Zur Vereinfachung des Debuggens habe ich au√üerdem eine separate Schaltfl√§che zum Zur√ºcksetzen hinzugef√ºgt. <br><br>  Das HOLD-Signal wird verwendet, um das gesamte System auszuschalten.  Wenn der Mikrocontroller startet, sollte er das Ger√§t auf diese Leitung stellen.  Wenn es Zeit zum Abrunden ist, setzt der Mikrocontroller auf der HOLD-Leitung Null und der PT1502-Leistungschip stoppt alle Stromquellen. <br><br>  Es w√§re m√∂glich, die niedrige Batterieladung mithilfe des BAT_LOW-Ausgangs zu verfolgen, aber in diesem Artikel habe ich sie bewertet. Sie m√ºssen keine Daten speichern, und nichts explodiert, wenn Sie nicht rechtzeitig eine leere Batterie bemerken.  Stirbt so stirbt.  Aber nur f√ºr den Fall, dass der Vorstand den Kontakt f√ºr dieses Gesch√§ft bereitstellte. <br><br>  Kehren wir f√ºr eine Sekunde zur SW1-Taste zur√ºck.  Ich habe beschlossen, keine 2 separaten Tasten zum Einschalten und Steuern zu erstellen.  Daher ist dieselbe Taste auch mit dem ATTiny85 verbunden und schaltet w√§hrend des Betriebs die Blinkmodi um.  Die Werte des Teilers R7-R8 werden so gew√§hlt, dass der Port des PB2-Mikrocontrollers nicht verbrannt wird.  F√ºr alle Batteriespannungsbereiche (3,3 - 4,2 V) wird die Spannung innerhalb der angegebenen Datenblattgrenzen (0,7 * VCC - VCC + 0,5 V) an den Fu√ü des Controllers geliefert. <br><br>  Betrachten Sie eine Stromquelle <br><br><img src="https://habrastorage.org/webt/u1/3q/kf/u13qkfyn6g7gffo_qb8j9licy4w.png"><br><br>  Dies ist ein gepulster DC-DC-Wandler.  Die Ausgangsspannung wird durch die Widerst√§nde R10-R11 eingestellt und gem√§√ü der Formel aus dem Datenblatt auf 3,3 V eingestellt.  Alles andere ist ein einfaches Umschnallen. <br><br>  Eine solche ausgetrickste Stromquelle wird f√ºr immer nicht wirklich ben√∂tigt - es w√§re m√∂glich, den Mikrocontroller im Allgemeinen direkt √ºber die Batterie mit Strom zu versorgen.  Es ist nur so, dass diese Quelle bereits im PT1502-Chip implementiert ist und bei Bedarf ein- und ausgeschaltet werden kann - warum nicht? <br><br><img src="https://habrastorage.org/webt/ad/8w/0z/ad8w0zewrcux0hdetprifertqss.png"><br><br>  Der Chip hat auch 2 lineare Stabilisatoren, aber ich werde sie nicht verwenden.  Wie sich herausstellte, ist es leider immer noch notwendig, die Eingangsspannung an diese Quelle zu liefern, andernfalls glaubt die Mikroschaltung, dass die Leistung immer noch nicht stabil genug ist und startet den Mikrocontroller nicht (dieses Wissen wurde mir durch eine Woche L√∂ten der Testplatine hin und her vermittelt - ich konnte nicht verstehen, warum es nicht funktioniert ) <br><br>  Kommen wir zum logischen Teil. <br><br><img src="https://habrastorage.org/webt/sq/su/xj/sqsuxjeblb7507pz8ej2h1t3yui.png"><br><br>  Das USB-Kabel wird unver√§ndert von der Digispark-Karte gel√§ppt.  Dies ist erforderlich, um die USB-Spannung (die 3,3 V betr√§gt) und die Signale des Mikrocontrollers (der im Original mit 5 V betrieben wird) zu koordinieren.  Da in meinem Fall der Mikrocontroller auch mit 3,3 V betrieben wird, k√∂nnte die Schaltung vereinfacht werden, aber nur f√ºr den Fall, dass ich die urspr√ºngliche Schaltung auf der Platine geschieden habe. <br><br><img src="https://habrastorage.org/webt/qe/q8/xr/qeq8xr1bwr-ux0jnsk5na1p6eaw.png"><br><br>  An der Bindung des Mikrocontrollers ist nichts Interessantes. <br><br>  Der letzte Schliff ist der Stecker <br><br><img src="https://habrastorage.org/webt/ic/vt/ey/icvtey-cwulcyqozyphkmglv-0m.png"><br><br>  Tats√§chlich habe ich mir auf ATTiny85 mit USB-Unterst√ºtzung und einem Leistungsregler mit Lithiumbatterie ein solches Debugging-Board besorgt.  Daher habe ich mich nicht darauf beschr√§nkt, nur die Leitung an die LED auszugeben.  Stattdessen habe ich alle Leitungen des Mikrocontrollers zum Kamm gebracht - gleichzeitig ist es bequem, eine Verbindung zum Programmierer herzustellen. <br><br>  Und lassen Sie in Zukunft fast alle Leitungen fest an eine bestimmte Funktionalit√§t gebunden sein (PB1 - Leitung halten, PB2 - Netzschalter, PB3 / PB4 - USB, PB5 - Zur√ºcksetzen), wird es m√∂glich sein, einige Grenzen zu umgehen.  L√∂ten Sie beispielsweise das USB-Kabel nicht und lassen Sie die PB3 / PB4-Leitungen los.  Oder lehnen Sie beispielsweise einen Reset ab und geben Sie PB5 frei.  In der Zwischenzeit bleibt nur PB0 frei - und schlie√üen Sie unsere LED daran an. <br><br>  Wir gehen an die Tafel.  Angesichts der Einschr√§nkungen hinsichtlich der Gr√∂√üe der Platine in 40 x 40 mm, der Anzahl der Komponenten und des QFN20-Geh√§uses des PT1502-Chips habe ich nicht einmal daran gedacht, die Platine zu Hause herzustellen.  Deshalb habe ich sofort angefangen, das kompakteste Zweischichtbrett zu z√ºchten.  Das habe ich bekommen <br><br><img src="https://habrastorage.org/webt/yt/6q/wh/yt6qwhfd9zkia64yyejpjx9litu.png"><br><br>  Zur Vereinfachung der Verwendung habe ich auf der R√ºckseite alle m√∂glichen Ausgabefunktionen signiert (die Idee kam vom Digispark-Board). <br><br><img src="https://habrastorage.org/webt/q-/on/8t/q-on8tdmxq_bvht8egr5ilipb4s.png"><br><br>  Ich habe das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Board</a> bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JLCPCB bestellt</a> .  Um ehrlich zu sein, bin ich mit der Qualit√§t nicht sehr zufrieden. Wenn Sie den Chip mehrmals l√∂ten, ist die Maske in der N√§he der kleinen Kontakte des PT1502 etwas getr√ºbt.  Nun, kleine Inschriften schwebten ein wenig.  Wenn jedoch beim ersten Mal alles gel√∂tet wird, dann die Normen. <br><br>  Zum L√∂ten von QFN20 ben√∂tigen Sie einen L√∂tkolben, alles andere kann mit einem bestimmten L√∂tkolben mit einer bestimmten F√§higkeit gel√∂tet werden.  So sieht die gel√∂tete Platine aus <br><br><img src="https://habrastorage.org/webt/ct/km/4g/ctkm4gs_myfjjfeoukwn4ijuuc4.jpeg"><br><br><h2>  Geh√§use </h2><br>  Es ist Zeit, zum Rumpf √ºberzugehen.  Ich habe es auf einem 3D-Drucker gedruckt.  Schn√∂rkelloses Design - Box und Knopf.  An der Box sind spezielle Haken vorgesehen, um die Gl√ºhw√ºrmchen im quadratischen Standardmodul des Designers zu installieren. <br><br><img src="https://habrastorage.org/webt/g9/bz/yd/g9bzydcnm7bwonoo6rhe-1hby7k.png"><br><br>  Die Hauptplatine und der Akku befinden sich im Geh√§use. <br><br><img src="https://habrastorage.org/webt/zp/4u/x-/zp4ux-vaqurrmg9yqe3jb3jkry8.jpeg"><br><br><img src="https://habrastorage.org/webt/4f/oa/dw/4foadwyytzwav_lfiyvqrl5lcxs.jpeg"><br><br>  Das LED-Panel ist auf der Abdeckung montiert, die wiederum mit Schrauben an der Hauptbox angeschraubt wird <br><br>  Zuerst dachte ich daran, das LED-Panel mit Schrauben an der Abdeckung festzuschrauben, aber am Ende klebte ich es einfach auf ein doppelseitiges Klebeband.  Es stellte sich so heraus <br><br><img src="https://habrastorage.org/webt/vy/ks/y2/vyksy2ccuvrwcrjmxgvzolhlia0.jpeg"><br><br>  In dieser Form kann das Ger√§t bereits verwendet werden, sieht aber trotzdem h√§sslich aus - es ist nicht gen√ºgend Diffusor vorhanden. <br><br>  Ich habe versucht, die erste Version des Diffusors mit der Technologie des Schrumpfens von PET-Flaschen mit einem Bau-Haartrockner herzustellen (siehe Flugzeugmodelle). <br><br>  Also, zuerst brauchst du ein Leerzeichen.  Ich habe es aus Gips gemacht, den ich in eine Form gegossen habe, die ich auf einem 3D-Drucker gedruckt habe.  In der ersten Version war die Form einteilig und ich konnte die gegossene Scheibe nie herausziehen.  Deshalb musste ich eine zweiteilige Form machen. <br><br><img src="https://habrastorage.org/webt/gb/x0/0i/gbx00iokd8ea_lfquvmbbfebed4.jpeg"><br><br>  Die Idee der Methode ist wie folgt.  Sie stellen eine Flasche Babyjoghurt auf einen Rohling und setzen sie mit einem Haartrockner auf.  Hier sind nur Teile von 20 verschiedenen Beh√§ltern unter unterschiedlicher Milch wiedergegeben. Ich habe es nie geschafft, dieses Ding sch√∂n zu platzieren, ohne Falten und Blasen.  Anscheinend m√ºssen Sie eine Art Vakuuminstallation und Sitzplastikfolie umz√§unen.  Im Allgemeinen stellte sich heraus, dass es f√ºr ein solches Fahrzeug zu schwierig war. <br><br>  Nachdem ich durch die Gophers gemurrt hatte, fand ich ein paar Meter Verbatim PET Transparent Plastiksonde.  Ich beschloss, den Diffusor nur zum Drucken auszuprobieren.  Und obwohl der Kunststoff am Eingang zum Drucker kristallklar erscheint, ist der Realteil langweilig.  Dies liegt wahrscheinlich an der internen Struktur, wie  Schichten f√ºllen das Volumen nicht vollst√§ndig aus, sondern √ºberlappen sich mit L√ºcken und L√ºcken.  Wenn Sie versuchen, das Teil mit Sandpapier f√ºr eine glattere Oberfl√§che zu verarbeiten, erhalten wir au√üerdem noch mehr Mattierung.  Dies ist jedoch genau das, was ich brauchte. <br><br>  Ich war zu faul, um mich mit der Halterung f√ºr den Diffusor zu besch√§ftigen, also f√ºgte ich sie dem Hei√ükleber hinzu.  Mein Design ist jetzt bedingt zusammenklappbar.  Ich k√∂nnte mit der Erfindung einer Art Riegel verwechselt werden, aber mir ist bereits die transparente Kunststoffsonde ausgegangen.  Also lass es hei√ü schmelzen. <br><br><img src="https://habrastorage.org/webt/xb/vy/49/xbvy49czm3mqdgjrexvvrcsm25m.jpeg"><br><br><img src="https://habrastorage.org/webt/fz/tx/tx/fztxtxljbgq0uwqnhlne0-mvcdc.jpeg"><br><br><h2>  Firmware </h2><br>  Bei LED-Blinkern m√ºssen Sie nicht besonders in die Peripherie des Mikrocontrollers eintauchen - nur ein paar Funktionen f√ºr die Arbeit mit GPIO reichen aus.  Da das Modul jedoch an die Arduino-Plattform angedockt ist, k√∂nnen Sie dies nutzen. <br><br>  Zun√§chst einige Definitionen und Konstanten <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Number of total LEDs on the board. Mine has 4x4 LEDs #define NUM_HW_PIXELS 16 // Pin number where LED data pin is attached #define DATA_PIN 0 // Pin number where mode switch button is attached #define BUTTON_PIN 2 // Power Enabled pin #define POWER_EN_PIN 1 // Max brightness (dimming the light for debugging) #define MAX_VAL 255</span></span></code> </pre> <br>  Dies bestimmt die Anzahl der Pixel in meiner Matrix, die Pin-Nummern und die maximale Helligkeit der LEDs (w√§hrend des Debuggens war es zweckm√§√üig, sie auf 50 einzustellen, damit meine Augen nicht geblendet werden). <br><br>  Die LEDs in meiner Matrix sind nicht offensichtlich angeordnet - im Zickzack.  Daher musste ich f√ºr verschiedene Effekte neu nummerieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// LED indexes for different patterns uint8_t circleLEDIndexes[] = {0, 1, 2, 3, 4, 11, 12, 13, 14, 15, 8, 7}; uint8_t beaconLEDIndexes[] = {6, 5, 10, 9}; uint8_t policeLEDIndexes[] = {7, 6, 10, 11, 4, 5, 9, 8};</span></span></code> </pre> <br>  Um die LEDs zu steuern, habe ich das Rad nicht neu erfunden und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigte Bibliothek f√ºr die Arbeit mit WS8211-LEDs genommen</a> .  Die Bibliotheksoberfl√§che ist leicht wei√ü get√ºncht.  Einige Zusatzfunktionen (z. B. die Konvertierung von HSV in RGB) blieben ebenfalls h√§ngen. <br><br>  Zun√§chst m√ºssen die Karte und die WS8211-Bibliothek initialisiert werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Driver Ai_WS2811 ws2811; void setup() { // Set up power pinMode(POWER_EN_PIN, OUTPUT); digitalWrite(POWER_EN_PIN, HIGH); // initialize LED data pin pinMode(LED_PIN, OUTPUT); // Initialize button pin pinMode(BUTTON_PIN, INPUT); // Initialize WS8211 library static CRGB ledsBuf[NUM_HW_PIXELS]; ws2811.init(DATA_PIN, NUM_HW_PIXELS, ledsBuf); // Set the watchdog timer to 2 sec wdt_enable(WDTO_2S); }</span></span></code> </pre> <br>  Zun√§chst m√ºssen Sie das POWER HOLD-Signal auf Eins setzen. Dies ist ein Signal an den PT1502-Chip, dass der Mikrocontroller aufgewickelt wurde und ordnungsgem√§√ü funktioniert.  Die Mikroschaltung wiederum versorgt den Mikrocontroller und die LEDs regelm√§√üig mit Strom, solange das HOLD-Signal auf Eins eingestellt ist. <br><br>  Als n√§chstes werden die Beine zur Steuerung der LED am Ausgang und die Tasten am Eingang konfiguriert.  Danach k√∂nnen Sie die WS8211-Bibliothek initialisieren. <br><br>  Da dies ein ziemlich autonomes Ger√§t ist, kann man nicht zulassen, dass der Mikrocontroller in einem unverst√§ndlichen Zustand bleibt und die gesamte Batterie verschlingt.  Dazu starte ich den Watchdog-Timer f√ºr 2 Sekunden.  Der Timer wird in der Hauptprogrammschleife neu gestartet. <br><br>  Jetzt m√ºssen Sie einige Hilfsfunktionen definieren.  Die WS8211-Bibliothek speichert einen Puffer mit den Farbwerten jeder LED.  Das direkte Arbeiten mit dem Puffer ist nicht sehr praktisch, da ich eine einfache Funktion zum Schreiben von RGB-Werten auf eine bestimmte LED geschrieben habe <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRgb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ CRGB * leds = ws2811.getRGBData(); leds[led_idx].r = r; leds[led_idx].g = g; leds[led_idx].b = b; }</code> </pre> <br>  In den meisten F√§llen ist das Z√§hlen von Farben im RGB-Farbmodell jedoch nicht sehr bequem oder sogar unm√∂glich.  Wenn Sie beispielsweise einen Regenbogen zeichnen, ist es bequemer, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem HSV-Farbmodell zu arbeiten</a> .  Die Farbe jedes Pixels wird durch den Wert des Farbtons und der Helligkeit festgelegt.  Die S√§ttigung wird der Einfachheit halber weggelassen (Maximum wird verwendet).  Die Farbtonwerte werden auf einen Bereich von 0 bis 255 reduziert (anstelle des Standards 0 bis 359). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * HVS to RGB conversion (simplified to the range 0-255) **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> brightness)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//this is the algorithm to convert from RGB to HSV double r = 0; double g = 0; double b = 0; double hf = hue/42.6; // Not /60 as range is _not_ 0-360 int i=(int)floor(hue/42.6); double f = hue/42.6 - i; double qv = 1 - f; double tv = f; switch (i) { case 0: r = 1; g = tv; break; case 1: r = qv; g = 1; break; case 2: g = 1; b = tv; break; case 3: g = qv; b = 1; break; case 4: r = tv; b = 1; break; case 5: r = 1; b = qv; break; } brightness = constrain(brightness, 0, MAX_VAL); setRgb(led_idx, constrain(brightness*r, 0, MAX_VAL), constrain(brightness*g, 0, MAX_VAL), constrain(brightness*b, 0, MAX_VAL) ); }</span></span></code> </pre><br>  Die Funktion wurde aus der Ai_WS8211-Bibliothek √ºbernommen und leicht abgelegt.  In der Originalversion dieser Funktion aus der Bibliothek gab es einige Fehler, aufgrund derer die Farbe auf den Regenbogen mit Rucken angezeigt wurde. <br><br>  Kommen wir zur Implementierung verschiedener Effekte.  Jede Funktion wird von der Hauptschleife aufgerufen, um einen ‚ÄûFrame‚Äú zu zeichnen.  Da jeder Effekt zwischen den Aufrufen mit unterschiedlichen Parametern arbeitet, werden sie in statischen Variablen gespeichert. <br><br>  Dies ist der einfachste Effekt - alle LEDs sind mit einer Farbe gef√ºllt, die sich reibungslos √§ndert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> hue = <span class="hljs-number"><span class="hljs-number">0</span></span>; hue++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, hue, MAX_VAL); ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Der n√§chste Effekt ist interessanter: Er zeigt einen Regenbogen entlang der Kontur der Matrix an und die Farben im Regenbogen verschieben sich allm√§hlich in einem Kreis. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slidingRainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hue = (pos + led*<span class="hljs-number"><span class="hljs-number">256</span></span>/ARRAY_SIZE(circleLEDIndexes)) % <span class="hljs-number"><span class="hljs-number">256</span></span>; setHue(circleLEDIndexes[led], hue, MAX_VAL); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  Und dieser Effekt f√ºllt die gesamte Matrix mit einer zuf√§lligen Farbe, die zuerst sanft aufleuchtet und dann auch glatt erlischt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomColorsFadeInOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !goesUp) { color = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; goesUp = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == MAX_VAL &amp;&amp; goesUp) { goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, color, curLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(goesUp) curLevel++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curLevel--; ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  Die n√§chste Gruppe von Effekten zeichnet verschiedene blinkende Leuchtfeuer.  So baut zum Beispiel ein Kind gerne einen Bulldozer aus Magneten und ein orangefarbener Blinker ist dort sehr n√ºtzlich. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orangeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ORANGE_HUE = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos+=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(circleLEDIndexes), <span class="hljs-number"><span class="hljs-number">70</span></span>); setHue(circleLEDIndexes[led], ORANGE_HUE, brightness); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Technisch gesehen sieht der Effekt wie ein heller Punkt aus, der sich entlang der Matrix bewegt.  Damit es jedoch sch√∂n aussieht, verschwinden benachbarte LEDs allm√§hlich, wenn Sie sich vom Hauptpunkt entfernen.  Daher brauchte ich eine Funktion, die dieselbe Helligkeit berechnet. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightnessByPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ledPos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pos - ledPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(diff &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-diff); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = MAX_VAL - constrain(MAX_VAL*diff/delta, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brightness; }</code> </pre><br>  Pos ist eine bestimmte bedingte Position des Lichthelligkeitspunkts, die auf einen Loopback-Bereich von 0 bis 255 abgebildet wird.  ledPos ist die Position der LED (im selben Bereich angezeigt), deren Helligkeit Sie berechnen m√ºssen.  Wenn der Positionsunterschied gr√∂√üer als Delta ist, leuchtet die LED nicht auf und je n√§her an der Position, desto heller leuchtet sie. <br><br>  Oder zum Beispiel ein rot-blaues Blinklicht der Polizei <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">policeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RED_HUE = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BLUE_HUE = <span class="hljs-number"><span class="hljs-number">170</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(policeLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ledPos = led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(policeLEDIndexes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], RED_HUE, brightness); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brightness == <span class="hljs-number"><span class="hljs-number">0</span></span>) { brightness = brightnessByPos((pos+<span class="hljs-number"><span class="hljs-number">100</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], BLUE_HUE, brightness); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Da es sich um Autos handelt, ist die Ampel hier kein Problem zu implementieren. <br><br>  Dies sind Funktionen, die verschiedene Verkehrssignale an verschiedenen Positionen enthalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPixels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;NUM_HW_PIXELS; i++) { setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) setRgb(i, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellowTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">4</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; i++) setRgb(i, MAX_VAL, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greenTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">8</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; i++) setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); }</code> </pre> <br>  Es ist Zeit, es wiederzubeleben.  Die Ampel arbeitet nach einem speziellen Programm, das in einer Art Bytecode definiert ist.  Die Platte beschreibt den Modus und die Zeit, f√ºr die dieser Modus eingeschaltet werden muss. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TRAFFIC_LIGHTS { NONE, RED, YELLOW, GREEN }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trafficLightState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> duration; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trafficLightState trafficLightStates[] = { {NONE, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// clear yellow {RED, 7000}, // red {YELLOW, 2000}, // red + yellow {NONE, 1}, // clear red+yellow {GREEN, 7000}, // green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 1}, // clear green {YELLOW, 2000}, // yellow };</span></span></code> </pre> <br>  Eigentlich die Funktion, die alles verarbeitet <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curStateIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> curStateTimeStamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Switch to a new state when time comes if(millis() - curStateTimeStamp &gt; (unsigned long)trafficLightStates[curStateIdx].duration) { curStateIdx++; curStateIdx %= ARRAY_SIZE(trafficLightStates); curStateTimeStamp = millis(); } switch(trafficLightStates[curStateIdx].state) { case NONE: clearPixels(); ws2811.sendLedData(); break; case RED: redTrafficLights(); break; case YELLOW: yellowTrafficLights(); break; case GREEN: greenTrafficLights(); break; default: break; } // Just waiting delay(10); }</span></span></code> </pre><br>  Bei Erreichen des angegebenen Zeitintervalls wird der n√§chste Ampelmodus eingeschaltet und der Countdown erneut gestartet. <br><br>  Der letzte Effekt, bei dem meine Vorstellungskraft ausreichte, sind Sternchen.  5 zuf√§llige LEDs leuchten mit zuf√§lliger Helligkeit und schalten sich dann sanft aus.  Wenn ein Stern ausgeht, leuchtet ein anderer an einer zuf√§lligen Stelle auf. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> numleds = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledIndexes[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numleds; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ledIndexes[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = rand() % (NUM_HW_PIXELS+<span class="hljs-number"><span class="hljs-number">1</span></span>); CRGB * leds = ws2811.getRGBData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(leds[led].r == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ledIndexes[i] = led; maxVal[i] = rand() % (MAX_VAL<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; curVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = ledIndexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] &lt; maxVal[i]) curVal[i]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == maxVal[i]) maxVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span> || --curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ledIndexes[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; setRgb(led<span class="hljs-number"><span class="hljs-number">-1</span></span>, curVal[i], curVal[i], curVal[i]); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Irgendwo hier hat sich ein b√∂ser K√§fer eingeschlichen.  Manchmal leuchten die Sterne scharf auf oder umgekehrt gehen sie pl√∂tzlich aus.  Aber um ehrlich zu sein, war ich zu faul, um es herauszufinden - es sieht ganz normal aus. <br><br>  Es ist Zeit, √ºber das Sparen von Batterie nachzudenken.  Ich habe bereits die Verbrauchswerte dieser ganzen Sache angegeben.  Wenn Sie nicht daran denken, den Strom auszuschalten, verbrauchen die LEDs den Akku in ein paar Stunden.  Diese Funktion ist f√ºr das Ausschalten der Stromversorgung nach 90 Sekunden Inaktivit√§t verantwortlich.  Anfangs waren es 60 Sekunden, aber mit einem echten Spiel war das nicht genug und 2 Minuten waren irgendwie lang. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdownOnTimeOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resetTimer = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(periodStartTime == <span class="hljs-number"><span class="hljs-number">0</span></span> || resetTimer) { periodStartTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(millis() - periodStartTime &gt;= <span class="hljs-number"><span class="hljs-number">90000U</span></span>L) { periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; shutDown(); } }</code> </pre> <br>  Tats√§chlich erfolgt das Ausschalten wie folgt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clearPixels(); ws2811.sendLedData(); wdt_disable(); digitalWrite(POWER_EN_PIN, LOW); <span class="hljs-comment"><span class="hljs-comment">// No power after this point while(true) ; }</span></span></code> </pre> <br>  Wenn der Benutzer die Tasten dr√ºckt, wird der Timer zur√ºckgesetzt.  Nach Ablauf der eingestellten Zeit setzt die Funktion das HOLD-Signal auf Null. Dies ist ein PT1502-Befehl zum Ausschalten der Stromversorgung.  Watchdog muss √ºbrigens auch gestoppt werden, sonst weckt es nach 2 Sekunden das System und schaltet den Strom wieder ein. <br><br>  Endlich die Hauptschleife, die alles startet <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// List of pointers to functions that serve different modes void (*Modes[])() = { rainbow, slidingRainbow, orangeBeacon, policeBeacon, trafficLights, stars, randomColorsFadeInOut }; void loop() { static uint8_t mode = eeprom_read_byte( (uint8_t*) 10 ); static bool waitingForBtnUp = false; static long btnPressTimeStamp; // Button switches mode if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; !waitingForBtnUp) { delay(20); if(digitalRead(BUTTON_PIN) == HIGH) { mode++; mode %= ARRAY_SIZE(Modes); // num modes clearPixels(); ws2811.sendLedData(); delay(1); eeprom_write_byte( (uint8_t*) 10, mode ); waitingForBtnUp = true; btnPressTimeStamp = millis(); shutdownOnTimeOut(true); } } // Shut down on long press over 5s if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; waitingForBtnUp &amp;&amp; millis() - btnPressTimeStamp &gt; 5000) shutDown(); // Detect button release if(digitalRead(BUTTON_PIN) == LOW &amp;&amp; waitingForBtnUp) waitingForBtnUp = false; // display LEDs according to current mode Modes[mode](); // pong shutdown timer shutdownOnTimeOut(); // Yes, we still alive wdt_reset(); }</span></span></code> </pre><br>  Durch Dr√ºcken der Taste werden die Modi umgeschaltet und der Auto-Off-Timer zur√ºckgesetzt.  Abh√§ngig vom aktuellen Modus wird eine der Effektfunktionen aus der Liste Modi gestartet.  Bei jedem Zyklus wird auch der Watchdog zur√ºckgesetzt. <br><br>  Wenn beispielsweise ein Kind ein Polizeiauto gespielt hat und nach 1,5 Minuten das Notlicht ausgeschaltet wurde, m√∂chte der Sohn h√∂chstwahrscheinlich nach einem zweiten Einschalten das Polizeiauto weiter spielen.  Dazu wird der ausgew√§hlte Modus im EEPROM gespeichert (Zellennummer 10 wird vom Bulldozer ausgew√§hlt). <br><br>  Hier ist ein Video, das zeigt, wie alles funktioniert. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5MLX1hc8Jz4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bootloader </h2><br>  Fast alles ist fertig.  Aber es gibt noch eine Sache, die abgelegt werden muss - einen Bootloader.  Tatsache ist, dass der Standard-Bootloader nicht zu uns passt. <br><br>  Erstens, wenn Sie das Ger√§t einschalten, wartet es bis zu 6 Sekunden - m√∂glicherweise flie√üt die Firmware hinein.  Erst danach wird die Steuerung auf die Hauptfirmware √ºbertragen.  Dies ist in der Entwicklungsphase praktisch, im fertigen Ger√§t jedoch √§rgerlich. <br><br>  Und zweitens wei√ü der Standard-Bootloader nichts √ºber den PT1502-Chip, was sch√∂n w√§re, ein HOLD-Signal zu geben.  Ohne dieses Signal glaubt die Mikroschaltung, dass der Mikrocontroller entweder nicht gestartet wurde oder sich im Gegenteil ausschalten m√∂chte.  In diesem Fall unterbricht der PT1502 nach einigen Millisekunden die Stromversorgung des gesamten Stromkreises. <br><br>  Der Vorteil der Behebung beider Probleme ist nicht schwierig.  Der Digispark ATTiny85 verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Mikronukleus-Bootloader</a> .  Dieser Bootloader ist einfach genug, um f√ºr unsere Bed√ºrfnisse zu archivieren.  Es ist nur erforderlich, die entsprechenden Definitionen in der Konfigurationsdatei zu korrigieren. <br><br>  Zun√§chst habe ich die Standardkonfiguration Firmware \ configuration \ t85_default in mein eigenes Verzeichnis kopiert und bereits alle √Ñnderungen daran vorgenommen.  In diesem Fall ist es einfach, zum urspr√ºnglichen Bootloader zur√ºckzukehren. <br><br>  In der Datei bootloaderconfig.h k√∂nnen Sie den Bootloader aufrufen.  Von dem, was sofort angeboten wird, passt nichts zu uns, aber die n√§chstgelegene Option ist ENTRY_JUMPER.  Bei dieser Option wird nur dann auf den Bootloader zugegriffen, wenn an einem bestimmten Pin eine bestimmte Ebene angezeigt wird (der Jumper ist auf der Platine geschlossen). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTRYMODE ENTRY_JUMPER</span></span></code> </pre> <br>  Wir haben keinen Jumper, aber am Fu√ü von PB2 befindet sich ein Knopf.  Lassen Sie den Bootloader eintreten, wenn die Taste beim Einschalten 5-7 Sekunden lang gedr√ºckt gehalten wird.  Wenn jedoch gedr√ºckt und losgelassen wird, erfolgt der √úbergang zur Hauptfirmware sofort. <br><br>  Wir m√ºssen 3 Funktionen definieren - Initialisierung, Deinitialisierung und tats√§chliche √úberpr√ºfung, ob es Zeit ist, den Bootloader aufzurufen.  Im Original sind sie alle einfach und mit Makros implementiert.  Nur die ersten 2 werden einfach sein <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOLD_PIN PB1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PIN PB2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_INP PINB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderInit() {JUMPER_DDR &amp;= ~_BV(JUMPER_PIN); JUMPER_DDR |= _BV(HOLD_PIN); JUMPER_PORT &amp;= ~_BV(JUMPER_PIN); JUMPER_PORT |= _BV(HOLD_PIN); _delay_ms(1);} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderExit() {;}</span></span></code> </pre> <br>  bootLoaderInit () konfiguriert den Button-Pin (JUMPER_PIN) f√ºr den Eingang und schaltet den Hosentr√§ger darauf aus.  Wir haben bereits einen Klimmzug auf dem Brett und auf dem Boden, und wenn Sie einen Knopf auf dem Stift dr√ºcken, wird es im Gegenteil einen geben.  Gleichzeitig k√∂nnen Sie das HOLD-Signal sofort f√ºr die Ausgabe konfigurieren und das Ger√§t darauf einstellen ... <br><br>  Eine Erkl√§rung der Bit-Arithmetik finden Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . Ein Verst√§ndnis der GPIO-Setup-Register in AVR-Controllern kann beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus gewonnen werden</a> . <br><br>  Die Funktion bootLoaderExit () ist leer, weil  Die exponierte Konfiguration eignet sich gut f√ºr den anschlie√üenden √úbergang zur Hauptfirmware <br><br>  Die Funktion bootLoaderStartCondition (), die f√ºr die Eingabe des Bootloaders im Makroformat verantwortlich ist, passt nicht hinein und ist daher zu einer vollwertigen Funktion geworden <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ASSEMBLER__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Bootloader condition is to hold the button for 5 seconds inline unsigned char bootLoaderStartCondition() { long int i; for(i=0; i&lt;10000000; i++) if( !(JUMPER_INP &amp; _BV(JUMPER_PIN))) return 0; return 1; } #endif</span></span></span></span></code> </pre> <br>  Die Funktion √ºberpr√ºft innerhalb weniger Sekunden (tats√§chlich ca. 6-7) den Status der Taste.  Wenn die Schaltfl√§che fr√ºher losgelassen wurde, m√ºssen wir den Bootloader nicht aufrufen.  Geduldig und hartn√§ckig d√ºrfen Sie den Bootloader betreten. <br><br>  Wie sich herausstellte, ist die Datei bootloaderconfig.h an der Kompilierung von Assembler-Dateien beteiligt, und der Code in dieser Datei verursacht Fehler.  Ich musste die Funktion in den Block #ifndef __ASSEMBLER__ einf√ºgen <br><br>  Ein weiterer Parameter, den ich optimiert habe, teilt dem Bootloader mit, was zu tun ist, wenn er nicht an USB angeschlossen ist. Beenden Sie ihn nach einer Sekunde.  Tatsache ist, dass der Sohn w√§hrend des Einbruchs oft den Knopf dr√ºckte und versehentlich in den Bootloader ging.  Ich wei√ü nicht, wie wunderbar es ist, aber wenn der Bootloader die USB-Verbindung nicht sieht, kann er versehentlich einige Speicherseiten √ºberschreiben.  Wenn keine Verbindung besteht, kehren wir einfach zum Hauptprogramm zur√ºck. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Define bootloader timeout value. * * The bootloader will only time out if a user program was loaded. * * AUTO_EXIT_NO_USB_MS The bootloader will exit after this delay if no USB is connected. * Set to 0 to disable * Adds ~6 bytes. * (This will wait for an USB SE0 reset from the host) * * All values are approx. in milliseconds */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTO_EXIT_NO_USB_MS 1000</span></span></code> </pre> <br>  Wir kompilieren ... und es wird eine Fehlermeldung angezeigt, dass der Code nicht in den ihm zugewiesenen Bootloader-Speicherplatz passt.  Da der Flash-Speicher im Controller sehr klein ist, wird der Bootloader maximal gedr√ºckt, um mehr Platz f√ºr das Hauptprogramm zu lassen.  Dies l√§sst sich jedoch leicht in der Datei Makefile.inc beheben, indem Sie den Anweisungen folgen. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hexadecimal address for bootloader section to begin. To calculate the best value: # - make clean; make main.hex; ### output will list data: 2124 (or something like that) # - for the size of your device (8kb = 1024 * 8 = 8192) subtract above value 2124... = 6068 # - How many pages in is that? 6068 / 64 (tiny85 page size in bytes) = 94.8125 # - round that down to 94 - our new bootloader address is 94 * 64 = 6016, in hex = 1780 BOOTLOADER_ADDRESS = 1940</span></span></code> </pre> <br>  Dann habe ich nur die Startadresse des Bootloaders auf eine Seite (64 Byte) reduziert und dadurch den Speicherplatz des Bootloaders vergr√∂√üert. <br><br>  Andernfalls war das Kompilieren und Hochladen des Bootloaders mit dem USBAsp-Programmierer kein Problem. <br><br><h2>  Fazit </h2><br>  Es war ein sehr interessanter Weg von einem Prototyp auf einem Steckbrett zu einem fertigen Ger√§t.  Es scheint wie ein gew√∂hnlicher Blinker aus einer Arduino-Lektion, aber tats√§chlich musste ich w√§hrend der Arbeit eine ganze Reihe interessanter Probleme l√∂sen - hier sind der Kampf mit dem Verbrauch, die Wahl der Elementbasis und das Design des Geh√§uses und das Erinnern an die Firmware mit dem Bootloader.  Ich hoffe aufrichtig, dass meine Erfahrung jemandem n√ºtzlich sein wird. <br><br>  K√∂nnte es einfacher gewesen sein?  Nat√ºrlich kannst du.  Ich denke, alles k√∂nnte mit einem Transistor gemacht werden.  Leider habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> gelesen, nachdem ich die Platine gel√∂tet habe.  Ich w√ºrde den Artikel fr√ºher sehen - ich w√ºrde alles auf dem gleichen beliebten TP4056 machen - es ist einfacher, ihn zu l√∂ten.  Der DC-DC-Wandler, der sich in diesem Ger√§t im PT1502 befindet, wird auf keinen Fall ben√∂tigt.  Eine praktische Untersuchung des PT1502-Mikroschaltkreises ist f√ºr mich jedoch n√ºtzlich f√ºr mein anderes Projekt sowie f√ºr die F√§higkeit, Mikroschaltkreise im QFN20-Geh√§use zu l√∂ten. <br><br>  Zum Schluss hier die Links zu meinem Projekt: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Firmware-Code</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schaltung und Platine</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geh√§use- und Diffusormodell</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereit STL-Modelle zum Drucken</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435198/">https://habr.com/ru/post/de435198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435184/index.html">K√ºnstliche Intelligenz lernte 6 Jahre vor der Diagnose, die Alzheimer-Krankheit im Gehirn zu finden</a></li>
<li><a href="../de435186/index.html">Rolls-Royce entwickelt das schnellste Elektroflugzeug der Welt</a></li>
<li><a href="../de435190/index.html">Google hat es geschafft, √ºber Irland und Bermuda Steuern von 22,7 Milliarden US-Dollar abzuziehen</a></li>
<li><a href="../de435194/index.html">Vereinfachen Sie das Schreiben eines Lebenslaufs eines Entwicklers</a></li>
<li><a href="../de435196/index.html">Forscher geben ReCAPTCHA √ºber Google-Dienste weiter</a></li>
<li><a href="../de435202/index.html">Wir schreiben unsere Programmiersprache, Teil 1: Wir schreiben eine Sprach-VM</a></li>
<li><a href="../de435204/index.html">Empfang f√ºr Entwickler zur √úberwindung des Aufschubs</a></li>
<li><a href="../de435206/index.html">Europa genehmigt Urheberrechtsrichtlinie - warum Streaming-Plattformen dagegen sind</a></li>
<li><a href="../de435208/index.html">Internet der Dinge ... die nach einer guten UI / UX schreien</a></li>
<li><a href="../de435210/index.html">Xamarins Arbeit mit dem C SDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>