<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ… ğŸ¤³ğŸ» ğŸ˜š Mekanika Kuantum Perhitungan dalam JS ğŸ’° ğŸ’†ğŸ½ â–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, nama saya Dmitry Karlovsky dan saya ... menganggur. Karena itu, saya punya banyak waktu luang untuk bermain musik, olahraga, kreativitas, bahasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mekanika Kuantum Perhitungan dalam JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413791/"><p> Halo, nama saya Dmitry Karlovsky dan saya ... menganggur.  Karena itu, saya punya banyak waktu luang untuk bermain musik, olahraga, kreativitas, bahasa, konferensi JS dan ilmu komputer.  Saya akan memberi tahu Anda tentang penelitian terbaru di bidang <code>$mol_fiber</code> semi-otomatis perhitungan panjang menjadi kuanta kecil beberapa milidetik, yang menghasilkan perpustakaan miniatur <code>$mol_fiber</code> .  Tapi pertama-tama, mari kita uraikan masalah yang akan kita pecahkan .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/787/033/fb0/787033fb0e7d49cad98ce046a4e2380a.gif" alt="Quanta!"></p><br><p>  Ini adalah versi teks dari kinerja eponymous di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS 2018 Piter</a> .  Anda dapat <a href="">membacanya sebagai artikel</a> , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membukanya di antarmuka presentasi</a> , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menonton video</a> . </p><a name="habracut"></a><br><h1 id="issue-low-responsiveness">  Masalah: Responsif yang rendah </h1><br><p>  Jika kita ingin memiliki 60 frame per detik yang stabil, maka kita hanya memiliki 16 frame dengan sepersekian milidetik untuk melakukan semua pekerjaan, termasuk apa yang dilakukan browser untuk menunjukkan hasil di layar. </p><br><p>  Tetapi bagaimana jika kita mengambil alur untuk waktu yang lebih lama?  Kemudian pengguna akan mengamati antarmuka yang tertinggal, menghambat animasi dan sejenisnya dari degradasi UX. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f8/b6f/431/9f8b6f43150f6aa318daf6bd7bde9e56.gif" alt="Daya tanggap yang rendah"></p><br><h1 id="issue-no-escape">  Masalah: Tidak ada jalan keluar </h1><br><p>  Kebetulan saat kita melakukan perhitungan, hasilnya tidak lagi menarik bagi kita.  Misalnya, kami memiliki gulir virtual, pengguna secara aktif menariknya, tetapi kami tidak dapat mengikutinya dan tidak dapat merender area yang sebenarnya hingga rendering mengembalikan kontrol untuk menangani peristiwa pengguna. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/28d/4d9/12f/28d4d912fb979ddb97ac61f3bb314756.jpg" alt="Tidak bisa diurungkan"></p><br><p>  Idealnya, tidak peduli berapa lama pekerjaan yang kita lakukan, kita harus terus memproses acara dan dapat setiap saat membatalkan pekerjaan yang telah kita mulai, tetapi belum selesai. </p><br><h1 id="im-fast-and-i-know-it">  Saya cepat dan saya tahu itu </h1><br><p>  Tetapi bagaimana jika pekerjaan kita bukan satu, tetapi beberapa, tetapi satu aliran?  Bayangkan Anda mengendarai teratai kuning yang baru dibeli dan pergi ke persimpangan kereta api.  Saat gratis, Anda dapat menyelipkannya dalam hitungan detik.  Tapi .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fcc/078/f2b/fcc078f2b90d03703c61d42ffe53701f.jpg" alt="Mobil keren"></p><br><h1 id="issue-no-concurrency">  Masalah: Tidak ada konkurensi </h1><br><p>  Ketika persimpangan ditempati oleh kereta satu kilometer, Anda harus berdiri dan menunggu sepuluh menit sampai berlalu.  Bukan untuk itu Anda membeli mobil sport, bukan? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0fe/ed1/d50/0feed1d50bc38d61f26f11d28f80a87c.gif" alt="Cepat, tunggu lambat"></p><br><p>  Dan betapa asyiknya jika kereta ini dibagi menjadi 10 kereta masing-masing 100 meter dan akan ada beberapa menit di antara mereka untuk melewatinya!  Anda tidak akan terlambat kalau begitu. </p><br><p>  Jadi apa solusi untuk masalah ini di dunia JS sekarang? </p><br><h1 id="solution-workers">  Solusi: Pekerja </h1><br><p>  Hal pertama yang terlintas dalam pikiran: mari kita letakkan semua perhitungan rumit ke dalam utas terpisah?  Untuk melakukan ini, kami memiliki mekanisme untuk WebWorkers. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6b/005/e78/f6b005e7836243e1434af86e1cc337cc.png" alt="Logika pekerja"></p><br><p>  Acara dari aliran UI diteruskan ke pekerja.  Di sana mereka diproses dan instruksi tentang apa dan bagaimana mengubah pada halaman sudah dikembalikan.  Jadi, kami menyimpan aliran UI dari lapisan besar komputasi, tetapi tidak semua masalah diselesaikan dengan cara ini, dan di samping itu, masalah baru ditambahkan. </p><br><h1 id="workers-issues-deserialization">  Pekerja: Masalah: Serialisasi (De) </h1><br><p>  Komunikasi antara aliran terjadi dengan mengirim pesan yang diserialisasi ke aliran byte, ditransfer ke aliran lain, dan di sana mereka diurai menjadi objek.  Semua ini jauh lebih lambat daripada pemanggilan metode langsung dalam satu utas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c76/7db/e9fc767db4a76ac2079610a2df590eaa.jpg" alt="(De) serialisasi"></p><br><h1 id="workers-issues-asynchronous-only">  Pekerja: Masalah: Asinkron saja </h1><br><p>  Pesan-pesan dikirimkan secara ketat secara tidak sinkron.  Dan ini berarti bahwa beberapa fitur yang saya minta tidak tersedia.  Misalnya, Anda tidak dapat menghentikan pendakian peristiwa ui dari pekerja, karena pada saat pawang dimulai, acara di utas UI sudah akan menyelesaikan siklus hidupnya. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/083/1c9/d42/0831c9d4270c8a64e17febb2d509ec56.png" alt="Pesan antrian"></p><br><h1 id="workers-issues-limited-apis">  Pekerja: Masalah: API Terbatas </h1><br><p>  API berikut ini tidak tersedia bagi kami di pekerja .. </p><br><ul><li>  DOM, CSSOM </li><li>  Kanvas </li><li>  Geolokasi </li><li>  Sejarah &amp; Lokasi </li><li>  Sinkronkan permintaan http </li><li>  XMLHttpRequest.responseXML </li><li>  Jendela </li></ul><br><h1 id="workers-issues-cant-cancel">  Pekerja: Masalah: Tidak bisa membatalkan </h1><br><p>  Dan lagi, kita tidak punya cara untuk menghentikan perhitungan di woker. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/059/e49/064059e49ab01b803d84001dc2111da8.jpg" alt="Hentikan itu!"></p><br><p>  Ya, kita bisa menghentikan seluruh pekerja, tetapi itu akan menghentikan semua tugas di dalamnya. <br>  Ya, Anda dapat menjalankan setiap tugas dalam pekerja yang terpisah, tetapi sangat intensif sumber daya. </p><br><h1 id="solution-react-fiber">  Solusi: Bereaksi Fiber </h1><br><p>  Tentunya banyak yang mendengar FaceBook secara heroik menulis ulang Bereaksi, memecah semua perhitungan di dalamnya menjadi banyak fungsi kecil yang diluncurkan oleh penjadwal khusus. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/079/4f3/de4/0794f3de41b63342f7298e82f7d6bdb2.png" alt="Tricky React Fiber Logic"></p><br><p>  Saya tidak akan membahas detail implementasinya, karena ini adalah topik besar yang terpisah.  Saya hanya akan mencatat beberapa fitur, karena itu mungkin tidak cocok untuk Anda .. </p><br><h1 id="react-fiber-react-required">  Bereaksi Fiber: Bereaksi diperlukan </h1><br><p>  Jelas, jika Anda menggunakan Angular, Vue, atau kerangka kerja lain selain Bereaksi, maka React Fiber tidak berguna untuk Anda. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/015/01e/1fa/01501e1fa047ab219dbaf0cd140e7002.jpg" alt="Bereaksi Di Mana Saja!"></p><br><h1 id="react-fiber-only-rendering">  React Fibre: Hanya rendering </h1><br><p>  Bereaksi - hanya mencakup lapisan rendering.  Semua lapisan aplikasi lainnya dibiarkan tanpa kuantisasi. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a82/3f5/c3e/a823f5c3e063d3961f64b0c18b25aa1b.gif" alt="Tidak aktif itu!"></p><br><p>  React Fibre tidak akan menyelamatkan Anda saat Anda perlu, misalnya, untuk memfilter sejumlah besar data dengan kondisi rumit. </p><br><h1 id="react-fiber-quantization-is-disabled">  React Fiber: Kuantisasi dinonaktifkan </h1><br><p>  Meskipun dukungan yang diklaim untuk kuantisasi, masih dinonaktifkan secara default, karena merusak kompatibilitas ke belakang. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/498/f7b/4be/498f7b4be46edbbbf0884a71bccc89a8.jpg" alt="Perangkap pemasaran"></p><br><p>  Kuantisasi dalam Bereaksi masih merupakan hal yang eksperimental.  Berhati-hatilah! </p><br><h1 id="react-fiber-debug-is-pain">  Serat Bereaksi: Debug adalah rasa sakit </h1><br><p>  Ketika Anda mengaktifkan kuantisasi, callstack tidak lagi cocok dengan kode Anda, yang sangat menyulitkan proses debug.  Tetapi kami akan kembali ke masalah ini. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3dd/725/bd5/3dd725bd5c728f4ecc43f167f2724f63.jpg" alt="Semua sakitnya debugging"></p><br><h1 id="solution-quantization">  Solusi: kuantisasi </h1><br><p>  Mari kita coba menggeneralisasi pendekatan React Fibre untuk menyingkirkan kerugian yang disebutkan.  Kami ingin tetap berada dalam kerangka satu aliran, tetapi memecah perhitungan panjang menjadi kuanta kecil, di antaranya browser dapat membuat perubahan yang telah dibuat ke laman, dan kami akan merespons acara. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a98/9c5/e9e/a989c5e9e41bc35a36a656a7ce19d610.png" alt="bagan nyala api"></p><br><p>  Di atas Anda melihat perhitungan panjang yang menghentikan seluruh dunia lebih dari 100 ms.  Dan dari bawah - perhitungan yang sama, tetapi dipecah menjadi irisan waktu sekitar 16ms, yang memberi rata-rata 60 frame per detik.  Karena kami biasanya tidak tahu berapa lama waktu yang diperlukan perhitungan, kami tidak dapat secara manual memecahnya menjadi potongan-potongan 16ms di muka.  Oleh karena itu, kita memerlukan semacam mekanisme runtime yang mengukur waktu yang diperlukan untuk menyelesaikan tugas dan ketika kuantum terlampaui, yang menghentikan sementara eksekusi hingga frame animasi berikutnya.  Mari kita pikirkan mekanisme apa yang kita miliki untuk mengimplementasikan tugas yang ditangguhkan di sini .. </p><br><h1 id="concurrency-fibers--stackfull-coroutines">  Konkurensi: serat - stackfull coroutine </h1><br><p>  Dalam bahasa seperti Go dan D ada ungkapan seperti "coroutine with a stack", itu juga "fiber" atau "fiber". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Future } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-fibers'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> Future.wait( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">future</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( future.return ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> Future.task( four ).detach()</code> </pre> <br><p>  Dalam contoh kode, Anda melihat <code>one</code> fungsi, yang dapat menjeda serat saat ini, tetapi itu sendiri memiliki antarmuka yang sepenuhnya sinkron.  <code>two</code> , <code>three</code> dan <code>four</code> fungsi adalah fungsi sinkron biasa yang tidak tahu apa-apa tentang serat.  Di dalamnya Anda dapat menggunakan semua fitur javascript secara penuh.  Dan akhirnya, pada baris terakhir, kita cukup menjalankan <code>four</code> fungsi dalam serat yang terpisah. </p><br><p>  Menggunakan serat cukup mudah, tetapi untuk mendukungnya, Anda memerlukan dukungan runtime, yang tidak dimiliki sebagian besar penerjemah JS.  Namun, untuk NodeJS ada ekstensi <code>node-fibers</code> yang menambahkan dukungan ini.  Sayangnya, tidak ada browser yang tersedia di browser apa pun. </p><br><h1 id="concurrency-fsm--stackless-coroutines">  Concurrency: FSM - coroutine tanpa tumpukan </h1><br><p>  Dalam bahasa seperti C # dan sekarang JS ada dukungan untuk "stackless coroutines" atau "asynchronous functions."  Fungsi-fungsi tersebut adalah mesin negara di bawah kap dan tidak tahu apa-apa tentang tumpukan, jadi Anda harus menandainya dengan kata kunci khusus "async", dan tempat-tempat di mana mereka dapat berhenti - "menunggu". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( done ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> one(</span></span></span><span class="hljs-function">) ) + 1 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">three</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> two() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> three() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> four()</code> </pre> <br><p>  Karena kita mungkin perlu menunda perhitungan kapan saja, ternyata hampir semua fungsi dalam aplikasi harus dibuat tidak sinkron.  Ini tidak hanya kompleksitas kode, tetapi juga sangat mempengaruhi kinerja.  Selain itu, banyak API yang menerima panggilan balik masih tidak mendukung panggilan balik yang tidak sinkron.  Contoh mencolok adalah metode <code>reduce</code> array apa pun. </p><br><h1 id="concurrency-semi-fibers---restarts">  Concurrency: semi-fiber - restart </h1><br><p>  Mari kita coba melakukan sesuatu yang mirip dengan fiber, hanya menggunakan fitur-fitur yang tersedia untuk kita di browser modern apa pun .. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async , $mol_fiber_start } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> $mol_fiber_async( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( back ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> $mol_fiber_start( four )</code> </pre> <br><p>  Seperti yang Anda lihat, fungsi perantara tidak tahu apa-apa tentang gangguan - ini adalah JS biasa.  Hanya <code>one</code> fungsi yang tahu tentang kemungkinan suspensi.  Untuk membatalkan perhitungan, dia hanya melempar <code>Promise</code> sebagai pengecualian.  Pada baris terakhir, kita menjalankan <code>four</code> fungsi dalam pseudo-fiber yang terpisah, yang memonitor pengecualian yang dilemparkan ke dalam, dan jika <code>Promise</code> tiba, berlangganan <code>resolve</code> , dan kemudian restart serat. </p><br><h1 id="figures">  Tokoh </h1><br><p>  Untuk menunjukkan cara kerja pseudo-fiber, kami akan menulis kode rumit .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dce/e56/26a/dcee5626ad6c81048ca43a54a2825fe4.svg" alt="Bagan Eksekusi Khas"></p><br><p>  Mari kita bayangkan bahwa fungsi <code>step</code> sini menulis sesuatu ke konsol dan melakukan kerja keras lainnya selama 20 ms.  Dan fungsi <code>walk</code> memanggil <code>step</code> dua kali, mencatat seluruh proses.  Di tengah, itu akan menunjukkan apa yang sekarang ditampilkan di konsol.  Dan di sebelah kanan adalah keadaan pohon pseudofiber. </p><br><h1 id="mol_fiber-no-quantization">  $ mol_fiber: tidak ada kuantisasi </h1><br><p>  Mari kita jalankan kode ini dan lihat apa yang terjadi .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aa0/8aa/d4e/aa08aad4e3770368fd787aba5e8fcf81.svg" alt="Eksekusi tanpa kuantisasi"></p><br><p>  Sejauh ini, semuanya sederhana dan jelas.  Pohon serat semu, tentu saja, tidak terlibat.  Dan semuanya akan baik-baik saja, tetapi kode ini dieksekusi selama lebih dari 40 ms, yang tidak berharga. </p><br><h1 id="mol_fiber-cache-first">  $ mol_fiber: cache terlebih dahulu </h1><br><p>  Mari kita bungkus kedua fungsi dalam pembungkus khusus yang menjalankannya dalam pseudo-fiber dan lihat apa yang terjadi .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/7e3/2f9/1f27e32f982035e32f59c4100aac3dd0.svg" alt="Cache mengisi"></p><br><p>  Di sini perlu diperhatikan fakta bahwa untuk setiap tempat memanggil <code>one</code> fungsi di dalam serat <code>walk</code> , serat terpisah dibuat.  Hasil dari panggilan pertama di-cache, tetapi alih-alih yang kedua, <code>Promise</code> dilemparkan, karena kami telah menghabiskan waktu kita. </p><br><h1 id="mol_fiber-cache-second">  $ mol_fiber: cache kedua </h1><br><p>  Dilemparkan ke dalam frame pertama, <code>Promise</code> akan secara otomatis diselesaikan pada frame berikutnya, yang akan menyebabkan restart dari <code>walk</code> fiber. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ec/d06/80b/2ecd0680bb11b2b425c2464e8d119362.svg" alt="Penggunaan Kembali Cache"></p><br><p>  Seperti yang Anda lihat, karena restart, kami kembali mengembalikan "start" dan "first done" ke konsol, tetapi "first start" tidak ada lagi, karena ia berada di serat dengan cache yang diisi sebelumnya, karena penangannya lebih tidak dipanggil.  Ketika cache serat <code>walk</code> terisi, semua serat yang tertanam dihancurkan, karena eksekusi tidak akan pernah mencapai mereka. </p><br><p>  Jadi mengapa <code>first begin</code> mencetak satu kali dan <code>first done</code> dua?  Ini semua tentang idempotensi.  <code>console.log</code> - operasi non-idempoten, berapa kali Anda menyebutnya, berapa kali akan menambahkan entri ke konsol.  Tetapi serat yang mengeksekusi di serat lain idempoten, serat hanya mengeksekusi pegangan pada panggilan pertama, dan pada pengembalian berikutnya segera hasil dari cache, tanpa mengarah ke efek samping tambahan. </p><br><h1 id="mol_fiber-idempotence-first">  $ mol_fiber: idempotence terlebih dahulu </h1><br><p>  Mari kita bungkus <code>console.log</code> dalam sebuah fiber, sehingga membuatnya idempoten, dan lihat bagaimana program tersebut berperilaku .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/340/552/c63/340552c63f8356ee7b680ae76558ec90.svg" alt="mengisi cache idempoten"></p><br><p>  Seperti yang Anda lihat, sekarang di pohon serat kami memiliki entri untuk setiap panggilan ke fungsi <code>log</code> . </p><br><h1 id="mol_fiber-idempotence-second">  $ mol_fiber: idempotence kedua </h1><br><p>  Pada restart berikutnya dari <code>walk</code> fiber, panggilan berulang ke fungsi <code>log</code> tidak lagi mengarah ke panggilan ke <code>console.log</code> nyata, tetapi segera setelah kita mendapatkan eksekusi dari fiber dengan cache kosong, panggilan ke <code>console.log</code> dilanjutkan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b32/2ac/e0b/b322ace0b34b91d3db8c52cbf78599f5.svg" alt="Menggunakan kembali cache idempoten"></p><br><p>  Harap dicatat bahwa di konsol kami sekarang tidak menampilkan sesuatu yang berlebihan - persis apa yang akan ditampilkan dalam kode sinkron tanpa serat dan kuantifikasi. </p><br><h1 id="mol_fiber-break">  $ mol_fiber: break </h1><br><p>  Bagaimana cara penghitungan interupsi?  Di awal kuantum, batas waktu ditetapkan.  Dan sebelum memulai setiap serat, diperiksa apakah kita telah mencapainya.  Dan jika Anda mencapai, maka <code>Promise</code> bergegas, yang diselesaikan di bingkai berikutnya dan memulai kuantum baru .. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) }</code> </pre> <br><h1 id="mol_fiber-deadline">  $ mol_fiber: batas waktu </h1><br><p>  Batas waktu untuk kuantum mudah diatur.  8 milidetik ditambahkan ke waktu saat ini.  Mengapa tepatnya 8, karena ada sebanyak 16 untuk mempersiapkan tembakan?  Faktanya adalah kita tidak tahu sebelumnya berapa lama browser harus di-render, jadi kita perlu menyisihkan waktu agar browser berfungsi.  Tetapi kadang-kadang terjadi bahwa browser tidak perlu membuat apa pun, dan kemudian dengan 8ms kuanta kita dapat memasukkan kuantum lain ke dalam bingkai yang sama, yang akan memberikan pengemasan padat dari quanta dengan downtime prosesor yang minimal. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> now = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quant = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elapsed = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span> , now - $mol_fiber.deadline ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resistance = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( elapsed , <span class="hljs-number"><span class="hljs-number">1000</span></span> ) / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 .. 100 ms $mol_fiber.deadline = now + quant + resistence</span></span></code> </pre> <br><p>  Tetapi jika kita hanya membuang eksepsi setiap 8ms, maka debugging dengan stop yang dihidupkan akan berubah menjadi cabang kecil neraka.  Kami membutuhkan beberapa mekanisme untuk mendeteksi mode debugger ini.  Sayangnya, ini hanya dapat dipahami secara tidak langsung: seseorang membutuhkan waktu sekitar satu detik untuk memahami apakah akan melanjutkan eksekusi atau tidak.  Dan ini berarti bahwa jika kontrol tidak kembali ke skrip untuk waktu yang lama, maka debugger akan berhenti, atau ada perhitungan yang berat.  Untuk duduk di kedua kursi, kami menambah 10% dari waktu yang telah berlalu, tetapi tidak lebih dari 100 ms.  Ini tidak terlalu memengaruhi FPS, tetapi mengurangi frekuensi berhenti debugger dengan urutan besarnya karena kuantisasi. </p><br><h1 id="debug-trycatch">  Debug: coba / tangkap </h1><br><p>  Karena kita berbicara tentang debugging, bagaimana menurut Anda, di mana kode ini berhenti debugger? </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new Error( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) // [<span class="hljs-number"><span class="hljs-number">1</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { handle( error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error // [<span class="hljs-number"><span class="hljs-number">2</span></span>] }</code> </pre> <br><p>  Sebagai aturan, ia perlu berhenti di mana pengecualian dilemparkan untuk pertama kalinya, tetapi kenyataannya adalah ia berhenti hanya di mana itu dilemparkan terakhir kali, yang biasanya sangat jauh dari tempat itu terjadi.  Karena itu, agar tidak menyulitkan debugging, pengecualian tidak boleh ditangkap, melalui try-catch.  Tetapi bahkan tanpa pengecualian penanganan itu tidak mungkin. </p><br><h1 id="debug-unhandled-events">  Debug: acara yang tidak ditangani </h1><br><p>  Biasanya, runtime menyediakan acara global yang terjadi untuk setiap pengecualian yang tidak tertangkap. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'error'</span></span> , event =&gt; handle( event.error ) ) foo()</code> </pre> <br><p>  Selain ketidaknyamanan, solusi ini memiliki kelemahan sehingga semua pengecualian jatuh di sini dan cukup sulit untuk memahami dari serat dan serat apakah peristiwa itu terjadi. </p><br><h1 id="debug-promise">  Debug: Janji </h1><br><p>  Janji adalah cara terbaik untuk menangani pengecualian. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { foo() } ).catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> handle( error ) )</code> </pre> <br><p>  Fungsi yang diteruskan ke Janji disebut segera, secara serempak, tetapi pengecualian tidak tertangkap dan aman menghentikan debugger di tempat kejadiannya.  Beberapa saat kemudian, secara tidak sinkron, ia sudah memanggil penangan kesalahan, di mana kita tahu persis serat mana yang memberi kegagalan dan kegagalan mana.  Inilah mekanisme yang digunakan dalam $ mol_fiber. </p><br><h1 id="stack-trace-react-fiber">  Jejak tumpukan: bereaksi serat </h1><br><p>  Mari kita lihat jejak stack yang Anda dapatkan di React Fiber .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/074/97d/d53/07497dd53b67863fe121c9cc7d314f96.png" alt="Tumpukan kosong"></p><br><p>  Seperti yang Anda lihat, kami mendapat banyak nyali Bereaksi.  Dari yang berguna di sini, hanya titik terjadinya pengecualian dan nama-nama komponen lebih tinggi dalam hierarki.  Tidak banyak. </p><br><h1 id="stack-trace-mol_fiber">  Jejak tumpukan: $ mol_fiber </h1><br><p>  Di $ mol_fiber, kami mendapatkan jejak stack yang jauh lebih berguna: tanpa nyali, hanya titik-titik tertentu dalam kode aplikasi yang melaluinya pengecualian. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b8/99d/8cc/5b899d8ccd70b5489cf87fea439beb5a.png" alt="Strace konten"></p><br><p>  Ini dicapai melalui penggunaan tumpukan asli, janji-janji dan penghapusan usus secara otomatis.  Jika mau, Anda dapat memperluas kesalahan di konsol, seperti di tangkapan layar, dan melihat isi, tetapi tidak ada yang menarik. </p><br><h1 id="mol_fiber-handle">  $ mol_fiber: handle </h1><br><p>  Jadi, untuk mengganggu kuantum, Janji dilemparkan. </p><br><pre> <code class="hljs javascript">limit() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Tetapi, seperti yang Anda duga, Janji dapat benar-benar apa saja - bagi seorang Fibre, secara umum, tidak masalah apa yang diharapkan: frame berikutnya, penyelesaian pemuatan data atau sesuatu yang lain .. </p><br><pre> <code class="hljs javascript">fail( error : <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> self.start() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.then( listener , listener ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Fibre hanya berlangganan untuk menyelesaikan janji dan memulai kembali.  Tapi janji melempar dan menangkap secara manual tidak perlu, karena paket itu mencakup beberapa pembungkus yang bermanfaat .. </p><br><h1 id="mol_fiber-functions">  $ mol_fiber: functions </h1><br><p>  Untuk mengubah fungsi sinkron apa pun menjadi serat idempoten, cukup bungkus dalam <code>$mol_fiber_func</code> .. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = fiberize( <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> main = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { log( getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ).data ) } )</code> </pre> <br><p>  Di sini kami membuat <code>console.log</code> idempoten, dan <code>main</code> diajarkan untuk menginterupsi sambil menunggu unduhan. </p><br><h1 id="mol_fiber-error-handling">  $ mol_fiber: penanganan kesalahan </h1><br><p>  Tetapi bagaimana menanggapi pengecualian jika kita tidak ingin menggunakan <code>try-catch</code> ?  Kemudian kita dapat mendaftarkan penangan kesalahan dengan <code>$mol_fiber_catch</code> ... </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize , $mol_fiber_catch <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> onError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getConfig = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { onError( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> }) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getData( <span class="hljs-string"><span class="hljs-string">'/config'</span></span> ).data } )</code> </pre> <br><p>  Jika kita mengembalikan sesuatu yang berbeda dari kesalahan di dalamnya, maka itu akan menjadi hasil dari serat saat ini.  Dalam contoh ini, jika tidak mungkin untuk mengunduh konfigurasi dari server, fungsi <code>getConfig</code> akan mengembalikan konfigurasi secara default. </p><br><h1 id="mol_fiber-methods">  $ mol_fiber: metode </h1><br><p>  Tentu saja, Anda dapat membungkus tidak hanya fungsi, tetapi juga metode menggunakan dekorator .. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_method <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mover</span></span></span><span class="hljs-class"> </span></span>{ @action move() { sendData( <span class="hljs-string"><span class="hljs-string">'ya.ru'</span></span> , getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ) ) } }</code> </pre> <br><p>  Di sini, misalnya, kami mengunggah data dari Google dan mengunggahnya ke Yandex. </p><br><h1 id="mol_fiber-promises">  $ mol_fiber: janji </h1><br><p>  Untuk mengunduh data dari server, cukup untuk mengambil, misalnya, fungsi asinkron <code>fetch</code> dan dengan gerakan pergelangan tangan mengubahnya menjadi sinkron. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_sync <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sync } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getData = sync( fetch )</code> </pre> <br><p>  Implementasi ini baik untuk semua orang, tetapi itu tidak mendukung membatalkan permintaan ketika pohon serat dihancurkan, jadi kita perlu menggunakan <code>API</code> lebih bingung .. </p><br><h1 id="mol_fiber-cancel-request">  $ mol_fiber: batalkan permintaan </h1><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> uri : string </span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AbortController(); fetch( uri , { <span class="hljs-attr"><span class="hljs-attr">signal</span></span> : controller.signal } ).then( back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> res ) , back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error } ) , ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> controller.abort() } ) }</code> </pre> <br><p>  Fungsi yang diteruskan ke bungkus <code>async</code> disebut hanya sekali dan bungkus <code>back</code> dilewatkan ke sana, di mana Anda perlu membungkus panggilan balik.  Karenanya, dalam panggilan balik ini, Anda harus mengembalikan nilainya atau melemparkan pengecualian.  Apa pun hasil dari panggilan balik itu, itu juga akan menjadi hasil serat.  Harap dicatat bahwa pada akhirnya kami mengembalikan fungsi yang akan dipanggil jika terjadi kerusakan prematur serat. </p><br><h1 id="mol_fiber-cancel-response">  $ mol_fiber: batalkan respons </h1><br><p>  Di sisi server, dapat juga berguna untuk membatalkan perhitungan ketika klien jatuh.  Mari kita menerapkan pembungkus di atas <code>midleware</code> yang akan membuat serat di mana <code>midleware</code> asli akan berjalan.     ,    ,       ,      . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_make <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Fiber } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> const middle_fiber = middleware =&gt; ( req , res ) =&gt; { const fiber = Fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> middleware( req , res ) ) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>( <span class="hljs-string"><span class="hljs-string">'close'</span></span> , <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> fiber.destructor() ) fiber.start() } app.get( <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> , middle_fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( req , res )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something } ) )</code> </pre> <br><h1 id="mol_fiber-concurrency"> $mol_fiber: concurrency </h1><br><p>       ,         .  ,    3 :    ,     ,   - .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/257/b87/a50/257b87a5095cecaf0e53da2234666a62.png" alt="Permintaan cepat dan lambat"></p><br><p>      :      ,    .       .       ,       ,   . </p><br><h1 id="mol_fiber-properties"> $mol_fiber: properties </h1><br><p>  ,    .. </p><br><blockquote> <strong>Pros:</strong> <br><ul><li> Runtime support isn't required </li><li> Can be cancelled at any time </li><li> High FPS </li><li> Concurrent execution </li><li> Debug friendly </li><li> ~ 3KB gzipped </li></ul><br><br> <strong>Cons:</strong> <br><ul><li> Instrumentation is required </li><li> All code should be idempotent </li><li> Longer total execution </li></ul><br></blockquote><p> $mol_fiber â€”   ,         .  â€” ,            .      , ,    .  ,   ,     ,     ,      .  ,          .        . </p><br><h1 id="links"> Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nin-jin.github.io/slides/fibers/</a> â€” this slides </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mol.js.org/fiber</a> â€” $mol_fiber online demo </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/eigenmethod/mol/tree/master/fiber</a> â€” $mol_fiber documentation </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">t.me/mam_mol</a> â€” lovely $mol chat </li></ul><br><h1 id="call-back"> Call back </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d35/cd4/554/d35cd4554553fa35a7d756cbf9737949.jpg" alt="Umpan balik"></p><br><p> <strong></strong> :   , ,        ) </p><br><p> <strong></strong> :  ,       . </p><br><p> <strong></strong> :  .    ,        . </p><br><p> <strong></strong> :    .   ,        .   ,    . </p><br><p> <strong></strong> :   ,            .     ,      ) </p><br><p> <strong></strong> :    ,     . </p><br><p> <strong></strong> :    -      .   ,        ,     . </p><br><p> <strong></strong> :       .  ,  ,     . </p><br><p> <strong></strong> :  ,     .     16ms,     ?  16  8 ,      8,   .      ,       .            ,    Â«Â». </p><br><p> <strong></strong> :      â€”       .  Terima kasih </p><br><p> <strong></strong> :    .    ,   .  ! </p><br><p> <strong></strong> :  ,         .        . </p><br><p> <strong></strong> :  ,     ,            ,      ,     ,     / ,            . </p><br><p> <strong></strong> :  ,     . </p><br><p> <strong></strong> :  . </p><br><p> <strong></strong> :         ,     .      mol. </p><br><p> <strong></strong> :    ,     ,    . ,  ,  ,   . </p><br><p> <strong></strong> :   . </p><br><p> <strong></strong> :       ,     .   ,     $mol,    ,  . </p><br><p> <strong></strong> :  ,  ,      .            â€” .  . </p><br><p> <strong></strong> :  -   ,         . </p><br><p> <strong></strong> :       $mol    ,        .  (pdf,  )  ,      . </p><br><p> <strong></strong> :     ,   .   ,     . </p><br><p> <strong></strong> :   ,    )       . </p><br><p> <strong></strong> :   .  . </p><br><p> <strong></strong> : In some places I missed what the reporter was saying. The conversation was about how to use the "Mola" library and "why?". But how it works remains a mystery for me.To smoke an source code is for the overhead. </p><br><p> <strong> </strong> :  ,  . </p><br><p> <strong> </strong> :  .         ,    .       .        . </p><br><p> <strong> </strong> :     :     .   -      (,   ).           ,   :          16? </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So-so</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Saya tidak bekerja dengan serat. </font><font style="vertical-align: inherit;">Pada laporan itu saya mendengar teori kerja serat. </font><font style="vertical-align: inherit;">Tapi saya benar-benar tidak tahu cara menggunakan mol_fiber di rumah ... Contoh kecil sangat bagus, tetapi bagaimana ini dapat diterapkan pada aplikasi besar dengan 30fps untuk mempercepat hingga 60fps - tidak ada pemahaman. </font><font style="vertical-align: inherit;">Sekarang, jika penulis lebih memperhatikan hal ini dan kurang mendesain modul internal - peringkat akan lebih tinggi.</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413791/">https://habr.com/ru/post/id413791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413779/index.html">Pengatur waktu dan multitasking di Arduino</a></li>
<li><a href="../id413781/index.html">Bagaimana Mengiklankan Bloodhound Ikuti Jejak Anda di Internet</a></li>
<li><a href="../id413783/index.html">Bagaimana bintang paling masif mati: supernova, hipernova, atau kolaps langsung?</a></li>
<li><a href="../id413787/index.html">Angular: ngx-terjemahkan. Meningkatkan infrastruktur dengan Webpack</a></li>
<li><a href="../id413789/index.html">Di Florida, mereka tidak memeriksa pembeli senjata di markas FBI selama setahun karena mereka lupa kata sandi</a></li>
<li><a href="../id413793/index.html">Kaset audio dalam budaya pop: mengapa format rekaman suara yang usang dianggap modis</a></li>
<li><a href="../id413795/index.html">Mengapa industri hiburan pindah ke IaaS: studi kasus</a></li>
<li><a href="../id413797/index.html">EA memperkenalkan bagian baru C&C di E3. Dan secara fisik menyakitkan untuk melihatnya</a></li>
<li><a href="../id413799/index.html">Penghitungan Lebah Ras Neural Pi Neural Network</a></li>
<li><a href="../id413801/index.html">"Roskosmos" menawarkan untuk membuat meriam laser ... sebuah teleskop optik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>