<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèº ü§∞üèº üë® Structures vs classes üíç üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üê°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D√®s le d√©but, quand j'ai commenc√© la programmation, la question s'est pos√©e de ce qu'il fallait utiliser pour am√©liorer les performances: structure ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structures vs classes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472290/">  D√®s le d√©but, quand j'ai commenc√© la programmation, la question s'est pos√©e de ce qu'il fallait utiliser pour am√©liorer les performances: structure ou classe;  quels tableaux sont les meilleurs √† utiliser et comment.  En ce qui concerne les structures, Apple se f√©licite de leur utilisation, expliquant qu'elles sont meilleures en optimisation, et toute l'essence du langage Swift est les structures.  Mais il y a ceux qui ne sont pas d'accord avec cela, car vous pouvez magnifiquement simplifier le code en h√©ritant d'une classe d'une autre et en travaillant avec une telle classe.  Pour acc√©l√©rer le travail avec les classes, nous avons cr√©√© diff√©rents modificateurs et objets qui ont √©t√© optimis√©s sp√©cifiquement pour les classes, et il est d√©j√† difficile de dire ce qui sera plus rapide et dans quel cas. <br><br>  Pour organiser tous les points sur le ¬´e¬ª, j'ai √©crit plusieurs tests qui utilisent les approches habituelles du traitement des donn√©es: passer √† une m√©thode, copier, travailler avec des tableaux, etc.  J'ai d√©cid√© de ne pas tirer de grandes conclusions, tout le monde d√©cidera par lui-m√™me s'il vaut la peine de croire les tests, pourra t√©l√©charger le projet et voir comment cela fonctionnera pour vous, et essayera d'optimiser le fonctionnement d'un test particulier.  Peut-√™tre m√™me de nouvelles puces sortiront que je n'ai pas mentionn√©es, ou elles sont si rarement utilis√©es que je n'en ai tout simplement pas entendu parler. <br><a name="habracut"></a><br>  PS J'ai commenc√© √† travailler sur un article sur Xcode 10.3 et j'ai pens√© √† comparer sa vitesse avec Xcode 11, mais l'article ne porte pas sur la comparaison de deux applications, mais sur la vitesse de nos applications.  Je ne doute pas que le temps d'ex√©cution des fonctions diminuera, et celui qui a √©t√© mal optimis√© deviendra plus rapide.  En cons√©quence, j'ai attendu le nouveau Swift 5.1 et j'ai d√©cid√© de tester les hypoth√®ses dans la pratique.  Bonne lecture. <br><br><h4>  Test 1: comparer des tableaux sur des structures et des classes </h4><br>  Supposons que nous ayons une classe et que nous voulions placer les objets de cette classe dans un tableau, l'action habituelle sur un tableau consiste √† la parcourir. <br><br>  Dans un tableau, lorsque vous utilisez des classes et que vous essayez de le parcourir, le nombre de liens augmente, une fois termin√©, le nombre de liens vers l'objet diminuera. <br><br>  Si nous parcourons la structure, au moment o√π l'objet est appel√© par index, une copie de l'objet sera cr√©√©e, en regardant la m√™me zone m√©moire, mais marqu√©e immuable.  Il est difficile de dire ce qui est plus rapide: augmenter le nombre de liens vers un objet ou cr√©er un lien vers une zone en m√©moire sans avoir la possibilit√© de le changer.  V√©rifions cela en pratique: <br><br><img src="https://habrastorage.org/webt/me/i5/2g/mei52ghwjxv_pg3c1toaoqachty.png"><br>  <i>Fig.</i>  <i>1: Comparaison de l'obtention d'une variable √† partir de tableaux bas√©s sur des structures et des classes</i> <br><br><h4>  Test 2. Comparez ContiguousArray vs Array </h4><br>  Ce qui est plus int√©ressant, c'est de comparer les performances d'un tableau (Array) avec un tableau de r√©f√©rence (ContiguousArray), qui est n√©cessaire sp√©cifiquement pour travailler avec des classes stock√©es dans le tableau. <br><br>  V√©rifions les performances dans les cas suivants: <br><br>  ContiguousArray stockant une structure avec un type de valeur <br>  ContiguousArray stockant struct avec String <br>  ContiguousArray stockant la classe avec le type de valeur <br>  ContiguousArray stockant la classe avec String <br>  Tableau stockant une structure avec un type de valeur <br>  Tableau stockant la structure avec String <br>  Tableau stockant une classe avec un type de valeur <br>  Tableau stockant la classe avec String <br><br>  √âtant donn√© que les r√©sultats des tests (tests: passage √† une fonction avec optimisation en ligne d√©sactiv√©e, passage √† une fonction avec optimisation en ligne activ√©e, suppression d'√©l√©ments, ajout d'√©l√©ments, acc√®s s√©quentiel √† un √©l√©ment dans une boucle) comprendront un grand nombre de tests (pour 8 tableaux de 5 tests chacun) , Je donnerai les r√©sultats les plus significatifs: <br><br><ol><li>  Si vous appelez une fonction et lui passez un tableau en d√©sactivant inline, un tel appel sera tr√®s co√ªteux (pour les classes bas√©es sur la cha√Æne de r√©f√©rence, il est 20 000 fois plus lent, pour les classes bas√©es sur Value, le type est 60 000 fois pire avec l'optimiseur en ligne d√©sactiv√©) . </li><li>  Si l'optimisation (en ligne) fonctionne pour vous, alors la d√©gradation ne devrait √™tre attendue que 2 fois, selon le type de donn√©es ajout√© √† quelle baie.  La seule exception √©tait le type de valeur, envelopp√© dans une structure situ√©e dans le ContiguousArray - sans d√©gradation de temps. </li><li>  Suppression - l'√©cart entre la matrice de r√©f√©rence et la matrice habituelle √©tait d'environ 20% (en faveur de la matrice habituelle). </li><li>  Ajouter: lors de l'utilisation d'objets envelopp√©s dans des classes, ContiguousArray avait une vitesse environ 20% plus rapide que Array avec les m√™mes objets, tandis qu'Array √©tait plus rapide lors du travail avec des structures que ContiguousArray avec des structures. </li><li>  L'acc√®s aux √©l√©ments du tableau lors de l'utilisation de wrappers √† partir de structures s'est av√©r√© √™tre plus rapide que n'importe quel wrapper sur des classes, y compris ContiguousArray (environ 500 fois plus rapide). </li></ol><br>  Dans la plupart des cas, l'utilisation de tableaux r√©guliers pour travailler avec des objets est plus efficace.  Utilis√© avant, nous utilisons plus loin. <br><br>  L'optimisation de boucle pour les tableaux est servie par l'initialiseur de collection paresseux, qui vous permet de parcourir une seule fois l'ensemble du tableau, m√™me si plusieurs filtres ou cartes sont utilis√©s sur les √©l√©ments du tableau. <br><br>  L'utilisation de structures comme outil d'optimisation pr√©sente des pi√®ges, tels que l'utilisation de types r√©f√©renc√©s en interne dans la nature: cha√Ænes, dictionnaires, tableaux de r√©f√©rence.  Ensuite, lorsqu'une variable qui stocke un type de r√©f√©rence en soi est entr√©e dans une fonction, une r√©f√©rence suppl√©mentaire est cr√©√©e pour chaque √©l√©ment qui est une classe.  Cela a un autre c√¥t√©, un peu plus loin.  Vous pouvez essayer d'utiliser une classe wrapper sur une variable.  Ensuite, le nombre de liens lors du passage √† la fonction augmentera uniquement pour elle, et le nombre de liens vers les valeurs √† l'int√©rieur de la structure restera le m√™me.  En g√©n√©ral, je veux voir combien de variables d'un type de r√©f√©rence doivent √™tre dans la structure pour que ses performances diminuent plus bas que les performances des classes avec les m√™mes param√®tres.  Il existe un article sur le Web intitul√© ¬´Arr√™tez d'utiliser les structures!¬ª Qui pose la m√™me question et y r√©pond.  J'ai t√©l√©charg√© le projet et j'ai d√©cid√© de comprendre ce qui se passe o√π et dans quels cas nous obtenons des structures lentes.  L'auteur montre la faible performance des structures par rapport aux classes, faisant valoir que la cr√©ation d'un nouvel objet est beaucoup plus lente que l'augmentation de la r√©f√©rence √† l'objet est absurde (j'ai donc supprim√© la ligne o√π un nouvel objet est cr√©√© dans la boucle √† chaque fois).  Mais si nous ne cr√©ons pas de lien vers l'objet, mais le passons simplement dans une fonction pour travailler avec lui, alors la diff√©rence de performance sera tr√®s insignifiante.  Chaque fois que nous mettons en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ligne</a> (jamais) une fonction, notre application doit l'ex√©cuter et ne pas cr√©er de code dans une cha√Æne.  √Ä en juger par les tests, Apple a fait en sorte que l'objet transmis √† la fonction soit l√©g√®rement modifi√©, pour les structures, le compilateur change de mutabilit√© et rend paresseux les propri√©t√©s non mutables de l'objet.  Quelque chose de similaire se produit dans la classe, mais augmente en m√™me temps le nombre de r√©f√©rences √† l'objet.  Et maintenant, nous avons un objet paresseux, tous ses champs sont √©galement paresseux, et chaque fois que nous appelons une variable objet, il l'initialise.  En cela, les structures n'ont pas d'√©gal: lorsqu'une fonction appelle deux variables, la structure de l'objet n'est que l√©g√®rement inf√©rieure √† la classe de vitesse;  lorsque vous en appelez trois ou plus, la structure sera toujours plus rapide. <br><br><h4>  Test 3: comparer les performances des structures et des classes stockant de grandes classes </h4><br>  J'ai √©galement l√©g√®rement modifi√© la m√©thode elle-m√™me, qui a √©t√© appel√©e lorsqu'une autre variable a √©t√© ajout√©e (de cette mani√®re, trois variables ont √©t√© initialis√©es dans la m√©thode, et non deux, comme dans l'article), et afin qu'il n'y ait pas de d√©bordement Int, j'ai remplac√© les op√©rations sur les variables par la somme et la soustraction.  Ajout de m√©triques de temps plus compr√©hensibles (dans la capture d'√©cran, il s'agit de secondes, mais ce n'est pas si important pour nous, il est important de comprendre les proportions r√©sultantes), en supprimant le cadre Darwin (je n'utilise pas dans les projets, peut-√™tre en vain, il n'y a pas de diff√©rences dans les tests avant / apr√®s l'ajout du cadre dans mon test), l'inclusion d'une optimisation maximale et de construire sur la version de la version (il semble que ce sera plus honn√™te), et voici le r√©sultat: <br><br><img src="https://habrastorage.org/webt/zv/q_/en/zvq_ens-bwgnuetcl53shkecjd0.png"><br>  <i>Fig.</i>  <i>2: Performances des structures et des classes de l'article ¬´Arr√™tez d'utiliser des structures¬ª</i> <br><br>  Les diff√©rences dans les r√©sultats des tests sont n√©gligeables. <br><br><h4>  Test 4: Fonction acceptant g√©n√©rique, protocole et fonction sans g√©n√©rique </h4><br>  Si nous prenons une fonction g√©n√©rique et y passons deux valeurs, unies uniquement par la possibilit√© de comparer ces valeurs (func min), alors le code de trois lignes se transformera en code de huit (comme le dit Apple).  Mais cela ne se produit pas toujours, Xcode a des m√©thodes d'optimisation dans lesquelles s'il voit deux valeurs structurelles lui √™tre transmises lorsqu'il appelle la fonction, il g√©n√®re automatiquement une fonction qui prend deux structures et ne copie plus les valeurs. <br><br><img src="https://habrastorage.org/webt/zo/fd/2v/zofd2v5qz7q3dkhzdcp_srpspyg.png"><br>  <i>Fig.</i>  <i>3: Fonction g√©n√©rique typique</i> <br><br>  J'ai d√©cid√© de tester deux fonctions: dans la premi√®re, le type de donn√©es g√©n√©rique est d√©clar√©, la seconde accepte uniquement le protocole.  Dans la nouvelle version de Swift 5.1 Protocol, il est m√™me un peu plus rapide que Generic (avant Swift 5.1, les protocoles √©taient 2 fois plus lents), bien que selon Apple, cela devrait √™tre l'inverse, mais quand il s'agit de passer par un tableau, nous devons d√©j√† taper, ce qui ralentit G√©n√©rique (mais ils sont toujours super, car ils sont plus rapides que les protocoles): <br><br><img src="https://habrastorage.org/webt/k-/ox/vr/k-oxvrhsx5mbw_osj7azkzu9x7y.png"><br>  <i>Fig.</i>  <i>4: Comparaison des fonctions h√¥tes g√©n√©riques et protocolaires.</i> <br><br><h4>  Test 5: Comparez l'appel de la m√©thode parent √† celui de la m√©thode native, et v√©rifiez en m√™me temps la classe finale pour un tel appel </h4><br>  Ce qui m'a toujours int√©ress√©, c'est la lenteur des cours avec un grand nombre de parents, la rapidit√© avec laquelle une classe appelle ses fonctions et celle d'un parent.  Dans les cas o√π nous essayons d'appeler une m√©thode qui prend une classe, la r√©partition dynamique entre en jeu.  Qu'est ce que c'est  Chaque fois qu'une m√©thode ou variable est appel√©e √† l'int√©rieur de notre fonction, un message est g√©n√©r√© demandant √† l'objet cette variable ou m√©thode.  L'objet, recevant une telle demande, commence √† rechercher la m√©thode dans la table de r√©partition de sa classe, et si un remplacement de la m√©thode ou de la variable a √©t√© appel√©, la prend et la renvoie, ou il atteint r√©cursivement la classe de base. <br><br><img src="https://habrastorage.org/webt/tr/wz/i-/trwzi-l8v51yv4oftdl33a-30z4.png"><br>  <i>Fig.</i>  <i>5: Appels de m√©thode de classe, pour les tests de r√©partition</i> <br><br>  Plusieurs conclusions peuvent √™tre tir√©es du test ci-dessus: plus la classe de classes parent est grande, plus elle fonctionnera lentement et que la diff√©rence de vitesse est si petite qu'elle peut √™tre n√©glig√©e en toute s√©curit√©, tr√®s probablement l'optimisation du code fera en sorte qu'il n'y aura pas de diff√©rence de vitesse.  Dans cet exemple, le modificateur de classe final n'a pas d'avantage, au contraire, le travail de la classe est encore plus lent, peut-√™tre du fait qu'il ne devient pas une fonction vraiment rapide. <br><br><h4>  Test 6: Appel d'une variable avec le dernier modificateur contre une variable de classe r√©guli√®re </h4><br>  √âgalement des r√©sultats tr√®s int√©ressants avec l'attribution du modificateur final √† une variable, vous pouvez l'utiliser lorsque vous savez avec certitude que la variable ne sera r√©√©crite nulle part dans les h√©ritiers de la classe.  Essayons de mettre le dernier modificateur √† une variable.  Si dans notre test, nous avons cr√©√© une seule variable et appel√© une propri√©t√© dessus, alors elle serait initialis√©e une fois (le r√©sultat est d'en bas).  Si nous cr√©ons honn√™tement √† chaque fois un nouvel objet et demandons sa variable, la vitesse ralentira sensiblement (le r√©sultat est au dessus): <br><br><img src="https://habrastorage.org/webt/ef/t7/d7/eft7d7u2wpc4htxcas5tiffnari.png"><br>  <i>Fig.</i>  <i>6: Appel de la derni√®re variable</i> <br><br>  De toute √©vidence, le modificateur n'est pas all√© au profit de la variable, et il est toujours plus lent que son concurrent. <br><br><h4>  Test 7: Probl√®me de polymorphisme et protocoles pour les structures.  Ou les performances d'un conteneur Existential </h4><br>  Probl√®me: si nous prenons un protocole qui prend en charge une certaine m√©thode et plusieurs structures h√©rit√©es de ce protocole, que pensera notre compilateur lorsque nous mettrons des structures avec diff√©rents volumes de valeurs stock√©es dans un tableau, unies par le protocole d'origine? <br><br>  Pour r√©soudre le probl√®me de l'appel d'une m√©thode pr√©d√©finie chez les h√©ritiers, le m√©canisme Protocol Witness Table est utilis√©.  Il cr√©e des structures shell qui r√©f√©rencent les m√©thodes n√©cessaires. <br><br>  Pour r√©soudre le probl√®me de stockage des donn√©es, un conteneur Existential est utilis√©.  Il stocke en lui-m√™me 5 cellules d'informations, chacune de 8 octets.  Dans les trois premiers, un espace est allou√© pour les donn√©es stock√©es dans la structure (si elles ne correspondent pas, cela cr√©e un lien vers le tas dans lequel les donn√©es sont stock√©es), le quatri√®me stocke des informations sur les types de donn√©es utilis√©es dans la structure et nous indique comment g√©rer ces donn√©es , le cinqui√®me contient des r√©f√©rences aux m√©thodes de l'objet. <br><br><img src="https://habrastorage.org/webt/jh/tu/6c/jhtu6cgi7hcnllrybgfphk9gx-i.png"><br>  <i>Figure 7. Comparaison des performances d'un tableau qui cr√©e un lien vers un objet et qui le contient</i> <br><br>  Entre les premier et deuxi√®me r√©sultats, le nombre de variables a tripl√©.  En th√©orie, ils doivent √™tre plac√©s dans un conteneur, ils sont stock√©s dans ce conteneur, et la diff√©rence de vitesse est due au volume de la structure.  Fait int√©ressant, si vous r√©duisez le nombre de variables dans la deuxi√®me structure, le temps de fonctionnement ne changera pas, c'est-√†-dire que le conteneur stocke en fait 3 ou 2 variables, mais il semble qu'il existe des conditions sp√©ciales pour une variable qui augmentent consid√©rablement la vitesse.  La deuxi√®me structure s'int√®gre parfaitement dans le conteneur et diff√®re en volume du troisi√®me de moiti√©, ce qui donne une forte d√©gradation √† l'ex√©cution, par rapport aux autres structures. <br><br><h4>  Un peu de th√©orie pour optimiser vos projets </h4><br>  Les facteurs suivants peuvent influencer les performances des structures: <br><br><ul><li>  o√π ses variables sont stock√©es (tas / pile); </li><li>  la n√©cessit√© de compter les r√©f√©rences pour les propri√©t√©s; </li><li>  m√©thodes de planification (statique / dynamique); </li><li>  Copy-On-Write est utilis√© uniquement par les structures de donn√©es qui sont des types de r√©f√©rence se faisant passer pour des structures (String, Array, Set, Dictionary) sous le capot. </li></ul><br>  Il convient de pr√©ciser tout de suite que les objets qui stockent les propri√©t√©s dans la pile sont les plus rapides, n'utilisez pas le comptage de r√©f√©rences avec la m√©thode statique de l'examen m√©dical. <br><h4>  Que les classes sont mauvaises et dangereuses par rapport aux structures </h4><br><br>  Nous ne contr√¥lons pas toujours la copie de nos objets, et si nous le faisons, nous pouvons obtenir trop de copies qui seront difficiles √† g√©rer (nous avons cr√©√© des objets dans le projet qui sont responsables de la formation de la vue, par exemple). <br><br>  Ils ne sont pas aussi rapides que les structures. <br><br>  Si nous avons un lien vers un objet et que nous essayons de contr√¥ler notre application dans un style multi-thread, nous pouvons obtenir la condition de concurrence lorsque notre objet est utilis√© √† partir de deux endroits diff√©rents (et ce n'est pas si difficile, car un projet construit avec Xcode est toujours un peu plus lent, que la version Store). <br><br>  Si nous essayons d'√©viter la condition de course, nous d√©pensons beaucoup de ressources sur Lock et nos donn√©es, ce qui commence √† consommer des ressources et √† perdre du temps au lieu d'un traitement rapide et nous obtenons des objets encore plus lents que les m√™mes construits sur des structures. <br><br>  Si nous faisons toutes les actions ci-dessus sur nos objets (liens), alors la probabilit√© de blocages impr√©vus est √©lev√©e. <br><br>  La complexit√© du code augmente √† cause de cela. <br><br>  Plus de code = plus de bugs, toujours! <br><br><h4>  Conclusions </h4><br>  Je pensais que les conclusions de cet article √©taient simplement n√©cessaires, parce que je ne veux pas lire l'article de temps en temps, et une liste consolid√©e de points est simplement n√©cessaire.  R√©sumant les lignes sous les tests, je veux souligner les points suivants: <br><br><ol><li>  Les tableaux sont mieux plac√©s dans un tableau. </li><li>  Si vous souhaitez cr√©er un tableau √† partir de classes, il est pr√©f√©rable de choisir un tableau r√©gulier, car ContiguousArray fournit rarement des avantages et ils ne sont pas tr√®s √©lev√©s. </li><li>  L'optimisation en ligne acc√©l√®re le travail, ne le d√©sactivez pas. </li><li>  L'acc√®s aux √©l√©ments du tableau est toujours plus rapide que l'acc√®s aux √©l√©ments du ContiguousArray. </li><li>  Les structures sont toujours plus rapides que les classes (√† moins bien s√ªr que vous n'activiez l'optimisation de module entier ou une optimisation similaire). </li><li>  Lorsque vous passez un objet dans une fonction et appelez ses propri√©t√©s, √† partir de la troisi√®me, la structure est plus rapide que les classes. </li><li>  Lorsque vous transmettez une valeur √† une fonction √©crite pour Generic et Protocol, Generic sera plus rapide. </li><li>  Avec l'h√©ritage de plusieurs classes, la vitesse de l'appel de fonction se d√©grade. </li><li>  Les variables ont marqu√© le travail final plus lentement que les poivrons ordinaires. </li><li>  Si une fonction accepte un objet qui combine plusieurs objets avec le protocole, elle fonctionnera rapidement si une seule propri√©t√© y est stock√©e et se d√©gradera consid√©rablement lors de l'ajout de propri√©t√©s. </li></ol><br>  R√©f√©rences: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">developer.apple.com/videos/play/wwdc2016/416</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">developer.apple.com/videos/play/wwdc2015/409</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">developer.apple.com/videos/play/wwdc2016/419</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">medium.com/commencis/stop-using-structs-e1be9a86376f</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tester le code source</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472290/">https://habr.com/ru/post/fr472290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472272/index.html">Un nouveau jeu avec une vieille ambiance sur Three.js. 2e partie</a></li>
<li><a href="../fr472274/index.html">SSH √† distance: conseils et astuces</a></li>
<li><a href="../fr472278/index.html">Mon git commit pr√©f√©r√©</a></li>
<li><a href="../fr472280/index.html">La t√¢che de d√©terminer la pr√©sence d'une paume sur un scanner veineux</a></li>
<li><a href="../fr472288/index.html">9 extensions de navigateur utiles pour les d√©veloppeurs (liste pour 2020)</a></li>
<li><a href="../fr472292/index.html">Blocage de contenu: la sc√®ne mondiale</a></li>
<li><a href="../fr472294/index.html">Cr√©ez des jeux et des vid√©os sur YouTube. Mon exp√©rience d'interaction et les revenus de cette</a></li>
<li><a href="../fr472296/index.html">Syst√®me de protection contre les fuites pour une machine √† laver</a></li>
<li><a href="../fr472298/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 385 (14-20 octobre 2019)</a></li>
<li><a href="../fr472300/index.html">Descente de gradient stochastique (SGD) pour la fonction de perte logarithmique (LogLoss) dans un probl√®me de classification binaire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>