<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÄ üßùüèΩ ‚úåüèª Wir machen Shrimp noch n√ºtzlicher: F√ºgen Sie Bildtranscodierungen zu anderen Formaten hinzu üõµ üî† ü§Ø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit Anfang 2017 entwickelt unser kleines Team die RESTinio OpenSource-Bibliothek zum Einbetten eines HTTP-Servers in C ++ - Anwendungen. Zu unserer g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir machen Shrimp noch n√ºtzlicher: F√ºgen Sie Bildtranscodierungen zu anderen Formaten hinzu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420353/"><img src="https://habrastorage.org/webt/7w/iy/b5/7wiyb5u0fpwa1duglcppwofjloa.jpeg"><br><br>  Seit Anfang 2017 entwickelt unser kleines Team die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RESTinio OpenSource-Bibliothek</a> zum Einbetten eines HTTP-Servers in C ++ - Anwendungen.  Zu unserer gro√üen √úberraschung erhalten wir von Zeit zu Zeit Fragen aus der Kategorie "Und warum ist m√∂glicherweise ein eingebetteter C ++ - HTTP-Server erforderlich?"  Leider sind einfache Fragen am schwierigsten zu beantworten.  Manchmal ist die beste Antwort Beispielcode. <br><br>  Vor ein paar Monaten haben wir mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shrimp</a> ein kleines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Projekt</a> gestartet, das ein typisches Szenario deutlich macht, in dem unsere Bibliothek ‚Äûgesch√§rft‚Äú wird.  Das Demo-Projekt ist ein einfacher Webdienst, der Anforderungen zum Skalieren von auf dem Server gespeicherten Bildern empf√§ngt und ein Bild mit der vom Benutzer ben√∂tigten Gr√∂√üe zur√ºckgibt. <br><br>  Dieses Demo-Projekt ist insofern gut, als es zum einen die Integration mit vor langer Zeit geschriebenem und korrekt funktionierendem Code in C oder C ++ (in diesem Fall ImageMagick) erfordert.  Daher sollte klar sein, warum es sinnvoll ist, den HTTP-Server in eine C ++ - Anwendung einzubetten. <br><br>  Und zweitens ist in diesem Fall eine asynchrone Anforderungsverarbeitung erforderlich, damit der HTTP-Server nicht blockiert, w√§hrend das Image skaliert wird (und dies kann Hunderte von Millisekunden oder sogar Sekunden dauern).  Und wir haben mit der Entwicklung von RESTinio begonnen, gerade weil wir keinen vern√ºnftigen eingebetteten C ++ - Server finden konnten, der speziell auf die asynchrone Anforderungsverarbeitung ausgerichtet ist. <br><br>  Wir haben die Arbeit iterativ auf Shrimp aufgebaut: Zuerst wurde die einfachste Version erstellt und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieben</a> , die nur die Bilder skalierte.  Dann haben wir eine Reihe von M√§ngeln der ersten Version behoben und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies im zweiten Artikel beschrieben</a> .  Schlie√ülich haben wir die Funktionalit√§t von Shrimp noch einmal erweitert: Die Konvertierung von Bildern von einem Format in ein anderes wurde hinzugef√ºgt.  Wie dies gemacht wurde und wird in diesem Artikel besprochen. <br><a name="habracut"></a><br><h1>  Unterst√ºtzung des Zielformats </h1><br>  In der n√§chsten Version von Shrimp haben wir die M√∂glichkeit hinzugef√ºgt, ein skaliertes Bild in einem anderen Format zu erstellen.  Wenn Sie also eine Shrimp-Anfrage des Formulars stellen: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  Dann rendert Shrimp das Bild im gleichen JPG-Format wie das Originalbild. <br><br>  Wenn Sie der URL jedoch den Parameter f√ºr das Zielformat hinzuf√ºgen, konvertiert Shrimp das Bild in das angegebene Zielformat.  Zum Beispiel: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">curl</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920&amp;target-format=webp"</span></span></code> </pre> <br>  In diesem Fall rendert Shrimp das Bild im Webp-Format. <br><br>  Das aktualisierte Shrimp unterst√ºtzt f√ºnf Bildformate: JPG, PNG, GIF, WebP und Heic (auch als HEIF bekannt).  Sie k√∂nnen mit verschiedenen Formaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf einer speziellen Webseite</a> experimentieren: <br><br><img src="https://habrastorage.org/webt/99/ab/ke/99abkec8ode-lxyxufceqjmwxt8.png"><br><br>  (Auf dieser Seite gibt es keine M√∂glichkeit, das heic-Format auszuw√§hlen, da normale Desktop-Browser dieses Format standardm√§√üig nicht unterst√ºtzen.) <br><br>  Um das Zielformat in Shrimp zu unterst√ºtzen, musste der Shrimp-Code leicht ge√§ndert werden (was uns selbst √ºberraschte, da es wirklich nur wenige √Ñnderungen gab).  Andererseits musste ich mit der Assembly von ImageMagick spielen, von der wir noch mehr √ºberrascht waren  Fr√ºher mussten wir uns durch einen gl√ºcklichen Zufall mit dieser K√ºche befassen.  Aber reden wir √ºber alles in Ordnung. <br><br><h2>  ImageMagick muss verschiedene Formate verstehen </h2><br>  ImageMagick verwendet externe Bibliotheken zum Codieren / Decodieren von Bildern: libjpeg, libpng, libgif usw.  Diese Bibliotheken m√ºssen auf dem System installiert sein, bevor ImageMagick konfiguriert und erstellt wird. <br><br>  Dasselbe sollte passieren, damit ImageMagick die Formate webp und heic unterst√ºtzt: Zuerst m√ºssen Sie libwebp und libheif erstellen und installieren, dann ImageMagick konfigurieren und installieren.  Und wenn mit libwebp alles einfach ist, dann musste ich um libheif mit einem Tamburin tanzen.  Obwohl nach einiger Zeit, nachdem sich alles endlich versammelt und funktioniert hatte, bereits nicht klar war: Warum mussten Sie auf ein Tamburin zur√ºckgreifen, scheint alles trivial zu sein?  ;) <br><br>  Wenn sich jemand mit heic und ImageMagick anfreunden m√∂chte, m√ºssen Sie im Allgemeinen Folgendes installieren: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x265 von videolan.org</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libde265</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libheif</a> </li></ul><br>  Es ist in dieser Reihenfolge (m√∂glicherweise m√ºssen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nasm</a> installieren, damit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x265</a> mit maximaler Geschwindigkeit funktioniert).  Wenn Sie dann den Befehl <i>./configure</i> ausgeben, kann ImageMagick alles finden, was zur Unterst√ºtzung von .heic-Dateien erforderlich ist. <br><br><h2>  Unterst√ºtzung f√ºr das Zielformat in der Abfragezeichenfolge eingehender Anforderungen </h2><br>  Nachdem wir ImageMagick mit den Formaten webp und heic befreundet haben, ist es Zeit, den Shrimp-Code zu √§ndern.  Zun√§chst m√ºssen wir lernen, wie das Zielformatargument in eingehenden HTTP-Anforderungen erkannt wird. <br><br>  Aus Sicht von RESTinio ist dies √ºberhaupt kein Problem.  Nun, ein weiteres Argument erschien in der Abfragezeichenfolge, na und?  Aus Sicht von Shrimp stellte sich die Situation jedoch als etwas komplizierter heraus, sodass der Code der Funktion, die f√ºr das Parsen der HTTP-Anforderung verantwortlich war, komplizierter wurde. <br><br>  Tatsache ist, dass es zuvor notwendig war, nur zwei Situationen zu unterscheiden: <br><br><ul><li>  Es kam eine Anfrage der Form "/filename.ext" ohne weitere Parameter.  Sie m√ºssen also nur die Datei "filename.ext" so wie sie ist angeben. </li><li>  Eine Anfrage kam in der Form "/filename.ext?op=resize &amp; ...".  In diesem Fall m√ºssen Sie das Bild aus der Datei "filename.ext" skalieren. </li></ul><br>  Nach dem Hinzuf√ºgen des Zielformats m√ºssen wir jedoch zwischen vier Situationen unterscheiden: <br><br><ul><li>  Es kam eine Anfrage der Form "/filename.ext" ohne weitere Parameter.  Sie m√ºssen also nur die Datei "filename.ext" so wie sie ist angeben, ohne Skalierung und ohne Transcodierung in ein anderes Format. </li><li>  Es kam eine Anfrage der Form "/filename.ext?target-format=fmt" ohne weitere Parameter.  Es bedeutet, ein Bild aus der Datei "filename.ext" zu nehmen und es in das Format "fmt" zu transkodieren, wobei die Originalgr√∂√üen beibehalten werden. </li><li>  Eine Anfrage kam in der Form "/filename.ext?op=resize &amp; ...", jedoch ohne Zielformat.  In diesem Fall m√ºssen Sie das Bild aus der Datei ‚Äûfilename.ext‚Äú skalieren und im Originalformat angeben. </li><li>  Eine Anfrage kam von der Form "/filename.ext?op=resize&amp;...&amp;target-format=fmt".  In diesem Fall m√ºssen Sie eine Skalierung durchf√ºhren und das Ergebnis dann in das Format ‚Äûfmt‚Äú umcodieren. </li></ul><br>  Infolgedessen hatte die Funktion zum Bestimmen der Abfrageparameter die <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">folgende Form</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> add_transform_op_handler( const app_params_t &amp; app_params, http_req_router_t &amp; router, so_5::mbox_t req_handler_mbox ) { router.http_get( R"(/:path(.*)\.:ext(.{3,4}))", restinio::path2regex::options_t{}.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ), [req_handler_mbox, &amp;app_params]( auto req, auto params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path() ) ) { //     . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } //   . const auto qp = restinio::parse_query( req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query() ); const auto target_format = qp.get_param( "target-format"sv ); //        // .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>,    //   .   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>  // ,    ,  //    . const auto image_format = try_detect_target_image_format( params[ "ext" ], target_format ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !image_format ) { //     .   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !qp.size() ) { //    ,    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ), *image_format ); } const auto operation = qp.get_param( "op"sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( operation &amp;&amp; "resize"sv != *operation ) { //    ,     resize. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !operation &amp;&amp; !target_format ) { //      op=resize, //   target-<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=something. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); } handle_resize_op_request( req_handler_mbox, *image_format, qp, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  In der vorherigen Version von Shrimp, in der Sie das Bild nicht transkodieren mussten, sah das Arbeiten mit den Anforderungsparametern <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/3e8beeeb8935f84e492af188dd6fc6f2ba785657/dev/shrimp/">etwas einfacher aus</a> . <br><br><h2>  Anforderungswarteschlange und Bildcache auf das Zielformat zugeschnitten </h2><br>  Der n√§chste Punkt bei der Implementierung der Unterst√ºtzung f√ºr das Zielformat war die Arbeit an der Warteschlange f√ºr wartende Anforderungen und einem Cache mit vorgefertigten Bildern im Agenten a_transform_manager.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im vorherigen Artikel</a> ausf√ºhrlicher √ºber diese Dinge gesprochen, aber wir m√∂chten Sie ein wenig daran erinnern, worum es ging. <br><br>  Wenn eine Anforderung zur Bildkonvertierung eintrifft, kann sich herausstellen, dass sich das fertige Bild mit solchen Parametern bereits im Cache befindet.  In diesem Fall m√ºssen Sie nichts tun, sondern nur das Bild als Antwort aus dem Cache senden.  Wenn das Bild transformiert werden muss, stellt sich m√∂glicherweise heraus, dass derzeit keine freien Mitarbeiter vorhanden sind und Sie warten m√ºssen, bis es angezeigt wird.  Dazu m√ºssen Anforderungsinformationen in die Warteschlange gestellt werden.  Gleichzeitig ist es jedoch erforderlich, die Eindeutigkeit der Anforderungen zu √ºberpr√ºfen. Wenn drei identische Anforderungen auf die Verarbeitung warten (d. H. Dass dasselbe Bild auf dieselbe Weise konvertiert werden muss), sollten wir das Bild nur einmal verarbeiten und das Ergebnis der Verarbeitung als Antwort angeben zu diesen drei Anfragen.  Das hei√üt,  In der Warteschlange m√ºssen identische Anforderungen gruppiert werden. <br><br>  Fr√ºher in Shrimp haben wir einen einfachen zusammengesetzten Schl√ºssel verwendet, um den Bildcache und die Warteschlange zu durchsuchen: eine <a href="">Kombination aus dem urspr√ºnglichen Dateinamen</a> und den <a href="">Optionen zur Gr√∂√üen√§nderung von Bildern</a> .  Nun mussten zwei neue Faktoren ber√ºcksichtigt werden: <br><br><ul><li>  erstens das Zielbildformat (d. h. das Originalbild kann in jpg sein und das resultierende Bild kann in png sein); </li><li>  zweitens die Tatsache, dass eine Skalierung des Bildes m√∂glicherweise nicht erforderlich ist.  Dies geschieht in einer Situation, in der der Client nur die Konvertierung des Bildes von einem Format in ein anderes anordnet, wobei jedoch die Originalgr√∂√üe des Bildes erhalten bleibt. </li></ul><br>  Ich muss sagen, dass wir hier den einfachsten Weg gegangen sind, ohne irgendwie etwas zu optimieren.  Beispielsweise k√∂nnte man versuchen, zwei Caches zu erstellen: Einer w√ºrde Bilder im Originalformat speichern, aber auf die gew√ºnschte Gr√∂√üe skalieren, und im zweiten Fall w√ºrden die skalierten Bilder in das Zielformat konvertiert. <br><br>  Warum sollte ein solches doppeltes Caching erforderlich sein?  Tatsache ist, dass beim Transformieren von Bildern die zwei teuersten Vorg√§nge in der Zeit die Gr√∂√üen√§nderung und Serialisierung des Bilds in das Zielformat sind.  Wenn wir daher die Anforderung erhalten, das Bild example.jpg auf eine Gr√∂√üe von 1920 in der Breite zu skalieren und in das Webp-Format umzuwandeln, k√∂nnen wir zwei Bilder in unserem Speicher speichern: example_1920px_width.jpg und example_1920px_width.webp.  Wir w√ºrden ein Beispiel_1920px_width.webp Bild geben, wenn wir eine zweite Anfrage erhalten.  Das Bild example_1920px_width.jpg kann jedoch verwendet werden, wenn Anforderungen zum Skalieren von example.jpg auf eine Gr√∂√üe von 1920 in der Breite empfangen und in ein heic-Format umgewandelt werden.  Wir k√∂nnten den Gr√∂√üen√§nderungsvorgang √ºberspringen und nur die Formatkonvertierung durchf√ºhren (d. H. Das fertige Bild example_1920px_width.jpg w√ºrde in das heic-Format transkodiert). <br><br>  Eine weitere potenzielle M√∂glichkeit: Wenn eine Anforderung zum Umcodieren eines Bilds in ein anderes Format ohne Gr√∂√üen√§nderung eingeht, k√∂nnen Sie die tats√§chliche Gr√∂√üe des Bildes bestimmen und diese Gr√∂√üe im zusammengesetzten Schl√ºssel verwenden.  Beispiel: Beispiel.jpg hat eine Gr√∂√üe von 3000 x 2000 Pixel.  Wenn wir als n√§chstes eine Anfrage zur Skalierung von example.jpg auf 2000px H√∂he erhalten, k√∂nnen wir sofort feststellen, dass wir bereits ein Bild in dieser Gr√∂√üe haben. <br><br>  Theoretisch verdienen all diese √úberlegungen Beachtung.  Aus praktischer Sicht ist jedoch nicht klar, wie hoch die Wahrscheinlichkeit einer solchen Entwicklung von Ereignissen ist.  Das hei√üt,  Wie oft erhalten wir eine Anfrage zur Skalierung von example.jpg auf 1920px mit Konvertierung in webp und dann eine Anfrage nach derselben Skalierung desselben Bildes, jedoch mit Konvertierung in png?  Es ist schwer zu sagen, keine wirklichen Statistiken zu haben.  Aus diesem Grund haben wir uns entschlossen, unser Leben in unserem Demo-Projekt nicht zu verkomplizieren, sondern zun√§chst den einfachsten Weg zu gehen.  Mit der Erwartung, dass, wenn jemand fortgeschrittenere Caching-Schemata ben√∂tigt, diese sp√§ter hinzugef√ºgt werden k√∂nnen, ausgehend von realen, nicht fiktiven Szenarien f√ºr die Verwendung von Shrimp. <br><br>  Infolgedessen haben wir in der aktualisierten Version von Shrimp den Schl√ºssel leicht erweitert und ihm auch einen Parameter wie das Zielformat hinzugef√ºgt: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_key_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_path; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_format; <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format, <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_path{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(path) } , m_format{ format } , m_params{ params } {} [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> &amp; o ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( m_path, m_format, m_params ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie( o.m_path, o.m_format, o.m_params ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_path; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> format() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_format; } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_params; } };</code> </pre> <br>  Das hei√üt,  Die Anforderung zur Gr√∂√üen√§nderung von example.jpg bis 1920px mit Konvertierung in PNG unterscheidet sich von der gleichen Gr√∂√üen√§nderung, jedoch mit der Konvertierung in WebP oder Heic. <br><br>  Das Hauptaugenmerk liegt jedoch <a href="">auf der neuen Implementierung der Klasse resize_params_t</a> , die die neuen Gr√∂√üen des skalierten Bildes bestimmt.  <a href="">Bisher unterst√ºtzte diese Klasse</a> drei Optionen: Nur die Breite wurde festgelegt, nur die H√∂he wurde festgelegt oder die lange Seite wurde festgelegt (die H√∂he oder Breite wird durch die aktuelle Bildgr√∂√üe bestimmt).  Dementsprechend hat die Methode <a href="">resize_params_t :: value ()</a> immer einen realen Wert zur√ºckgegeben (welcher Wert wurde durch die Methode <a href="">resize_params_t :: mode ()</a> bestimmt). <br><br>  Im neuen Shrimp wurde jedoch ein weiterer Modus hinzugef√ºgt - keep_original. Dies bedeutet, dass keine Skalierung durchgef√ºhrt wird und das Bild in seiner urspr√ºnglichen Gr√∂√üe gerendert wird.  Um diesen Modus zu unterst√ºtzen, musste resize_params_t einige √Ñnderungen vornehmen.  Zun√§chst bestimmt jetzt die Methode <a href="">resize_params_t :: make ()</a> , ob der keep_original-Modus verwendet wird (es wird davon ausgegangen, dass dieser Modus verwendet wird, wenn keiner der Parameter width, height und max in der Abfragezeichenfolge der eingehenden Anforderung angegeben ist).  Dadurch konnten wir die Funktion <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">handle_resize_op_request ()</a> nicht neu <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">schreiben</a> , wodurch die Anforderung zum Skalieren des <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/4049abf4ca148fb0d291239b28135315d5f4053f/dev/shrimp/">auszuf√ºhrenden</a> Bildes weitergeleitet wird. <br><br>  Zweitens kann die Methode <a href="">resize_params_t :: value ()</a> jetzt nicht immer aufgerufen werden, sondern nur, wenn sich der Skalierungsmodus von keep_original unterscheidet. <br><br>  Das Wichtigste ist jedoch, dass <a href="">resize_params_t :: operator &lt;()</a> weiterhin wie beabsichtigt funktioniert. <br><br>  Dank all dieser √Ñnderungen im a_transform_manager sind sowohl der skalierte Bildcache als auch die Warteschlange der wartenden Anforderungen gleich geblieben.  In diesen Datenstrukturen werden nun Informationen zu verschiedenen Abfragen gespeichert.  Der Schl√ºssel {"example.jpg", "jpg", keep_original} unterscheidet sich also sowohl vom Schl√ºssel {"example.jpg", "png", keep_original} als auch vom Schl√ºssel {"example.jpg", "jpg", width = 1920px}. <br><br>  Es stellte sich heraus, dass wir, nachdem wir die Definition so einfacher Datenstrukturen wie resize_params_t und resize_params_key_t ein wenig verdorben hatten, es vermieden haben, komplexere Strukturen wie den Cache der resultierenden Bilder und die Warteschlange wartender Anforderungen zu √§ndern. <br><br><h2>  Unterst√ºtzung f√ºr das Zielformat in a_transformer </h2><br>  Nun, der letzte Schritt zur Unterst√ºtzung des Zielformats besteht darin, die Logik des Agenten a_transformer zu erweitern, sodass das m√∂glicherweise bereits skalierte Bild dann in das Zielformat konvertiert wird. <br><br>  Es stellte sich heraus, dass dies am einfachsten war. Sie mussten <a href="">lediglich</a> den Code der Methode <a href="">a_transform_t :: handle_resize_request () erweitern</a> : <br><br><pre> <code class="hljs pgsql">[[nodiscard]] a_transform_manager_t::resize_result_t::result_t a_transformer_t::handle_resize_request( const <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_request_key_t &amp; key ) { try { m_logger-&gt;trace( "transformation started; request_key={}", key ); auto image = load_image( key.path() ); const auto resize_duration = measure_duration( [&amp;]{ //       //    keep_original. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize_params_t::mode_t::keep_original != key.params().mode() ) { <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>::resize( key.params(), total_pixel_count, image ); } } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "resize finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( resize_duration).count() ); image.magick( magick_from_image_format( key.format() ) ); datasizable_blob_shared_ptr_t blob; const auto serialize_duration = measure_duration( [&amp;] { blob = make_blob( image ); } ); m_logger-&gt;<span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>( "serialization finished; request_key={}, time={}ms", key, std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;( serialize_duration).count() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::successful_resize_t{ std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(blob), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( resize_duration), std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( serialize_duration) }; } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; x ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a_transform_manager_t::failed_resize_t{ x.what() }; } }</code> </pre> <br>  Im Vergleich <a href="">zur Vorg√§ngerversion</a> gibt es zwei grundlegende Erg√§nzungen. <br><br>  Rufen Sie zun√§chst die wirklich magische image.magick () -Methode nach der Gr√∂√üen√§nderung auf.  Diese Methode teilt ImageMagick das resultierende Bildformat mit.  Gleichzeitig √§ndert sich die Darstellung des Bildes im Speicher nicht - ImageMagick speichert es weiterhin so, wie es ihm passt.  Der von der magick () -Methode festgelegte Wert wird dann beim nachfolgenden Aufruf von Image :: write () ber√ºcksichtigt. <br><br>  Zweitens zeichnet die aktualisierte Version die Zeit auf, die zum Serialisieren des Bildes in das angegebene Format ben√∂tigt wird.  Die neue Version von Shrimp legt jetzt die f√ºr die Skalierung aufgewendete Zeit und die f√ºr die Konvertierung in das Zielformat aufgewendete Zeit separat fest. <br><br>  Der Rest des Agenten a_transformer_t hat keine √Ñnderungen erfahren. <br><br><h1>  ImageMagick-Parallelisierung </h1><br>  Standardm√§√üig wird ImageMagic mit OpenMP-Unterst√ºtzung erstellt.  Das hei√üt,  Es ist m√∂glich, Operationen an Bildern, die ImageMagick ausf√ºhrt, zu parallelisieren.  Sie k√∂nnen die Anzahl der Workflows, die ImageMagick in diesem Fall verwendet, mithilfe der Umgebungsvariablen MAGICK_THREAD_LIMIT steuern. <br><br>  Auf meinem Testger√§t mit dem Wert MAGICK_THREAD_LIMIT = 1 (d. H. Ohne echte Parallelisierung) erhalte ich beispielsweise die folgenden Ergebnisse: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1323</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">1086.72</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">236.276</span></span></code> </pre><br>  Die f√ºr die Gr√∂√üen√§nderung aufgewendete Zeit wird im Header Shrimp-Resize-Time angegeben.  In diesem Fall sind es 1086,72 ms. <br><br>  Wenn Sie jedoch MAGICK_THREAD_LIMIT = 3 auf demselben Computer festlegen und Shrimp ausf√ºhren, erhalten wir unterschiedliche Werte: <br><br><pre> <code class="hljs powershell">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/DSC08084.jpg?op=resize&amp;max=2400"</span></span> <span class="hljs-literal"><span class="hljs-literal">-v</span></span> &gt; /dev/null &gt; GET /DSC08084.jpg?op=resize&amp;max=<span class="hljs-number"><span class="hljs-number">2400</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> &gt; Host: localhost:<span class="hljs-number"><span class="hljs-number">8080</span></span> &gt; User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: curl/<span class="hljs-number"><span class="hljs-number">7.47</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; Accept: */* &gt; &lt; HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK &lt; Connection: keep<span class="hljs-literal"><span class="hljs-literal">-alive</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">2043917</span></span> &lt; Server: Shrimp draft server &lt; Date: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Last<span class="hljs-literal"><span class="hljs-literal">-Modified</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">15</span></span> Aug <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> GMT &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Allow</span></span><span class="hljs-literal"><span class="hljs-literal">-Origin</span></span>: * &lt; Access<span class="hljs-literal"><span class="hljs-literal">-Control</span></span><span class="hljs-literal"><span class="hljs-literal">-Expose</span></span><span class="hljs-literal"><span class="hljs-literal">-Headers</span></span>: Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>, Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span> &lt; Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: image/jpeg &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Image</span></span><span class="hljs-literal"><span class="hljs-literal">-Src</span></span>: transform &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Processing</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">779.901</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Resize</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">558.246</span></span> &lt; Shrimp<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span><span class="hljs-literal"><span class="hljs-literal">-Time</span></span>: <span class="hljs-number"><span class="hljs-number">221.655</span></span></code> </pre> <br>  Das hei√üt,  Die Gr√∂√üen√§nderungszeit wurde auf 558,25 ms reduziert. <br><br>  Da ImageMagick die M√∂glichkeit bietet, Berechnungen zu parallelisieren, k√∂nnen Sie diese M√∂glichkeit nutzen.  Gleichzeitig ist es jedoch w√ºnschenswert zu steuern, wie viele Arbeitsf√§den Shrimp f√ºr sich selbst ben√∂tigt.  In fr√ºheren Versionen von Shrimp konnte nicht beeinflusst werden, wie viele Workflows Shrimp erstellt.  In der aktualisierten Version von Shrimp ist dies m√∂glich.  Oder √ºber Umgebungsvariablen, zum Beispiel: <br><br><pre> <code class="hljs tex">SHRIMP_IO_THREADS=1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>SHRIMP_WORKER_THREADS=3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MAGICK_THREAD_LIMIT=4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>shrimp.app -p 8080 -i ...</code> </pre> <br>  Oder √ºber Befehlszeilenargumente, zum Beispiel: <br><br><pre> <code class="hljs powershell">MAGICK_THREAD_LIMIT=<span class="hljs-number"><span class="hljs-number">4</span></span> \ shrimp.app <span class="hljs-literal"><span class="hljs-literal">-p</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-literal"><span class="hljs-literal">-i</span></span> ... -<span class="hljs-literal"><span class="hljs-literal">-io</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-literal"><span class="hljs-literal">-worker</span></span><span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  √úber die Befehlszeile angegebene Werte haben eine h√∂here Priorit√§t. <br><br>  Es sollte betont werden, dass MAGICK_THREAD_LIMIT nur die Operationen betrifft, die ImageMagick selbst ausf√ºhrt.  Die Gr√∂√üen√§nderung erfolgt beispielsweise √ºber ImageMagick.  Die Konvertierung von einem Format in ein anderes ImageMagick wird jedoch an externe Bibliotheken delegiert.  Und wie Operationen in diesen externen Bibliotheken parallelisiert werden, ist ein separates Problem, das wir nicht verstanden haben. <br><br><h1>  Fazit </h1><br>  Vielleicht haben wir in dieser Version von Shrimp unser Demo-Projekt in einen akzeptablen Zustand gebracht.  Wer sehen und experimentieren m√∂chte, findet die Ausgangstexte von Shrimp auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BitBucket</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> .  Dort finden Sie auch die Docker-Datei, mit der Sie Shrimp f√ºr Ihre Experimente erstellen k√∂nnen. <br><br>  Im Allgemeinen haben wir unsere Ziele erreicht, die wir uns mit dem Start dieses Demo-Projekts gesetzt haben.  Eine Reihe von Ideen f√ºr die Weiterentwicklung von RESTinio und SObjectizer sind aufgetaucht, und einige von ihnen haben bereits ihre Verk√∂rperung gefunden.  Ob sich Shrimp irgendwo weiterentwickeln wird, h√§ngt daher vollst√§ndig von Fragen und W√ºnschen ab.  Wenn ja, kann sich Shrimp ausdehnen.  Wenn nicht, bleibt Shrimp ein Demo-Projekt und ein √úbungsfeld f√ºr das Experimentieren mit neuen Versionen von RESTinio und SObjectizer. <br><br>  Abschlie√üend m√∂chte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Aensidhe meinen</a> besonderen Dank f√ºr ihre Hilfe und ihren Rat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">aussprechen</a> , ohne die unsere T√§nze mit einem Tamburin viel l√§nger und trauriger w√§ren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420353/">https://habr.com/ru/post/de420353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420343/index.html">LED-Lampen OK</a></li>
<li><a href="../de420345/index.html">IXcellerate Rechenzentrums√ºbersicht (der gr√∂√üte Maschinenraum in der Russischen F√∂deration)</a></li>
<li><a href="../de420347/index.html">Erfahren Sie, wie Sie in weniger als 4 Minuten Ihre eigenen Bash-Befehle erstellen</a></li>
<li><a href="../de420349/index.html">IT-Outsourcing-Checkliste: Arbeiten ohne Risiken</a></li>
<li><a href="../de420351/index.html">So f√ºhren Sie Benutzersuchen auf GitHub mit Vue durch</a></li>
<li><a href="../de420355/index.html">Smart Watch Pebble: Wie man √ºber Nacht zur Seltenheit wird</a></li>
<li><a href="../de420357/index.html">Vuex: Strukturierung gro√üer Projekte und Arbeiten mit Modulen</a></li>
<li><a href="../de420359/index.html">Var, let oder const? Variable Scope Issues und ES6</a></li>
<li><a href="../de420361/index.html">Fehler beim Ausf√ºhren von TextBox.GetLineText in .NET WPF</a></li>
<li><a href="../de420363/index.html">HPE-Webinare von August bis Oktober: Neue Themen (+ SHD, KI-Praxis, schl√ºsselfertiger Petabyte-Speicher)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>