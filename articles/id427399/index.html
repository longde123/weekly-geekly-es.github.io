<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏿 💞 👁‍🗨 Bekerja dengan data saat membangun API berdasarkan GraphQL ✒️ 👩🏻‍🤝‍👨🏾 🍀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembukaan 


 Pertama-tama, artikel ini dirancang untuk pembaca yang sudah terbiasa dengan GraphQL dan lebih banyak tentang seluk-beluk dan nuansa bek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekerja dengan data saat membangun API berdasarkan GraphQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427399/"><h3 id="preambula">  Pembukaan </h3><br><p>  Pertama-tama, artikel ini dirancang untuk pembaca yang sudah terbiasa dengan GraphQL dan lebih banyak tentang seluk-beluk dan nuansa bekerja dengannya.  Meskipun demikian, saya berharap ini akan bermanfaat bagi pemula. </p><br><p>  GraphQL adalah alat yang hebat.  Saya pikir banyak orang sudah tahu dan mengerti kelebihannya.  Namun, ada beberapa nuansa yang harus diperhatikan ketika membangun API berbasis GraphQL Anda. </p><br><p> Misalnya, GraphQL memungkinkan Anda untuk kembali ke konsumen (pengguna atau program) yang meminta data hanya bagian yang diminati konsumen ini.  Namun demikian, ketika membangun server cukup mudah untuk membuat kesalahan, yang mengarah pada fakta bahwa di dalam server (yang dapat, antara lain, didistribusikan), data akan berjalan dalam "bundel" penuh.  Hal ini terutama disebabkan oleh kenyataan bahwa GraphQL sendiri tidak menyediakan alat yang mudah untuk mem-parsing permintaan yang masuk, dan antarmuka yang diletakkan di dalamnya tidak didokumentasikan dengan baik. </p><a name="habracut"></a><br><h3 id="istochnik-problemy">  Sumber masalah </h3><br><p>  Mari kita lihat contoh khas dari implementasi yang tidak optimal (buka gambar di jendela terpisah jika kurang dibaca): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/497/409/cb6/497409cb638a09186c79f0c60e49154c.png" alt="gambar"></p><br><p>  Misalkan konsumen kita adalah aplikasi atau komponen tertentu dari "buku telepon" yang meminta dari API kita hanya pengidentifikasi, nama, dan nomor telepon pengguna yang disimpan oleh kita.  Pada saat yang sama, API kami jauh lebih luas, itu akan memungkinkan akses ke data lain, seperti alamat fisik tempat tinggal dan alamat email pengguna. </p><br><p>  Pada titik pertukaran data antara konsumen dan API, GraphQL dengan sempurna melakukan semua pekerjaan yang kita butuhkan - hanya data yang diminta akan dikirim sebagai tanggapan atas permintaan tersebut.  Masalah dalam hal ini adalah pada titik pengambilan sampel data dari database - yaitu  dalam implementasi internal server kami, dan itu terdiri atas fakta bahwa untuk setiap permintaan yang masuk kami memilih semua data pengguna dari basis data, terlepas dari kenyataan bahwa kami tidak memerlukan sebagian dari mereka.  Ini menghasilkan beban berlebihan pada database dan menyebabkan sirkulasi lalu lintas yang berlebihan dalam sistem.  Dengan sejumlah besar kueri, Anda bisa mendapatkan optimasi yang signifikan dengan mengubah pendekatan pengambilan sampel data dan memilih hanya bidang yang diminta.  Pada saat yang sama, sama sekali tidak masalah sumber data kami - basis data relasional, teknologi NoSQL, atau layanan lain (internal atau eksternal).  Perilaku tidak optimal dapat dipengaruhi oleh implementasi apa pun.  MySQL dalam hal ini dipilih hanya sebagai contoh. </p><br><h3 id="reshenie">  Solusi </h3><br><p> Dimungkinkan untuk mengoptimalkan perilaku server ini jika kami menganalisis argumen yang datang ke fungsi <code>resolve()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> resolve(source, args, context, info) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Ini adalah argumen terakhir, <code>info</code> , yang menarik bagi kami, dalam hal ini.  Kami beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dan menganalisis secara detail apa fungsi <code>resolve()</code> dan argumen yang kami minati terdiri dari: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLFieldResolveFn</span></span></span><span class="hljs-class"> = ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">?: {[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">argName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">}, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">?: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLResolveInfo</span></span></span><span class="hljs-class"> ) =&gt; any </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLResolveInfo</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldNodes</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Array</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">returnType</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLOutputType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parentType</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLCompositeType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schema</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLSchema</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fragments</span></span></span><span class="hljs-class">: { [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fragmentName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FragmentDefinition</span></span></span><span class="hljs-class"> }, rootValue: any, operation: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OperationDefinition</span></span></span><span class="hljs-class">, variableValues: { [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variableName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class"> }, }</span></span></code> </pre> <br><p>  Jadi, tiga argumen pertama yang diteruskan ke resolver adalah <code>source</code> - data yang dikirimkan dari simpul induk dalam pohon GraphQL skema, <code>args</code> - argumen permintaan (yang berasal dari permintaan), dan <code>context</code> - objek konteks eksekusi yang ditentukan pengembang, sering dipanggil untuk mengirimkan beberapa data global di "resolvers."  Dan akhirnya, argumen keempat adalah informasi meta tentang permintaan tersebut. </p><br><p>  Apa yang bisa kita ekstrak dari <code>GraphQLResolveInfo</code> untuk menyelesaikan masalah kita? </p><br><p>  Bagian yang paling menarik adalah: </p><br><ul><li>  <code>fieldName</code> adalah nama bidang saat ini dari skema GraphQL mereka.  Yaitu  itu sesuai dengan nama bidang yang ditentukan dalam skema untuk resolver ini.  Jika kami menangkap objek <code>info</code> di bidang <code>users</code> , seperti dalam contoh kami di atas, maka "pengguna" yang akan dimuat sebagai nilai <code>fieldName</code> </li><li>  <code>fieldNodes</code> - koleksi (array) node yang DIMINTA dalam kueri.  Apa yang dibutuhkan! </li><li>  <code>fragments</code> - kumpulan fragmen permintaan (jika permintaan itu terpecah-pecah).  Juga informasi penting untuk mengambil bidang data akhir. </li></ul><br><p>  Jadi, sebagai solusi, kita perlu mengurai alat <code>info</code> dan memilih daftar bidang yang datang kepada kita dari kueri, dan kemudian meneruskannya ke kueri SQL.  Sayangnya, paket GraphQL dari Facebook "out of the box" tidak memberi kami apa pun untuk menyederhanakan tugas ini.  Secara keseluruhan, seperti yang telah ditunjukkan oleh praktik, tugas ini tidak sepele, mengingat fakta bahwa permintaan dapat terpecah-pecah.  Dan selain itu, analisis semacam itu memiliki solusi universal, yang kemudian disalin dari proyek ke proyek. </p><br><p>  Jadi saya memutuskan untuk menulisnya sebagai pustaka sumber terbuka di bawah lisensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ISC</a> .  Dengan bantuannya, solusi untuk mem-parsing bidang permintaan masuk diselesaikan dengan cukup sederhana, misalnya, dalam kasus kami seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsList } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'graphql-fields-list'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... async resolve(source, args, context, info) { const requestedFields = fieldsList(info); return await database.query(`SELECT ${requestedFields.join(',')} FROM users`) }</span></span></code> </pre> <br><p>  <code>fieldsList(info)</code> dalam hal ini melakukan semua pekerjaan untuk kami dan mengembalikan array "flat" bidang anak untuk resolver ini, mis.  Kueri SQL final kami akan terlihat seperti ini: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, phone <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  Jika kami mengubah permintaan masuk ke: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UserListQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name phone email } }</code> </pre> <br><p>  maka query SQL akan berubah menjadi: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, phone, email <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  Namun, itu tidak selalu mungkin dilakukan dengan tantangan sederhana.  Seringkali, aplikasi nyata dalam struktur jauh lebih kompleks.  Dalam beberapa implementasi, kita mungkin perlu menggambarkan resolver di tingkat atas sehubungan dengan data dalam skema GraphQL akhir.  Misalnya, jika kami memutuskan untuk menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Relay</a> , kami ingin menggunakan mekanisme yang sudah jadi untuk memecah koleksi objek data ke halaman, yang mengarah pada fakta bahwa skema GraphQL kami akan dibangun sesuai dengan aturan tertentu.  Misalnya, kami mengerjakan ulang skema kami dengan cara ini (TypeScript): </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { GraphQLObjectType, GraphQLSchema, GraphQLString } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connectionDefinitions, connectionArgs, nodeDefinitions, fromGlobalId, globalIdField, connectionFromArray, GraphQLResolveInfo, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-relay'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { fieldsList } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-fields-list'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { nodeInterface, nodeField } = nodeDefinitions(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (globalId: string) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type, id } = fromGlobalId(globalId); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node: any = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type === <span class="hljs-string"><span class="hljs-string">'User'</span></span>) { node = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> database.select(<span class="hljs-string"><span class="hljs-string">`SELECT id FROM user WHERE id="</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">"`</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLObjectType({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-attr"><span class="hljs-attr">interfaces</span></span>: [nodeInterface], <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: globalIdField(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, (user: any) =&gt; user.id), <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, } }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">connectionType</span></span>: userConnection } = connectionDefinitions({ <span class="hljs-attr"><span class="hljs-attr">nodeType</span></span>: User }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLObjectType({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Query'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">node</span></span>: nodeField, <span class="hljs-attr"><span class="hljs-attr">users</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: userConnection, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: { ...connectionArgs }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> resolve( source: any, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: {[argName: string]: any}, <span class="hljs-attr"><span class="hljs-attr">context</span></span>: any, <span class="hljs-attr"><span class="hljs-attr">info</span></span>: GraphQLResolveInfo, ) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement }, }, }); export const schema = new GraphQLSchema({ query: Query });</span></span></code> </pre> <br><p>  Dalam kasus ini, <code>connectionDefinition</code> dari Relay akan menambahkan <code>edges</code> , <code>node</code> , <code>pageInfo</code> dan <code>cursor</code> nodes ke dalam skema, mis.  kita sekarang perlu membangun kembali kueri kita secara berbeda (kita tidak akan membahas pagination sekarang): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UserListQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-section"><span class="hljs-section">edges</span></span> { <span class="hljs-section"><span class="hljs-section">node</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name phone email } } } }</code> </pre> <br><p>  Jadi, <code>resolve()</code> fungsi yang diterapkan pada simpul <code>users</code> sekarang harus menentukan bidang mana yang diminta bukan untuk dirinya sendiri, tetapi untuk simpul <code>node</code> anak bersarangnya, yang, seperti yang kita lihat, relatif terhadap <code>users</code> sepanjang <code>edges.node</code> path. </p><br><p>  <code>fieldsList</code> dari <code>graphql-fields-list</code> akan membantu menyelesaikan masalah ini, untuk ini Anda harus meneruskan opsi <code>path</code> sesuai dengannya.  Sebagai contoh, berikut adalah implementasinya dalam kasus kami: </p><br><pre> <code class="hljs pgsql">async resolve( source: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, args: {[argName: string]: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>}, context: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: GraphQLResolveInfo, ) { const fields = fieldsList(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'edges.node'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectionFromArray( await <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.query(`<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ${fields.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">','</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users`), args ); }</code> </pre> <br><p>  Juga di dunia nyata, mungkin dalam skema GraphQL kami hanya menetapkan satu nama bidang, dan dalam skema database, nama bidang lainnya sesuai dengan mereka.  Misalnya, anggap tabel pengguna dalam database didefinisikan secara berbeda: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> AUTO_INCREMENT, fullName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), email <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), phoneNumber <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>), address <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) );</code> </pre> <br><p>  Dalam kasus ini, bidang dari kueri GraphQL harus diganti namanya sebelum disematkan dalam kueri SQL.  <code>fieldsList</code> akan membantu dalam hal ini jika Anda melewatinya peta terjemahan nama dalam opsi <code>transform</code> sesuai: </p><br><pre> <code class="hljs pgsql">async resolve( source: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, args: {[argName: string]: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>}, context: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: GraphQLResolveInfo, ) { const fields = fieldsList(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'edges.node'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>: { phone: <span class="hljs-string"><span class="hljs-string">'phoneNumber'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'fullName'</span></span> }, }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectionFromArray( await <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.query(`<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ${fields.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">','</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users`), args ); }</code> </pre> <br><p>  Namun, kadang-kadang, mengonversi ke array bidang datar tidak cukup (misalnya, jika sumber data mengembalikan struktur kompleks dengan bersarang).  Dalam hal ini, fungsi <code>fieldsMap</code> dari <code>graphql-fields-list</code> akan datang untuk menyelamatkan, yang mengembalikan seluruh pohon bidang yang diminta sebagai objek: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsMap } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">`graphql-fields-list`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... some resolver implementation on `users`: resolve(arc, args, ctx, info) { const map = fieldsMap(info); /* RESULT: { edges: { node: { id: false, name: false, phone: false, } } } */ }</span></span></code> </pre> <br><p>  Jika kita menganggap bahwa pengguna dideskripsikan oleh struktur yang kompleks, kita akan mendapatkan semuanya.  Metode ini juga dapat mengambil argumen <code>path</code> opsional, yang memungkinkan Anda untuk mendapatkan peta hanya cabang yang diperlukan dari seluruh pohon, misalnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsMap } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">`graphql-fields-list`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... some resolver implementation on `users`: resolve(arc, args, ctx, info) { const map = fieldsMap(info, 'edges.node'); /* RESULT: { id: false, name: false, phone: false, } */ }</span></span></code> </pre> <br><p>  Transformasi nama pada kartu saat ini tidak didukung dan tetap berada di tangan pengembang. </p><br><h2 id="fragmentaciya-zaprosov">  Minta Fragmentasi </h2><br><p>  GraphQL mendukung fragmentasi kueri, misalnya, kami dapat berharap konsumen mengirimkan permintaan seperti itu (di sini kami merujuk pada skema asli, sedikit dibuat-buat, tetapi secara sintaksis benar): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UsersFragmentedQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> ...NamesFramgment ...ContactsFragment } } fragment NamesFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } fragment AddressFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">address</span></span> } fragment ContactsFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">phone</span></span> email ...AddressFragment }</code> </pre> <br><p>  Anda tidak perlu khawatir dalam hal ini, dan <code>fieldsList(info)</code> , dan <code>fieldsMap(info)</code> dalam kasus ini akan mengembalikan hasil yang diharapkan, karena mereka mempertimbangkan kemungkinan memecah permintaan.  Jadi, <code>fieldsList(info)</code> akan mengembalikan <code>['id', 'name', 'phone', 'email', 'address']</code> , dan <code>fieldsMap(info)</code> , masing-masing, akan kembali: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><h2 id="ps">  PS </h2><br><p>  Saya harap artikel ini membantu menjelaskan beberapa nuansa bekerja dengan GraphQL di server, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka graphql-bidang-daftar</a> dapat membantu Anda membuat solusi optimal di masa depan. </p><br><h2 id="upd-1">  UPD 1 </h2><br><p>  Versi 1.1.0 perpustakaan telah dirilis - dukungan untuk <code>@skip</code> dan <code>@include</code> dalam permintaan telah ditambahkan.  Secara default, opsi ini diaktifkan, jika perlu, nonaktifkan seperti ini: </p><br><pre> <code class="javascript hljs">fieldsList(info, { <span class="hljs-attr"><span class="hljs-attr">withDirectives</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) fieldsMap(info, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427399/">https://habr.com/ru/post/id427399/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427389/index.html">Operasi Vk 2.0. RUU tentang agregator berita telah diperkenalkan. Yandex.Berita baru akan ditutup jika layanan tidak mengubah pemilik</a></li>
<li><a href="../id427391/index.html">Tips untuk Junior: Membangun Kebiasaan Baik</a></li>
<li><a href="../id427393/index.html">Analisis Keamanan Nirkabel Perusahaan</a></li>
<li><a href="../id427395/index.html">"Mari kita jelaskan: atau mengapa harus seorang programmer matematika." Sebuah buku tentang bagaimana tidak ketinggalan kuliah matematika</a></li>
<li><a href="../id427397/index.html">Pengembangan dataset akustik untuk pelatihan jaringan saraf</a></li>
<li><a href="../id427401/index.html">Shades Pembubaran dan Eksplorasi Dunia</a></li>
<li><a href="../id427403/index.html">API ReportingObserver: lihat kode halaman web dari perspektif baru</a></li>
<li><a href="../id427405/index.html">ES2018 - metode akhirnya menjanjikan</a></li>
<li><a href="../id427407/index.html">Meta-clustering dengan minimisasi kesalahan, dan mengapa saya pikir otak bekerja seperti ini</a></li>
<li><a href="../id427409/index.html">Buku "The Brilliant Agile. Manajemen proyek yang fleksibel dengan Agile, Scrum dan Kanban »</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>