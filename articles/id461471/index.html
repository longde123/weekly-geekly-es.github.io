<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏾 💱 ⛰️ .NET - Alat untuk bekerja dengan multithreading dan asynchrony - Bagian 2 👈🏾 ♣️ 😼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya awalnya memposting artikel ini di blog CodingSight . 
 Ini juga tersedia dalam bahasa Rusia di sini . 

 Artikel ini berisi bagian kedua dari pid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET - Alat untuk bekerja dengan multithreading dan asynchrony - Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461471/">  <i>Saya awalnya memposting artikel ini di blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodingSight</a> .</i> <i><br></i>  <i>Ini juga tersedia dalam bahasa Rusia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</i> <br><br>  Artikel ini berisi bagian kedua dari pidato saya di pertemuan multithreading.  Anda dapat melihat bagian pertama di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Pada bagian pertama, saya fokus pada seperangkat alat dasar yang digunakan untuk memulai utas atau Tugas, cara untuk melacak keadaan mereka, dan beberapa hal rapi lainnya seperti PLinq.  Pada bagian ini, saya akan memperbaiki masalah yang mungkin Anda temui di lingkungan multi-threaded dan beberapa cara untuk mengatasinya. <br><br><h2>  Isi </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengenai sumber daya bersama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kemungkinan masalah di lingkungan multi-utas</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jalan buntu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kondisi balapan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sibuk-tunggu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelaparan benang</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode sinkronisasi</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saling bertautan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitor. Masukkan, Monitor. Keluar, kunci</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitor. Tunggu, Monitor. Tolong [Semua]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keluarga ResetEvent</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ul><br><a name="habracut"></a><a name="SharedResources"></a><br><h2>  Mengenai sumber daya bersama </h2><br>  Anda tidak dapat menulis program yang pekerjaannya didasarkan pada banyak utas tanpa memiliki sumber daya bersama.  Bahkan jika itu berfungsi pada level abstraksi Anda saat ini, Anda akan menemukan bahwa itu benar-benar telah membagikan sumber daya begitu Anda turun satu atau beberapa level abstraksi.  Berikut ini beberapa contohnya: <br><br>  <b>Contoh # 1:</b> <br><br>  Untuk menghindari kemungkinan masalah, Anda membuat utas berfungsi dengan file berbeda, satu file untuk setiap utas.  Tampaknya bagi Anda bahwa program tersebut tidak memiliki sumber daya bersama apa pun. <br><br>  Turun beberapa tingkat ke bawah, Anda akan tahu bahwa hanya ada satu hard drive, dan terserah pada driver atau OS untuk menemukan solusi untuk masalah dengan akses hard drive. <br><br>  <b>Contoh # 2:</b> <br><br>  Setelah membaca <i>contoh # 1</i> , Anda memutuskan untuk meletakkan file pada dua mesin jarak jauh yang berbeda dengan perangkat keras dan sistem operasi yang berbeda secara fisik.  Anda juga memelihara dua koneksi FTP atau NFS yang berbeda. <br><br>  Turun beberapa tingkat lagi, Anda memahami bahwa tidak ada yang benar-benar berubah, dan masalah akses kompetitif sekarang didelegasikan ke driver kartu jaringan atau OS mesin di mana program ini berjalan. <br><br>  <b>Contoh # 3:</b> <br><br>  Setelah mencabut sebagian besar rambut Anda di atas upaya membuktikan Anda dapat menulis program multi-berulir, Anda memutuskan untuk membuang file sepenuhnya dan memindahkan perhitungan ke dua objek yang berbeda, dengan tautan ke masing-masing objek yang tersedia hanya untuk spesifik mereka utas. <br><br>  Untuk memalu selusin paku terakhir ke peti mati ide ini: satu runtime dan Garbage Collector, satu penjadwal ulir, secara fisik satu RAM terpadu, dan satu prosesor masih dianggap sebagai sumber daya bersama. <br><br>  Jadi, kami belajar bahwa tidak mungkin untuk menulis program multi-threaded tanpa sumber daya bersama pada semua tingkat abstraksi dan pada seluruh ruang lingkup tumpukan teknologi.  Untungnya, setiap tingkat abstraksi (sebagai aturan umum) sebagian atau bahkan sepenuhnya menangani masalah akses kompetitif atau langsung menolaknya (misalnya: kerangka kerja UI tidak memungkinkan bekerja dengan elemen dari utas berbeda).  Jadi biasanya, masalah dengan sumber daya bersama muncul di tingkat abstraksi Anda saat ini.  Untuk mengatasinya, konsep sinkronisasi diperkenalkan. <br><a name="Problems"></a><br><h2>  Kemungkinan masalah di lingkungan multi-utas </h2><br>  Kami dapat mengklasifikasikan kesalahan perangkat lunak ke dalam kategori berikut: <br><ol><li>  Program tidak membuahkan hasil - macet atau macet. </li><li>  Program memberikan hasil yang salah. </li><li>  Program ini menghasilkan hasil yang benar tetapi tidak memenuhi beberapa persyaratan yang tidak terkait fungsi - ia menghabiskan terlalu banyak waktu atau sumber daya. </li></ol><br>  Dalam lingkungan multi-utas, masalah utama yang menghasilkan kesalahan # 1 dan # 2 adalah <b>kondisi</b> <b>jalan buntu</b> dan <b>ras</b> . <br><br><a name="Deadlock"></a><br><h3>  Jalan buntu </h3><br>  Kebuntuan adalah blok timbal balik.  Ada banyak variasi kebuntuan.  Yang berikut ini dapat dianggap sebagai yang paling umum: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Sementara <b>Thread # 1</b> sedang melakukan sesuatu, <b>Thread # 2</b> memblokir sumber <b>B.</b>  Beberapa waktu kemudian, <b>Thread # 1</b> memblokir sumber daya <b>A</b> dan mencoba untuk memblokir sumber daya B. Sayangnya, ini tidak akan pernah terjadi karena <b>Thread # 2</b> hanya akan melepaskan sumber daya <b>B</b> setelah memblokir sumber daya <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Kondisi balapan </h3><br>  Race-Condition adalah situasi ketika keduanya, perilaku dan hasil perhitungan tergantung pada penjadwal thread dari lingkungan eksekusi <br><br>  Masalahnya adalah bahwa program Anda dapat bekerja secara tidak benar satu kali dalam seratus, atau bahkan dalam jutaan. <br><br>  Hal-hal mungkin menjadi lebih buruk ketika masalah datang bertiga.  Sebagai contoh, perilaku spesifik dari penjadwal thread dapat menyebabkan kebuntuan timbal balik. <br><br>  Selain dua masalah ini yang menyebabkan kesalahan eksplisit, ada juga masalah yang, jika tidak mengarah ke hasil perhitungan yang salah, masih dapat membuat program mengambil lebih banyak waktu atau sumber daya untuk menghasilkan hasil yang diinginkan.  Dua dari masalah tersebut adalah <b>Busy Wait</b> dan <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Sibuk-tunggu </h3><br>  Busy Wait adalah masalah yang terjadi ketika program menghabiskan sumber daya prosesor menunggu daripada pada perhitungan. <br><br>  Biasanya, masalah ini terlihat seperti berikut: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Ini adalah contoh kode yang sangat buruk karena sepenuhnya menempati satu inti dari prosesor Anda tanpa benar-benar melakukan sesuatu yang produktif sama sekali.  Kode tersebut hanya dapat dibenarkan ketika sangat penting untuk dengan cepat memproses perubahan nilai di utas yang berbeda.  Dan dengan 'cepat' maksud saya Anda tidak bisa menunggu bahkan untuk beberapa nanodetik.  Dalam semua kasus lain, yaitu, semua kasus dapat muncul pikiran yang masuk akal, jauh lebih nyaman untuk menggunakan variasi ResetEvent dan versi Slim mereka.  Kami akan membicarakannya sedikit nanti. <br><br>  Mungkin, beberapa pembaca akan menyarankan menyelesaikan masalah satu inti sepenuhnya sibuk dengan menunggu dengan menambahkan Thread. Tidur (1) (atau yang serupa) ke dalam siklus.  Sementara itu akan menyelesaikan masalah ini, yang baru akan dibuat - waktu yang dibutuhkan untuk bereaksi terhadap perubahan sekarang akan rata-rata 0,5 ms.  Di satu sisi, ini tidak banyak, tetapi di sisi lain, nilai ini lebih tinggi dari apa yang dapat kita capai dengan menggunakan primitif sinkronisasi dari keluarga ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Kelaparan benang </h3><br>  Thread Starvation adalah masalah dengan program yang memiliki terlalu banyak thread yang beroperasi secara bersamaan.  Di sini, kita berbicara secara khusus tentang utas yang sibuk dengan perhitungan daripada menunggu jawaban dari beberapa IO.  Dengan masalah ini, kami kehilangan semua manfaat kinerja yang mungkin muncul seiring dengan utas karena prosesor menghabiskan banyak waktu untuk beralih konteks. <br><br>  Anda dapat menemukan masalah seperti itu dengan menggunakan berbagai profiler.  Berikut ini adalah tangkapan layar dari profiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotTrace yang</a> bekerja dalam mode Timeline <br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(klik untuk memperbesar).</i> <br><br>  Biasanya, program yang tidak menderita kelaparan utas tidak memiliki bagian berwarna merah muda pada bagan yang mewakili utas.  Selain itu, dalam kategori Subsistem, kita dapat melihat bahwa program sedang menunggu CPU untuk 30,6% dari waktu. <br><br>  Ketika masalah seperti itu didiagnosis, Anda bisa mengatasinya secara sederhana: Anda telah memulai terlalu banyak utas sekaligus, jadi mulailah lebih sedikit utas. <br><a name="SyncPrimitives"></a><br><h2>  Metode sinkronisasi </h2><br><a name="Interlocked"></a><br><h3>  Saling bertautan </h3><br>  Ini mungkin metode sinkronisasi yang paling ringan.  Saling bertautan adalah serangkaian operasi atom sederhana.  Ketika operasi atom sedang dijalankan, tidak ada yang bisa terjadi.  Dalam .NET, Interlocked diwakili oleh kelas statis dengan nama yang sama dengan pilihan metode, masing-masing menerapkan satu operasi atom. <br><br>  Untuk mewujudkan kengerian utama operasi non-atom, coba tulis sebuah program yang meluncurkan 10 utas, masing-masing meningkatkan variabel yang sama satu juta kali lipat.  Ketika mereka selesai dengan pekerjaan mereka, output nilai dari variabel ini.  Sayangnya, ini akan sangat berbeda dari 10 juta.  Selain itu, akan berbeda setiap kali Anda menjalankan program.  Ini terjadi karena bahkan operasi sederhana seperti kenaikan itu bukan operasi atom, dan termasuk ekstraksi nilai dari memori, perhitungan nilai baru dan menulisnya ke memori lagi.  Jadi, dua utas dapat membuat salah satu dari operasi ini dan peningkatan akan hilang dalam kasus ini. <br><br>  Kelas yang saling bertautan menyediakan metode Peningkatan / Penurunan, dan tidak sulit untuk menebak apa yang seharusnya mereka lakukan.  Mereka sangat berguna jika Anda memproses data dalam beberapa utas dan menghitung sesuatu.  Kode seperti itu akan bekerja lebih cepat daripada kunci klasik.  Jika kami menggunakan Saling Bertautan dalam situasi yang dijelaskan dalam paragraf sebelumnya, program akan menghasilkan nilai 10 juta dalam skenario apa pun. <br><br>  Fungsi metode CompareExchange tidak begitu jelas.  Namun, keberadaannya memungkinkan implementasi banyak algoritma yang menarik.  Yang paling penting, yang dari keluarga bebas kunci. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Metode ini mengambil tiga nilai.  Yang pertama dilewatkan melalui referensi dan itu adalah nilai yang akan diubah ke yang kedua jika location1 sama dengan perbandingan dan ketika perbandingan dilakukan.  Nilai asli location1 akan dikembalikan.  Ini terdengar rumit, jadi lebih mudah untuk menulis sepotong kode yang melakukan operasi yang sama dengan CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Satu-satunya perbedaan adalah bahwa kelas yang saling bertautan mengimplementasikan ini dalam cara atom.  Jadi, jika kita menulis kode ini sendiri, kita bisa menghadapi skenario di mana kondisi location1 == comparand telah terpenuhi.  Tetapi ketika pernyataan location1 = nilai dieksekusi, utas yang berbeda telah mengubah nilai location1, sehingga akan hilang. <br><br>  Kita dapat menemukan contoh yang baik tentang bagaimana metode ini dapat digunakan dalam kode yang dihasilkan oleh kompiler untuk setiap peristiwa C #. <br><br>  Mari kita menulis kelas sederhana dengan satu acara bernama MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  Sekarang, mari kita bangun proyek dalam konfigurasi Release dan buka build through <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotPeek</a> dengan opsi "Show Compiler Generated Code" diaktifkan: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Di sini, kita dapat melihat bahwa kompiler telah menghasilkan algoritma yang agak rumit di belakang layar.  Algoritma ini mencegah kita dari kehilangan berlangganan ke acara di mana beberapa utas secara bersamaan berlangganan ke acara ini.  Mari kita uraikan metode add sambil mengingat apa yang dilakukan metode CompareExchange di balik layar: <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Ini jauh lebih mudah dikelola, tetapi mungkin masih membutuhkan penjelasan.  Ini adalah bagaimana saya menggambarkan algoritma: <br><br>  <i>Jika MyEvent masih sama seperti pada saat kami mulai menjalankan Delegate.Combine, kemudian atur ke Delegate.Combine kembali.</i>  <i>Jika tidak, coba lagi sampai berfungsi.</i> <br><br>  Dengan cara ini, langganan tidak akan pernah hilang.  Anda harus menyelesaikan masalah serupa jika Anda ingin mengimplementasikan array dinamis, aman-thread, dan bebas-kunci.  Jika beberapa utas tiba-tiba mulai menambahkan elemen ke array itu, penting agar semua elemen tersebut berhasil ditambahkan. <br><a name="Lock"></a><br><h3>  Monitor. Masukkan, Monitor. Keluar, kunci </h3><br>  Konstruksi ini paling sering digunakan untuk sinkronisasi ulir.  Mereka menerapkan konsep bagian kritis: yaitu, kode yang ditulis antara panggilan Monitor. Masukkan dan Monitor. Keluar hanya dapat dieksekusi pada satu sumber daya pada satu titik waktu dengan hanya satu utas.  Operator kunci berfungsi sebagai sintaks-gula di sekitar panggilan Enter / Exit yang dibungkus try-akhirnya.  Kualitas yang menyenangkan dari bagian kritis dalam .NET adalah mendukung reentrancy.  Ini berarti bahwa kode berikut dapat dieksekusi tanpa masalah nyata: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Tidak mungkin ada orang yang menulis dengan cara yang persis seperti ini, tetapi jika Anda menyebarkan kode ini di antara beberapa metode melalui kedalaman tumpukan-panggilan, fitur ini dapat menghemat beberapa IFs.  Agar trik ini berfungsi, pengembang .NET harus menambahkan batasan - Anda hanya dapat menggunakan contoh tipe referensi sebagai objek sinkronisasi, dan beberapa byte ditambahkan ke setiap objek tempat pengenal utas akan ditulis. <br><br>  Keunikan proses kerja bagian kritis ini dalam C # memberlakukan satu batasan menarik pada operator kunci: Anda tidak dapat menggunakan operator menunggu di dalam operator kunci.  Pada awalnya, ini mengejutkan saya karena Monitor yang coba-akhirnya serupa. Konstruksi Masuk / Keluar dapat dikompilasi.  Apa masalahnya?  Penting untuk membaca kembali paragraf sebelumnya dan menerapkan pengetahuan tentang bagaimana async / menunggu berfungsi: kode setelah menunggu tidak akan dieksekusi pada utas yang sama dengan kode sebelum menunggu.  Ini tergantung pada konteks sinkronisasi dan apakah metode ConfigureAwait dipanggil atau tidak.  Dari sini, berikut Monitor.Exit dapat dieksekusi pada utas yang berbeda dari Monitor.Enter, yang akan menyebabkan SynchronizationLockException dilemparkan.  Jika Anda tidak percaya, coba jalankan kode berikut di aplikasi konsol - itu akan menghasilkan <b>SynchronizationLockException</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Perlu dicatat bahwa, dalam aplikasi WinForms atau WPF, kode ini akan berfungsi dengan benar jika Anda memanggilnya dari utas utama karena akan ada konteks sinkronisasi yang mengimplementasikan kembali ke UI-Utas setelah panggilan menunggu.  Bagaimanapun, lebih baik tidak bermain-main dengan bagian-bagian penting dalam konteks kode yang berisi operator yang menunggu.  Dalam contoh seperti itu, lebih baik menggunakan primitif sinkronisasi yang akan kita bahas nanti. <br><br>  Sementara kita berada pada topik bagian kritis dalam. NET, penting untuk menyebutkan satu lagi kekhasan bagaimana mereka diterapkan.  Bagian kritis dalam .NET berfungsi dalam dua mode: spin-wait dan core-wait.  Kami dapat mewakili algoritma spin-tunggu seperti kodesemu berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Optimalisasi ini diarahkan untuk menangkap bagian kritis secepat mungkin dalam waktu singkat dengan dasar bahwa, bahkan jika sumber daya saat ini ditempati, itu akan dirilis segera.  Jika ini tidak terjadi dalam waktu singkat, utas akan beralih ke menunggu dalam mode inti, yang membutuhkan waktu - sama seperti mundur dari menunggu.  Para pengembang .NET telah mengoptimalkan skenario blok pendek sebanyak mungkin.  Sayangnya, jika banyak utas mulai menarik bagian kritis di antara mereka, itu dapat menyebabkan beban CPU yang tiba-tiba tinggi. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Setelah menyebutkan algoritma menunggu siklik (spin-tunggu), ada baiknya berbicara tentang struktur SpinLock dan SpinWait dari BCL.  Anda harus menggunakannya jika ada alasan untuk menganggapnya akan selalu mungkin untuk mendapatkan blok dengan sangat cepat.  Di sisi lain, Anda seharusnya tidak benar-benar memikirkannya sampai hasil profiling akan menunjukkan bahwa kemacetan program Anda disebabkan oleh penggunaan primitif sinkronisasi lainnya. <br><a name="Pulse"></a><br><h3>  Monitor. Tunggu, Monitor. Tolong [Semua] </h3><br>  Kita harus melihat kedua metode ini secara berdampingan.  Dengan bantuan mereka, Anda dapat menerapkan berbagai skenario Produsen-Konsumen. <br><br>  Produser-Konsumen adalah pola desain multi-proses / multi-utas yang menyiratkan satu atau lebih utas / proses yang menghasilkan data dan satu atau lebih proses / utas yang memproses data ini.  Biasanya, koleksi bersama digunakan. <br><br>  Kedua metode ini hanya dapat dipanggil oleh utas yang saat ini memiliki blok.  Metode Tunggu akan melepaskan blok dan membeku sampai utas lainnya akan memanggil Pulse. <br><br>  Sebagai contohnya, saya menulis sedikit contoh: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Saya menggunakan gambar daripada teks di sini untuk secara akurat menunjukkan perintah pelaksanaan instruksi)</i> <br>  <b>Penjelasan:</b> Saya menetapkan latensi 100 ms saat memulai utas kedua untuk secara khusus menjamin bahwa itu akan dieksekusi nanti. <br>  - T1: Baris # 2 utas dimulai <br>  - T1: Baris # 3 utas memasuki bagian kritis <br>  - T1: Baris # 6 utas tertidur <br>  - T2: Baris # 3 utas dimulai <br>  - T2: Baris # 4 membeku dan menunggu bagian kritis <br>  - T1: Baris # 7 itu membiarkan bagian kritis pergi dan membeku sambil menunggu Pulsa keluar <br>  - T2: Baris # 8 memasuki bagian kritis <br>  - T2: Baris # 11 memberi sinyal T1 dengan bantuan Pulse <br>  - T2: Baris # 14 keluar dari bagian kritis.  T1 tidak dapat melanjutkan eksekusi sebelum ini terjadi. <br>  - T1: Baris # 15 keluar dari menunggu <br>  - T1: Baris # 16 keluar dari bagian kritis <br><br>  <i>Ada komentar penting dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MSDN</a> mengenai penggunaan metode Pulse / Tunggu: Monitor tidak menyimpan informasi keadaan, yang berarti memanggil metode Pulse sebelum metode Tunggu dapat menyebabkan kebuntuan.</i>  <i>Jika hal ini memungkinkan, lebih baik menggunakan salah satu kelas dari keluarga ResetEvent.</i> <br><br>  Contoh sebelumnya dengan jelas menunjukkan bagaimana metode Tunggu / Denyut dari kelas Monitor berfungsi, tetapi masih menyisakan beberapa pertanyaan tentang kasus-kasus di mana kita harus menggunakannya.  Contoh yang baik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi</a> BlockingQueue &lt;T&gt; ini.  Di sisi lain, implementasi BlockingCollection &lt;T&gt; dari System.Collections.Concurrent menggunakan SemaphoreSlim untuk sinkronisasi. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Saya sangat suka primitif sinkronisasi ini, dan itu diwakili oleh kelas dengan nama yang sama dari System.Threading namespace.  Saya pikir banyak program akan bekerja lebih baik jika pengembang mereka menggunakan kelas ini daripada kunci standar. <br><br>  Ide: banyak utas dapat membaca, dan satu-satunya yang bisa menulis.  Ketika utas ingin menulis, bacaan baru tidak dapat dimulai - mereka akan menunggu penulisan sampai akhir.  Ada juga konsep upgrade-baca-kunci.  Anda dapat menggunakannya ketika, selama proses membaca, Anda memahami ada kebutuhan untuk menulis sesuatu - kunci tersebut akan diubah menjadi kunci-tulis dalam satu operasi atom. <br><br>  Di System.Threading namespace, ada juga kelas ReadWriteLock, tetapi sangat disarankan untuk tidak menggunakannya untuk pengembangan baru.  Versi Slim akan membantu menghindari kasus-kasus yang menyebabkan kebuntuan dan memungkinkan untuk dengan cepat menangkap blok karena mendukung sinkronisasi dalam mode spin-wait sebelum masuk ke mode inti. <br><br>  Jika Anda tidak tahu tentang kelas ini sebelum membaca artikel ini, saya pikir sekarang, Anda telah mengingat banyak contoh dari kode yang baru ditulis di mana pendekatan ini untuk blok memungkinkan program untuk bekerja secara efektif. <br><br>  Antarmuka kelas ReaderWriterLockSlim sederhana dan mudah dipahami, tetapi tidak nyaman untuk digunakan: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Saya biasanya suka membungkusnya dalam kelas - ini membuatnya lebih mudah. <br><br>  <i><b>Ide:</b> buat metode Baca / WriteLock yang mengembalikan objek beserta metode Buang.</i>  <i>Anda kemudian dapat mengaksesnya di Menggunakan, dan itu mungkin tidak akan jauh berbeda dari kunci standar dalam hal jumlah baris.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Ini memungkinkan kami untuk hanya menulis yang berikut di kode nanti: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  Keluarga ResetEvent </h3><br>  Saya menyertakan kelas-kelas berikut dalam keluarga ini: ManualResetEvent, ManualResetEventSlim, dan AutoResetEvent. <br><br>  Kelas ManualResetEvent, versi Slim-nya, dan kelas AutoResetEvent dapat ada di dua negara: <br><br>  - Non-sinyal - dalam keadaan ini, semua utas yang telah memanggil WaitOne dibekukan hingga acara beralih ke status bersinyal. <br>  - Ditandatangani - dalam kondisi ini, semua utas yang sebelumnya dibekukan pada panggilan WaitOne dilepaskan.  Semua panggilan WaitOne baru pada acara yang ditandai dilakukan secara relatif instan. <br><br>  AutoResetEvent berbeda dari ManualResetEvent dalam hal itu secara otomatis beralih ke keadaan tanpa sinyal setelah melepaskan <b>tepat satu utas</b> .  Jika beberapa utas dibekukan saat menunggu AutoResetEvent, maka memanggil Set hanya akan merilis satu utas acak, sebagai lawan dari ManualResetEvent yang melepaskan semua utas. <br><br>  Mari kita lihat contoh bagaimana AutoResetEvent bekerja: <br><br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br>  Dalam contoh-contoh ini, kita dapat melihat bahwa peristiwa tersebut beralih ke keadaan tanpa sinyal secara otomatis hanya setelah melepaskan utas yang dibekukan pada panggilan WaitOne. <br><br>  Tidak seperti ReaderWriterLock, ManualResetEvent tidak dianggap usang bahkan setelah versi Slim-nya muncul.  Versi Slim kelas ini bisa efektif untuk waktu yang singkat karena terjadi dalam mode Spin-Wait;  versi standarnya bagus untuk menunggu lama. <br><br>  Terlepas dari kelas ManualResetEvent dan AutoResetEvent, ada juga kelas CountdownEvent.  Kelas ini sangat berguna untuk mengimplementasikan algoritma yang menggabungkan hasil bersama setelah bagian paralel.  Pendekatan ini dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fork-join</a> .  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> bagus yang didedikasikan untuk kelas ini, jadi saya tidak akan menjelaskannya secara rinci di sini. <br><a name="Conclusions"></a><br><h2>  Kesimpulan </h2><br><ul><li>  Saat bekerja dengan utas, ada dua masalah yang dapat menyebabkan hasil yang salah atau bahkan tidak ada hasil - kondisi balapan dan kebuntuan. </li><li>  Masalah yang dapat membuat program menghabiskan lebih banyak waktu atau sumber daya adalah thread kelaparan dan menunggu sibuk. </li><li>  .NET menyediakan banyak cara untuk menyinkronkan utas. </li><li>  Ada dua mode tunggu blok - Putar Tunggu dan Tunggu Inti.  Kadang-kadang primitif sinkronisasi utas di .NET menggunakan keduanya. </li><li>  Saling bertautan adalah seperangkat operasi atom yang dapat digunakan untuk mengimplementasikan algoritma bebas kunci.  Ini primitif sinkronisasi tercepat. </li><li>  Penguncian dan Monitor. Operator Enter / Exit mengimplementasikan konsep bagian kritis - sebuah fragmen kode yang hanya dapat dieksekusi oleh satu utas pada satu titik waktu. </li><li>  Metode Monitor.Pulse / Tunggu berguna untuk mengimplementasikan skenario Produser-Consumer. </li><li>  ReaderWriterLockSlim bisa lebih berguna daripada kasus penguncian standar saat pembacaan paralel diharapkan. </li><li>  Keluarga kelas ResetEvent dapat berguna untuk sinkronisasi utas. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461471/">https://habr.com/ru/post/id461471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461461/index.html">Cadangan tumbuh subur di zaman cloud, tetapi gulungan kaset tidak dilupakan. Percakapan dengan Veeam</a></li>
<li><a href="../id461463/index.html">Proses bisnis di perusahaan perusahaan: spekulasi dan kenyataan. Terangkan dengan R</a></li>
<li><a href="../id461465/index.html">Panduan Pengukuran</a></li>
<li><a href="../id461467/index.html">Contoh membuat aplikasi Makefile for Go</a></li>
<li><a href="../id461469/index.html">Bagaimana rasanya mendengarkan kode dengan 1000 kata per menit</a></li>
<li><a href="../id461473/index.html">Algoritma debugging pada grafik - sekarang dengan gambar</a></li>
<li><a href="../id461475/index.html">AMA dengan Habr. 1011</a></li>
<li><a href="../id461483/index.html">Openstack Load Balancing</a></li>
<li><a href="../id461487/index.html">Tugas CTF Mini</a></li>
<li><a href="../id461493/index.html">Django 3.0 akan tidak sinkron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>