<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèª ‚¨õÔ∏è üòâ Netzwerkcode Age of Empires: 1.500 Bogensch√ºtzen pro 28,8-kbit / s-Modem üë©üèø‚Äçüç≥ üíæ üï•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anmerkung des √úbersetzers: Dieser Artikel ist bereits 17 Jahre alt und nur aus historischer Sicht interessant. Es ist interessant zu erfahren, wie es ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Netzwerkcode Age of Empires: 1.500 Bogensch√ºtzen pro 28,8-kbit / s-Modem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417703/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eaa/c7f/fd7/eaac7ffd7c6a997f72a9cdd4cf67e982.png" alt="Bild"></div><br>  <i>Anmerkung des √úbersetzers: Dieser Artikel ist bereits 17 Jahre alt und nur aus historischer Sicht interessant.</i>  <i>Es ist interessant zu erfahren, wie es den Entwicklern im Zeitalter von 28,8.000 Modems und den ersten Pentiums gelungen ist, ein reibungsloses Online-Spiel zu erreichen.</i> <br><br>  Dieser Artikel beschreibt die Architektur und Implementierung sowie einige Lehren aus der Erstellung des Mehrbenutzercodes (Netzwerkcodes) f√ºr <em>Age of Empires 1- und 2-</em> Spiele.  Au√üerdem werden aktuelle und zuk√ºnftige Ans√§tze der Netzwerkarchitektur beschrieben, die Ensemble Studios in ihren Game Engines verwenden. <br><br><h2>  Multiplayer Age of Empires: Strukturanforderungen </h2><br>  Zu Beginn der Arbeit am Multiplayer-Code <em>Age of Empires</em> im Jahr 1996 haben wir uns sehr spezifische Ziele gesetzt, die f√ºr die Implementierung des erforderlichen Gameplays erforderlich sind. <br><a name="habracut"></a><br><ul><li>  Gro√üe und epische historische Schlachten mit vielen verschiedenen Milit√§reinheiten </li><li>  Unterst√ºtzung f√ºr bis zu 8 Spieler im Mehrspielermodus </li><li>  Reibungslose Gameplay-Simulation √ºber LAN, direkte Modemverbindung und √ºber das Internet </li><li>  Unterst√ºtzung der Zielplattform: Pentium 90 mit 16 MB RAM und 28,8-Kbit / s-Modem </li><li>  Das Kommunikationssystem sollte mit der vorhandenen Engine (Genie) funktionieren. </li><li>  Stabile 15 Bilder pro Sekunde auf Maschinen mit minimaler Konfiguration </li></ul><br>  Die Genie-Engine war bereits fertig und das Gameplay im Einzelbenutzermodus nahm seine Form an.  Die Genie-Engine ist eine zweidimensionale Single-Threaded-Game-Loop-Engine.  Sprites werden in einer aus Kacheln zusammengesetzten Welt in 256 Farben gerendert.  Zuf√§llig generierte Karten sind mit Tausenden von Objekten gef√ºllt: von B√§umen, die gef√§llt werden k√∂nnen, bis zu galoppierenden Gazellen.  Die ungef√§hre Aufteilung (nach der Optimierung) der Zeit f√ºr die Ausf√ºhrung von Engine-Aufgaben: 30% f√ºr das Rendern von Grafiken, 30% f√ºr die KI und das Finden von Pfaden, 30% f√ºr das Ausf√ºhren von Simulationen und offiziellen Aufgaben. <br><br>  Bereits zu einem relativ fr√ºhen Zeitpunkt war die Engine relativ stabil, und die Mehrbenutzerkommunikation musste mit vorgefertigtem Code arbeiten, ohne dass die vorhandene (funktionierende) Architektur wesentlich ge√§ndert werden musste. <br><br>  Um die Aufgabe zu verkomplizieren, kann die Zeit, die f√ºr die einzelnen Schritte der Simulation ben√∂tigt wird, sehr unterschiedlich sein: Die Renderzeit hing davon ab, ob der Benutzer die Einheiten beobachtete, scrollte oder den unerforschten Bereich betrachtete, und lange Pfade oder die strategische Planung der KI beeinflussten die Ausf√ºhrungszeit des Spielzugs erheblich : Die Schwingungen betrugen bis zu 200 ms. <br><br>  Kurze Berechnungen zeigten, dass die √úbertragung selbst eines kleinen Datensatzes √ºber Einheiten und der Versuch, diese in Echtzeit zu aktualisieren, die Anzahl der Einheiten und Objekte, mit denen der Spieler interagieren kann, stark einschr√§nkt.  Wenn Sie einfach die X- und Y-Koordinaten, den Status, die Aktion, die Blickrichtung und den Schaden √ºbertragen, k√∂nnen im Spiel nicht mehr als 250 mobile Einheiten vorhanden sein. <br><br>  Wir wollten, dass die Spieler in der Lage sind, griechische St√§dte mit Katapulten, Bogensch√ºtzen und Kriegern zu zerst√∂ren und gleichzeitig Belagerungen mit Triremen aus dem Meer durchzuf√ºhren.  Offensichtlich brauchten wir einen anderen Ansatz. <br><br><h2>  Simultane Simulationen </h2><br>  Anstatt den Status jeder Spieleinheit zu √ºbertragen, wollten wir auf jeder Maschine absolut identische Simulationen durchf√ºhren und dabei jeweils den gleichen Befehlssatz √ºbergeben, den die Spieler gleichzeitig gegeben haben.  Die Computer der Spieler mussten im Wesentlichen das Gameplay in den besten Traditionen von Kriegsfilmen synchronisieren, damit die Spieler Befehle erteilen und diese dann auf die gleiche Weise und zur gleichen Zeit ausf√ºhren konnten, um die Identit√§t der Spiele sicherzustellen. <br><br>  Anfangs war eine solch knifflige Synchronisation schwierig zu implementieren, brachte jedoch in anderen Bereichen unerwartete Vorteile. <br><br>  <strong>Grundlegende Modellverbesserung</strong> <br><br>  Auf der einfachsten konzeptionellen Ebene scheint die Implementierung simultaner Simulationen sehr einfach zu sein.  In einigen Spielen, die Simulationen mit einem festen Schritt (Lock-Step) und konstanten Timings verwenden, kann dies sogar durchaus m√∂glich sein. <br><br>  Da bei diesem Ansatz die Verantwortung f√ºr das gleichzeitige Verschieben von Hunderten oder Tausenden von Objekten √ºbernommen werden sollte, muss das System auch bei Verz√∂gerungsschwankungen von 20 bis 1000 Millisekunden funktionsf√§hig bleiben und √Ñnderungen w√§hrend der Frame-Verarbeitung verarbeiten k√∂nnen. <br><br>  Das Senden von Spielerbefehlen, das Best√§tigen aller Nachrichten und das anschlie√üende Verarbeiten dieser Nachrichten, bevor mit dem n√§chsten Zug fortgefahren wird, w√§re aus Sicht des Spielprozesses ein Albtraum, mit st√§ndigem Warten und einem langsamen Austausch von Teams.  Wir brauchten ein Schema, das das Spiel parallel zum Hintergrund weiter verarbeiten konnte und auf den Abschluss des Datenaustauschprozesses wartete. <br><br>  Mark [Terrano] verwendete ein System zum Markieren von Befehlen, die in Zukunft durch zwei ‚ÄûDatenaustauschbewegungen‚Äú ausgef√ºhrt werden sollten (die Datenaustauschbewegungen in <em>AoE</em> wurden von den Rendering-Frames selbst getrennt). <br><br>  Das hei√üt, die w√§hrend des Kurses 1000 gegebenen Befehle werden zugewiesen, um w√§hrend des Kurses 1002 ausgef√ºhrt zu werden (siehe Fig. 1).  Im Laufe von 1001 werden die im Laufe von 0999 erteilten Befehle ausgef√ºhrt. Dadurch konnten wir Nachrichten f√ºr die Verarbeitung empfangen, best√§tigen und vorbereiten, w√§hrend das Spiel weiterhin Animationen zeichnete und Simulationen durchf√ºhrte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/163/10f/01d16310f6b5958701fbde3e8480790a.jpg"></div><br>  <i>Abbildung 1. Markup von Befehlen, die durch zwei ‚ÄûDatenaustauschbewegungen‚Äú ausgef√ºhrt werden sollen.</i> <br><br>  Normalerweise dauerten die Bewegungen 200 ms und die Teams wurden in dieser Runde geschickt.  Nach 200 ms stoppte die Bewegung und eine neue Bewegung begann.  Zu jedem Zeitpunkt des Spiels wurden die Teams in einem Zug verarbeitet, f√ºr den n√§chsten Zug empfangen und gespeichert und zwei Z√ºge sp√§ter zur Ausf√ºhrung geschickt. <br><br><h2>  "Geschwindigkeitsregelung" </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/133/4b0/fc51334b03798cffa22b0a18938e9ce3.jpg"></div><br>  <i>Abbildung 2. Geschwindigkeitsregelung.</i> <br><br>  Da Simulationen immer genau die gleiche Eingabe haben sollten, kann ein Spiel nicht schneller ausgef√ºhrt werden, als es die langsamste Maschine schafft, den Datenaustausch zu verarbeiten, einen Zug auszuf√ºhren und neue Befehle zu senden.  Wir haben das System, das die Strichdauer √§ndert, um reibungslose Animationen und das Gameplay unter Bedingungen variabler Datenaustauschverz√∂gerung und Verarbeitungsgeschwindigkeit aufrechtzuerhalten, als "Geschwindigkeitsregelung" bezeichnet. <br><br>  Das Gameplay kann aus zwei Gr√ºnden als "bremsen" empfunden werden: Wenn die Bildrate einer Maschine sinkt (oder niedriger als die der anderen ist), verarbeiten andere Maschinen ihre Befehle, rendern alles zum festgelegten Zeitpunkt und m√ºssen daher auf den n√§chsten Zug warten.  In diesem Fall macht sich jede Pause sofort bemerkbar.  Zus√§tzlich wird das Spiel durch eine Verz√∂gerung des Datenaustauschs verlangsamt - die Spieler m√ºssen warten, bis die Maschine gen√ºgend Daten erh√§lt, um den Zug abzuschlie√üen. <br><br>  Jeder Client berechnete die als konstant erreichbar angesehene Bildrate, die durch Mittelung der Verarbeitungszeit mehrerer Bilder berechnet wurde.  Da sich dieser Wert w√§hrend des Spiels abh√§ngig vom Umfang, der Anzahl der Einheiten, der Gr√∂√üe der Karte und anderen Faktoren √§ndert, wurde er in jeder Nachricht √ºber den Abschluss des Zuges √ºbertragen. <br><br>  Dar√ºber hinaus hat jeder Client auch die ‚ÄûPing-Zeit‚Äú von sich selbst zu anderen Clients und umgekehrt gemessen.  Er schickte auch den durchschnittlichen Ping an den l√§ngsten Client in einer Nachricht √ºber den Abschluss der Verschiebung (insgesamt wurden 2 Bytes verwendet, um die Geschwindigkeit zu steuern). <br><br>  Bei jeder Bewegung analysierte die vom Host bestimmte Maschine die Abschlussnachrichten, berechnete die erforderliche Bildrate und die Korrektur f√ºr die Verz√∂gerung bei der Daten√ºbertragung √ºber das Internet.  Dann schickte der Host eine neue Bildrate und die Dauer des Datenaustauschs.  Die Abbildungen 3-5 zeigen, wie der Datenaustausch unter verschiedenen Bedingungen aufgeteilt wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34d/ce4/48d/34dce448d5683dd1e449b7d2cf25d505.jpg"></div><br>  <i>Abbildung 3. Typischer Datenaustauschfluss.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/6b4/1a8/3b96b41a83ee28f6d94164f87f8a8df6.jpg"></div><br>  <i>Abbildung 4. Daten√ºbertragung mit hoher Latenz √ºber das Internet bei normaler Maschinengeschwindigkeit.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/645/4d5/bd1/6454d5bd11e1ca0b16971e8a3e27cf9f.jpg"></div><br>  <i>Abbildung 5. Niedrige Maschinengeschwindigkeit bei normaler Daten√ºbertragungsverz√∂gerung.</i> <br><br>  Der "Datenaustauschfortschritt", der ungef√§hr der Ping-Zeit f√ºr den Roundtrip f√ºr die Nachricht entsprach, wurde durch die Anzahl der Simulationsrahmen geteilt, die die langsamste Maschine w√§hrend dieser Zeit durchschnittlich ausf√ºhren konnte. <br><br>  Die Dauer des Datenaustauschs wurde gewichtet, sodass sie entsprechend den √Ñnderungen der Verz√∂gerungen bei der Daten√ºbertragung √ºber das Internet schnell zunehmen und langsam auf die beste Durchschnittsgeschwindigkeit abnehmen konnte, die kontinuierlich beibehalten werden kann.  Normalerweise verlangsamte sich das Spiel und verlangsamte sich nur in den Momenten der schlimmsten Spitzen - die √úbertragungsverz√∂gerung der Befehle nahm zu, blieb jedoch reibungslos (und erh√∂hte sich nur um einige Millisekunden pro Runde), da das Spiel die Verz√∂gerungen allm√§hlich auf die bestm√∂gliche Geschwindigkeit reduzierte.  Dies f√ºhrte zu einer gr√∂√ütm√∂glichen Gl√§tte des Spiels und gleichzeitig zu einer Anpassung an sich √§ndernde Bedingungen. <br><br><h2>  Garantierte Lieferung </h2><br>  UDP wurde in der Netzwerkschicht verwendet, und jeder Client war an der Bestellung von Befehlen, der Erkennung von Verlusten und der erneuten √úbertragung beteiligt.  Jede Nachricht verwendete ein Bytepaar, das den Kurs angibt, f√ºr den die Ausf√ºhrung der Befehle geplant war, und die Seriennummer der Nachricht.  Wenn eine Nachricht nach dem Verschieben empfangen wurde, wurde sie abgelehnt und eingehende Nachrichten wurden zur Ausf√ºhrung gespeichert.  Aufgrund der Art von UDP verwendete Mark beim Empfang von Nachrichten das folgende Prinzip: ‚ÄûIm Zweifelsfall sollten Sie die Nachricht als verloren betrachten.  Wenn Nachrichten nicht in der richtigen Reihenfolge empfangen werden, sendet der Empf√§nger sofort eine Anforderung zur erneuten √úbertragung verlorener Nachrichten.  Wenn die Empfangsbest√§tigung sp√§ter als die vorhergesagte Zeit eingeht, sendet der Absender die Nachricht einfach erneut, ohne auf ein Signal √ºber ihren Verlust zu warten. " <br><br><h2>  Versteckte Vorteile </h2><br>  Da die vom Spiel berechneten Ergebnisse davon abhingen, dass alle Benutzer identische Simulationen durchf√ºhrten, war es f√ºr einen Client (oder Client-Datenstrom) unglaublich schwierig, zu hacken und zu betr√ºgen.  Jede anders durchgef√ºhrte Simulation wurde als "nicht synchron" markiert und das Spiel gestoppt.  Es war immer noch m√∂glich, lokal f√ºr die Offenlegung von Informationen zu betr√ºgen, aber solche Lecks konnten in nachfolgenden Patches und Revisionen relativ leicht behoben werden.  Sicherheit ist unser gr√∂√üter Sieg geworden. <br><br><h2>  Versteckte Probleme </h2><br>  Auf den ersten Blick scheint es einfach zu sein, dieselbe Ausf√ºhrung von zwei Instanzen desselben Codes zu implementieren, ist es aber nicht.  Zu Beginn des Projekts erkl√§rte Microsoft-Produktmanager Tim Znamenachek gegen√ºber Mark: ‚ÄûJedes Projekt weist einen dauerhaften Fehler auf, der erst nach Abschluss des Projekts aufgibt.  Ich denke in unserem Fall wird es nicht synchron sein. ‚Äú  Und er hatte recht.  Die Schwierigkeiten, Synchronisationsfehler herauszufinden, vervielfachten sich mit jeder kleinen √Ñnderung.  Der Hirsch, dessen Position beim Erstellen einer zuf√§lligen Karte etwas anders ist, bewegt sich etwas anders, und Minuten sp√§ter bewegt sich der J√§ger etwas aus dem Weg oder verfehlt einen Speer, weil er ohne Fleisch nach Hause zur√ºckkehrt.  Was manchmal nur ein Unterschied in den Pr√ºfsummen der Lebensmittelmenge zu sein schien, hatte daher Gr√ºnde, die sehr schwer zu verfolgen waren. <br><br>  Obwohl wir die Welt, Objekte, die Suche nach Pfaden, das Zielen und alle anderen Systeme mit Pr√ºfsummen √ºberpr√ºft haben, gab es immer etwas, das wir nicht ber√ºcksichtigen konnten.  Riesige (jeweils 50 MB) Mengen an Nachrichtenverfolgung und Speicherausz√ºgen von Weltobjekten machten das Problem noch komplizierter.  Ein Teil der Schwierigkeiten war konzeptionell - Programmierer waren es nicht gewohnt, Code zu schreiben, der dieselbe Anzahl von Zufallszahlengeneratoraufrufen in einer Simulation verwendete (ja, Zufallszahlen wurden ebenfalls generiert und synchronisiert). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d29/1c3/690/d291c3690fef6c18cc65aec724dafe31.png" alt="Bild"></div><br><h2>  Lektionen gelernt </h2><br>  Bei der Entwicklung des Netzwerkteils von <em>Age of Empires haben</em> wir verschiedene Lektionen erhalten, die auf die Entwicklung jedes Gaming-Mehrbenutzersystems angewendet werden k√∂nnen. <br><br>  <strong><em>Lernen Sie Ihren Benutzer.</em></strong>  Das Studium des Benutzers ist der wichtigste Schritt, um seine Erwartungen hinsichtlich der Geschwindigkeit des Mehrspielers, der wahrgenommenen Bremsen und Verz√∂gerungen bei der √úbertragung von Befehlen zu verstehen.  Jedes Genre ist individuell und Sie m√ºssen verstehen, was zu Ihrem Spiel- und Managementstil passt. <br><br>  In den fr√ºhen Phasen des Entwicklungsprozesses haben Mark und der leitende Designer Verz√∂gerungen beim Datenaustausch prototypisiert (dieser Prototyp wurde w√§hrend des Entwicklungsprozesses mehrmals √ºberarbeitet).  Da sie ein Einzelspielerspiel spielten, war es sehr einfach, verschiedene Ebenen von Teamtransferverz√∂gerungen zu simulieren und Spielerfeedback zu erhalten (‚ÄûKontrolle scheint gut / langsam / zuckend / einfach schrecklich‚Äú). <br><br>  Bei Spielen des RTS-Genres sind Verz√∂gerungen bei der Befehls√ºbertragung von 250 Millisekunden nicht einmal erkennbar. Bei 250 bis 500 ms ist das Gameplay gut spielbar, und die Bremsen werden bei 500 ms und h√∂her sp√ºrbar.  Es ist auch interessant festzustellen, dass die Spieler an das "Tempo des Spiels" und die mentale Erwartung einer Verz√∂gerung zwischen Mausklicks und Einheitenreaktionen gew√∂hnt sind.  Eine konstante verz√∂gerte Antwort war besser als Spr√ºnge bei Befehls√ºbertragungsverz√∂gerungen (z. B. von 80 auf 500 ms). In diesem Fall wurden konstante Verz√∂gerungen von 500 ms als spielbar empfunden, und ver√§nderbare Verz√∂gerungen schienen ‚Äûnerv√∂s‚Äú zu sein und das Spiel zu komplizieren. <br><br>  Dies zwang die Programmierer, ihre Bem√ºhungen auf die Gew√§hrleistung der Laufruhe zu richten. Es ist besser, eine l√§ngere Hubdauer zu w√§hlen und sicherzustellen, dass alles glatt und konstant ist, als die Operationen angesichts regelm√§√üiger Verlangsamungen so schnell wie m√∂glich durchzuf√ºhren.  Alle Geschwindigkeits√§nderungen sollten schrittweise erfolgen und die Wachstumsrate sollte so gering wie m√∂glich sein. <br><br>  Wir haben auch die Anforderungen des Benutzers an das System gemessen - normalerweise gaben sie Befehle (bewegen, angreifen, B√§ume f√§llen) ungef√§hr alle anderthalb bis zwei Sekunden, manchmal mit Spitzenwerten von 3-4 Teams pro Sekunde w√§hrend heftiger K√§mpfe.  Da die aktiven Aktionen in unserem Spiel st√§ndig zunehmen, entstehen die h√∂chsten Anforderungen f√ºr den Datenaustausch in der Mitte und gegen Ende des Spiels. <br><br>  Wenn Sie sich die Zeit nehmen, um das Benutzerverhalten zu untersuchen, werden Sie andere Funktionen der Spielweise bemerken. Dies hilft beim Einrichten des Netzwerkspiels.  In <em>AoE klickten</em> Benutzer w√§hrend eines Angriffs schnell mit der Maus (Klick-Klick-Klick-Klick - vorw√§rts-vorw√§rts-vorw√§rts-vorw√§rts!), Was zu enormen Spitzenwerten bei der Anzahl der ausgegebenen Befehle f√ºhrte.  Dar√ºber hinaus schickten sie gro√üe Gruppen von Einheiten, die den Weg ebnen m√ºssen - auch gro√üe Spitzen bei den Anforderungen f√ºr die Daten√ºbertragung √ºber das Netzwerk.  Ein einfacher Filter, der wiederholte Befehle an einem Punkt abschneidet, reduziert die negativen Auswirkungen dieses Verhaltens erheblich. <br><br>  Im Allgemeinen k√∂nnen Sie Benutzer √ºberwachen, um: <br><br><ul><li>  Informieren Sie sich √ºber die Erwartungen der Benutzer bez√ºglich Spielverz√∂gerungen </li><li>  Prototyp-Multiplayer-Aspekte in den fr√ºhen Entwicklungsstadien </li><li>  Siehe Verhalten, das sich nachteilig auf die Geschwindigkeit des Mehrbenutzermodus auswirkt. </li></ul><br>  <strong><em>Messung ist das Wichtigste.</em></strong>  Wenn Sie in den fr√ºhen Arbeitsphasen Metriken einf√ºhren, lernen Sie erstaunliche Dinge √ºber Ihr Datenaustauschsystem.  Machen Sie die Metriken f√ºr Tester lesbar und verwenden Sie sie, um zu verstehen, was in der Netzwerk-Engine vor sich geht. <br><br>  Lektion: Ein Teil des Problems beim Datenaustausch in AoE trat auf, als Mark die Metriken zu fr√ºh ableitete und die Nachrichtenebenen (L√§nge und H√§ufigkeit) nach der Erstellung des endg√ºltigen Codes nicht erneut √ºberpr√ºfte.  Unerwartete Dinge wie zuf√§llige Rennen zwischen AIs, schwer zu berechnende Pfade und schlecht strukturierte Befehlspakete k√∂nnen gro√üe Leistungsprobleme verursachen, selbst wenn das System ansonsten gut funktioniert. <br><br>  Lassen Sie das System Tester und Entwickler √ºber einen scheinbaren √úberschuss an Randbedingungen informieren. Programmierer und Tester sehen im Entwicklungsprozess, welche Aufgaben das System laden.  Dies wird Probleme in den fr√ºhen Stadien ihres Auftretens l√∂sen. <br><br>  Nehmen Sie sich Zeit, um den Testern die Funktionsweise des Datenaustauschsystems zu erkl√§ren, ihnen Metriken anzuzeigen und zu erkl√§ren. Sie werden √ºberrascht sein, dass sie feststellen, wenn im Netzwerkcode unvermeidlich seltsame Fehler auftreten. <br><br>  Im Allgemeinen sollten Metriken die folgenden Eigenschaften haben: <br><br><ul><li>  Seien Sie f√ºr Tester lesbar und verst√§ndlich </li><li>  Zeigen Sie Engp√§sse, Bremsen und Probleme an </li><li>  Geringe Auswirkungen auf die Ausf√ºhrung und st√§ndige Einf√ºhrung. </li></ul><br>  <strong><em>Entwicklerschulung.</em></strong>  Es ist sehr schwierig, Programmierern, die es gewohnt sind, Einzelbenutzeranwendungen zu erstellen, beizubringen, √ºber die Trennung zwischen Geben, Empfangen und Verarbeiten eines Befehls nachzudenken.  Es ist leicht zu vergessen, dass Sie nach etwas fragen k√∂nnen, das nicht passiert ist, oder was einige Sekunden nach der Befehlsausgabe passieren kann.  Befehle m√ºssen sowohl beim Senden als auch beim Empfang auf ihre Richtigkeit √ºberpr√ºft werden. <br><br>  In einem synchronen Modell m√ºssen Programmierer auch ber√ºcksichtigen, dass der Code innerhalb der Simulation nicht von lokalen Faktoren abh√§ngen sollte (z. B. Verf√ºgbarkeit von Freizeit, Spezialausr√ºstung oder anderen Einstellungen).  Die Codeausf√ºhrung auf allen Computern muss √ºbereinstimmen.  Beispielsweise kann das Vorhandensein zuf√§lliger Gel√§ndet√∂ne in einer Simulation zu einem unterschiedlichen Spielverhalten f√ºhren. <br><br>  <strong><em>Andere Lektionen.</em></strong>  Dies sollte der √ºbliche gesunde Menschenverstand sein. Wenn Sie jedoch von einem Netzwerk eines Drittanbieters abh√§ngig sind (in unserem Fall DirectPlay), schreiben Sie eine unabh√§ngige Testanwendung, in der best√§tigt wird, dass die Nachrichten, wenn die Eigent√ºmer "garantierte Zustellung" beanspruchen, tats√§chlich die "garantierte Paketbestellung" erhalten. in der Tat gibt es und dass das Produkt keine versteckten Engp√§sse oder seltsames Verhalten bei der Verarbeitung der √ºbertragenen Daten in Ihrem Spiel hat. <br><br>  Machen Sie sich bereit, Simulationsanwendungen und Stresstestsimulatoren zu erstellen.  Am Ende haben wir drei verschiedene Minimal-Testanwendungen erstellt, mit denen einzelne und wichtige Probleme untersucht werden: Verbindungsfluten, Probleme mit gleichzeitigen Verbindungen bei der Auswahl von Gegnern und Verlust garantierter Pakete. <br><br>  Testen Sie so fr√ºh wie m√∂glich mit Modems (und mit etwas Gl√ºck mit Modemsimulatoren).  Setzen Sie die Modemtests (egal wie schmerzhaft sie auch sein m√∂gen) w√§hrend des gesamten Entwicklungsprozesses fort.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich sind die Probleme schwer zu isolieren (was ist der Grund f√ºr den starken Geschwindigkeitsabfall - Anbieter, Spiel, Kommunikationssoftware, Modem, konkurrierender Suchdienst f√ºr ein Match oder etwas anderes?), Und Benutzer m√∂chten sich nicht mit langsamen DF√ú-Verbindungen herumschlagen und sich an sofortige LAN-Geschwindigkeiten gew√∂hnen . </font><font style="vertical-align: inherit;">Es ist wichtig, dass Sie Modemverbindungen mit der gleichen Best√§ndigkeit wie bei LAN-Spielen f√ºr mehrere Spieler testen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4b/f84/6f8/f4bf846f89de72b3374179b174094cc8.jpg" alt="Bild"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserungen f√ºr </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires 2</font></font></em> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires 2: Das Zeitalter der K√∂nige haben</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir Mehrbenutzerfunktionen wie Spielaufzeichnung, Datei√ºbertragung und st√§ndige Verfolgung von Statistiken auf der The Zone-Website hinzugef√ºgt. Wir haben auch Multiplayer-Systeme wie DirectPlay-Integration und Geschwindigkeitskontrolle verbessert, um die nach der Ver√∂ffentlichung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> festgestellten Fehler und Geschwindigkeitsprobleme zu beheben </font><font style="vertical-align: inherit;">.</font></font><br><br>        ,     ,      ¬´¬ª .      -.        ,      ,    .      .            ,   ,        ,        . <br><br>       ()  The Zone    <em>Age of Empires</em>   .  <em>Age of Kings</em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben es erweitert, und so konnten wir die Startparameter steuern und st√§ndige Berichte √ºber Statistiken erstellen. </font><font style="vertical-align: inherit;">Dies erm√∂glichte es den Spielern, Spiele, an denen sie interessiert waren, besser zu finden, da sie die Matchmaking-Level-Parameter sehen konnten und nicht darauf warten mussten, dass die Spieleinstellungen zum Bildschirm mit den Spieleinstellungen gelangen. </font><font style="vertical-align: inherit;">Im Backend haben wir st√§ndige Berichts- und Nachverfolgungsstatistiken implementiert. </font><font style="vertical-align: inherit;">Wir haben The Zone mit einer gemeinsamen Struktur versehen, die am Ende des Spiels ausgef√ºllt und auf den Server √ºbertragen wurde. </font><font style="vertical-align: inherit;">Die Daten aus dieser Struktur wurden verwendet, um Benutzerbewertungen zu erstellen und diese auf der The Zone-Website anzuzeigen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b89/ec7/ef8/b89ec7ef8b25272c8d6e35e6b1593f7d.jpg" alt="Bild"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RTS3 Multiplayer: Aufgaben </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTS3 ist der Codename f√ºr das Strategiespiel Ensemble der n√§chsten Generation </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ca. Per: Das Spiel wurde unter dem Namen Age of Mythology ver√∂ffentlicht)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die RTS3-Struktur basiert auf der erfolgreichen Formel der Age of Empires-Spieleserie und enth√§lt viele neue Funktionen und Anforderungen f√ºr den Mehrbenutzermodus.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basierend auf den Funktionen von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Age of Empires 1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Obligatorische Anforderungen wie das Spielen im Internet, gro√üe und abwechslungsreiche Karten, Tausende von verwalteten Einheiten.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3D: RTS3 ist ein vollst√§ndig dreidimensionales Spiel mit interpolierten Animationen und nicht diskreten Positionen und Einheitenrotationen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mehr Spieler - Unterst√ºtzung f√ºr mehr als acht Spieler. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TCP / IP-Unterst√ºtzung: Unser Hauptziel ist eine 56 / kbps-TCP / IP-Internetverbindung. </font></font></li><li>    ‚Äî     ,      NAT. </li></ul><br>      RTS3         ,    <em>Age of Empires 1</em>  <em>2</em> ‚Äî   ‚Äî    RTS3       .  <em>AOE/AOK</em>         DirectPlay,   RTS3     ,        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der √úbergang zu einer vollst√§ndig dreidimensionalen Welt bedeutet, dass wir Probleme mit der Bildrate und der allgemeinen Gl√§tte der Simulation im Mehrbenutzermodus st√§rker ber√ºcksichtigen m√ºssen. Dies bedeutet jedoch auch, dass die Aktualisierungszeit der Simulationssituation und die Bildrate noch st√§rker variieren und wir mehr Zeit f√ºr das Rendern aufwenden m√ºssen. In der Genie-Engine waren die Rotationen der Einheiten diskret und die Animationen an die Bildrate in BANG gebunden! Beliebige Einheitenrotation und sanfte Animation sind m√∂glich, dh das Spiel reagiert visuell viel empfindlicher auf den Einfluss von Verz√∂gerungen und Spr√ºngen in der Aktualisierungsfrequenz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das </font><em><font style="vertical-align: inherit;">Zeitalter der K√∂nige</font></em><font style="vertical-align: inherit;"> abschlie√üen</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wollten diese kritischen Bereiche angehen, in denen durchdachtes Design und die Arbeit mit Tools die Debugging-Zeit erheblich verk√ºrzen w√ºrden. </font><font style="vertical-align: inherit;">Wir haben auch erkannt, wie wichtig der iterative Testprozess f√ºr das Design unserer Spiele ist, daher wurde dem fr√ºhestm√∂glichen Abschluss des Online-Spiels eine hohe Priorit√§t einger√§umt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RTS3-Kommunikationsarchitektur </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66a/92d/4a9/66a92d4a984730fcf03a9a392945afb7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 6. Die strikte objektorientierte Netzwerkarchitektur von RTS3. </font></font></i> <br><br> <strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektorientierter Ansatz. </font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Netzwerkarchitektur von RTS3 ist stark objektorientiert (siehe Abbildung 6). </font><font style="vertical-align: inherit;">Mit den Supportanforderungen f√ºr verschiedene Netzwerkkonfigurationen k√∂nnen Sie den OO-Ansatz nutzen, der von den Besonderheiten der Plattform, des Protokolls und der Topologie abstrahiert ist, die einer Reihe verallgemeinerter Objekte und Systeme zugrunde liegen.</font></font><br><br>              .         .          ,       (,    ,         -).     (  Channels, TimeSync  ..)   ,               . <br><br> <strong><em> .</em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Genie-Engine unterst√ºtzte eine Peer-to-Peer-Netzwerktopologie, in der alle Clients in einer Sitzung in einer Sternkonfiguration miteinander verbunden sind. </font><font style="vertical-align: inherit;">In RTS3 haben wir diese Topologie weiterhin verwendet, da sie bei Implementierung mit einem synchronen Simulationsmodell inh√§rente Vorteile bietet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Peer-to-Peer-Topologie impliziert die Verwendung einer Sternkonfiguration f√ºr verbundene Clients in einer Sitzung (Abbildung 7). </font><font style="vertical-align: inherit;">Das hei√üt, jeder Client ist mit allen anderen Clients verbunden. </font><font style="vertical-align: inherit;">Das gleiche Schema wurde im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alter von 1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angewendet </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f35/d91/d21/f35d91d21ae3a744d54db202a3710ed4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 7. Sternkonfiguration von Peer-Clients in einer Sitzung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peer-to-Peer-Vorteile:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verringerte Latenz aufgrund des Client-zu-Client-Messaging-Schemas anstelle des Client-Server-Client. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt kein zentrales schwaches Glied - wenn der Client (sogar der Host) die Verbindung zur Sitzung trennt, kann das Spiel fortgesetzt werden. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peer-to-Peer-Nachteile: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aktivere Verbindungen im System (Summe von n = 0 bis k-1 (n)), dh mehr potenzielle schwache Glieder und h√∂here wahrscheinliche Verz√∂gerungen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Unf√§higkeit, einige NAT-Konfigurationen in einem solchen Schema zu unterst√ºtzen. </font></font></li></ul><br> <strong><em>Net.lib.</em></strong>      RTS3     ,     ,         ,       ,        .    ,    ,     ,    ,       ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abf/0cc/057/abf0cc057404cbf9c580d39155c9aff9.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 8. Vier Schichten von Diensten in unserem Netzwerkmodell.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RTS3 basiert auf unserer BANG Engine! Eine neue Generation, die eine modulare Architektur mit Komponentenbibliotheken wie Sound, Rendering und Netzwerk verwendet. Das Netzwerk-Subsystem ist hier als Komponente integriert, aber mit der BANG-Engine verbunden! (sowie mit verschiedenen hauseigenen Werkzeugen). Unser Netzwerkmodell ist in vier Service-Schichten unterteilt, die dem im Spiel verwendeten OSI-Netzwerkmodell fast, aber nicht vollst√§ndig √§hnlich sind (siehe Abbildung 8). </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Socken Level 1</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Ebene, Socks, bietet eine grundlegende API auf Socket-Ebene in C. Sie wird abstrahiert, um einen generischen Satz von Netzwerkprozeduren auf niedriger Ebene f√ºr viele Betriebssysteme zu erstellen. Die Schnittstelle √§hnelt der Berkeley-Socket-Schnittstelle. Die Socks-Schicht wird haupts√§chlich von h√∂heren Schichten der Netzwerkbibliothek verwendet und ist eigentlich nicht f√ºr die Verwendung durch Anwendungscode vorgesehen. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link, Level 2</font></font></u> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Level 2, Link, bietet Transportschichtdienste. Objekte auf dieser Ebene, wie z. B. Link, Listener, NetworkAddress und Packet, sind n√ºtzliche Elemente, um eine Verbindung herzustellen und Nachrichten dar√ºber zu senden (siehe Abbildung 9).</font></font><br><br><ul><li> <strong>Packet ():</strong>      ‚Äî  ,    / (    )     . </li><li> <strong>Link ():</strong>      .       ,           .  send  receive  ,    ,      void*. </li><li> <strong>Listener ():</strong>  .           . </li><li> <strong>Data stream ( ):</strong>        , , ,   . </li><li> <strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netzadresse </font><strong><font style="vertical-align: inherit;">: Eine</font></strong><font style="vertical-align: inherit;"> protokollunabh√§ngige Netzwerkadressierungseinheit.</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ping: Eine</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einfache Ping-Klasse. </font><font style="vertical-align: inherit;">Meldet eine Netzwerkverz√∂gerung bei der Kommunikation mit der Verbindung.</font></font></li><li><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a4/8a3/f76/0a48a3f7672c524404eab911ebd7d062.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 9. Verbindungsebene.</font></font></i> </li></ul><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multiplayer-Level 3</font></font></u> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Multiplayer-Level ist das h√∂chste Level an Objekten und Prozeduren, die in der net.lib-API vorhanden sind. </font><font style="vertical-align: inherit;">Dies ist die Ebene, mit der RTS3 interagiert, wenn Objekte einer niedrigeren Ebene wie Links gesammelt und in n√ºtzlichere Konzepte / Objekte konvertiert werden - Clients, Sitzungen usw. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die interessantesten Objekte in der BANG-Netzwerkbibliothek! </font><font style="vertical-align: inherit;">sind diejenigen, die sich im Multiplayer-Level befinden. </font><font style="vertical-align: inherit;">Hier bietet die API eine Reihe von Objekten, mit denen die Spielebene interagieren kann, bietet jedoch eine vom Spielansatz unabh√§ngige Implementierung.</font></font><br><br><ul><li> <strong>Client ():</strong>      .       ()     (  ).    ,    . </li><li> <strong>Session ():</strong>  ,   ,  ,    .       .        host()  join(),    ,   ,     .       / ,           . </li><li> <strong>Channel  Ordered Channel:</strong>        .              .      TimeSync,            . </li><li> <strong>Shared Data:</strong>        .        ,     ,                . </li><li> <strong>Time Sync:</strong>           . </li></ul><br> <u>Game Communications,  4</u> <br><br>      RTS3.    ,       ,     .               ,       ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/d8a/f3b/0acd8af3b2f9d73984b7afda314f0e6e.jpg" alt="Bild"></div><br><h2>      </h2><br>  <strong><em>Verbessertes Synchronisationssystem.</em></strong>  Keines der <em>Age of Empires-</em> Entwicklungsteams kann sagen, dass wir keine besseren Synchronisationstools ben√∂tigen.  Wie bei jedem Projekt stellt sich bei der Analyse des Entwicklungsprozesses im Post-Mortem-Bereich heraus, dass die meiste Zeit in einigen Bereichen verbracht wurde, aber es k√∂nnte viel weniger sein, wenn wir sie im Voraus angehen.  Zu Beginn der Entwicklung von RTS3 stand das Debuggen der Synchronisation ganz oben auf der Liste dieser Bereiche. <br><br>  Das RTS3-Synchronisationsverfolgungssystem zielt haupts√§chlich darauf ab, Synchronisationsfehler schnell zu erkennen.  Weitere Priorit√§ten waren die Vereinfachung der Verwendung, die F√§higkeit, beliebig gro√üe Mengen synchronisierter Daten zu verarbeiten, die durch das System geleitet werden, die F√§higkeit, den Synchronisationscode im Release-Build vollst√§ndig zu kompilieren, und schlie√ülich die F√§higkeit, die Testkonfiguration durch √Ñndern von Variablen vollst√§ndig zu √§ndern, anstatt sie vollst√§ndig neu zu kompilieren. <br><br>  Die Synchronisationspr√ºfung in RTS3 wird mit zwei Makros√§tzen durchgef√ºhrt: <br><br> <code>#define syncRandCode(userinfo) <br> gSync-&gt;addCodeSync(cRandSync, userinfo, __FILE__, __LINE__) <br></code> <br><br> <code>#define syncRandData(userinfo, <br> v) gSync-&gt;addDataSync(cRandSync, v, userinfo, __FILE__, __LINE__)</code> <br> <br>  Beide Makros erhalten den Zeichenfolgenparameter userinfo, der den Namen oder die Angabe eines bestimmten synchronisierten Elements darstellt.  Ein Synchronisationsaufruf k√∂nnte beispielsweise folgenderma√üen aussehen: <br><br> <code>syncRandCode("syncing the random seed", seed);</code> <br> <br>  <em><strong>Synchrone Konsolenbefehle und Konfigurationsvariablen.</strong></em>  Wie jeder <em>Quake-</em> Mod-Entwickler best√§tigen kann, sind Konsolenbefehle und Konfigurationsvariablen f√ºr den Entwicklungsprozess sehr wichtig.  Konsolenbefehle sind einfache Funktionsaufrufe, die mithilfe der Startkonfigurationsdatei, der In-Game-Konsole oder der Benutzeroberfl√§che ausgef√ºhrt werden und beliebige Spielfunktionen aufrufen.  Konfigurationsvariablen sind benannte Datentypen, die durch die einfachen Funktionen get, set, define und toggle bereitgestellt werden, die wir f√ºr alle Arten von Tests und Einstellungskonfigurationsparametern verwenden. <br><br>  Paul hat Multiplayer-kompatible Versionen unserer Konsolenbefehlssysteme und variablen Konfigurationen erstellt.  Mit ihrer Hilfe k√∂nnen wir eine regul√§re Konfigurationsvariable (z. B. enableCheating) bequem in eine Multiplayer-Konfigurationsvariable umwandeln, indem wir der Definition der Konfigurationsvariablen ein Flag hinzuf√ºgen.  Wenn dieses Flag aktiviert ist, wird die Konfigurationsvariable innerhalb des Mehrspielerspiels √ºbertragen, und synchronisierte Entscheidungen im Spiel (z. B. √ºber die Zul√§ssigkeit der freien √úbertragung von Ressourcen) k√∂nnen auf ihrem Wert basieren.  Konsolenbefehle des Multiplayers haben ein √§hnliches Prinzip: Aufrufe der Konsolenbefehle des Multiplayers werden √ºber das Netzwerk √ºbertragen und auf allen Client-Computern synchron ausgef√ºhrt. <br><br>  Mit diesen beiden Tools k√∂nnen Entwickler das Multiplayer-System verwenden, ohne Code schreiben zu m√ºssen.  Sie k√∂nnen schnell neue Test- und Konfigurationstools hinzuf√ºgen und diese einfach in eine Netzwerkumgebung integrieren. <br><br><h2>  Zusammenfassend </h2><br>  Die synchronisierte Simulation und das Peer-to-Peer-Modell wurden in der Age of Empires-Spieleserie erfolgreich eingesetzt.  Trotz der entscheidenden Bedeutung, Zeit in die Erstellung von Tools und Technologien zur L√∂sung der Hauptprobleme dieses Ansatzes (wie Synchronisation und Netzwerkmetriken) zu investieren, wurde die Realisierbarkeit dieser Architektur im Genre der Echtzeitstrategien durch Erfahrung bewiesen.  Nachfolgende Verbesserungen an RTS3 f√ºhrten dazu, dass das Multiplayer-Gameplay selbst unter den schrecklichsten Bedingungen von Netzwerkverbindungen kaum von Einzelspielern zu unterscheiden ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417703/">https://habr.com/ru/post/de417703/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417689/index.html">Mobio spricht mit Appnext CEO √ºber CPI-Markt und Trends bei mobilen Anwendungen</a></li>
<li><a href="../de417691/index.html">Unser B√ºcherregal ist ein C # -Programmierer. Was ist mit dir?</a></li>
<li><a href="../de417697/index.html">Einfacher Bildeditor auf VueJS</a></li>
<li><a href="../de417699/index.html">Western Digital schlie√üt eine weitere Festplattenfabrik aufgrund geringerer Nachfrage</a></li>
<li><a href="../de417701/index.html">Von einfachen Skripten bis hin zu Do-it-yourself-Client-Server-Anwendungen auf WCF: Warum ich gerne in CM arbeite</a></li>
<li><a href="../de417705/index.html">Wie ein Grafikkartenhersteller die Rentabilit√§t des GPU-Mining beeinflusst</a></li>
<li><a href="../de417709/index.html">Wo und wie bewerten Entwickler ihre Arbeitgeber? Unternehmensbewertungsdienste in der IT-Branche</a></li>
<li><a href="../de417711/index.html">Was kann man auf Swift auf Russisch lesen?</a></li>
<li><a href="../de417715/index.html">Auf Wiedersehen Google Maps</a></li>
<li><a href="../de417717/index.html">Wie war die Erde, als es so hei√ü war, wie es uns 2100 versprochen wurde?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>