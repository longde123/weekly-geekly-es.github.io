<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏻 💆🏼 🏻 Théorie au lieu d'heuristique: s'améliorer en tant que développeurs frontend 🚐 👆🏼 🗒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Devenir un meilleur développeur front-end en utilisant les fondamentaux au lieu de l'heuristique 

 Notre expérience montre que les éducateurs non tec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Théorie au lieu d'heuristique: s'améliorer en tant que développeurs frontend</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/458642/"><img src="https://habrastorage.org/getpro/habr/post_images/424/ed0/eec/424ed0eec08450f6be205e19896298a7.png"><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Devenir un meilleur développeur front-end en utilisant les fondamentaux au lieu de l'heuristique</a></i> <br><br>  Notre expérience montre que les éducateurs non techniques et les autodidactes s'appuient souvent non pas sur des principes théoriques, mais sur des méthodes heuristiques. <br><br>  Heuristique - modèles et règles éprouvées qu'un développeur a appris de la pratique.  Ils peuvent fonctionner imparfaitement ou de manière limitée, mais dans une mesure suffisante, et ne nécessitent pas de réflexion sérieuse.  Voici quelques exemples d'heuristiques: <br><br><ul><li> "Utilisez <code>$(document).ready(function(){})</code> pour initialiser le code sur les sites jQuery" </li><li>  "Le <code>var self = this</code> construction est nécessaire pour appeler une méthode dans une fonction de rappel" </li><li>  «Les fonctions fléchées n'ont pas d' <code>return</code> » <br></li></ul><br>  En même temps, le principe théorique peut être utilisé pour trouver des solutions à d'autres problèmes.  Il est invariablement fidèle et détermine souvent l'appareil même de l'un ou l'autre élément.  Les principes théoriques comprennent, par exemple: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La syntaxe officielle des fonctions fléchées</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation de l'API Lodash</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Règles d'utilisation et fonctions d'alignement vertical</a> <br></li></ul><br>  A noter: nous n'avons cité que des exemples heuristiques afin de souligner le caractère artisanal de l'heuristique par rapport à la rigueur des fondements théoriques.  Aucun des exemples heuristiques n'est universel dans tous les cas, mais ils fonctionnent dans un nombre suffisant de situations pour que les développeurs qui les utilisent reçoivent du code de travail sans une compréhension complète de son fonctionnement. <br><a name="habracut"></a><br><h2>  Arguments pour une approche théorique </h2><br>  Nous avons souvent rencontré le fait que les développeurs sans formation technique ne sont pas enclins à résoudre des problèmes en utilisant des principes théoriques.  En règle générale, cela s'explique par le fait qu'au début de leur carrière, ils n'ont pas eu l'occasion de les apprendre, et comme les méthodes heuristiques fonctionnent de manière satisfaisante, ils continuent de les utiliser. <br><br>  Cependant, malgré l'apparente complexité, l'apprentissage d'une théorie peut être très utile.  Pourquoi?  Ensuite, cette théorie vous permettra de vous sentir confiant que votre solution fonctionne, ainsi que d'afficher indépendamment les réponses aux nouvelles questions, sans avoir à chercher les solutions de quelqu'un d'autre.  À court terme, les algorithmes heuristiques peuvent sembler être une solution simple et rapide, mais ils conduisent souvent à des solutions imparfaites - voire pas du tout. <br><br>  De plus, en s'appuyant sur des méthodes heuristiques, vous n'apprendrez jamais à résoudre des problèmes pour de vrai.  Vous pouvez souvent réussir à trouver une solution de travail, mais tôt ou tard, vous arriverez à un arrêt, dont vous ne verrez pas d'issue.  Les programmeurs C&amp;P s'appuient sur l'heuristique dans leur travail. <br><br><h2>  Critères de niveau de compétence du développeur </h2><br>  Lors des entretiens avec les développeurs frontend, nous leur avons défini une tâche de programmation et leur avons dit qu'ils étaient libres d'utiliser toutes les sources, que ce soit Google ou Stack Overflow.  De cette façon, il est facile de déterminer si le développeur est un adepte de l'heuristique ou de la théorie. <br><br>  Les premiers, sans exception, copient du code à partir d'exemples plus ou moins adaptés avec Stack Overflow.  Ce n'est que lorsque le code ne fonctionne pas comme prévu qu'ils ont commencé à le peaufiner eux-mêmes.  Souvent, ils échouent. <br><br>  Ces derniers ont tendance à rechercher des réponses dans la documentation de l'API.  Ils y trouvent des informations sur le nombre de paramètres pris par une fonction particulière, ou la syntaxe spécifique de la forme développée de la propriété CSS souhaitée. <br><br>  Dès les cinq premières minutes de l'entretien, vous pouvez déterminer exactement à quel type de programmeurs appartient le candidat. <br><br><h2>  Exemple </h2><br>  Prenons Bill comme exemple.  Il a suivi plusieurs cours de formation, résolu un certain nombre de tâches en JavaScript et écrit des sites Web pendant son temps libre, mais il n'a pas vraiment appris JavaScript. <br><br>  Une fois que Bill tombe sur un objet comme celui-ci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> usersById = { <span class="hljs-string"><span class="hljs-string">"5"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adam"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"27"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"27"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bobby"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"32"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Clarence"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-string"><span class="hljs-string">"39"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"39"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Danielle"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"42"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ekaterina"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre><br>  Un tel objet peut afficher une liste d'utilisateurs et s'ils se sont inscrits à un événement particulier. <br><br>  Supposons que Bill doive récupérer une liste d'utilisateurs enregistrés.  En d'autres termes, filtrez-les.  Il est tombé sur du code dans lequel la méthode <code>.filter()</code> été utilisée pour filtrer la liste.  Il essaie donc quelque chose comme: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = usersById.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered);</code> </pre> <br>  Et voici ce qu'il obtient: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: usersById.filter is not a <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br>  "Quelque chose de non-sens", pense Bill, car il a vu le code dans lequel <code>.filter()</code> fonctionnait comme un filtre. <br><br>  Le problème est que Bill s'est appuyé sur la méthode heuristique.  Il ne comprend pas que le <code>filter</code> est une méthode définie sur des tableaux, tandis que <code>usersById</code> est un objet normal qui n'a pas de méthode de <code>filter</code> . <br><br>  Le Bill confus google le « <i>filtre javascript</i> ».  Il trouve de nombreuses références aux tableaux et se rend compte qu'il doit transformer <code>usersById</code> en tableau.  Puis, en demandant « <i>javascript pour transformer un objet en tableau</i> », il trouve des exemples en utilisant <code>Object.keys()</code> sur Stack Overflow.  Après cela, il essaie: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered);</code> </pre> <br>  Cette fois, l'erreur ne s'affiche pas, mais, à la surprise de Bill, le champ des <code>attendees</code> reste vide. <br><br>  Le fait est que <code>Object.keys()</code> renvoie les clés de l'objet, mais pas sa valeur.  En fait, le nom de la variable <code>user</code> est facilement trompeur, car ce n'est pas un objet <code>user</code> , mais un identifiant, c'est-à-dire une chaîne.  Étant donné que l'attribut <code>registered</code> n'est pas défini pour les chaînes, le <code>filter</code> traite chaque entrée comme faux et le tableau reste vide. <br><br>  Bill examine de plus près les réponses Stack Overflow et apporte la modification suivante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id].registered);</code> </pre> <br>  Cette fois, le résultat est meilleur: <code>["5", "27", "39"]</code> .  Mais Bill voulait obtenir des objets visiteurs, pas leur carte d'identité. <br><br>  Pour comprendre comment filtrer les visiteurs, Bill ennuyé recherche un « <i>filtre d'objet javascript</i> », examine les résultats de la recherche pour Stack Overflow et trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette réponse</a> avec le code suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.filter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, predicate</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj) .filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function"> =&gt;</span></span> predicate(obj[key]) ) .reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, key</span></span></span><span class="hljs-function">) =&gt;</span></span> (res[key] = obj[key], res), {} );</code> </pre> <br>  Bill copie ces lignes et essaie: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.filter(usersById, user =&gt; user.registered);</code> </pre> <br>  Tout fonctionne - bien qu'il ne soit pas clair pourquoi.  Le projet de loi ne comprend pas pourquoi la <code>reduce</code> nécessaire et comment elle est utilisée.  De plus, Bill ne comprend pas qu'il vient de définir une nouvelle méthode non standard pour l' <code>Object</code> global. <br><br>  Mais Bill s'en fiche - ça marche!  Les conséquences ne l'intéressent pas encore. <br><br><h2>  Qu'est-ce que Bill a fait de mal? </h2><br>  Bill a essayé une méthode heuristique pour résoudre le problème et a rencontré les problèmes suivants: <br><br><ol><li>  En utilisant <code>.filter()</code> sur une variable, Bill a obtenu une <code>TypeError</code> .  Il n'a pas compris que le <code>filter</code> pas défini sur des objets ordinaires. <br></li><li>  Il a utilisé <code>Object.keys()</code> pour «transformer l'objet en un tableau», mais cela seul n'a donné aucun résultat.  Il avait besoin de créer un tableau de valeurs d'objets. </li><li>  Même après avoir reçu les valeurs et les avoir utilisées comme condition de filtrage, il n'a reçu que des identifiants au lieu des objets utilisateur associés à ces identifiants.  En effet, le tableau filtré contenait un ID, pas des objets utilisateur. </li><li>  Au fil du temps, Bill a abandonné cette approche et a trouvé une solution de travail sur Internet.  Néanmoins, il n'a toujours pas compris comment cela fonctionne - et ne perdra pas de temps à le trier, car il a d'autres choses à faire. <br></li></ol><br>  C'est un exemple artificiel, mais nous avons rencontré de nombreux développeurs qui résolvent les problèmes de la même manière.  Pour les résoudre efficacement, vous devez vous éloigner des méthodes heuristiques et étudier la théorie. <br><br><h2>  Passons aux bases </h2><br>  Si Bill était un partisan d'une approche théorique, le processus ressemblerait à ceci: <br><br><ol><li>  Pour identifier les données d'entrée données et déterminer la sortie souhaitée - au sens de leurs propriétés: <i>«J'ai un objet dont les clés sont des chaînes représentant l'ID et les valeurs sont des objets représentant les utilisateurs.</i>  <i>Je veux obtenir un tableau dont les valeurs seront des objets utilisateur - mais uniquement des objets d'utilisateurs enregistrés »</i> </li><li>  Pour comprendre comment rechercher à l'intérieur d'un objet: <i>«Je sais que je peux obtenir un tableau de clés dans un objet en appelant <code>Object.keys()</code> .</i>  <i>Je veux obtenir un tableau car les tableaux prennent en charge l'énumération</i> . <i>"</i> </li><li>  Pour se rendre compte que cette méthode aide à obtenir les clés, et que vous devez transformer les clés en valeurs, et rappelez-vous de la <code>map</code> - une méthode évidente de création d'un nouveau tableau en transformant les valeurs d'un autre tableau: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id])</code> </pre> </li><li>  Pour voir que vous disposez maintenant d'un tableau d'objets utilisateur pouvant être filtré et contenant des valeurs réelles que vous souhaitez filtrer: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id]).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered)</code> </pre> </li></ol><br>  Allez Bill de cette façon, il pourrait travailler pour nous. <br><br><h2>  Pourquoi les gens ne recourent-ils pas plus souvent à la théorie? </h2><br>  Parfois, ils ne la connaissent tout simplement pas.  Le plus souvent, ils sont trop occupés et ne trouvent pas le temps d'apprendre cette façon de résoudre les problèmes - ils ont juste besoin de tout pour fonctionner.  Ils risquent de transformer cette approche en une habitude qui deviendra un obstacle au développement de leurs compétences. <br><br>  Pour éviter de telles erreurs, commencez toujours par une théorie.  À chaque étape du processus, réfléchissez au type de données que vous traitez.  Au lieu de s'appuyer sur des modèles familiers tout le temps, pensez aux types de données primitifs: tableau, objet, chaîne, etc.  Lorsque vous utilisez une fonction ou une méthode, reportez-vous à la documentation pour savoir exactement quels types de données les prennent en charge, quels arguments ils prennent et quel est le résultat. <br><br>  Avec cette approche, vous pouvez trouver une solution de travail dès le premier essai.  Vous pouvez être sûr de son exactitude, car vous avez spécialement sélectionné vos actions en fonction de l'entrée donnée et de la sortie souhaitée.  Approfondissez les bases de chaque opération (types de données et valeurs de retour), plutôt que les formulations commerciales floues (comme les "utilisateurs enregistrés"). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458642/">https://habr.com/ru/post/fr458642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458632/index.html">Vue vraiment typée</a></li>
<li><a href="../fr458634/index.html">«D̶o̶n̶'̶t be evil» ou ce que Facebook nous cache</a></li>
<li><a href="../fr458636/index.html">Cassettes vidéo de mitap DevLeads du bureau Tutu.ru</a></li>
<li><a href="../fr458638/index.html">Projet Intel oneAPI: de nombreuses architectures, une API</a></li>
<li><a href="../fr458640/index.html">Trouver un long tableau de bord</a></li>
<li><a href="../fr458646/index.html">Atomic Swaps en bref</a></li>
<li><a href="../fr458648/index.html">CI / CD avec AWS et Bamboo</a></li>
<li><a href="../fr458650/index.html">Cyber ​​Challenge. Un nouveau niveau. Concours en ligne de Rostelecom Solar</a></li>
<li><a href="../fr458652/index.html">RamblerFront et Meetup # 7</a></li>
<li><a href="../fr458654/index.html">Le virus Lurk a piraté des banques alors qu'il était écrit par des employés ordinaires</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>