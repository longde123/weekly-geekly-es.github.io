<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏼 👨‍👩‍👦‍👦 🎊 关于名称空间的一些事情 💘 ✉️ ⚡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我在用PHP编程。 还有一点关于JS 。 一旦我用Java编程，就可以使用LotusScript 。 尝试了python和dart的味道。 Basic ， Fortran ， Pascal ， Prolog ， VisualBasic ， ++ /  ， perl在所有这些上，我还描绘了一些可执行文...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于名称空间的一些事情</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434968/"><p>我在用<code>PHP</code>编程。 还有一点关于<code>JS</code> 。 一旦我用<code>Java</code>编程，就可以使用<code>LotusScript</code> 。 尝试了<code>python</code>和<code>dart</code>的味道。  <code>Basic</code> ， <code>Fortran</code> ， <code>Pascal</code> ， <code>Prolog</code> ， <code>VisualBasic</code> ， <code>++</code> / <code></code> ， <code>perl</code>在所有这些上，我还描绘了一些可执行文件。 编程语言使我对创建计算机应用程序感兴趣。  Web应用程序。 复杂的Web应用程序。 那些写彼此不熟悉的人。 更准确地说，他们本人并不熟悉-通过提交到公共存储库的签名和通过错误跟踪器的昵称彼此了解。 我不太聪明，无法在各种操作系统的<code></code> / <code>++</code>进行编程，因此我在<code>PHP</code>为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Magento进行</a>编程。 </p><br><p> 因此，回到本文的主题，我可以说<em>命名空间</em>是非常重要的支柱之一，在此基础上，编写<em>复杂的</em> Web应用程序是基于<em>一群</em>彼此不熟悉<em>的</em>开发人员。 </p><a name="habracut"></a><br><p> 在本文中，就<em>命名空间而言，</em>我的意思是从<code>PHP</code>的角度来看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命名空间</a> ，而不是从<code>python</code>的角度来看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命名空间</a> ： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Vendor</span></span>\<span class="hljs-title"><span class="hljs-title">Project</span></span>\<span class="hljs-title"><span class="hljs-title">Module</span></span>\<span class="hljs-title"><span class="hljs-title">Component</span></span>\<span class="hljs-title"><span class="hljs-title">Unit</span></span>;</code> </pre> <br><p> 当我尝试理解“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">package</a> ”指令的秘密时，我第一次遇到了一个命名空间： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.sun.source.util;</code> </pre> <br><p> 该指令的目的尚不清楚，如果可以指示任何行，则应在其中确切指出。 来自该语言作者的建议（在您的公司域中）用作注册的软件包名称的一部分，看上去有些奢侈。 现在每个人，每个人，每个人都有自己的域名，这样的建议并不是很尴尬，而15到20年前，我非常考虑要使用哪个域名作为我的第一个软件包的名称，以及它将来可能会影响什么。 直到后来，当我使用<code>maven</code>构建应用程序时，我<code>maven</code>这一建议的见解感到赞赏。 </p><br><h1 id="menedzhery-zavisimostey"> 依赖经理 </h1><br><p> 依赖性管理器帮助我理解了名称空间的含义。 如果您的代码使用第三方代码，而第三方代码依赖于其他依赖第三方程序包的程序包，则很难在此类转储中维持顺序。 尽管如此，正是由于使用<em>后域</em>规则来命名堆在一个目录（例如，在<code>WEB-INF/lib</code> ）中的一堆JAR中的软件包，所以导航起来非常容易： </p><br><p><img src="https://habrastorage.org/webt/sv/fd/hk/svfdhkknixvmrgj9b9kddl_12xg.png" alt="图片"></p><br><p> 与<code>npm</code> （ <code>JavaScript</code> ）比较： </p><br><p><img src="https://habrastorage.org/webt/0f/nu/c6/0fnuc6uadhda5grmfm-hzfk6vyc.png" alt="图片"></p><br><p> 在<code>Java</code>开发人员相当广泛地采用了程序包的“ <em>后域</em> ”名称（由于模块），而在<code>JS</code>则没有。 因此，在<code>Java</code>您可以独立创建大量无冲突的程序包（模块），而无需明确同意它们的名称作为独立的开发组；在<code>JS</code>您必须明确地使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm注册表</a> 。 是的，在<code>Java</code> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全局域注册表</a>隐式地涉及解决冲突，但是任何社区（不仅仅是<code>Java</code>编码器）都可以使用相同的命名规则。 </p><br><p> 在<code>PHP</code> ， <code>composer</code>依赖项管理器创建一个两级目录结构： <code>./company/module</code> ： </p><br><p><img src="https://habrastorage.org/webt/ez/xb/fe/ezxbfekemmejjmuf1ayer_tsouy.png" alt="图片"></p><br><p> 与单级分配相比，这在依赖项导航中提供了一些优势。 </p><br><p> 以下是<code>Java</code> / <code>JS</code> / <code>PHP</code>中央软件包存储库的统计信息： </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://mvnrepository.com/repos/central-3</a> 358 578个索引罐 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.npmjs.com/-872459</a>程序包 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://packagist.org/statistics-207560</a>包（1,472,944版本） </p><br><p> 对于<code>maven</code>最有可能的是，统计信息中会考虑所有模块版本，而<code>npm</code>和<code>composer</code>会考虑模块本身。 </p><br><h1 id="dlya-chego-nuzhno-prostranstvo-imyon"> 命名空间是什么？ </h1><br><p> 主要的答案是防止具有相同名称但在不同模块中的各种代码元素（常量，函数，类等）之间发生冲突。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python</a>名称空间成功地解决了这个问题。 但是我仍然在这里用引号将“命名空间”使用，因为 从本质上讲，它更接近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">范围</a> 。 </p><br><p> 首先，根据<code>Java</code> （ <code>package</code> ）和<code>PHP</code> （ <code>namespace</code> ）版本的<code>namespace</code>允许明确地寻址聚合社区中的特定代码元素。 这是名称空间（逻辑分组）的一个属性，它使得由开发者联系较少的组创建更复杂的软件系统成为可能。 </p><br><h1 id="adresaciya-programmnyh-elementov"> 寻址软件元素 </h1><br><p> 在<code>PHP</code>无论源代码如何连接到项目，都将唯一地寻址<code>\Doctrine\DBAL\Schema\Column</code>类。  IDE可以轻松地形成此地址。 在PhpStorm中，这是这样完成的（右键单击代码元素）： </p><br><p><img src="https://habrastorage.org/webt/ny/ax/h7/nyaxh7zwz5xbvgmr7anzsofpvye.png" alt="图片"></p><br><p> 如果您对<code>JS</code>代码（没有名称空间）应用类似的技术，则会丢失相同的PhpStorm。 让我们尝试以这种方式形成指向<code>JS</code> <code>query</code>函数的链接的地址： </p><br><p><img src="https://habrastorage.org/webt/8l/be/lg/8lbelgpjb7dqzt3570ubfeludhq.png" alt="图片"></p><br><p> 输出是<code>module.query</code> ，它的信息不足。 </p><br><p> 要解决文档中的<code>query</code>功能（信函，错误跟踪器等），您必须引用文件中的特定代码行： </p><br><p><img src="https://habrastorage.org/webt/zd/ik/hr/zdikhr5lbcvyegkhiwcffl-v2ku.png" alt="图片"></p><br><p> 结果： <code>./node_modules/express/lib/middleware/query.js:25</code> ： <code>./node_modules/express/lib/middleware/query.js:25</code> </p><br><p> 当然，当更改文件中的行数或移动/重命名文件时，我们将在文档中提供我们感兴趣的程序元素的过时地址。 </p><br><p> 因此，使用名称空间可以使与项目代码的各个元素的链接比与文件中的行的链接保持相关的时间更长。 </p><br><h1 id="obnaruzhenie-konfliktuyuschih-versiy-koda"> 检测有冲突的代码版本 </h1><br><p> 没有依赖管理器（ <code>maven</code> ， <code>composer</code> ， <code>npm</code> ，...），就无法开发现代复杂的应用程序。 同时，我们的依赖关系会拉动它们的依赖关系，拉动自己的依赖关系，依此类推，结果可能导致同一包通过不同的依赖关系（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">jar hell</a> ）出现版本冲突。 </p><br><p> 在<code>JS</code>由于缺少命名空间'ov而不会发生这种情况。 我自己遇到一种情况，当在<code>Magento</code>安装其他模块时，它们加载的<code>jQuery</code>库的不同版本数超过5-6。 一方面，这种行为为开发人员提供了更大的自由，另一方面，更多的自由对资格提出了更高的要求。 好吧，在如此多版本的依赖关系中寻找错误-限定条件比制造这些错误的限定条件要高一个或两个等级。 </p><br><p> 在<code>PHP</code>使用名称空间可以很容易地在IDE级别检测到此类冲突（例如，我制作了另一个文件，其中包含该类的副本）： </p><br><p><img src="https://habrastorage.org/webt/yz/li/9e/yzli9exmlbfiqewnp301xia_zee.png" alt="图片"></p><br><p> 因此，检测项目中重复代码元素的任务变得非常容易实现。 </p><br><h1 id="avtozagruzka-koda"> 代码启动 </h1><br><p>  <code>PHP</code>的<code>spl_autoload_register</code>函数使开发人员不必费心去<code>spl_autoload_register</code>带有其类源的文件所在的位置。 在任何项目中，您都可以覆盖此函数，并按类名实现自己的脚本加载算法。 在不使用命名空间的情况下，有必要为类写出卷曲的名称，以确保它们在复杂项目中的唯一性（尤其是考虑到第三方库）。 在<code>Zend1</code>用于数据库<code>Zend1</code>抽象适配器定义如下： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Zend_Db_Adapter_Abstract</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p> 为了确保唯一性，从本质上讲，有必要在类名称中添加名称空间。 当然，在代码中使用此类名称时，您必须睁大眼睛。 </p><br><p> 在<code>Zend2</code> ，已经使用了名称空间，类似的类定义如下所示： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">Db</span></span>\<span class="hljs-title"><span class="hljs-title">Adapter</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Adapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> ... </span></span>{}</code> </pre> <br><p> 代码最终变得更具可读性，但是使用名称空间的最重要结果是可以通过将类的逻辑层次结构绑定到文件结构来统一类加载器的功能。 以下是<code>./vendor/composer/autoload_namespaces.php</code>文件的摘录，该文件是<code>composer</code>在<code>PHP</code>创建的，以使<code>./vendor/autoload.php</code>加载程序正常工作： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $vendorDir = dirname(dirname(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)); $baseDir = dirname($vendorDir); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'Zend_'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($vendorDir . <span class="hljs-string"><span class="hljs-string">'/magento/zendframework1/library'</span></span>), <span class="hljs-string"><span class="hljs-string">'Yandex'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($vendorDir . <span class="hljs-string"><span class="hljs-string">'/allure-framework/allure-codeception/src'</span></span>, $vendorDir . <span class="hljs-string"><span class="hljs-string">'/allure-framework/allure-php-api/src'</span></span>, $vendorDir . <span class="hljs-string"><span class="hljs-string">'/allure-framework/allure-php-api/test'</span></span>), <span class="hljs-string"><span class="hljs-string">'Prophecy\\'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($vendorDir . <span class="hljs-string"><span class="hljs-string">'/phpspec/prophecy/src'</span></span>), <span class="hljs-string"><span class="hljs-string">'PhpOption\\'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($vendorDir . <span class="hljs-string"><span class="hljs-string">'/phpoption/phpoption/src'</span></span>), <span class="hljs-string"><span class="hljs-string">'PhpCollection'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($vendorDir . <span class="hljs-string"><span class="hljs-string">'/phpcollection/phpcollection/src'</span></span>), <span class="hljs-string"><span class="hljs-string">'PHPMD\\'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($vendorDir . <span class="hljs-string"><span class="hljs-string">'/phpmd/phpmd/src/main/php'</span></span>), <span class="hljs-string"><span class="hljs-string">'OAuth\\Unit'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($vendorDir . <span class="hljs-string"><span class="hljs-string">'/lusitanian/oauth/tests'</span></span>), <span class="hljs-string"><span class="hljs-string">'OAuth'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($vendorDir . <span class="hljs-string"><span class="hljs-string">'/lusitanian/oauth/src'</span></span>), ...</code> </pre> <br><p> 可以看出，不同库中的源可以以不同的方式定位（不同的模块内部结构），并且<code>composer</code>在形成项目时会创建一个在文件系统上叠加类的逻辑层次结构的映射。 命名空间在此叠加层中起着重要作用。 </p><br><p> 要评估该角色，只需尝试将一些<code>npm</code>模块分解为几个较小的模块，然后重建项目以使用两个新模块，而不是一个大模块即可。 顺便说一句， <code>ES6</code>中类的存在以及代码逻辑分组的意义上缺少名称空间，可能会导致出现与大型<code>ES6</code>项目中的<code>Zend1</code> （ <code>Module_Path_To_Class</code> ）类似的名称。 </p><br><h1 id="ioc">  IoC </h1><br><p>  IoC容器中对象的标识符是一个字符串（至少在<code>PHP</code> ）。 在简单的示例中，完全可以接受<code>dbAdapter</code> ， <code>serviceA</code> ， <code>serviceB</code>等标识符。 但是项目越大，就越难<code>searchFilterList</code>带有标识符的对象的创建位置，例如<code>searchFilterList</code>及其使用位置。 逻辑上的出路是使用类名作为对象的标识符。 在这种情况下，由容器创建对象的逻辑变得可以预测，并且源代码和使用位置由IDE进行基本确定。 命名空间使您可以在一个逻辑结构中组织所有项目类，并在使用容器创建对象时使用适当的路径。 </p><br><h1 id="rezyume"> 总结 </h1><br><p> 鉴于上述情况，我认为，与没有逻辑分组的语言相比，本机使用名称空间通过其元素的逻辑分组来自然地构造源代码的编程语言使您能够以更低的成本构建更复杂的应用程序。 因此，具有<code>JavaScript</code> / <code>Python</code> / <code>C</code> / ...相同资格的开发人员无法实现可以在<code>Java</code> / <code>PHP</code> / <code>C++</code> / ...中创建的应用程序的最大复杂性。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434968/">https://habr.com/ru/post/zh-CN434968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434956/index.html">IT公司正在成长，利润并不特别。 怎么办</a></li>
<li><a href="../zh-CN434960/index.html">井字游戏：演示DNA结构重新配置的受控过程</a></li>
<li><a href="../zh-CN434962/index.html">不，您在Node.js的REST API中不需要Express</a></li>
<li><a href="../zh-CN434964/index.html">足够的偏执狂或为什么您在Page Speed中不发光100点</a></li>
<li><a href="../zh-CN434966/index.html">新的Mash编程语言</a></li>
<li><a href="../zh-CN434970/index.html">关于IT业务等</a></li>
<li><a href="../zh-CN434972/index.html">如果您根本不喜欢如何编写单元测试</a></li>
<li><a href="../zh-CN434974/index.html">使用配置格式1C：企业</a></li>
<li><a href="../zh-CN434976/index.html">ITMO University Fablab：为有创造力的人提供DIY协作-显示内部内容</a></li>
<li><a href="../zh-CN434978/index.html">介绍HealthKit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>