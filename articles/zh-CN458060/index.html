<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏿 👩🏿‍🤝‍👨🏻 🍨 在Unity引擎中创建草着色器 🙄 👇🏿 🔄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本教程将向您展示如何编写几何着色器，以从传入网格的顶部生成草叶，并使用细分来控制草的密度。 

 本文介绍了在Unity中编写草着色器的分步过程。 着色器接收传入的网格，然后使用几何着色器从网格的每个顶点生成草叶。 为了有趣和现实起见，草叶的大小和旋转度是随机的 ，并且它们也会受到风的影响。 为了控...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity引擎中创建草着色器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458060/"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 本教程将向您展示如何编写几何着色器，以从传入网格的顶部生成草叶，并使用细分来控制草的密度。 <br><br> 本文介绍了在Unity中编写草着色器的分步过程。 着色器接收传入的网格，然后使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几何着色器</a>从网格的每个顶点生成草叶。 为了有趣和现实起见，草叶的<strong>大小</strong>和<strong>旋转度</strong>是<strong>随机的</strong> ，并且它们也会受到<strong>风的</strong>影响。 为了控制草的密度，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">细分</a>来分离传入的网格。 草将能够<strong>投射</strong>并<strong>接收</strong>阴影。 <br><br>  <strong>完成的项目</strong>将发布在文章的末尾。 生成的着色器文件包含大量注释，这些注释使理解变得更容易。 <br><a name="habracut"></a><br><h3> 要求条件 </h3><br> 要完成本教程，您将需要有关Unity引擎的实用知识以及对着色器语法和功能的初步了解。 <br><br>  <a href="">下载项目草案（.zip）</a> 。 <br><br><h2> 开始工作 </h2><br> 下载项目草稿，然后在Unity编辑器中将其打开。 打开<code>Main</code>场景，然后在代码编辑器中打开<code>Grass</code>着色器。 <br><br> 该文件包含一个产生白色的着色器，以及我们将在本教程中使用的一些功能。 您会注意到，这些功能以及顶点着色器都包含在<code>CGINCLUDE</code> <em>外部</em>的<code>CGINCLUDE</code>块<em>中</em> 。 放置在此块中的代码将<strong>自动包含在</strong>着色器的<strong>所有遍次</strong>中。 稍后将派上用场，因为我们的着色器将经过数次传递。 <br><br> 我们将从编写一个<strong>几何着色器</strong>开始，该<strong>着色器</strong>从网格表面上的每个顶点生成三角形。 <br><br><h2>  1.几何着色器 </h2><br> 几何着色器是渲染管线的可选部分。 它们<strong>在</strong>顶点着色器（如果使用镶嵌细分，则为镶嵌细分着色器）之后，在为片段着色器处理顶点之前执行。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/c01/458/ef7c01458cadf7cd0cf46695d7114f96.jpg"></div><br>  <i>Direct3D图形管道11.请注意，在此图中，片段着色器称为<em>pixel shader</em> 。</i> <br><br> 几何着色器在输入处接收单个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图元</a> ，并且可以生成零个，一个或多个图元。 我们将从编写一个几何着色器开始，该着色器在输入处接收一个<strong>顶点</strong> （或<em>点</em> ），并馈入<strong>一个</strong>代表草叶的<strong>三角形</strong> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block. struct geometryOutput { float4 pos : SV_POSITION; }; [maxvertexcount(3)] void geo(triangle float4 IN[3] : SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream) { } … // Add inside the SubShader Pass, just below the #pragma fragment frag line. #pragma geometry geo</span></span></code> </pre> <br> 上面的代码声明了一个带有两个参数的几何着色器，称为<code>geo</code> 。 第一个<code>triangle float4 IN[3]</code>报告将采用一个三角形（由三个点组成）作为输入。 第二个对象，例如<code>TriangleStream</code> ，设置了一个着色器以输出三角形的流，以便每个顶点都使用<code>geometryOutput</code>结构来传输其数据。 <br><br><div class="spoiler">  <b class="spoiler_title">上面我们说过，着色器将接收一个顶点并输出一草。</b>  <b class="spoiler_title">为什么然后我们得到一个三角形？</b> <div class="spoiler_text"> 将一个<code></code>作为输入将降低成本。 这可以如下进行。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point vertexOutput IN[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span></span></span></code> </pre> <br> 但是，由于我们的传入网格（在本例中为<code>GrassPlane10x10</code>文件夹中的<code>GrassPlane10x10</code> ）具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三角形拓扑</a> ，因此这将导致传入网格拓扑与所需的输入图元之间不匹配。 尽管DirectX HLSL中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">允许</a>这样做，但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenGL中不允许</a>这样做，因此将显示错误。 </div></div><br> 此外，我们在函数声明上方的方括号中添加了最后一个参数： <code>[maxvertexcount(3)]</code> 。 他告诉GPU，我们将输出（但不<strong>要求</strong>这样做） <em>不超过</em> 3个顶点。 我们还通过在<code>Pass</code>声明<code>SubShader</code>使用几何着色器。 <br><br> 我们的几何着色器尚未执行任何操作。 要绘制三角形，请在几何着色器中添加以下代码。 <br><br><pre> <code class="cpp hljs">geometryOutput o; o.pos = float4(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/534/ac1/0db534ac10c125955829fd53b9923cd7.gif"></div><br> 这给出了非常奇怪的结果。 当您移动相机时，很明显三角形在<strong>屏幕空间中</strong>呈现。 这是合乎逻辑的：由于几何着色器是在处理顶点之前立即执行的，因此它使顶点着色器无需承担顶点着色器在<strong>截断空间中</strong>显示的责任。 我们将更改代码以反映这一点。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the return call in the vertex shader. //return UnityObjectToClipPos(vertex); return vertex; … // Update each assignment of o.pos in the geometry shader. o.pos = UnityObjectToClipPos(float4(0.5, 0, 0, 1)); … o.pos = UnityObjectToClipPos(float4(-0.5, 0, 0, 1)); … o.pos = UnityObjectToClipPos(float4(0, 1, 0, 1));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/912/b3e/221912b3e6bc0581126a0f415b6e79c5.png"></div><br> 现在我们的三角形在世界上正确渲染了。 但是，似乎只创建了一个。 实际上，为网格的每个顶点<em>绘制</em>了一个三角形，但是分配给三角形顶点的位置是<strong>恒定的</strong> -它们对于每个传入的顶点都不会改变。 因此，所有三角形都位于另一个三角形的上方。 <br><br> 我们将通过使输出顶点位置相对于输入点<strong>偏移</strong>来解决此问题。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the top of the geometry shader. float3 pos = IN[0]; … // Update each assignment of o.pos. o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); … o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); … o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/ac4/84c/6b2ac484c5a033b18e88400e10191779.png"></div><br><div class="spoiler">  <b class="spoiler_title">为什么有些顶点不创建三角形？</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/447/d9c/cab447d9c4c82d8208a28e7cee2f7807.png"></div><br> 尽管我们确定传入的图元将是<strong>三角形</strong> ，但仅从三角形的<strong>一个</strong>点传输草叶，而丢弃其他两个点。 当然，我们可以从所有三个传入点转移草叶，但是这将导致以下事实：相邻的三角形过度地在彼此之上创建草叶。 <br><br> 或者，您可以通过将具有拓扑<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">点</a>类型的网格作为几何着色器的传入网格来解决此问题。 </div></div><br> 现在可以正确绘制三角形，并且三角形的底部位于发出三角形的峰值处。 在继续之前，请使<code>GrassPlane</code>对象在场景中<strong>处于非活动状态</strong> ，并使<code>GrassBall</code>对象<strong>处于活动状态</strong> 。 我们希望草能够在不同类型的表面上正确生成，因此在不同形状的网格上对其进行测试非常重要。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19b/f67/8fb/19bf678fbb6ce3c03956dbdf068004f0.png"></div><br> 而所有三角形均沿一个方向发射，而不是从球体表面向外发射。 为了解决这个问题，我们将在<strong>切线空间中</strong>创建草叶。 <br><br><h2>  2.切线空间 </h2><br> 理想情况下，我们希望通过设置不同的宽度，高度，曲率和旋转来创建草叶，而不考虑从中发出草叶的表面的角度。 简单地说，我们在发出<strong>该顶点的顶点局部</strong>的空间中定义一片草叶，然后对其进行变换，使其位于<strong>网格的局部</strong> 。 该空间称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">切线空间</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/8f7/c39/3fd8f7c394bf4eb18cb988aceafe342b.png"></div><br>  <i>在切线空间中，相对于曲面的法线和位置（在我们的情况下为顶点）定义<strong>X</strong>轴， <strong>Y</strong>轴和<strong>Z</strong>轴。</i> <br><br> 像任何其他空间一样，我们可以使用三个向量来定义顶点的切线空间： <strong>right</strong> ， <strong>forward</strong>和<strong>up</strong> 。 使用这些向量，我们可以创建一个矩阵，用于将草叶从切线变为局部空间。 <br><br> 您可以通过添加新的输入顶点数据来<strong>向上</strong>和<strong>向右</strong>访问向量。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; … // Modify the vertex shader. vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; } … // Modify the input for the geometry shader. Note that the SV_POSITION semantic is removed. void geo(triangle vertexOutput IN[3], inout TriangleStream&lt;geometryOutput&gt; triStream) … // Modify the existing line declaring pos. float3 pos = IN[0].vertex;</span></span></code> </pre> <br> 第三向量可以通过取两个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向量</a>之间的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向量乘积</a>来计算。 向量乘积返回一个<strong>垂直</strong>于两个传入向量的向量。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Place in the geometry shader, below the line declaring float3 pos. float3 vNormal = IN[0].normal; float4 vTangent = IN[0].tangent; float3 vBinormal = cross(vNormal, vTangent) * vTangent.w;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">为什么矢量乘积的结果乘以切线w的坐标？</b> <div class="spoiler_text"> 从3D编辑器导出网格时，它通常已经在网格数据中存储了双法线（也称为<em>到两个点的切线</em> ）。 无需导入这些双法线，Unity只需获取每个双法线的方向并将其分配给切线<strong>w</strong>的坐标即可。 这样可以节省内存，同时提供重新创建正确的Binormal的功能。 有关此主题的详细讨论，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 </div></div><br> 有了所有三个向量，我们可以为切线和局部空间之间的转换创建矩阵。 在将草叶的每个顶点传递给<code>UnityObjectToClipPos</code>之前，我们将其乘以该矩阵，该矩阵期望局部空间中有一个顶点。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the lines declaring the three vectors. float3x3 tangentToLocal = float3x3( vTangent.x, vBinormal.x, vNormal.x, vTangent.y, vBinormal.y, vNormal.y, vTangent.z, vBinormal.z, vNormal.z );</span></span></code> </pre> <br> 在使用矩阵之前，我们将顶点输出代码传递给函数，以免一次又一次地写相同的代码行。 这就是所谓<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的DRY原理</a> ，或者<strong>不要重复自己</strong> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. geometryOutput VertexOutput(float3 pos) { geometryOutput o; o.pos = UnityObjectToClipPos(pos); return o; } … // Remove the following from the geometry shader. //geometryOutput o; //o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0)); //triStream.Append(o); // ...and replace it with the code below. triStream.Append(VertexOutput(pos + float3(0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(-0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(0, 1, 0)));</span></span></code> </pre> <br> 最后，我们将输出顶点与<code>tangentToLocal</code>矩阵相乘，使它们与输入点的法线正确对齐。 <br><br><pre> <code class="cpp hljs">triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/3f8/286/c953f828675a9d4e202c0c9349d37f9d.png" alt="图片"></div><br> 这更像我们所需要的，但并不完全正确。 这里的问题是，最初我们将<strong>Y</strong>轴的方向指定为“上”（上）。 但是，在切线空间中，向上方向通常沿<strong>Z</strong>轴定位。 现在，我们将进行这些更改。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the position of the third vertex being emitted. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1))));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/f51/ddb/0cff51ddbea12280cb78a1db9ada1786.png"></div><br><h2>  3.草的外观 </h2><br> 为了使三角形看起来更像草叶，您需要添加颜色和变化。 我们首先添加一个从草叶顶部向下的<strong>渐变</strong> 。 <br><br><h3>  3.1颜色渐变 </h3><br> 我们的目标是允许艺术家设置两种颜色-顶部和底部，并在这两种颜色之间进行插值，以使他倾斜到草叶的底部。 这些颜色已在着色器文件中定义为<code>_TopColor</code>和<code>_BottomColor</code> 。 为了正确采样，您需要将<strong>UV坐标</strong>传递到片段着色器。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. float2 uv : TEXCOORD0; … // Modify the VertexOutput function signature. geometryOutput VertexOutput(float3 pos, float2 uv) … // Add to VertexOutput, just below the line assigning o.pos. o.uv = uv; … // Modify the existing lines in the geometry shader. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br> 我们为三角形的草叶创建了UV坐标，三角形的基点的两个顶点分别位于左下和右下，顶端位于顶部的中心。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/165/e39/932/165e399323aaa07e7c4cee728c0c9988.png"></div><br>  <i>草叶片的三个顶点的UV坐标。</i>  <i>尽管我们使用简单的渐变绘制草叶，但相似的纹理排列方式允许您覆盖纹理。</i> <br><br> 现在，我们可以使用UV对片段着色器中的顶部和底部颜色进行采样，然后使用<code>lerp</code>对其进行<code>lerp</code> 。 我们还将需要修改片段着色器的参数，使<code>geometryOutput</code>作为输入，而不仅仅是<code>float4</code>的位置。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the function signature of the fragment shader. float4 frag (geometryOutput i, fixed facing : VFACE) : SV_Target … // Replace the existing return call. return float4(1, 1, 1, 1); return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/510/51f/59651051f474907a88740e83bc9d4532.png"></div><br><h3>  3.2随机叶片方向 </h3><br> 为了产生变化并赋予草更自然的外观，我们将使每片草在随机方向上看起来。 为此，我们需要创建一个旋转矩阵，使草叶绕其<strong>上</strong>轴旋转任意量。 <br><br> 着色器文件中有两个函数可以帮助我们做到这一点： <code>rand</code>从3D输入生成一个随机数，而<code>AngleAxis3x3</code>接收角度（以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">弧度为单位</a> ）并返回一个矩阵，该矩阵绕着指定的轴旋转该值。 后一个函数的工作原理与C＃ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quaternion.AngleAxis</a>函数完全相同（只有<code>AngleAxis3x3</code>返回一个矩阵，而不是一个四元数）。 <br><br>  <code>rand</code>函数返回的数字范围为0 ... 1； 我们将其乘以<strong>2 Pi</strong>即可获得整个角度值范围。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring the tangentToLocal matrix. float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(0, 0, 1));</span></span></code> </pre> <br> 我们使用传入的<code>pos</code>位置作为随机旋转的种子。 因此，每片草叶都会有自己的旋转，在每帧中都是恒定的。 <br><br> 通过将其乘以创建的<code>tangentToLocal</code>矩阵，可以将旋转应用于草叶。 注意矩阵乘法是<strong>不可</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交换的</a> ; 操作数的顺序很<strong>重要</strong> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring facingRotationMatrix. float3x3 transformationMatrix = mul(tangentToLocal, facingRotationMatrix); … // Replace the multiplication matrix operand with our new transformationMatrix. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09f/c2f/e80/09fc2fe8028b51f78989954e65812cd3.png"></div><br><h3>  3.3随机向前弯曲 </h3><br> 如果所有草叶都完全对齐，它们将看起来一样。 这可能适合修剪整齐的草，例如在修剪过的草坪上，但在自然界中，草不会像这样生长。 我们将创建一个新的矩阵来沿<strong>X</strong>轴旋转草，并创建一个属性来控制该旋转。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _BendRotationRandom("Bend Rotation Random", Range(0, 1)) = 0.2 … // Add to the CGINCLUDE block. float _BendRotationRandom; … // Add to the geometry shader, below the line declaring facingRotationMatrix. float3x3 bendRotationMatrix = AngleAxis3x3(rand(pos.zzx) * _BendRotationRandom * UNITY_PI * 0.5, float3(-1, 0, 0));</span></span></code> </pre> <br> 再次，我们将草叶的位置用作随机种子，这一次是通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扫掠它</a>来创建唯一的种子。 我们还将<code>UNITY_PI</code>乘以<strong>0.5</strong> ； 这将使我们的随机间隔为0 ... 90度。 <br><br> 我们再次通过旋转应用此矩阵，以正确的顺序乘以所有内容。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line. float3x3 transformationMatrix = mul(mul(tangentToLocal, facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49c/122/534/49c122534d7298c0f9c646501a708daa.gif"></div><br><h3>  3.4宽度和高度 </h3><br> 而草叶的大小被限制为1个单位的宽度和1个单位的高度。 我们将添加属性以控制大小，并添加属性以添加随机变化。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeWidth("Blade Width", Float) = 0.05 _BladeWidthRandom("Blade Width Random", Float) = 0.02 _BladeHeight("Blade Height", Float) = 0.5 _BladeHeightRandom("Blade Height Random", Float) = 0.3 … // Add to the CGINCLUDE block. float _BladeHeight; float _BladeHeightRandom; float _BladeWidth; float _BladeWidthRandom; … // Add to the geometry shader, above the triStream.Append calls. float height = (rand(pos.zyx) * 2 - 1) * _BladeHeightRandom + _BladeHeight; float width = (rand(pos.xzy) * 2 - 1) * _BladeWidthRandom + _BladeWidth; … // Modify the existing positions with our new height and width. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-width, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, height)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/22e/f34/35b22ef34945a576100a152a0e25eec5.png"></div><br> 三角形现在更像草叶，但也太少了。 传入的网格中根本没有足够的峰值以产生密集密集的场的印象。 <br><br> 一种解决方案是使用C＃或在3D编辑器中创建一个新的，更密集的网格。 这将起作用，但不允许我们动态控制草的密度。 相反，我们将使用<strong>tessellation</strong>拆分传入的网<strong>格</strong> 。 <br><br><h2>  4.镶嵌 </h2><br>  <strong>细分</strong>是渲染管线的可选阶段，在顶点着色器之后和几何着色器（如果有）之前执行。 它的任务是将一个传入表面细分为许多图元。 细分可通过两个可编程步骤来实现： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">外壳</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">域</a>着色器。 <br><br> 对于表面着色器，Unity具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内置的镶嵌实现</a> 。 但是，由于我们<strong>不使用</strong>表面着色器，因此必须实现自己的外壳着色器和域着色器。 在本文中，我将不详细讨论镶嵌的实现，而仅使用现有的<code>CustomTessellation.cginc</code>文件。 该文件改编自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Catlike Coding文章</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>是有关Unity中细分实现的极好信息来源。 <br><br> 如果在场景中包含<code>TessellationExample</code>对象，我们将看到它已经具有实现镶嵌细分的材质。 更改“ <strong>镶嵌细分统一”</strong>属性可演示细分效果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/8a7/f01/2d88a7f01e3a7462ffd0c8f20953b5ca.gif"></div><br> 我们在草着色器中实现了细分，以控制平面的密度，从而控制生成的草叶片的数量。 首先，您需要添加<code>CustomTessellation.cginc</code>文件。 我们将通过其到着色器的<em>相对</em>路径来引用它。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block, below the other #include statements. #include "Shaders/CustomTessellation.cginc"</span></span></code> </pre> <br> 如果打开<code>CustomTessellation.cginc</code> ，您会注意到已经在其中定义了<code>vertexInput</code>和<code>vertexOutput</code>以及顶点着色器。 无需在我们的草着色器中重新定义它们； 它们可以被删除。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; }*/</span></span></code> </pre> <br> 请注意， <code>CustomTessellation.cginc</code>顶点着色器只是将输入直接传递给细分阶段； 在域着色器内部调用的<code>vertexOutput</code>函数承担创建<code>vertexOutput</code>结构的任务。 <br><br> 现在，我们可以将<strong>外壳</strong>和<strong>域</strong>着色器添加到草着色器中。 我们还将添加一个新的<code>_TessellationUniform</code>属性以控制单位大小-与此属性相对应的变量已经在<code>CustomTessellation.cginc</code>声明。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _TessellationUniform("Tessellation Uniform", Range(1, 64)) = 1 … // Add below the other #pragma statements in the SubShader Pass. #pragma hull hull #pragma domain domain</span></span></code> </pre> <br> 现在，更改<strong>Tessellation Uniform</strong>属性可以控制草的密度。 我发现以<strong>5</strong>的值可获得良好的结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/280/d93/c14/280d93c1420a9744bd56f2d2496f96ab.gif"></div><br><h2>  5.风 </h2><br> 我们通过采样<strong>变形纹理来</strong>实现风。 该纹理看起来就像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">法线贴图</a> ，仅其中只有两个而不是三个通道。 我们将使用这两个通道作为沿<strong>X</strong>和<strong>Y的</strong>风向。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/aaa/687/a58aaa68742934ff1bddf1cbaf9564f5.png"></div><br> 在采样风纹理之前，我们需要创建一个UV坐标。 代替使用分配给网格的纹理坐标，我们应用输入点的位置。 因此，如果世界上有多个草网，就会产生一种幻想，即它们都属于同一风力系统。 我们还使用<code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">shader内置变量</a>在草表面上滚动风纹理。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _WindDistortionMap("Wind Distortion Map", 2D) = "white" {} _WindFrequency("Wind Frequency", Vector) = (0.05, 0.05, 0, 0) … // Add to the CGINCLUDE block. sampler2D _WindDistortionMap; float4 _WindDistortionMap_ST; float2 _WindFrequency; … // Add to the geometry shader, just above the line declaring the transformationMatrix. float2 uv = pos.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency * _Time.y;</span></span></code> </pre> <br> 我们将<code>_WindDistortionMap</code>的比例尺和偏移量应用于该位置，然后将其进一步移至<code>_Time.y</code> ，并缩放至<code>_WindFrequency</code> 。 现在，我们将使用这些UV来采样纹理并创建一个属性来控制风的强度。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _WindStrength("Wind Strength", Float) = 1 … // Add to the CGINCLUDE block. float _WindStrength; … // Add below the line declaring float2 uv. float2 windSample = (tex2Dlod(_WindDistortionMap, float4(uv, 0, 0)).xy * 2 - 1) * _WindStrength;</span></span></code> </pre> <br> 请注意，我们将采样值从纹理从0 ... 1间隔缩放到-1 ... 1间隔。 接下来，我们可以创建表示风向的归一化矢量。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float2 windSample. float3 wind = normalize(float3(windSample.x, windSample.y, 0));</span></span></code> </pre> <br> 现在，我们可以创建一个矩阵来围绕此向量旋转，并将其乘以我们的<code>transformationMatrix</code> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3 wind. float3x3 windRotation = AngleAxis3x3(UNITY_PI * windSample, wind); … // Modify the existing line. float3x3 transformationMatrix = mul(mul(mul(tangentToLocal, windRotation), facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br> 最后，我们在Unity编辑器中将“ <code>Wind</code>纹理（位于项目的根）传输到草材质的“ <strong>风扭曲贴图”</strong>字段。 我们还将纹理的“ <strong>平铺”</strong>参数设置为<code>0.01, 0.01</code> 。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 如果草没有在“ <strong>场景”</strong>窗口中设置动画，则单击“ <strong>切换天空盒”，“雾”和其他各种效果</strong>按钮以启用动画材质。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从远处看，草看上去是正确的，但是如果我们仔细观察草叶片，就会注意到整个草叶片都在转动，这就是为什么基部不再附着在地面上的原因。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/148/51e/6e914851e888c448c30080a7abefae33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">草叶的根部不再附着在地面上，而是与地面相交（以</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红色显示</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），并垂悬在地面的上方（以</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绿</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线</font><font style="vertical-align: inherit;">表示</font><font style="vertical-align: inherit;">）。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将通过定义第二个变换矩阵来解决此问题，该变换矩阵仅适用于基础的两个顶点。</font><font style="vertical-align: inherit;">在该矩阵</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不被</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包括基质</font></font><code>windRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>bendRotationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，由于其中底座附接到草表面。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3x3 transformationMatrix. float3x3 transformationMatrixFacing = mul(tangentToLocal, facingRotationMatrix); … // Modify the existing lines outputting the base vertex positions. triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(-width, 0, 0)), float2(1, 0)));</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.叶片的曲率 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，单个草叶由一个三角形定义。在远距离，这不是问题，但是在草叶附近，它们看起来非常僵硬和几何形状，而不是有机的和生动的。我们将通过从几个三角形构建草叶并将它们沿</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弯曲来解决此问题</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每片草被分成</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几段</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。每个片段将具有矩形形状，并且由两个三角形组成，除了上面的片段以外-它是一个三角形，表示草叶的尖端。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们仅绘制了三个顶点，创建了一个三角形。那么，如果有更多的顶点，几何着色器如何知道需要连接哪些顶点并形成三角形？答案在于数据结构</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三角带</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。前三个顶点连接并形成三角形，每个新顶点与前两个顶点形成三角形。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/8ec/676/8718ec676d7efd819718bd25d5b27b54.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细分的草叶，以三角形带表示，一次创建一个顶点。在前三个顶点之后，每个新顶点与前两个顶点形成一个新三角形。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这不仅在内存使用方面更加高效，而且还使您可以轻松，快速地在代码中创建三角形序列。如果我们要创建几个三角形的条纹，可以为</font></font><code>TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">调用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RestartStrip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们开始从几何着色器绘制更多顶点之前，我们需要增加它</font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们将使用该设计</font></font><code>#define</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许着色器作者控制线段的数量，并从中计算显示的顶点数量。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. #define BLADE_SEGMENTS 3 … // Modify the existing line defining the maxvertexcount. [maxvertexcount(BLADE_SEGMENTS * 2 + 1)]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初，我们将线段数设置为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后</font><font style="vertical-align: inherit;">根据线段数进行</font><font style="vertical-align: inherit;">更新</font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以计算顶点数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建分段的草叶，我们使用一个循环</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。循环的每次迭代都将添加</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个顶点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">left</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">right</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。完成尖端后，我们将最后一个顶点添加到草叶的尖端。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在执行此操作之前，将代码的草叶顶点的部分计算位置移入函数中将很有用，因为我们将在循环内外多次使用此代码。将</font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下内容</font><font style="vertical-align: inherit;">添加到块中</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">geometryOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGrassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 vertexPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, float2 uv, float3x3 transformMatrix)</span></span></span><span class="hljs-function"> </span></span>{ float3 tangentPoint = float3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, height); float3 localPosition = vertexPosition + mul(transformMatrix, tangentPoint); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VertexOutput(localPosition, uv); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数执行相同的任务，因为它传递了我们先前传递的参数</font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以生成草叶的顶点。</font><font style="vertical-align: inherit;">获得位置，高度和宽度后，它将使用传输的矩阵正确地变换顶点并为其分配UV坐标。</font><font style="vertical-align: inherit;">我们将更新现有代码以使该功能正常工作。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the existing code outputting the vertices. triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数开始正确运行，并且我们准备将顶点生成代码移入循环</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在此行下添加</font></font><code>float width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下内容：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; BLADE_SEGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = i / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)BLADE_SEGMENTS; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们宣布一个循环，该循环将针对每个草叶片段运行一次。</font><font style="vertical-align: inherit;">在循环内部，添加一个变量</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此变量将存储一个介于0 ... 1之间的值，指示我们沿着草叶移动了多远。</font><font style="vertical-align: inherit;">我们使用此值在循环的每次迭代中计算段的宽度和高度。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float t. float segmentHeight = height * t; float segmentWidth = width * (1 - t);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当向上移动一片草时，高度增加而宽度减小。</font><font style="vertical-align: inherit;">现在我们可以将调用添加到循环中，</font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以将顶点添加到三角形流中。</font><font style="vertical-align: inherit;">我们还将</font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在循环外部</font><font style="vertical-align: inherit;">添加一个调用</font><font style="vertical-align: inherit;">，以创建草尖。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float segmentWidth. float3x3 transformMatrix = i == 0 ? transformationMatrixFacing : transformationMatrix; triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, float2(1, t), transformMatrix)); … // Add just below the loop to insert the vertex at the tip of the blade. triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix)); … // Remove the existing calls to triStream.Append. //triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看一下带有声明的行</font></font><code>float3x3 transformMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-在这里，我们选择两个转换矩阵之一：我们取</font></font><code>transformationMatrixFacing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基的顶点和</font></font><code>transformationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有其他</font><font style="vertical-align: inherit;">的顶点</font><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/211/61c/02b21161cd4afc0cca35ae71ffe2570e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如今，草叶分为许多部分，但草叶表面仍然平坦-尚未涉及新的三角形。</font><font style="vertical-align: inherit;">我们将添加草曲率的叶片，转移的顶点的位置</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先，我们需要修改函数</font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使其在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个偏移量</font><font style="vertical-align: inherit;">，我们将其称为</font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the function signature of GenerateGrassVertex. geometryOutput GenerateGrassVertex(float3 vertexPosition, float width, float height, float forward, float2 uv, float3x3 transformMatrix) … // Modify the Y coordinate assignment of tangentPoint. float3 tangentPoint = float3(width, forward, height);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了计算每个顶点的位移，我们将一个</font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值代</font><font style="vertical-align: inherit;">入函数中</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">提高</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功率后，其对前移的影响将是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非线性的，</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将草叶变成曲线。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeForward("Blade Forward Amount", Float) = 0.38 _BladeCurve("Blade Curvature Amount", Range(1, 4)) = 2 … // Add to the CGINCLUDE block. float _BladeForward; float _BladeCurve; … // Add inside the geometry shader, below the line declaring float width. float forward = rand(pos.yyz) * _BladeForward; … // Add inside the loop, below the line declaring segmentWidth. float segmentForward = pow(t, _BladeCurve) * forward; … // Modify the GenerateGrassVertex calls inside the loop. triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(1, t), transformMatrix)); … // Modify the GenerateGrassVertex calls outside the loop. triStream.Append(GenerateGrassVertex(pos, 0, height, forward, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一段相当大的代码，但是所有工作都与草叶的宽度和高度类似。</font><font style="vertical-align: inherit;">在较低值</font></font><code>_BladeForward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><code>_BladeCurve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到一个有序，整齐干净的草坪，和更大的价值将给予相反的效果。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/cbc/e43/c1fcbce43fa5e1c1be319dc1f5190f3d.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.灯光和阴影 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为完成着色器的最后一步，我们将添加</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投射</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接收</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阴影的功能。</font><font style="vertical-align: inherit;">我们还将从主要的定向光源中添加简单的照明。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.1投射阴影 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要在Unity中投射阴影，您需要向着色器添加第二遍。场景中创建阴影的光源将使用此通道，以将草的深度渲染到其</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阴影贴图中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这意味着必须在阴影通道中启动几何着色器，以便草叶可以投射阴影。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于几何着色器是写在块内部的</font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此我们可以在文件的任何传递中使用它。创建第二遍，该遍将使用与第一遍相同的着色器，但片段着色器除外-我们将定义一个新遍，并在其中编写一个用于处理输出的宏。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the existing Pass. Pass { Tags { "LightMode" = "ShadowCaster" } CGPROGRAM #pragma vertex vert #pragma geometry geo #pragma fragment frag #pragma hull hull #pragma domain domain #pragma target 4.6 #pragma multi_compile_shadowcaster float4 frag(geometryOutput i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了创建新的片段着色器之外，这段代码还有一些重要的区别。</font><font style="vertical-align: inherit;">标签</font></font><code>LightMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有值</font></font><code>ShadowCaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是一个</font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-它说的统一，这段话应该用来渲染阴影贴图的对象。</font><font style="vertical-align: inherit;">这里还有一个预处理器指令</font></font><code>multi_compile_shadowcaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它可以确保着色器编译投射阴影所需的所有必要选项。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使游戏对象</font><font style="vertical-align: inherit;">在场景中</font></font><code>Fence</code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处于活动状态</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；</font><font style="vertical-align: inherit;">因此我们得到了一个表面，草叶可以在其上投射阴影。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/640/6cf/c576406cf284fe41e4b04d8af264d96e.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.2获取阴影 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity从创建阴影的光源的角度渲染阴影贴图后，会启动一个通道，将阴影“收集”到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">屏幕空间</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的纹理中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要对该纹理进行采样，我们将需要计算屏幕空间中顶点的位置，并将其转移到片段着色器。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. unityShadowCoord4 _ShadowCoord : TEXCOORD1; … // Add to the VertexOutput function, just above the return call. o._ShadowCoord = ComputeScreenPos(o.pos);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在段落的片段着色器中，</font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用宏来获取一个值，该值</font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指示曲面是否在阴影中。</font><font style="vertical-align: inherit;">此值的范围是0 ... 1，其中0是完全阴影，1是完全照明。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么屏幕空间的UV坐标称为_ShadowCoord？</font><font style="vertical-align: inherit;">这不符合以前的命名约定。</font></font></b> <div class="spoiler_text">    Unity           (       ).          <code>SHADOW_ATTENUATION</code> .         <code>Autolight.cginc</code> ,  ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)</span></span></code> </pre> <br>              -    ,            . </div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's fragment shader, replacing the existing return call. return SHADOW_ATTENUATION(i); //return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们需要将着色器正确配置为接收阴影。</font><font style="vertical-align: inherit;">为此，我们将在</font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预处理过程中</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">预处理器指令</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">以便编译所有必需的着色器选项。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's preprocessor directives, below #pragma target 4.6. #pragma multi_compile_fwdbase</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/491/468/90a491468a1ad129d35bea03b0b51898.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将相机拉近后，我们可以注意到草叶表面上的伪影。</font><font style="vertical-align: inherit;">它们是由单个草叶在自己身上投射阴影的事实引起的。</font><font style="vertical-align: inherit;">我们可以通过</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性移动</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或将截断空间中的顶点位置稍微远离屏幕</font><font style="vertical-align: inherit;">来解决此问题</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将为此使用Unity宏，并将其包含在设计中，</font></font><code>#if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便仅在阴影路径中执行操作。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add at the end of the VertexOutput function, just above the return call. #if UNITY_PASS_SHADOWCASTER // Applying the bias prevents artifacts from appearing on the surface. o.pos = UnityApplyLinearShadowBias(o.pos); #endif</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/ec0/d88/dcaec0d88eea1893b6a07eb45724a0b6.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用线性阴影偏移后，条纹形式的阴影伪影将从三角形的表面消失。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么在阴影的草叶边缘会出现伪影？</font></font></b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/12e/af1/08a12eaf1af17fc9b35de7d07a64afca.png"></div><br>      (multisample anti-aliasing <strong>MSAA</strong> ) Unity <em> </em>     ,        .        ,  . <br><br>    —  ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  Unity</a> .      (     );     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    Unity</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.3照明 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将使用非常简单且常见的漫射照明计算算法来实现照明。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/3ae/452/4043ae452046c0b4b405aa88afe8d2b7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...，其中</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是表面的法线，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是主要方向照明的标准化方向，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是计算出的照明。</font><font style="vertical-align: inherit;">在本教程中，我们</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不会</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现间接照明。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目前，法线尚未分配给草叶的顶点。</font><font style="vertical-align: inherit;">与顶点位置一样，我们首先计算</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切线空间中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的法线</font><font style="vertical-align: inherit;">，然后将其转换为局部。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当“ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叶片曲率量”</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1时</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，切线空间中的所有草叶都指向一个方向：与</font><strong><font style="vertical-align: inherit;">Y</font></strong><font style="vertical-align: inherit;">轴正对</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">作为解决方案的第一步，我们假设没有曲率，计算法线。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the GenerateGrassVertex function, belowing the line declaring tangentPoint. float3 tangentNormal = float3(0, -1, 0); float3 localNormal = mul(transformMatrix, tangentNormal);</span></span></code> </pre> <br> <code>tangentNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义为与</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轴正好相对</font><font style="vertical-align: inherit;">，由用于将切点转换为局部空间的同一矩阵进行转换。</font><font style="vertical-align: inherit;">现在我们可以将其传递给函数</font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后传递给结构</font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the return call in GenerateGrassVertex. return VertexOutput(localPosition, uv, localNormal); … // Add to the geometryOutput struct. float3 normal : NORMAL; … // Modify the existing function signature. geometryOutput VertexOutput(float3 pos, float2 uv, float3 normal) … // Add to the VertexOutput function to pass the normal through to the fragment shader. o.normal = UnityObjectToWorldNormal(normal);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意，在得出结论之前，我们将法线转换为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界空间</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；</font><font style="vertical-align: inherit;">Unity将着色器在世界空间中的主要定向光源的方向传达给着色器，因此这种转换是必需的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以可视化着色器片段中的法线，</font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以检查工作的结果。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader. float3 normal = facing &gt; 0 ? i.normal : -i.normal; return float4(normal * 0.5 + 0.5, 1); // Remove the existing return call. //return SHADOW_ATTENUATION(i);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于在我们的着色器中</font></font><code>Cull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配</font><font style="vertical-align: inherit;">了一个</font><font style="vertical-align: inherit;">值</font></font><code>Off</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此将渲染草叶的两侧。</font><font style="vertical-align: inherit;">为了使法线指向正确的方向，我们使用</font></font><code>VFACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加到片段着色器</font><font style="vertical-align: inherit;">的辅助参数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果我们显示曲面的正面，则</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该参数</font></font><code>fixed facing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数；如果</font><font style="vertical-align: inherit;">相反，则</font><font style="vertical-align: inherit;">该参数</font><font style="vertical-align: inherit;">将返回一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负数</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果需要，我们在上面的代码中使用它来翻转法线。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/8ca/965/e1b8ca965ed8e80b539a9773d1adeb0c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当“ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叶片曲率量”</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大于1时，</font><font style="vertical-align: inherit;">每个顶点</font><font style="vertical-align: inherit;">的切线</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位置</font><font style="vertical-align: inherit;">将偏移</font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递给函数</font><font style="vertical-align: inherit;">的量</font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将使用此值按比例缩放</font><font style="vertical-align: inherit;">法线</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轴</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line in GenerateGrassVertex. float3 tangentNormal = normalize(float3(0, -1, forward));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，将代码添加到片段着色器以组合阴影，定向照明和环境照明。</font><font style="vertical-align: inherit;">我建议在我的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">卡通着色器教程中研究有关</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在着色器中实现自定义照明的更多详细信息</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader, below the line declaring float3 normal. float shadow = SHADOW_ATTENUATION(i); float NdotL = saturate(saturate(dot(normal, _WorldSpaceLightPos0)) + _TranslucentGain) * shadow; float3 ambient = ShadeSH9(float4(normal, 1)); float4 lightIntensity = NdotL * _LightColor0 + float4(ambient, 1); float4 col = lerp(_BottomColor, _TopColor * lightIntensity, i.uv.y); return col; // Remove the existing return call. //return float4(normal * 0.5 + 0.5, 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/894/d14/c14894d14edc336b770f4b94bedd3708.png"></div><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本教程中，草覆盖了10x10单位的小区域。</font><font style="vertical-align: inherit;">为了使着色器在保持高性能的同时覆盖较大的开放空间，必须进行优化。</font><font style="vertical-align: inherit;">您可以基于距离应用镶嵌，以使更少的草叶远离相机渲染。</font><font style="vertical-align: inherit;">另外，在长距离上，可以使用具有叠加纹理的单个四边形来绘制多组草叶，而不是单独的草叶。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/a05/e86/5a7a05e8690c152f9196bb3c94fada19.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity引擎的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准资产</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包中包含的草纹理</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在一个四边形上绘制了许多草叶，这减少了场景中三角形的数量。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管从本质上讲我们不能将几何着色器与表面着色器一起使用，以改善或扩展照明和阴影的功能，但是如果您需要使用标准Unity照明模型，则可以研究</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此GitHub存储库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">存储库</font></a><font style="vertical-align: inherit;">通过延迟渲染和手动填充G缓冲区展示了该问题的解决方案。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub存储库中的着色器源代码</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 补充：合作 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有互操作性，图形效果对玩家来说似乎是静止的或毫无生气的。</font><font style="vertical-align: inherit;">本教程已经很长了，因此我没有添加有关世界对象与草的交互作用的部分。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交互式药草的幼稚实现将包含两个组件：游戏世界中的一些组件，可以将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据传输</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到着色器以告诉它正在与草的哪一部分进行交互，以及在着色器中进行编码以</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解释</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此数据。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">此处</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示了如何用水实现的示例</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它可以适应与草一起工作；</font><font style="vertical-align: inherit;">无需在角色所在的位置绘制涟漪图，而是可以将草叶调低以模拟台阶的效果。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458060/">https://habr.com/ru/post/zh-CN458060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458046/index.html">摇篮备忘单</a></li>
<li><a href="../zh-CN458048/index.html">委托作为管理工具</a></li>
<li><a href="../zh-CN458050/index.html">Mobius 2019 Piter的情况如何（以及有关下一个Mobius的一些知识）</a></li>
<li><a href="../zh-CN458052/index.html">AMA与Habr.10。 最后*问题</a></li>
<li><a href="../zh-CN458056/index.html">Martin Kleppmann的大型访谈：“弄清楚分布式数据系统的未来”</a></li>
<li><a href="../zh-CN458062/index.html">UserGate平台概述</a></li>
<li><a href="../zh-CN458064/index.html">云中的PVS-Studio-在Travis CI上运行分析</a></li>
<li><a href="../zh-CN458068/index.html">PVS-Studio for Visual Studio</a></li>
<li><a href="../zh-CN458070/index.html">PVS-Studio for Visual Studio</a></li>
<li><a href="../zh-CN458072/index.html">PVS-Studio走向云端-在Travis CI上启动分析</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>