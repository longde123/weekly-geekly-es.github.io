<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚖️ 👰🏾 👩🏻‍🎨 Utilisation de modules JavaScript en production: situation actuelle. 2e partie 👨‍👦 🍆 🆎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous publions la deuxième partie de la traduction du matériel, qui est consacrée à l'utilisation des modules JS dans la production. 

  
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de modules JavaScript en production: situation actuelle. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/466539/">  Aujourd'hui, nous publions la deuxième partie de la traduction du matériel, qui est consacrée à l'utilisation des modules JS dans la production. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/y4/3w/bg/y43wbgvqwezj1-b0oyx882a-gne.jpeg"></a> <br><br>  → Au fait, voici la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de l'</a> article. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Importation dynamique</font> </h2><br>  L'un des inconvénients de l'utilisation d'expressions d'importation réelles pour séparer le code et charger les modules est que la tâche de travailler avec des navigateurs qui ne prennent pas en charge les modules incombe au développeur. <br><br>  Et si vous souhaitez utiliser des commandes dynamiques <code>import()</code> pour organiser le chargement de code paresseux, vous devrez, entre autres, faire face au fait que certains navigateurs, bien que, très certainement, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les modules de support</a> , ne prennent toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas en charge les commandes dynamiques import ()</a> (Edge 16–18, Firefox 60–66, Safari 11, Chrome 61–63). <br><br>  Heureusement, ce problème nous aidera à résoudre un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> petit (environ 400 octets) et extrêmement rapide. <br><br>  L'ajout de ce polyfill à un projet Web est très simple.  Il vous suffit de l'importer et de l'initialiser au point d'entrée principal de l'application (avant d'appeler l'une des commandes <code>import()</code> du code): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dynamicImportPolyfill <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dynamic-import-polyfill'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         .   //    ,       . dynamicImportPolyfill.initialize({modulePath: '/modules/'});</span></span></code> </pre> <br>  Et la dernière chose à faire pour que ce schéma fonctionne, est de dire à Rollup qu'il doit renommer les commandes dynamic <code>import()</code> qui apparaissent dans le code en utilisant le nom que vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">choisissez</a> (via l'option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">output.dynamicImportFunction</a> ).  Un polyfill qui implémente la fonction d'importation dynamique utilise le nom <code>__import__</code> par défaut, mais il peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">personnalisé</a> . <br><br>  La raison pour laquelle vous devez renommer <code>import()</code> expressions <code>import()</code> est que l' <code>import</code> est, en JavaScript, un mot-clé.  Cela signifie qu'il est impossible, par polyfill, d'organiser le remplacement de la commande standard <code>import()</code> par une commande du même nom.  Si vous essayez de faire cela, une erreur de syntaxe se produira. <br><br>  Mais c'est très bien que Rollup renomme les commandes lors de la construction du projet, car cela signifie que vous pouvez utiliser des commandes standard dans le code source.  De plus, à l'avenir, lorsque le polyfill ne sera plus nécessaire, le code source du projet n'aura pas à être réécrit, changeant pour <code>import</code> ce qui était précédemment nommé d'une manière ou d'une autre. <br><br><h2>  <font color="#3AC1EF">Chargement efficace de JavaScript</font> </h2><br>  Chaque fois que vous utilisez la séparation de code, cela ne fait pas de mal d'organiser le préchargement de tous les modules dont vous savez qu'ils seront chargés très prochainement (par exemple, ce sont tous les modules dans l'arborescence des dépendances du module principal, qui est le point d'entrée du projet). <br><br>  Mais lorsque nous chargeons de vrais modules JavaScript (via <code>&lt;script type="module"&gt;</code> puis via les commandes d' <code>import</code> correspondantes), nous devons utiliser l'attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modulepreload</a> au lieu du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">préchargement</a> habituel, qui est destiné uniquement aux scripts classiques. <br><br><pre> <code class="javascript hljs">&lt;link rel=<span class="hljs-string"><span class="hljs-string">"modulepreload"</span></span> href=<span class="hljs-string"><span class="hljs-string">"/modules/main.XXXX.mjs"</span></span>&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-one.XXXX.mjs"&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-two.XXXX.mjs"&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-three.XXXX.mjs"&gt; &lt;!-- ... --&gt; &lt;script type="module" src="/modules/main.XXXX.mjs"&gt;&lt;/script&gt;</code> </pre> <br>  En fait, la <code>modulepreload</code> est nettement meilleure que le mécanisme de <code>preload</code> traditionnel dans la précharge de vrais modules.  Le fait est que lorsque vous l'utilisez, ce n'est pas seulement que le fichier est téléchargé.  De plus, il démarre immédiatement, en dehors du thread principal, l'analyse et la compilation du script.  Un <code>preload</code> régulier ne peut pas faire cela car il ne sait pas, lors du préchargement, si le fichier sera utilisé comme module ou comme script normal. <br><br>  Cela signifie que le chargement des modules à l'aide de l'attribut <code>modulepreload</code> souvent plus rapide et que lorsque les modules sont initialisés, il est moins susceptible de créer une charge excessive sur le thread principal, ce qui provoque des problèmes d'interface. <br><br><h2>  <font color="#3AC1EF">Création d'une liste de modules pour le préchargement</font> </h2><br>  Le fragment d'entrée dans l'objet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bundle</a> Rollup contient une liste complète des importations dans leurs arborescences de dépendances statiques.  Par conséquent, dans le hook Rollup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">generateBundle</a> , il est facile d'obtenir une liste de fichiers qui doivent être préchargés. <br><br>  Bien que des plugins puissent être trouvés dans npm pour générer des listes de préchargement de module, la création d'une liste similaire pour chaque point d'entrée dans l'arborescence des dépendances ne nécessite que quelques lignes de code.  Par conséquent, je préfère créer ces listes manuellement, en utilisant quelque chose comme ce code: <br><br><pre> <code class="javascript hljs">{  generateBundle(options, bundle) {    <span class="hljs-comment"><span class="hljs-comment">//         .    const modulepreloadMap = {};    for (const [fileName, chunkInfo] of Object.entries(bundle)) {      if (chunkInfo.isEntry || chunkInfo.isDynamicEntry) {        modulepreloadMap[chunkInfo.name] = [fileName, ...chunkInfo.imports];      }    }    //  -   ...    console.log(modulepreloadMap);  } }</span></span></code> </pre> <br>  Voici, par exemple, comment j'ai créé une <a href="">liste</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chargement</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">philipwalton.com</a> et pour mon <a href="">application de démonstration</a> , dont nous parlerons ci-dessous. <br><br>  Veuillez noter que bien que l'attribut <code>modulepreload</code> nettement meilleur que le <code>preload</code> classique pour le chargement des scripts de module, il a la pire prise en charge du navigateur (actuellement, seul Chrome le prend en charge).  Si une partie importante de votre trafic ne provient pas de Chrome, dans votre cas, il peut être judicieux d'utiliser la <code>preload</code> régulière au lieu de la <code>preload</code> du <code>preload</code> . <br><br>  Concernant l'utilisation de la <code>preload</code> , je voudrais vous avertir de quelque chose.  Le fait est que lors du chargement de scripts à l'aide du <code>preload</code> , contrairement au <code>modulepreload</code> , ces scripts n'entrent pas dans la carte du module du navigateur.  Cela signifie qu'il est possible que les demandes de préchargement puissent être exécutées plusieurs fois (par exemple, si le module importe le fichier avant que le navigateur ait fini de le précharger). <br><br><h2>  <font color="#3AC1EF">Pourquoi déployer de vrais modules en production?</font> </h2><br>  Si vous utilisez déjà un bundler comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webpack</a> , ainsi que si vous utilisez déjà le fractionnement de code et le préchargement des fichiers correspondants (similaire à ce que je viens de dire), alors vous vous demandez peut-être si vous devez passer à une stratégie concentré sur l'utilisation de vrais modules.  Il y a plusieurs raisons qui me font croire que vous devriez envisager de passer aux modules.  De plus, je pense qu'il est préférable de convertir un projet en modules réels que d'utiliser des scripts classiques avec leur propre code conçu pour charger des modules. <br><br><h3>  <font color="#3AC1EF">▍ Réduire la quantité totale de code</font> </h3><br>  Si le projet utilise de vrais modules, les utilisateurs de navigateurs modernes n'auront pas à télécharger de code supplémentaire conçu pour charger des modules ou pour gérer les dépendances.  Par exemple, lorsque vous utilisez de vrais modules, vous n'aurez pas besoin de charger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les mécanismes d'exécution et le manifeste du webpack</a> . <br><br><h3>  <font color="#3AC1EF">▍ Code de précharge amélioré</font> </h3><br>  Comme mentionné dans la section précédente, l'utilisation de l'attribut <code>modulepreload</code> permet de charger du code, de l' <code>modulepreload</code> et de le compiler en dehors du thread principal.  Tout le reste, par rapport à l'attribut de <code>preload</code> , reste le même.  Cela signifie que grâce au <code>modulepreload</code> pages deviennent interactives plus rapidement, et cela réduit la probabilité de bloquer le flux principal pendant l'interaction avec l'utilisateur. <br><br>  Par conséquent, quelle que soit la taille du code d'application divisé en fragments, il sera beaucoup plus productif de télécharger ces fragments à l'aide des commandes d'importation et de l'attribut <code>modulepreload</code> que de les charger à l'aide de la balise de <code>script</code> habituelle et de l'attribut de <code>preload</code> habituel (surtout si les balises correspondantes sont générées dynamiquement et ajouté au DOM lors de l'exécution). <br><br>  En d'autres termes, un bundle de cumul de code de projet, composé de 20 fragments de module, se chargera plus rapidement qu'un bundle du même projet, composé de 20 fragments de script classiques préparés par webpack (non pas à cause de l'utilisation de webpack, mais parce que que ce ne sont pas de vrais modules). <br><br><h3>  <font color="#3AC1EF">▍ Améliorer l'orientation future du code</font> </h3><br>  De nombreuses nouvelles fonctionnalités des navigateurs sont basées sur des modules et non sur des scripts classiques.  Cela signifie que si vous prévoyez d'utiliser ces fonctionnalités, votre code doit être présenté sous la forme de vrais modules.  Cela ne devrait pas être quelque chose de transpilé dans ES5 et chargé avec les moyens de la balise de <code>script</code> classique (c'est le problème que j'ai écrit lorsque j'ai essayé d'utiliser l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API</a> expérimentale de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stockage KV</a> ). <br><br>  Voici quelques-unes des nouvelles fonctionnalités de navigateur les plus intéressantes qui se concentrent exclusivement sur les modules: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modules intégrés</a> </li><li>  <a href="">Modules HTML</a> </li><li>  <a href="">Modules CSS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modules JSON</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Importer des cartes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partage des modules avec les employés, les employés de service et la fenêtre de document</a> </li></ul><br><h2>  <font color="#3AC1EF">Prise en charge du navigateur hérité</font> </h2><br>  À l'échelle mondiale, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus de 83% des navigateurs</a> prennent en charge les modules JavaScript (y compris l'importation dynamique), par conséquent, la plupart des utilisateurs pourront travailler avec un projet qui est passé à des modules sans aucun effort particulier de la part des développeurs de ce projet. <br><br>  Dans le cas des navigateurs qui prennent en charge les modules mais ne prennent pas en charge l'importation dynamique, il est recommandé d'utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill dynamic-import-polyfill</a> décrit ci-dessus.  Puisqu'il est très petit et, si possible, utilise la méthode standard <code>import()</code> navigateur <code>import()</code> , l'utilisation de ce polyfill n'a presque aucun effet sur la taille ou les performances du projet. <br><br>  Si nous parlons de navigateurs qui ne supportent absolument pas les modules, alors, pour organiser le travail avec eux, vous pouvez utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle module / nomodule</a> . <br><br><h3>  <font color="#3AC1EF">▍Exemple de fonctionnement</font> </h3><br>  Puisqu'il est toujours plus facile de parler de compatibilité entre navigateurs que de la réaliser, j'ai créé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application de démonstration</a> qui utilise les technologies décrites ci-dessus. <br><br>  Cette application fonctionne dans les navigateurs comme Edge 18 et Firefox ESR, qui ne prennent pas en charge <code>import()</code> commandes d' <code>import()</code> dynamique <code>import()</code> .  De plus, il fonctionne dans des navigateurs comme Internet Explorer 11, qui ne prennent pas en charge les modules. <br><br>  Afin de montrer que la stratégie discutée ici convient non seulement aux projets simples, j'ai utilisé de nombreuses fonctionnalités dans cette application qui sont nécessaires aujourd'hui dans les grands projets: <br><br><ul><li>  Transformation de code à l'aide de Babel (y compris JSX). </li><li>  Dépendances CommonJS (par exemple react et react-dom). </li><li>  Dépendances CSS. </li><li>  Hachage de ressources </li><li>  Séparation de code </li><li>  Importation dynamique (avec un repli comme polyfill). </li><li>  Implémentation du modèle module / nomodule. </li></ul><br>  Le code du projet peut être trouvé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> (c'est-à-dire que vous pouvez bifurquer le référentiel et construire le projet vous-même), la version de démonstration est hébergée sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Glitch</a> , ce qui vous permet de l'expérimenter. <br><br>  La chose la plus importante dans le projet de démonstration est la <a href="">configuration Rollup</a> , car elle détermine la façon dont les modules résultants sont créés. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  J'espère que ce matériel vous a convaincu non seulement de la possibilité de déployer des modules JavaScript standard en production, mais aussi qu'il peut vraiment améliorer le temps de chargement du site et ses performances. <br><br>  Voici un bref aperçu des étapes à suivre pour implémenter les modules dans le projet: <br><br><ul><li>  Utilisez un bundler, parmi les formats de sortie pris en charge par lesquels il existe des modules ES2015. </li><li>  Approchez de manière agressive la séparation du code (si possible, jusqu'à l'allocation des dépendances de <code>node_modules</code> en fragments séparés). </li><li>  Préchargez tous les modules qui se trouvent dans votre arborescence de dépendances statiques (en utilisant <code>modulepreload</code> ). </li><li>  Utilisez polyfill pour les navigateurs qui ne prennent pas en charge <code>import()</code> instructions <code>import()</code> dynamiques. </li><li>  Utilisez le modèle de module / nomodule pour organiser le travail avec les navigateurs qui ne prennent pas en charge les modules. </li></ul><br>  Si vous utilisez déjà Rollup pour construire le projet, je voudrais que vous essayiez de ce dont je parlais ici et que vous alliez déployer de vrais modules en production (en utilisant des techniques de séparation de code et d'importation dynamique).  Si vous le faites, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">faites-moi savoir</a> comment vous allez.  Je suis intéressé à connaître les problèmes et les cas réussis d'introduction de modules. <br><br>  Il est très clair que les modules sont l’avenir de JavaScript.  J'aimerais voir, et de préférence bientôt, comment les outils que nous utilisons et les bibliothèques auxiliaires adoptent cette technologie.  J'espère que ce matériel pourra au moins aider un peu ce processus. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous des modules JS en production? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466539/">https://habr.com/ru/post/fr466539/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466525/index.html">Qu'est-ce qu'une disposition iPhone PSD et comment l'utiliser?</a></li>
<li><a href="../fr466527/index.html">Test de la fonctionnalité utilisateur du site Web avec les objets de page Capybara</a></li>
<li><a href="../fr466529/index.html">Types de compilation dans la JVM: exposer la session Black Magic</a></li>
<li><a href="../fr466535/index.html">Repenser deepClone</a></li>
<li><a href="../fr466537/index.html">Utilisation de modules JavaScript en production: situation actuelle. Partie 1</a></li>
<li><a href="../fr466541/index.html">Utilisation de DbTool pour amorcer des bases de données dans des applications .NET (Core)</a></li>
<li><a href="../fr466543/index.html">Les prêts Habr Weekly # 17 / Sberbank seront approuvés par AI - effrayant, publicité dans les produits open source - douteux</a></li>
<li><a href="../fr466547/index.html">Bonne fête du programmeur</a></li>
<li><a href="../fr466549/index.html">Principes généraux de fonctionnement de QEMU-KVM</a></li>
<li><a href="../fr466551/index.html">Marionnettiste avec ES6 dans un nœud et un navigateur, ou pourquoi Zora est le meilleur framework de test dans sa niche</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>