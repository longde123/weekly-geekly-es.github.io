<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔰 🕴🏾 🕧 Algoritma penempatan ubin berbasis kendala 🕵🏼 👍 🌳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting ini menjelaskan algoritma yang digunakan dalam Generate Worlds , alat yang memungkinkan pengguna untuk membuat dan menjelajahi dunia prosedura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritma penempatan ubin berbasis kendala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475188/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f37/e4f/998f37e4feeb5b1aef28f76a1b4453e8.jpg" alt="gambar"></div><br>  Posting ini menjelaskan algoritma yang digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generate Worlds</a> , alat yang memungkinkan pengguna untuk membuat dan menjelajahi dunia prosedural dengan membangun set kecil voxel tile.  Saya akan memberikan deskripsi singkat tentang algoritma, dan dalam posting berikut saya akan berbicara tentang kelebihannya dalam kecepatan dan fleksibilitas dibandingkan dengan metode lain.  Untuk mempelajari lebih lanjut tentang apa yang dimaksud dengan generasi prosedural berbasis kendala dan apa yang menarik, saya sarankan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> . <br><br>  Jika Anda ingin menguji kekuatan Anda dalam menciptakan dunia prosedural menggunakan sistem ini, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membeli</a> Generate Worlds.  Jika harga terlalu tinggi untuk Anda, maka lanjutkan membaca: posting ini akan memberi Anda informasi tentang bagaimana menerapkan algoritma Generate Worlds secara mandiri. <br><a name="habracut"></a><br><h3>  Set ubin </h3><br>  Di Generate Worlds, setiap dunia dirakit dari satu <em>set ubin</em> (tileset).  Pada dasarnya, ubin hanyalah model voxel kecil.  Mari kita mulai dengan sebuah contoh.  Gambar di bawah ini terdiri dari 9 ubin.  Seperti yang Anda lihat, setiap ubin terdiri dari voxels yang muncul sebagai kubus berwarna. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/108/c47/1d0/108c471d0bd6a102cacf2ef8011e278e.svg"><br>  Jika Anda mengatur model voxel ini dengan cara yang logis, Anda dapat membuat adegan pastoral yang indah, seperti pada animasi di bawah ini.  Yang dimaksud dengan "logika" adalah ubin yang cocok jika warnanya di sepanjang tepi sambungan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/b9b/8ad/285b9b8ad2f4a095bcd1f734ebec5e9e.gif" alt="gambar"></div><br>  Tugas dari algoritma Generate Worlds adalah untuk dengan cepat dan otomatis menyelesaikan perakitan tersebut.  Sebelum memulai algoritme, mari kita lihat pernyataan masalahnya. <br><br><h3>  Kami menghubungkan ubin di antara mereka sendiri </h3><br>  Lihatlah tileset yang berisi 4 ubin: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/039/02d/6e9/03902d6e96866cd606d89bfbd3678114.png"></div><br>  Ubin ini mirip dengan ubin tiga dimensi yang ditunjukkan di atas. <br><br>  Algoritma Generate Worlds menciptakan <em>kombinasi ubin yang valid</em> menggunakan satu aturan sederhana: <em>jika dua ubin menyentuh satu sama lain, semua warna di sepanjang tepi sentuhan harus cocok</em> .  Aturan ini meresmikan pendekatan yang digunakan oleh desainer hidup untuk membuat dunia 3D dari ubin voxel. <br><br>  Dalam kombinasi yang diizinkan dari 4 ubin yang disajikan di atas, sel-sel cahaya di sepanjang perbatasan harus hanya menyentuh sel-sel cahaya, dan sel gelap harus hanya menyentuh sel-sel gelap.  Sebagai contoh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f5/87c/81a/7f587c81a68124adbec7870583a55eda.svg"></div><br>  <i>Contoh koneksi yang benar dan salah.</i> <br><br>  Contoh di sebelah kanan tidak dapat diterima, karena di sepanjang tepi ubin menyentuh, kotak cahaya menyentuh kotak gelap.  Dua kombinasi valid yang dihasilkan untuk tileset ini ditunjukkan di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02a/a19/87e/02aa1987ea6a2fca68969088e8bd3ea9.png"></div><br>  Dalam kasus umum, membuat kombinasi ubin yang valid bukanlah tugas yang sepele.  Misalnya, pertimbangkan strategi "serakah" sederhana berikut ini: kita mulai dengan kisi kosong.  Di setiap iterasi, kami menempatkan ubin di beberapa titik, memilih ubin yang dapat diterima dengan mempertimbangkan ubin yang sudah ditempatkan.  Diagram di bawah ini menunjukkan masalah dari strategi semacam itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/edd/bcb/aeceddbcbebf2b579949a1c6f96b04fb.svg" alt="penempatan serakah"></div><br>  Jika kita akan menempatkan ubin tanpa melihat bagaimana penempatan akan memengaruhi pilihan masa depan, maka algoritma "serakah" dengan cepat terhenti;  dalam diagram di atas, tidak ada ubin yang valid dapat ditempatkan di kotak merah.  Dan ini adalah masalah utama: ubin yang diposkan sebelumnya dapat mengurangi jumlah opsi saat ini menjadi nol.  Kita perlu beberapa cara untuk melindungi dari memasang ubin, yang dapat membawa kita ke jalan buntu.  Algoritme yang diimplementasikan dalam Generate Worlds dimulai dengan mempertimbangkan semua petak mungkin untuk ditempatkan pada semua titik kisi.  Jika kita menempatkan satu ubin di kotak, maka jelas bahwa beberapa opsi di masa depan menjadi tidak dapat diakses.  Setelah algoritma menghilangkan opsi-opsi ini, kami dapat memeriksa kembali opsi yang tersisa dan menghilangkan ubin lain yang sekarang tidak kompatibel dengan jumlah ubin yang tersisa yang lebih kecil di titik-titik tetangga. <br><br>  Perhatikan contoh berikut.  Algoritme dimulai dengan kisi 3x3, di tengahnya terdapat petak tunggal.  Lokasi ubin ini menyiratkan bahwa 9 ubin yang mungkin pada titik-titik grid tetangga tidak diperbolehkan, jadi ia membuangnya dan tidak lagi mempertimbangkannya.  Setelah menghapus petak ini, ia dapat menghapus petak yang tidak kompatibel dengan semua petak yang dianggap sebagai kandidat untuk penempatan di titik kisi di sebelahnya.  Kotak merah di diagram menandai titik di mana ubin dihapus, karena mereka tidak kompatibel dengan semua tetangga yang masih dipertimbangkan.  Jika algoritma melanjutkan proses ini hingga ada ubin yang dapat dihapus, itu akan kembali ke keadaan yang ditunjukkan di sudut kiri bawah rangkaian.  Seperti yang Anda lihat, banyak ubin dikeluarkan dari pertimbangan.  Jika strategi menempatkan ubin hanya terdiri dari memilih ubin dari kelompok-kelompok yang tersisa ini, maka kemungkinan masuk ke jalan buntu akan jauh lebih rendah daripada dalam pendekatan "serakah" yang dijelaskan di atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/1ba/a2c/2761baa2c29c776b8c38d40ffbfc2507.svg"></div><br>  Masalah dengan pendekatan ini adalah bahwa setiap kali ubin ditempatkan, itu membutuhkan proses berulang yang mahal.  Tetapi perhatikan bahwa setiap kali saya menempatkan ubin dengan T terbalik, 19 ubin yang saya hapus dalam contoh di atas dapat dihapus dari pertimbangan di sekitar penempatan ini.  Saya menyebut kumpulan ubin, yang tetap menjadi opsi yang valid di sekitar ubin yang dihosting, <em>lingkungan</em> ubin <em>yang valid</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f3/71d/5e9/1f371d5e975f66d9dade441076871130.svg"></div><br><h3>  Penempatan ubin cepat berkat caching informasi </h3><br>  <strong>Prinsip terpenting dari algoritma Generate Worlds adalah bahwa informasi yang dikumpulkan tentang kemungkinan tetangga ubin dapat digunakan kembali setiap kali ubin ini ditempatkan.</strong>  Misalnya, dalam kasus T terbalik untuk delapan kotak di sekitarnya, kita dapat menghapus 19 ubin segera setelah menempatkan ubin ini dengan melihat versi cache dari lingkungan yang diizinkan untuk ubin ini. <br><br>  Misalnya, dalam contoh di bawah ini, algoritma mengisi kisi 5x5 dengan ubin menggunakan lingkungan yang diijinkan dalam cache dari 4 ubin.  Setelah menempatkan ubin pertama, ia menghilangkan 19 ubin pertimbangan yang tidak mungkin dalam contoh di atas.  Setelah menempatkan setiap ubin, semua opsi yang tidak ada di lingkungan yang dapat diterima dari ubin ditempatkan dihapus dari pertimbangan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/258/00f/cb625800f505110fbc8df42d11735aa1.svg"></div><br>  Melanjutkan dengan cara ini, kita dapat mengisi seluruh grid dengan hanya pembaruan lokal cepat ke set ubin, yang masih merupakan opsi yang valid untuk masing-masing poin. <br><br>  Lingkungan yang diizinkan dapat ukuran apa pun yang Anda butuhkan, sehingga Anda dapat menghapus ubin yang tidak kompatibel dari jauh setiap kali Anda menempatkan ubin.  Meskipun generasi lingkungan yang dapat diterima agak lambat, perlu dilakukan hanya sekali, setelah itu setiap waktu secara linear tergantung pada ukuran lingkungan untuk mengakomodasi setiap ubin. <br><br><h3>  Memperluas sistem dalam 3D </h3><br>  Algoritma Generate Worlds secara alami berkembang ke dunia yang memiliki dimensi ketiga.  Alih-alih ubin 2D yang cocok dengan warna dengan 4 ubin tetangga di sepanjang wajah yang sama, kami sekarang memiliki ubin 3D yang harus cocok dengan warna di tetangga mereka di sepanjang 6 wajah.  Pertimbangkan ubin 3D berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/835/271/cb4/835271cb4cd44d702e63a2a4b31659c2.svg"></div><br>  Perakitan ubin ini dalam 3D adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/492/a7e/11f/492a7e11f49c10ed645ea0b923eb9390.gif" alt="gambar"></div><br>  Dalam hal ini, lingkungan yang dapat diterima bukan berupa jaringan dua dimensi, tetapi tiga dimensi, dan algoritme menghasilkannya dalam kasus 2D yang serupa. <br><br><h3>  Galeri Hasil </h3><br>  Di bawah ini adalah dunia yang dihasilkan oleh implementasi algoritma ini bersama dengan deskripsi singkat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f37/e4f/998f37e4feeb5b1aef28f76a1b4453e8.jpg"></div><br>  <i>Cuplikan layar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generate Worlds</a> menunjukkan kamar dengan pintu keluar.</i>  <i>Tepian di langit-langit bertepatan dengan batas ubin.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/384/6c3/bcf/3846c3bcfde6900fe6838bfae03b72e1.jpg"></div><br>  <i>Tangkapan layar dari alat lain yang saya buat yang juga menggunakan algoritma Generate Worlds;</i>  <i>berbagai jenis kamar dan koridor ditampilkan.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b21/b6c/3d5/b21b6c3d517ed695c0c4c779c7ee7c55.jpg"></div><br>  <i>Dunia yang mirip dengan yang sebelumnya, tetapi sekarang dalam tampilan isometrik yang indah</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f1/7dd/2c2/4f17dd2c2c1733b0a382cf49ea85394c.png"></div><br>  <i>Dunia, ciptaan yang diilhami saya oleh lingkaran kesembilan Neraka Dante: para pendosa yang membeku di dalam es.</i>  <i>Diberikan dalam MagicaVoxel.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8a/efb/7b4/b8aefb7b4139940854b21344edcf6238.png"></div><br>  <i>Dunia, ciptaan yang diilhami saya oleh putaran kedua neraka Dante: bentang alam, yang diairi oleh hujan yang membakar, yang melintasi jembatan.</i>  <i>Diberikan dalam MagicaVoxel.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/c77/361/627c7736180c96618ef1b43cb6249b18.png"></div><br>  <i>Dunia platform berumput dengan air terjun dan sungai.</i>  <i>Diberikan dalam MagicaVoxel.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a39/09a/856/a3909a8564ab602825e020a4dab6796a.png" alt="dunia kota"></div><br>  <i>Lansekap kota abad pertengahan dengan bangunan dan dinding.</i>  <i>Diberikan dalam MagicaVoxel.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475188/">https://habr.com/ru/post/id475188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475174/index.html">Cara melepas baterai atau sedikit teori paramotor listrik. Bagian 1</a></li>
<li><a href="../id475178/index.html">Mengganti EAV dengan JSONB di PostgreSQL</a></li>
<li><a href="../id475180/index.html">Bagaimana melepas baterai atau praktik mengoperasikan paramotor listrik SkyMax. Bagian 2</a></li>
<li><a href="../id475182/index.html">Bagaimana Saya Memutuskan Kompetisi Pembelajaran Mesin Seperti Data</a></li>
<li><a href="../id475184/index.html">Panggilan sistem Linux yang mewah</a></li>
<li><a href="../id475192/index.html">Bagaimana menemukan pekerjaan di perusahaan yang membantu memerangi pemanasan global?</a></li>
<li><a href="../id475194/index.html">Menulis redux oleh SOLID</a></li>
<li><a href="../id475196/index.html">Intisari materi menarik untuk pengembang ponsel # 321 (pada 4 - 10 November)</a></li>
<li><a href="../id475200/index.html">Berita dari dunia OpenStreetMap No. 484 (10/22/2019 - 28/10/2019)</a></li>
<li><a href="../id475202/index.html">Kesan pertama Xiaomi MIUI 11</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>