<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüåæ üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ ‚¨õÔ∏è Implementaci√≥n de Spring Framework API desde cero. Tutorial para principiantes. Parte 1 ‚ö†Ô∏è üêù üßëüèø‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spring Framework es uno de los marcos m√°s complicados para la comprensi√≥n y el aprendizaje. La mayor√≠a de los desarrolladores lo aprenden lentamente, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementaci√≥n de Spring Framework API desde cero. Tutorial para principiantes. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419679/"><img src="https://habrastorage.org/webt/iw/mz/82/iwmz824_ptetkxwvc6sqtwjmbjw.png"><br><br>  Spring Framework es uno de los marcos m√°s complicados para la comprensi√≥n y el aprendizaje.  La mayor√≠a de los desarrolladores lo aprenden lentamente, a trav√©s de tareas pr√°cticas y google.  Este enfoque no es efectivo, ya que no ofrece una imagen completa y al mismo tiempo es costoso. <br><br>  Me gustar√≠a ofrecerle un enfoque fundamentalmente nuevo para el estudio de la primavera.  Consiste en el hecho de que una persona pasa por una serie de tutoriales especialmente preparados e implementa independientemente el funcionamiento de la primavera.  La peculiaridad de este enfoque es que, adem√°s de una comprensi√≥n del 100% de los aspectos estudiados de Spring, tambi√©n proporciona un gran aumento en Java Core (Anotaciones, Reflexi√≥n, Archivos, Gen√©ricos). <br><br>  El art√≠culo te brindar√° una experiencia inolvidable y te har√° sentir como un desarrollador Pivotal.  Paso a paso, har√° que sus clases sean m√°s agradables y organizar√° su ciclo de vida (lo mismo que en una primavera real).  Las clases que implementar√° son <b>BeanFactory</b> , <b>Component</b> , <b>Service</b> , <b>BeanPostProcessor</b> , <b>BeanNameAware</b> , <b>BeanFactoryAware</b> , <b>InitializingBean</b> , <b>PostConstruct</b> , <b>PreDestroy</b> , <b>DisposableBean</b> , <b>ApplicationContext</b> , <b>ApplicationListener</b> , <b>ContextClosedEvent</b> . <br><a name="habracut"></a><br><h2>  Un poco sobre ti </h2><br>  Mi nombre es Yaroslav y soy un desarrollador de Java con 4 a√±os de experiencia.  En este momento trabajo para EPAM Systems (SPB) y profundizo en las tecnolog√≠as que utilizamos.  Muy a menudo tengo que lidiar con la primavera, y veo en ella un t√©rmino medio en el que puedes crecer (Java todo el mundo lo sabe muy bien, y las herramientas y tecnolog√≠as demasiado espec√≠ficas pueden ir y venir). <br><br>  Hace un par de meses, pas√© la certificaci√≥n Spring Professional v5.0 (sin tomar cursos).  Despu√©s de eso, pens√© en c√≥mo ense√±ar a otras personas a saltar.  Desafortunadamente, por el momento no existe una metodolog√≠a de ense√±anza efectiva.  La mayor√≠a de los desarrolladores tienen una idea muy superficial del marco y sus caracter√≠sticas.  La depuraci√≥n de las fuentes de primavera es demasiado dif√≠cil y absolutamente no efectiva desde el punto de vista del entrenamiento (de alguna manera me gustaba).  ¬ø10 proyectos?  S√≠, puede profundizar su conocimiento en alg√∫n lugar y obtener mucha experiencia pr√°ctica, pero gran parte de lo que est√° "bajo el cap√≥" nunca se abrir√° ante usted.  Leer la primavera en acci√≥n?  Genial, pero costoso en esfuerzo.  Lo trabaj√© un 40% (durante la preparaci√≥n para la certificaci√≥n), pero no fue f√°cil. <br><br>  La √∫nica forma de entender algo hasta el final es desarrollarlo usted mismo.  Recientemente, tuve la idea de que puedes guiar a una persona a trav√©s de un interesante tutorial que supervisar√° el desarrollo de su marco DI.  Su caracter√≠stica principal ser√° que la API coincidir√° con la API que se est√° estudiando.  La genialidad de este enfoque es que, adem√°s de una comprensi√≥n profunda (sin espacios) de la primavera, una persona obtendr√° una GRAN cantidad de experiencia en Java Core.  Francamente, yo mismo aprend√≠ muchas cosas nuevas durante la preparaci√≥n del art√≠culo, tanto en Spring como en Java Core.  ¬°Comencemos a desarrollar! <br><br><h2>  Proyecto desde cero </h2><br>  Entonces, lo primero que debe hacer es abrir su IDE favorito y crear un proyecto desde cero.  No conectaremos ninguna biblioteca de Maven ni de terceros.  Ni siquiera conectaremos las dependencias de Spring.  Nuestro objetivo es desarrollar una API que sea m√°s similar a Spring API e implementarla nosotros mismos. <br><br>  En un proyecto limpio, cree 2 paquetes principales.  El primer paquete es su aplicaci√≥n ( <code>com.kciray</code> ) y la clase <code>Main.java</code> dentro de √©l.  El segundo paquete es org.springframework.  S√≠, duplicaremos la estructura del paquete del resorte original, el nombre de sus clases y sus m√©todos.  Hay un efecto tan interesante: cuando creas algo propio, el tuyo comienza a parecer simple y comprensible.  Luego, cuando trabaje en proyectos grandes, le parecer√° que todo se crea all√≠ en funci√≥n de su pieza de trabajo.  Este enfoque puede tener un efecto muy positivo en la comprensi√≥n del sistema en su conjunto, mejorarlo, corregir errores, resolver problemas, etc. <br><br>  Si tiene alg√∫n problema, puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">realizar un</a> proyecto de trabajo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  Crea un contenedor </h2><br>  Para comenzar, configure la tarea.  Supongamos que tenemos 2 clases: <code>ProductFacade</code> y <code>PromotionService</code> .  Ahora imagine que desea conectar estas clases entre s√≠, pero para que las clases mismas no se conozcan entre s√≠ (Patr√≥n DI).  Necesitamos una clase separada que gestione todas estas clases y determine las dependencias entre ellas.  Llam√©moslo un contenedor.  Creemos la clase <code>Container</code> ... Aunque no, ¬°espera!  Spring no tiene una sola clase de contenedor.  Tenemos muchas implementaciones de contenedores, y todas estas implementaciones se pueden dividir en 2 tipos: f√°bricas de contenedores y contextos.  La f√°brica de contenedores crea beans y los vincula (inyecci√≥n de dependencia, DI), y el contexto hace casi lo mismo, adem√°s agrega algunas caracter√≠sticas adicionales (por ejemplo, mensajes de internacionalizaci√≥n).  Pero ahora no necesitamos estas funciones adicionales, por lo que trabajaremos con la f√°brica de contenedores. <br><br>  Cree una nueva clase <code>BeanFactory</code> y p√≥ngala en el paquete <code>org.springframework.beans.factory</code> .  Deje que los <code>Map&lt;String, Object&gt; singletons</code> almacenen dentro de esta clase, en la que el <code>id</code> bin se asigna al bin en s√≠.  Agregue el <code>Object getBean(String beanName)</code> , que extrae los beans por identificador. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Object&gt; singletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String beanName)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singletons.get(beanName); } }</code> </pre> <br>  Tenga en cuenta que <code>BeanFactory</code> y <code>FactoryBean</code> son dos cosas diferentes.  El primero es la f√°brica de contenedores (contenedor), y el segundo es la f√°brica de contenedores, que se encuentra dentro del contenedor y tambi√©n produce contenedores.  F√°brica dentro de la f√°brica.  Si est√° confundido entre estas definiciones, puede recordar que en ingl√©s el segundo sustantivo es el principal y el primero es algo as√≠ como un adjetivo.  En Bean <b>Factory, la</b> palabra principal es f√°brica, y en Factory <b>Bean</b> , el frijol. <br><br>  Ahora, cree las clases <code>ProductService</code> y <code>PromotionsService</code> .  <code>ProductService</code> devolver√° el producto de la base de datos, pero antes de eso debe verificar si se aplican descuentos (Promociones) a este producto.  En el comercio electr√≥nico, el trabajo con descuento a menudo se asigna a una clase de servicio separada (y a veces a un servicio web de terceros). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PromotionsService promotionsService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PromotionsService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promotionsService; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PromotionsService promotionsService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.promotionsService = promotionsService; } }</code> </pre><br>  Ahora tenemos que hacer que nuestro contenedor ( <code>BeanFactory</code> ) detecte nuestras clases, crearlas para nosotros e inyectar una en la otra.  Las operaciones como el <code>new ProductService()</code> deben ubicarse dentro del contenedor y realizarse para el desarrollador.  Usemos el enfoque m√°s moderno (escaneo de clase y anotaciones).  Para hacer esto, necesitamos crear una anotaci√≥n <code>@Component</code> con las <code>@Component</code> ( <code> org.springframework.beans.factory.stereotype</code> ). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Component { }</code> </pre><br>  De forma predeterminada, las anotaciones no se cargan en la memoria mientras se ejecuta el programa ( <code>RetentionPolicy.CLASS</code> ).  Cambiamos este comportamiento a trav√©s de una nueva pol√≠tica de retenci√≥n ( <code>RetentionPolicy.RUNTIME</code> ). <br><br>  Ahora agregue <code>@Component</code> antes de las clases <code>ProductService</code> y antes de <code>PromotionService</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } @Component public class PromotionService { //... }</span></span></code> </pre> <br><br>  Necesitamos <code>BeanFactory</code> escanear nuestro paquete ( <code>com.kciray</code> ) y encontrar clases en √©l anotadas por <code>@Component</code> .  Esta tarea est√° lejos de ser trivial.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay una soluci√≥n preparada</a> en Java Core, y tendremos que hacer una muleta nosotros mismos.  Miles de aplicaciones de resorte utilizan escaneo de componentes a trav√©s de esta muleta.  Has aprendido la terrible verdad.  Tendr√° que extraer los nombres de <code>ClassLoader</code> de <code>ClassLoader</code> y verificar <code>ClassLoader</code> terminan con ".class" o no, y luego construir su nombre completo y extraer objetos de clase de √©l. <br><br>  Quiero advertirle de inmediato que habr√° muchas excepciones marcadas, as√≠ que prep√°rese para envolverlas.  Pero primero, decidamos qu√© queremos.  Queremos agregar un m√©todo especial a <code>BeanFactory</code> y llamarlo en <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java public class BeanFactory{ public void instantiate(String basePackage) { } } //Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray");</span></span></code> </pre><br>  A continuaci√≥n, necesitamos obtener <code>ClassLoader</code> .  Es responsable de cargar las clases, y se extrae de manera bastante simple: <br><br><pre> <code class="java hljs">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</code> </pre> <br>  Probablemente ya haya notado que los paquetes est√°n separados por un punto y los archivos por una barra diagonal.  Necesitamos convertir la ruta del lote a la ruta de la carpeta y obtener algo como <code>List&lt;URL&gt;</code> (las rutas en su sistema de archivos donde puede buscar archivos de clase). <br><br><pre> <code class="java hljs">String path = basePackage.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//"com.kciray" -&gt; "com/kciray" Enumeration&lt;URL&gt; resources = classLoader.getResources(path);</span></span></code> </pre> <br>  ¬°Espera un momento!  <code>Enumeration&lt;URL&gt;</code> no es una <code>List&lt;URL&gt;</code> .  ¬øDe qu√© se trata todo esto?  Oh, horror, este es el antiguo progenitor de <code>Iterator</code> , disponible desde Java 1.0.  Este es el legado con el que tenemos que lidiar.  Si es posible recorrer <code>Iterable</code> usando for (todas las colecciones lo implementan), entonces, en el caso de <code>Enumeration</code> , tendr√° que hacer un bypass de manejador, <code>while(resources.hasMoreElements())</code> y <code>nextElement()</code> .  Y, sin embargo, no hay forma de eliminar elementos de la colecci√≥n.  Solo 1996, solo hardcore.  Ah, s√≠, en Java 9 agregaron el m√©todo <code>Enumeration.asIterator()</code> , para que pueda resolverlo. <br><br>  Vamos m√°s all√°.  Necesitamos extraer las carpetas y trabajar a trav√©s del contenido de cada una de ellas.  Convierta la URL en un archivo y luego obtenga su nombre.  Cabe se√±alar aqu√≠ que no escanearemos paquetes anidados para no complicar el c√≥digo.  Puede complicar su tarea y hacer una recursi√≥n si lo desea. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (resources.hasMoreElements()) { URL resource = resources.nextElement(); File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(resource.toURI()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(File classFile : file.listFiles()){ String fileName = classFile.getName();<span class="hljs-comment"><span class="hljs-comment">//ProductService.class } }</span></span></code> </pre><br>  A continuaci√≥n, necesitamos obtener el nombre del archivo sin la extensi√≥n.  En el patio en 2018, Java ha desarrollado File I / O (NIO 2) durante muchos a√±os, pero a√∫n no puede separar la extensi√≥n del nombre del archivo.  Tengo que crear mi propia bicicleta, porque  decidimos no utilizar bibliotecas de terceros como Apache Commons.  <code>lastIndexOf(".")</code> el antiguo m√©todo de abuelo <code>lastIndexOf(".")</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fileName.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>)){ String className = fileName.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"."</span></span>)); }</code> </pre> <br>  A continuaci√≥n, podemos obtener el objeto de clase usando el nombre completo de la clase (para esto llamamos la clase de la clase <code>Class</code> ): <br><br><pre> <code class="java hljs">Class classObject = Class.forName(basePackage + <span class="hljs-string"><span class="hljs-string">"."</span></span> + className);</code> </pre> <br>  Bien, ahora nuestras clases est√°n en nuestras manos.  Adem√°s, solo queda destacar entre ellos aquellos que tienen la anotaci√≥n <code>@Component</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(classObject.isAnnotationPresent(Component.class)){ System.out.println(<span class="hljs-string"><span class="hljs-string">"Component: "</span></span> + classObject); }</code> </pre> <br>  Corre y comprueba.  La consola deber√≠a ser algo como esto: <br><br><pre> <code class="bash hljs">Component: class com.kciray.ProductService Component: class com.kciray.PromotionsService</code> </pre> <br>  Ahora necesitamos crear nuestro bean.  Debe hacer algo como el <code>new ProductService()</code> , pero para cada bean tenemos nuestra propia clase.  Reflection in Java nos proporciona una soluci√≥n universal (se llama al constructor predeterminado): <br><br><pre> <code class="java hljs">Object instance = classObject.newInstance();<span class="hljs-comment"><span class="hljs-comment">//=new CustomClass()</span></span></code> </pre> <br>  A continuaci√≥n, tenemos que poner este bean en <code>Map&lt;String, Object&gt; singletons</code> .  Para hacer esto, seleccione el nombre del bean (su id).  En Java, llamamos variables como clases (solo la primera letra es min√∫scula).  Este enfoque tambi√©n se puede aplicar a los beans, porque Spring es un framework Java.  Convierta el nombre del contenedor para que la primera letra sea peque√±a y agr√©guela al mapa: <br><br><pre> <code class="java hljs">String beanName = className.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase() + className.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); singletons.put(beanName, instance);</code> </pre> <br>  Ahora aseg√∫rese de que todo funcione.  El contenedor debe crear beans y se deben recuperar por nombre.  Tenga en cuenta que el nombre de su m√©todo <code>instantiate()</code> y el nombre del m√©todo <code>classObject.newInstance();</code>  tener una ra√≠z com√∫n  Adem√°s, <code>instantiate()</code> es parte del ciclo de vida del frijol.  ¬°En Java, todo est√° interconectado! <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray"); ProductService productService = (ProductService) beanFactory.getBean("productService"); System.out.println(productService);//ProductService@612</span></span></code> </pre> <br><br>  Intente tambi√©n implementar la anotaci√≥n <code>org.springframework.beans.factory.stereotype.Service</code> .  Realiza exactamente la misma funci√≥n que <code>@Component</code> , pero se llama de manera diferente.  Todo el asunto est√° en el nombre: demuestras que la clase es un servicio, no solo un componente.  Esto es algo as√≠ como la tipificaci√≥n conceptual.  En la certificaci√≥n de primavera hubo una pregunta: "¬øQu√© anotaciones son estereotipadas?"  (de los mencionados) ".  Entonces, las anotaciones estereotipadas son aquellas que est√°n en el paquete de <code>stereotype</code> . <br><br><h2>  Rellena las propiedades </h2><br>  Mire el diagrama a continuaci√≥n, muestra el comienzo del ciclo de vida del frijol.  Lo que hicimos antes de esto es Instantiate (creando beans mediante <code>newInstance()</code> ).  El siguiente paso es la inyecci√≥n cruzada de beans (inyecci√≥n de dependencia, tambi√©n es la inversi√≥n de control (IoC)).  Debe revisar las propiedades de los beans y comprender qu√© propiedades debe inyectar.  Si llama a <code>productService.getPromotionsService()</code> , obtendr√° <code>null</code> , porque  dependencia a√∫n no agregada. <br><br><img src="https://habrastorage.org/webt/2i/4v/4c/2i4v4cbsb-bdpdrgb0grh_swclu.png"><br><br>  Primero, cree el paquete <code>org.springframework.beans.factory.annotation</code> y agregue la anotaci√≥n <code>@Autowired</code> .  La idea es marcar los campos que son dependencias con esta anotaci√≥n. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Autowired { }</code> </pre> <br>  A continuaci√≥n, agr√©guelo a la propiedad: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> PromotionsService promotionsService; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Ahora necesitamos ense√±ar a nuestra <code>BeanFactory</code> encontrar estas anotaciones e inyectar dependencias en ellas.  Agregue un m√©todo separado para esto y ll√°melo desde <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... public void populateProperties(){ System.out.println("==populateProperties=="); } }</span></span></code> </pre> <br>  A continuaci√≥n, solo tenemos que revisar todos nuestros bins en el mapa de <code>singletons</code> , y para cada bin ir a trav√©s de todos sus campos ( <code>object.getClass().getDeclaredFields()</code> devuelve todos los campos, incluidos los privados).  Y verifique si el campo tiene una anotaci√≥n <code>@Autowired</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Field field : object.getClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.isAnnotationPresent(Autowired.class)) { } } }</code> </pre> <br>  Luego, tenemos que revisar todos los contenedores una vez m√°s y ver su tipo; de repente, este es el tipo que nuestro contenedor quiere tomar por s√≠ mismo.  ¬°S√≠, tenemos un ciclo tridimensional! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object dependency : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependency.getClass().equals(field.getType())) { } }</code> </pre> <br>  Adem√°s, cuando encontramos la adicci√≥n, necesitamos inyectarla.  Lo primero que puede pensar es escribir el campo de servicio de <code>promotionsService</code> usando la reflexi√≥n directamente.  Pero la primavera no funciona as√≠.  Despu√©s de todo, si el campo tiene un modificador <code>private</code> , primero tendremos que configurarlo como <code>public</code> , luego escribir nuestro valor, luego configurarlo nuevamente como <code>private</code> (para mantener la integridad).  Suena como una gran muleta.  En lugar de una muleta grande, hagamos una muleta peque√±a (formaremos el nombre del setter y lo llamaremos): <br><br><pre> <code class="java hljs">String setterName = <span class="hljs-string"><span class="hljs-string">"set"</span></span> + field.getName().substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + field.getName().substring(<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//setPromotionsService System.out.println("Setter name = " + setterName); Method setter = object.getClass().getMethod(setterName, dependency.getClass()); setter.invoke(object, dependency);</span></span></code> </pre> <br>  Ahora ejecute su proyecto y aseg√∫rese de que al llamar a <code>productService.getPromotionsService()</code> lugar de <code>null</code> , se devuelva nuestro bean. <br><br>  Lo que hemos implementado es inyecci√≥n por tipo.  Tambi√©n hay una inyecci√≥n por nombre (anotaci√≥n <code>javax.annotation.Resource</code> ).  Se diferencia en que, en lugar del tipo de campo, se extraer√° su nombre y, seg√∫n este, la dependencia del mapa.  Aqu√≠ todo es similar, incluso en algo m√°s simple.  Le recomiendo que experimente y cree su propio bean, y luego lo inyecte con <code>@Resource</code> y extienda el m√©todo <code>populateProperties()</code> . <br><br><h2>  Apoyamos los frijoles que saben sobre su nombre. </h2><br><img src="https://habrastorage.org/webt/ds/ge/nn/dsgennl2rvz-spa6h51l_yox81o.png"><br><br>  Hay momentos en los que necesitas poner su nombre dentro del contenedor.  Tal necesidad no surge a menudo, porque  Los contenedores, en esencia, no deben conocerse entre s√≠ y que son contenedores.  En las primeras versiones de la primavera, se supon√≠a que el bean es un POJO (Objeto de Java antiguo simple, el buen objeto de Java antiguo), y toda la configuraci√≥n se representa en archivos XML y se separa de la implementaci√≥n.  Pero implementamos esta funcionalidad, ya que la inyecci√≥n de nombre es parte del ciclo de vida del contenedor. <br><br>  ¬øC√≥mo sabemos qu√© bean quiere saber cu√°l es su nombre y qu√© no quiere?  Lo primero que viene a la mente es hacer una nueva anotaci√≥n de tipo <code>@InjectName</code> y esculpirla en campos de tipo String.  Pero esta soluci√≥n ser√° demasiado general y le permitir√° dispararse en el pie muchas veces (coloque esta anotaci√≥n en campos de tipos inapropiados (no String) o intente inyectar un nombre en varios campos de la misma clase).  Hay otra soluci√≥n, m√°s precisa: crear una interfaz especial con un m√©todo de configuraci√≥n.  Todos los contenedores que lo implementan reciben su nombre.  Cree la clase <code>BeanNameAware</code> en el paquete <code>org.springframework.beans.factory</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br>  A continuaci√≥n, deje que nuestro Servicio de <code>PromotionsService</code> implemente: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String beanName; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ beanName = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanName; } }</code> </pre> <br>  Y finalmente, agregue un nuevo m√©todo a la f√°brica de frijoles.  Aqu√≠ todo es simple: revisamos nuestro bin-singleton, verificamos si el bin implementa nuestra interfaz y llamamos al configurador: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectBeanNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BeanNameAware){ ((BeanNameAware) bean).setBeanName(name); } } }</code> </pre> <br>  Corre y aseg√∫rate de que todo funcione: <br><br><pre> <code class="java hljs">BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); beanFactory.instantiate(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); beanFactory.populateProperties(); beanFactory.injectBeanNames(); <span class="hljs-comment"><span class="hljs-comment">//... System.out.println("Bean name = " + promotionsService.getBeanName());</span></span></code> </pre><br>  Cabe se√±alar que en la primavera hay otras interfaces similares.  Le recomiendo que implemente la interfaz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BeanFactoryAware usted mismo</a> , lo que permite que los beans reciban un enlace a la f√°brica de beans.  Se implementa de manera similar. <br><br><h2>  Inicializar frijoles </h2><br><img src="https://habrastorage.org/webt/yq/0w/5t/yq0w5t8x0kqrgqwllfuxsi77xug.png"><br><br>  Imagine que tiene una situaci√≥n en la que necesita ejecutar algo de c√≥digo despu√©s de que se hayan inyectado las dependencias (se establecen las propiedades del contenedor).  En t√©rminos simples, debemos darle al contenedor la capacidad de inicializarse.  Alternativamente, podemos crear una interfaz <code>InitializingBean</code> y ponerle la firma del m√©todo <code>void afterPropertiesSet()</code> .  La implementaci√≥n de este mecanismo es exactamente la misma que la presentada para la interfaz <code>BeanNameAware</code> , por lo que la soluci√≥n est√° bajo el spoiler.  Practica y hazlo t√∫ mismo en un minuto: <br><br><div class="spoiler">  <b class="spoiler_title">Soluci√≥n de inicializaci√≥n de frijoles</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//InitializingBean.java package org.springframework.beans.factory; public interface InitializingBean { void afterPropertiesSet(); } //BeanFactory.java public void initializeBeans(){ for (Object bean : singletons.values()) { if(bean instanceof InitializingBean){ ((InitializingBean) bean).afterPropertiesSet(); } } } //Main.java beanFactory.initializeBeans();</span></span></code> </pre> <br></div></div><br><br><h2>  Agregar procesadores posteriores </h2><br>  Imag√≠nese en el lugar de los primeros desarrolladores de primavera.  Su marco est√° creciendo y es muy popular entre los desarrolladores, se env√≠an cartas por correo todos los d√≠as con solicitudes para agregar una u otra caracter√≠stica √∫til.  Si para cada caracter√≠stica agrega su propia interfaz y la verifica en el ciclo de vida del bean, entonces (el ciclo de vida) se obstruir√° con informaci√≥n innecesaria.  En su lugar, podemos crear una interfaz universal que le permita agregar algo de l√≥gica (absolutamente ninguna, ya sea verificar la anotaci√≥n, reemplazar el bin con otro bin, establecer algunas propiedades especiales, etc.). <br><br>  Pensemos para qu√© sirve esta interfaz.  Necesita realizar un procesamiento posterior de los beans, por lo tanto, puede llamarse BeanPostProcessor.  Pero nos enfrentamos a una pregunta dif√≠cil: ¬øcu√°ndo se debe seguir la l√≥gica?  Despu√©s de todo, podemos ejecutarlo antes de la inicializaci√≥n, pero podemos ejecutarlo despu√©s.  Para algunas tareas, la primera opci√≥n es mejor, para otras, la segunda ... ¬øC√≥mo ser? <br><br>  Podemos habilitar ambas opciones a la vez.  Deje que un postprocesador lleve dos l√≥gicas, dos m√©todos.  Uno se ejecuta antes de la inicializaci√≥n (antes del m√©todo <code>afterPropertiesSet()</code> ) y el otro despu√©s.  Ahora pensemos en los m√©todos mismos: ¬øqu√© par√°metros deber√≠an tener?  Obviamente, el <code>Object bean</code> s√≠ ( <code>Object bean</code> ) debe estar all√≠.  Por conveniencia, adem√°s del bean, puede pasar el nombre de este bean.  Recuerda que el contenedor en s√≠ mismo no conoce su nombre.  Y no queremos obligar a todos los beans a implementar la interfaz BeanNameAware.  Pero, en el nivel posterior al procesador, el nombre del bean puede ser muy √∫til.  Por lo tanto, lo agregamos como el segundo par√°metro. <br><br>  ¬øY qu√© deber√≠a devolver el m√©todo cuando se procesa el bean?  Hagamos que devuelva el contenedor en s√≠.  Esto nos da una gran flexibilidad, porque en lugar de un contenedor, puede deslizar un objeto proxy que envuelve sus llamadas (y agrega seguridad).  O puede devolver completamente otro objeto volviendo a crear el contenedor nuevamente.  Los desarrolladores tienen una gran libertad de acci√≥n.  A continuaci√≥n se muestra la versi√≥n final de la interfaz dise√±ada: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.beans.factory.config; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; }</code> </pre> <br>  A continuaci√≥n, necesitamos agregar una lista de procesadores simples a nuestra f√°brica de frijoles y la capacidad de agregar otros nuevos.  S√≠, esta es una ArrayList regular. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java private List&lt;BeanPostProcessor&gt; postProcessors = new ArrayList&lt;&gt;(); public void addPostProcessor(BeanPostProcessor postProcessor){ postProcessors.add(postProcessor); }</span></span></code> </pre> <br>  Ahora cambie el m√©todo <code>initializeBeans</code> para que tenga en cuenta los postprocesadores: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeBeans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeforeInitialization(bean, name); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> InitializingBean) { ((InitializingBean) bean).afterPropertiesSet(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessAfterInitialization(bean, name); } } }</code> </pre> <br>  Creemos un peque√±o postprocesador que simplemente rastree las llamadas a la consola y agr√©guelo a nuestra f√°brica de frijoles: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor Before "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor After "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.addPostProcessor(new CustomPostProcessor());</span></span></code> </pre> <br><br>  Ahora corre y aseg√∫rate de que todo funcione.  Como tarea de capacitaci√≥n, cree un postprocesador que proporcione la anotaci√≥n <code>@PostConstruct (javax.annotation.PostConstruct)</code> .  Proporciona una forma alternativa de inicializar (arraigado en Java, no en primavera).  Su esencia es que coloca la anotaci√≥n en alg√∫n m√©todo, y este m√©todo se denominar√° ANTES de la inicializaci√≥n de resorte est√°ndar (InitializingBean). <br><br>  Aseg√∫rese de crear todas las anotaciones y paquetes (incluso javax.annotation) manualmente, ¬°no conecte las dependencias!  Esto lo ayudar√° a ver la diferencia entre el n√∫cleo de resorte y sus extensiones (soporte javax), y recordarlo.  Esto mantendr√° un estilo en el futuro. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Te interesar√° el hecho de que en un verdadero resorte la anotaci√≥n </font></font><code>@PostConstruct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se implementa de esta manera, a trav√©s del postprocesador CommonAnnotationBeanPostProcessor. </font><font style="vertical-align: inherit;">Pero no mires all√≠, escribe tu implementaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por √∫ltimo, le recomiendo que agregue un m√©todo </font></font><code>void close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la clase </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y resuelva dos mecanismos m√°s. </font><font style="vertical-align: inherit;">La primera es una anotaci√≥n </font></font><code>@PreDestroy (javax.annotation.PreDestroy)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, destinada a los m√©todos que deber√≠an llamarse cuando el contenedor est√° cerrado. </font><font style="vertical-align: inherit;">El segundo es la interfaz </font></font><code>org.springframework.beans.factory.DisposableBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que contiene el m√©todo </font></font><code>void destroy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Todos los contenedores que ejecutan esta interfaz tendr√°n la capacidad de destruirse a s√≠ mismos (liberar recursos, por ejemplo).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@PreDestroy + Bean desechable</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//DisposableBean.java package org.springframework.beans.factory; public interface DisposableBean { void destroy(); } //PreDestroy.java package javax.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface PreDestroy { } //DisposableBean.java public void close() { for (Object bean : singletons.values()) { for (Method method : bean.getClass().getMethods()) { if (method.isAnnotationPresent(PreDestroy.class)) { try { method.invoke(bean); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } if (bean instanceof DisposableBean) { ((DisposableBean) bean).destroy(); } } }</span></span></code> </pre> <br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ciclo de vida completo del frijol </font></font></h2><img src="https://habrastorage.org/webt/ns/uh/lk/nsuhlk9ko9d9gxtzmcytopfruim.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ que hemos implementado el ciclo de vida completo del contenedor, en su forma moderna. </font><font style="vertical-align: inherit;">Espero que este enfoque te ayude a recordarlo.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nuestro contexto favorito </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los programadores muy a menudo usan el t√©rmino contexto, pero no todos entienden lo que realmente significa. </font><font style="vertical-align: inherit;">Ahora pondremos todo en orden. </font><font style="vertical-align: inherit;">Como se√±al√© al principio del art√≠culo, el contexto es la implementaci√≥n del contenedor, as√≠ como tambi√©n </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero, adem√°s de las funciones b√°sicas (DI), todav√≠a agrega algunas caracter√≠sticas interesantes. </font><font style="vertical-align: inherit;">Una de estas caracter√≠sticas es enviar y procesar eventos entre contenedores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El art√≠culo result√≥ ser demasiado grande y el contenido comenz√≥ a cortarse, as√≠ que puse la informaci√≥n de contexto debajo del spoiler.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos damos cuenta del contexto</font></font></b> <div class="spoiler_text">    .   <code>org.springframework.context</code> ,   <code>ApplicationContext</code>  .        <code>BeanFactory</code> .      ,      <code>close()</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String basePackage)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException</span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"******Context is under construction******"</span></span>); beanFactory.instantiate(basePackage); beanFactory.populateProperties(); beanFactory.injectBeanNames(); beanFactory.initializeBeans(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); } }</code> </pre> <br><br>     <code>Main</code> ,   ,   : <br><br><pre> <code class="java hljs">ApplicationContext applicationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationContext(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); applicationContext.close();</code> </pre> <br>   ,   .       <code>close()</code> ,     ¬´ ¬ª     - .   ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context.event; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>      <code>ApplicationListener</code> ,      .        ,          ( <code>ApplicationListener&lt;E&gt;</code> ). ,    Java-,         . ,      ,    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E event)</span></span></span></span>; }</code> </pre> <br>     <code>ApplicationContext</code> .     <code>close()</code>     ,  ,      .    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     <code>onApplicationEvent(ContextClosedEvent)</code> .    ,   ? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Object bean : beanFactory.getSingletons().values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ApplicationListener) { } } }</code> </pre> <br>  Pero no   .       <code>bean instanceof ApplicationListener&lt;ContextClosedEvent&gt;</code> .      Java.      <i>  (type erasure)</i> ,    &lt;T&gt;   &lt;Object&gt;.   ,   ?    ,    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     ? <br><br>   ,       ,       .  ,      ,    ,     ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Type type: bean.getClass().getGenericInterfaces()){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ParameterizedType){ ParameterizedType parameterizedType = (ParameterizedType) type; } }</code> </pre> <br> ,       ,  ,   ‚Äî   .   ,         : <br><br><pre> <code class="java hljs">Type firstParameter = parameterizedType.getActualTypeArguments()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstParameter.equals(ContextClosedEvent.class)){ Method method = bean.getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"onApplicationEvent"</span></span>, ContextClosedEvent.class); method.invoke(bean, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContextClosedEvent()); }</code> </pre> <br>        ApplicationListener: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @Override public void onApplicationEvent(ContextClosedEvent event) { System.out.println("&gt;&gt; ContextClosed EVENT"); } }</span></span></code> </pre> <br> ,     Main  ,    ,   : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java void testContext() throws ReflectiveOperationException{ ApplicationContext applicationContext = new ApplicationContext("com.kciray"); applicationContext.close(); }</span></span></code> </pre> <br></div></div><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, plane√© este art√≠culo para Baeldung en ingl√©s, pero luego pens√© que la audiencia del Habr√© podr√≠a evaluar positivamente este enfoque de capacitaci√≥n. </font><font style="vertical-align: inherit;">Si le gustaron mis ideas, aseg√∫rese de apoyar el art√≠culo. </font><font style="vertical-align: inherit;">Si obtiene una calificaci√≥n de m√°s de 30, entonces prometo continuar. </font><font style="vertical-align: inherit;">Al escribir el art√≠culo, trat√© de mostrar exactamente el conocimiento de Spring Core, que se usa con mayor frecuencia, y tambi√©n basado en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gu√≠a de estudio de certificaci√≥n Core Spring 5.0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En el futuro, con la ayuda de dichos tutoriales, puede cubrir toda la certificaci√≥n y hacer que la primavera sea m√°s accesible para los desarrolladores de Java.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actualizaci√≥n 10/05/2018 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constantemente me llegan cartas con preguntas "y cuando la continuaci√≥n, lo estamos esperando". </font><font style="vertical-align: inherit;">Pero no hay tiempo en absoluto, y otros proyectos personales son una prioridad. </font><font style="vertical-align: inherit;">Sin embargo, si a uno de ustedes realmente le gust√≥ la idea, puede estudiar la secci√≥n estrecha de la primavera y escribir un art√≠culo de continuaci√≥n. </font><font style="vertical-align: inherit;">Si no tiene una cuenta habr, entonces puedo publicar un art√≠culo de mi cuenta o ayudarlo a obtener una invitaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distribuci√≥n de temas: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Container - [nombre de usuario] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring AOP - [nombre de usuario] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Web - [nombre de usuario] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Cloud - [nombre de usuario]</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419679/">https://habr.com/ru/post/es419679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419669/index.html">Diez mejores ratones para juegos para cualquier billetera</a></li>
<li><a href="../es419671/index.html">Limitaciones que deben violarse o c√≥mo aceleramos las pruebas funcionales tres veces</a></li>
<li><a href="../es419673/index.html">El universo primitivo 6. La din√°mica de un universo en expansi√≥n homog√©neo, parte 2</a></li>
<li><a href="../es419675/index.html">Revisi√≥n del alquiler por minuto de scooters el√©ctricos en Mosc√∫, verano de 2018</a></li>
<li><a href="../es419677/index.html">C√≥mo rastrear el tr√°fico HTTPS de un dispositivo iOS</a></li>
<li><a href="../es419683/index.html">¬øQu√© significan las m√©tricas para los equipos √°giles?</a></li>
<li><a href="../es419685/index.html">Las estructuras de datos m√°s importantes que debe conocer sobre su entrevista de programaci√≥n</a></li>
<li><a href="../es419687/index.html">Secret Keyboard Level 3 o c√≥mo imprimir un gui√≥n largo</a></li>
<li><a href="../es419689/index.html">I. Desadaptaci√≥n. II ¬øTDAH o un imb√©cil perezoso?</a></li>
<li><a href="../es419693/index.html">Mikrotik: reinicio, copias de seguridad y DualBoot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>