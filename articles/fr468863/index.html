<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñï üîÄ üèà Internals Go: boucler les variables de boucle en fermeture ‚öôÔ∏è ü¶ë üìô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, j'ai d√©cid√© de traduire pour vous un court article sur l'int√©rieur de la mise en ≈ìuvre des soi-disant fermetures ou fermetures. De plus, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Internals Go: boucler les variables de boucle en fermeture</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468863/"><p><img src="https://habrastorage.org/webt/a2/v0/es/a2v0es8qfgkdntuzeattfznxanq.jpeg"></p><br><p>  <em>Aujourd'hui, j'ai d√©cid√© de traduire pour vous un court article sur l'int√©rieur de la mise en ≈ìuvre des soi-disant fermetures ou fermetures.</em>  <em>De plus, vous apprendrez comment Go essaie de d√©terminer automatiquement s'il faut utiliser un pointeur / lien ou une valeur dans diff√©rents cas.</em>  <em>Comprendre ces choses √©vitera les erreurs.</em>  <em>Et c'est juste que tous ces int√©rieurs sont sacr√©ment int√©ressants, je pense!</em> </p><br><p>  <em>Et je voudrais √©galement vous inviter √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Golang Conf 2019</a> , qui se tiendra le 7 octobre √† Moscou.</em>  <em>Je suis membre du comit√© de programme de la conf√©rence et mes coll√®gues et moi avons choisi de nombreux rapports tout aussi inconditionnels et tr√®s, tr√®s int√©ressants.</em>  <em>Ce que j'aime!</em> </p><br><p>  <em>Sous la coupe, je passe le mot √† l'auteur.</em> </p><a name="habracut"></a><br><br><p>  Il y a une page sur le wiki de Go intitul√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Erreurs fr√©quentes</a> .  Curieusement, il n'y a qu'un seul exemple: la mauvaise utilisation des variables de boucle avec des goroutines: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(val) }() }</code> </pre> <br><p>  Ce code affichera la derni√®re valeur du tableau de valeurs len (valeurs) fois.  La correction du code est tr√®s simple: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// assume the type of each value is string for _, val := range values { go func(val string) { fmt.Println(val) }(val) }</span></span></code> </pre> <br><p>  Cet exemple suffit pour comprendre le probl√®me et ne plus jamais se tromper.  Mais si vous souhaitez conna√Ætre les d√©tails de mise en ≈ìuvre, cet article vous donnera une compr√©hension approfondie du probl√®me et de la solution. </p><br><h1 id="bazovye-veschi-peredacha-po-znacheniyu-i-peredacha-po-ssylke">  Choses de base: passer par valeur et passer par r√©f√©rence </h1><br><p>  Dans Go, il existe une diff√©rence dans le passage d'objets par valeur et par r√©f√©rence [1].  Commen√ßons par l' <strong>exemple 1</strong> [2]: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyval(i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre><br><p>  Personne, tr√®s probablement, ne doute que le r√©sultat affichera des valeurs de 0 √† 4. Probablement dans une sorte d‚Äôordre al√©atoire. </p><br><p>  Regardons l' <strong>exemple 2</strong> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(*n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyref(&amp;i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  En cons√©quence, les √©l√©ments suivants seront affich√©s: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Comprendre pourquoi le r√©sultat est juste cela nous donnera d√©j√† 80% de la compr√©hension de l'essence du probl√®me.  Prenons donc un peu de temps pour trouver les raisons. </p><br><p>  Et la r√©ponse est l√† dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la sp√©cification de la langue Go</a> .  La sp√©cification se lit comme suit: </p><br><blockquote>  Les variables d√©clar√©es dans l'instruction d'initialisation sont r√©utilis√©es dans chaque boucle. </blockquote><p>  Cela signifie que lorsque le programme est en cours d'ex√©cution, il n'y a qu'un seul objet ou morceau de m√©moire pour la variable i, et pas un nouveau n'est cr√©√© pour chaque cycle.  Cet objet prend une nouvelle valeur √† chaque it√©ration. </p><br><p>  Examinons la diff√©rence dans le code machine g√©n√©r√© [3] pour la boucle dans les exemples 1 et 2. Commen√ßons par l'exemple 1. </p><br><pre> <code class="plaintext hljs">0x0026 00038 (go-func-byval.go:14) MOVL $8, (SP) 0x002d 00045 (go-func-byval.go:14) LEAQ "".foobyval¬∑f(SB), CX 0x0034 00052 (go-func-byval.go:14) MOVQ CX, 8(SP) 0x0039 00057 (go-func-byval.go:14) MOVQ AX, 16(SP) 0x003e 00062 (go-func-byval.go:14) CALL runtime.newproc(SB) 0x0043 00067 (go-func-byval.go:13) MOVQ "".i+24(SP), AX 0x0048 00072 (go-func-byval.go:13) INCQ AX 0x004b 00075 (go-func-byval.go:13) CMPQ AX, $5 0x004f 00079 (go-func-byval.go:13) JLT 33</code> </pre> <br><p>  L'instruction Go devient un appel √† la fonction runtime.newproc.  La m√©canique de ce processus est tr√®s int√©ressante, mais laissons cela pour le prochain article.  Maintenant, nous nous int√©ressons davantage √† ce qui arrive √† la variable i.  Il est stock√© dans le registre AX, qui est ensuite transmis par valeur √† travers la pile √† la fonction foobyval [4] comme argument.  ¬´Par valeur¬ª dans ce cas ressemble √† copier la valeur du registre AX sur la pile.  Et changer AX √† l'avenir n'affecte pas ce qui est pass√© √† la fonction foobyval. </p><br><p>  Et voici √† quoi ressemble l'exemple 2: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-func-byref.go:14) LEAQ "".foobyref¬∑f(SB), CX 0x0047 00071 (go-func-byref.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-func-byref.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-func-byref.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-func-byref.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-func-byref.go:13) INCQ (AX) 0x005e 00094 (go-func-byref.go:13) CMPQ (AX), $5 0x0062 00098 (go-func-byref.go:13) JLT 57</code> </pre> <br><p>  Le code est tr√®s similaire - avec une seule diff√©rence, mais tr√®s importante.  Maintenant, dans AX, c'est l'adresse i, et non sa valeur.  Notez √©galement que l'incr√©mentation et la comparaison de la boucle se font sur (AX), pas sur AX.  Et puis, lorsque nous mettons AX sur la pile, il se trouve que nous passons l'adresse i √† la fonction.  Le changement (AX) sera vu de cette fa√ßon dans goroutine aussi. </p><br><p>  Pas de surprise.  En fin de compte, nous passons un pointeur sur un nombre dans la fonction foobyref. <br>  Pendant le fonctionnement, le cycle se termine plus rapidement que n'importe lequel des goroutines cr√©√©s commence √† fonctionner.  Quand ils commenceront √† travailler, ils auront un pointeur vers la m√™me variable i, et non vers une copie.  Et quelle est la valeur de i en ce moment?  La valeur est 5. Celle-l√† m√™me sur laquelle le cycle s'est arr√™t√©.  Et c'est pourquoi tous les goroutins en d√©rivent 5. </p><br><h1 id="metody-so-znacheniem-vs-metody-s-ukazatelem">  M√©thodes avec une valeur VS m√©thodes avec un pointeur </h1><br><p>  Un comportement similaire peut √™tre observ√© lors de la cr√©ation de goroutines qui invoquent toutes les m√©thodes.  Ceci est indiqu√© par la m√™me page wiki.  Regardez l' <strong>exemple 3</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Cet exemple affiche les √©l√©ments du tableau ms.  Dans un ordre al√©atoire, comme nous nous y attendions.  Un <strong>exemple</strong> tr√®s similaire <strong>4</strong> utilise une m√©thode de pointeur pour la m√©thode Show: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi *MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(*mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Essayez de deviner quelle sera la conclusion: 90, imprim√©s cinq fois.  La raison est la m√™me que dans l'exemple plus simple 2. Ici, le probl√®me est moins visible en raison du sucre syntaxique dans Go lors de l'utilisation des m√©thodes de pointeur.  Si dans les exemples, lors du passage de l'exemple 1 √† l'exemple 2, nous avons chang√© i en &amp; i, ici l'appel se ressemble!  m.Show () dans les deux exemples, et le comportement est diff√©rent. </p><br><p>  Pas une combinaison tr√®s heureuse de deux fonctionnalit√©s Go, il me semble.  Rien √† la place de l'appel n'indique une transmission par r√©f√©rence.  Et vous devrez examiner l'impl√©mentation de la m√©thode Show pour voir exactement comment l'appel se d√©roulera (et la m√©thode, bien s√ªr, peut √™tre dans un fichier ou un package compl√®tement diff√©rent). </p><br><p>  Dans la plupart des cas, cette fonctionnalit√© est utile.  Nous √©crivons un code plus propre.  Mais ici, le passage par r√©f√©rence entra√Æne des effets inattendus. </p><br><h1 id="zamykaniya">  Court-circuits </h1><br><p>  Enfin, nous arrivons aux fermetures.  Regardons l' <strong>exemple 5</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(i) }() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Il imprimera ce qui suit: </p><br><p>  5 <br>  5 <br>  5 <br>  5 <br>  5 </p><br><p>  Et cela malgr√© le fait que i soit pass√© par valeur √† foobyval dans la fermeture.  Similaire √† l'exemple 1. Mais pourquoi?  Regardons la vue de la boucle de l'assembleur: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-closure.go:14) LEAQ "".main.func1¬∑f(SB), CX 0x0047 00071 (go-closure.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-closure.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-closure.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-closure.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-closure.go:13) INCQ (AX) 0x005e 00094 (go-closure.go:13) CMPQ (AX), $5 0x0062 00098 (go-closure.go:13) JLT 57</code> </pre> <br><p>  Le code est tr√®s similaire √† l'exemple 2: notez que i est repr√©sent√© par une adresse dans le registre AX.  Autrement dit, nous passons i par r√©f√©rence.  Et cela malgr√© le fait que foobyval soit appel√©.  Le corps de la boucle appelle la fonction √† l'aide de runtime.newproc, mais d'o√π vient cette fonction? </p><br><p>  Func1 est cr√©√© par le compilateur, et c'est une fermeture.  Le compilateur a allou√© le code de fermeture en tant que fonction distincte et l'appelle depuis main.  Le principal probl√®me de cette allocation est de savoir comment traiter les variables utilis√©es par les fermetures, mais qui ne sont clairement pas des arguments. </p><br><p>  Voici √† quoi ressemble le corps de func1: </p><br><pre> <code class="plaintext hljs">0x0000 00000 (go-closure.go:14) MOVQ (TLS), CX 0x0009 00009 (go-closure.go:14) CMPQ SP, 16(CX) 0x000d 00013 (go-closure.go:14) JLS 56 0x000f 00015 (go-closure.go:14) SUBQ $16, SP 0x0013 00019 (go-closure.go:14) MOVQ BP, 8(SP) 0x0018 00024 (go-closure.go:14) LEAQ 8(SP), BP 0x001d 00029 (go-closure.go:15) MOVQ "".&amp;i+24(SP), AX 0x0022 00034 (go-closure.go:15) MOVQ (AX), AX 0x0025 00037 (go-closure.go:15) MOVQ AX, (SP) 0x0029 00041 (go-closure.go:15) CALL "".foobyval(SB) 0x002e 00046 (go-closure.go:16) MOVQ 8(SP), BP 0x0033 00051 (go-closure.go:16) ADDQ $16, SP 0x0037 00055 (go-closure.go:16) RET</code> </pre> <br><p>  Il est int√©ressant ici que la fonction ait un argument en 24 (SP), qui est un pointeur vers int: jetez un ≈ìil √† la ligne MOVQ (AX), AX, qui prend une valeur avant de la passer √† foobyval.  En fait, func1 ressemble √† ceci: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { foobyval(*i) }    main   - : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> func1(&amp;i) }</code> </pre><br><p>  Re√ßu l'√©quivalent de l'exemple 2, ce qui explique la conclusion.  En langage technique, nous dirions que i est une variable libre √† l'int√©rieur d'une fermeture et ces variables sont captur√©es par r√©f√©rence dans Go. </p><br><p>  Mais est-ce toujours le cas?  √âtonnamment, la r√©ponse est non.  Dans certains cas, les variables libres sont captur√©es par valeur.  Voici une variante de notre exemple: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { ii := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(ii) }() }</code> </pre> <br><p>  Cet exemple affichera 0, 1, 2, 3, 4 dans un ordre al√©atoire.  Mais pourquoi le comportement ici est-il diff√©rent de l'exemple 5? </p><br><p>  Il s'av√®re que ce comportement est un artefact de l'heuristique que le compilateur Go utilise lorsqu'il fonctionne avec des fermetures. </p><br><h1 id="smotrim-pod-kapot">  On regarde sous le capot </h1><br><p>  Si vous n'√™tes pas familier avec l'architecture du compilateur Go, je vous recommande de lire mes premiers articles sur ce sujet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> . </p><br><p>  L'arbre de syntaxe sp√©cifique (par opposition √† abstrait) obtenu en analysant le code ressemble √† ceci: </p><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.CallStmt { . Tok: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> . Call: *syntax.CallExpr { . . Fun: *syntax.FuncLit { . . . Type: *syntax.FuncType { . . . . ParamList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . . ResultList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . } . . . Body: *syntax.BlockStmt { . . . . List: []syntax.Stmt (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.ExprStmt { . . . . . . X: *syntax.CallExpr { . . . . . . . Fun: foobyval @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span> . . . . . . . ArgList: []syntax.Expr (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: i @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> . . . . . . . } . . . . . . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . . . . . . } . . . . . } . . . . } . . . . Rbrace: syntax.Pos {} . . . } . . } . . ArgList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . } }</code> </pre> <br><p>  La fonction appel√©e est repr√©sent√©e par le n≈ìud FuncLit, une fonction constante.  Lorsque cet arbre est converti en AST (arbre de syntaxe abstraite), la mise en √©vidence de cette fonction constante comme une fonction distincte sera le r√©sultat.  Cela se produit dans la m√©thode noder.funcLit, qui r√©side dans gc / fermeture.go. </p><br><p>  Ensuite, le v√©rificateur de pointes termine la transformation et nous obtenons la repr√©sentation suivante pour la fonction dans l'AST: </p><br><pre> <code class="go hljs">main.func1: . DCLFUNC l(<span class="hljs-number"><span class="hljs-number">14</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) FUNC-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(8)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PFUNC)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">il</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PAUTOHEAP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  Notez que la valeur transmise √† foobyval est NAME-main.i, c'est-√†-dire que nous pointons explicitement vers la variable de la fonction qui encapsule la fermeture. </p><br><p>  √Ä ce stade, l'√©tape du compilateur, appel√©e capturevars, c'est-√†-dire ¬´capture variable¬ª, entre en service.  Son but est de d√©cider comment capturer les "variables ferm√©es" (c'est-√†-dire les variables libres utilis√©es dans les fermetures).  Voici un commentaire de la fonction de compilation correspondante, qui d√©crit √©galement l'heuristique: </p><br><p>  // capturevars est appel√© dans une phase distincte apr√®s toutes les v√©rifications de type. <br>  // Il d√©cide de capturer la variable par valeur ou par r√©f√©rence. <br>  // Nous utilisons la capture par valeur pour des valeurs &lt;= 128 octets qui ne changent plus de valeur apr√®s la capture (essentiellement des constantes). </p><br><p>  Lorsque capturevars est appel√© dans l'exemple 5, il d√©cide que la variable de boucle i doit √™tre captur√©e par r√©f√©rence et lui ajoute le drapeau addrtaken appropri√©.  Cela peut √™tre vu dans la sortie AST: </p><br><pre> <code class="go hljs">FOR l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) . LT l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> . . NAME-main.ia(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) g(<span class="hljs-number"><span class="hljs-number">1</span></span>) l(<span class="hljs-number"><span class="hljs-number">13</span></span>) x(<span class="hljs-number"><span class="hljs-number">0</span></span>) class(PAUTOHEAP) esc(h) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) addrtaken assigned used <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br><p>  Pour la variable de boucle, l'heuristique de s√©lection ¬´par valeur¬ª ne fonctionne pas, car la variable change de valeur apr√®s l'appel (rappelez-vous la citation de la sp√©cification selon laquelle la variable de boucle est r√©utilis√©e √† chaque it√©ration).  Par cons√©quent, la variable i est captur√©e par r√©f√©rence. <br>  Dans cette variation de notre exemple, o√π nous avons ii: = i, ii n'est plus utilis√© et est donc captur√© par la valeur [5]. </p><br><p>  Ainsi, nous voyons un exemple √©tonnant de chevauchement de deux caract√©ristiques diff√©rentes d'une langue d'une mani√®re inattendue.  Au lieu d'utiliser une nouvelle variable √† chaque it√©ration de la boucle, Go r√©utilise la m√™me.  Ceci, √† son tour, conduit au d√©clenchement d'heuristiques et au choix de capture par r√©f√©rence, et cela conduit √† un r√©sultat inattendu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La FAQ Go</a> indique que ce comportement peut √™tre une erreur de conception. </p><br><blockquote>  Ce comportement (n'utilisez pas de nouvelle variable) est probablement une erreur lors de la conception d'un langage.  Peut-√™tre que nous le corrigerons dans les futures versions, mais en raison de la compatibilit√© descendante, nous ne pouvons rien faire dans Go version 1. </blockquote><p>  Si vous √™tes conscient du probl√®me, vous ne marcherez probablement pas sur ce r√¢teau.  Mais gardez √† l'esprit que les variables libres peuvent toujours √™tre captur√©es par r√©f√©rence.  Pour √©viter les erreurs, assurez-vous que seules les variables en lecture seule sont captur√©es lors de l'utilisation de goroutin.  Ceci est √©galement important en raison de probl√®mes potentiels avec les vols de donn√©es. </p><br><hr><br><p>  [1] Certains lecteurs ont remarqu√© qu'√† proprement parler, il n'y a pas de concept de ¬´passage par r√©f√©rence¬ª dans Go, car tout est pass√© par valeur, y compris les pointeurs.  Dans cet article, lorsque vous voyez ¬´passer par r√©f√©rence¬ª, je veux dire ¬´passer par adresse¬ª et il est explicite dans certains cas (comme le passage de &amp; n √† une fonction qui attend * int), et dans certains cas implicite, comme dans les versions ult√©rieures parties de l'article. </p><br><p>  [2] Ci-apr√®s, j'utilise le temps. Le sommeil comme un moyen rapide et sale d'attendre que tous les goroutines se terminent.  Sans cela, le principal se terminera avant que les goroutines ne commencent √† fonctionner.  La bonne fa√ßon de proc√©der serait d'utiliser quelque chose comme WaitGroup ou done channel. </p><br><p>  [3] La repr√©sentation de l'assembleur pour tous les exemples de cet article a √©t√© obtenue √† l'aide de la commande go tool compile -l -S.  L'indicateur -l d√©sactive la fonction inline et rend le code assembleur plus lisible. </p><br><p>  [4] Foobyval n'est pas appel√© directement, car l'appel passe par go.  Au lieu de cela, l'adresse est pass√©e en tant que deuxi√®me argument (16 (SP)) √† la fonction runtime.newproc, et l'argument √† foobyval (i dans ce cas) remonte la pile. </p><br><p>  [5] Comme exercice, ajoutez ii = 10 comme derni√®re ligne de la boucle for (apr√®s avoir appel√© go).  Quelle a √©t√© votre conclusion?  Pourquoi? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468863/">https://habr.com/ru/post/fr468863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468849/index.html">R√©tro-ing√©nierie de processeur inconnu dans un seul programme</a></li>
<li><a href="../fr468851/index.html">Impl√©mentation d'animation dans React Native</a></li>
<li><a href="../fr468853/index.html">L'histoire d'une application r√©ussie de SPR dans un projet Legacy</a></li>
<li><a href="../fr468859/index.html">¬´Routeur de pompage¬ª: r√©glage de l'√©quipement TP-Link pour les fournisseurs Internet</a></li>
<li><a href="../fr468861/index.html">Positive Technologies donne vie √† la ¬´ville piratable¬ª dans The Cyberbattle Standoff √† HITB + CyberWeek</a></li>
<li><a href="../fr468873/index.html">Un train priv√© qui a ruin√© la commodit√©</a></li>
<li><a href="../fr468875/index.html">√âpisode de hachage et d'amortissement effondr√©</a></li>
<li><a href="../fr468877/index.html">Une approche alternative pour afficher la charge pendant la pagination</a></li>
<li><a href="../fr468879/index.html">√Ä l'aube de la m√©moire informatique</a></li>
<li><a href="../fr468883/index.html">Natalya Kozlovsky: ¬´ Est - ce important qui attire par OpenStreetMap: hommes ou femmes ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>