<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòº üóø üêÅ La ingenier√≠a inversa de la representaci√≥n de The Witcher 3 ü§∏üèª ü¶ã ‚õπüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La primera parte de la traducci√≥n est√° aqu√≠ . En esta parte, hablaremos sobre el efecto de la nitidez, el brillo promedio, las fases de la luna y los ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La ingenier√≠a inversa de la representaci√≥n de The Witcher 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437100/">  La primera parte de la traducci√≥n est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  En esta parte, hablaremos sobre el efecto de la nitidez, el brillo promedio, las fases de la luna y los fen√≥menos atmosf√©ricos durante la lluvia. <br><br><h2>  Parte 6. Afilar </h2><br>  En esta parte, veremos m√°s de cerca otro efecto de procesamiento posterior de The Witcher 3 - Sharpen. <br><br>  La nitidez hace que la imagen de salida sea un poco m√°s n√≠tida.  Este efecto es conocido por Photoshop y otros editores gr√°ficos. <br><br>  En The Witcher 3, el enfoque tiene dos opciones: baja y alta.  A continuaci√≥n, hablar√© sobre la diferencia entre ellos, pero por ahora, echemos un vistazo a las capturas de pantalla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/1fc/6bc/2851fc6bc19e39660e0307f2775b0322.png" alt="imagen"></div><br>  <i>Opci√≥n "baja" - hasta</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/cd4/4cd/dc2cd44cd83306f2c08bbf7f87831d8c.png" alt="imagen"></div><br>  <i>Opci√≥n "baja" - despu√©s</i> <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/807/2aa/aad8072aa3977f32549856c0be24206b.png"></div><br>  <i>Alta opci√≥n - hasta</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/3ce/0f3/b873ce0f320a785f4fb4bc83e9a696f5.png"></div><br>  <i>Opci√≥n "Alta" - despu√©s</i> <br><br>  Si desea ver comparaciones m√°s detalladas (interactivas), consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secci√≥n en la Gu√≠a de rendimiento The Witcher 3 de Nvidia</a> .  Como puede ver, el efecto es especialmente notable en la hierba y el follaje. <br><br>  En esta parte de la publicaci√≥n, estudiaremos el marco desde el comienzo del juego: lo eleg√≠ intencionalmente, porque aqu√≠ vemos el relieve (larga distancia de dibujo) y la c√∫pula del cielo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/898/e97/895/898e9789593705231157a07ebcf34f5e.png"></div><br>  En t√©rminos de entrada, el enfoque requiere un b√∫fer de color <b>t0</b> (LDR despu√©s de la correcci√≥n de tono y destellos de lente) y un b√∫fer de profundidad <b>t1</b> . <br><br>  Examinemos el c√≥digo del ensamblador para el sombreador de p√≠xeles: <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb3[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_input_ps_siv v0.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 7 <br> 0: ftoi r0.xy, v0.xyxx <br> 1: mov r0.zw, l(0, 0, 0, 0) <br> 2: ld_indexable(texture2d)(float,float,float,float) r0.x, r0.xyzw, t1.xyzw <br> 3: mad r0.x, r0.x, cb12[22].x, cb12[22].y <br> 4: mad r0.y, r0.x, cb12[21].x, cb12[21].y <br> 5: max r0.y, r0.y, l(0.000100) <br> 6: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 7: mad_sat r0.y, r0.y, cb3[1].z, cb3[1].w <br> 8: add r0.z, -cb3[1].x, cb3[1].y <br> 9: mad r0.y, r0.y, r0.z, cb3[1].x <br> 10: add r0.y, r0.y, l(1.000000) <br> 11: ge r0.x, r0.x, l(1.000000) <br> 12: movc r0.x, r0.x, l(0), l(1.000000) <br> 13: mul r0.z, r0.x, r0.y <br> 14: round_z r1.xy, v0.xyxx <br> 15: add r1.xy, r1.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000) <br> 16: div r1.xy, r1.xyxx, cb3[0].zwzz <br> 17: sample_l(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s0, l(0) <br> 18: lt r0.z, l(0), r0.z <br> 19: if_nz r0.z <br> 20: div r3.xy, l(0.500000, 0.500000, 0.000000, 0.000000), cb3[0].zwzz <br> 21: add r0.zw, r1.xxxy, -r3.xxxy <br> 22: sample_l(texture2d)(float,float,float,float) r4.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 23: mov r3.zw, -r3.xxxy <br> 24: add r5.xyzw, r1.xyxy, r3.zyxw <br> 25: sample_l(texture2d)(float,float,float,float) r6.xyz, r5.xyxx, t0.xyzw, s0, l(0) <br> 26: add r4.xyz, r4.xyzx, r6.xyzx <br> 27: sample_l(texture2d)(float,float,float,float) r5.xyz, r5.zwzz, t0.xyzw, s0, l(0) <br> 28: add r4.xyz, r4.xyzx, r5.xyzx <br> 29: add r0.zw, r1.xxxy, r3.xxxy <br> 30: sample_l(texture2d)(float,float,float,float) r1.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 31: add r1.xyz, r1.xyzx, r4.xyzx <br> 32: mul r3.xyz, r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000) <br> 33: mad r1.xyz, -r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000), r2.xyzx <br> 34: max r0.z, abs(r1.z), abs(r1.y) <br> 35: max r0.z, r0.z, abs(r1.x) <br> 36: mad_sat r0.z, r0.z, cb3[2].x, cb3[2].y <br> 37: mad r0.x, r0.y, r0.x, l(-1.000000) <br> 38: mad r0.x, r0.z, r0.x, l(1.000000) <br> 39: dp3 r0.y, l(0.212600, 0.715200, 0.072200, 0.000000), r2.xyzx <br> 40: dp3 r0.z, l(0.212600, 0.715200, 0.072200, 0.000000), r3.xyzx <br> 41: max r0.w, r0.y, l(0.000100) <br> 42: div r1.xyz, r2.xyzx, r0.wwww <br> 43: add r0.y, -r0.z, r0.y <br> 44: mad r0.x, r0.x, r0.y, r0.z <br> 45: max r0.x, r0.x, l(0) <br> 46: mul r2.xyz, r0.xxxx, r1.xyzx <br> 47: endif <br> 48: mov o0.xyz, r2.xyzx <br> 49: mov o0.w, l(1.000000) <br> 50: ret</code> <br> <br>  50 l√≠neas de c√≥digo de ensamblador parecen una tarea factible.  Vamos a resolverlo. <br><br><h3>  Agudizar la generaci√≥n de valor </h3><br>  El primer paso es cargar el b√∫fer de profundidad (l√≠nea 1).  Vale la pena se√±alar que "The Witcher 3" utiliza una profundidad invertida (1.0 - cerca, 0.0 - lejos).  Como ya sabr√°, la profundidad del hardware est√° vinculada de forma no lineal (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo para m√°s detalles</a> ). <br><br>  Las l√≠neas 3-6 proporcionan una forma muy interesante de asociar esta profundidad de hardware [1.0 - 0.0] con valores [casi lejanos] (los establecemos en la etapa MatrixPerspectiveFov).  Considere los valores del b√∫fer constante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/636/345/52a/63634552ae9daf03f14305c118cccc25.png"></div><br>  Teniendo el valor "close" de 0.2 y el valor de "far" 5000, podemos calcular los valores de cb12_v21.xy de la siguiente manera: <br><br> <code>cb12_v21.y = 1.0 / near <br> cb12_v21.x = - (1.0 / near) + (1.0 / near) * (near / far)</code> <br> <br>  Este c√≥digo es bastante com√∫n en los sombreadores TW3, as√≠ que creo que es solo una funci√≥n. <br><br>  Despu√©s de obtener la "profundidad de la pir√°mide de visibilidad", la l√≠nea 7 usa la escala / distorsi√≥n para crear el coeficiente de interpolaci√≥n (aqu√≠ usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">saturar</a> para limitar los valores al intervalo [0-1]). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/efd/571/e89efd5711cb2aa1a3c544e9deda9321.png"></div><br>  cb3_v1.xy y cb3_v2.xy: este es el brillo del efecto de nitidez a distancias cortas y largas.  Llam√©moslos sharpenNear y sharpenFar.  Y esta es la √∫nica diferencia entre las opciones "Bajo" y "Alto" de este efecto en The Witcher 3. <br><br>  Ahora es el momento de usar la relaci√≥n resultante.  Las l√≠neas 8-9 solo hacen <code>lerp(sharpenNear, sharpenFar, interpolationCoeff)</code> .  ¬øPara qu√© es esto?  Gracias a esto, obtenemos un brillo diferente cerca de Geralt y lejos de √©l.  Echa un vistazo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/233/515/6462335151728759f236b58f14b894dd.png"></div><br>  Quiz√°s esto apenas se nota, pero aqu√≠ interpolamos en funci√≥n de la distancia entre el brillo de nitidez junto al reproductor (2.177151) y el brillo del efecto est√° muy lejos (1.91303).  Despu√©s de este c√°lculo, agregamos 1.0 al brillo (l√≠nea 10).  ¬øPor qu√© se necesita esto?  Supongamos que la operaci√≥n lerp que se muestra arriba nos dio 0.0.  Despu√©s de agregar 1.0, naturalmente obtenemos 1.0, y este es un valor que no afectar√° el p√≠xel cuando se enfoca.  Lea m√°s sobre esto a continuaci√≥n. <br><br>  Mientras se afila, no queremos afectar el cielo.  Esto se puede lograr agregando una simple verificaci√≥n condicional: <br><br> <code>//   sharpen   <br> float fSkyboxTest = (fDepth &gt;= 1.0) ? 0 : 1;</code> <br> <br>  En The Witcher 3, el valor de la profundidad de p√≠xel del cielo es 1.0, por lo que lo usamos para obtener una especie de "filtro binario" (un hecho interesante: en este caso, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paso</a> no funcionar√° correctamente). <br><br>  Ahora podemos multiplicar el brillo interpolado por un "filtro de cielo": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/ed1/f50/63ced1f5036d9ee63cfe54de6a501bc1.png"></div><br>  Esta multiplicaci√≥n se realiza en la l√≠nea 13. <br><br>  Ejemplo de c√≥digo de sombreador: <br><br> <code>//    sharpen <br> float fSharpenAmount = fSharpenIntensity * fSkyboxTest;</code> <br> <br><h3>  Centro de muestreo de p√≠xeles </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SV_Position</a> tiene un aspecto que ser√° importante aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un desplazamiento de medio p√≠xel</a> .  Resulta que este p√≠xel en la esquina superior izquierda (0, 0) tiene coordenadas no (0, 0) en t√©rminos de SV_Position.xy, sino (0.5, 0.5).  Wow! <br><br>  Aqu√≠ queremos tomar una muestra en el centro del p√≠xel, as√≠ que veamos las l√≠neas 14-16.  Puedes escribirlos en HLSL: <br><br> <code>//   . <br> //   ""   SV_Position.xy. <br> float2 uvCenter = trunc( Input.Position.xy ); <br> <br> //   ,       <br> uvCenter += float2(0.5, 0.5); <br> uvCenter /= g_Viewport.xy</code> <br> <br>  Y luego, tomamos muestras de la textura de color de entrada de texcoords "uvCenter".  No se preocupe, el resultado del muestreo ser√° el mismo que con el m√©todo "normal" (SV_Position.xy / ViewportSize.xy). <br><br><h3>  Afilar o no afilar </h3><br>  La decisi√≥n sobre si usar sharpen depende de fSharpenAmount. <br><br> <code>//     <br> float3 colorCenter = TexColorBuffer.SampleLevel( samplerLinearClamp, uvCenter, 0 ).rgb; <br> <br> //   <br> float3 finalColor = colorCenter; <br> <br> if ( fSharpenAmount &gt; 0 ) <br> { <br> //   sharpening... <br> } <br> <br> return float4( finalColor, 1 );</code> <br> <br><h3>  Afilar </h3><br>  Es hora de echar un vistazo al interior del algoritmo mismo. <br><br>  B√°sicamente, realiza las siguientes acciones: <br><br>  - muestra cuatro veces la textura de color de entrada en las esquinas del p√≠xel, <br><br>  - agrega muestras y calcula el valor promedio, <br><br>  - calcula la diferencia entre "centro" y "esquina promedio", <br><br>  - encuentra el componente absoluto m√°ximo de la diferencia, <br><br>  - corrige max.  abs.  componente usando escala + valores de sesgo, <br><br>  - determina la magnitud del efecto usando max.  abs.  componente <br><br>  - calcula el valor de brillo (luma) para "centerColor" y "averageColor", <br><br>  - divide colorCenter en su luma, <br><br>  - calcula un nuevo valor de luma interpolado basado en la magnitud del efecto, <br><br>  - Multiplica colorCenter por el nuevo valor de luma. <br><br>  Mucho trabajo, y fue dif√≠cil para m√≠ resolverlo, porque nunca hab√≠a experimentado con filtros afilados. <br><br>  Comencemos con el patr√≥n de muestreo.  Como puede ver en el c√≥digo del ensamblador, se realizan cuatro lecturas de textura. <br><br>  Esto se mostrar√° mejor utilizando un ejemplo de una imagen de p√≠xeles (el nivel de habilidad del artista es <i>un experto</i> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e3/d46/5fa/5e3d465fadc0bccd551256c40c6e5368.png"></div><br>  Todas las lecturas en el sombreador usan muestreo bilineal (D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT). <br><br>  El desplazamiento desde el centro a cada uno de los √°ngulos es (¬± 0.5, ¬± 0.5), dependiendo del √°ngulo. <br><br>  ¬øVes c√≥mo se puede implementar esto en HLSL?  A ver: <br><br> <code>float2 uvCorner; <br> float2 uvOffset = float2( 0.5, 0.5 ) / g_Viewport.xy; // remember about division! <br> <br> float3 colorCorners = 0; <br> <br> //    <br> // -0,5, -0.5 <br> uvCorner = uvCenter - uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, -0.5 <br> uvCorner = uvCenter + float2(uvOffset.x, -uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // -0.5, +0.5 <br> uvCorner = uvCenter + float2(-uvOffset.x, uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, +0.5 <br> uvCorner = uvCenter + uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb;</code> <br> <br>  Entonces, ahora las cuatro muestras se resumen en la variable "colorCorners".  Sigamos estos pasos: <br><br> <code>//     <br> float3 averageColorCorners = colorCorners / 4.0; <br> <br> //    <br> float3 diffColor = colorCenter - averageColorCorners; <br> <br> //  . . RGB-  <br> float fDiffColorMaxComponent = max( abs(diffColor.x), max( abs(diffColor.y), abs(diffColor.z) ) ); <br> <br> //    <br> float fDiffColorMaxComponentScaled = saturate( fDiffColorMaxComponent * sharpenLumScale + sharpenLumBias ); <br> <br> //     . <br> //   "1.0" -      fSharpenIntensity  1.0. <br> float fPixelSharpenAmount = lerp(1.0, fSharpenAmount, fDiffColorMaxComponentScaled); <br> <br> //   ""     . <br> float lumaCenter = dot( LUMINANCE_RGB, finalColor ); <br> float lumaCornersAverage = dot( LUMINANCE_RGB, averageColorCorners ); <br> <br> //  "centerColor"    <br> float3 fColorBalanced = colorCenter / max( lumaCenter, 1e-4 ); <br> <br> //    <br> float fPixelLuminance = lerp(lumaCornersAverage, lumaCenter, fPixelSharpenAmount); <br> <br> //     <br> finalColor = fColorBalanced * max(fPixelLuminance, 0.0); <br> } <br> <br> return float4(finalColor, 1.0);</code> <br> <br>  El reconocimiento de bordes se realiza calculando max.  abs.  componente de diferencia.  Movimiento inteligente!  Echa un vistazo a su visualizaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/a26/44a/aa9a2644a16b1b79c6213f7d4effe068.jpg"></div><br>  <i>Visualizaci√≥n del componente absoluto m√°ximo de la diferencia.</i> <br><br>  Genial  El sombreador HLSL terminado est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Perd√≥n por el formato bastante pobre.  Puede usar mi programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HLSLexplorer</a> y experimentar con el c√≥digo. <br><br>  ¬°Puedo decir felizmente que el c√≥digo anterior crea el mismo c√≥digo de ensamblador que en el juego! <br><br>  Para resumir: el sombreador de nitidez Witcher 3 est√° muy bien escrito (tenga en cuenta que fPixelSharpenAmount es mayor que 1.0! Esto es interesante ...).  Adem√°s, la forma principal de cambiar el brillo del efecto es el brillo de los objetos cercanos / lejanos.  En este juego, no son constantes;  He compilado varios ejemplos de valores: <br><br>  Skellige: <br><br><table><tbody><tr><th></th><th>  agudizar </th><th>  sharpenFar </th><th>  sharpenDistanceScale </th><th>  sharpenDistanceBias </th><th>  sharpenLumScale </th><th>  sharpenLumBias </th></tr><tr><td>  <b>bajo</b> </td></tr></tbody><tbody><tr><td>  <b>alto</b> </td><td>  2,0 </td><td>  1,8 </td><td>  0,025 <br></td><td>  -0.25 <br></td><td>  -13.33333 <br></td><td>  1.33333 </td></tr></tbody></table><br>  Kaer Morhen: <br><br><table><tbody><tr><th></th><th>  agudizar <br></th><th>  sharpenFar <br></th><th>  sharpenDistanceScale <br></th><th>  sharpenDistanceBias <br></th><th>  sharpenLumScale <br></th><th>  sharpenLumBias <br></th></tr><tr><td>  bajo <br></td><td>  0.57751 <br></td><td>  0.31303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1.0 <br></td><td>  2,0 <br></td></tr><tr><td>  alto <br></td><td>  2.17751 <br></td><td>  1.91303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1.0 <br></td><td>  2,0 </td></tr></tbody></table><br><h2>  Parte 7. Brillo promedio </h2><br>  La operaci√≥n de calcular el brillo promedio del cuadro actual se puede encontrar en casi cualquier videojuego moderno.  Este valor a menudo se usa m√°s tarde para el efecto de la adaptaci√≥n ocular y la correcci√≥n tonal (ver en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte anterior de la</a> publicaci√≥n).  En soluciones simples, el c√°lculo del brillo se usa para, por ejemplo, la textura 512 <sup>2</sup> , luego el c√°lculo de sus niveles de mip y la aplicaci√≥n de este √∫ltimo.  Esto generalmente funciona, pero limita enormemente las posibilidades.  Las soluciones m√°s complejas utilizan sombreadores computacionales que realizan, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reducci√≥n paralela</a> . <br><br>  Veamos c√≥mo el equipo de CD Projekt Red resolvi√≥ este problema en The Witcher 3.  En la parte anterior, ya examin√© la correcci√≥n tonal y la adaptaci√≥n del ojo, por lo que la √∫nica pieza restante del rompecabezas era el brillo promedio. <br><br>  Para empezar, el c√°lculo del brillo promedio de The Witcher 3 consta de dos pases.  Para mayor claridad, decid√≠ dividirlos en partes separadas, y primero miramos el primer paso: "distribuci√≥n de brillo" (c√°lculo del histograma de brillo). <br><br><h3>  Distribuci√≥n de brillo </h3><br>  Estos dos pases son bastante f√°ciles de encontrar en cualquier analizador de cuadros.  Estas son las llamadas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Despacho</a> en orden justo antes de realizar la adaptaci√≥n ocular: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/5fb/09c/7de5fb09ce00453f14262f9e2b1bae30.png"></div><br>  Veamos la entrada para este pase.  Necesita dos texturas: <br><br>  1) b√∫fer de color HDR, cuya escala se reduce a 1/4 x 1/4 (por ejemplo, de 1920x1080 a 480x270), <br><br>  2) buffer de profundidad de pantalla completa <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/021/38b/795/02138b795946d192f553eadc20d34366.png"></div><br>  <i>Tamp√≥n de color 1/4 x 1/4 HDR.</i>  <i>Tenga en cuenta el truco complicado: este b√∫fer es parte de un b√∫fer m√°s grande.</i>  <i>Reutilizar los tampones es una buena pr√°ctica.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/62d/c97/0e362dc97908f75db564cff0f46b1e7e.png"></div><br>  <i>Buffer de profundidad de pantalla completa</i> <br><br>  ¬øPor qu√© alejar el b√∫fer de color?  Creo que se trata de rendimiento. <br><br>  En cuanto a la salida de este pase, es un b√∫fer estructurado.  256 elementos de 4 bytes cada uno. <br><br>  Los sombreadores no tienen informaci√≥n de depuraci√≥n aqu√≠, as√≠ que supongamos que es solo un b√∫fer de valores int sin signo. <br><br>  Importante: el primer paso para calcular el brillo promedio llama a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ClearUnorderedAccessViewUint</a> para restablecer todos los elementos del b√∫fer estructurado a cero. <br><br>  Estudiemos el c√≥digo de ensamblador del sombreador computacional (¬°este es el primer sombreador computacional en todo nuestro an√°lisis!) <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[3], immediateIndexed <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_uav_structured u0, 4 <br> dcl_input vThreadGroupID.x <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 6 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: store_structured g0.x, vThreadIDInGroup.x, l(0), l(0) <br> 1: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 2: store_structured g0.x, r0.x, l(0), l(0) <br> 3: store_structured g0.x, r0.y, l(0), l(0) <br> 4: store_structured g0.x, r0.z, l(0), l(0) <br> 5: sync_g_t <br> 6: ftoi r1.x, cb0[2].z <br> 7: mov r2.y, vThreadGroupID.x <br> 8: mov r2.zw, l(0, 0, 0, 0) <br> 9: mov r3.zw, l(0, 0, 0, 0) <br> 10: mov r4.yw, l(0, 0, 0, 0) <br> 11: mov r1.y, l(0) <br> 12: loop <br> 13: utof r1.z, r1.y <br> 14: ge r1.z, r1.z, cb0[0].x <br> 15: breakc_nz r1.z <br> 16: iadd r2.x, r1.y, vThreadIDInGroup.x <br> 17: utof r1.z, r2.x <br> 18: lt r1.z, r1.z, cb0[0].x <br> 19: if_nz r1.z <br> 20: ld_indexable(texture2d)(float,float,float,float) r5.xyz, r2.xyzw, t0.xyzw <br> 21: dp3 r1.z, r5.xyzx, l(0.212600, 0.715200, 0.072200, 0.000000) <br> 22: imul null, r3.xy, r1.xxxx, r2.xyxx <br> 23: ld_indexable(texture2d)(float,float,float,float) r1.w, r3.xyzw, t1.yzwx <br> 24: eq r1.w, r1.w, cb0[2].w <br> 25: and r1.w, r1.w, cb0[2].y <br> 26: add r2.x, -r1.z, cb0[2].x <br> 27: mad r1.z, r1.w, r2.x, r1.z <br> 28: add r1.z, r1.z, l(1.000000) <br> 29: log r1.z, r1.z <br> 30: mul r1.z, r1.z, l(88.722839) <br> 31: ftou r1.z, r1.z <br> 32: umin r4.x, r1.z, l(255) <br> 33: atomic_iadd g0, r4.xyxx, l(1) <br> 34: endif <br> 35: iadd r1.y, r1.y, l(64) <br> 36: endloop <br> 37: sync_g_t <br> 38: ld_structured r1.x, vThreadIDInGroup.x, l(0), g0.xxxx <br> 39: mov r4.z, vThreadIDInGroup.x <br> 40: atomic_iadd u0, r4.zwzz, r1.x <br> 41: ld_structured r1.x, r0.x, l(0), g0.xxxx <br> 42: mov r0.w, l(0) <br> 43: atomic_iadd u0, r0.xwxx, r1.x <br> 44: ld_structured r0.x, r0.y, l(0), g0.xxxx <br> 45: atomic_iadd u0, r0.ywyy, r0.x <br> 46: ld_structured r0.x, r0.z, l(0), g0.xxxx <br> 47: atomic_iadd u0, r0.zwzz, r0.x <br> 48: ret</code> <br> <br>  Y un b√∫fer constante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/805/dc6/c14805dc6b7ffd431d9307cc46dcba0d.png"></div><br>  Ya sabemos que la primera entrada es un b√∫fer de color HDR.  Con FullHD, su resoluci√≥n es 480x270.  Miremos la llamada de Despacho. <br><br>  Despacho (270, 1, 1): esto significa que ejecutamos 270 grupos de subprocesos.  En pocas palabras, ejecutamos un grupo de hilos por l√≠nea del b√∫fer de color. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/a97/7e3/e9aa977e3f9a60104fe9a66d797a27cc.png"></div><br>  <i>Cada grupo de subprocesos ejecuta una l√≠nea de b√∫fer de color HDR</i> <br><br>  Ahora que tenemos este contexto, intentemos averiguar qu√© hace el sombreador. <br><br>  Cada grupo de hilos tiene 64 hilos en la direcci√≥n X (dcl_thread_group 64, 1, 1), as√≠ como memoria compartida, 256 elementos con 4 bytes cada uno (dcl_tgsm_structured g0, 4, 256). <br><br>  Observe que en el sombreador usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SV_GroupThreadID</a> (vThreadIDInGroup.x) [0-63] y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SV_GroupID</a> (vThreadGroupID.x) [0-269]. <br><br>  1) Comenzamos asignando a todos los elementos de la memoria compartida valores cero.  Dado que la memoria total contiene 256 elementos y 64 hilos por grupo, esto se puede hacer convenientemente con un simple ciclo: <br><br> <code>//   -      . <br> //        64 ,          4 . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = 0; <br> }</code> <br> <br>  2) Despu√©s de eso, establecemos la barrera usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GroupMemoryBarrierWithGroupSync</a> (sync_g_t).  Hacemos esto para garantizar que todos los subprocesos en la memoria compartida de los grupos se restablezcan a cero antes de continuar con el siguiente paso. <br><br>  3) Ahora estamos ejecutando un bucle, que puede escribirse m√°s o menos as√≠: <br><br> <code>// cb0_v0.x -      .  1920x1080   1920/4 = 480; <br> float ViewportSizeX = cb0_v0.x; <br> [loop] for ( uint PositionX = 0; PositionX &lt; ViewportSizeX; PositionX += 64 ) <br> { <br> ...</code> <br> <br>  Este es un ciclo for simple con un incremento de 64 (¬øya entendiste por qu√©?). <br><br>  El siguiente paso es calcular la posici√≥n del p√≠xel cargado. <br><br>  Pensemos en ello. <br><br>  Para la coordenada Y, podemos usar SV_GroupID.x porque lanzamos 270 grupos de subprocesos. <br><br>  Para la coordenada X, podemos ... ¬°aprovechar el flujo de grupo actual!  Intentemos hacerlo. <br><br>  Como hay 64 subprocesos en cada grupo, dicha soluci√≥n omitir√° todos los p√≠xeles. <br><br>  Considere el grupo de hilos (0, 0, 0). <br><br>  - La transmisi√≥n (0, 0, 0) procesar√° p√≠xeles (0, 0), (64, 0), (128, 0), (192, 0), (256, 0), (320, 0), (384, 0), (448,0). <br><br>  - El hilo (1, 0, 0) procesar√° p√≠xeles (1, 0), (65, 0), (129, 0), (193, 0), (257, 0), (321, 0), (385, 0), (449, 0) ... <br><br>  - La transmisi√≥n (63, 0, 0) procesar√° los p√≠xeles (63, 0), (127, 0), (191, 0), (255, 0), (319, 0), (383, 0), (447, 0) <br><br>  Por lo tanto, todos los p√≠xeles ser√°n procesados. <br><br>  Tambi√©n debemos asegurarnos de no cargar p√≠xeles desde fuera del b√∫fer de color: <br><br> <code>//      X.  Y  GroupID. <br> uint CurrentPixelPositionX = PositionX + threadID; <br> uint CurrentPixelPositionY = groupID; <br> if ( CurrentPixelPositionX &lt; ViewportSizeX ) <br> { <br> // HDR- . <br> //   HDR-    ,     . <br> uint2 colorPos = uint2(CurrentPixelPositionX, CurrentPixelPositionY); <br> float3 color = texture0.Load( int3(colorPos, 0) ).rgb; <br> float luma = dot(color, LUMA_RGB);</code> <br> <br>  ¬øVes?  ¬°Es bastante simple! <br><br>  Tambi√©n calcul√© el brillo (l√≠nea 21 del c√≥digo del ensamblador). <br><br>  Genial, ya hemos calculado el brillo a partir de un p√≠xel de color.  El siguiente paso es cargar (¬°no muestra!) El valor de profundidad correspondiente. <br><br>  Pero aqu√≠ tenemos un problema, porque conectamos el b√∫fer de profundidades de resoluci√≥n completa.  ¬øQu√© hacer al respecto? <br><br>  Esto es sorprendentemente simple: simplemente multiplique colorPos por alguna constante (cb0_v2.z).  Redujimos el b√∫fer de color HDR cuatro veces.  por lo tanto, el valor es 4! <br><br> <code>const int iDepthTextureScale = (int) cb0_v2.z; <br> uint2 depthPos = iDepthTextureScale * colorPos; <br> float depth = texture1.Load( int3(depthPos, 0) ).x;</code> <br> <br>  Hasta ahora todo bien!  Pero ... llegamos a las l√≠neas 24-25 ... <br><br> <code>24: eq r2.x, r2.x, cb0[2].w <br> 25: and r2.x, r2.x, cb0[2].y</code> <br> <br>  Entonces  Primero tenemos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparaci√≥n de la igualdad de</a> coma flotante, su resultado est√° escrito en r2.x, y justo despu√©s de eso va ... ¬øqu√©?  Bitwise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Y</a> ??  Enserio?  ¬øPara un valor de coma flotante?  ¬øQu√© demonios? <br><br>  <b>El problema 'eq + y'</b> <br><br>  Perm√≠tanme decir que para m√≠ fue la parte m√°s dif√≠cil del sombreador.  Incluso prob√© combinaciones extra√±as de asint / asfloat ... <br><br>  ¬øY si usas un enfoque ligeramente diferente?  Hagamos la comparaci√≥n habitual de flotante a flotante en HLSL. <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y); <br> return test; <br> }</code> <br> <br>  Y aqu√≠ est√° la salida en c√≥digo ensamblador: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, l(0x3f800000) <br> 2: ret</code> <br> <br>  Interesante, ¬øverdad?  No esperaba ver "y" aqu√≠. <br><br>  0x3f800000 es solo 1.0f ... Es l√≥gico porque obtenemos 1.0 y 0.0 de lo contrario si la comparaci√≥n tiene √©xito. <br><br>  Pero, ¬øqu√© pasa si "reemplazamos" 1.0 con alg√∫n otro valor?  Por ejemplo, as√≠: <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y) ? cb0_v0.z : 0.0; <br> return test; <br> }</code> <br> <br>  Obtenemos el siguiente resultado: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, cb0[0].z <br> 2: ret</code> <br> <br>  Ja!  Funcion√≥.  Esto es solo la magia del compilador HLSL.  Nota: si reemplazas 0.0 con otra cosa, entonces solo obtienes movc. <br><br>  Volvamos al sombreador computacional.  El siguiente paso es verificar que la profundidad sea igual a cb0_v2.w.  Siempre es igual a 0.0; en otras palabras, verificamos si un p√≠xel est√° en un plano lejano (en el cielo).  Si es as√≠, le asignamos a este coeficiente alg√∫n valor, aproximadamente 0.5 (verifiqu√© en varios cuadros). <br><br>  Este coeficiente calculado se usa para interpolar entre el brillo del color y el brillo del "cielo" (valor cb0_v2.x, que a menudo es aproximadamente igual a 0.0).  Supongo que esto es necesario para controlar la importancia del cielo en el c√°lculo del brillo promedio.  Por lo general, la importancia se reduce.  Muy buena idea. <br><br> <code>// ,       ( ).  ,    ,    <br> //    . <br> float value = (depth == cb0_v2.w) ? cb0_v2.y : 0.0; <br> <br> //  'value'  0.0,   lerp    'luma'.   'value'  <br> // (  0.50),   luma    . (cb0_v2.x    0.0). <br> float lumaOk = lerp( luma, cb0_v2.x, value );</code> <br> <br>  Como tenemos lumaOk, el siguiente paso es calcular su logaritmo natural para crear una buena distribuci√≥n.  Pero espera, digamos que lumaOk es 0.0.  Sabemos que el valor de log (0) no est√° definido, por lo que agregamos 1.0 porque log (1) = 0.0. <br><br>  Despu√©s de eso, escalamos el logaritmo calculado a 128 para distribuirlo en 256 celdas.  Muy inteligente! <br><br>  Y es a partir de aqu√≠ que se toma este valor 88.722839.  Este es un <code>128 *   (2)</code> . <br><br>  Esta es solo la forma en que HLSL calcula los logaritmos. <br><br>  Solo hay una funci√≥n en el c√≥digo del ensamblador HLSL que calcula logaritmos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">log</a> , y tiene una base de 2. <br><br> <code>// ,  lumaOk  0.0. <br> // log(0)   undefined <br> // log(1) = 0. <br> //     <br> lumaOk = log(lumaOk + 1.0); <br> <br> //     128 <br> lumaOk *= 128;</code> <br> <br>  Finalmente, calculamos el √≠ndice de la celda a partir del brillo logar√≠tmicamente distribuido y agregamos 1 a la celda correspondiente en la memoria compartida. <br><br> <code>//   .    Uint,    256 , <br> //  ,      . <br> uint uLuma = (uint) lumaOk; <br> uLuma = min(uLuma, 255); <br> <br> //  1    . <br> InterlockedAdd( shared_data[uLuma], 1 );</code> <br> <br>  El siguiente paso nuevamente ser√° establecer una barrera para garantizar que se hayan procesado todos los p√≠xeles de la fila. <br><br>  Y el √∫ltimo paso es agregar valores de la memoria compartida al b√∫fer estructurado.  Esto se hace de la misma manera, a trav√©s de un bucle simple: <br><br> <code>// ,       <br> GroupMemoryBarrierWithGroupSync(); <br> <br> //      . <br> [unroll] for (uint idx = 0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> <br> uint data = shared_data[offset]; <br> InterlockedAdd( g_buffer[offset], data ); <br> }</code> <br> <br>  Despu√©s de que los 64 subprocesos del grupo de subprocesos completen los datos comunes, cada subproceso agrega 4 valores al b√∫fer de salida. <br><br>  Considere el b√∫fer de salida.  Pensemos en ello.  ¬°La suma de todos los valores en el b√∫fer es igual al n√∫mero total de p√≠xeles!  (a 480x270 = 129,600).  Es decir, sabemos cu√°ntos p√≠xeles tienen un valor de brillo espec√≠fico. <br><br>  Si no conoce bien los sombreadores computacionales (como yo), al principio puede que no sea claro, as√≠ que lea la publicaci√≥n unas cuantas veces m√°s, tome papel y l√°piz e intente comprender los conceptos sobre los que se basa esta t√©cnica. <br><br>  Eso es todo!  As√≠ es como The Witcher 3 calcula un histograma de brillo.  Personalmente, aprend√≠ mucho al escribir esta parte.  ¬°Felicitaciones a los chicos de CD Projekt Red por su excelente trabajo! <br><br>  Si est√° interesado en un sombreador HLSL completo, est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  ¬°Siempre me esfuerzo por obtener el c√≥digo de ensamblaje lo m√°s cerca posible del juego y estoy completamente feliz de haber tenido √©xito nuevamente! <br><br><h2>  C√°lculo de brillo promedio </h2><br>  Esta es la segunda parte del an√°lisis de los c√°lculos de brillo medio en "The Witcher 3: Wild Hunt". <br><br>  Antes de entrar en batalla con otro sombreador computacional, repitamos brevemente lo que sucedi√≥ en la √∫ltima parte: trabajamos con un b√∫fer de color HDR con una escala de 1 / 4x1 / 4.  Despu√©s de la primera pasada, obtuvimos un histograma de brillo (b√∫fer estructurado de 256 valores enteros sin signo).  Calculamos el logaritmo para el brillo de cada p√≠xel, lo distribuimos en 256 celdas y aumentamos el valor correspondiente del b√∫fer estructurado en 1 por p√≠xel.  Debido a esto, la suma total de todos los valores en estas 256 celdas es igual al n√∫mero de p√≠xeles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/89c/d16/3c389cd16ec2eed7617dcf9334429c6e.png"></div><br>  <i>Un ejemplo de la salida de la primera pasada.</i>  <i>Hay 256 elementos.</i> <br><br>  Por ejemplo, nuestro b√∫fer de pantalla completa tiene un tama√±o de 1920x1080.  Despu√©s de alejar, la primera pasada us√≥ un b√∫fer de 480x270.  La suma de todos los 256 valores en el b√∫fer ser√° igual a 480 * 270 = 129 600. <br><br>  Despu√©s de esta breve introducci√≥n, estamos listos para pasar al siguiente paso: la inform√°tica. <br><br>  Esta vez solo se usa un grupo de subprocesos (Despacho (1, 1, 1)). <br><br>  Veamos el c√≥digo ensamblador del sombreador computacional: <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_uav_structured u0, 4 <br> dcl_uav_typed_texture2d (float,float,float,float) u1 <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 4 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, vThreadIDInGroup.x, l(0), u0.xxxx <br> 1: store_structured g0.x, vThreadIDInGroup.x, l(0), r0.x <br> 2: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 3: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.w, r0.x, l(0), u0.xxxx <br> 4: store_structured g0.x, r0.x, l(0), r0.w <br> 5: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.y, l(0), u0.xxxx <br> 6: store_structured g0.x, r0.y, l(0), r0.x <br> 7: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.z, l(0), u0.xxxx <br> 8: store_structured g0.x, r0.z, l(0), r0.x <br> 9: sync_g_t <br> 10: if_z vThreadIDInGroup.x <br> 11: mul r0.x, cb0[0].y, cb0[0].x <br> 12: ftou r0.x, r0.x <br> 13: utof r0.y, r0.x <br> 14: mul r0.yz, r0.yyyy, cb0[0].zzwz <br> 15: ftoi r0.yz, r0.yyzy <br> 16: iadd r0.x, r0.x, l(-1) <br> 17: imax r0.y, r0.y, l(0) <br> 18: imin r0.y, r0.x, r0.y <br> 19: imax r0.z, r0.y, r0.z <br> 20: imin r0.x, r0.x, r0.z <br> 21: mov r1.z, l(-1) <br> 22: mov r2.xyz, l(0, 0, 0, 0) <br> 23: loop <br> 24: breakc_nz r2.x <br> 25: ld_structured r0.z, r2.z, l(0), g0.xxxx <br> 26: iadd r3.x, r0.z, r2.y <br> 27: ilt r0.z, r0.y, r3.x <br> 28: iadd r3.y, r2.z, l(1) <br> 29: mov r1.xy, r2.yzyy <br> 30: mov r3.z, r2.x <br> 31: movc r2.xyz, r0.zzzz, r1.zxyz, r3.zxyz <br> 32: endloop <br> 33: mov r0.w, l(-1) <br> 34: mov r1.yz, r2.yyzy <br> 35: mov r1.xw, l(0, 0, 0, 0) <br> 36: loop <br> 37: breakc_nz r1.x <br> 38: ld_structured r2.x, r1.z, l(0), g0.xxxx <br> 39: iadd r1.y, r1.y, r2.x <br> 40: utof r2.x, r2.x <br> 41: utof r2.w, r1.z <br> 42: add r2.w, r2.w, l(0.500000) <br> 43: mul r2.w, r2.w, l(0.011271) <br> 44: exp r2.w, r2.w <br> 45: add r2.w, r2.w, l(-1.000000) <br> 46: mad r3.z, r2.x, r2.w, r1.w <br> 47: ilt r2.x, r0.x, r1.y <br> 48: iadd r2.w, -r2.y, r1.y <br> 49: itof r2.w, r2.w <br> 50: div r0.z, r3.z, r2.w <br> 51: iadd r3.y, r1.z, l(1) <br> 52: mov r0.y, r1.z <br> 53: mov r3.w, r1.x <br> 54: movc r1.xzw, r2.xxxx, r0.wwyz, r3.wwyz <br> 55: endloop <br> 56: store_uav_typed u1.xyzw, l(0, 0, 0, 0), r1.wwww <br> 57: endif <br> 58: ret</code> <br> <br>  Hay un b√∫fer constante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbe/13a/0ab/bbe13a0abe0d79f47b0a59d33d51ab9c.png"></div><br>  Echemos un vistazo r√°pido al c√≥digo del ensamblador: se adjuntan dos UAV (u0: b√∫fer de entrada de la primera parte y u1: textura de salida del formato 1x1 R32_FLOAT).  Tambi√©n vemos que hay 64 subprocesos por grupo y 256 elementos de memoria de grupo compartida de 4 bytes. <br><br>  Comenzamos llenando la memoria compartida con datos del b√∫fer de entrada.  Tenemos 64 hilos, por lo que tendr√° que hacer casi lo mismo que antes. <br><br>  Para estar absolutamente seguros de que todos los datos se han cargado para su posterior procesamiento, despu√©s de eso, pusimos una barrera. <br><br> <code>//   -        . <br> //        64 ,    4     <br> //    . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = g_buffer[offset]; <br> } <br> //    ,       ,     <br> //             . <br> GroupMemoryBarrierWithGroupSync();</code> <br> <br>  Todos los c√°lculos se realizan en un solo subproceso, todos los dem√°s se utilizan simplemente para cargar valores desde el b√∫fer en la memoria compartida. <br><br>  La secuencia "inform√°tica" tiene un √≠ndice de 0. ¬øPor qu√©?  Te√≥ricamente, podemos usar cualquier secuencia del intervalo [0-63], pero gracias a una comparaci√≥n con 0, podemos evitar comparaciones enteras-enteras adicionales (es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decir,</a> instrucciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">q</a> ). <br><br>  El algoritmo se basa en la indicaci√≥n del intervalo de p√≠xeles que se tendr√° en cuenta en la operaci√≥n. <br><br>  En la l√≠nea 11, multiplicamos ancho * alto para obtener el n√∫mero total de p√≠xeles y los multiplicamos por dos n√∫meros del intervalo [0.0f-1.0f], indicando el comienzo y el final del intervalo.  Se utilizan restricciones adicionales para garantizar que <code>0 &lt;= Start &lt;= End &lt;= totalPixels - 1</code> : <br><br> <code>//        0. <br> [branch] if (threadID == 0) <br> { <br> //         <br> uint totalPixels = cb0_v0.x * cb0_v0.y; <br> <br> //   (,  ,    ), <br> //        . <br> int pixelsToConsiderStart = totalPixels * cb0_v0.z; <br> int pixelsToConsiderEnd = totalPixels * cb0_v0.w; <br> <br> int pixelsMinusOne = totalPixels - 1; <br> <br> pixelsToConsiderStart = clamp( pixelsToConsiderStart, 0, pixelsMinusOne ); <br> pixelsToConsiderEnd = clamp( pixelsToConsiderEnd, pixelsToConsiderStart, pixelsMinusOne );</code> <br> <br>  Como puede ver, hay dos ciclos a continuaci√≥n.  El problema con ellos (o con su c√≥digo de ensamblador) es que hay transiciones condicionales extra√±as en los extremos de los bucles.  Fue muy dif√≠cil para m√≠ recrearlos.  Tambi√©n eche un vistazo a la l√≠nea 21. ¬øPor qu√© hay "-1"?  Lo explicar√© un poco m√°s abajo. <br><br>  La tarea del primer ciclo es descartar <i>pixelsToConsiderStart</i> y darnos el √≠ndice de la celda del b√∫fer en la que <i>pixelsToConsiderStart</i> +1 est√° presente (as√≠ como el n√∫mero de todos los p√≠xeles en las celdas anteriores). <br><br>  Digamos que <i>pixelsToConsiderStart es</i> aproximadamente igual a 30,000, y en el b√∫fer hay 37,000 p√≠xeles en la celda "cero" (esto sucede en el juego por la noche).  Por lo tanto, queremos comenzar el an√°lisis de brillo con aproximadamente el p√≠xel 30001, que est√° presente en la celda "cero".  En este caso, salimos inmediatamente del bucle, obteniendo el √≠ndice inicial '0' y cero p√≠xeles descartados. <br><br>  Eche un vistazo al c√≥digo HLSL: <br><br> <code>//     <br> int numProcessedPixels = 0; <br> <br> //   [0-255] <br> int lumaValue = 0; <br> <br> //      <br> bool bExitLoop = false; <br> <br> //    -  "pixelsToConsiderStart" . <br> //          lumaValue,      . <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> // ,      lumaValue <br> int tempSum = numProcessedPixels + numPixels; <br> <br> //  ,  pixelsToConsiderStart,    . <br> // ,      lumaValue. <br> //  , pixelsToConsiderStart -   "" ,   ,    . <br> [flatten] <br> if (tempSum &gt; pixelsToConsiderStart) <br> { <br> bExitLoop = true; <br> } <br> else <br> { <br> numProcessedPixels = tempSum; <br> lumaValue++; <br> } <br> }</code> <br> <br>  El misterioso n√∫mero "-1" de la l√≠nea 21 del c√≥digo del ensamblador est√° asociado con la condici√≥n booleana para la ejecuci√≥n del bucle (descubr√≠ esto casi por accidente). <br><br>  Habiendo recibido el n√∫mero de p√≠xeles de <i>las</i> celdas <i>lumaValue</i> y <i>lumaValue</i> , podemos pasar al segundo ciclo. <br><br>  La tarea del segundo ciclo es calcular la influencia de los p√≠xeles y el brillo promedio. <br><br>  Comenzamos con <i>lumaValue</i> calculado en el primer bucle. <br><br> <code>float finalAvgLuminance = 0.0f; <br> <br> //       <br> uint numProcessedPixelStart = numProcessedPixels; <br> <br> //    -      . <br> //    ,    ,        lumaValue. <br> //      [0-255],     ,    ,   ,    <br> //    pixelsToConsiderEnd. <br> //          . <br> bExitLoop = false; <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> //      <br> numProcessedPixels += numPixels; <br> <br> //    ,    [0-255] (uint) <br> uint encodedLumaUint = lumaValue; <br> <br> //        <br> float numberOfPixelsWithCurrentLuma = numPixels; <br> <br> //    ,    [0-255] (float) <br> float encodedLumaFloat = encodedLumaUint;</code> <br> <br>  En esta etapa, obtuvimos el valor de brillo codificado en el intervalo [0.0f-255.f]. <br><br>  El proceso de decodificaci√≥n es bastante simple: debe invertir el c√°lculo de la etapa de codificaci√≥n. <br><br>  Una breve repetici√≥n del proceso de codificaci√≥n: <br><br> <code>float luma = dot( hdrPixelColor, float3(0.2126, 0.7152, 0.0722) ); <br> ... <br> float outLuma; <br> <br> //   log(0)  undef,  log(1) = 0 <br> outLuma = luma + 1.0; <br> <br> //   <br> outLuma = log( outLuma ); <br> <br> //   128,   log(1) * 128 = 0, log(2,71828) * 128 = 128, log(7,38905) * 128 = 256 <br> outLuma = outLuma * 128 <br> <br> //   uint <br> uint outLumaUint = min( (uint) outLuma, 255);</code> <br> <br>  Para decodificar el brillo, revertimos el proceso de codificaci√≥n, por ejemplo, as√≠: <br><br> <code>//    0.5f (  ,    ) <br> float fDecodedLuma = encodedLumaFloat + 0.5; <br> <br> //   : <br> <br> //   128 <br> fDecodedLuma /= 128.0; <br> <br> // exp(x),   log(x) <br> fDecodedLuma = exp(fDecodedLuma); <br> <br> //  1.0 <br> fDecodedLuma -= 1.0;</code> <br> <br>  Luego calculamos la distribuci√≥n multiplicando el n√∫mero de p√≠xeles con un brillo dado por el brillo decodificado, y sum√°ndolos hasta que lleguemos al procesamiento de p√≠xeles a los p√≠xeles de <i>Finalizar la Consideraci√≥n</i> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de eso, dividimos el efecto total en la cantidad de p√≠xeles analizados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ est√° el resto del bucle (y el sombreador): </font><font style="vertical-align: inherit;">el sombreador completo est√° disponible </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">aqu√≠</font></a><font style="vertical-align: inherit;"> . Es totalmente compatible con mi programa </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> , sin el cual no ser√≠a capaz de recrear efectivamente el c√°lculo de brillo promedio en The Witcher 3 (¬°y todos los dem√°s efectos tambi√©n!). </font><font style="vertical-align: inherit;">En conclusi√≥n, algunos pensamientos. En t√©rminos de c√°lculo del brillo promedio, este sombreador fue dif√≠cil de recrear. Las razones principales: </font><font style="vertical-align: inherit;">1) Extra√±os controles "pendientes" sobre la ejecuci√≥n del ciclo, tom√≥ mucho m√°s tiempo de lo que pensaba anteriormente. </font><font style="vertical-align: inherit;">2) Problemas con la depuraci√≥n de este sombreador computacional en RenderDoc (v. 1.2).</font></font><br><br> <code>//     <br> float fCurrentLumaContribution = numberOfPixelsWithCurrentLuma * fDecodedLuma; <br> <br> // ()       . <br> float tempTotalContribution = fCurrentLumaContribution + finalAvgLuminance; <br> <br> <br> [flatten] <br> if (numProcessedPixels &gt; pixelsToConsiderEnd ) <br> { <br> //     <br> bExitLoop = true; <br> <br> //      ,     . <br> //         <br> int diff = numProcessedPixels - numProcessedPixelStart; <br> <br> //     <br> finalAvgLuminance = tempTotalContribution / float(diff); <br> } <br> else <br> { <br> //       lumaValue <br> finalAvgLuminance = tempTotalContribution; <br> lumaValue++; <br> } <br> } <br> <br> //    <br> g_avgLuminance[uint2(0,0)] = finalAvgLuminance;</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las operaciones "ld_structured_indexable" no son totalmente compatibles, aunque el resultado de la lectura del √≠ndice 0 da el valor correcto, todos los dem√°s devuelven ceros, raz√≥n por la cual los ciclos contin√∫an indefinidamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque no pude lograr el mismo c√≥digo de ensamblaje que en el original (vea la captura de pantalla a continuaci√≥n para ver las diferencias), al usar RenderDoc pude inyectar este sombreador en la tuber√≠a, ¬°y los resultados fueron los mismos!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/a0e/74f/de1a0e74f0f6619994d1edc9621d148d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El resultado de la batalla. </font><font style="vertical-align: inherit;">A la izquierda est√° mi sombreador, a la derecha est√° el c√≥digo ensamblador original.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 8. La luna y sus fases. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la octava parte del art√≠culo, examino el sombreador de luna de The Witcher 3 (y m√°s espec√≠ficamente, de la extensi√≥n Blood and Wine). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La luna es un elemento importante del cielo nocturno, y puede ser bastante dif√≠cil hacerlo cre√≠ble, pero para m√≠ caminar de noche en TW3 fue un verdadero placer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Solo mira esta escena!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/099/b6c/53f099b6ccfcef0eeb0755ced73894b9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de tomar el sombreador de p√≠xeles, dir√© algunas palabras sobre los matices de la representaci√≥n. Desde un punto de vista geom√©trico, la Luna es solo una esfera (ver m√°s abajo), que tiene coordenadas de textura, vectores normales y tangentes. El sombreador de v√©rtices calcula la posici√≥n en el espacio mundial, as√≠ como los vectores normalizados de normales, tangentes y tangentes a dos puntos (usando un producto vectorial), multiplicados por la matriz mundial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantizar que la luna se encuentre completamente en un plano distante, los campos MinDepth y MaxDepth de la estructura D3D11_VIEWPORT </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tienen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asignado el valor 0.0 (el mismo truco utilizado para la c√∫pula del cielo). La luna se representa inmediatamente despu√©s del cielo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/999/ec7/6f5999ec7ca1176dfac370f60820d97f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La esfera sol√≠a dibujar la luna</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bueno, creo que todo puede proceder. </font><font style="vertical-align: inherit;">Echemos un vistazo al sombreador de p√≠xeles: la </font><font style="vertical-align: inherit;">raz√≥n principal por la que eleg√≠ un sombreador de Blood and Wine es simple: es m√°s corto. </font><font style="vertical-align: inherit;">Primero, calculamos el desplazamiento para muestrear la textura. </font><font style="vertical-align: inherit;">cb0 [0] .w se usa como desplazamiento a lo largo del eje X. Con este simple truco podemos simular la rotaci√≥n de la luna alrededor de su eje.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[267], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_input_ps linear v1.w <br> dcl_input_ps linear v2.xyzw <br> dcl_input_ps linear v3.xy <br> dcl_input_ps linear v4.xy <br> dcl_output o0.xyzw <br> dcl_temps 3 <br> 0: mov r0.x, -cb0[0].w <br> 1: mov r0.y, l(0) <br> 2: add r0.xy, r0.xyxx, v2.xyxx <br> 3: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, r0.xyxx, t0.xyzw, s0 <br> 4: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 5: log r0.w, r0.w <br> 6: mul r0.w, r0.w, l(2.200000) <br> 7: exp r0.w, r0.w <br> 8: add r0.xyz, r0.xyzx, r0.xyzx <br> 9: dp3 r1.x, r0.xyzx, r0.xyzx <br> 10: rsq r1.x, r1.x <br> 11: mul r0.xyz, r0.xyzx, r1.xxxx <br> 12: mul r1.xy, r0.yyyy, v3.xyxx <br> 13: mad r0.xy, v4.xyxx, r0.xxxx, r1.xyxx <br> 14: mad r0.xy, v2.zwzz, r0.zzzz, r0.xyxx <br> 15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185) <br> 17: sincos r1.x, r2.x, r0.z <br> 18: mov r2.y, r1.x <br> 19: dp2_sat r0.x, r0.xyxx, r2.xyxx <br> 20: mul r0.xyz, r0.xxxx, cb12[266].xyzx <br> 21: mul r0.xyz, r0.xyzx, r0.wwww <br> 22: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 23: add_sat r0.w, -v1.w, l(1.000000) <br> 24: mul r0.w, r0.w, cb2[2].w <br> 25: mul o0.xyz, r0.wwww, r0.xyzx <br> 26: mov o0.w, l(0) <br> 27: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/ddb/c02/fc2ddbc0262d27002f70d837a623c366.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos de valores del b√∫fer constante.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una textura (1024x512) se adjunta como entrada. </font><font style="vertical-align: inherit;">El mapa normal est√° codificado en los canales RGB y el color de la superficie de la luna en el canal alfa. </font><font style="vertical-align: inherit;">Listo!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/733/1a1/3927331a17867d712e667c36a0ee6641.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El canal alfa de una textura es el color de la superficie de la luna.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/542/d70/c64542d70a7e3b58aa9426f12e8880d7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los canales de textura RGB son un mapa normal.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habiendo recibido las coordenadas de textura correctas, tomamos muestras de los canales RGBA. Necesitamos desempaquetar el mapa normal y realizar la correcci√≥n gamma del color de la superficie. Actualmente, un sombreador HLSL puede escribirse as√≠, por ejemplo: </font><font style="vertical-align: inherit;">El siguiente paso es realizar un enlace normal, pero solo en componentes XY. (En The Witcher 3, el eje Z est√° arriba y todo el canal Z de la textura es 1.0). Podemos hacerlo de esta manera: </font><font style="vertical-align: inherit;">ahora es el momento de mi parte favorita de este sombreador. </font><font style="vertical-align: inherit;">Mire </font><font style="vertical-align: inherit;">nuevamente las l√≠neas 15-16: </font><font style="vertical-align: inherit;">¬øQu√© es este misterioso 0.033864? Al principio, parece que no tiene sentido, pero si calculamos el valor inverso a √©l, obtenemos aproximadamente 29.53, que es igual a la duraci√≥n del </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">mes sin√≥dico</font></a></font><br><br> <code>float4 MoonPS(in InputStruct IN) : SV_Target0 <br> { <br> //  Texcoords <br> float2 uvOffsets = float2(-cb0_v0.w, 0.0); <br> <br> //  texcoords <br> float2 uv = IN.param2.xy + uvOffsets; <br> <br> //   <br> float4 sampledTexture = texture0.Sample( sampler0, uv); <br> <br> //    -  - <br> float moonColorTex = pow(sampledTexture.a, 2.2 ); <br> <br> //     [0,1]   [-1,1]. <br> // : sampledTexture.xyz * 2.0 - 1.0    <br> float3 sampledNormal = normalize((sampledTexture.xyz - 0.5) * 2);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>//    <br> float3 Tangent = IN.param4.xyz; <br> float3 Normal = float3(IN.param2.zw, IN.param3.w); <br> float3 Bitangent = IN.param3.xyz; <br> <br> //  TBN <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> <br> //    XY <br> //   TBN  float3x2: 3 , 2  <br> float2 vNormal = mul(sampledNormal, (float3x2)TBN).xy;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185)</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en dias! </font><font style="vertical-align: inherit;">¬°Esto es lo que llamo la atenci√≥n al detalle! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos suponer de manera confiable que cb0 [0] .y es el n√∫mero de d√≠as que han pasado durante el juego. </font><font style="vertical-align: inherit;">Aqu√≠ se usa una desviaci√≥n adicional, utilizada como el desplazamiento a lo largo del eje x de la textura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo recibido este coeficiente, lo multiplicamos por 2 * Pi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, usando sincos, calculamos otro vector 2d. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al calcular el producto escalar entre el vector normal y el vector "luna", se simula una fase de la luna. </font><font style="vertical-align: inherit;">Mira las capturas de pantalla con diferentes fases de la luna:</font></font><br><br> <code>//  . <br> //   days/29.53 + bias. <br> float phase = cb0_v0.y * (1.0 / SYNODIC_MONTH_LENGTH) + cb0_v0.w; <br> <br> //   2*PI.  , 29.53     <br> //   sin/cos. <br> phase *= TWOPI; <br> <br> //      . <br> float outSin = 0.0; <br> float outCos = 0.0; <br> sincos(phase, outSin, outCos); <br> <br> //    <br> float lunarPhase = saturate( dot(vNormal, float2(outCos, outSin)) );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c54/e7f/648/c54e7f6488b10d402a7f4b45e61d455d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/133/edc/899133edc0c04c67ffb4987748e908b7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El paso final es realizar una serie de operaciones de multiplicaci√≥n para calcular el color final. </font><font style="vertical-align: inherit;">Probablemente no entiendas por qu√© este sombreador env√≠a un valor alfa de 0.0 a la salida. </font><font style="vertical-align: inherit;">Esto se debe a que la luna se representa con la combinaci√≥n habilitada:</font></font><br><br> <code>//        . <br> <br> // cb12_v266.xyz ,      . <br> //  (1.54, 2.82, 4.13) <br> float3 moonSurfaceGlowColor = cb12_v266.xyz; <br> <br> float3 moonColor = lunarPhase * moonSurfaceGlowColor; <br> moonColor = moonColorTex * moonColor; <br> <br> // cb_v2.xyz - , , ,  (1.0, 1.0, 1.0) <br> moonColor *= cb2_v2.xyz; <br> <br> //   ,    , .  -   . <br> //     ,         , <br> //   . <br> float paramHorizon = saturate(1.0 - IN.param1.w); <br> paramHorizon *= cb2_v2.w; <br> <br> moonColor *= paramHorizon; <br> <br> //        <br> return float4(moonColor, 0.0);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/549/32c/2d954932c188bcdcdd0a156796b85da7.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este enfoque le permite obtener el color de fondo (cielo) si este sombreador devuelve negro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si est√° interesado en un sombreador completo, puede tomarlo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tiene grandes buffers constantes y ya deber√≠a estar listo para la inyecci√≥n en RenderDoc en lugar del sombreador original (solo cambie el nombre de "MoonPS" a "EditedShaderPS"). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y el √∫ltimo: quer√≠a compartir los resultados contigo: a </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la izquierda est√° mi sombreador, a la derecha est√° el sombreador original del juego. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La diferencia es m√≠nima y no afecta los resultados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff8/c4a/8fa/ff8c4a8fa103b9592941c965ad060729.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como puede ver, este sombreador fue bastante f√°cil de recrear. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 9. G-buffer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte, revelar√© algunos detalles del gbuffer en The Witcher 3. Asumiremos </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que conoce los conceptos b√°sicos del sombreado diferido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breve repetici√≥n: la idea de posponer no es calcular todas las luces y sombras terminadas a la vez, sino dividir los c√°lculos en dos etapas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la primera (pasada de geometr√≠a) llenamos el GBuffer con datos de superficie (posici√≥n, normales, color especular, etc.), y en la segunda (pasada de iluminaci√≥n) combinamos todo y calculamos la iluminaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sombreado diferido es un enfoque muy popular porque le permite calcular en una sola pasada de pantalla completa mediante t√©cnicas como el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sombreado diferido de mosaico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que mejora enormemente el rendimiento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En pocas palabras, GBuffer es un conjunto de texturas con propiedades de geometr√≠a. </font><font style="vertical-align: inherit;">Es muy importante crear la estructura adecuada para ello. </font><font style="vertical-align: inherit;">Como ejemplo de la vida real, puede estudiar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tecnolog√≠a de renderizado Crysis 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de esta breve introducci√≥n, veamos un marco de ejemplo de The Witcher 3: Blood and Wine:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/6f5/537/2c36f5537e82217c31d0f5f682b17b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uno de los muchos hoteles en Toussent</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basic GBuffer consta de tres objetivos de representaci√≥n en pantalla completa en el formato DXGI_FORMAT_R8G8B8A8_UNORM y un b√∫fer de profundidad + plantilla en el formato DXGI_FORMAT_D24_UNORM_S8_UINT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ est√°n sus capturas de pantalla:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/dec/857/309dec857a7839f41984b44ff82516ab.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizar objetivo 0: canales RGB, color de superficie</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/44c/b90/16c44cb90b067cb420d921e101319bb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizar objetivo 0: canal alfa. </font><font style="vertical-align: inherit;">Honestamente, no tengo idea de qu√© es esta informaci√≥n.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/f1a/cf3/de9f1acf36c9f9e18ec6f4a9708ede11.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 1 - Canales RGB. </font><font style="vertical-align: inherit;">Aqu√≠ se registran los vectores normales en el intervalo [0-1].</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/a60/1e8/0a5a601e893d88a619b94f1ed7d21ae2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizar objetivo 1: canal alfa. </font><font style="vertical-align: inherit;">Parece que la reflectividad!</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fa/8f5/d61/7fa8f5d61cfc903b764eec1e9b46c431.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target 2: canales RGB. </font><font style="vertical-align: inherit;">¬°Parece un color especular! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta escena, el canal alfa es negro (pero luego se usa).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/27d/dab/e7e27ddab2102174b3f63bb9037e28a0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buffer profundidades. </font><font style="vertical-align: inherit;">Tenga en cuenta que la profundidad invertida se utiliza aqu√≠.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/77d/daa/e4e77ddaa01705381f956410f546fdf4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El b√∫fer de plantilla utilizado para marcar un tipo espec√≠fico de p√≠xel (por ejemplo, piel, vegetaci√≥n, etc.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este no es el GBuffer completo. </font><font style="vertical-align: inherit;">El pase de iluminaci√≥n tambi√©n utiliza sondas de iluminaci√≥n y otros amortiguadores, pero no los analizar√© en este art√≠culo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de pasar a la parte "principal" de la publicaci√≥n, har√© observaciones generales:</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Observaciones generales </font></font></h3><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) El √∫nico b√∫fer a limpiar es el b√∫fer de profundidad / plantilla.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si analiza las texturas mencionadas anteriormente en un buen analizador de cuadros, se sorprender√° un poco, ya que no utilizan la llamada "Borrar", con la excepci√≥n de Profundidad / Plantilla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, en realidad, RenderTarget1 se ve as√≠ (tenga en cuenta los p√≠xeles "borrosos" en el plano lejano):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/16a/3a7/22a16a3a7df971c2d1609f15e254cd06.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una optimizaci√≥n simple e inteligente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una lecci√≥n importante: </font><font style="vertical-align: inherit;">debe gastar recursos </font><font style="vertical-align: inherit;">en llamadas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClearRenderTargetView</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as√≠ que </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">√∫selas</font></a><font style="vertical-align: inherit;"> solo cuando sea necesario. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) la profundidad invertida - es enfriar</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muchos </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culos </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ya </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escritos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre la precisi√≥n de la memoria intermedia de profundidad con coma flotante. Witcher 3 usa z invertida. Esta es la elecci√≥n natural para un juego de mundo abierto con largas distancias de renderizado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar a DirectX no ser√° dif√≠cil: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Limpiamos el b√∫fer de profundidad escribiendo "0", no "1". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el enfoque tradicional, el valor lejano "1" se utiliz√≥ para borrar el b√∫fer de profundidad. Despu√©s del cambio de profundidad, el nuevo valor "distante" se convirti√≥ en 0, por lo que debe cambiar todo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Cambie los l√≠mites cercanos y lejanos al calcular la matriz de proyecci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Cambie la verificaci√≥n de profundidad de "menos" a "m√°s". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para OpenGL, se necesita un poco m√°s de trabajo (ver los art√≠culos mencionados anteriormente), pero vale la pena. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) No mantenemos nuestra posici√≥n en el mundo</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , s√≠, todo es muy simple. </font><font style="vertical-align: inherit;">En el paso de la iluminaci√≥n, recreamos una posici√≥n en el mundo desde las profundidades.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de p√≠xeles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte, quer√≠a mostrar exactamente el sombreador de p√≠xeles que proporciona datos de superficie a GBuffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ que ahora ya sabemos c√≥mo almacenar colores, normales y especulares. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, no todo es tan simple como podr√≠a pensar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema con el sombreador de p√≠xeles es que tiene muchas opciones. </font><font style="vertical-align: inherit;">Difieren en el n√∫mero de texturas transferidas a ellos y en el n√∫mero de par√°metros utilizados del buffer constante (probablemente del buffer constante que describe el material). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para el an√°lisis, decid√≠ usar este hermoso barril:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/635/aa0/262635aa0a42dde5353586c867bc91d1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro heroico barril! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por favor, dale la bienvenida a las texturas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/fde/9bb/9e4fde9bbe2ebcc3c1088eff5e3ea40d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces tenemos albedo, un mapa normal y color especular. Estuche bastante est√°ndar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de comenzar, algunas palabras sobre la entrada de geometr√≠a: La </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geometr√≠a se transmite con posici√≥n, texcoords, buffers normales y tangentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El sombreador de v√©rtices genera </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al menos</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texcoords, vectores tangentes / normales / tangentes normalizados a dos puntos, previamente multiplicados por la matriz mundial. Para materiales m√°s complejos (por ejemplo, con dos mapas difusos o dos mapas normales), el sombreador de v√©rtices puede generar otros datos, pero quer√≠a mostrar un ejemplo simple aqu√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sombreador de p√≠xeles en el c√≥digo del ensamblador: un </font><font style="vertical-align: inherit;">sombreador consta de varios pasos. Describir√© cada parte principal de este sombreador por separado.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[3], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t2 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 3 <br> 0: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v1.xyxx, t1.xyzw, s0 <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t0.xyzw, s0 <br> 2: add r1.w, r1.y, r1.x <br> 3: add r1.w, r1.z, r1.w <br> 4: mul r2.x, r1.w, l(0.333300) <br> 5: add r2.y, l(-1.000000), cb4[1].x <br> 6: mul r2.y, r2.y, l(0.500000) <br> 7: mov_sat r2.z, r2.y <br> 8: mad r1.w, r1.w, l(-0.666600), l(1.000000) <br> 9: mad r1.w, r2.z, r1.w, r2.x <br> 10: mul r2.xzw, r1.xxyz, cb4[0].xxyz <br> 11: mul_sat r2.xzw, r2.xxzw, l(1.500000, 0.000000, 1.500000, 1.500000) <br> 12: mul_sat r1.w, abs(r2.y), r1.w <br> 13: add r2.xyz, -r1.xyzx, r2.xzwx <br> 14: mad r1.xyz, r1.wwww, r2.xyzx, r1.xyzx <br> 15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx <br> 21: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r1.xyz, v3.xyzx, r0.xxxx, r1.xyzx <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r1.xyzx <br> 28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w <br> 46: dp3 r0.w, r0.xyzx, r0.xyzx <br> 47: rsq r0.w, r0.w <br> 48: mul r0.xyz, r0.wwww, r0.xyzx <br> 49: max r0.w, abs(r0.y), abs(r0.x) <br> 50: max r0.w, r0.w, abs(r0.z) <br> 51: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 52: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 53: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 54: lt r1.z, r1.y, r1.x <br> 55: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 56: div r1.z, r1.y, r1.x <br> 57: div r0.xyz, r0.xyzx, r0.wwww <br> 58: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 59: mul r0.xyz, r0.wwww, r0.xyzx <br> 60: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 61: mov o0.w, cb4[2].x <br> 62: mov o2.w, l(0) <br> 63: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pero primero, como de costumbre, una captura de pantalla con los valores del b√∫fer constante: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e94/24c/abb/e9424cabbd31630a47b7489e0e32c6af.jpg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Albedo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzaremos con cosas complejas. </font><font style="vertical-align: inherit;">No es solo </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"OutputColor.rgb = Texture.Sample (uv) .rgb"</font></font></strike> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de probar la textura de color RGB (l√≠nea 1), las siguientes 14 l√≠neas son lo que yo llamo el "buffer de reducci√≥n de saturaci√≥n". </font><font style="vertical-align: inherit;">D√©jame mostrarte el c√≥digo HLSL: </font><font style="vertical-align: inherit;">para la mayor√≠a de los objetos, este c√≥digo no hace m√°s que devolver el color original de la textura. </font><font style="vertical-align: inherit;">Esto se logra mediante los valores correspondientes de "material cbuffer". </font><font style="vertical-align: inherit;">cb4_v1.x tiene un valor de 1.0, que devuelve una m√°scara de 0.0 y devuelve el color de entrada de la instrucci√≥n </font><i><font style="vertical-align: inherit;">lerp</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sin embargo, hay algunas excepciones. </font><font style="vertical-align: inherit;">El </font><i><font style="vertical-align: inherit;">factor de desaturaci√≥n</font></i><font style="vertical-align: inherit;"> m√°s grande </font><font style="vertical-align: inherit;">que </font><i><font style="vertical-align: inherit;">encontr√©</font></i><font style="vertical-align: inherit;"> es 4.0 (nunca es menor que 1.0), y el </font><i><font style="vertical-align: inherit;">color desaturado</font></i></font><br><br> <code>float3 albedoColorFilter( in float3 color, in float desaturationFactor, in float3 desaturationValue ) <br> { <br> float sumColorComponents = color.r + color.g + color.b; <br> <br> float averageColorComponentValue = 0.3333 * sumColorComponents; <br> float oneMinusAverageColorComponentValue = 1.0 - averageColorComponentValue; <br> <br> float factor = 0.5 * (desaturationFactor - 1.0); <br> <br> float avgColorComponent = lerp(averageColorComponentValue, oneMinusAverageColorComponentValue, saturate(factor)); <br> float3 desaturatedColor = saturate(color * desaturationValue * 1.5); <br> <br> float mask = saturate( avgColorComponent * abs(factor) ); <br> <br> float3 finalColor = lerp( color, desaturatedColor, mask ); <br> return finalColor; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depende del material. </font><font style="vertical-align: inherit;">Puede ser algo como (0.2, 0.3, 0.4); </font><font style="vertical-align: inherit;">No hay reglas estrictas. </font><font style="vertical-align: inherit;">Por supuesto, no pude resistirme a implementar esto en mi propio marco DX11, y aqu√≠ est√°n los resultados donde todos los valores </font><font style="vertical-align: inherit;">de color </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son iguales a float3 (0.25, 0.3, 0.45)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12f/184/2d9/12f1842d9d272fc057f35bc73439c4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 1.0 (no tiene efecto)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/ead/3a3/03cead3a3d5a713e051e7d863d99ecb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 2.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/c81/992/cafc81992ebb70914c1e9d6605b8ba17.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 3.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f37/193/7fb/f371937fb39f94a887410a951f9eb628.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 4.0</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estoy seguro de que esto es solo una aplicaci√≥n de par√°metros de material, pero no se realiza al final de la parte albedo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las l√≠neas 15-20 agregan los toques finales: </font><font style="vertical-align: inherit;">v0.z es la salida del sombreador de v√©rtices, y son cero. </font><font style="vertical-align: inherit;">No lo olvides, porque v0.z luego se usar√° un par de veces. </font><font style="vertical-align: inherit;">Parece que es alg√∫n tipo de coeficiente, y todo el c√≥digo parece un peque√±o albedo de atenuaci√≥n, pero dado que v0.z es 0, el color permanece sin cambios. </font><font style="vertical-align: inherit;">HLSL: </font><font style="vertical-align: inherit;">Con respecto a RT0.a, como podemos ver, se toma del b√∫fer de material constante, pero dado que el sombreador no tiene informaci√≥n de depuraci√≥n, es dif√≠cil decir qu√© es. </font><font style="vertical-align: inherit;">Tal vez la translucidez? </font><font style="vertical-align: inherit;">¬°Hemos terminado con el primer objetivo de renderizado!</font></font><br><br> <code>15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* ALBEDO */ <br> //     (?) <br> float3 albedoColor = albedoColorFilter( colorTex, cb4_v1.x, cb4_v0.rgb ); <br> float albedoMaxComponent = getMaxComponent( albedoColor ); <br> <br> //   ,   <br> //       "paramZ"   0 <br> float paramZ = Input.out0.z; // ,    0 <br> <br> // ,  0.70  0.85      <br> //       lerp,     . <br> float param = (albedoMaxComponent &gt; 0.22) ? 0.70 : 0.85; <br> float mulParam = lerp(1, param, paramZ); <br> <br> //  <br> pout.RT0.rgb = albedoColor * mulParam; <br> pout.RT0.a = cb4_v2.x;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos desempacando el mapa normal y luego, como de costumbre, vincularemos las normales: </font><font style="vertical-align: inherit;">hasta ahora, nada sorprendente. </font><i><font style="vertical-align: inherit;">Mire las l√≠neas 28-33:</font></i><font style="vertical-align: inherit;"> podemos escribirlas aproximadamente de la siguiente manera: </font><font style="vertical-align: inherit;">No estoy seguro si es correcto escribirlas. </font><font style="vertical-align: inherit;">Si sabes qu√© es esta operaci√≥n matem√°tica, h√°zmelo saber. </font><font style="vertical-align: inherit;">Vemos que el sombreador de p√≠xeles usa SV_IsFrontFace.</font></font><br><br> <code>/*  */ <br> float3 sampledNormal = ((normalTex.xyz - 0.5) * 2); <br> <br> //     TBN <br> float3 Tangent = Input.TangentW.xyz; <br> float3 Normal = Input.NormalW.xyz; <br> float3 Bitangent; <br> Bitangent.x = Input.out0.w; <br> Bitangent.yz = Input.out1.zw; <br> <br> //      ;  ,  ,   normal-tbn <br> //      'mad'   'mov' <br> Bitangent = saturate(Bitangent); <br> <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> float3 normal = mul( sampledNormal, TBN );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <code>28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>[branch] if (bIsFrontFace &lt;= 0) <br> { <br> float cosTheta = dot(Input.NormalW, normal); <br> float3 invNormal = cosTheta * Input.NormalW; <br> normal = normal - 2*invNormal; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br>  Que es esto<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> viene para ayudar </font><font style="vertical-align: inherit;">(quer√≠a escribir "msdn", pero ...):</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determina si el tri√°ngulo est√° mirando a la c√°mara. </font><font style="vertical-align: inherit;">Para l√≠neas y puntos, IsFrontFace es verdadero. </font><font style="vertical-align: inherit;">Una excepci√≥n son las l√≠neas dibujadas a partir de tri√°ngulos (modo de estructura al√°mbrica), que establecen IsFrontFace de manera similar a rasterizar un tri√°ngulo en modo s√≥lido. </font><font style="vertical-align: inherit;">Se puede escribir en √©l con un sombreador de geometr√≠a y leerlo con un sombreador de p√≠xeles.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quer√≠a comprobarlo por mi cuenta. </font><font style="vertical-align: inherit;">Y, de hecho, el efecto solo se nota en el modo de estructura al√°mbrica. </font><font style="vertical-align: inherit;">Creo que este c√≥digo es necesario para el c√°lculo correcto de las normales (y, por lo tanto, la iluminaci√≥n) en modo de estructura al√°mbrica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay una comparaci√≥n: tanto los colores del marco de la escena terminada con este truco activado / desactivado, como la textura del gbuffer [0-1] normales con el truco activado / desactivado:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/46b/81b/59846b81b8b9ed57f0441f29e22e6656.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El color de la escena sin truco.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/590/7e1/a97/5907e1a978e58b6fa362ef2e4b6187a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escena de color con acrobacias</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/09a/c0e/74509ac0e56fa639ec4ae2d70a39be44.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] sin truco</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/2f8/622/db82f86223182135807d316fe479ff08.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] con un truco</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øHas notado que cada objetivo de renderizado en GBuffer tiene el formato R8G8B8A8_UNORM? Esto significa que hay 256 valores posibles por componente. ¬øEs esto suficiente para almacenar normales? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El almacenamiento de normales de alta calidad con suficientes bytes en Gbuffer es un problema conocido, pero afortunadamente hay </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muchos </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">materiales </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diferentes</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">aprender</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Quiz√°s algunos de ustedes ya saben qu√© t√©cnica se usa aqu√≠. Debo decir que en todo el pasaje de la geometr√≠a hay una textura adicional unida a la ranura 13 ...:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/e4a/0bf/ab1e4a0bf128bfed8837d3cd081748f8.jpg"></div><br><br>  Ja!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Witcher 3 utiliza una t√©cnica llamada " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal de mejor ajuste</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Aqu√≠ no lo explicar√© en detalle (ver presentaci√≥n). </font><font style="vertical-align: inherit;">Fue inventado alrededor de 2009-2010 por Crytek, y dado que CryEngine tiene c√≥digo abierto, BFN tambi√©n es de </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo abierto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFN le da a la textura de las normales un aspecto "granulado". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de escalar las normales usando BFN, las recodificamos del intervalo [-1; 1] a [0, 1].</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Especular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos desde la l√≠nea 34 y muestreemos la textura especular: </font><font style="vertical-align: inherit;">como puede ver, hay un filtro de "atenuaci√≥n" que conocemos de Albedo: </font><font style="vertical-align: inherit;">calculamos el componente con m√°x. </font><font style="vertical-align: inherit;">valor, y luego calcular el color "oscuro" e interpolarlo con el color especular original, tomando el par√°metro del sombreador de v√©rtices ... que es 0, entonces en la salida obtenemos el color de la textura. </font><font style="vertical-align: inherit;">HLSL:</font></font><br><br> <code>34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* SPECULAR */ <br> float3 specularTex = texture2.Sample( samplerAnisoWrap, Texcoords ).rgb; <br> <br> //   ,    Albedo.  . ,    <br> // -        "". <br> //      paramZ   0,    <br> //  . <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> float3 specB = (specularMaxComponent &gt; 0.2) ? specularTex : float3(0.12, 0.12, 0.12); <br> float3 finalSpec = lerp(specularTex, specB, paramZ); <br> pout.RT2.xyz = finalSpec;</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflexividad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tengo idea de si este nombre es adecuado para este par√°metro, porque no s√© c√≥mo afecta el paso de la iluminaci√≥n. </font><font style="vertical-align: inherit;">El hecho es que el canal alfa del mapa normal de entrada contiene datos adicionales:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/9e5/bd1/5d29e5bd1cb4888593139c38630e3f8e.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textura de canal alfa "mapa normal". </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo de ensamblador: ¬° </font><font style="vertical-align: inherit;">Saluda a nuestro viejo amigo - v0.z! </font><font style="vertical-align: inherit;">Su significado es similar al albedo y especular:</font></font><br><br> <code>41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>/* REFLECTIVITY */ <br> float reflectivity = normalTex.a; <br> float reflectivity2 = (reflectivity &lt; 0.33) ? (reflectivity * 0.95) : 0.33; <br> <br> float finalReflectivity = lerp(reflectivity, reflectivity2, paramZ); <br> pout.RT1.a = finalReflectivity;</code> <br> <br>  Genial<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es el final del an√°lisis de la primera versi√≥n del sombreador de p√≠xeles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay una comparaci√≥n de mi sombreador (izquierda) con el original (derecha):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/f18/47b/2c1f1847b5ceef3cd0e2f8dfba45d2a6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estas diferencias no afectan los c√°lculos, por lo que mi trabajo aqu√≠ est√° terminado. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader: Albedo + Opci√≥n Normal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decid√≠ mostrar una opci√≥n m√°s, ahora solo con albedo y mapas normales, sin textura especular. El c√≥digo del ensamblador es un poco m√°s largo: </font><font style="vertical-align: inherit;">la diferencia entre esta y las opciones anteriores es la siguiente: </font><font style="vertical-align: inherit;">a) </font><b><font style="vertical-align: inherit;">l√≠neas 1, 19</font></b><font style="vertical-align: inherit;"> : el par√°metro de interpolaci√≥n v0.z se multiplica por cb4 [0] .x del b√∫fer constante, pero este producto solo se usa para el albedo de interpolaci√≥n en la l√≠nea 19. Para otra salida, se utiliza el valor "normal" de v0.z. </font><font style="vertical-align: inherit;">b) </font><b><font style="vertical-align: inherit;">l√≠neas 54-55</font></b><font style="vertical-align: inherit;"> : o2.w ahora se establece bajo la condici√≥n de que (cb4 [7] .x&gt; 0.0) </font><font style="vertical-align: inherit;">Ya reconocemos este patr√≥n "alg√∫n tipo de comparaci√≥n - Y" a partir del c√°lculo del histograma de brillo. Se puede escribir as√≠: </font><font style="vertical-align: inherit;">c) </font><b><font style="vertical-align: inherit;">l√≠neas 34-42</font></b><font style="vertical-align: inherit;"> : un c√°lculo especular completamente diferente.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 4 <br> 0: mul r0.x, v0.z, cb4[0].x <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t1.xyzw, s0 <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.yzw, v1.xyxx, t0.wxyz, s0 <br> 3: add r2.x, r0.z, r0.y <br> 4: add r2.x, r0.w, r2.x <br> 5: add r2.z, l(-1.000000), cb4[2].x <br> 6: mul r2.yz, r2.xxzx, l(0.000000, 0.333300, 0.500000, 0.000000) <br> 7: mov_sat r2.w, r2.z <br> 8: mad r2.x, r2.x, l(-0.666600), l(1.000000) <br> 9: mad r2.x, r2.w, r2.x, r2.y <br> 10: mul r3.xyz, r0.yzwy, cb4[1].xyzx <br> 11: mul_sat r3.xyz, r3.xyzx, l(1.500000, 1.500000, 1.500000, 0.000000) <br> 12: mul_sat r2.x, abs(r2.z), r2.x <br> 13: add r2.yzw, -r0.yyzw, r3.xxyz <br> 14: mad r0.yzw, r2.xxxx, r2.yyzw, r0.yyzw <br> 15: max r2.x, r0.w, r0.z <br> 16: max r2.x, r0.y, r2.x <br> 17: lt r2.x, l(0.220000), r2.x <br> 18: movc r2.x, r2.x, l(-0.300000), l(-0.150000) <br> 19: mad r0.x, r0.x, r2.x, l(1.000000) <br> 20: mul o0.xyz, r0.xxxx, r0.yzwy <br> 21: add r0.xyz, r1.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r0.xyw, v3.xyxz, r0.xxxx, r1.xyxz <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r0.xywx <br> 28: uge r0.w, l(0), v4.x <br> 29: if_nz r0.w <br> 30: dp3 r0.w, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r0.wwww, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx <br> 43: max r0.w, r1.z, r1.y <br> 44: max r0.w, r0.w, r1.x <br> 45: lt r0.w, l(0.200000), r0.w <br> 46: movc r2.xyz, r0.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 47: add r2.xyz, -r1.xyzx, r2.xyzx <br> 48: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 49: lt r0.w, r1.w, l(0.330000) <br> 50: mul r1.x, r1.w, l(0.950000) <br> 51: movc r0.w, r0.w, r1.x, l(0.330000) <br> 52: add r0.w, -r1.w, r0.w <br> 53: mad o1.w, v0.z, r0.w, r1.w <br> 54: lt r0.w, l(0), cb4[7].x <br> 55: and o2.w, r0.w, l(0.064706) <br> 56: dp3 r0.w, r0.xyzx, r0.xyzx <br> 57: rsq r0.w, r0.w <br> 58: mul r0.xyz, r0.wwww, r0.xyzx <br> 59: max r0.w, abs(r0.y), abs(r0.x) <br> 60: max r0.w, r0.w, abs(r0.z) <br> 61: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 62: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 63: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 64: lt r1.z, r1.y, r1.x <br> 65: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 66: div r1.z, r1.y, r1.x <br> 67: div r0.xyz, r0.xyzx, r0.wwww <br> 68: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 69: mul r0.xyz, r0.wwww, r0.xyzx <br> 70: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 71: mov o0.w, cb4[6].x <br> 72: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>pout.RT2.w = (cb4_v7.x &gt; 0.0) ? (16.5/255.0) : 0.0;</code> <br> <br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay textura especular aqu√≠. </font><font style="vertical-align: inherit;">Veamos el c√≥digo del ensamblador responsable de esta parte: </font><font style="vertical-align: inherit;">tenga en cuenta que lo usamos aqu√≠ (1 - capacidad reflejada). </font><font style="vertical-align: inherit;">Afortunadamente, escribir esto en HLSL es bastante simple: </font><font style="vertical-align: inherit;">agregar√© que en esta versi√≥n el b√∫fer constante con datos de material es un poco m√°s grande. </font><font style="vertical-align: inherit;">Aqu√≠, estos valores adicionales se utilizan para emular el color especular. </font><font style="vertical-align: inherit;">El resto del sombreador es el mismo que en la versi√≥n anterior. </font><font style="vertical-align: inherit;">72 l√≠neas de c√≥digo de ensamblador es demasiado para mostrar en WinMerge, as√≠ que cr√©ame: mi c√≥digo result√≥ ser casi el mismo que en el original. </font><font style="vertical-align: inherit;">¬°O puede descargar mi </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> y verlo usted mismo!</font></font><br><br> <code>34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>float oneMinusReflectivity = 1.0 - normalTex.a; <br> float3 specularTex = pow(cb4_v3.rgb, 2.2); <br> oneMinusReflectivity = oneMinusReflectivity * cb4_v4.x + cb4_v5.x; <br> specularTex = saturate(specularTex * oneMinusReflectivity); <br> specularTex = pow(specularTex, 1.0/2.2); <br> <br> //     ... <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para resumir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... y si lo lees aqu√≠, entonces probablemente quieras profundizar un poco m√°s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo que parece simple en la vida real a menudo no es el caso, y la transferencia de datos a gbuffer The Witcher 3 no fue la excepci√≥n. </font><font style="vertical-align: inherit;">Le mostr√© solo las versiones m√°s simples de los sombreadores de p√≠xeles responsables de ello, y tambi√©n proporcion√© observaciones generales relacionadas con el sombreado diferido en general. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para la mayor√≠a de los pacientes, hay dos opciones para sombreadores de p√≠xeles en pastebin: </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opci√≥n 1 - con textura especular </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opci√≥n 2 - sin textura especular</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 10. Cortinas de lluvia a lo lejos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte veremos un maravilloso efecto atmosf√©rico que realmente me gusta: </font><font style="vertical-align: inherit;">lluvia </font><font style="vertical-align: inherit;">distante </font><font style="vertical-align: inherit;">/ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cortinas de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> luz cerca del horizonte. </font><font style="vertical-align: inherit;">En el juego, son m√°s f√°ciles de encontrar en las Islas Skellig.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VXt4PEEqV2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personalmente, me gusta mucho este fen√≥meno atmosf√©rico y ten√≠a curiosidad por saber c√≥mo lo implementaron los programadores gr√°ficos de CD Projekt Red. </font><font style="vertical-align: inherit;">¬°Vamos a resolverlo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay dos capturas de pantalla antes y despu√©s de aplicar las cortinas de lluvia:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/62a/eb6/a9a62aeb6050efd2404f9d352fc89d33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A las cortinas de lluvia</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/e43/fcf/9aae43fcf34413a4810778e101b8a209.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de las cortinas de lluvia</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geometr√≠a </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, nos centraremos en la geometr√≠a. </font><font style="vertical-align: inherit;">La idea es usar un cilindro peque√±o:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/df3/add/fc4df3addf2524bc18f91c46a42fcd6a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un cilindro en el espacio local</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desde el punto de vista de su posici√≥n en el espacio local, es bastante peque√±o: su posici√≥n est√° en el rango (0.0 - 1.0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El circuito de entrada para esta llamada de sorteo se ve as√≠ ...</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1d/a35/c00/c1da35c0080225e7a47d8010c42aeab8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo siguiente es importante para nosotros aqu√≠: Texcoords e Instance_Transform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los Texcoords se envuelven de manera bastante simple: U de las bases superior e inferior est√°n en el intervalo [0.02777 - 1.02734]. V en la base inferior es 1.0, y en la superior - 0.0. Como puede ver, simplemente puede crear esta malla incluso de manera procesal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo recibido este peque√±o cilindro en el espacio local, lo multiplicamos por la matriz mundial provista para cada instancia del elemento de entrada INSTANCE_TRANSFORM. Veamos los valores de esta matriz:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e88/791/17e/e8879117edb6f1dd9b53d3e7334a22df.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/fb8/697/adffb8697a86ac86b935a00d6ae23dda.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/608/599/f6c/608599f6cf3930889c92df1a256991af.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece bastante aterrador, ¬øverdad? </font><font style="vertical-align: inherit;">¬°Pero no se preocupe, analizaremos esta matriz y veremos qu√© oculta! </font><font style="vertical-align: inherit;">Los resultados son muy interesantes: </font><font style="vertical-align: inherit;">es importante conocer la posici√≥n de la c√°mara en este cuadro en particular: (-116.5338, 234.8695, 2.09) </font><font style="vertical-align: inherit;">Como puede ver, escalamos el cilindro para hacerlo bastante grande en el espacio mundial (en TW3 el eje Z est√° dirigido hacia arriba), lo movimos en relaci√≥n con la posici√≥n de la c√°mara y se volvi√≥. </font><font style="vertical-align: inherit;">As√≠ es como se ve el cilindro despu√©s de la conversi√≥n con el sombreador de v√©rtices:</font></font><br><br> <code>XMMATRIX mat( -227.7472, 159.8043, 374.0736, -116.4951, <br> -194.7577, -173.3836, -494.4982, 238.6908, <br> -14.16466, -185.4743, 784.564, -1.45565, <br> 0.0, 0.0, 0.0, 1.0 ); <br> <br> mat = XMMatrixTranspose( mat ); <br> <br> XMVECTOR vScale; <br> XMVECTOR vRotateQuat; <br> XMVECTOR vTranslation; <br> XMMatrixDecompose( &amp;vScale, &amp;vRotateQuat, &amp;vTranslation, mat ); <br> <br> //  ... <br> XMMATRIX matRotate = XMMatrixRotationQuaternion( vRotateQuat );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>vRotateQuat: (0.0924987569, -0.314900011, 0.883411944, -0.334462732) <br> <br> vScale: (299.999969, 300.000000, 1000.00012) <br> <br> vTranslation: (-116.495102, 238.690796, -1.45564997)</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/457/ca6/f60457ca61dd2d15ec3805b387e71def.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cilindro despu√©s de la conversi√≥n por sombreador de v√©rtices. </font><font style="vertical-align: inherit;">Vea c√≥mo se ubica en relaci√≥n con la pir√°mide de visibilidad.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de v√©rtices </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La geometr√≠a de entrada y el sombreador de v√©rtices dependen estrictamente el uno del otro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echemos un vistazo m√°s de cerca al c√≥digo de ensamblador para el sombreador de v√©rtices: </font><font style="vertical-align: inherit;">junto con Texcoords simples que pasan (l√≠nea 0) e Instance_LOD_Params (l√≠nea 8), se necesitan dos elementos m√°s para la salida: SV_Position (esto es obvio) y Altura (componente .z) de la posici√≥n en el mundo. </font><font style="vertical-align: inherit;">¬øRecuerdas que el espacio local est√° en el rango [0-1]? Entonces, justo antes de aplicar la matriz mundial, el sombreador de v√©rtices usa escala y desviaci√≥n para cambiar la posici√≥n local. Movimiento inteligente! </font><font style="vertical-align: inherit;">En este caso, scale = float3 (4, 4, 2) y bias = float3 (-2, -2, -1). &lt; </font><font style="vertical-align: inherit;">El patr√≥n que se nota entre las l√≠neas 9 y 28 es la multiplicaci√≥n de dos matrices de filas principales. </font><font style="vertical-align: inherit;">Veamos el sombreador de v√©rtices terminado en HLSL:</font></font><br><br> <code>vs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb1[7], immediateIndexed <br> dcl_constantbuffer cb2[6], immediateIndexed <br> dcl_input v0.xyz <br> dcl_input v1.xy <br> dcl_input v4.xyzw <br> dcl_input v5.xyzw <br> dcl_input v6.xyzw <br> dcl_input v7.xyzw <br> dcl_output o0.xyz <br> dcl_output o1.xyzw <br> dcl_output_siv o2.xyzw, position <br> dcl_temps 2 <br> 0: mov o0.xy, v1.xyxx <br> 1: mul r0.xyzw, v5.xyzw, cb1[6].yyyy <br> 2: mad r0.xyzw, v4.xyzw, cb1[6].xxxx, r0.xyzw <br> 3: mad r0.xyzw, v6.xyzw, cb1[6].zzzz, r0.xyzw <br> 4: mad r0.xyzw, cb1[6].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 5: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx <br> 6: mov r1.w, l(1.000000) <br> 7: dp4 o0.z, r1.xyzw, r0.xyzw <br> 8: mov o1.xyzw, v7.xyzw <br> 9: mul r0.xyzw, v5.xyzw, cb1[0].yyyy <br> 10: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw <br> 11: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw <br> 12: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 13: dp4 o2.x, r1.xyzw, r0.xyzw <br> 14: mul r0.xyzw, v5.xyzw, cb1[1].yyyy <br> 15: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw <br> 16: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw <br> 17: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 18: dp4 o2.y, r1.xyzw, r0.xyzw <br> 19: mul r0.xyzw, v5.xyzw, cb1[2].yyyy <br> 20: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw <br> 21: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw <br> 22: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 23: dp4 o2.z, r1.xyzw, r0.xyzw <br> 24: mul r0.xyzw, v5.xyzw, cb1[3].yyyy <br> 25: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw <br> 26: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw <br> 27: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 28: dp4 o2.w, r1.xyzw, r0.xyzw <br> 29: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>cbuffer cbPerFrame : register (b1) <br> { <br> row_major float4x4 g_viewProjMatrix; <br> row_major float4x4 g_rainShaftsViewProjMatrix; <br> } <br> <br> cbuffer cbPerObject : register (b2) <br> { <br> float4x4 g_mtxWorld; <br> float4 g_modelScale; <br> float4 g_modelBias; <br> } <br> <br> struct VS_INPUT <br> { <br> float3 PositionW : POSITION; <br> float2 Texcoord : TEXCOORD; <br> float3 NormalW : NORMAL; <br> float3 TangentW : TANGENT; <br> float4 InstanceTransform0 : INSTANCE_TRANSFORM0; <br> float4 InstanceTransform1 : INSTANCE_TRANSFORM1; <br> float4 InstanceTransform2 : INSTANCE_TRANSFORM2; <br> float4 InstanceLODParams : INSTANCE_LOD_PARAMS; <br> }; <br> <br> struct VS_OUTPUT <br> { <br> float3 TexcoordAndZ : Texcoord0; <br> <br> float4 LODParams : LODParams; <br> float4 PositionH : SV_Position; <br> }; <br> <br> VS_OUTPUT RainShaftsVS( VS_INPUT Input ) <br> { <br> VS_OUTPUT Output = (VS_OUTPUT)0; <br> <br> //    <br> Output.TexcoordAndZ.xy = Input.Texcoord; <br> Output.LODParams = Input.InstanceLODParams; <br> <br> //   <br> float3 meshScale = g_modelScale.xyz; // float3( 4, 4, 2 ); <br> float3 meshBias = g_modelBias.xyz; // float3( -2, -2, -1 ); <br> float3 PositionL = Input.PositionW * meshScale + meshBias; <br> <br> //    instanceWorld  float4s: <br> float4x4 matInstanceWorld = float4x4(Input.InstanceTransform0, Input.InstanceTransform1, <br> Input.InstanceTransform2 , float4(0, 0, 0, 1) ); <br> <br> //     (.z) <br> float4x4 matWorldInstanceLod = mul( g_rainShaftsViewProjMatrix, matInstanceWorld ); <br> Output.TexcoordAndZ.z = mul( float4(PositionL, 1.0), transpose(matWorldInstanceLod) ).z; <br> <br> // SV_Posiiton <br> float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld ); <br> Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) ); <br> <br> return Output; <br> }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparaci√≥n de mi sombreador (izquierda) y el original (derecha): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef3/4f3/4ed/ef34f34edbc63113a08f47b7cde00df0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las diferencias no afectan los c√°lculos. </font><font style="vertical-align: inherit;">¬°Inyect√© mi sombreador en el marco y todo segu√≠a bien!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de p√≠xeles </font></font></h3><br>  Por fin!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comenzar, le mostrar√© la entrada: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠ se utilizan dos texturas: la textura de ruido y el b√∫fer de profundidad:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/558/fc3/83a558fc3c8c7e723eb85308b12657d6.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/0da/111/db50da111880f6b934d8bed6b74491e6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valores de buffers constantes: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/394/bdc/a12394bdc039e522beeff97b8e41cd80.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37a/c47/485/37ac47485335960b2efbefc9f315ef14.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/e70/38a/4e7e7038a1bc956aadbb695d70b80ded.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/775/bc4/7ae775bc4a9388feceaa1ddf8c0a214a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y el c√≥digo ensamblador para el sombreador de p√≠xeles: </font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[8], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s15, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t15 <br> dcl_input_ps linear v0.xyz <br> dcl_input_ps linear v1.w <br> dcl_input_ps_siv v2.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 1 <br> 0: mul r0.xy, cb0[0].xxxx, cb4[5].xyxx <br> 1: mad r0.xy, v0.xyxx, cb4[4].xyxx, r0.xyxx <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t0.xyzw, s0 <br> 3: add r0.y, -cb4[2].x, cb4[3].x <br> 4: mad_sat r0.x, r0.x, r0.y, cb4[2].x <br> 5: mul r0.x, r0.x, v0.y <br> 6: mul r0.x, r0.x, v1.w <br> 7: mul r0.x, r0.x, cb4[1].x <br> 8: mul r0.yz, v2.xxyx, cb0[1].zzwz <br> 9: sample_l(texture2d)(float,float,float,float) r0.y, r0.yzyy, t15.yxzw, s15, l(0) <br> 10: mad r0.y, r0.y, cb12[22].x, cb12[22].y <br> 11: mad r0.y, r0.y, cb12[21].x, cb12[21].y <br> 12: max r0.y, r0.y, l(0.000100) <br> 13: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 14: add r0.y, r0.y, -v0.z <br> 15: mul_sat r0.y, r0.y, cb4[6].x <br> 16: mul_sat r0.x, r0.y, r0.x <br> 17: mad r0.y, cb0[7].y, r0.x, -r0.x <br> 18: mad r0.x, cb4[7].x, r0.y, r0.x <br> 19: mul r0.xyz, r0.xxxx, cb4[0].xyzx <br> 20: log r0.xyz, r0.xyzx <br> 21: mul r0.xyz, r0.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 22: exp r0.xyz, r0.xyzx <br> 23: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 24: mul o0.xyz, r0.xyzx, cb2[2].wwww <br> 25: mov o0.w, l(0) <br> 26: ret</code> <br> <br>  Wow!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una cantidad bastante grande, pero de hecho, no todo es tan malo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© est√° pasando aqu√≠? </font><font style="vertical-align: inherit;">Primero, calculamos los UV animados usando el tiempo transcurrido desde cbuffer (cb0 [0] .x) y la escala / compensaciones. </font><font style="vertical-align: inherit;">Estos texcoords se usan para tomar muestras de la textura de ruido (l√≠nea 2). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo recibido el valor de ruido de la textura, interpolamos entre los valores min / max (generalmente 0 y 1). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego hacemos la multiplicaci√≥n, por ejemplo, por la coordenada de la textura V (¬ørecuerda que la coordenada V va de 1 a 0?) - l√≠nea 5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, calculamos la "m√°scara de brillo" - se ve as√≠:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/1a8/801/0641a88012fb6ec18797c0b143fb5f27.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que los objetos distantes (un faro, monta√±as ...) han desaparecido. </font><font style="vertical-align: inherit;">Esto sucedi√≥ porque el cilindro pasa la prueba de profundidad: el cilindro no est√° en el plano lejano y se dibuja sobre estos objetos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/8f5/ffd/1068f5ffde6b0efba2c4894b88d5ddf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prueba de profundidad</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Queremos simular que la cortina de lluvia est√° m√°s lejos (pero no necesariamente en el plano lejano). </font><font style="vertical-align: inherit;">Para hacer esto, calculamos otra m√°scara, la "m√°scara de objetos distantes". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se calcula mediante la siguiente f√≥rmula: </font></font><br><br> <code>farObjectsMask = saturate( (FrustumDepth - CylinderWorldSpaceHeight) * 0.001 );</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0.001 se toma del b√∫fer), lo que nos da la m√°scara deseada:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/02a/153/9ff02a1534054fb27b370d5cd58e7a75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(En la parte sobre el efecto Enfocar, ya expliqu√© superficialmente c√≥mo se extrae la profundidad de la pir√°mide de visibilidad del b√∫fer de profundidad). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personalmente, me parece que este efecto podr√≠a ser menos costoso sin calcular la altura en el espacio mundial multiplicando la profundidad de la pir√°mide de visibilidad por un n√∫mero menor, por ejemplo 0.0004. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando ambas m√°scaras se multiplican, se obtiene la √∫ltima:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/fb2/c1e/c49fb2c1e1dd2ee8d38d81c0cccb0daf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo recibido esta m√°scara final (l√≠nea 16), realizamos otra interpolaci√≥n, que no hace casi nada (al menos en el caso probado), y luego multiplicamos la m√°scara final por el color de las cortinas (l√≠nea 19), realizamos la correcci√≥n gamma (l√≠neas 20 -22) y multiplicaciones finales (23-24). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al final, devolvemos un color con un valor alfa cero. Esto se debe a que la mezcla est√° habilitada en este paso: </font></font><br><br> <code>FinalColor = SourceColor * 1.0 + (1.0 - SourceAlpha) * DestColor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si no comprende bien c√≥mo funciona la mezcla, aqu√≠ hay una breve explicaci√≥n: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SourceColor es la salida RGB del sombreador de p√≠xeles, y DestColor es el color RGB actual del p√≠xel en el objetivo de renderizado . Desde SourceAlpha siempre igual a 0,0, la ecuaci√≥n anterior se reduce a: </font></font><code>FinalColor = SourceColor + DestColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En pocas palabras, aqu√≠ estamos realizando una mezcla aditiva. </font><font style="vertical-align: inherit;">Si el sombreador de p√≠xeles regresa (0, 0, 0), el color seguir√° siendo el mismo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ est√° el c√≥digo HLSL terminado: creo que despu√©s de explicarlo ser√° mucho m√°s f√°cil de entender: </font><font style="vertical-align: inherit;">puedo decir con placer que mi sombreador de p√≠xeles crea el mismo c√≥digo de ensamblador que en el original. </font><font style="vertical-align: inherit;">Espero que hayas disfrutado el art√≠culo. </font><font style="vertical-align: inherit;">Gracias por leer!</font></font><br><br> <code>struct VS_OUTPUT <br> { <br> float3 TexcoordAndWorldspaceHeight : Texcoord0; <br> float4 LODParams : LODParams; // float4(1,1,1,1) <br> float4 PositionH : SV_Position; <br> }; <br> <br> float getFrustumDepth( in float depth ) <br> { <br> // from [1-0] to [0-1] <br> float d = depth * cb12_v22.x + cb12_v22.y; <br> <br> // special coefficents <br> d = d * cb12_v21.x + cb12_v21.y; <br> <br> // return frustum depth <br> return 1.0 / max(d, 1e-4); <br> } <br> <br> float4 EditedShaderPS( in VS_OUTPUT Input ) : SV_Target0 <br> { <br> // * Input from Vertex Shader <br> float2 InputUV = Input.TexcoordAndWorldspaceHeight.xy; <br> float WorldHeight = Input.TexcoordAndWorldspaceHeight.z; <br> float LODParam = Input.LODParams.w; <br> <br> // * Inputs <br> float elapsedTime = cb0_v0.x; <br> float2 uvAnimation = cb4_v5.xy; <br> float2 uvScale = cb4_v4.xy; <br> float minValue = cb4_v2.x; // 0.0 <br> float maxValue = cb4_v3.x; // 1.0 <br> float3 shaftsColor = cb4_v0.rgb; // RGB( 147, 162, 173 ) <br> <br> float3 finalColorFilter = cb2_v2.rgb; // float3( 1.175, 1.296, 1.342 ); <br> float finalEffectIntensity = cb2_v2.w; <br> <br> float2 invViewportSize = cb0_v1.zw; <br> <br> float depthScale = cb4_v6.x; // 0.001 <br> <br> // sample noise <br> float2 uvOffsets = elapsedTime * uvAnimation; <br> float2 uv = InputUV * uvScale + uvOffsets; <br> float disturb = texture0.Sample( sampler0, uv ).x; <br> <br> // * Intensity mask <br> float intensity = saturate( lerp(minValue, maxValue, disturb) ); <br> intensity *= InputUV.y; // transition from (0, 1) <br> intensity *= LODParam; // usually 1.0 <br> intensity *= cb4_v1.x; // 1.0 <br> <br> // Sample depth <br> float2 ScreenUV = Input.PositionH.xy * invViewportSize; <br> float hardwareDepth = texture15.SampleLevel( sampler15, ScreenUV, 0 ).x; <br> float frustumDepth = getFrustumDepth( hardwareDepth ); <br> <br> <br> // * Calculate mask covering distant objects behind cylinder. <br> <br> // Seems that the input really is world-space height (.z component, see vertex shader) <br> float depth = frustumDepth - WorldHeight; <br> float distantObjectsMask = saturate( depth * depthScale ); <br> <br> // * calculate final mask <br> float finalEffectMask = saturate( intensity * distantObjectsMask ); <br> <br> // cb0_v7.y and cb4_v7.x are set to 1.0 so I didn't bother with naming them :) <br> float paramX = finalEffectMask; <br> float paramY = cb0_v7.y * finalEffectMask; <br> float effectAmount = lerp(paramX, paramY, cb4_v7.x); <br> <br> // color of shafts comes from contant buffer <br> float3 effectColor = effectAmount * shaftsColor; <br> <br> // gamma correction <br> effectColor = pow(effectColor, 2.2); <br> <br> // final multiplications <br> effectColor *= finalColorFilter; <br> effectColor *= finalEffectIntensity; <br> <br> // return with zero alpha 'cause the blending used here is: <br> // SourceColor * 1.0 + (1.0 - SrcAlpha) * DestColor <br> return float4( effectColor, 0.0 ); <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437100/">https://habr.com/ru/post/437100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437088/index.html">Promoci√≥n de una startup en el extranjero: c√≥mo llegar a cientos de miles de lectores de habla inglesa con Medium</a></li>
<li><a href="../437092/index.html">La seguridad de los algoritmos de aprendizaje autom√°tico. Ataques de Python</a></li>
<li><a href="../437094/index.html">Bombeamos la mesa de servicio de Atlassian: el anuncio del mitap y la transmisi√≥n en vivo</a></li>
<li><a href="../437096/index.html">UDB Que es esto Parte 4. Datapath ALU</a></li>
<li><a href="../437098/index.html">6 de febrero, Mosc√∫, DI Telegraph - Gran cocina QIWI en dise√±o de producto</a></li>
<li><a href="../437102/index.html">Nuevo campe√≥n de Lego: Lego Boost</a></li>
<li><a href="../437104/index.html">Introscopio: bueno, pruebas unitarias muy flojas</a></li>
<li><a href="../437106/index.html">IT en la zona .it</a></li>
<li><a href="../437108/index.html">La mayor√≠a de los textos en Internet est√°n escritos por locos.</a></li>
<li><a href="../437110/index.html">Los nanomateriales est√°n cambiando nuestro mundo y todav√≠a no tenemos procedimientos para verificar su seguridad.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>