<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚖️ 👩🏼‍🤝‍👨🏿 👩🏼‍⚕️ 混合编程和关于 👼🏿 🕚 🌬️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="辉煌的世纪过去了。 他被替换了 
 诡辩者，经济学家和计算器的年龄； 名望 
 欧洲将永远消失。 
 贝克（英国，1792年） 

 怎么了 
 作为一名程序员生活不短，我问自己：“编程中是否有什么有趣的东西？如果是，那么什么影响最大并留在内存中？” 根据文学才华，答案可能会导致小说，哲学论文，诗歌...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>混合编程和关于</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471184/">  <i>辉煌的世纪过去了。</i>  <i>他被替换了</i> <i><br></i>  <i>诡辩者，经济学家和计算器的年龄；</i>  <i>名望</i> <i><br></i>  <i>欧洲将永远消失。</i> <i><br></i>  <i>贝克（英国，1792年）</i> <br><br><h2> 怎么了 </h2><br> 作为一名程序员生活不短，我问自己：“编程中是否有什么有趣的东西？如果是，那么什么影响最大并留在内存中？” 根据文学才华，答案可能会导致小说，哲学论文，诗歌或笑话。 借助契ov夫的才华，人们可以写出一系列有关普通程序员的灰色/充满活力的生活的故事，在这些生活中，虚拟生活可以杀死/生出一个真正的程序员。 但是契kh夫是程序员吗？ <br><br> 尽我所能，我将自己局限于“沙发冥想”风格的杂文。 尽管全文已有多年，但我仍然冒着风险... <br><br> 现场是明斯克。 <br><a name="habracut"></a><br><h2> 我如何成为一名程序员 </h2><br>  <b>开始</b> 。 从BSU毕业后，他们没有给我们文凭，而是在ACS的第六年就去学习了。 该国需要asushnikami。 想象一下一个知道自己有文凭并打算再学习六个月的学生的天堂生活。 <br><br> 编程从CCK课程开始-Minsk-32机器的符号编码系统。 在一开始，就有一些神秘的基址寄存器。 很久以后，我在汇编器中进行了不错的编程，但是想象一个对编程一无所知的人，并且开始从Assembler（不是从教科书中，而是从一些技术描述中）学习​​编程。 经过一个和谐的物理系统，这是一种废话（我怀疑那确实是废话）。 物理学家的灵魂无法解决这个问题。 然后每天的困难都落在我身上，我几乎没去上课。 总的来说，我并不完全了解SSK。 但是现在该参加考试了。 这次考试的所有五年前，我都为考试做好了坦白的准备。 现在该怎么办？ 在这里，我遇到了一个来自西伯利亚安息日的朋友（我以他开朗的性格记得他，而且我们去西伯利亚的那三天里，笑话都在昼夜讲故事）。 他因喝啤酒而悲伤。 快速而大胆地找到了解决方案-他通过了我的一瓶伏特加酒考试（此事因没有多余的标记而变得容易）。 一切都交给了奥基。 <br><br> 试图找借口。  “我不是唯一应受责备的人。” 有罪和老师。 教学质量在很多方面令人恶心。 一位老师表示，与使用OS / 360系统的IBM Minsk-32计算机相比，IBM的优势在于，IBM仅使用8位（字节）工作，而Minsk-32则是后者的四倍-32（字）。 而且，看来Minsk-32比IBM计算机好四倍。 原来，这仅适用于寻址。 这一切完全相反。 <br><br> 但是，所描述的情况不仅是编程的特征。 在BSU物理系的第四年，教授了“量子场论”学科一年。 整整一年，我们都没有听到关于她的任何消息，但是我们展示了一位教师学者的研究结果，该结果与他最初对洛伦兹小组的参数化有关。 这可能很重要，但是基本物理学的基本装置的量子场论在哪里？ 顺便说一句，在我看来，任何小组都可以通过无数种方法来参数化，并且每种方法都有其优势。 你能想象你可以写多少篇论文！ 由于白俄罗斯共和国有几所大学，我对其教育质量的怀疑甚至更大。 如果没有足够的一位教师，那么不清楚将他们刮到几位。 具有“质量”的专家不得不在以后见面。 例如，在非政府组织Agat中。 一位理学博士以这种方式提高了我们的资格：他假设“ ...向量a大于向量b ...”得出了很好的结论。 但是载体是无序的：没有人确定它们的比率。 第二个隐式使用错误的比率“乘积之和等于乘积之和： <math> </math> $ inline $ ∑_i∏_ja（i，j）= ∏_j∑_ia（i，j）$内联$   。 由此他收到了很多后果。 尽管他承认了错误，但由于某种原因他认为后果是正确的（“我需要它，所以它是正确的”）。 接下来的情况通常是病理性的。 无线电工程师正在考虑电磁场的电矢量。 一般来说，它旋转。 记住牛顿的力学原理，无线电工程师介绍了作用在电场矢量末端的离心力，并从此处发展了整个理论，驳斥了Gonorovsky（显然是无线电工程领域的权威）。 <br><br> 然而，回到编程，我不喜欢编程，但是我对它充满敬意。 但这是最好的老师的优点-生活。 <br><br>  <b>待续</b> 。 但是生活需要我们为诡计报仇。 我将自己分配给物理研究所，并开始在公理量子场论领域（Wow！）紧张。 但是他很快意识到，手中只有86卢布，其中有30卢布用于公寓，公理量子场论并不太适合自己，“如何生活？”的问题越来越多。 结论：“你不能那样生活。” 顺便说一句，我三岁的同学担任Integral的调解员，获得的BSU文凭是我的三倍。 那么你如何生活呢？ 在这里，啤酒杯再次提供帮助。 在与女友的一次会面中，我结识了中央电信与信息科学研究院所长-在女士们的陪伴下，我们的男人毕竟在谈论工作。 所以他告诉我他在做什么，在我看来我可以成为一个好的任务经理。 毕竟，设定目标不是解决目标，不是吗？ 我在这里是中央技术研究院。 虽然，a，不是导演，而是新手程序员。 但是“高”物理学呢？ 我安慰自己，我将从事“高级”编程-各种科学计算。 最主要的是远离会计的所有借方和贷方。 簿记和银行业务是繁琐的象征，并希望远离它们。 但是生活固执地将我们的贪婪推向了现实。 实际上，后来必须处理的只是借方和贷方。 这是从夸克到会计程序的演变。 是的，必须对会计进行编程。 毕竟，“社会主义是会计和控制”。 好吧，由于控制权已经被占用（该党控制了我们国家的一切），所以我们不得不处理会计。 <br><br> 道德  <b>我们不仅爱不了解的科学。</b> 您需要了解基础，对主题的尊重是对基本原理的理解，当然，如果是基础知识的话。 <br><br><h2> 什么是编程和数学的主要问题 </h2><br> 有这么一个乏味的问题-问“什么是编程？”，“什么是物理学？”，“什么是数学？”。 对此类问题可能没有确切答案。 自然不会将世界划分为物理学，化学等。因此，科学之间的界限是任意的。 他们不是天生的，而是人。 顺便说一句，恩格斯似乎说，最终将有两门科学-物理学和心理学（物质和意识）。 一位物理学家对“那么什么是物理学？”这个问题感到愤怒。 他这样回答：“物理学就是物理学家的工作。” 这是完全严重的。 <br><br> 那程序员怎么办？ 他们活动的实质是什么？ 在我看来，程序员的主要职业是将大的未解决问题呈现为解决的小问题的组成。 这种组合是从过渡到解决的方法。 用给定的正式语言编写的此路径称为程序。 然后，文字应该是给定形式语言的文字-这就是程序。 该算法的形式-文本实施例是编程的，并且不同于其他构造学科。 因此，有<b>两个编程功能：1）极高的结构性2）严格的语法框架</b> 。 <br><br> 由于编程是一门建设性的学科，因此对他而言，是否有解决方案并不是那么有趣，而是解决方案本身。 在数学中，存在的许多定理都声称存在一个解决方案，但是却没有说明如何找到它。 诺贝尔物理学家兰道（Landau）提议从物理学家的数学历程中删除关于存在定理的任何提及。 物理学家知道微分方程有解的用途是什么。 您需要知道解决方案，而不是解决方案。 仅在“是否有解决方案？”主题上 关于兰道有一个有趣的故事。 当物理学家去某个地方参加聚会时，他们沿路很有趣，因为观察前面汽车前面的四位数数字，有必要尽快地识别数字中的模式，仅使用基本的（学校动作），而无需重新排列数字并仅使用一次。 例如，对于数字73-85，我们有7-3 = 8-5，对于数字38-53，我们有 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.111em; margin-right: 0.111em;">∛</span></span><span class="MJXp-mn" id="MJXp-Span-30">8</span><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-32">5</span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-34">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2">∛8= 5-3 </script>  。 兰道在这件事上是一个伟大的权威。 提出了一个问题，即是否可以找到任何数字，这是存在定理的问题。 兰道回答：“不，不适合任何人。”  “为什么，兰道，你证明了不存在定理！？”  “嗯，不，仅仅是因为我兰道（Landau）找不到任何数字的这种模式。 例如，对于数字75-65”。 精巧。 但是，其中一位年轻的数学家绝对认真地对待了存在定理，并证明了任何整数都可以“等于”另一个定理，因为存在将N +1简化为N的公式： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-35"><span class="MJXp-mrow" id="MJXp-Span-36"><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0.111em; margin-right: 0.111em;">√</span></span><span class="MJXp-mrow" id="MJXp-Span-38"><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">N</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-42">1</span><span class="MJXp-mrow" id="MJXp-Span-43"><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-46"><span class="MJXp-mo" id="MJXp-Span-47" style="margin-left: 0.278em; margin-right: 0.278em;">秒</span></span><span class="MJXp-mrow" id="MJXp-Span-48"><span class="MJXp-mo" id="MJXp-Span-49" style="margin-left: 0em; margin-right: 0em;"></span></span><span class="MJXp-mrow" id="MJXp-Span-50"><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">g</span><span class="MJXp-mrow" id="MJXp-Span-57"><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mrow" id="MJXp-Span-59"><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0.111em; margin-right: 0.111em;">√</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">N</span><span class="MJXp-mrow" id="MJXp-Span-62"><span class="MJXp-mo" id="MJXp-Span-63" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-64"><span class="MJXp-mo" id="MJXp-Span-65" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3">√（N + 1）=秒⁡（arctg（√N））</script><br>  las，在证明存在性定理后，游戏失去了清晰度。 这里是：“ <b>知识越多，悲伤就越多</b> 。 <b>”</b> <br><br> 设计解决方案分为两个阶段： <br><br><ol><li> 算法化。 问题的算法化-减少人们理解的标准操作的组成。 这是最重要的部分。 毕竟，程序是为人们编写的。 </li><li> 编码。 将算法简化为基本给定操作和数据的组合-编程语言中的短语。 但是，最小程序的编写要经历其微算法化的阶段。 </li></ol><br><h3> 私人建设性问题的例子 </h3><br> 允许的操作集是指由指南针和标尺执行的学校操作：建立连接两个给定点的线段，将线段分成两半，建立垂直线，提取平方根... <br><br> 以下是经典的建筑问题： <br><br>  <b>圆的平方</b> 。 给定一个圆，您需要使用<b>有限数量的上述操作</b>来构建一个面积等于给定圆的面积的正方形。 <br><br>  <b>三等分的角度</b> 。 使用有限数量的上述操作，给定角度必须分为三个相等的部分 <br><br> 然后，这里的“到达存在性定理的线-立即给我们解决方案”的做法令人失望。  <b>假定有解决方案，它已经寻求了许多世纪。</b>  <b>但是事实证明，没有解决方案。</b> <br><br> 许多数学家和业余爱好者都在为完成这些任务而苦苦挣扎（小时候，我提出了解决方差问题的方法，结果证明它的近似度约为10％，但是在我青年时代就已经清楚了）。 提出了许多解决方案，但事实证明它们都是近似的。 在19世纪，事实证明任务没有解决方案。 对于角度的三等分，现在可以将其显示给学生（例如，参见Courant和Robbins的书“什么是数学”），并为学生平方圆。 而且，这种情况使得可以任意精确地找到近似值，但是没有精确的解决方案。 如果您考虑一下，结果是奇怪的。 仿佛在所需正方形的前面，有一面墙无法克服。 但是，随着解决方案变得基本，还值得允许其他操作。 这是由阿基米德针对角度的三等分完成的。 <br><br><h3> 算法概念的形式化 </h3><br> 直观上讲，什么是算法。 但是，如果数学家们不对算法的概念进行形式化，他们就不会是数学家。 直觉屡屡失败。 因此，不可能相信存在连续函数，这些函数在任何地方（无论您触碰曲线的任何地方）或荆棘丛都没有导数。 直觉不允许这样做。 <br><br> 提出了几种学习算法概念（或科学地讲解）的表述：递归函数，马尔可夫字母替换，Post机器，Turing机器。 这些配方的等效性逐渐得到证明。 最后，数学家认为这些公式足以满足算法概念的要求是公理，这就是丘奇的论文。 就其而言，图灵机接近于真实的计算机。 模拟它是基本的，但是由于它们的原始性和缓慢性，因此不需要这些模型。 但是作为一种理论手段，它是必不可少的。 例如，可以将算法复杂性的概念形式化。 然后又出现了令人惊奇的事情。 因此，程序员的直觉表明乘法比乘法困难。 将数字a乘以数字n意味着进行n次加法。 因此，乘法似乎要复杂几倍。 该理论有什么作用？ <br><br> 假设有两个n位数字，图灵机将它们乘以U（n），再将其乘以S（n）。 直觉表明U（n））/（S（n）→∞，但是理论分析表明，对于任意小的ε，我们都有 <math> </math> $ inline $ U（n））/ [S（n）（S（n））^ε]→0 $ inline $   。 这表明与乘法相比，加法已经没有什么了-它们的复杂度非常接近。 <br><br> 任何建设性的问题都可以用对通用图灵机进行编程来表示。 问题出现了：是否<b>有可能为任何建设性问题找到通用算法</b> ？ 这里的问题已经与圆的正交类型的陈述完全不同。 可以添加新的允许的构造操作，从而解决了问题。 通用图灵机没有什么可添加的-这是最通用的机器，它可以实现任何算法。 事实证明，即使在这里，创作者也会遇到障碍。 发现许多建设性的问题，没有共同的算法来解决。 例如，在数学逻辑中，他们长时间尝试寻找一种算法，通过该算法可以确定一个逻辑表达式是否可从另一个逻辑表达式推导。 原来，问题没有解决。 <br><br> 费马大定理也有类似的情况： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-msubsup" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-94" style="vertical-align: 0.5em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-95" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97" style="margin-right: 0.05em;">y</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-98" style="vertical-align: 0.5em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-99" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101" style="margin-right: 0.05em;">z</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-102" style="vertical-align: 0.5em;">n</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> x ^ n + y ^ n = z ^ n </script> 对于n&gt; 2，没有整数解。 <br><br> 可以给这个陈述一个我想说的字符，“这不可能。” <br> 除以右边，我们传递给有理数：等式 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-msubsup" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105" style="margin-right: 0.05em;">p</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-106" style="vertical-align: 0.5em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-107" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109" style="margin-right: 0.05em;">q</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-110" style="vertical-align: 0.5em;">n</span></span><span class="MJXp-mo" id="MJXp-Span-111" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-112">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> p ^ n + q ^ n = 1 </script> 没有有理数&lt;&gt; 0的解。 <br><br> 此外，我们将自己限制为甚至n。 对于他们，我们有一张照片： <br><br><img src="https://habrastorage.org/webt/ey/is/eg/eyisegtteiqh3cwvg3atsuuiq4s.jpeg"><br><br> 该图显示了n = 2（圆形）和n =无穷大（正方形）时的费马曲线。 对于n = 2k&gt; 2，所有其他曲线都位于圆和正方形之间，并且随着n的增加，它们越来越接近正方形。 而且，如果采用所有这些曲线，它们将越来越多地填充正方形周围的空间。 并且有无数个有理坐标的点，因此，如果所有有理点都被涂成深色，则正方形的整个空间将为黑色-有理坐标的点集到处都是稠密的。 但是，费马曲线中没有一条曲线通过有理点。 似乎为此，您需要疯狂循环。 但是，费马定理说，一条完美平滑的曲线不会通过任何有理点。 好吧，这是不可能相信的。 这里出了点问题。 <br> 所有数学中都存在类似情况。 这对于数学问题和数学上的处理都是很好的。 例如，假设找到数学问题“ If A，then B”的解决方案，这是数学对象在一定空间中从原始数据到所需数据的运动。 这是从A到B的建设性路径的示例： <br><br><img src="https://habrastorage.org/webt/fn/al/p4/fnalp47yicy6tr_3-bnoke0ketm.jpeg"><br><br> 沿路径移动时，仅使用算术公理。 <br><br> 对于任何定理“如果A，那么B”，就可以通过构造方法构造从A到B的轨迹。这将是数学的一次胜利。 能做到吗？ 有这样的轨迹吗？ <br><br> 伟大的数学家希尔伯特（被20世纪许多伟大的数学家认为）热情地开始实施莱布尼兹（Leibniz）程序-将任何数学问题形式化，算法化。 该程序称为数学形式化-为所有数学提供公理基础，作为公理的结果以形式语言表达所有数学问题，并根据数学逻辑规则推导出所有定理。 为了使数学完全正规化，已经进行了大量工作。 那些愿意的人可以看到希尔伯特和伯奈斯撰写的两本厚厚的《数学基础》。 但是在工作的中间出现了库尔特·哥德尔的著作，除其他外，他证明了在任何包含算术的形式理论中，人们都可以陈述一个不可推论的有意义的定理。 并且她（或者在没有任何理由的情况下否认她）可以被视为一种新的公理。 我们提请注意“正式”一词。 对于非正式理论，您总是可以说“很明显……”之类的话，所有障碍都会被消除。 因此，戈德尔定理在非正式理论上的任何应用都是不正确的。 对于喜欢推测这个话题的哲学来说尤其如此。 <br><br> 因此， <b>格式</b>数学明显不完整，并且永远无法完成。 这使她与物理学有关，由于其自​​然位置，它从未声称过形式化（而且形式化的精神与物理学是异类的，后者习惯于所有公理都是暂时性的事实）。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">似乎可以通过将不可约定理（或它的否定）作为一个公理来摆脱情况，将其添加到原始的公理体系中，并从这一扩展的形式系统中推导出推论。但是，哥德尔定理适用于这种扩展的形式系统。我们得到了无尽的过程。只有在无限的系统中才能找到普遍性。但是如何使用一组无限的公理呢？最无害的公理会带来完全出乎意料的后果，这使事情变得复杂。例如，采用选择的公理：如果给出了一组不相交的集合，则可以从每个集合中选择一个元素并将它们组合成一个集合。似乎有些争论。但是使用选择公理，Banach和Tarski证明了可以将不同半径的两个球面S1和S2分为相同数量的成对不相交集：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S1 = A1 + A2 + ... + An且S2 = B1 + B2 + ... Bn，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此对于所有i：Ai = Bi。因此，不相等的球体被分成相同的部分。这是什么废话但是一切都是合乎逻辑的，要相信什么，要拒绝什么？一次添加一个，我们得到一个球体，而另一个得到一个大球体。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约翰·冯·诺伊曼（John von Neumann）使用选择的公理证明，具有有限分隔线的线段A小于线段B的长度，线段B的长度小于其长度。因此，请相信这个数学。如果我们接受无害的选择公理（并且比可以从第一堂课选出一名学生，从第二堂课选出一名学生，等等更明显的事实），那么将获得完全矛盾的结果。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，冯·诺伊曼（von Neumann）在编程方面也出类拔萃-他证明了自动机自我复制的可能性，而冯·诺依曼的计算机体系结构也源于他。他在数学和量子物理学两方面都出类拔萃-他基于希尔伯特空间的概念建立了量子物理学的数学仪器，并试图证明爱因斯坦所依赖的隐藏参数的可能性，认为量子理论是不完整的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，回到较高的绘图，我们感到遗憾的是，我们无法通过建设性的手段来构建所指示的普遍轨迹。 las！这意味着数学比看起来更复杂。您可以随意在解决方案附近徘徊，但是永远不要坚持。这是一般数学问题的“正交”。但是，不像平方圆，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在任何建设性操作的扩展下，它都没有解决方案</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您只能编写相当私人的任务。最常见的问题没有建设性的解决方案。而且，即使许多特殊问题也没有共同的建设性解决方案，因此，需要将它们分为甚至可能具有建设性解决方案的更具体的问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回到戈德尔定理，我们注意到编程语言是一种形式系统。因此，您可以编写一个没有任何程序证明其正确性或不正确性的程序。真的是这样吗书面的程序或其取反可以作为编程的公理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，不可能有程序的通用验证。而且不可能有通用程序。好吧，尽管一般来说不可能有一个通用程序，但是至少要针对特定​​主题领域获得通用程序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个典型的程序映像：</font></font><br><br><img src="https://habrastorage.org/webt/tx/ka/bf/txkabfgztlxlsdqxm43tkleyrga.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种方法的缺点是它会被特定的功能所锐化。当然，您可以对其进行参数化。通过此参数化，函数的类型不会更改，而仅其参数参数会更改。但我希望参数能够更改函数的类型。是的，您可以将函数作为参数传递-例如，函数集成程序。但这并不仅仅是整合。简而言之，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最好将主题区域的完整描述作为参数</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是我想要的：</font></font><br><br><img src="https://habrastorage.org/webt/rm/vo/-j/rmvo-j2zjxvs1zsjwgkjzw4y1rm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">爸！ -但这是Prologe上的程序。 Prolog本身充当上述参数函数。域说明-对域进行编码的序言。目标是一个参数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我尝试在Prolog上的许多关系上实施搜索任务时，我感到非常惊讶。该搜索首先在Delphi中实现，然后在C＃中实现。因此，在Prologe上由Delphi（C＃）中的几个相当大的程序实现的内容适合它们之间关系和功能的紧凑描述。然后，可以针对此描述请求各种目标请求。没错，我不能说比较性能。但是在一些具体示例中，我没有发现明显的不同。但是，Delphi仍然绘制了目标关系的漂亮图表。我没有在Prologe上这样做。但是对每个人自己。逻辑必须通过逻辑语言，演示文稿-演示文稿语言，报告-报告语言，输入-输入语言，通讯-通讯语言，服务交互-分发语言，服务的交互和协调。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 经典版 </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 旧经典 </font></font></h3><br>  “经典作品需要了解和尊重。” 无需以为一切都是在本世纪发明的。  “月球下什么都没有。” 这对于编程及其基本概念都是适用的。 顺便说一句，“算法”一词本身起源于九世纪，源于数学家al-Khwarizmi的名字。 欧几里得算法的许多构造。 因此，他找到最大公约数的算法仍然有效。 卢利（穆斯林向他投掷石块-这是宗教的“进步”角色）在13世纪提出了一种逻辑机器，它使用符号进行操作的想法。 在达芬奇（Leonardo da Vinci）的手稿中，发现了一个十三位数的计算设备的图纸。  （但是，在他的手稿中只发现了很多，有些学者认真地声称达芬奇不是人，而是外星人。） <br><br>  1623年，图林大学语言教授（!!）Schickard设计了一台计算机。 大帕斯卡（Great Pascal）对机械计算机有了清晰的构想，并制造了机械测速仪。 伟大的莱布尼兹（Leibniz）提出了对陈述进行数字化处理的想法，以将争端减少到一个计算中。 “如果我能同时使用一台机器，”莱布尼兹说，他做了一台计算机，梦想着一个可以计算一切的通用机器。 <br><br>  19世纪的Bebbage设计并开始制造<b>通用的可编程机械机器</b> 。 这是第一台通用计算机。 巴贝基有些不该被遗忘，所以我无法抗拒，我将引述一些有关他的有趣事实。 <br><br>  “我们相信，这种设备的存在，除了在执行算术运算时节省劳力外，还将使很多可行的事情变得可行，而这些事情太接近人类的能力极限，”英国巴贝奇分析机研究科学促进会的报告说。 <br><br> 如果您遵循现代术语-巴贝奇是“物理学家”。 他不喜欢音乐。 在歌剧中，他想出了彩色音乐。 关于坦尼森的诗 <br><br>  <i>“一个人每分钟都死去，</i> <i><br></i>  <i>但是一个人每一分钟出生</i> <br><br> 巴贝奇给作者写了以下信：“我必须认真地向您指出，这些计算得出的结论是总人口处于恒定均衡状态。 同时，众所周知，提到的数量在不断增加。 因此，我冒昧地假设，在下一版您的出色诗中，我指出的错误计算将按以下方式纠正： <br><br>  <i>人死的每一刻</i> <i><br></i>  <i>但是1.16人出生了...</i> <br><br> 我可以告诉您一个更准确的数字-1.167，但这当然应该违背诗句的节奏……” <br><br> 尽管如此，巴贝奇还是打算研究幽默的本质。 他是典型的思想产生者。 由于想法过多，他没有完成他的众多建议和项目。 发明了速度计，创建了横刨和旋转的机器，模具，刀具，并提出了一种在木材上雕刻的方法。 一般来说，这是英语的达芬奇。  1832年，他写了一本书《机器与生产的经济学》，其中他预期进行系统分析，运筹学和科学的劳动力组织。 马克思非常了解这本书，并在《资本论》中引用了它，凯恩斯对此赞叹不已。 但是最重​​要的发明是分析机，它是通用的可编程机械计算机。 国家的钱不够用，巴贝奇（Babbage）花了他的钱来造汽车。 寻找金钱的各种来源。  Ada Lovelace和他的搭档一起为赛马提供了一个“双赢系统”。 该制度导致了这位女士必须用家庭珍珠来付款的事实。 然后，巴贝奇计划写一本小说，并把所得花在汽车上。 从他的生意劝说他的朋友。 然后不知疲倦的巴贝奇计划用井字游戏机充斥整个国家，然后将收益再次投入汽车。 但是为此需要金钱。 <br><br> 街头音乐家干涉了他的表演。 通过新闻界，议会的通缉令，警察正在与他们作战。 作为回应，每个酒鬼都认为在巴贝奇的窗户下大喊大叫是他的责任，音乐家们已经从远方开始在他的窗户下找乐子。 巴贝奇（Babbage）死后，《泰晤士报》（Times）的ob告台词如下：“ ...尽管街头音乐家受到迫害，但他活到80岁左右。” 我不知道当现代街头音乐家配备大得多的分贝时，他现在会住多少年？ <br><br> 巴贝奇（Babbage）提出了有效应对火灾的计划后，却说：“我不会公开它，它们将全部丢失，将其所有房屋烧毁。” 我讨厌虔诚 当他在意大利看到一个水泵时，上面刻有铭文，上面写着主人以对上帝和他的国家的爱的名义建造这台水泵，以便疲倦的流浪者能解渴，然后巴贝奇警惕着，检查水泵，发现每次旅行的人抽水，大部分掉进了虔诚的主人家。 在这集之后，巴贝奇补充说：“ <b>除了敬虔之外，我唯一讨厌的就是爱国主义。</b> ” <br><br> 巴贝奇分析机的第一个程序员是诗人拜伦·阿达的女儿。 这是她的一些声明。 <br><br>  “ <b>分析机可以定义为具有任何程度的通用性或复杂性的任何不确定函数的重要体现</b> ”！ <br>  “在考虑任何新发明时，我们经常会尝试高估我们已经认为有趣或什至杰出的事物，另一方面，当我们发现我们的新思想取代了我们认为不可动摇的思想时，就低估了事情的真实状态。” <br><br>  Ada创造了术语“工作单元”，“循环”。 因此，五角大楼使用的编程语言“ Ada”就得了一个好名字。 <br><br> 巴贝奇更是物理学家，而不是数学家。 他对通用计算器的实际体现很感兴趣。 当数学家开始工作时，他们一如既往地希望形式化通用计算器的概念。 毕竟，机器的非正式概念是一回事，而确切的概念是另一回事。 最后，正如我们所看到的，直觉和形式主义是不同的。 马可夫·丘奇（Church），马可夫（Markov）是最早将算法概念形式化的人。 第一个作为递归函数，第二个作为字母表中的一组排列即语法。 图灵几乎用技术术语形式化了算法的概念-它是图灵机。 <br><br> 通用图灵机在理论上等同于通用计算机-计算机。 事实证明，有足够的语言包含两个字符（|和一个空格），四个命令和无限的外部存储器-任何算法都可以在通用图灵机上编程。 证明算法的上述所有三个定义都是等效的-在一个定义中表示的将在其他定义中表示。 图灵的优点反映在图灵最佳编程成就奖的存在上。 顺便说一句，图灵提出了所谓的图灵测试-一种区分人与计算机的测试。 这是一项纯粹的<u>功能测试，没有任何神秘的物质，例如人类的灵魂</u> 。 如果某人坐在一个房间里，并且一台机器通过显示屏在另一房间里与他们通信，并且很长一段时间我们无法确定该人在哪里，机器在哪里，那么该机器在智力上就等同于该人，因此无需讨论哪个制造和如何。 这不是必需的。 <br><br> 早已提到的冯·诺伊曼（von Neumann）纯粹从理论上证明了自动机自我复制的可能性。 顺便说一下，这个功能是在实践中实现的。 <br><br><h2> 古典文学 </h2><br> 文字放在巴比伦的一幅平板电脑上：“艰难的时刻到了，众神变得愤怒，孩子们不再服从父母，每个人都想写一本书。” 大量的书籍已经阅读，一半阅读。 但是它们对我来说至关重要。 哪一个 在我开展IT活动之初，这些活动是： <br><br>  <b>布鲁克斯</b>  <b>如何设计和编程软件系统</b> <br> 关于大型项目所面临问题的经典著作。 <br>  <b>达尔，迪克斯特拉，霍尔。</b>  <b>结构程序设计</b> 。 <br> 它标志着编程新时代的开始。 您对如何看待普通程序感到惊讶和惊奇。 它包含许多哲学观点。 <br>  <b>迪克斯特拉。</b>  <b>编程学科。</b> <br> 绝对很棒的书。 在我青年时期，我在上面度过了两个假期。  las，我无法向自己保证我了解一切。 当我遇到试图用自己的才智发光的程序员时，我让他们读了这本书。 他们有些尴尬地把她还给了她。 对“关于Algol-68的修订报告”也有类似的反应（正如当局之一对Algol-68所说的那样-“这是一种针对程序员和诗人的语言”） <br>  <b>威斯</b>  <b>系统编程。</b> <br> 阅读的第一本书表明编程指南可能是不错的。 <br>  <b>尤丹</b>  <b>结构程序设计</b> 。 <br> 最主要的是要注意一个时尚的话题。 但是这里不合时宜。 <br>  <b>格里斯</b>  <b>编程科学</b> <br>  “如果我们考虑Dijkstra（编程学科）的重要著作的智力启示，那么Gris的著作就是使徒行径”（Ershov）。 <br>  <b>Aho，Hopcroft，Ullman。</b>  <b>计算算法的构建与分析</b> <br> 与现代单日读物（例如“ 21秒，一分钟……内的C + +”）的对等关系包括对重要的快速算法的阐述，这些算法不会长期消失。 <br>  <b>游览。</b>  <b>编程方法</b> <br> 关于小型编程和大型编程，有很多有趣的注释。 <br>  <b>库什尼连科。</b>  <b>数学家编程</b> <br> 出色的教程，具有高水平的介绍。 <br><br> 在我积极的编程过程中，几乎没有东西可以添加到此列表中。 从那时起，已经过去了很多时间。 但是即使到现在，编程技术还没有诸如物理学之类的基础知识作为技术基础。 这种情况类似于中世纪的技术状态，当时它没有物理学形式的科学依据。 然后出现永动机的项目。 <br><br><h2> 杂项 </h2><br><h3> 神话 </h3><br>  <b>任何人都可以编程</b> 。 因此，引用莎士比亚的话说：“ <i>我可以从深渊召唤灵魂，我可以并且每个人都可以，唯一的问题是他们是否去参加电话会议</i> 。” 与任何专业活动一样，编程也需要一定的才能和能力。 在我看来，并非所有程序员都可以编程。 在自己解决基本的应用程序任务之前，有可能对Windows NT有所了解并且无能为力。 <br><br> 每个人都可以用他们的母语写作，但是没有那么多好的作家。 这也适用于以编程语言编写。 <br><br>  <b>记帐的任务易于编写且无趣，但是创建网页却既困难又有趣。</b> <br><br> 第一和第二都可以改变。 最主要的是：他们说，日常任务很容易实现，因此您不应该特别去做。 只有各种各样的昆士提基值得关注。 但是，以我的观点，只有程序员说，而没有创建一个像样的项目。 这就像是一种音乐概念，就像时髦的耳机一样，很多耳机的音乐爱好者在其中徘徊，并且对某种神秘的事物有某种特殊的参与。 我本人曾经向程序员势利致敬。 显然，任何程序员都要经历“我什么都知道，我能做的一切”的阶段。 但是对于大多数人来说，它不会持续很长时间。 <br><br> 这种情绪可能来自“高”方面。 在一家公司里，我遇到了一位来自Fiztekh的程序员，他曾经为弹道导弹飞行编程。 我们开始讨论在银行中使用数学的问题。 他立即带给我很多页面，其中包含银行活动的一部分的数学模型-带有延迟（!!）的微分方程（延迟来自利息-今天发放的贷款在一段时间后获利-就是延迟）。 事实证明，他从银行的利润功能开始，然后应用了众所周知的数学方法。 但是任务就是找到此功能。 但是在数学家-程序员看来，这是任何银行家都可以应付的琐事，但银行家将无法进一步积累一堆公式。 第二个是正确的，但第一个不是。 这就是重点。 不仅需要数学，还需要数学。 否则，这仅仅是公式的学术性。 顺便说一句，利润函数肯定会是不连续的函数（几乎所有经济指标都是不连续的，例如汇率），因此连续经典方法不适用于它-例如Pontryagin最大原理。 <br><br>  <b>给我一台足够强大的计算机，我将破解所有代码</b> 。 许多程序员会沙哑地确保任何代码都可以被黑客入侵。 只提供一台足够强大的计算机。 在我看来，这是对香农提出的信息论基础的无知。 一切都非常简单。 将噪声视为已编码的消息。 任何东西都可以从噪音中提取出来。 它不能以任何方式解码-提取有用的东西。 否则，这不是噪音。 叠加在消息上的噪音会发出噪音。 因此，让我们在消息上添加噪声：噪声（W）+消息（C）=噪声1（1）。 噪声1无法解密。 当然，通过详尽搜索，您可以找到消息的底部。 但是您怎么知道这是正确的信息。 让我们收到“ Petya是个傻瓜”的信息。 完整搜索将提取此消息，但还将提取以下消息：“ Petya是一个聪明的人”和“ Vasya是一个傻瓜”，等等。 那么拿哪一个呢？ <br><br> 但是您仍然可以提取消息。 为此，您需要了解噪声和叠加方法。 然后=1-。 但这不需要超级计算机，但是您需要知道噪音。 <br><br> 顺便说一句，在美国和俄罗斯总统之间的对话中似乎也采用了类似的方案。 <br><br>  <b>程序员不需要数学</b> <br><br> 围绕编程，人文美学开始挣扎。 嗯，程序员如何在没有审美的情况下绘制漂亮的网页，以及如何在没有GUI界面的情况下相处融洽。 和嫁接出现。 而且似乎开始他们是程序员。 <br><br> 在我看来，作为物理学家，如果没有数学就很痛苦，如果没有数学知识，程序员也就痛苦而荒谬。 充其量是个工匠。 您可以了解操作系统的每个选项，如何安装各种驱动程序而无法开发基本项目。 在技​​术上，这是一个熟悉的情况。 有工程师，有工人。 您可以成为出色的汽车设计者，并且驾驶不善，或者您可以成为赛车手，而不是理解发动机的原则。 <br><br><h2> 原则 </h2><br> 哪些一般规定给您留下了深刻的印象？ <br><br>  <b>分而治之</b> <br><br> 最有用的原则。 任何任务都需要能够分成几个简单的任务，以便子任务可以被解决和合并，从而获得原始问题的解决方案。 关于获得的子任务，可以做同样的事情。 依此类推。 在许多方面，分割的技巧是找到算法的技巧。 示例缺少数字：快速排序将排序后的集合分为两部分，二进制搜索将搜索后的集合分为两部分。 <br><br>  <b>丑陋但统一</b> <br><br> 不要创造不必要的变化。 它只会增加熵。 接受统一标准并坚定不移地遵守。 这适用于名称，缩写，编码样式。 <br><br> 在这方面，令人惊讶的是，没有推动系统的必要语言构造。 用于开发DBMS应用程序本身的最先进的工具是基于文件方法的。 以及如何以数据库的形式呈现项目并将搜索和选择设备应用于该项目会更加方便... <br><br>  <b>语言定义思维</b> <br><br> 通过将自己限制在某些句法结构上，我们甚至不怀疑我们如何限制思维。 如果没有数学符号，微分算术将是什么？ 没有Backus-Naur形式主义或与之等效的编程语言的语法是什么？ <br><br>  <b>程序=算法+数据</b> <br><br> 在面向对象的方法中，此位置扩展到基本构造-由数据和方法组成的对象。 程序首先在算法的标志下开发，然后是数据。 主题DBMS完全位于“数据”标题下。 但是算法也很流行-搜索方法，索引方法。 <br><br>  <b>为主题领域建模</b> <br><br> 言语模型产生了主题领域的想法，IT专家可以访问并包含最基本的主题。  “实体-通信”类型的信息模型生成数据库。 功能模型“模块M在输入In接收并将其转换为Out”定义了程序的体系结构。 对象模型将主题区域表示为一组交互对象。 事件模型有助于将系统的运动描述为对某些事件的响应变化。 <br><br><h2> 一些任务 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些让我印象深刻的任务。</font><font style="vertical-align: inherit;">当然，我仅列举一些小任务。</font><font style="vertical-align: inherit;">坚持类型，很难简单说出大任务。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">咖啡豆问题</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该银行有一定数量的黑白咖啡豆，并且免费供应咖啡豆。</font><font style="vertical-align: inherit;">从罐头中随机选择两个谷物。</font><font style="vertical-align: inherit;">如果它们是相同的颜色，则将它们放入库存中，然后将黑色谷物放入库中。</font><font style="vertical-align: inherit;">如果它们的颜色不同，则退还白色的谷物，然后将黑色的谷物放入库存中。</font><font style="vertical-align: inherit;">继续该过程，直到有五谷为止。</font><font style="vertical-align: inherit;">它会是什么颜色？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方法。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该过程显然是周期性的：重复执行“取出并放入”操作</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环的不变性是白色颗粒数量的奇偶性。因此，如果白色颗粒的初始数量为偶数，则最后一个颗粒将为黑色；如果为奇数，则白色。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手册上</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有三个很长的文件：工人r，学生s，失业b。它们按名称排序。众所周知，有一些流氓学生在工作，并在失业者名单上，因此，他们可获得失业救济。编写一个程序，查找第一个这样的流氓-名称按字母顺序第一个的流氓。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方法。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令i，j，k为文件r，s，b中的坐标</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I，j，k：= 0,0,0; -从头开始</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止（r（i）&lt;&gt; s（j）和s（j）&lt;&gt; b（k）和b（k）&lt;&gt; r（i））重复从头</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果r（i）&lt;s（j ）然后i：= i + 1; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果s（i）&lt;b（j），则j：= j + 1;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果b（i）&lt;r（j），则k：= k + 1; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i，j，k在其文件中包含流氓坐标。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是用Dijkstra的符号看起来很优雅：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i，j，k：= 0,0,0; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R（I）&lt;S（j）的i：ⅰ+ 1 =; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S（j）&lt;B（k）j：= j + 1; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B（k）&lt;R（i）k：= k + 1; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">od </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{i，j，k是所需的坐标} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中符号表示所谓的防护（R（i）&lt;S（j），等等。）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可惜的是，该符号未包含在语言中。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">火车上厕所的寓言</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从前，有一个国家，每个马车都是用厕所制造的。但是随后，一位经济学家出现了，并决定为一半的货车提供厕所来省钱。于是他们开始做。但是他们忘了警告火车开往的分拣站。结果，一些火车最终没有厕所。为了纠正这种情况，每节车厢上都刻有题字，上面写着是否有厕所，并指示车钩：“火车上应该有大约一半的厕所。”尽管这使拖车的生活变得复杂，但他们还是诚实地遵循了指示。但是，有人抱怨有时厕所在火车的一半内。为了解决这个问题，他们发布了一条新指令：“当联结时，带马桶和不带马桶的备用马车。”这增加了预告片的工作量，但他们抱怨不已，开始诚实地遵循指示。但是，有人抱怨说另外，对于没有厕所的汽车，厕所不是在至少一辆相邻汽车的开始处，而是在两者的远端。一个民主国家的严重不公。</font></font>怎么办<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经过深思熟虑，官员们发布了另一条指令：“为每辆马车提供一个带有指示洗手间位置的箭头的马桶。耦合时，火车车厢的所有箭头应朝一个方向指向。”拖车虽然没有足够的转盘，却拉紧并开始这样做。但是-恐怖！ -乘客开始担心，尽管最近的厕所只不过是汽车，但不清楚厕所在哪一边。出现了其他说明：“在每辆没有厕所的汽车中，画出箭头“厕所”并互锁汽车，以使该箭头指向最近的厕所。”拖车大叫：他们没有时间。然后，有一个人注意到了以下情况：如果您将带马桶的汽车钩上而没有马桶，以使马桶位于对中，而永远不要解开对，那么分拣站将处理N / 2个对称（非定向）货车对，而不是N个货车。然后所有排序问题都消失了。没错，火车必须包含偶数的货车。但是你可以忍受。他们做到了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些经典著作声称，尽管该国还不知道计算机，但是找到解决方案的人是一位真正的程序员。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速排序</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在气泡排序和排序之后，壳牌是一个启示。</font><font style="vertical-align: inherit;">漂亮的算法和最快的结果。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个打印自身文本的程序，</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该程序的结果是打印自己的文本。</font><font style="vertical-align: inherit;">我很惊讶一个年轻的程序员如何在25分钟的时间内用Pascal编写该程序。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">国际象棋在</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序中给我留下了深刻的印象，在C语言中大约有50行，这在象棋上很不错。</font><font style="vertical-align: inherit;">一行中可能有多个语句。</font></font><br><br><h2> 案例 </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 波兰入境 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很久以前了。我们正在Belpromstroibank展览中心开发一个项目，以维护共和国建筑项目的数据。报告生成器已绘制。每个图都可以用任何算术公式定义。如何计算呢？确定用户必须填写一种特殊的表格，在该表格中他自己将公式简化为基本公式。例如，公式r =（a + b）/（cd）分解如下：1）x = a + b，2）y = cd，3）r = x / y。他们做到了。我们跑了。该项目正在实施中。每天，数十公斤的穿孔芬兰纸上印有数十份报告。老板正在考虑该项目的进一步发展。逐渐地，他有了一个想法，即任何公式的分解都可以由机器本身完成。因此，用户摆脱了繁琐的工作-分解公式（将其分解为一系列简单的公式）。出现了将公式提升为无括号记录的想法。接下来是堆栈的想法。然后我回想起我读过某处关于波兰语表达记录的地方。我找到一本书，发现老板亲自提出了波兰唱片（或换句话说，后缀）和书架的想法。如果不是因为自行车的发明，所有这些本来都是令人高兴的。毕竟，程序员应该知道的所有这些。但是他和我都是业余爱好者-来自其他专业的外国人... A，事实证明，我们的专业人士（从BSU matfak毕业并在计算机研究所工作过）不知道这一点。因此，这里更加令人难过。毕竟，程序员应该知道的所有这些。但是他和我都是业余爱好者-来自其他专业的外国人... A，事实证明，我们的专业人士（从BSU matfak毕业并在计算机研究所工作过）不知道这一点。因此，这里更加令人难过。毕竟，程序员应该知道的所有这些。但是他和我都是业余爱好者-来自其他专业的外国人... A，事实证明，我们的专业人士（从BSU matfak毕业并在计算机研究所工作过）不知道这一点。因此，这里更加令人难过。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las，在我看来，这种情况不仅存在于编程中。我们由三路医生治疗，三路建筑者正在建造，三路教师任教。我们有“不学习但只会无聊的学生”。然后业余专家出来了。结果，我们有很多没有受过教育的傻瓜，有很多受过教育的傻瓜，有很多没有受过教育的聪明人，但是很少有聪明有教养的人。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于业余主义的更多信息。为我们工作后，主管（我们称他为A.M.）决定更换程序员的负责人。因此，我被认为是竞争者。似乎正在进行一次不错的采访，但测试实际上正在进行中。因此，我被问到一个问题：“如何确定文件的结尾？” las，我不知道这一点，没有回答他们说，为什么我应该知道这种语言是否给我带来了EOF的局面，并且与实现方式无关紧要。正如K. Prutkov所说：“ ... Kostaki是对的，我是对的。”但是作为程序员的负责人，我被黑了。但是，有人提议我领导董事。 （回到故事的开头，回想经典，我们可以说“白痴的梦想成真了”）。 A.M.说：“考虑到广阔的世界观”因此，绵羊与山羊是分开的-通才是专家。以及进一步的上午熟练地处理人员。因此，我解决问题的方法“自上而下-从问题到机器”占据了主导地位，而我的同事则有相反的“自下而上-从机器到问题”。上午立即将我们引向不同的两极。一位同事开始研究建筑工地数据输入设备的驱动程序，而我正在研究用于接收建筑工地状态报告的数学模型。在其他项目中，我遇到了与其他经理相反的情况。结果，一个人谈论位，第二个谈论积分，彼此不了解。在其他项目中，我遇到了与其他经理相反的情况。结果，一个人谈论位，第二个谈论积分，彼此不了解。在其他项目中，我遇到了与其他经理相反的情况。结果，一个人谈论位，第二个谈论积分，彼此不了解。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我成为了董事。和编程，当然。程序员由另一个人（专业人士）领导。我们已经成为好朋友。我从他那儿得到了“不确定问题专家”的奉承和讽刺意味，他认识到我可以将最平庸的问题带入数学基础并使其扎实，即使从本质上讲它可能只是虚张声势。理论物理学家的遗产受到影响。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以AM为例我看到一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目是没有那么多智能的产品</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了尊重厨师，我们甚至收集了他的短语。</font></font><br><br> 范例： <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ……到……”-您只需要考虑疼痛就可以了。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">致Bitik</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”- </font><b><font style="vertical-align: inherit;">拙劣</font></b><font style="vertical-align: inherit;">，肤浅的方法在这里不起作用。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">卷起袖子</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”-没有什么可以释放的，没有网就可以工作。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">” </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是吗？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “-你在胡说八道，兄弟？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每天与他重复这些记录。但是在上午和更多不愉快的特性他非常喜欢在假日集体讨论。放假桌子的布置已经完成，香槟已经开瓶了-然后等待AM的电话。是的，钟声。 -“那么我有几个主意。我建议与他们讨论。”再见-假期。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一条蛇充满了所有空间</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示器一出现，视觉游戏就出现了。</font><font style="vertical-align: inherit;">首先是一条蛇咬住它的尾巴。</font><font style="vertical-align: inherit;">必须引导蛇，避免随机障碍，向左/右发出命令。</font><font style="vertical-align: inherit;">蛇一直在延长，所以剩下的空间更少了。</font><font style="vertical-align: inherit;">然后我有一个任务。</font><font style="vertical-align: inherit;">是否可以选择一条蛇形路线，使其占据整个屏幕空间。</font><font style="vertical-align: inherit;">经过几个小时的思考，我找到了正确的路线。</font><font style="vertical-align: inherit;">我们去吃午饭吧。</font><font style="vertical-align: inherit;">我把任务排队给我的同事。</font><font style="vertical-align: inherit;">令我惊讶的是，当他解决了这个问题时，我们没有时间倒第一个（虽然排队很长，但是没有几个小时）。</font><font style="vertical-align: inherit;">在考虑了这个案例之后，我开始以一个事实为安慰，那就是，显然，吃饭的欲望会激发智力。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 经典短语 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">某些经典经文的成本平庸。</font><font style="vertical-align: inherit;">以下是定义整个编程领域的一些语句。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布鲁克斯</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">精通的背后是机巧，这要归功于其经济，快速的程序。</font><font style="vertical-align: inherit;">几乎总是这是战略突破而不是战术技能的结果。</font><font style="vertical-align: inherit;">有时，这样的战略突破是一种算法，例如Cooley和Tukey提出的快速傅立叶变换或替代算法。</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-msubsup" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115" style="margin-right: 0.05em;">n</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-116" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7">n^2</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序时对n * log（n）的比较。</font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据或表格的显示常常会带来战略突破。</font><font style="vertical-align: inherit;">该程序的核心在这里。</font><font style="vertical-align: inherit;">仅显示流程图而不显示表格，我将继续迷路。</font><font style="vertical-align: inherit;">给我看您的表格，很可能不需要流程图：它们很明显</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数据表示是编程的本质。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在我看来，适应完美准确性的要求是学习编程过程中最困难的。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该项目最终被采用后，就其概念而言已过时。 </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沃思</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 程序=算法+数据。 </font></font></li><li>      ()     ,     ,     . </li><li>  .      ,     . </li><li>             ,         ,     . </li><li> ,       (,     ),           .      ,                         . </li><li>      ,  ,    ,  ,    .          ,          .         ,             .           .   </li><li>           ( )   ;      ,        .               ,     . </li><li> ,           ,      .       , : <br><br><ol><li>        , </li><li>       </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 选择的分解功能使您可以在某种意义上获得与最终编写程序的语言更接近的指令。 </font></font></li></ol></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SUN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络就是一台计算机。</font></font><br><br> 好主意。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，理想情况下，从开发语言的角度考虑的分布式程序不应与单一程序有所不同。</font><font style="vertical-align: inherit;">按使用级别分配的基础不应与未分配的有所不同。</font><font style="vertical-align: inherit;">分发应该由操作系统来实现。</font><font style="vertical-align: inherit;">服务的分发和编排也不应该是应用程序程序员所关心的。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dijkstra</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><ul><li>  -   ,           ( ,         ,        ,     ). </li><li>  -:        –  . </li><li>          ?  : “     : .  ,         ,         ,         –    ,       , <br> …      ,        .      ,       , ,    “”      .        –     …  ,      ,  <br>     –  ”. </li><li>    <br><br>            — <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-117"><span class="MJXp-mn" id="MJXp-Span-118">1</span><span class="MJXp-mrow" id="MJXp-Span-119"><span class="MJXp-mo" id="MJXp-Span-120" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-msubsup" id="MJXp-Span-121"><span class="MJXp-mn" id="MJXp-Span-122" style="margin-right: 0.05em;">10</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-123" style="vertical-align: 0.5em;">6</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8">1/10^6</script>       — <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-msubsup" id="MJXp-Span-125"><span class="MJXp-mn" id="MJXp-Span-126" style="margin-right: 0.05em;">10</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-127" style="vertical-align: 0.5em;">4</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9">10^4</script>  。                  .      , -,   . </li><li>  . <br><br>     ,   ,   ,         ,    ,      ,       .      , ,     ,         .   ,     ,       ,       .  ,       ,         ,   .     ,        ,   .          ,    –  ,        .   ,         ,  ,     ,     . </li><li> …         .    :       “” ?      : ””,      ,      ;      : ””, —    .  ,   ,      –    –     ,      .    ,                ,    ,           .       :       ,    . </li><li>       ,        . </li><li>    ,            ,    «   »  —  ! — « ».      - ,       <br>    ,     : «    ,      ,     ,  , «»       ,     ?»    , ,     -,      ."  , , ,            ,       . </li><li>       ,           ,     ( ),           ,   «   ».       ;     ,   ,        ,    « », . .  ,    ,       <br>   . </li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不知道</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最重要的编程语言是母语。</font><font style="vertical-align: inherit;">正式语言的程序是用母语表达的思想的翻译。</font><font style="vertical-align: inherit;">因此，那些以本国语言昏暗出现的人也会在正式场合中变暗。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 营销与程序员 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我为我的项目的展览准备了宣传材料。</font><font style="vertical-align: inherit;">我公司的营销人员通过以下攻击攻击了我的广告材料：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该材料有很多负面因素（描述了现有项目的缺点），并且带有负面能量 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 传单的大小不符合黄金分割率。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有其他类似的东西。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是这些营销人员没有注意到传单中没有电话，地址和有关公司的信息，当我熟悉展览会上的资料时，我的前任老板曾引起我的注意。我开始对接：先生们，我给您提供产品的技术说明，而您，营销商给您提供产品的市场描述。在哪里他们只同意批评。结果，它成为了公司的负责人。他告诉我：服从行销人员，毕竟她是从经济中毕业的。我：我以优异的成绩从BSU毕业。然后厨师说：“您优秀的学生了解自己，我不会吵架。”</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这给我留下了深刻的印象（总体而言，而不是对公司的营销）。这就是名字的魔力。每个人都必须至少给一个重要的事实起个名字，并可能要加上一个庄重的缩写。这已经保证您不会忽略该事实本身。然后，您需要匹配名称。名称是“分而治之”原则的应用。当我们给出一个名字时，我们就以此突出主题。有多少版权主张是这样的：“我们看到了，但是我们没有坚持这一事实，也没有给它起名字。”这就是重点！然后我理解了OLE-&gt; OCX-&gt; ActiveX-&gt; COM-&gt;？站点-&gt;门户-&gt;吗？..恩，关于企业对企业的交互，我们能说些什么，但是当我们说B2B（企业对企业）时，这是一个术语，因此，它背后有一些含义，尽管实际上实际上，可能没有任何东西，而仅仅是一个名称。缩写词ERP出现后，许多开发人员就开始以ERP形式展示他们的发展。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这方面，回顾以下内容。</font><font style="vertical-align: inherit;">当党允许控制论时，关于什么叫做现在所谓的“计算机”的争论开始了。</font><font style="vertical-align: inherit;">“计算器”，“ TsAM”，“计算机” ...-一切都没有完成。</font><font style="vertical-align: inherit;">我们伟大而强大的语言在美国主义之前拯救了“计算机”。</font><font style="vertical-align: inherit;">我认为，这是西方自卑情结的体现。</font><font style="vertical-align: inherit;">而且，我必须说，a，一个完全合理的复合体。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 关于整合 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我看到了银行系统的许多实现，并且几乎总是将它们称为集成系统。</font><font style="vertical-align: inherit;">但实际上，他们从来没有那样。</font><font style="vertical-align: inherit;">我认为真正的集成系统还没有到来。</font><font style="vertical-align: inherit;">这样的系统应该具有单个信息模型，单个对象模型，单个功能模型，单个概念和体系结构：应该在数据，对象，功能，事件，接口上实现集成。</font><font style="vertical-align: inherit;">我还没看过</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最 </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最有趣的任务 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个业务分析项目。</font><font style="vertical-align: inherit;">意识到TK决定了自己，进行了生产自己，信息模型自己，对象模型自己以及您也进行编程这样的事实，就可以感到自豪为荣。</font><font style="vertical-align: inherit;">这项任务的新颖性和广度很有趣。</font><font style="vertical-align: inherit;">其边框不可见。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最大的挑战 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大的集体项目是所有白俄罗斯的建筑护照。</font><font style="vertical-align: inherit;">该项目是在欧盟计算机的汇编程序上实施的。</font><font style="vertical-align: inherit;">主题区域-白俄罗斯所有建筑项目的数据。</font><font style="vertical-align: inherit;">用户自己设置施工报告的结构和内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大的单个项目是商业智能。</font><font style="vertical-align: inherit;">主题区域-对过去，当前，计划和预测的业务状态的分析。</font><font style="vertical-align: inherit;">工具：分解器，比较器，模拟方案，时间序列，统计假设。</font><font style="vertical-align: inherit;">语言：Delphi，C＃。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最惊人的挑战 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是递归的第一个介绍。</font><font style="vertical-align: inherit;">使用递归解决河内塔问题的方法给我留下了深刻的印象-简化为相同的问题，但是尺寸较小，因此对于小尺寸而言，解决方案是显而易见的。</font><font style="vertical-align: inherit;">八个皇后的问题也令人印象深刻。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最引人注目的书 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">达尔，迪克斯特拉，灰白。</font><font style="vertical-align: inherit;">结构化编程。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迪克斯特拉。</font><font style="vertical-align: inherit;">编程学科。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最可笑的情况 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们针对EC-1020开发了有关Kobol的项目。我是一个初学者程序员。需要一种根据情况调用某些程序的调度程序。他人无法下载Kobol上的程序（或者我不知道该怎么做）。有必要要么用汇编器编写（我们不知道），要么做其他事情。然后他们发现了不同之处-这是DOS操作系统的作业管理语言（JCL）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诸如SYSIN（逻辑输入设备），SYSRDRR（逻辑指令输入设备JCL）之类的东西。</font><font style="vertical-align: inherit;">可以在运行时重新分配它们。</font><font style="vertical-align: inherit;">因此，为每个可能的分支准备了一堆SYSRDR，原则上您可以完成任务。</font><font style="vertical-align: inherit;">我们为此付出了很多努力。</font><font style="vertical-align: inherit;">当然，所有这些都是徒劳的。</font><font style="vertical-align: inherit;">学习了Assembler之后，我们得到了一切，并且在JCL上花费了大量的精力，即使取得了成果，我们也没有得到任何新的东西。</font><font style="vertical-align: inherit;">您无需从更近的地方选择，而是从总体上带来更多好处的地方选择。</font><font style="vertical-align: inherit;">顺便说一下，DOS被OS / 360取代了，JCL已经成为过去。</font><font style="vertical-align: inherit;">但是更加诱人，但是这样的错误没有再发生。</font><font style="vertical-align: inherit;">用弹弓制造枪是很难的。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最有趣的 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“窃听”开始时，使用一个测试示例将该产品投入试运行。</font><font style="vertical-align: inherit;">测试案例是经济学家编写的一项全球测试。</font><font style="vertical-align: inherit;">产品运行的结果通常是表格表-在解决方案的不同阶段报告要解决的问题的状态。</font><font style="vertical-align: inherit;">对照对照表检查表格，如果它们重合，则该产品可以接受试运行。</font><font style="vertical-align: inherit;">但是该项目尚未准备就绪。</font></font>怎么办<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案很简单。</font><font style="vertical-align: inherit;">编写程序在额头产生表格。</font><font style="vertical-align: inherit;">交货时，它们开始。</font><font style="vertical-align: inherit;">并且没有经验的人（然后是谁？）客户签署了接受证书以进行试运行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“如果您能说出话，那么为什么要表演”-一位亲爱的程序员回答了这样的短语，即在他创建的程序令人兴奋的表演之后，后者在表演开始时就倒下了，他从表演转向了表演。</font></font><br><br><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在开发一个项目-“商业智能”。它是在NT下开发的。现在，我们迫切需要在银行中演示该系统。我们决定在笔记本电脑上进行操作。 Windows 98已经在那里。我们放置，重新编译，运行-一切都很好，除了一个：这个时期的开始是在1898年。我们开始怀疑包含日期的上下文被错误地提取了。用户代码可以检索上下文，用户代码可以通过调用Windows API的GetUserName函数来检索。我们开始怀疑此功能不能正常工作。我们设置撬点并运行调试器。一切正常，程序运行正常，日期正常。他们偶然地注销了一切。那天晚上，我们高兴地回家了。明天在银行。第二天早上，我们打开-同样的日期日期。我们在调试器中打开解析器-一切正常。好吧，量子力学中的情况很简单：当它们不监视粒子时，它们会干扰波，而当它们监视时，它们就是粒子。因此我们没有收到答案。为了一切顺利，我们“笔”输入了正确的数据，演示成功了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，还有另外一个案例。</font><font style="vertical-align: inherit;">我们一起开发了分析项目，因此使用了支持该项目团队合作的工具-MS SourceSafe。</font><font style="vertical-align: inherit;">该产品支持多个历史版本。</font><font style="vertical-align: inherit;">在这里，我反复发现，在修复了一些重要的分支之后，一段时间后，我注意到旧版本就在那里，但是没有更正。</font><font style="vertical-align: inherit;">因此，重复了几次。</font><font style="vertical-align: inherit;">我把一切归因于文盲。</font><font style="vertical-align: inherit;">但是，什么样的产品对文盲如此残酷呢？</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 几乎是哲学 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何描述程序（具有固定内存大小的计算机）的智力能力？显然，他们甚至不记得足够多的数字。因此，我们也无法记住并写下足够多的数字。但是，我们不认为自己</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是非知识分子。那么，智力的正式定义在哪里？我认为这是根本问题之一。如何用给定的外部参数（内存）来描述系统智能的度量？程序如何了解自己-自我知识的局限性？宏的使用-自行修改的程序会引发问题：程序可以变得更明智吗？智能的局限性在哪里？</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和以前一样，世界观是由自然科学决定的，因此现在它越来越由计算机科学决定。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不是指原始编程，而是编程科学。所以</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从视图计算机的角度考虑他们时，许多抽象的哲学问题是非常具体</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。考虑这个例子。毕竟，可以在计算机上模拟智能生物程序。您可以模拟繁殖，选择，遗传，空间，时间...结果是计算机内部世界。在这里，计算机内生物（softhomo）居住在那里，争夺一块面包，交谈，进行哲学思考，迟早要思考：世界上有上帝吗？什么是主要的：物质还是意识？你自己有东西吗？你知道世界吗？有一个固执主义者，宣称：“整个世界只存在于我的想象中。”当地唯物主义者在这方面提出了a叫。谁是对的？从他们的世界的角度来看，唯物主义者是正确的；从我们的世界的角度来看，唯物主义者是正确的。这证明关闭了计算机。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们这个世界上，人们早已表达出唯物主义者和理想主义者都是正确的想法。在物理学中，很早就克服了诸如“粒子或波”或“粒子与波”之类的二元原始思维。哲学也是如此。当被问到什么是深层真理时，博拉回答说：“深层真理就是这样的真理，否认这一点也是深层真理。”否定真理2 * 2 = 4并不深，这意味着这个真理本身也不深。但是，正如哲学的整体发展所言，当“列宁主义的唯物主义者只批评唯心主义的创新而没有提出任何新的东西时”，对“最重要的”真理的否定却是深刻的。但是，一旦我们对它进行了唯物主义的解释，那么一切都将成为真正的科学“例子”-控制论，符号学，量子力学的哥本哈根解释，等等。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是问题所在：无论发明了什么软件家庭，无论他们的智力有多努力，他们都永远不会在他们之外看到和听到我们的世界-例如，程序员（如果程序员没有明确地打开对话）。对他们来说，程序员是上帝，而我们的世界对他们自己而言就是物，对他们来说，我们的世界是不可知的，程序员对他们的知识充实是先验知识。康德（Kant）似乎在他的哲学中谈到了所有这一切，但他对此确实了解很多。康德最抽象的概念，“自身的事物”，“先验的”，“先验的”，“先验的综合知识”在这种解释中得到了相当可理解的东西。对于指示的世界，我们的整个世界本身就是事物，先验的综合知识就是程序员对计算机内部世界的理解，对他而言，先验知识就是程序员如何创建这个计算机世界。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，您可能会问自己：也许对于我们某些人来说，我们是计算机世界，而上帝是程序员？顺便说一句，所谓的人类原理是在物理学中提出的。事实证明，所有物理定律都以这样的方式排列：它们会稍稍改变一下，而不会出现一个人。稍微改变引力常数，或者电子的电荷，或者普朗克常数，一切都会起作用，从而使太阳不发光，或者太阳太热。就是说，一切都做好了，以便一个人出现。的确，很多人都说这是不言而喻的：没有一个人，不同的世界可以出现数百万次，但是，如果一个人已经出现了，那么自然地，他出现的世界被设计成可以出现。拖拉机离开输送机后，自然会设计好输送机，使拖拉机出现。但是，仍然...</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，编程使您可以重新审视世界观问题。</font><font style="vertical-align: inherit;">这可以从根本上改变世界观本身。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最后一个 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我一生的旅途中，我收获了平庸的智慧：“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个头脑不足以</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明智</font><i><font style="vertical-align: inherit;">地行动</font></i><font style="vertical-align: inherit;">。” </font><font style="vertical-align: inherit;">我们课程中有多少聪明的女人-很多。</font><font style="vertical-align: inherit;">他们在哪 </font><font style="vertical-align: inherit;">成功还需要什么？</font><font style="vertical-align: inherit;">但是上帝认识他。</font><font style="vertical-align: inherit;">还有运气，金钱和世俗的傲慢。</font><font style="vertical-align: inherit;">las，无礼的三位统治者统治着一切。</font><font style="vertical-align: inherit;">聪明的人也怀疑自己。</font><font style="vertical-align: inherit;">他们有足够的智慧，但意志不足。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古代巴比伦人的抱怨：“苦难来了，众神生气了，孩子们不再服从父母，每个人都想写一本书”现代性修改：“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">苦难来了，神灵们生气了，孩子们不再服从父母，每个人都想要写书，而不幸的是，每个人愚人想在Internete上创建自己的站点/门户/博客</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。”</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471184/">https://habr.com/ru/post/zh-CN471184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471170/index.html">功能实践和前端：monad和函子</a></li>
<li><a href="../zh-CN471174/index.html">使用Git和GitHub入门比使用GitHub Desktop 2.2更加容易</a></li>
<li><a href="../zh-CN471176/index.html">用VS Code原生编辑Jupyter Notebook</a></li>
<li><a href="../zh-CN471178/index.html">DPI快速入门指南：使用方案</a></li>
<li><a href="../zh-CN471182/index.html">GitHub Desktop 2.2：新功能</a></li>
<li><a href="../zh-CN471186/index.html">国际标准中的知识管理：ISO，PMI</a></li>
<li><a href="../zh-CN471188/index.html">Visual Studio Code中的Python-10月更新</a></li>
<li><a href="../zh-CN471190/index.html">40种最佳Laravel工具和资源</a></li>
<li><a href="../zh-CN471192/index.html">我们邀请您参加2019年10月19日在塔甘罗格举行的Azov开发者大会2019</a></li>
<li><a href="../zh-CN471194/index.html">关于手指上的重心坐标</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>