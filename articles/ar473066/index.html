<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤖 🔫 👨🏼‍⚕️ رباعي الأشجار والاعتراف الاصطدام 🤾🏼 👠 👿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="كان هذا الأسبوع قصيرًا ، يومي الاثنين والثلاثاء واصلت العمل على نظام الإضاءة ثنائي الأبعاد . بقية الوقت الذي قضيته في تنفيذ أشجار quadtree. 

 في هذه ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>رباعي الأشجار والاعتراف الاصطدام</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473066/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/59e/237/20a/59e23720a19b3109d80e62c6d2d539a0.gif" alt="صورة"></div><br>  كان هذا الأسبوع قصيرًا ، يومي الاثنين والثلاثاء واصلت العمل على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نظام الإضاءة ثنائي الأبعاد</a> .  بقية الوقت الذي قضيته في تنفيذ أشجار quadtree. <br><br>  في هذه المقالة سوف أشارك تطبيقي وأفكاري التي نشأت أثناء عملية تصميمها. <br><br>  أولاً ، يجب أن أقول لماذا قررت تنفيذ شجرة رباعية. <br><br>  Quadtree هو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بنية بيانات قسم الفضاء</a> .  ميزتها الرئيسية على هياكل البيانات الأخرى هي قدرتها على التكيف.  يوفر أداءً جيدًا عند الإدراج والحذف والبحث.  وهذا يعني أنه يمكننا استخدام هذه الشجرة في سياق ديناميكي حيث تتغير البيانات غالبًا.  علاوة على ذلك ، هذا الهيكل سهل الفهم والتنفيذ. <br><br>  إذا كان تقسيم الفضاء موضوعًا جديدًا لك ، فأنا أوصي بقراءة هذه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المقالة بواسطة</a> روبرت نيستروم.  إذا كنت تريد معرفة المزيد حول أشجار الأرباع ، فاقرأ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذا</a> المقال أو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذا</a> المقال. <br><a name="habracut"></a><br>  هناك مناطق في لعبتي يُفيد فيها استخدام quadtree على الفور: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  عند اكتشاف الاصطدامات ، تكون الشجرة الرباعية أكثر كفاءة من طريقة القوة الغاشمة (اختبار جميع الأزواج).  ولكن هذا ليس هو النهج الأكثر فعالية ، ويمكن دراسة لمحة عامة عن مختلف التقنيات والمعايير في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذه المقالة</a> .  ومع ذلك ، بالنسبة للإصدار الأول من محرك الفيزياء الخاص بي ، أستخدمه.  ربما في وقت لاحق ، إذا لزم الأمر ، سأختار خوارزمية أكثر تخصصًا. </li><li style=";text-align:right;direction:rtl">  في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الرسم البياني للمشهد ،</a> عند تنفيذ لقطة ، يمكنني استخدام quadtree للبحث عن جميع العقد المرئية. </li><li style=";text-align:right;direction:rtl">  في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نظام الإضاءة ،</a> يمكنك استخدام المربع الرباعي لإيجاد جدران تتقاطع مع مضلع رؤية مصدر الضوء. </li><li style=";text-align:right;direction:rtl">  في نظام الذكاء الاصطناعى ، يمكنك استخدام quadtree للبحث عن كل الكائنات أو الأعداء القريبين من الجوهر. </li><li style=";text-align:right;direction:rtl">  وهلم جرا ... </li></ul><br>  كما ترون ، أشجار رباعي تنوعا جدا.  سيكون تجديد جيد في مجموعة الأدوات الخاصة بك. <br><br>  يمكن العثور على جميع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الكودات</a> الموضحة في المقال على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جيثب</a> . <br><br><h1 style=";text-align:right;direction:rtl">  التحضير الأولي </h1><br>  قبل تفصيل كود quadtree ، نحتاج إلى فصول صغيرة <code>Vector2</code> الهندسية: فئة <code>Vector2</code> لتحديد النقاط وفئة <code>Box</code> لتحديد المستطيلات.  على حد سواء سيكون boilerplate. <br><br><h2 style=";text-align:right;direction:rtl">  Vector2 </h2><br>  فئة <a href=""><code>Vector2</code></a> أضيق الحدود.  أنه يحتوي على صانعي فقط ، وكذلك <code>+</code> و <code>/</code> المشغلين.  هذا كل ما نحتاجه: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T x; T y; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;(TX = <span class="hljs-number"><span class="hljs-number">0</span></span>, TY = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : x(X), y(Y) { } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x += other.x; y += other.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/=(T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x /= t; y /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vector2&lt;T&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { lhs += rhs; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/(Vector2&lt;T&gt; vec, T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { vec /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec; }</code> </pre> <br><h2 style=";text-align:right;direction:rtl">  صندوق </h2><br>  فئة <a href=""><code>Box</code></a> ليست أكثر تعقيدًا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T left; T top; T width; <span class="hljs-comment"><span class="hljs-comment">// Must be positive T height; // Must be positive constexpr Box(T Left = 0, T Top = 0, T Width = 0, T Height = 0) noexcept : left(Left), top(Top), width(Width), height(Height) { } constexpr Box(const Vector2&lt;T&gt;&amp; position, const Vector2&lt;T&gt;&amp; size) noexcept : left(position.x), top(position.y), width(size.x), height(size.y) { } constexpr T getRight() const noexcept { return left + width; } constexpr T getBottom() const noexcept { return top + height; } constexpr Vector2&lt;T&gt; getTopLeft() const noexcept { return Vector2&lt;T&gt;(left, top); } constexpr Vector2&lt;T&gt; getCenter() const noexcept { return Vector2&lt;T&gt;(left + width / 2, top + height / 2); } constexpr Vector2&lt;T&gt; getSize() const noexcept { return Vector2&lt;T&gt;(width, height); } constexpr bool contains(const Box&lt;T&gt;&amp; box) const noexcept { return left &lt;= box.left &amp;&amp; box.getRight() &lt;= getRight() &amp;&amp; top &lt;= box.top &amp;&amp; box.getBottom() &lt;= getBottom(); } constexpr bool intersects(const Box&lt;T&gt;&amp; box) const noexcept { return !(left &gt;= box.getRight() || getRight() &lt;= box.left || top &gt;= box.getBottom() || getBottom() &lt;= box.top); } };</span></span></code> </pre> <br>  أنه يحتوي على بعض الهدايا مفيدة. <br><br>  ما هو أكثر إثارة للاهتمام هو أنه يحتوي على طريقة تحتوي على ، والتي تتحقق مما إذا كان المستطيل داخل آخر ، وطريقة <code>intersects</code> ، والذي يتحقق ما إذا كان المستطيل يتقاطع مع آخر. <br><br>  سوف نستخدم <code>contains</code> عند الإدراج والحذف ، <code>intersects</code> عند التعرف على التقاطعات. <br><br><h1 style=";text-align:right;direction:rtl">  Quadtree </h1><br>  هنا هو <a href=""><code>Quadtree</code></a> فئة <a href=""><code>Quadtree</code></a> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GetBox, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Equal = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::equal_to&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Float = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; class Quadtree { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;GetBox, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, Box&lt;Float&gt;&gt;, <span class="hljs-string"><span class="hljs-string">"GetBox must be a callable of signature Box&lt;Float&gt;(const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Equal, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;, <span class="hljs-string"><span class="hljs-string">"Equal must be a callable of signature bool(const T&amp;, const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt;Float&gt;); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Quadtree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GetBox&amp; getBox = GetBox(), <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Equal&amp; equal = Equal()) : mBox(box), mRoot(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Node&gt;()), mGetBox(getBox), mEqual(equal) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Threshold = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> MaxDepth = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt;, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; children; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; values; }; Box&lt;Float&gt; mBox; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt; mRoot; GetBox mGetBox; Equal mEqual; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLeaf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Node* node)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(node-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } };</code> </pre> <br>  كما ترون ، <code>Quadtree</code> هي فئة القالب.  هذا سيسمح لنا باستخدام الفصل لأغراض متعددة ، والتي تحدثت عنها في البداية. <br><br>  خيارات القالب: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>T</code> : نوع القيم التي سيتم تضمينها في quadtree.  يجب أن تكون فئة <code>T</code> سهلة ، لأنه سيتم تخزينها داخل رباعي.  من الناحية المثالية ، يجب أن يكون هذا مؤشر أو بنية بيانات بسيطة صغيرة (POD). </li><li style=";text-align:right;direction:rtl">  <code>GetBox</code> : نوع الكائن الذي تم استدعاؤه والذي سيتلقى القيمة عند الإدخال وإرجاع مستطيل. </li><li style=";text-align:right;direction:rtl">  <code>Equal</code> : نوع الكائن الذي تم استدعاؤه للتحقق مما إذا كانت القيمتان متساويتان.  بشكل افتراضي ، نستخدم عامل المساواة القياسي. </li><li style=";text-align:right;direction:rtl">  <code>Float</code> : النوع الحسابي المستخدم في العمليات الحسابية.  افتراضيا ، نستخدم <code>float</code> . </li></ul><br>  في بداية تعريف الفئة ، هناك ثلاثة تأكيدات ثابتة للتحقق من صحة معلمات القالب. <br><br>  دعنا نلقي نظرة على تعريف العقدة.  تقوم العقدة ببساطة بتخزين المؤشرات إلى العقد الفرعية الأربعة الخاصة بها وقائمة من القيم الموجودة فيها.  نحن لا نخزن فيه الصندوق المحيط أو العمق ، سيتم حسابها على الطاير. <br><br>  لقد أجريت مقارنات لكلا النهجين (الحفاظ على مستطيل بعمق وبدون الحفاظ) ولم أجد أي تدهور في الأداء عند حسابهما أثناء الطيران.  علاوة على ذلك ، فإنه يوفر القليل من الذاكرة. <br><br>  لتتمكن من تمييز عقدة داخلية عن ورقة ، <code>isLeaf</code> طريقة <code>isLeaf</code> .  إنه يتحقق فقط من أن الطفل الأول ليس خاليًا.  نظرًا لأن null هي كل العقد الفرعية أو لا توجد أي منها ، فهذا يكفي للتحقق من الأولى فقط. <br><br>  الآن يمكننا أن ننظر إلى <code>Quadtree</code> عضو <code>Quadtree</code> : <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>mBox</code> هو مربع <code>mBox</code> عالمي.  يجب أن تكون جميع القيم المدرجة في quadtree ضمنها. </li><li style=";text-align:right;direction:rtl">  <code>mRoot</code> هو أصل quadtree. </li><li style=";text-align:right;direction:rtl">  <code>mGetBox</code> هو كائن يسمى ، والذي <code>mGetBox</code> للحصول على المستطيل من القيمة. </li><li style=";text-align:right;direction:rtl">  <code>mEqual</code> هو الكائن الذي يسمى ، والذي <code>mEqual</code> للتحقق من المساواة بين القيمتين. </li></ul><br>  يقوم المنشئ ببساطة بتعيين <code>mBox</code> و <code>mGetBox</code> و <code>mEqual</code> ، كما ينشئ عقدة جذر. <br><br>  <code>MaxDepth</code> لم نتحدث <code>MaxDepth</code> بعد هما <code>Threshold</code> و <code>MaxDepth</code> .  <code>Threshold</code> هو الحد الأقصى لعدد القيم التي يمكن أن تحتويها العقدة قبل تقسيمها.  <code>MaxDepth</code> هو أقصى عمق للعقدة ، نتوقف عن محاولة تقسيم العقد الموجودة على <code>MaxDepth</code> ، لأنه إذا قسمت أكثر من اللازم ، فقد يعيق ذلك الأداء.  أعطيت هذه الثوابت قيم معقولة مناسبة لمعظم الحالات.  يمكنك محاولة تحسينها من أجل التكوين الخاص بك. <br><br>  نحن الآن على استعداد لبدء عمليات أكثر إثارة للاهتمام. <br><br><h1 style=";text-align:right;direction:rtl">  إدراج وحذف </h1><br>  قبل أن أعرض رمز الإدراج ، نحتاج إلى مناقشة العقد التي ستحتوي على القيم.  هناك استراتيجيتان: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم تخزين القيم فقط في الأوراق.  نظرًا لأن المربع المحيط بقيمة يمكن أن يتفاعل مع أوراق متعددة ، سيتم تخزين القيمة في كل هذه الأوراق. </li><li style=";text-align:right;direction:rtl">  يمكن تخزين القيم في جميع العقد.  نقوم بتخزين القيمة في أصغر عقدة تحتوي بالكامل على المربع المحيط بها. </li></ul><br>  إذا كانت المستطيلات المحيطية صغيرة الحجم وبنفس الحجم تقريبًا ، فإن الإستراتيجية الأولى تكون أكثر فعالية عند البحث عن التقاطعات.  ومع ذلك ، في حالة وجود مستطيلات كبيرة ، قد تحدث حالات متدهورة يكون الأداء فيها سيئًا للغاية.  على سبيل المثال ، إذا قمنا بإدراج قيمة يكون مستطيلها في المربع المحيط العام ، فسيتم إضافتها إلى جميع الأوراق.  وإذا قمنا بإدراج حد لهذه القيم ، فسيتم تقسيم كل العقد حتى <code>MaxDepth</code> الوصول إلى <code>MaxDepth</code> ولن تكون القيم في جميع الأوراق.  لذلك ، سوف quadtree تحتوي <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="37.45ex" height="2.539ex" viewBox="0 -987.6 16124.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-65" x="611" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-78" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="1650" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="2012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="2373" y="0"></use><g transform="translate(2735,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-54" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-68" x="704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-72" x="1281" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-65" x="1732" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-73" x="2199" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-68" x="2668" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-6F" x="3245" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-6C" x="3730" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-64" x="4029" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="7537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-69" x="7899" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-6D" x="8244" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-65" x="9123" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-73" x="9589" y="0"></use><g transform="translate(10059,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMAIN-34" x="0" y="0"></use><g transform="translate(500,404)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-65" x="715" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-78" x="1181" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="1754" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="2115" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="2477" y="0"></use><g transform="translate(2007,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-4D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-61" x="1051" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-78" x="1581" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-44" x="2153" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-65" x="2982" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-70" x="3448" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-74" x="3952" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhhOGf0u28jyyFEFm8mOlAcIcUHQQA#MJMATHI-68" x="4313" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&nbsp;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ texttt {Threshold} \ times 4 ^ {\ texttt {MaxDepth}} </script>  المعاني ، وهذا ... الكثير. <br><br>  علاوة على ذلك ، مع الاستراتيجية الأولى ، سيكون الإدخال والحذف أبطأ قليلاً ، لأنه يتعين علينا إدراج (أو حذف) جميع العقد التي تتقاطع مع القيمة. <br><br>  لذلك ، سأستخدم الإستراتيجية الثانية ، التي لا توجد فيها حالات تنكس.  لأنني أخطط لاستخدام quadtree في سياقات مختلفة ، سيكون أكثر ملاءمة.  بالإضافة إلى ذلك ، تعتبر هذه الاستراتيجية أكثر ملاءمة للسياقات الديناميكية التي يتم فيها إجراء الكثير من عمليات الإدراج والحذف لتحديث القيم ، على سبيل المثال ، في محرك فعلي يتم نقل الكيانات فيه. <br><br>  لمعرفة العقدة التي سنقوم بإدراجها أو حذفها ، سنستخدم وظيفتين مساعدتين. <br><br>  الأول ، <code>computeBox</code> ، يحسب مستطيل العقدة التابعة بواسطة مستطيل العقدة الأصل وفهرس الربع الخاص به. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Box&lt;Float&gt; computeBox(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> origin = box.getTopLeft(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childSize = box.getSize() / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Float&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-comment"><span class="hljs-comment">// North West case 0: return Box&lt;Float&gt;(origin, childSize); // Norst East case 1: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x + childSize.x, origin.y), childSize); // South West case 2: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x, origin.y + childSize.y), childSize); // South East case 3: return Box&lt;Float&gt;(origin + childSize, childSize); default: assert(false &amp;&amp; "Invalid child index"); return Box&lt;Float&gt;(); } }</span></span></code> </pre> <br>  الثاني ، <code>getQuadrant</code> ، بإرجاع الربع الذي توجد فيه القيمة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getQuadrant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; nodeBox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; valueBox)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> center = nodeBox.getCenter(); <span class="hljs-comment"><span class="hljs-comment">// West if (valueBox.getRight() &lt; center.x) { // North West if (valueBox.getBottom() &lt; center.y) return 0; // South West else if (valueBox.top &gt;= center.y) return 2; // Not contained in any quadrant else return -1; } // East else if (valueBox.left &gt;= center.x) { // North East if (valueBox.getBottom() &lt; center.y) return 1; // South East else if (valueBox.top &gt;= center.y) return 3; // Not contained in any quadrant else return -1; } // Not contained in any quadrant else return -1; }</span></span></code> </pre> <br>  تقوم بإرجاع <code>-1</code> إذا لم يكن موجودًا في أي من الأرباع. <br><br>  نحن الآن على استعداد للنظر في أساليب الإدراج والحذف. <br><br><h2 style=";text-align:right;direction:rtl">  إدراج </h2><br>  استدعاء الأسلوب ببساطة استدعاء أسلوب مساعد خاص: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ add(mRoot.get(), <span class="hljs-number"><span class="hljs-number">0</span></span>, mBox, value); }</code> </pre> <br>  هنا هو رمز طريقة المساعد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Insert the value in this node if possible if (depth &gt;= MaxDepth || node-&gt;values.size() &lt; Threshold) node-&gt;values.push_back(value); // Otherwise, we split and we try again else { split(node, box); add(node, depth, box, value); } } else { auto i = getQuadrant(box, mGetBox(value)); // Add the value in a child if the value is entirely contained in it if (i != -1) add(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), depth + 1, computeBox(box, i), value); // Otherwise, we add the value in the current node else node-&gt;values.push_back(value); } }</span></span></code> </pre> <br>  في البداية ، يوجد افتراضان يتحققان من أننا لا نقوم بأي شيء غير منطقي ، على سبيل المثال ، نحن لا ندرج قيمة في عقدة لا تحتوي على المربع المحيط بها. <br><br>  ثم ، إذا كانت العقدة عبارة عن ورقة ، ويمكننا إدراج قيمة جديدة فيها ، أي  لم <code>MaxDepth</code> إلى <code>MaxDepth</code> أو <code>Threshold</code> ، قم بإجراء الإدراج.  وإلا ، فإننا نشارك هذه العقدة ونعيد المحاولة. <br><br>  إذا كانت العقدة داخلية ، فإننا نحسب الربع الذي يحتوي على المربع المحيط للقيمة.  إذا كانت مضمنة تمامًا في العقدة الفرعية ، فنحن نجري مكالمة متكررة.  خلاف ذلك ، تضاف في هذه العقدة. <br><br>  هنا هو إجراء الفصل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only leaves can be split"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Create children for (auto&amp; child : node-&gt;children) child = std::make_unique&lt;Node&gt;(); // Assign values to children auto newValues = std::vector&lt;T&gt;(); // New values for this node for (const auto&amp; value : node-&gt;values) { auto i = getQuadrant(box, mGetBox(value)); if (i != -1) node-&gt;children[static_cast&lt;std::size_t&gt;(i)]-&gt;values.push_back(value); else newValues.push_back(value); } node-&gt;values = std::move(newValues); }</span></span></code> </pre> <br>  ننشئ أربع عقد تابعة ، ومن ثم لكل قيمة للعقدة الأصل ، نقرر في أي عقدة (تابعة أو أصل) يجب تخزين القيمة. <br><br><h2 style=";text-align:right;direction:rtl">  إزالة </h2><br>  تقوم طريقة <code>remove</code> أيضًا باستدعاء طريقة المساعد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ remove(mRoot.get(), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, mBox, value); }</code> </pre> <br>  فيما يلي رمز طريقة المساعد ، وهو مشابه جدًا لكود الإدراج: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, Node* parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Remove the value from node removeValue(node, value); // Try to merge the parent if (parent != nullptr) tryMerge(parent); } else { // Remove the value in a child if the value is entirely contained in it auto i = getQuadrant(box, mGetBox(value)); if (i != -1) remove(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), node, computeBox(box, i), value); // Otherwise, we remove the value from the current node else removeValue(node, value); } }</span></span></code> </pre> <br>  إذا كانت العقدة الحالية عبارة عن ورقة ، فسنقوم بإزالة القيمة من قائمة قيم العقدة الحالية <br>  وحاول دمج هذه العقدة مع العقد الشقيقة والوالد.  خلاف ذلك ، فإننا نحدد في أي مربع رباعي يقع المربع المحيط للقيمة.  إذا كانت مضمنة تمامًا في العقدة الفرعية ، فسنقوم بإجراء مكالمة متكررة.  خلاف ذلك ، احذف من قيم العقدة الحالية. <br><br>  نظرًا لأننا لا نهتم بترتيب القيم المخزنة في العقدة ، عندما أقوم بمسحها ، أستخدم تحسينًا بسيطًا: لقد قمت فقط بتغيير القيمة التي تم محوها باستخدام القيمة الأخيرة وحذفها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the value in node-&gt;values auto it = std::find_if(std::begin(node-&gt;values), std::end(node-&gt;values), [this, &amp;value](const auto&amp; rhs){ return mEqual(value, rhs); }); assert(it != std::end(node-&gt;values) &amp;&amp; "Trying to remove a value that is not present in the node"); // Swap with the last element and pop back *it = std::move(node-&gt;values.back()); node-&gt;values.pop_back(); }</span></span></code> </pre> <br>  نحتاج أيضًا إلى إلقاء نظرة على <code>tryMerge</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryMerge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(!isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only interior nodes can be merged"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> nbValues = node-&gt;values.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; child : node-&gt;children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(child.get())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; nbValues += child-&gt;values.size(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbValues &lt;= Threshold) { node-&gt;values.reserve(nbValues); <span class="hljs-comment"><span class="hljs-comment">// Merge the values of all the children for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : child-&gt;values) node-&gt;values.push_back(value); } // Remove the children for (auto&amp; child : node-&gt;children) child.reset(); } }</span></span></code> </pre> <br>  يتحقق <code>tryMerge</code> أن جميع العقد الفرعية هي أوراق وأن العدد الإجمالي لقيمها وقيم العقد الفرعية أقل من العتبة.  إذا كان الأمر كذلك ، فنحن ننسخ جميع القيم من العقد الفرعية إلى العقدة الحالية ونحذف العقد الفرعية. <br><br><h1 style=";text-align:right;direction:rtl">  بحث تقاطع </h1><br><h2 style=";text-align:right;direction:rtl">  تقاطع مع المستطيل </h2><br>  وأخيرا ، وصلنا إلى الأكثر إثارة للاهتمام: للبحث عن التقاطعات.  أول طريقة لاستخدامها هي الحصول على جميع القيم التي تتقاطع مع مستطيل معين.  على سبيل المثال ، هذا مطلوب لأداء لقطة. <br><br>  وسيتم <code>query</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; query(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(); query(mRoot.get(), mBox, box, values); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values; }</code> </pre> <br>  في هذه الطريقة ، نختار ببساطة <code>std::vector</code> ، والتي ستحتوي على القيم التي تتقاطع مع المربع المحيط ، ونستدعي طريقة المساعد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; queryBox, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(queryBox.intersects(box)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; value : node-&gt;values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(mGetBox(value))) values.push_back(value); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(node)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; node-&gt;children.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childBox = computeBox(box, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(i)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(childBox)) query(node-&gt;children[i].get(), childBox, queryBox, values); } } }</code> </pre> <br>  أولاً ، نضيف جميع القيم المخزنة في العقدة الحالية التي تتقاطع مع المستطيل المطلوب.  ثم ، إذا كانت العقدة الحالية داخلية ، فإننا نقوم بإجراء مكالمة متكررة لكل عقدة تابعة يتقاطع مستطيلها المحيط مع المستطيل المطلوب. <br><br><h2 style=";text-align:right;direction:rtl">  جميع التقاطعات الزوجية </h2><br>  حالة الاستخدام المدعومة الثانية هي البحث عن جميع أزواج القيم المخزنة في شجرة الربع التي تتقاطع.  هذا مفيد بشكل خاص عند إنشاء محرك مادي.  يمكن حل هذه المشكلة باستخدام طريقة <code>query</code> .  وفي الواقع ، يمكننا استدعاء <code>query</code> في المربع المحيط لجميع القيم.  ومع ذلك ، يمكن القيام بذلك بشكل أكثر كفاءة عن طريق إضافة تقاطع واحد فقط للزوج (مع <code>query</code> سنجدهم مرتين). <br><br>  لتحقيق هذا ، نحن بحاجة إلى النظر في أن التقاطع يمكن أن يحدث فقط <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  بين قيمتين المخزنة في عقدة واحدة </li></ul><br>  أو <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  بين القيمة المخزنة في العقدة وقيمة أخرى مخزنة في سليل هذه العقدة. </li></ul><br>  نتيجة لهذا ، نحتاج إلى التحقق من التقاطع بين: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  القيمة والقيم التالية المخزنة في نفس العقدة </li></ul><br>  و <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  القيمة والقيم المخزنة في السليل. </li></ul><br>  وبالتالي ، فإننا بالتأكيد لن نبلغ عن نفس التقاطع مرتين. <br><br>  فيما يلي رمز <code>findAllIntersections</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt; findAllIntersections() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> intersections = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt;(); findAllIntersections(mRoot.get(), intersections); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersections; }</code> </pre> <br>  مرة أخرى ، نحن ببساطة نخصص <code>std::vector</code> لتخزين التقاطعات واستدعاء وظيفة المساعد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllIntersections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find intersections between values stored in this node // Make sure to not report the same intersection twice for (auto i = std::size_t(0); i &lt; node-&gt;values.size(); ++i) { for (auto j = std::size_t(0); j &lt; i; ++j) { if (mGetBox(node-&gt;values[i]).intersects(mGetBox(node-&gt;values[j]))) intersections.emplace_back(node-&gt;values[i], node-&gt;values[j]); } } if (!isLeaf(node)) { // Values in this node can intersect values in descendants for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : node-&gt;values) findIntersectionsInDescendants(child.get(), value, intersections); } // Find intersections in children for (const auto&amp; child : node-&gt;children) findAllIntersections(child.get(), intersections); } }</span></span></code> </pre> <br>  في المرحلة الأولى ، يتم فحص التقاطعات بين القيم المخزنة في العقدة الحالية.  ثم ، إذا كانت العقدة الحالية داخلية ، فإن <code>findIntersectionInDescendants</code> عن التقاطعات بين القيم المخزنة في هذه العقدة والقيم المخزنة في أحفادها.  أخيرًا ، نجري مكالمات متكررة. <br><br>  <code>findIntersectionsInDescendants</code> بشكل متكرر <code>findIntersectionsInDescendants</code> التقاطعات بين القيمة المعطاة وجميع القيم المخزنة في الشجرة الفرعية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIntersectionsInDescendants</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Test against the values stored in this node for (const auto&amp; other : node-&gt;values) { if (mGetBox(value).intersects(mGetBox(other))) intersections.emplace_back(value, other); } // Test against values stored into descendants of this node if (!isLeaf(node)) { for (const auto&amp; child : node-&gt;children) findIntersectionsInDescendants(child.get(), value, intersections); } }</span></span></code> </pre> <br>  هذا كل شئ!  أكرر ، يتم نشر جميع التعليمات البرمجية على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جيثب</a> . <br><br><h1 style=";text-align:right;direction:rtl">  موارد مفيدة </h1><br>  إذا كنت ترغب في معرفة المزيد حول التعرف على التصادم وتقسيم هياكل البيانات ، فإنني أوصي بقراءة الكتاب بواسطة Christer Erickson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Real-Time Collision Detection</a> .  يتم الكشف عن العديد من المواضيع بعمق وفي نفس الوقت يتم كتابة الكتاب بلغة مفهومة للغاية.  علاوة على ذلك ، يمكن قراءة الفصول بشكل منفصل.  هذا هو مصدر مرجعي كبير. <br><br><h1 style=";text-align:right;direction:rtl">  استنتاج </h1><br>  هذا يكمل العمل مع التعرف على الاصطدام.  ومع ذلك ، هو فقط نصف المحرك المادي.  النصف الثاني هو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قرار الاصطدام</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar473066/">https://habr.com/ru/post/ar473066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar473056/index.html">كيف يتعرف أليس البلدان من الصور. بحث ياندكس</a></li>
<li><a href="../ar473058/index.html">سيرجي سينتسين: "OSM أكثر من مجرد رسم المنازل أو المسارات. هذه هي المزيد من القصص! "</a></li>
<li><a href="../ar473060/index.html">العلاقات غير الرسمية في الفريق: لماذا وكيف تديرها</a></li>
<li><a href="../ar473062/index.html">user.js ذاتي لـ Mozilla Firefox وليس فقط</a></li>
<li><a href="../ar473064/index.html">دموع باتافيا والسيارات وزجاج الغوريلا: حول بعض أنواع الزجاج المقوى</a></li>
<li><a href="../ar473070/index.html">استرجاع - ليست هناك حاجة! استبدال useContext و useReducer في رد الفعل؟</a></li>
<li><a href="../ar473072/index.html">كيف تقوم Gazpromneft بإنشاء مسار رقمي لعميل مشترك</a></li>
<li><a href="../ar473074/index.html">ما المقصود بـ APS ولماذا "لا تجعل خطة الإنتاج بالطريقة التي نريدها ..."</a></li>
<li><a href="../ar473078/index.html">بسهولة إدارة تكوينات microservice مع microconfig.io</a></li>
<li><a href="../ar473082/index.html">كيف نكتب خدمات micros ولماذا لا نفعل ذلك بسرعة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>