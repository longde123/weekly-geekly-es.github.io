<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç≠ üíÜüèº üñåÔ∏è .NET: Outils pour travailler avec le multithread et l'asynchronie - Partie 1 üèáüèº üêò üî§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai initialement publi√© cet article dans le blog CodingSight 
 La deuxi√®me partie de l'article est disponible ici 

 La n√©cessit√© de faire les choses...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Outils pour travailler avec le multithread et l'asynchronie - Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455252/">  <i>J'ai initialement publi√© cet article dans le blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CodingSight</a></i> <br>  <i>La deuxi√®me partie de l'article est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a></i> <br><br>  La n√©cessit√© de faire les choses de mani√®re asynchrone - c'est-√†-dire de diviser les grandes t√¢ches entre plusieurs unit√©s de travail - √©tait pr√©sente bien avant l'apparition des ordinateurs.  Cependant, lorsqu'ils sont apparus, ce besoin est devenu encore plus √©vident.  Nous sommes en 2019 et j'√©cris cet article sur un ordinateur portable aliment√© par un processeur Intel Core √† 8 c≈ìurs qui, en plus de cela, travaille simultan√©ment sur des centaines de processus, avec un nombre de threads encore plus important.  √Ä c√¥t√© de moi, se trouve un smartphone l√©g√®rement obsol√®te que j'ai achet√© il y a quelques ann√©es - et il abrite √©galement un processeur √† 8 c≈ìurs.  Les ressources Web sp√©cialis√©es contiennent une grande vari√©t√© d'articles faisant l'√©loge des smartphones phares de cette ann√©e √©quip√©s de processeurs 16 c≈ìurs.  Pour moins de 20 $ de l'heure, MS Azure peut vous donner acc√®s √† une machine virtuelle √† 128 c≈ìurs avec 2 To de RAM.  Mais, malheureusement, vous ne pouvez pas tirer le meilleur parti de ce pouvoir √† moins de savoir comment contr√¥ler l'interaction entre les threads. <br><a name="habracut"></a><br><h4>  Table des mati√®res </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Terminologie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une m√©taphore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Outils .NET</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©marrage d'un fil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Affichage et d√©bogage des threads</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que parall√®le de t√¢ches</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Arr√™t des threads</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformer une API h√©rit√©e en une API bas√©e sur les t√¢ches √† l'aide de FromAsync</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformer une API h√©rit√©e en une API bas√©e sur les t√¢ches √† l'aide de TaskCompletionSource</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trucs et astuces de TaskCompletionSource</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ValueTask: pourquoi et comment</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TaskScheduler: Contr√¥le des strat√©gies d'ex√©cution des t√¢ches</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PLinq et la classe parall√®le</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©sum√©</a> </li></ul><br><a name="Terminology"></a><br><h3>  Terminologie </h3><br>  <b>Processus</b> - un objet OS qui repr√©sente un espace d'adressage isol√© contenant des threads. <br><br>  <b>Thread</b> - un objet OS qui repr√©sente la plus petite unit√© d'ex√©cution.  Les threads sont des √©l√©ments constitutifs des processus, ils divisent la m√©moire et d'autres ressources entre eux dans le cadre d'un processus. <br><br>  <b>Multit√¢che</b> - une fonctionnalit√© du syst√®me d'exploitation qui repr√©sente la capacit√© d'ex√©cuter plusieurs processus simultan√©ment. <br><br>  <b>Multi-core</b> - une fonction CPU qui repr√©sente la possibilit√© d'utiliser plusieurs c≈ìurs pour le traitement des donn√©es <br><br>  <b>Multiprocessing</b> - la caract√©ristique d'un ordinateur qui repr√©sente la capacit√© de travailler physiquement avec plusieurs CPU. <br><br>  <b>Multi-threading</b> - la caract√©ristique d'un processus qui repr√©sente la capacit√© de diviser et de r√©partir le traitement des donn√©es entre plusieurs threads. <br><br>  <b>Parall√©lisme</b> - ex√©cution physique simultan√©e de plusieurs actions dans une unit√© de temps <br><br>  <b>Asynchronie</b> - ex√©cuter une op√©ration sans attendre qu'elle soit enti√®rement trait√©e, laissant le calcul du r√©sultat pour plus tard. <br><br><a name="Metaphor"></a><br><h3>  Une m√©taphore </h3><br>  Toutes les d√©finitions ne sont pas efficaces et certaines d'entre elles n√©cessitent une √©laboration, alors permettez-moi de fournir une m√©taphore culinaire pour la terminologie que je viens d'introduire. <br><br>  Faire le petit d√©jeuner repr√©sente un <b>processus</b> dans cette m√©taphore. <br><br>  En faisant le petit d√©jeuner le matin, je ( <b>CPU</b> ) vais √† la cuisine ( <b>Ordinateur</b> ).  J'ai deux mains ( <b>noyaux</b> ).  Sur la cuisine, il y a un assortiment d'appareils ( <b>IO</b> ): cuisini√®re, bouilloire, grille-pain, r√©frig√©rateur.  J'allume le po√™le, y mets une po√™le et y verse de l'huile v√©g√©tale.  Sans attendre que l'huile se r√©chauffe ( <b>asynchrone, non bloquant-IO-Wait</b> ), je r√©cup√®re des ≈ìufs du r√©frig√©rateur, les casse sur un bol et puis je les fouette d'une main ( <b>fil # 1</b> ).  Pendant ce temps, la seconde main (Thread # 2) tient le bol en place ( <b>Shared Resource</b> ).  Je voudrais allumer la bouilloire, mais je n'ai pas assez de mains libres pour le moment ( <b>Thread Starvation</b> ).  Pendant que je fouettais les ≈ìufs, la po√™le est devenue assez chaude (traitement des r√©sultats), alors j'ai vers√© les ≈ìufs fouett√©s dedans.  J'atteins la bouilloire, l'allume et regarde l'eau bouillante ( <b>Blocking-IO-Wait</b> ) - mais j'aurais pu utiliser cette fois pour laver le bol. <br><br>  Je n'ai utilis√© que 2 mains pour faire l'omelette (car je n'en ai pas plus), mais il y a eu 3 op√©rations simultan√©es en cours d'ex√©cution: fouetter les ≈ìufs, tenir le bol, chauffer la po√™le.  Le CPU est la partie la plus rapide de l'ordinateur et IO est la partie qui n√©cessite d'attendre le plus souvent, il est donc assez efficace de charger le CPU avec du travail pendant qu'il attend les donn√©es d'IO. <br><br>  Pour √©tendre la m√©taphore: <br><br><ul><li>  Si j'essayais √©galement de changer de v√™tements pendant le petit-d√©jeuner, j'aurais √©t√© <b>multit√¢che</b> .  Les ordinateurs sont bien meilleurs √† cet √©gard que les humains. </li><li>  Une cuisine avec plusieurs cuisiniers - par exemple, dans un restaurant - est un ordinateur <b>multic≈ìur</b> . </li><li>  Une aire de restauration de centre commercial avec de nombreux restaurants repr√©senterait un <b>centre de donn√©es</b> . </li></ul><br><br><a name="NetTools"></a><br><h3>  Outils .NET </h3><br>  .NET est vraiment bon quand il s'agit de travailler avec des threads - ainsi qu'√† bien d'autres choses.  Avec chaque nouvelle version, il fournit plus d'outils pour travailler avec des threads et de nouvelles couches d'abstraction de threads OS.  Lorsqu'ils travaillent avec des abstractions, les d√©veloppeurs travaillant avec le framework utilisent une approche qui leur permet de descendre une ou plusieurs couches tout en utilisant des abstractions de haut niveau.  Dans la plupart des cas, cela n'est pas vraiment n√©cessaire (et cela peut introduire une possibilit√© de se tirer une balle dans le pied), mais parfois, cela peut √™tre le seul moyen de r√©soudre un probl√®me qui ne peut pas √™tre r√©solu au niveau d'abstraction actuel. <br><br>  Lorsque j'ai parl√© des outils plus t√¥t, je parlais √† la fois des interfaces de programme (API) fournies par le cadre ou des packages tiers et des solutions logicielles √† part enti√®re qui simplifient le processus de recherche de probl√®mes li√©s au code multithread. <br><br><a name="StartingAThread"></a><br><h4>  D√©marrage d'un fil </h4><br>  La classe Thread est la classe .NET la plus basique pour travailler avec des threads.  Son constructeur accepte l'un de ces deux d√©l√©gu√©s: <br><br><ul><li>  ThreadStart - aucun param√®tre </li><li>  ParametrizedThreadStart - un param√®tre de type objet. </li></ul><br><br>  Le d√©l√©gu√© sera ex√©cut√© dans un thread nouvellement cr√©√© apr√®s avoir appel√© la m√©thode Start.  Si le d√©l√©gu√© ParametrizedThreadStart a √©t√© pass√© au constructeur, alors un objet doit √™tre pass√© √† la m√©thode Start.  Ce processus est n√©cessaire pour transmettre toute information locale au thread.  Je dois souligner qu'il faut beaucoup de ressources pour cr√©er un thread et que le thread lui-m√™me est un objet lourd - au moins parce qu'il n√©cessite une interaction avec l'API du syst√®me d'exploitation et 1 Mo de m√©moire est allou√© √† la pile. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  La classe ThreadPool repr√©sente le concept d'un pool.  Dans .NET, le pool de threads est une ≈ìuvre d'art d'ing√©nierie et les d√©veloppeurs Microsoft ont investi beaucoup d'efforts pour le faire fonctionner de mani√®re optimale dans toutes sortes de sc√©narios. <br><br>  <b>Le concept g√©n√©ral:</b> <br>  <i>Au d√©marrage, l'application cr√©e quelques threads en arri√®re-plan, permettant d'y acc√©der en cas de besoin.</i>  <i>Si les threads sont utilis√©s fr√©quemment et en grand nombre, le pool est √©tendu pour r√©pondre aux besoins du code appelant.</i>  <i>Si le pool n'a pas suffisamment de threads libres au bon moment, il attendra que l'un des threads actifs devienne inoccup√© ou en cr√©era un nouveau.</i>  <i>Sur cette base, il s'ensuit que le pool de threads est parfait pour les actions courtes et ne fonctionne pas si bien pour les processus qui fonctionnent comme des services pendant toute la dur√©e de fonctionnement de l'application.</i> <br><br>  La m√©thode QueueUserWorkItem permet d'utiliser des threads du pool.  Cette m√©thode prend le <i>d√©l√©gu√© de</i> type <i>WaitCallback</i> .  Sa signature co√Øncide avec la signature de ParametrizedThreadStart et le param√®tre qui lui est transmis remplit le m√™me r√¥le. <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  La m√©thode de pool de threads RegisterWaitForSingleObject moins connue est utilis√©e pour organiser les op√©rations d'E / S non bloquantes.  Le d√©l√©gu√© qui est pass√© √† cette m√©thode sera appel√© lorsque le WaitHandle est lib√©r√© apr√®s avoir √©t√© pass√© √† la m√©thode. <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br><br>  Il existe un temporisateur de threads dans .NET, et il diff√®re des temporisateurs WinForms / WPF en ce que son gestionnaire est appel√© dans le thread extrait du pool. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br><br>  Il existe √©galement un moyen assez inhabituel d'envoyer le d√©l√©gu√© √† un thread √† partir du pool - la m√©thode BeginInvoke. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br><br>  Je voudrais √©galement jeter un coup d'≈ìil √† la fonction que la plupart des m√©thodes que j'ai mentionn√©es pr√©c√©demment se r√©sument √† - CreateThread de l'API Win32 Kernel32.dll.  Il existe un moyen d'appeler cette fonction √† l'aide du m√©canisme externe des m√©thodes.  Je n'ai vu cela √™tre utilis√© qu'une seule fois dans un cas particuli√®rement mauvais de code h√©rit√© - et je ne comprends toujours pas les raisons de son auteur. <br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><br><a name="ViewingAndDebuggingThreads"></a><br><h4>  Affichage et d√©bogage des threads </h4><br>  Tous les threads - qu'ils soient cr√©√©s par vous, des composants tiers ou le pool .NET - peuvent √™tre affich√©s dans la fen√™tre <b>Threads de</b> Visual Studio.  Cette fen√™tre n'affichera les informations sur les threads que lorsque l'application est en cours de d√©bogage en mode Arr√™t.  Ici, vous pouvez afficher les noms et les priorit√©s de chaque thread et concentrer le mode de d√©bogage sur des threads sp√©cifiques.  La propri√©t√© Priority de la classe Thread vous permet de d√©finir la priorit√© du thread.  Cette priorit√© sera alors prise en consid√©ration lorsque le syst√®me d'exploitation et le CLR r√©partissent le temps processeur entre les threads. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><a name="TaskParallelLibrary"></a><br><h4>  Biblioth√®que parall√®le de t√¢ches </h4><br>  La biblioth√®que parall√®le de t√¢ches (TPL) est apparue pour la premi√®re fois dans .NET 4.0.  Actuellement, c'est l'outil principal pour travailler avec l'asynchronie.  Tout code utilisant des approches plus anciennes sera consid√©r√© comme du code h√©rit√©.  L'unit√© principale de TPL est la classe <b>Task</b> de l'espace de noms System.Threading.Tasks.  Les t√¢ches repr√©sentent l'abstraction des threads.  Avec la derni√®re version de C #, nous avons acquis une nouvelle fa√ßon √©l√©gante de travailler avec les t√¢ches - les op√©rateurs asynchrones / attendent.  Celles-ci permettent d'√©crire du code asynchrone comme s'il √©tait simple et synchrone, de sorte que ceux qui ne connaissent pas bien la th√©orie des threads peuvent d√©sormais √©crire des applications qui n'auront pas de difficult√© avec de longues op√©rations.  Utiliser async / wait est vraiment un sujet pour un article s√©par√© (ou m√™me quelques articles), mais je vais essayer de d√©crire les bases en quelques phrases: <br><br><ul><li>  async est un modificateur d'une m√©thode qui renvoie une t√¢che ou un vide </li><li>  attend est un op√©rateur d'une t√¢che d'attente non bloquante. </li></ul><br><br>  Encore une fois: l'op√©rateur wait laissera g√©n√©ralement (il y a des exceptions) le thread courant et, lorsque la t√¢che sera ex√©cut√©e et le thread (en fait, le contexte, mais nous y reviendrons plus tard) sera libre en tant que Par cons√©quent, il continuera √† ex√©cuter la m√©thode.  Dans .NET, ce m√©canisme est impl√©ment√© de la m√™me mani√®re que yield return - une m√©thode est transform√©e en une classe de machine √† √©tats finis qui peut √™tre ex√©cut√©e en plusieurs morceaux en fonction de son √©tat.  Si cela semble int√©ressant, je recommanderais d'√©crire n'importe quel morceau de code simple bas√© sur async / wait, de le compiler et de regarder sa compilation √† l'aide de JetBrains dotPeek avec le code g√©n√©r√© par le compilateur activ√©. <br><br>  Examinons les options dont nous disposons lorsqu'il s'agit de d√©marrer et d'utiliser une t√¢che.  Dans l'exemple ci-dessous, nous cr√©ons une nouvelle t√¢che qui ne fait rien de productif (Thread.Sleep (10000)).  Cependant, dans les cas r√©els, nous devons le remplacer par un travail complexe qui utilise les ressources du processeur. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br><br>  Une t√¢che est cr√©√©e avec les options suivantes: <br><br><ul><li>  LongRunning - cette option indique que la t√¢che ne peut pas √™tre effectu√©e rapidement.  Par cons√©quent, il est peut-√™tre pr√©f√©rable de cr√©er un thread distinct pour cette t√¢che plut√¥t que d'en prendre un existant dans le pool pour minimiser les dommages caus√©s aux autres t√¢ches. </li><li>  AttachedToParent - Les t√¢ches peuvent √™tre organis√©es de mani√®re hi√©rarchique.  Si cette option est utilis√©e, la t√¢che attendra que ses t√¢ches enfants soient ex√©cut√©es apr√®s avoir √©t√© ex√©cut√©e elle-m√™me. </li><li>  PreferFairness - cette option sp√©cifie que la t√¢che doit √™tre mieux ex√©cut√©e avant les t√¢ches qui ont √©t√© cr√©√©es ult√©rieurement.  Cependant, c'est plus une suggestion, donc le r√©sultat n'est pas toujours garanti. </li></ul><br><br>  Le deuxi√®me param√®tre transmis √† la m√©thode est CancellationToken.  Pour que l'op√©ration soit correctement annul√©e apr√®s son d√©marrage, le code ex√©cutable doit contenir des v√©rifications d'√©tat CancellationToken.  S'il n'y a pas de telles v√©rifications, la m√©thode Cancel appel√©e sur l'objet CancellationTokenSource ne pourra arr√™ter l'ex√©cution de la t√¢che qu'avant le d√©marrage de la t√¢che. <br><br>  Pour le dernier param√®tre, nous avons envoy√© un objet de type TaskScheduler appel√© ordonnanceur.  Cette classe, avec ses classes enfants, est utilis√©e pour contr√¥ler la r√©partition des t√¢ches entre les threads.  Par d√©faut, une t√¢che sera ex√©cut√©e sur un thread s√©lectionn√© au hasard dans le pool <br><br>  L'op√©rateur d'attente est appliqu√© √† la t√¢che cr√©√©e.  Cela signifie que le code √©crit apr√®s (s'il existe un tel code) sera ex√©cut√© dans le m√™me contexte (souvent, cela signifie ¬´sur le m√™me thread¬ª) que le code √©crit avant l'attend. <br><br>  Cette m√©thode est √©tiquet√©e comme async void, ce qui signifie que l'op√©rateur d'attente peut y √™tre utilis√©, mais le code appelant ne pourra pas attendre l'ex√©cution.  Si une telle possibilit√© est n√©cessaire, la m√©thode doit renvoyer une t√¢che.  Les m√©thodes √©tiquet√©es comme async void peuvent √™tre vues assez souvent: ce sont g√©n√©ralement des gestionnaires d'√©v√©nements ou d'autres m√©thodes fonctionnant sous le principe du feu et de l'oubli.  S'il est n√©cessaire d'attendre la fin de l'ex√©cution et de renvoyer le r√©sultat, vous devez utiliser Task. <br><br>  Pour les t√¢ches qui renvoient la m√©thode StartNew, nous pouvons appeler ConfigureAwait avec le faux param√®tre - puis, l'ex√©cution apr√®s attente se poursuivra sur un contexte al√©atoire au lieu d'un contexte captur√©.  Cela doit toujours √™tre fait si le code √©crit apr√®s l'attente ne n√©cessite pas de contexte d'ex√©cution sp√©cifique.  Il s'agit √©galement d'une recommandation de MS lorsqu'il s'agit d'√©crire du code fourni sous forme de biblioth√®que. <br><br>  Voyons comment nous pouvons attendre la fin d'une t√¢che.  Ci-dessous, vous pouvez voir un exemple de code avec des commentaires indiquant quand l'attente est impl√©ment√©e de mani√®re relativement bonne ou mauvaise. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  Dans le premier exemple, nous attendons que la t√¢che soit ex√©cut√©e sans bloquer le thread appelant, nous reviendrons donc au traitement du r√©sultat lorsqu'il sera pr√™t.  Avant cela, le thread appelant est laiss√© seul. <br><br>  Dans la deuxi√®me tentative, nous bloquons le thread appelant jusqu'√† ce que le r√©sultat de la m√©thode soit calcul√©.  Il s'agit d'une mauvaise approche pour deux raisons.  Tout d'abord, nous gaspillons un fil - une ressource tr√®s pr√©cieuse - sur une simple attente.  De plus, si la m√©thode que nous appelons contient une attente tandis qu'un retour au thread appelant apr√®s l'attente est pr√©vu par le contexte de synchronisation, nous obtiendrons un blocage.  Cela se produit car le thread appelant attendra le r√©sultat d'une m√©thode asynchrone et la m√©thode asynchrone elle-m√™me tentera sans succ√®s de continuer son ex√©cution dans le thread appelant. <br><br>  Un autre inconv√©nient de cette approche est la complexit√© accrue de la gestion des erreurs.  Les erreurs peuvent en fait √™tre g√©r√©es assez facilement en code asynchrone si async / wait est utilis√© - le processus dans ce cas est identique √† celui en code synchrone.  Cependant, lorsqu'une attente synchrone est appliqu√©e √† une t√¢che, l'exception initiale est encapsul√©e dans AggregateException.  En d'autres termes, pour g√©rer l'exception, nous aurions besoin d'explorer le type InnerException et d'√©crire manuellement une cha√Æne if dans un bloc catch ou, alternativement, d'utiliser la structure catch when au lieu de la cha√Æne plus habituelle de blocs catch. <br><br>  Les deux derniers exemples sont √©galement √©tiquet√©s comme relativement mauvais pour les m√™mes raisons et contiennent tous les deux les m√™mes probl√®mes. <br><br>  Les m√©thodes WhenAny et WhenAll sont tr√®s utiles lorsqu'il s'agit d'attendre un groupe de t√¢ches - elles regroupent ces t√¢ches en une seule et elles seront ex√©cut√©es soit lorsqu'une t√¢che du groupe est d√©marr√©e, soit lorsque toutes ces t√¢ches sont ex√©cut√©es avec succ√®s. <br><br><a name="StoppingThreads"></a><br><h4>  Arr√™t des threads </h4><br>  Pour diverses raisons, il peut √™tre n√©cessaire d'arr√™ter un thread apr√®s son d√©marrage.  Il existe plusieurs fa√ßons de proc√©der.  La classe Thread a deux m√©thodes avec des noms appropri√©s - <b>Abort</b> et <b>Interruption</b> .  Je d√©conseille fortement d'utiliser le premier car, apr√®s son appel, il y aurait une <b>exception ThreadAbortedException</b> √† tout moment al√©atoire lors du traitement de toute instruction choisie arbitrairement.  Vous ne vous attendez pas √† ce qu'une telle exception se produise lorsqu'une variable enti√®re est incr√©ment√©e, non?  Eh bien, lorsque vous utilisez la m√©thode Abort, cela devient une r√©elle possibilit√©.  Si vous devez refuser la capacit√© du CLR √† cr√©er de telles exceptions dans une partie sp√©cifique du code, vous pouvez l' <b>encapsuler</b> <b>dans les</b> appels <b>Thread. BeginCriticalRegion</b> et <b>Thread.EndCriticalRegion</b> .  Tout code √©crit dans le bloc finally est encapsul√© dans ces appels.  C'est pourquoi vous pouvez trouver des blocs avec un essai vide et un non-vide enfin dans les profondeurs du code framework.  Microsoft n'aime pas cette m√©thode au point de ne pas l'inclure dans le noyau .NET. <br><br>  La m√©thode d' <b>interruption</b> fonctionne d'une mani√®re beaucoup plus pr√©visible.  Il peut interrompre un thread avec une <b>ThreadInterruptedException</b> uniquement lorsque le thread est en mode d'attente.  Il passe √† cet √©tat lorsqu'il est suspendu en attendant WaitHandle, un verrou ou apr√®s l'appel de Thread.Sleep. <br><br>  Ces deux m√©thodes pr√©sentent un inconv√©nient d'impr√©visibilit√©.  Pour √©chapper √† ce probl√®me, nous devons utiliser la structure <b>CancellationToken</b> et la classe <b>CancellationTokenSource</b> .  L'id√©e g√©n√©rale est la suivante: une instance de la classe CancellationTokenSource est cr√©√©e, et seuls ceux qui en sont propri√©taires peuvent arr√™ter l'op√©ration en appelant la m√©thode <b>Cancel</b> .  Seul CancellationToken est transmis √† l'op√©ration.  Les propri√©taires de CancellationToken ne peuvent pas annuler l'op√©ration eux-m√™mes - ils peuvent uniquement v√©rifier si l'op√©ration a √©t√© annul√©e.  Cela peut √™tre r√©alis√© en utilisant une propri√©t√© bool√©enne <b>IsCancellationRequested</b> et la m√©thode <b>ThrowIfCancelRequested</b> .  Le dernier g√©n√©rera une <b>TaskCancelledException</b> si la m√©thode Cancel a √©t√© appel√©e sur l'instance CancellationTokenSource qui a cr√©√© le CancellationToken.  C'est la m√©thode que je recommande d'utiliser.  Son avantage par rapport aux m√©thodes d√©crites pr√©c√©demment r√©side dans le fait qu'il offre un contr√¥le total sur les cas d'exception exacts dans lesquels une op√©ration peut √™tre annul√©e. <br><br>  La fa√ßon la plus brutale d'arr√™ter un thread serait d'appeler une fonction API Win32 appel√©e TerminateThread.  Une fois cette fonction appel√©e, le comportement du CLR peut √™tre assez impr√©visible.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MSDN</a> , ce qui suit est √©crit sur cette fonction: <i>¬´TerminateThread est une fonction dangereuse qui ne doit √™tre utilis√©e que dans les cas les plus extr√™mes.</i>  <i>"</i> <br><br><a name="FromAsync"></a><br><h4>  Transformer une API h√©rit√©e en une API bas√©e sur les t√¢ches √† l'aide de FromAsync </h4><br>  Si vous avez eu la chance de travailler sur un projet qui a √©t√© lanc√© apr√®s l'introduction des t√¢ches (et lorsqu'elles n'incitent plus √† l'horreur existentielle chez la plupart des d√©veloppeurs), vous n'aurez pas √† vous occuper des anciennes API - √† la fois la tierce partie celles et ceux sur lesquels votre √©quipe a travaill√© dans le pass√©.  Heureusement, l'√©quipe de d√©veloppement de .NET Framework nous a facilit√© la t√¢che - mais cela aurait pu √™tre une prise en charge personnelle, pour tout ce que nous savons.  Dans tous les cas, .NET dispose de quelques outils qui permettent de rapprocher en toute transparence le code √©crit avec les anciennes approches √† une forme mise √† jour.  L'un d'eux est la m√©thode TaskFactory appel√©e FromAsync.  Dans l'exemple ci-dessous, j'encapsule les anciennes m√©thodes asynchrones de la classe WebRequest dans une t√¢che √† l'aide de FromAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>Ce n'est qu'un exemple, et vous ne ferez probablement pas quelque chose de ce genre avec des types int√©gr√©s.</i>  <i>Cependant, les anciens projets regorgent de m√©thodes BeginDoSomething qui renvoient les m√©thodes IAsyncResult et EndDoSomething qui les re√ßoivent.</i> <br><br><a name="TaskCompletionSource"></a><br><h4>  Transformer une API h√©rit√©e en une API bas√©e sur les t√¢ches √† l'aide de TaskCompletionSource </h4><br>  Un autre outil √† explorer est la classe <b>TaskCompletionSource</b> .  Dans sa fonctionnalit√©, son objectif et son principe de fonctionnement, il ressemble √† la m√©thode RegisterWaitForSingleObject de la classe ThreadPool que j'ai mentionn√©e pr√©c√©demment.  Cette classe nous permet d'encapsuler facilement les anciennes API asynchrones dans des t√¢ches. <br><br>  <i>Vous voudrez peut-√™tre dire que j'ai d√©j√† parl√© de la m√©thode FromAsync de la classe TaskFactory qui a servi ces objectifs.</i>  <i>Ici, nous devons nous souvenir de l'historique complet des mod√®les asynchrones fournis par Microsoft au cours des 15 derni√®res ann√©es: avant les mod√®les asynchrones bas√©s sur les t√¢ches (TAP), il existait des mod√®les de programmation asynchrones (APP).</i>  <i>Les applications √©taient toutes destin√©es √† <b>Begin</b> DoSomething renvoyant IAsyncResult et √† la m√©thode <b>End</b> DoSomething qui l'accepte - et la m√©thode FromAsync est parfaite pour l'h√©ritage de ces ann√©es.</i>  <i>Cependant, au fil du temps, cela a √©t√© remplac√© par des mod√®les asynchrones bas√©s sur les √©v√©nements (EAP) qui sp√©cifiaient qu'un √©v√©nement est appel√© lorsqu'une op√©ration asynchrone est ex√©cut√©e avec succ√®s.</i> <br><br>  TaskCompletionSource sont parfaits pour encapsuler des API h√©rit√©es construites autour du mod√®le d'√©v√©nement dans des t√¢ches.  Voici comment cela fonctionne: les objets de cette classe ont une propri√©t√© publique appel√©e Task, dont l'√©tat peut √™tre contr√¥l√© par diff√©rentes m√©thodes de la classe TaskCompletionSource (SetResult, SetException etc.).  Aux endroits o√π l'op√©rateur d'attente a √©t√© appliqu√© √† cette t√¢che, il sera ex√©cut√© ou bloqu√© avec une exception selon la m√©thode appliqu√©e √† TaskCompletionSource.  Pour mieux le comprendre, regardons cet exemple de code.  Ici, certaines anciennes API de l'√®re EAP sont envelopp√©es dans une t√¢che √† l'aide de TaskCompletionSource: lorsqu'un √©v√©nement est d√©clench√©, la t√¢che passe √† l'√©tat Termin√© tandis que la m√©thode qui a appliqu√© l'op√©rateur d'attente √† cette t√¢che continue son ex√©cution. apr√®s avoir re√ßu un objet <b>r√©sultat</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><a name="TaskCompletionSourceTips"></a><br><h4>  Trucs et astuces de TaskCompletionSource </h4><br>  TaskCompletionSource peut faire plus que simplement encapsuler des API obsol√®tes.  Cette classe ouvre une possibilit√© int√©ressante de concevoir diverses API bas√©es sur des t√¢ches qui n'occupent pas de threads.  Un thread, comme nous nous en souvenons, est une ressource co√ªteuse limit√©e principalement par la RAM.  Nous pouvons facilement atteindre cette limite lors du d√©veloppement d'une application Web robuste avec une logique m√©tier complexe.  Examinons les capacit√©s que j'ai mentionn√©es en action en impl√©mentant une astuce connue sous le nom de Long Polling. <br><br>  <b>En bref, voici comment fonctionne l'interrogation longue:</b> <br>  <i>Vous devez obtenir des informations d'une API sur les √©v√©nements qui se produisent de son c√¥t√©, mais l'API, pour une raison quelconque, ne peut que renvoyer un √©tat plut√¥t que de vous informer de l'√©v√©nement.</i>  <i>Un exemple serait une API construite sur HTTP avant l'apparition de WebSocket ou dans des circonstances o√π cette technologie ne peut pas √™tre utilis√©e.</i>  <i>Le client peut demander au serveur HTTP.</i>  <i>Le serveur HTTP, en revanche, ne peut pas initier seul le contact avec le client.</i>  <i>La solution la plus simple serait de demander au serveur p√©riodiquement √† l'aide d'un minuteur, mais cela cr√©erait une charge suppl√©mentaire pour le serveur et un d√©lai g√©n√©ral qui √©quivaut approximativement √† TimerInterval / 2. Pour contourner cela, le Long Polling a √©t√© invent√©.</i>  <i>Cela implique de retarder la r√©ponse du serveur jusqu'√† l'expiration du d√©lai d'expiration ou jusqu'√† ce qu'un √©v√©nement se produise.</i>  <i>Si un √©v√©nement se produit, il sera trait√©;</i>  <i>sinon, la demande sera envoy√©e √† nouveau.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Cependant, l'efficacit√© de cette solution diminuera radicalement si le nombre de clients en attente de l'√©v√©nement augmente - chaque client en attente occupe un thread complet.  De plus, nous obtenons un d√©lai suppl√©mentaire de 1 ms pour le d√©clenchement d'√©v√©nements.  Souvent, ce n'est pas vraiment crucial, mais pourquoi rendrions-nous notre logiciel pire qu'il ne pourrait l'√™tre?  D'un autre c√¥t√©, si nous supprimons Thread.Sleep (1), l'un des c≈ìurs de processeur sera charg√© √† 100% sans rien faire dans un cycle inutile.  Avec l'aide de TaskCompletionSource, nous pouvons facilement transformer notre code pour r√©soudre tous les probl√®mes que nous avons mentionn√©s: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Veuillez garder √† l'esprit que ce morceau de code n'est qu'un exemple, et en aucun cas pr√™t pour la production.</i>  <i>Pour l'utiliser dans des cas r√©els, nous aurions au moins besoin d'ajouter un moyen de g√©rer les situations dans lesquelles un message est re√ßu alors que rien ne l'attendait: dans ce cas, la m√©thode AcceptMessageAsync devrait renvoyer une t√¢che d√©j√† termin√©e.</i>  <i>Si ce cas est le plus courant, nous pouvons envisager d'utiliser ValueTask.</i> <br><br>  Lors de la r√©ception d'une demande de message, nous cr√©ons un TaskCompletionSource, le pla√ßons dans un dictionnaire, puis attendons l'un des √©v√©nements suivants: soit l'intervalle de temps sp√©cifi√© est pass√©, soit un message est re√ßu. <br><br><a name="ValueTask"></a><br><h4>  ValueTask: pourquoi et comment </h4><br>  Les op√©rateurs asynchrones / attendent, tout comme l'op√©rateur return return, g√©n√®rent une machine √† √©tats finis √† partir d'une m√©thode, ce qui signifie cr√©er un nouvel objet - cela n'a pas vraiment d'importance la plupart du temps, mais peut toujours cr√©er des probl√®mes dans de rares cas.  Un de ces cas peut se produire avec des m√©thodes fr√©quemment appel√©es - nous parlons de dizaines et de centaines de milliers d'appels par seconde.  Si une telle m√©thode est √©crite d'une mani√®re qui lui fait retourner le r√©sultat tout en contournant toutes les m√©thodes d'attente dans la plupart des cas, .NET fournit un outil d'optimisation pour cela - la structure ValueTask.  Pour comprendre comment cela fonctionne, regardons un exemple.  Supposons qu'il existe un cache auquel nous acc√©dons r√©guli√®rement.  S'il y a des valeurs, nous les renvoyons simplement;  s'il n'y a pas de valeurs - nous essayons de les obtenir √† partir d'un IO lent.  Cette derni√®re devrait id√©alement √™tre effectu√©e de mani√®re asynchrone, donc toute la m√©thode sera asynchrone.  Ainsi, la fa√ßon la plus √©vidente d'impl√©menter cette m√©thode sera la suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br>  Avec un d√©sir de l'optimiser un peu et un souci de ce que Roslyn g√©n√©rera lors de la compilation de ce code, nous pourrions r√©√©crire la m√©thode comme ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br>  Cependant, la meilleure solution dans ce cas serait d'optimiser le hot-path - en particulier, obtenir des valeurs de dictionnaire sans allocations inutiles et sans charge sur GC.  Pendant ce temps, dans les cas peu fr√©quents o√π nous devons obtenir des donn√©es d'E / S, les choses resteront presque les m√™mes: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br>  Examinons de plus pr√®s ce fragment de code: si une valeur est pr√©sente dans le cache, nous cr√©erons une structure;  sinon, la vraie t√¢che sera envelopp√©e dans une ValueTask.  Le chemin par lequel ce code est ex√©cut√© n'est pas important pour le code appelant: du point de vue de la syntaxe C #, une ValueTask se comportera comme une t√¢che habituelle. <br><br><a name="TaskScheduler"></a><br><h4>  TaskScheduler: Contr√¥le des strat√©gies d'ex√©cution des t√¢ches </h4><br>  La prochaine API dont je voudrais parler est la classe <b>TaskScheduler</b> et celles qui en d√©rivent.  J'ai d√©j√† mentionn√© que TPL fournit une capacit√© de contr√¥ler exactement comment les t√¢ches sont r√©parties entre les threads.  Ces strat√©gies sont d√©finies dans des classes h√©rit√©es de TaskScheduler.  Presque toutes les strat√©gies dont nous pourrions avoir besoin se trouvent dans la biblioth√®que <b>ParallelExtensionsExtras</b> .  Cette biblioth√®que est d√©velopp√©e par Microsoft, mais ne fait pas partie de .NET - elle est plut√¥t distribu√©e sous forme de package Nuget.  Voyons quelques-unes des strat√©gies: <br><br><ul><li>  CurrentThreadTaskScheduler - ex√©cute des t√¢ches sur le thread actuel </li><li>  LimitedConcurrencyLevelTaskScheduler - limite le nombre de t√¢ches ex√©cut√©es simultan√©ment en utilisant le param√®tre N qu'il accepte dans le constructeur </li><li>  OrderedTaskScheduler - est d√©fini comme LimitedConcurrencyLevelTaskScheduler (1), donc les t√¢ches seront ex√©cut√©es s√©quentiellement. </li><li>  WorkStealingTaskScheduler - impl√©mente l'approche de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vol</a> de travail pour l'ex√©cution des t√¢ches.  Essentiellement, il peut √™tre consid√©r√© comme un ThreadPool distinct.  Cela aide √† r√©soudre le probl√®me de ThreadPool en tant que classe statique dans .NET - s'il est surcharg√© ou utilis√© de mani√®re incorrecte dans une partie de l'application, des effets secondaires d√©sagr√©ables peuvent se produire √† un endroit diff√©rent.  Les causes r√©elles de ces d√©fauts peuvent √™tre difficiles √† localiser, vous devrez donc peut-√™tre utiliser des WorkStealingTaskSchedulers distincts dans les parties de l'application o√π l'utilisation de ThreadPool peut √™tre agressive et impr√©visible. </li><li>  QueuedTaskScheduler - permet d'ex√©cuter des t√¢ches sur la base d'une file d'attente prioritaire </li><li>  ThreadPerTaskScheduler - cr√©e un thread s√©par√© pour chaque t√¢che qui y est ex√©cut√©e.  Cela peut √™tre utile pour les t√¢ches dont le temps d'ex√©cution ne peut pas √™tre estim√©. </li></ul><br>  Il y a un tr√®s bon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur TaskSchedulers sur le blog de Microsoft, alors n'h√©sitez pas √† le consulter. <br><br>  Dans Visual Studio, il existe une fen√™tre T√¢ches qui peut vous aider √† d√©boguer tout ce qui concerne les t√¢ches.  Dans cette fen√™tre, vous pouvez voir l'√©tat de la t√¢che et acc√©der √† la ligne de code actuellement ex√©cut√©e. <br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><a name="PLinq"></a><br><h4>  PLinq et la classe parall√®le </h4><br>  Mis √† part les t√¢ches et toutes les choses qui leur sont li√©es, il existe deux outils suppl√©mentaires dans .NET que nous pouvons trouver int√©ressants - <b>PLinq</b> (Linq2Parallel) et la classe <b>Parallel</b> .  La premi√®re promet l'ex√©cution parall√®le de toutes les op√©rations Linq sur tous les threads.  Le nombre de threads peut √™tre configur√© par une m√©thode d'extension WithDegreeOfParallelism.  Malheureusement, dans la plupart des cas, PLinq en mode par d√©faut n'aura pas suffisamment d'informations sur la source de donn√©es pour fournir une augmentation significative de la vitesse.  En revanche, le co√ªt de l'essai est tr√®s faible: il suffit d'appeler <b>AsParallel</b> avant la cha√Æne de m√©thodes Linq et de r√©aliser des tests de performances.  De plus, vous pouvez transmettre des informations suppl√©mentaires sur la nature de votre source de donn√©es √† PLinq en utilisant le m√©canisme de partitions.  Vous pouvez trouver plus d'informations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  La classe statique Parallel fournit des m√©thodes pour √©num√©rer les collections en parall√®le via Foreach, ex√©cuter le cycle For et ex√©cuter plusieurs d√©l√©gu√©s en parall√®le √† Invoke.  L'ex√©cution du thread actuel sera arr√™t√©e jusqu'√† ce que les r√©sultats soient calcul√©s.  Vous pouvez configurer le nombre de threads en passant ParallelOptions comme dernier argument.  TaskScheduler et CancellationToken peuvent √©galement √™tre d√©finis √† l'aide d'options. <br><br><a name="Summary"></a><br><h3>  R√©sum√© </h3><br>  Quand j'ai commenc√© √† √©crire cet article sur la base de ma th√®se et des connaissances que j'ai acquises en travaillant apr√®s, je ne pensais pas qu'il y aurait autant d'informations.  Maintenant, avec l'√©diteur de texte qui me dit avec reproche que j'ai √©crit pr√®s de 15 pages, je voudrais tirer une conclusion interm√©diaire.  Nous examinerons d'autres techniques, API, outils visuels et dangers cach√©s dans le prochain article. <br><br>  <b>Conclusions:</b> <br><br><ul><li>  Pour utiliser efficacement les ressources des PC modernes, vous auriez besoin de conna√Ætre les outils pour travailler avec les threads, l'asynchronie et le parall√©lisme. </li><li>  Il existe de nombreux outils comme celui-ci dans .NET </li><li>  Tous n'ont pas √©t√© cr√©√©s en m√™me temps, vous pouvez donc souvent rencontrer du code h√©rit√© - mais il existe des moyens de transformer les anciennes API avec peu d'effort. </li><li>  Dans .NET, les classes Thread et ThreadPool sont utilis√©es pour travailler avec les threads </li><li>  La m√©thode Thread.Abort et Thread.Interrupt, ainsi que la fonction API Win32 TerminateThread, sont dangereuses et non recommand√©es.  Au lieu de cela, il vaut mieux utiliser CancellationTokens </li><li>  Les threads sont une ressource pr√©cieuse et leur nombre est limit√©.  Vous devez √©viter les cas dans lesquels les threads sont occup√©s en attendant les √©v√©nements.  La classe TaskCompletionSource peut aider √† atteindre cet objectif. </li><li>  Les t√¢ches sont l'outil le plus puissant et le plus robuste dont dispose NET pour travailler avec le parall√©lisme et l'asynchronie. </li><li>  Les op√©rateurs C # asynchrones / attendent impl√©mentent le concept d'attente non bloquante </li><li>  Vous pouvez contr√¥ler la r√©partition des t√¢ches entre les threads √† l'aide de classes d√©riv√©es de TaskScheduler </li><li>  La structure ValueTask peut √™tre utilis√©e pour optimiser les raccourcis et le trafic m√©moire </li><li>  Les fen√™tres T√¢ches et Threads de Visual Studio fournissent de nombreuses informations utiles pour le d√©bogage de code multithread ou asynchrone </li><li>  PLinq est un outil g√©nial, mais il peut ne pas avoir toutes les informations requises sur votre source de donn√©es - qui peuvent toujours √™tre corrig√©es avec le m√©canisme de partitionnement </li></ul><br>  <i>√Ä <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivre</a> ...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455252/">https://habr.com/ru/post/fr455252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455242/index.html">Moins d'oreilles ou comment ne pas g√¢cher le son du jeu d√®s le d√©but</a></li>
<li><a href="../fr455244/index.html">Bande dessin√©e "Soldering is Easy" dans la version mise √† jour (2019)</a></li>
<li><a href="../fr455246/index.html">L'inscription √† la Journ√©e de l'exp√©rience client √† Saint-P√©tersbourg est ouverte le 20 juin</a></li>
<li><a href="../fr455248/index.html">Principales erreurs de d√©veloppement lors de l'utilisation de PostgreSQL</a></li>
<li><a href="../fr455250/index.html">Celui qui a ressuscit√© Duke Nukem: entretien avec Randy Pitchford, magicien de Gearbox</a></li>
<li><a href="../fr455256/index.html">Habr Weekly # 4 / Computex, comment b√™ta-t-on Apple, Durov meurt de faim, BadComedian cat, pourquoi le r√©seau de neurones a-t-il cherch√© des acteurs porno</a></li>
<li><a href="../fr455258/index.html">Le vote pour les rapports de la section Backend √† l'anniversaire de DevConfX a commenc√©, qui se tiendra les 21 et 22 juin √† Moscou</a></li>
<li><a href="../fr455260/index.html">Merkle Tree: rouill√© et rapide</a></li>
<li><a href="../fr455264/index.html">Soyez comme Munch, ou quelques mots sur le devoir technique</a></li>
<li><a href="../fr455268/index.html">Comment tout a commenc√©: des √©crans flexibles et pliants - l'histoire de l'apparition et de la sortie des "personnes"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>