<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úùÔ∏è üöΩ ü¶Å Plugin memcached: NoSQL di MySQL üéç ‚úåüèº ü§¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Nama saya Maxim Matyukhin, saya seorang programmer PHP di Badoo . Dalam pekerjaan kami, kami secara aktif menggunakan MySQL. Tetapi kadang-kadang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plugin memcached: NoSQL di MySQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/453742/"><img src="https://habrastorage.org/webt/1v/q0/h5/1vq0h5tev1qw1ivnheyxg7jfiqm.jpeg"><br><br>  Halo  Nama saya Maxim Matyukhin, saya seorang programmer PHP di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Badoo</a> .  Dalam pekerjaan kami, kami secara aktif menggunakan MySQL.  Tetapi kadang-kadang kita kurang kinerjanya, jadi kami terus mencari cara untuk mempercepat pekerjaannya. <br><br>  Pada 2010, Yoshinori Matsunobu memperkenalkan plugin NoSQL MySQL yang disebut HandlerSocket.  Diklaim bahwa plugin ini memungkinkan Anda untuk melakukan lebih dari 750.000 permintaan per detik.  Kami menjadi ingin tahu, dan hampir segera kami mulai menggunakan solusi ini.  Kami sangat menyukai hasilnya sehingga kami mulai membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> dan menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> mempromosikan HandlerSocket. <br><br>  Rupanya, kami adalah salah satu dari sedikit pengguna plugin ini - karena MySQL 5.7 berhenti bekerja.  Namun dalam versi ini, muncul lagi plugin Oracle - plugin memoached InnoDB, yang menjanjikan fungsionalitas serupa. <br><br>  Terlepas dari kenyataan bahwa plugin memcached muncul kembali di MySQL 5.6 pada 2013, tidak ada begitu banyak artikel tentang itu dan sebagian besar mereka mengulangi dokumentasi: label sederhana dibuat dan permintaan dibuat melalui klien memcached. <br><br>  Kami memiliki pengalaman luas dengan Memcached dan terbiasa dengan kemudahan berinteraksi dengannya.  Dari plugin memoached InnoDB kami mengharapkan kesederhanaan yang sama.  Tetapi pada kenyataannya, ternyata jika pola untuk menggunakan plug-in setidaknya sedikit berbeda dari yang dijelaskan dalam dokumentasi dan artikel, banyak nuansa dan batasan muncul, yang pasti layak dipertimbangkan jika Anda akan menggunakan plug-in. <br><a name="habracut"></a><br><h1>  MySQL HandlerSocket </h1><br>  Dalam artikel ini, kita akan membandingkan plugin memcached baru dengan HandlerSocket yang lama.  Karena itu, saya ingat itu yang terakhir. <br><br>  Setelah menginstal plugin HandlerSocket, MySQL mulai mendengarkan dua port tambahan: <br><br><ol><li>  Port pertama menerima permintaan klien untuk membaca data. <br></li><li>  Port kedua menerima permintaan klien untuk merekam data. <br></li></ol><br>  Klien harus membuat koneksi TCP reguler pada salah satu port ini (tidak ada otentikasi yang didukung), dan setelah itu perlu untuk mengirim perintah "indeks terbuka" (perintah khusus yang digunakan klien untuk menginformasikan tabel mana dari indeks mana bidang yang akan kita kunjungi baca (atau tulis)). <br><br>  Jika perintah "indeks terbuka" bekerja dengan sukses, maka Anda dapat mengirim perintah GET atau INSERT / UPDATE / DELETE tergantung pada port tempat koneksi dibuat. <br><br>  HandlerSocket diizinkan untuk melakukan tidak hanya GET pada kunci utama, tetapi juga sampel sederhana dari indeks yang tidak unik, sampel jangkauan, multiget yang didukung, dan LIMIT.  Pada saat yang sama, dimungkinkan untuk bekerja dengan tabel baik dari SQL biasa, maupun melalui plugin.  Ini, misalnya, memungkinkan untuk membuat beberapa perubahan dalam transaksi melalui SQL, dan kemudian membaca data ini melalui HandlerSocket. <br><br>  Penting bahwa HandlerSocket menangani semua koneksi dengan kumpulan benang terbatas melalui epoll, sehingga mudah untuk mendukung puluhan ribu koneksi, sedangkan di MySQL sendiri utas dibuat untuk setiap koneksi dan jumlah mereka sangat terbatas. <br><br>  Pada saat yang sama, itu masih merupakan server MySQL biasa - sebuah teknologi yang akrab bagi kita.  Kami tahu cara mereplikasi dan memonitornya.  Memonitor HandlerSocket sulit karena tidak memberikan metrik khusus;  namun, beberapa metrik standar MySQL dan InnoDB berguna. <br><br>  Tentu saja ada ketidaknyamanan, khususnya, plugin ini tidak mendukung bekerja dengan tipe timestamp.  Yah, protokol HandlerSocket lebih sulit dibaca dan karenanya lebih sulit untuk di-debug. <br><br>  Baca lebih lanjut tentang HandlerSocket di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Anda juga dapat menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu presentasi kami</a> . <br><br><h1>  Plugin InnoDB memcached </h1><br>  Apa yang ditawarkan plugin memcached baru kepada kami? <br><br>  Sesuai namanya, idenya adalah menggunakan klien memcached untuk bekerja dengan MySQL dan untuk menerima dan menyimpan data melalui perintah memcached. <br><br>  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca</a> tentang kelebihan utama plugin di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Kami paling tertarik pada yang berikut: <br><br><ol><li>  Konsumsi CPU rendah. <br></li><li>  Data disimpan di InnoDB, yang memberikan jaminan tertentu. <br></li><li>  Anda dapat bekerja dengan data baik melalui Memcached dan melalui SQL;  mereka dapat direplikasi menggunakan alat bawaan MySQL. <br></li></ol><br>  Anda dapat menambahkan nilai plus ke daftar ini sebagai: <br><br><ol><li>  Koneksi cepat dan murah.  Koneksi MySQL biasa diproses oleh satu utas, dan jumlah utas terbatas, dan dalam plugin memcached, satu utas memproses semua koneksi dalam loop peristiwa. <br></li><li>  Kemampuan untuk meminta beberapa kunci dengan satu permintaan GET. <br></li><li>  Jika dibandingkan dengan MySQL HandlerSocket, maka dalam plugin memcached Anda tidak perlu menggunakan perintah "Open Table" dan semua operasi baca dan tulis terjadi pada port yang sama. <br></li></ol><br><br>  Rincian lebih lanjut tentang plugin dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> resmi.  Bagi kami, halaman yang paling berguna adalah: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">InnoDB memcached Architecture</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">InnoDB memcached Internal Plugin</a> . <br></li></ol><br>  Setelah menginstal plugin, MySQL mulai menerima koneksi pada port 11211 (port memcached standar).  Database khusus (skema) innodb_memcache juga muncul, di mana Anda akan mengkonfigurasi akses ke tabel Anda. <br><br><h1>  Contoh sederhana </h1><br>  Misalkan Anda sudah memiliki tabel yang ingin Anda kerjakan melalui protokol memcached: <br><br><pre><code class="plaintext hljs">CREATE TABLE `auth` (  `email` varchar(96) NOT NULL,  `password` varchar(64) NOT NULL,  `type` varchar(32) NOT NULL DEFAULT '',  PRIMARY KEY (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</code> </pre> <br>  dan Anda ingin menerima dan memodifikasi data pada kunci utama. <br><br>  Anda harus terlebih dahulu menjelaskan korespondensi antara kunci memcached dan tabel SQL di tabel innodb_memcache.containers.  Tabel ini terlihat seperti ini (Saya menghapus deskripsi penyandian untuk membuatnya lebih mudah dibaca): <br><br><pre> <code class="plaintext hljs">CREATE TABLE `containers` ( `name` varchar(50) NOT NULL, `db_schema` varchar(250) NOT NULL, `db_table` varchar(250) NOT NULL, `key_columns` varchar(250) NOT NULL, `value_columns` varchar(250) DEFAULT NULL, `flags` varchar(250) NOT NULL DEFAULT '0', `cas_column` varchar(250) DEFAULT NULL, `expire_time_column` varchar(250) DEFAULT NULL, `unique_idx_name_on_key` varchar(250) NOT NULL, PRIMARY KEY (`name`) ) ENGINE=InnoDB DEFAULT</code> </pre> <br>  Bidang yang paling penting: <br><br><ul><li>  nama - awalan kunci Memcached Anda; <br></li><li>  db_schema - nama basis (sirkuit); <br></li><li>  db_table adalah meja Anda; <br></li><li>  key_columns - nama bidang dalam tabel yang akan kami cari (biasanya ini adalah kunci utama Anda); <br></li><li>  value_columns - daftar bidang dari tabel yang akan tersedia untuk plugin memcached; <br></li><li>  unique_idx_name_on_key adalah indeks yang digunakan untuk mencari (walaupun Anda telah menentukan key_columns, mereka dapat berada dalam indeks yang berbeda dan Anda perlu menentukan indeks secara eksplisit). <br></li></ul><br>  Kolom yang tersisa tidak terlalu penting untuk memulai. <br><br>  Tambahkan deskripsi tabel kami ke innodb_memcache.containers: <br><br><pre> <code class="plaintext hljs">INSERT INTO innodb_memcache.containers SET   name='auth',   db_schema='test',   db_table='auth',   key_columns='email',   value_columns='password|type',   flags='0',   cas_column='0',   expire_time_column='0',   unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Dalam contoh ini, name = 'auth' adalah awalan dari kunci memcached kami.  Dalam dokumentasi itu sering disebut table_id, dan nanti dalam artikel saya akan menggunakan istilah ini. <br><br>  Sekarang TELNET terhubung ke plugin memcached dan cobalah untuk menyimpan dan mendapatkan data: <br><br><pre> <code class="plaintext hljs">[21:26:22] maxm@localhost: ~&gt; telnet memchached-mysql.dev 11211 Trying 127.0.0.1... Connected to memchached-mysql.dev. Escape character is '^]'. get @@auth.max@example.com END set @@auth.max@example.com 0 0 10 1234567|89 STORED get @@auth.max@example.com VALUE @@auth.max@example.com 0 10 1234567|89 END</code> </pre> <br>  Pertama kami mengirim permintaan GET, itu tidak mengembalikan apa pun kepada kami.  Kemudian kami menyimpan data dengan permintaan SET, setelah itu kami mendapatkannya kembali dengan GET. <br><br>  GET mengembalikan baris berikut: 1234567 | 89.  Ini adalah nilai dari kolom "kata sandi" dan "ketik", dipisahkan oleh simbol "|".  Bidang dikembalikan dalam urutan seperti yang dijelaskan di innodb_memcache.containers.value_columns. <br><br>  Mungkin Anda sekarang bertanya-tanya: "Apa yang akan terjadi jika simbol" | "ditemukan di" kata sandi "?"  Saya akan membicarakan ini di bawah. <br><br>  Melalui SQL, data ini juga tersedia: <br><br><pre> <code class="plaintext hljs">MySQL [(none)]&gt; select * from auth where email='max@example.com'; +-----------------+----------+------+ | email      | password | type | +-----------------+----------+------+ | max@example.com | 1234567  | 89 | +-----------------+----------+------+ 1 row in set (0.00 sec)</code> </pre> <br><h2>  Table_id default </h2><br>  Ada juga mode operasi seperti itu: <br><br><pre> <code class="plaintext hljs">get @@auth VALUE @@auth 0 21 test/auth END get max@example.com VALUE max@example.com 0 10 1234567|99 END set ivan@example.com 0 0 10 qwerty|xxx STORED get ivan@example.com VALUE ivan@example.com 0 10 qwerty|xxx END</code> </pre> <br>  Dalam contoh ini, dengan get @@ auth, kami membuat table_id auth sebagai awalan default untuk koneksi ini.  Setelah itu, semua kueri berikutnya dapat dilakukan tanpa menentukan table_id. <br><br>  Sejauh ini, semuanya sederhana dan logis.  Tetapi jika Anda mulai mengerti, maka ada banyak nuansa.  Saya akan memberi tahu Anda apa yang kami temukan. <br><br><h1>  Nuansa </h1><br><h2>  Caching tabel innodb_memcache.containers </h2><br>  Plugin memcached membaca tabel innodb_memcache.containers sekali saat startup.  Lebih lanjut, jika table_id yang tidak dikenal tiba melalui protokol Memcached, plugin mencarinya di tabel.  Oleh karena itu, Anda dapat dengan mudah menambahkan kunci baru (table_id), tetapi jika Anda ingin mengubah pengaturan table_id yang ada, Anda harus memulai kembali plugin memcached: <br><br><pre> <code class="plaintext hljs">mysql&gt; UNINSTALL PLUGIN daemon_memcached; mysql&gt; INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code> </pre> <br>  Di antara dua permintaan ini, antarmuka Memcached tidak akan berfungsi.  Karena itu, seringkali lebih mudah untuk membuat table_id baru daripada mengubah yang sudah ada dan me-restart plugin. <br><br>  Merupakan kejutan bagi kami bahwa nuansa penting dari operasi plug-in dijelaskan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Adaptasi Aplikasi memcached untuk</a> halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plugin InnoDB memcached</a> , yang bukan tempat yang sangat logis untuk informasi tersebut. <br><br><h2>  Tandai, cas_column, expire_time_column </h2><br>  Bidang-bidang ini diperlukan untuk mensimulasikan beberapa fitur Memcached.  Dokumentasi untuk mereka tidak konsisten.  Sebagian besar contoh di dalamnya menggambarkan bekerja dengan tabel di mana bidang ini.  Mungkin ada kekhawatiran bahwa Anda perlu menambahkannya ke tabel Anda (dan ini setidaknya tiga bidang INT).  Tapi tidak.  Jika Anda tidak memiliki bidang tersebut di tabel dan Anda tidak akan menggunakan fungsionalitas Memcached seperti CAS, kedaluwarsa atau bendera, maka Anda tidak perlu menambahkan bidang ini ke tabel. <br><br>  Saat mengkonfigurasi tabel di innodb_memcache.containers, Anda harus memasukkan '0' di bidang ini, buat persis garis dengan nol: <br><br><pre> <code class="plaintext hljs">INSERT INTO innodb_memcache.containers SET   name='auth',   db_schema='test',   db_table='auth',   key_columns='email',   value_columns='password|type',   flags='0',   cas_column='0',   expire_time_column='0',   unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Sangat menjengkelkan karena cas_column dan expire_time_column memiliki nilai default NULL, dan jika Anda menjalankan INSERT INTO innodb_memcache.containers tanpa menentukan nilai '0' untuk bidang ini, NULL akan disimpan di dalamnya dan awalan memcache ini tidak akan berfungsi. <br><br><h2>  Tipe data </h2><br>  Dari dokumentasi itu tidak terlalu jelas tipe data apa yang dapat digunakan saat bekerja dengan plugin.  Di beberapa tempat dikatakan bahwa plugin hanya dapat bekerja dengan bidang teks (CHAR, VARCHAR, BLOB).  Di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyesuaikan Skema MySQL yang Ada untuk Plugin InnoDB memcached</a> menawarkan untuk menyimpan angka dalam bidang string, dan jika Anda kemudian perlu bekerja dengan bidang angka ini dari SQL, lalu buat VIEW di mana bidang VARCHAR dengan angka akan dikonversi ke bidang INTEGER : <br><br><pre> <code class="plaintext hljs">CREATE VIEW numbers AS SELECT c1 KEY, CAST(c2 AS UNSIGNED INTEGER) val FROM demo_test WHERE c2 BETWEEN '0' and '9999999999';</code> </pre> <br>  Namun, di beberapa tempat dalam dokumentasi masih tertulis bahwa Anda dapat bekerja dengan angka.  Sejauh ini, kami hanya memiliki pengalaman produksi nyata dengan bidang teks, tetapi hasil percobaan menunjukkan bahwa plugin juga berfungsi dengan angka: <br><br><pre> <code class="plaintext hljs">CREATE TABLE `numbers` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `counter` int(10) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=InnoDB INSERT INTO innodb_memcache.containers SET name='numbers', db_schema='test', db_table='numbers', key_columns='id', value_columns='counter', flags='0', cas_column='0',expire_time_column='0',unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Setelah itu, melalui protokol Memcached: <br><br><pre> <code class="plaintext hljs">get @@numbers.1 END set @@numbers.1 0 0 2 12 STORED get @@numbers.1 VALUE @@numbers.1 0 2 12 END</code> </pre> <br>  Kami melihat bahwa plugin memcached dapat mengembalikan semua tipe data.  Tapi dia mengembalikan mereka dalam bentuk di mana mereka berada di InnoDB, jadi, misalnya, dalam kasus timestamp / datetime / float / desimal / JSON, string biner dikembalikan.  Tetapi bilangan bulat dikembalikan seperti yang kita lihat melalui SQL. <br><br><h2>  Multiget </h2><br>  Protokol memcached memungkinkan Anda untuk meminta beberapa kunci dengan satu permintaan: <br><br><pre> <code class="plaintext hljs">get @@numbers.2 @@numbers.1 VALUE @@numbers.2 0 2 12 VALUE @@numbers.1 0 2 13 END</code> </pre> <br>  Fakta bahwa multiget berfungsi sudah bagus.  Tetapi ia bekerja dalam kerangka satu table_id: <br><br><pre> <code class="plaintext hljs">get @@auth.ivan@example.com @@numbers.2 VALUE @@auth.ivan@example.com 0 10 qwerty|xxx END</code> </pre> <br>  Poin ini dijelaskan dalam dokumentasi di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://dev.mysql.com/doc/refman/8.0/en/innodb-memcached-multiple-get-range-query.html</a> .  Ternyata dalam multiget Anda dapat menentukan table_id hanya untuk kunci pertama, jika semua kunci lain diambil dari table_id default (contoh dari dokumentasi): <br><br><pre> <code class="plaintext hljs">get @@aaa.AA BB VALUE @@aaa.AA 8 12 HELLO, HELLO VALUE BB 10 16 GOODBYE, GOODBYE END</code> </pre> <br>  Dalam contoh ini, kunci kedua diambil dari table_id default.  Kita bisa menentukan lebih banyak kunci dari table_id default, dan untuk kunci pertama kita tentukan table_id terpisah, dan ini hanya mungkin dalam kasus kunci pertama. <br><br>  Kami dapat mengatakan bahwa multiget berfungsi dalam kerangka satu tabel, karena Anda tidak ingin mengandalkan logika seperti itu dalam kode produksi: tidak jelas, mudah untuk melupakannya, membuat kesalahan. <br><br>  Jika dibandingkan dengan HandlerSocket, maka di sana juga, multiget bekerja di tabel yang sama.  Tetapi pembatasan ini tampak alami: klien membuka indeks dalam tabel dan meminta satu atau beberapa nilai darinya.  Tetapi ketika bekerja dengan plugin memcached multiget pada beberapa tombol dengan awalan yang berbeda, ini adalah praktik biasa.  Dan Anda mengharapkan hal yang sama dari plugin memcached MySQL.  Tapi tidak :( <br><br><h2>  INCR, DEL </h2><br>  Saya sudah memberikan contoh permintaan GET / SET.  Pertanyaan INCR dan DEL memiliki fitur.  Itu terletak pada kenyataan bahwa mereka hanya bekerja ketika menggunakan table_id default: <br><br><pre> <code class="plaintext hljs">DELETE @@numbers.1 ERROR get @@numbers VALUE @@numbers 0 24 test/numbers END delete 1 DELETED</code> </pre> <br><h2>  Keterbatasan protokol memcached </h2><br>  Memcached memiliki protokol teks, yang memberikan beberapa batasan.  Misalnya, kunci memcached tidak boleh mengandung karakter spasi putih (spasi, umpan baris).  Jika Anda melihat kembali deskripsi tabel dari contoh kita: <br><br><pre> <code class="plaintext hljs">CREATE TABLE `auth` ( `email` varchar(96) NOT NULL, `password` varchar(64) NOT NULL, `type` varchar(32) NOT NULL DEFAULT '', PRIMARY KEY (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</code> </pre> <br>  ini berarti bahwa di bidang "email" tidak boleh ada karakter seperti itu. <br><br>  Selain itu, kunci memcached harus kurang dari 250 byte (byte, bukan karakter).  Jika Anda mengirim lebih banyak, Anda mendapatkan kesalahan: <br><br><pre> <code class="plaintext hljs">"CLIENT_ERROR bad command line format"</code> </pre> <br>  Selain itu, seseorang harus memperhitungkan fakta bahwa plugin memcached menambahkan sintaksnya sendiri ke protokol memcached.  Misalnya, ia menggunakan karakter "|"  sebagai pemisah bidang dalam respons.  Anda perlu memastikan bahwa simbol ini tidak digunakan di meja Anda.  Pemisah dapat dikonfigurasi, tetapi pengaturan akan berlaku untuk semua tabel di seluruh server MySQL. <br><br><h2>  Pembatas bidang value_columns </h2><br>  Jika Anda perlu mengembalikan beberapa kolom melalui protokol memcached, seperti pada contoh pertama kami: <br><br><pre> <code class="plaintext hljs">get @@auth.max@example.com VALUE @@auth.max@example.com 0 10 1234567|89 END</code> </pre> <br>  maka nilai kolom dipisahkan oleh pemisah standar "|".  Timbul pertanyaan: "Apa yang akan terjadi jika, misalnya, karakter" | "berada di bidang pertama dalam barisan?"  Plugin memcached dalam hal ini akan mengembalikan string apa adanya, seperti ini: 1234 | 567 | 89.  Dalam kasus umum, tidak mungkin untuk memahami di mana ada bidang. <br><br>  Karena itu, penting untuk memilih pemisah yang tepat segera.  Dan karena itu akan digunakan untuk semua kunci dari semua tabel, itu harus menjadi simbol universal yang tidak akan ditemukan di bidang apa pun yang dengannya Anda akan bekerja melalui protokol memcached. <br><br><h1>  Ringkasan </h1><br>  Ini bukan untuk mengatakan bahwa plugin memcached itu buruk.  Tetapi orang mendapat kesan bahwa itu ditulis untuk skema kerja tertentu: server MySQL dengan satu tabel yang dapat diakses menggunakan protokol memcached, dan table_id ini dibuat default.  Klien membuat koneksi persisten dengan plugin Memcached dan membuat permintaan ke table_id default.  Mungkin, dalam skema seperti itu, semuanya akan bekerja dengan sempurna.  Jika Anda menjauh darinya, Anda menemukan berbagai ketidaknyamanan. <br><br>  Anda mungkin berharap melihat beberapa laporan kinerja plugin.  Tetapi kami belum memutuskan untuk menggunakannya di tempat-tempat yang sangat padat.  Kami menggunakannya hanya dalam beberapa sistem yang tidak terlalu banyak dan ada yang bekerja pada kecepatan yang sama dengan HandlerSocket, tetapi kami tidak membuat tolok ukur yang jujur.  Namun demikian, plugin ini menyediakan antarmuka sedemikian rupa sehingga programmer dapat dengan mudah melakukan kesalahan - Anda perlu mengingat banyak nuansa.  Karena itu, kami belum siap untuk menggunakan plugin ini secara massal. <br><br>  Kami membuat beberapa permintaan fitur di pelacak bug MySQL: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bugs.mysql.com/bug.php?id=95091</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bugs.mysql.com/bug.php?id=95092</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bugs.mysql.com/bug.php?id=95093</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bugs.mysql.com/bug.php?id=95094</a> <br><br>  Mari berharap tim pengembangan plugin memcached akan meningkatkan produknya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453742/">https://habr.com/ru/post/id453742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453722/index.html">Tentang penelitian proses non-stasioner</a></li>
<li><a href="../id453728/index.html">Pertempuran Hyperstars</a></li>
<li><a href="../id453730/index.html">Kedokteran gigi modern: implantasi gigi simultan dan perluasan tulang rahang melalui mata direktur teknis</a></li>
<li><a href="../id453732/index.html">Saya dari Moreinis. Pandangan miring atau rasa hormat?</a></li>
<li><a href="../id453734/index.html">Memperkenalkan Helm 3</a></li>
<li><a href="../id453744/index.html">Kami mempelajari prinsip pseudo-class: not () menggunakan contoh tugas "Menyorot baris aktif tabel dalam CSS murni"</a></li>
<li><a href="../id453748/index.html">Membuat prototipe game seluler, mulai dari mana, dan bagaimana melakukannya. Bagian 3 (final)</a></li>
<li><a href="../id453750/index.html">Tentang serangan cyber Baltimore baru-baru ini</a></li>
<li><a href="../id453756/index.html">Masalah metodologi saat ini untuk menentukan ancaman saat ini dari FSTEC</a></li>
<li><a href="../id453760/index.html">Kamp pelatihan sirkuit untuk tank dan prosesor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>