<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôã üë©üèª‚Äçü§ù‚Äçüë®üèº üë©üèº‚Äçü§ù‚Äçüë©üèª Jobsystem. √úbersicht von der anderen Seite ‚ò∫Ô∏è üé™ ‚úîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der neuen Version von Unity im Jahr 2018 haben sie schlie√ülich offiziell das neue Entity-Komponentensystem, kurz ECS , hinzugef√ºgt, mit dem Sie nur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jobsystem. √úbersicht von der anderen Seite</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420829/">  In der neuen Version von <b>Unity im Jahr</b> 2018 haben sie schlie√ülich offiziell das neue <b>Entity-Komponentensystem,</b> kurz <b>ECS</b> , hinzugef√ºgt, mit dem Sie nur mit ihren Daten arbeiten k√∂nnen, anstatt wie √ºblich mit den Komponenten des Objekts. <br><br>  Ein zus√§tzliches Task-System bietet Ihnen die M√∂glichkeit, parallele Rechenleistung zu verwenden, um die Leistung Ihres Codes zu verbessern. <br><a name="habracut"></a><br>  Zusammen bieten diese beiden neuen Systeme ( <b>ECS</b> und <b>Job System</b> ) eine neue Ebene der Datenverarbeitung. <br><br>  Insbesondere werde ich in diesem Artikel nicht das gesamte <b>ECS-</b> System analysieren, das derzeit als separat herunterladbarer Satz von Tools in <b>Einheit</b> verf√ºgbar ist, sondern nur das Task-System und dessen Verwendung au√üerhalb des <b>ECS-</b> Pakets ber√ºcksichtigen. <br><br><h3>  Neues System </h3><br>  Urspr√ºnglich h√§tte <b>Unity</b> zuvor Multithread-Computing verwenden k√∂nnen, aber all dies musste vom Entwickler selbst erstellt werden, um die Probleme selbst zu l√∂sen und die Fallstricke zu umgehen.  Und wenn es fr√ºher notwendig war, direkt mit Dingen wie dem Erstellen von Threads, dem Schlie√üen von Threads, Pools und der Synchronisierung zu arbeiten, fiel diese ganze Arbeit jetzt auf die Schultern der Engine, und der Entwickler selbst musste nur noch Aufgaben erstellen und ausf√ºhren. <br><br><h3>  Die Aufgaben </h3><br>  Um Berechnungen im neuen System durchzuf√ºhren, m√ºssen Aufgaben verwendet werden, bei denen es sich um Objekte handelt, die aus Methoden und Daten f√ºr die Berechnung bestehen. <br><br>  Wie alle anderen Daten im <b>ECS-</b> System werden auch Aufgaben im <b>Jobsystem</b> als Strukturen dargestellt, die eine von drei Schnittstellen erben. <br><br><h4>  Ijob </h4><br>  Die einfachste Task-Schnittstelle mit einer <b>Execute-</b> Methode, die nichts in Form von Parametern akzeptiert und nichts zur√ºckgibt. <br><br>  Die Aufgabe selbst sieht folgenderma√üen aus: <br><br><div class="spoiler">  <b class="spoiler_title">Ijob</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  In der <b>Execute-</b> Methode k√∂nnen Sie die erforderlichen Berechnungen durchf√ºhren. <br><br><h4>  IJobParallelFor </h4><br>  Eine weitere Schnittstelle mit derselben <b>Execute-</b> Methode, die wiederum bereits den numerischen Parameterindex akzeptiert. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelFor</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Diese <b>IJobParallelFor-</b> Schnittstelle bietet im Gegensatz zur <b>IJob-</b> Schnittstelle die M√∂glichkeit, eine Aufgabe mehrmals auszuf√ºhren und diese Ausf√ºhrung nicht nur auszuf√ºhren, sondern in Bl√∂cke <b>aufzuteilen</b> , die zwischen Threads verteilt werden. <br><br>  <i>Unverst√§ndlich?</i>  <i>Mach dir dar√ºber keine Sorgen, ich werde dir mehr erz√§hlen.</i> <br><br><h4>  IJobParallelForTransform </h4><br>  Und die letzte spezielle Schnittstelle, die, wie der Name schon sagt, f√ºr diese Transformationen des Objekts ausgelegt ist.  Es enth√§lt auch die <b>Execute-</b> Methode mit dem numerischen Parameterindex und dem <b>TransformAccess-</b> Parameter, in der sich Position, Gr√∂√üe und Drehung der Transformation befinden. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelForTransform</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelForTransform { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index, TransformAccess transform) {} }</code> </pre> <br></div></div><br>  Aufgrund der Tatsache, dass Sie nicht direkt in der Aufgabe mit <b>Unity-</b> Objekten arbeiten k√∂nnen, kann diese Schnittstelle Transformationsdaten nur als separate <b>TransformAccess-</b> Struktur verarbeiten. <br><br>  Wenn Sie fertig sind und wissen, wie Aufgabenstrukturen erstellt werden, k√∂nnen Sie mit dem √úben fortfahren. <br><br><h3>  Aufgabenerf√ºllung </h3><br>  Lassen Sie uns eine einfache Aufgabe erstellen, die von der <b>IJob-</b> Oberfl√§che <b>geerbt wurde</b> , und sie abschlie√üen.  Dazu ben√∂tigen wir ein einfaches <b>MonoBehaviour-</b> Skript und die Struktur der Aufgabe selbst. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() {} }</code> </pre> <br></div></div><br>  Legen Sie dieses Skript nun auf einem Objekt in der Szene ab.  Im selben Skript ( <b>TestJob</b> ) schreiben wir die Struktur der Aufgabe und vergessen nicht, die erforderlichen Bibliotheken zu importieren. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Hello parallel world!"</span></span>); } }</code> </pre> <br></div></div><br>  Drucken Sie in der <b>Execute-</b> Methode beispielsweise eine einfache Zeile an die Konsole. <br><br>  <b>Fahren</b> wir nun mit der <b>Start-</b> Methode des <b>TestJob-</b> Skripts fort, in der wir eine Instanz der Aufgabe erstellen und dann ausf√ºhren. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.Schedule().Complete(); } }</code> </pre> <br></div></div><br>  Wenn Sie alles wie im Beispiel gemacht haben, erhalten Sie nach dem Start des Spiels eine einfache Nachricht an die Konsole wie auf dem Bild. <br><br><img src="https://lh6.googleusercontent.com/QQeMBMeZy0HVw0r_D5Q_cH4k6Zzt-HAC6uev1O4pR--mOh96C2TQvw5DTH1X3ZPE7LORJ4wdV5kyKjGiJzVWLFm-HBi8HzSP4-DlbrYa65eRV1RF672uwsLsZvrCKtF5CdaGJ5tj" alt="Bild"><br><br>  Was hier passiert: Nach dem Aufrufen der <b>Schedule-</b> Methode platziert der Scheduler die Aufgabe im Handle und kann nun durch Aufrufen der <b>Complete-</b> Methode <b>abgeschlossen</b> werden. <br><br>  Dies war ein Beispiel f√ºr eine Aufgabe, bei der einfach Text auf die Konsole gedruckt wurde.  Damit eine Aufgabe parallele Berechnungen durchf√ºhren kann, muss sie mit Daten gef√ºllt werden. <br><br><h3>  Daten in der Aufgabe </h3><br>  Wie im <b>ECS-</b> System gibt es bei Aufgaben keinen Zugriff auf <b>Unity-</b> Objekte. Sie k√∂nnen das <b>GameObject nicht</b> in die Aufgabe aufnehmen und dort seinen Namen √§ndern.  Sie k√∂nnen lediglich einige separate Objektparameter auf die Aufgabe √ºbertragen, diese Parameter √§ndern und diese √Ñnderungen nach Abschluss der Aufgabe wieder auf das Objekt anwenden. <br><br>  Die Daten in der Aufgabe selbst unterliegen mehreren Einschr√§nkungen: Erstens m√ºssen es Strukturen sein, und zweitens d√ºrfen es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine konvertierbaren</a> Datentypen sein, <b>dh</b> Sie k√∂nnen nicht denselben <b>Booleschen Wert</b> oder dieselbe <b>Zeichenfolge</b> an die Aufgabe √ºbergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float a, b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { float result = a + b; Debug.Log(result); } }</code> </pre> <br></div></div><br>  Und die Hauptbedingung: Auf Daten, die nicht in einem Container enthalten sind, kann nur innerhalb der Aufgabe zugegriffen werden! <br><br><h3>  Container </h3><br>  Bei der Arbeit mit Multithread-Computing m√ºssen Daten zwischen Threads ausgetauscht werden.  Um Daten in sie √ºbertragen und im Task-System zur√ºcklesen zu k√∂nnen, gibt es f√ºr diese Zwecke Container.  Diese Container werden in Form gew√∂hnlicher Strukturen dargestellt, und ich arbeite nach dem Prinzip einer Br√ºcke, √ºber die Elementardaten zwischen Fl√ºssen synchronisiert werden. <br><br>  Es gibt verschiedene Arten von Beh√§ltern: <br>  <b>NativeArray</b> .  Der einfachste und am h√§ufigsten verwendete Containertyp wird als einfaches Array mit fester Gr√∂√üe dargestellt. <br>  <b>NativeSlice</b> .  Ein weiterer Container - ein Array, wie aus der √úbersetzung hervorgeht, dient dazu, das NativeArray in St√ºcke zu schneiden. <br><br>  Dies sind die beiden Hauptcontainer, die ohne Anschluss eines <b>ECS-</b> Systems verf√ºgbar sind.  In einer fortgeschritteneren Version gibt es mehrere weitere Arten von Containern. <br><br>  <b>NativeList</b> .  Es ist eine regelm√§√üige Liste von Daten. <br>  <b>NativeHashMap</b> .  Ein Analogon eines W√∂rterbuchs mit einem Schl√ºssel und einem Wert. <br>  <b>NativeMultiHashMap</b> .  <b>Dieselbe NativeHashMap</b> mit nur wenigen Werten unter einem Schl√ºssel. <br>  <b>NativeQueue</b>  Liste der Datenwarteschlangen. <br><br>  Da wir ohne Anschluss eines <b>ECS-</b> Systems arbeiten, stehen <b>uns</b> nur <b>NativeArray</b> und <b>NativeSlice</b> zur Verf√ºgung. <br><br>  Bevor Sie mit dem praktischen Teil fortfahren, m√ºssen Sie den wichtigsten Punkt analysieren - die Erstellung von Instanzen. <br><br><h3>  Erstellen Sie Container </h3><br>  Wie bereits erw√§hnt, stellen diese Container eine Br√ºcke dar, √ºber die Daten zwischen Threads synchronisiert werden.  Das Task-System √∂ffnet diese Br√ºcke vor Arbeitsbeginn und schlie√üt sie nach Abschluss.  Der √ñffnungsprozess wird als " <i>Zuweisung</i> " ( <b>Zuweisung</b> ) oder <i>"Zuweisung von Speicher" bezeichnet</i> , der Schlie√üvorgang als " <i>Freigabe von Ressourcen</i> " ( <b>Entsorgen</b> ). <br><br>  Die Zuordnung bestimmt, wie lange die Aufgabe die Daten im Container verwenden kann - mit anderen Worten, wie lange die Br√ºcke ge√∂ffnet sein wird. <br><br>  Um diese beiden Prozesse besser zu verstehen, schauen wir uns das folgende Bild an. <br><br><img src="https://lh4.googleusercontent.com/6yL2x_ynGZj1C1ukkQlfDZuYKzlvJ4ceAYU9Zyb40xwDzuASeUNB__Od067_3xZkYANEOPl84JoKLyqTPn4hrvQNogbksb7akoQvcWjDLg2yyUJY9eF37uj7TO0YkOL3cQyMsXPu" alt="Bild"><br><br>  Der untere Teil zeigt den Lebenszyklus des Hauptthreads ( <b>Hauptthread</b> ), der in der Anzahl der Frames berechnet wird. Im ersten Frame erstellen wir einen weiteren parallelen Thread ( <b>Neuer Thread),</b> der f√ºr eine bestimmte Anzahl von Frames vorhanden ist, und schlie√üen dann sicher. <br>  Im selben <b>neuen Thread kommt die</b> Aufgabe mit dem Container an. <br><br>  Schauen Sie sich jetzt den oberen Rand des Bildes an. <br><br><img src="https://lh5.googleusercontent.com/1IZ_CMZhX4JfBWBLEuAijf1st_6e7p96EncPomR_jLNhQVbJDvS_o_-gf1emw3glwEGt8y3xXARp4xJJ9qu0WjYTH4asrblwul2rHa_SqQiLzrTTOoDJ5DlomcPBP8qkfCI3w9R8" alt="Bild"><br><br>  Der wei√üe Balken <b>Allocation</b> zeigt die Lebensdauer des Containers an.  Im ersten Frame wird der Container <i>zugewiesen</i> - die Br√ºcke wird ge√∂ffnet, bis zu diesem Zeitpunkt der Container nicht vorhanden war. Nachdem alle Berechnungen in der Aufgabe abgeschlossen wurden, wird der Container aus dem Speicher freigegeben und im 9. Frame wird die Br√ºcke geschlossen. <br><br>  Auch auf diesem Streifen ( <b>Zuordnung</b> ) befinden sich <b>Zeitsegmente</b> ( <b>Temp</b> , <b>TempJob</b> und <b>Presistent</b> ). Jedes dieser Segmente zeigt die gesch√§tzte Lebensdauer des Containers. <br><br>  Warum werden diese Segmente ben√∂tigt?  Tatsache ist, dass die Ausf√ºhrung einer Aufgabe nach Dauer unterschiedlich sein kann, wir k√∂nnen sie direkt in derselben Methode ausf√ºhren, in der wir sie erstellt haben, oder wir k√∂nnen die Ausf√ºhrungszeit der Aufgabe verl√§ngern, wenn sie recht kompliziert ist, und diese Segmente zeigen, wie dringend und wie lange die Aufgabe die Daten verwenden kann im Beh√§lter. <br><br>  <i>Wenn es immer noch nicht klar ist, werde ich jede Art der Zuordnung anhand eines Beispiels analysieren.</i> <br><br>  Jetzt k√∂nnen wir mit dem praktischen Teil des Erstellens von Containern <b>fortfahren.</b> Dazu kehren wir zur <b>Start-</b> Methode des <b>TestJob-</b> Skripts zur√ºck und erstellen eine neue Instanz des <b>NativeArray-</b> Containers. Vergessen Sie nicht, die erforderlichen Bibliotheken zu verbinden. <br><br><h3>  Temp </h3><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; using Unity.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); } }</code> </pre> <br></div></div><br>  Um eine neue Containerinstanz zu erstellen, m√ºssen Sie die Gr√∂√üe und den Typ der Zuordnung in ihrem Konstruktor angeben.  In diesem Beispiel wird der <b>Temp-</b> Typ verwendet, da die Aufgabe nur in der <b>Start-</b> Methode ausgef√ºhrt wird. <br><br>  Initialisieren Sie nun genau dieselbe Array-Variable in der Struktur der <b>SimpleJob-</b> Task. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Fertig.  Jetzt k√∂nnen Sie die Aufgabe selbst erstellen und eine Array-Instanz an sie √ºbergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; }</code> </pre> <br></div></div><br>  Um die Aufgabe dieses Mal <b>auszuf√ºhren</b> , verwenden wir das <b>JobHandle-</b> Handle, um sie durch Aufrufen derselben <b>Schedule-</b> Methode <b>abzurufen</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); }</code> </pre> <br></div></div><br>  Jetzt k√∂nnen Sie die <b>Complete-</b> Methode an ihrem Handle aufrufen und pr√ºfen, ob die Aufgabe abgeschlossen ist, um den Text in der Konsole anzuzeigen. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">" "</span></span>); }</code> </pre> <br></div></div><br>  Wenn Sie die Aufgabe in dieser Form ausf√ºhren, wird nach dem Start des Spiels ein fetter roter Fehler angezeigt, der besagt, dass Sie den Array-Container nach Abschluss der Aufgabe nicht aus den Ressourcen freigegeben haben. <br><br>  So etwas in der Art. <br><br><img src="https://lh3.googleusercontent.com/EewKhLiPm0_qidpB0-YnlUfbTcIlzOhPw_OXgJqcmm-m9MpAaq96PHSc-FlN7GNArl9JkThBUZEGM9YFIHR5BkkMRUBwTAM6awQAEYGOw45i31irFlXtkT7peTOmjFfoEq_ASONA" alt="Bild"><br><br>  Um dies zu vermeiden, rufen Sie nach Abschluss der Aufgabe die <b>Dispose-</b> Methode f√ºr den Container auf. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">"Complete"</span></span>); array.Dispose(); }</code> </pre> <br></div></div><br>  Dann k√∂nnen Sie es sicher neu starten. <br>  Aber die Aufgabe macht nichts!  - F√ºgen Sie dann einige Aktionen hinzu. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { array[i] = i * i; } } }</code> </pre> <br></div></div><br>  Bei der <b>Execute-</b> Methode multipliziere ich den Index jedes Elements des Arrays mit mir selbst und schreibe ihn zur√ºck in das Array- <b>Array</b> , um das Ergebnis in der <b>Start-</b> Methode an die Konsole zu drucken. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(job.array[job.array.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]); array.Dispose(); }</code> </pre> <br></div></div><br><blockquote>  Was ist das Ergebnis in der Konsole, wenn wir das letzte Element des Arrays im Quadrat drucken? </blockquote><br>  Auf diese Weise k√∂nnen Sie Container erstellen, in Aufgaben einf√ºgen und Aktionen f√ºr sie ausf√ºhren. <br><br>  Dies war ein Beispiel f√ºr die Verwendung des <b>Temp-</b> Zuordnungstyps, bei dem eine Aufgabe innerhalb eines Frames ausgef√ºhrt wird.  Dieser Typ wird am besten verwendet, wenn Sie schnell Berechnungen durchf√ºhren m√ºssen, ohne den Hauptthread zu laden. Sie m√ºssen jedoch vorsichtig sein, wenn die Aufgabe zu kompliziert ist oder wenn viele davon auftreten, kann es zu einem Durchh√§ngen kommen. In diesem Fall ist es besser, den <b>TempJob-</b> Typ zu verwenden <b>,</b> den ich sp√§ter analysieren werde. <br><br><h3>  Tempjob </h3><br>  In diesem Beispiel werde ich <b>die</b> Struktur der <b>SimpleJob-</b> Task leicht <b>√§ndern</b> und von einer anderen <b>IJobParallelFor-</b> Schnittstelle erben. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Da die Aufgabe l√§nger als ein Frame ausgef√ºhrt wird, werden die Ergebnisse der Aufgabe in verschiedenen <b>Awake-</b> und <b>Start-</b> Methoden ausgef√ºhrt und <b>gesammelt</b> , die in Form einer Coroutine dargestellt werden.  √Ñndern Sie dazu das Erscheinungsbild der <b>TestJob-</b> Klasse ein <b>wenig</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() {} IEnumerator Start() {} }</code> </pre> <br></div></div><br>  In der <b>Awake-</b> Methode erstellen wir eine Aufgabe und einen Container mit Vektoren und geben in der <b>Start-</b> Methode die empfangenen Daten aus und geben Ressourcen frei. <br><br><div class="spoiler">  <b class="spoiler_title">Wach auf</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; }</code> </pre> <br></div></div><br>  Auch hier wird ein <b>Array-</b> Container mit der Art der Zuordnung <b>TempJob</b> erstellt. <b>Anschlie√üend</b> erstellen wir eine Aufgabe und erhalten ihr Handle, indem wir die <b>Schedule-</b> Methode mit geringf√ºgigen √Ñnderungen aufrufen. <br><br><div class="spoiler">  <b class="spoiler_title">Wach auf</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br></div></div><br>  Der erste Parameter in der <b>Schedule-</b> Methode gibt an, wie oft die Aufgabe ausgef√ºhrt wird. Hier ist dieselbe Zahl wie die Gr√∂√üe des Array- <b>Arrays</b> . <br>  Der zweite Parameter gibt an, wie viele Bl√∂cke die Aufgabe gemeinsam nutzen sollen. <br><br>  <i>Welche anderen Bl√∂cke?</i> <br>  Fr√ºher, um eine Aufgabe abzuschlie√üen, hat ein Thread die <b>Execute-</b> Methode nur einmal aufgerufen. Jetzt muss diese Methode 100 Mal aufgerufen werden, sodass der Scheduler diese 100-maligen Wiederholungen in Bl√∂cke aufteilt, die er zwischen den Threads verteilt, um keinen separaten Thread zu laden.  In diesem Beispiel werden hundert Wiederholungen in 5 Bl√∂cke mit jeweils 20 Wiederholungen unterteilt, dh der Scheduler verteilt diese 5 Bl√∂cke vermutlich auf 5 Threads, wobei jeder Thread die <b>Execute-</b> Methode 20 Mal <b>aufruft</b> .  In der Praxis ist es nat√ºrlich keine Tatsache, dass der Scheduler genau das tut, es h√§ngt alles von der Arbeitslast des Systems ab, sodass m√∂glicherweise alle 100 Wiederholungen in einem Thread stattfinden. <br><br>  Jetzt k√∂nnen Sie die <b>Complete-</b> Methode im Task-Handle aufrufen. <br><br><div class="spoiler">  <b class="spoiler_title">Wach auf</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  In der <b>Start-</b> Coroutine √ºberpr√ºfen wir die Ausf√ºhrung der Aufgabe und bereinigen dann den Container. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.isCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Fahren wir nun mit den Aktionen in der Aufgabe selbst fort. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) { float x = index; float y = index; Vector2 vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x * x, y * y / (y * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array[index] = vector; } }</code> </pre> <br></div></div><br>  Zeigen Sie nach Abschluss der Aufgabe in der <b>Start-</b> Methode alle Elemente des Arrays in der Konsole an. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } foreach(Vector2 vector <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array) { print(vector); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Wenn Sie fertig sind, k√∂nnen Sie das Ergebnis anzeigen. <br><br>  Schauen Sie sich die folgenden Bilder an <b>,</b> um den Unterschied zwischen <b>IJob</b> und <b>IJobParallelFor</b> zu verstehen. <br>  In <b>IJob k√∂nnen</b> Sie beispielsweise eine einfache <b>for-</b> Schleife verwenden, um Berechnungen mehrmals durchzuf√ºhren. In jedem Fall kann ein Thread die <b>Execute-</b> Methode jedoch nur einmal f√ºr die gesamte Dauer der Aufgabe aufrufen. Auf diese Weise kann eine Person Hunderte derselben Aktionen hintereinander ausf√ºhren. <br><br><img src="https://lh3.googleusercontent.com/qUadSqRojz1W8kiqtm-xgi-TYeJ9IlVh38o0MrG0mTWnU3j0qTjtTOWa8pkPc0kjPQcTKoqOJtNl6E4Olb5MKCNgUhrsAXGujN0flm_YVoFfEVS9kCCjFOucANAw74Kjq2W_Zzho" alt="Bild"><br><br>  <b>IJobParallelFor</b> bietet nicht nur die <b>M√∂glichkeit</b> , eine Aufgabe in einem Thread mehrmals auszuf√ºhren, sondern diese Wiederholungen auch auf andere Threads zu verteilen. <br><br><img src="https://lh5.googleusercontent.com/-5ggH4tUKWvhz6I8UUi2eGzqY_B_QqA1PA_298vp89xg4v2yC3wn3N9D8TlVOMwWuDM593H_Aw9WZOU-_esyT7vyL4MM17bZaevfiOiYSEUb0I1oT2Fi3cXbBtoc9SuMYIhVnMc7" alt="Bild"><br><br>  Im Allgemeinen ist die Art der Zuordnung <b>TempJob</b> perfekt f√ºr die meisten Aufgaben, die √ºber mehrere Frames ausgef√ºhrt werden. <br><br>  Was aber, wenn Sie Daten auch nach Abschluss einer Aufgabe speichern m√ºssen, was ist, wenn Sie sie nach Erhalt des Ergebnisses nicht sofort zerst√∂ren m√ºssen?  Hierzu ist es erforderlich, die Art der Zuordnung <b>Persistent zu verwenden</b> , was die Freigabe von Ressourcen dann ‚Äû <i>bei Bedarf!‚Äú Impliziert.</i>  . <br><br><h3>  Hartn√§ckig </h3><br>  <b>Kehren wir</b> zur <b>TestJob-</b> Klasse zur√ºck und √§ndern sie.  Jetzt erstellen wir Aufgaben in der <b>OnEnable-</b> Methode, √ºberpr√ºfen deren Ausf√ºhrung in der <b>Update-</b> Methode und bereinigen Ressourcen in der <b>OnDisable-</b> Methode. <br>  In diesem Beispiel verschieben wir das Objekt in der <b>Update-</b> Methode. Zur Berechnung der Trajektorie verwenden wir zwei Vektorcontainer - <b>inputArray,</b> in die wir die aktuelle Position und <b>outputArray einf√ºgen,</b> von wo aus wir die Ergebnisse erhalten. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; inputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() {} }</code> </pre> <br></div></div><br>  <b>Wir werden</b> auch <b>die</b> Struktur der <b>SimpleJob-</b> Task leicht <b>√§ndern,</b> indem <b>wir</b> sie von der <b>IJob-</b> Schnittstelle erben, um sie einmal auszuf√ºhren. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  In der Aufgabe selbst werden wir auch zwei Vektorcontainer verraten, einen Positionsvektor und ein numerisches Delta, die das Objekt zum Ziel bewegen. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; inputArray; [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float delta; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Die Attribute <b>ReadOnly</b> und <b>WriteOnly</b> zeigen die <b>Flussbeschr√§nkungen</b> f√ºr die Aktionen an, die den Daten in den Containern zugeordnet sind.  <b>ReadOnly</b> bietet den Stream nur zum Lesen von Daten aus dem Container an. Das <b>WriteOnly-</b> Attribut hingegen erm√∂glicht es dem Stream, nur Daten in den Container zu schreiben.  Wenn Sie diese beiden Aktionen gleichzeitig mit einem Container ausf√ºhren m√ºssen, m√ºssen Sie ihn √ºberhaupt nicht mit einem Attribut markieren. <br><br>  <b>Fahren</b> wir mit der <b>OnEnable-</b> Methode der <b>TestJob-</b> Klasse fort, in der die Container initialisiert werden. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); }</code> </pre> <br></div></div><br>  Die Abmessungen der Container sind einfach, da Parameter nur einmal gesendet und empfangen werden m√ºssen.  Die Art der Zuordnung ist <b>dauerhaft</b> . <br>  Bei der <b>OnDisable-</b> Methode geben <b>wir</b> die Ressourcen der Container frei. <br><br><div class="spoiler">  <b class="spoiler_title">Ondisable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray.Dispose(); }</code> </pre> <br></div></div><br>  Erstellen wir eine separate <b>CreateJob-</b> Methode, in der wir eine Aufgabe mit ihrem Handle erstellen und dort mit Daten f√ºllen. <br><br><div class="spoiler">  <b class="spoiler_title">CreateJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateJob() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.delta = Time.deltaTime; Vector2 position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position; job.position = position; Vector2 newPosition = position + Vector2.right; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; job.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray; job.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  <i>Eigentlich wird <b>inputArray</b> hier nicht wirklich ben√∂tigt, da es m√∂glich ist, einen Richtungsvektor nur auf die Aufgabe zu √ºbertragen, aber ich denke, es ist besser zu verstehen, warum diese <b>ReadOnly-</b> und <b>WriteOnly-</b> Attribute √ºberhaupt ben√∂tigt werden.</i> <br><br>  In der <b>Update-</b> Methode pr√ºfen wir, ob die Aufgabe abgeschlossen ist. Anschlie√üend wenden wir das erhaltene Ergebnis auf die Objekttransformation an und f√ºhren es erneut aus. <br><br><div class="spoiler">  <b class="spoiler_title">Update</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position = newPosition; CreateJob(); } }</code> </pre> <br></div></div><br>  Bevor wir beginnen, werden wir die <b>OnEnable-</b> Methode leicht <b>anpassen</b> , sodass die Aufgabe unmittelbar nach der Initialisierung der Container erstellt wird. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); CreateJob(); }</code> </pre> <br></div></div><br>  Fertig, jetzt k√∂nnen Sie zur Aufgabe selbst gehen und die erforderlichen Berechnungen in der <b>Execute-</b> Methode durchf√ºhren. <br><br><div class="spoiler">  <b class="spoiler_title">Ausf√ºhren</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; newPosition = Vector2.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position, newPosition, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; }</code> </pre> <br></div></div><br>  Um das Ergebnis der Arbeit zu sehen, k√∂nnen Sie das <b>TestJob-</b> Skript auf ein Objekt werfen und das Spiel ausf√ºhren. <br><br>  Zum Beispiel verschiebt sich mein Sprite nur allm√§hlich nach rechts. <br><br><div class="spoiler">  <b class="spoiler_title">Animation</b> <div class="spoiler_text"><img src="https://lh3.googleusercontent.com/YCf68msYSI0w6ARjOAeAWsPPhpPOrXC-3jWTfqtlnu1pS1xa9m6FCjTD3DdvcvWi5KSEh_-q6X2yUf62j1FOgSU6d0plX603FOQiydF-yLRQFvbd2YBY-mp8I5p5V4cQH9t7SKPR" alt="Bild"><br></div></div><br>  Im Allgemeinen <b>eignet sich</b> die Art der Zuordnung <b>Persistent</b> hervorragend f√ºr wiederverwendbare Container, die nicht jedes Mal zerst√∂rt und neu erstellt werden m√ºssen. <br><br>  <i>Also, welche Art zu verwenden !?</i> <br>  Der <b>Temp-</b> Typ eignet sich am besten f√ºr die schnelle Durchf√ºhrung von Berechnungen. Wenn die Aufgabe jedoch zu komplex und zu gro√ü ist, kann es zu einem Durchhang kommen. <br>  Der <b>TempJob-</b> Typ <b>eignet sich</b> hervorragend f√ºr die Arbeit mit <b>Unity-</b> Objekten, sodass Sie die Parameter von Objekten √§ndern und sie beispielsweise im n√§chsten Frame anwenden k√∂nnen. <br>  Der Typ <b>Persistent</b> kann verwendet werden, wenn die Geschwindigkeit f√ºr Sie nicht wichtig ist, Sie jedoch nur st√§ndig Daten nebenbei berechnen m√ºssen, z. B. Daten √ºber ein Netzwerk verarbeiten oder die Arbeit einer KI. <br><br><div class="spoiler">  <b class="spoiler_title">Ung√ºltig und keine</b> <div class="spoiler_text">  <i>Es gibt zwei weitere Arten der Zuweisung: <b>Ung√ºltig</b> und <b>Keine</b> . Sie werden jedoch h√§ufiger zum Debuggen ben√∂tigt und nehmen nicht an der Arbeit teil.</i> <br></div></div><br><br><h3>  Jobhandle </h3><br>  Unabh√§ngig davon lohnt es sich, die Funktionen des Aufgabenhandles zu analysieren, da dieses kleine Handle nicht nur den Prozess der Aufgabenausf√ºhrung √ºberpr√ºft, sondern auch ganze Netzwerke von Aufgaben durch Abh√§ngigkeiten erstellen kann (obwohl ich sie lieber eher als Warteschlangen bezeichne). <br><br>  Wenn Sie beispielsweise zwei Aufgaben in einer bestimmten Reihenfolge ausf√ºhren m√ºssen, m√ºssen Sie dazu nur das Handle einer Aufgabe an das Handle einer anderen anh√§ngen. <br><br>  Es sieht ungef√§hr so ‚Äã‚Äãaus. <br><br><img src="https://lh3.googleusercontent.com/K62BSMljveR8lED8wCuCUCuLN6zyNlXS8RQybQuztrT_FMalHHSP7oMGIDf6xUcjXAMqRG3njvHIJ4FPL_tU1uSZr5XQDmCOPyM_YJye2i_z58lIPAkflcia511L2ILI72In61aT" alt="Bild"><br><br>  Jedes einzelne Handle enth√§lt zun√§chst eine eigene Aufgabe. In Kombination erhalten wir jedoch ein neues Handle mit zwei Aufgaben. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { Job jobA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleA = jobA.Schedule(); Job jobB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleB = jobB.Schedule(); JobHandle result = JobHandle.CombineDependecies(handleA, handleB); result.Complete(); }</code> </pre> <br></div></div><br>  Oder so. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); handle = job.Schedule(handle); } handle.Complete(); }</code> </pre> <br></div></div><br>  Die Ausf√ºhrungssequenz wird gespeichert und der Scheduler startet die n√§chste Aufgabe erst, wenn er von der vorherigen √ºberzeugt ist. Beachten Sie jedoch, dass die <b>Handle-</b> Eigenschaft IsCompleted auf den Abschluss aller darin enthaltenen Aufgaben wartet. <br><br><h2>  Fazit </h2><br><h3>  Container </h3><br><ol><li>  Vergessen Sie beim Arbeiten mit Daten in Containern nicht, dass es sich um Strukturen handelt. Wenn Sie also Daten im Container √ºberschreiben, werden diese nicht ge√§ndert, sondern erneut erstellt. </li><li>  <i>Was passiert, wenn Sie die Art der Zuordnung Temp festlegen und die Ressourcen nach Abschluss der Aufgabe nicht l√∂schen?</i>  Der Fehler. </li><li>  <i>Kann ich meine eigenen Container erstellen?</i>  Es ist m√∂glich, dass die Unites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Prozess der Erstellung benutzerdefinierter Container hier ausf√ºhrlich beschrieben haben, aber es ist besser, ein paar Mal dar√ºber nachzudenken: Lohnt es sich, vielleicht gibt es genug normale Container! </li></ol><br><h4>  Sicherheit! </h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statische Daten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versuchen Sie nicht, statische Daten in einer Aufgabe zu verwenden ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuf√§llig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und andere). Jeder Zugriff auf statische Daten verletzt die Sicherheit des Systems. Momentan k√∂nnen Sie auf statische Daten zugreifen, aber nur, wenn Sie sicher sind, dass sie sich w√§hrend der Arbeit nicht √§ndern - das hei√üt, sie sind vollst√§ndig statisch und schreibgesch√ºtzt. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann soll das Task-System verwendet werden?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle diese Beispiele, die hier im Artikel aufgef√ºhrt sind, sind nur bedingt und zeigen, wie Sie mit diesem System arbeiten und nicht wann Sie es verwenden. Das Task-System kann ohne </font><b><font style="vertical-align: inherit;">ECS</font></b><font style="vertical-align: inherit;"> verwendet werden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen verstehen, dass das System auch bei der Arbeit Ressourcen verbraucht und dass es aus jedem Grund einfach sinnlos ist, sofort Aufgaben zu schreiben und Containerhaufen zu erstellen - alles wird noch schlimmer. Zum Beispiel ist die Neuberechnung eines Arrays mit einer Gr√∂√üe von 10 Tausend Elementen nicht korrekt. Es dauert l√§nger, bis der Scheduler funktioniert. Wenn Sie jedoch alle Polygone eines riesigen Terrans neu berechnen oder sogar generieren, ist dies die richtige L√∂sung. Sie k√∂nnen den Terran in Aufgaben aufteilen und jedes in einem separaten Stream verarbeiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie st√§ndig in komplexe Berechnungen in Projekten involviert sind und st√§ndig nach neuen M√∂glichkeiten suchen, um diesen Prozess weniger ressourcenintensiv zu gestalten, dann ist </font><b><font style="vertical-align: inherit;">Job System</font></b><font style="vertical-align: inherit;"> genau das Richtige f√ºr Sie</font></font><b><font style="vertical-align: inherit;"></font></b>      .                      ,  <b>ECS</b>     .       <b>WebGL</b>     ,    <b>Job System</b>     ,      ,    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.google.com/url%3Fq%3D">   </a> <cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420829/">https://habr.com/ru/post/de420829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420815/index.html">Wie "die digitale Welt entschl√ºsseln" die Halle in die Luft jagte: Top 10 Berichte von DotNext 2018 Piter</a></li>
<li><a href="../de420819/index.html">Top 10 Python-Tools f√ºr maschinelles Lernen und Datenwissenschaft</a></li>
<li><a href="../de420821/index.html">Regel 10: 1 beim Programmieren und Schreiben</a></li>
<li><a href="../de420825/index.html">Heute ist das erste Spiel zwischen OpenAI- und Dota 2-Profis (Menschen haben gewonnen). Wir verstehen, wie der Bot funktioniert</a></li>
<li><a href="../de420827/index.html">Erstellen Sie ein einfaches Maven-Projekt mit Java EE + WildFly10 + JPA (Ruhezustand) + Postgresql + EJB + IntelliJ IDEA</a></li>
<li><a href="../de420831/index.html">Das Ger√§t zur Ausgabe von Cookies "Cook 3000"</a></li>
<li><a href="../de420833/index.html">Wichtige Monetarisierungsfehler bei Anwendungen [und wie man sie behebt]</a></li>
<li><a href="../de420837/index.html">Testen von Software-RAID-Arrays f√ºr NVMe-Ger√§te mithilfe der SNIA-Methode</a></li>
<li><a href="../de420841/index.html">Hotfix vor dem Krankenhaus oder ‚ÄûHey Swagger! Wo sind meine Fehler? "</a></li>
<li><a href="../de420843/index.html">7. September, Jekaterinburg - ein Treffen f√ºr .NET-Entwickler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>