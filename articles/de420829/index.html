<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋 👩🏻‍🤝‍👨🏼 👩🏼‍🤝‍👩🏻 Jobsystem. Übersicht von der anderen Seite ☺️ 🎪 ✔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der neuen Version von Unity im Jahr 2018 haben sie schließlich offiziell das neue Entity-Komponentensystem, kurz ECS , hinzugefügt, mit dem Sie nur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jobsystem. Übersicht von der anderen Seite</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420829/">  In der neuen Version von <b>Unity im Jahr</b> 2018 haben sie schließlich offiziell das neue <b>Entity-Komponentensystem,</b> kurz <b>ECS</b> , hinzugefügt, mit dem Sie nur mit ihren Daten arbeiten können, anstatt wie üblich mit den Komponenten des Objekts. <br><br>  Ein zusätzliches Task-System bietet Ihnen die Möglichkeit, parallele Rechenleistung zu verwenden, um die Leistung Ihres Codes zu verbessern. <br><a name="habracut"></a><br>  Zusammen bieten diese beiden neuen Systeme ( <b>ECS</b> und <b>Job System</b> ) eine neue Ebene der Datenverarbeitung. <br><br>  Insbesondere werde ich in diesem Artikel nicht das gesamte <b>ECS-</b> System analysieren, das derzeit als separat herunterladbarer Satz von Tools in <b>Einheit</b> verfügbar ist, sondern nur das Task-System und dessen Verwendung außerhalb des <b>ECS-</b> Pakets berücksichtigen. <br><br><h3>  Neues System </h3><br>  Ursprünglich hätte <b>Unity</b> zuvor Multithread-Computing verwenden können, aber all dies musste vom Entwickler selbst erstellt werden, um die Probleme selbst zu lösen und die Fallstricke zu umgehen.  Und wenn es früher notwendig war, direkt mit Dingen wie dem Erstellen von Threads, dem Schließen von Threads, Pools und der Synchronisierung zu arbeiten, fiel diese ganze Arbeit jetzt auf die Schultern der Engine, und der Entwickler selbst musste nur noch Aufgaben erstellen und ausführen. <br><br><h3>  Die Aufgaben </h3><br>  Um Berechnungen im neuen System durchzuführen, müssen Aufgaben verwendet werden, bei denen es sich um Objekte handelt, die aus Methoden und Daten für die Berechnung bestehen. <br><br>  Wie alle anderen Daten im <b>ECS-</b> System werden auch Aufgaben im <b>Jobsystem</b> als Strukturen dargestellt, die eine von drei Schnittstellen erben. <br><br><h4>  Ijob </h4><br>  Die einfachste Task-Schnittstelle mit einer <b>Execute-</b> Methode, die nichts in Form von Parametern akzeptiert und nichts zurückgibt. <br><br>  Die Aufgabe selbst sieht folgendermaßen aus: <br><br><div class="spoiler">  <b class="spoiler_title">Ijob</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  In der <b>Execute-</b> Methode können Sie die erforderlichen Berechnungen durchführen. <br><br><h4>  IJobParallelFor </h4><br>  Eine weitere Schnittstelle mit derselben <b>Execute-</b> Methode, die wiederum bereits den numerischen Parameterindex akzeptiert. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelFor</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Diese <b>IJobParallelFor-</b> Schnittstelle bietet im Gegensatz zur <b>IJob-</b> Schnittstelle die Möglichkeit, eine Aufgabe mehrmals auszuführen und diese Ausführung nicht nur auszuführen, sondern in Blöcke <b>aufzuteilen</b> , die zwischen Threads verteilt werden. <br><br>  <i>Unverständlich?</i>  <i>Mach dir darüber keine Sorgen, ich werde dir mehr erzählen.</i> <br><br><h4>  IJobParallelForTransform </h4><br>  Und die letzte spezielle Schnittstelle, die, wie der Name schon sagt, für diese Transformationen des Objekts ausgelegt ist.  Es enthält auch die <b>Execute-</b> Methode mit dem numerischen Parameterindex und dem <b>TransformAccess-</b> Parameter, in der sich Position, Größe und Drehung der Transformation befinden. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelForTransform</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelForTransform { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index, TransformAccess transform) {} }</code> </pre> <br></div></div><br>  Aufgrund der Tatsache, dass Sie nicht direkt in der Aufgabe mit <b>Unity-</b> Objekten arbeiten können, kann diese Schnittstelle Transformationsdaten nur als separate <b>TransformAccess-</b> Struktur verarbeiten. <br><br>  Wenn Sie fertig sind und wissen, wie Aufgabenstrukturen erstellt werden, können Sie mit dem Üben fortfahren. <br><br><h3>  Aufgabenerfüllung </h3><br>  Lassen Sie uns eine einfache Aufgabe erstellen, die von der <b>IJob-</b> Oberfläche <b>geerbt wurde</b> , und sie abschließen.  Dazu benötigen wir ein einfaches <b>MonoBehaviour-</b> Skript und die Struktur der Aufgabe selbst. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() {} }</code> </pre> <br></div></div><br>  Legen Sie dieses Skript nun auf einem Objekt in der Szene ab.  Im selben Skript ( <b>TestJob</b> ) schreiben wir die Struktur der Aufgabe und vergessen nicht, die erforderlichen Bibliotheken zu importieren. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Hello parallel world!"</span></span>); } }</code> </pre> <br></div></div><br>  Drucken Sie in der <b>Execute-</b> Methode beispielsweise eine einfache Zeile an die Konsole. <br><br>  <b>Fahren</b> wir nun mit der <b>Start-</b> Methode des <b>TestJob-</b> Skripts fort, in der wir eine Instanz der Aufgabe erstellen und dann ausführen. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.Schedule().Complete(); } }</code> </pre> <br></div></div><br>  Wenn Sie alles wie im Beispiel gemacht haben, erhalten Sie nach dem Start des Spiels eine einfache Nachricht an die Konsole wie auf dem Bild. <br><br><img src="https://lh6.googleusercontent.com/QQeMBMeZy0HVw0r_D5Q_cH4k6Zzt-HAC6uev1O4pR--mOh96C2TQvw5DTH1X3ZPE7LORJ4wdV5kyKjGiJzVWLFm-HBi8HzSP4-DlbrYa65eRV1RF672uwsLsZvrCKtF5CdaGJ5tj" alt="Bild"><br><br>  Was hier passiert: Nach dem Aufrufen der <b>Schedule-</b> Methode platziert der Scheduler die Aufgabe im Handle und kann nun durch Aufrufen der <b>Complete-</b> Methode <b>abgeschlossen</b> werden. <br><br>  Dies war ein Beispiel für eine Aufgabe, bei der einfach Text auf die Konsole gedruckt wurde.  Damit eine Aufgabe parallele Berechnungen durchführen kann, muss sie mit Daten gefüllt werden. <br><br><h3>  Daten in der Aufgabe </h3><br>  Wie im <b>ECS-</b> System gibt es bei Aufgaben keinen Zugriff auf <b>Unity-</b> Objekte. Sie können das <b>GameObject nicht</b> in die Aufgabe aufnehmen und dort seinen Namen ändern.  Sie können lediglich einige separate Objektparameter auf die Aufgabe übertragen, diese Parameter ändern und diese Änderungen nach Abschluss der Aufgabe wieder auf das Objekt anwenden. <br><br>  Die Daten in der Aufgabe selbst unterliegen mehreren Einschränkungen: Erstens müssen es Strukturen sein, und zweitens dürfen es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine konvertierbaren</a> Datentypen sein, <b>dh</b> Sie können nicht denselben <b>Booleschen Wert</b> oder dieselbe <b>Zeichenfolge</b> an die Aufgabe übergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float a, b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { float result = a + b; Debug.Log(result); } }</code> </pre> <br></div></div><br>  Und die Hauptbedingung: Auf Daten, die nicht in einem Container enthalten sind, kann nur innerhalb der Aufgabe zugegriffen werden! <br><br><h3>  Container </h3><br>  Bei der Arbeit mit Multithread-Computing müssen Daten zwischen Threads ausgetauscht werden.  Um Daten in sie übertragen und im Task-System zurücklesen zu können, gibt es für diese Zwecke Container.  Diese Container werden in Form gewöhnlicher Strukturen dargestellt, und ich arbeite nach dem Prinzip einer Brücke, über die Elementardaten zwischen Flüssen synchronisiert werden. <br><br>  Es gibt verschiedene Arten von Behältern: <br>  <b>NativeArray</b> .  Der einfachste und am häufigsten verwendete Containertyp wird als einfaches Array mit fester Größe dargestellt. <br>  <b>NativeSlice</b> .  Ein weiterer Container - ein Array, wie aus der Übersetzung hervorgeht, dient dazu, das NativeArray in Stücke zu schneiden. <br><br>  Dies sind die beiden Hauptcontainer, die ohne Anschluss eines <b>ECS-</b> Systems verfügbar sind.  In einer fortgeschritteneren Version gibt es mehrere weitere Arten von Containern. <br><br>  <b>NativeList</b> .  Es ist eine regelmäßige Liste von Daten. <br>  <b>NativeHashMap</b> .  Ein Analogon eines Wörterbuchs mit einem Schlüssel und einem Wert. <br>  <b>NativeMultiHashMap</b> .  <b>Dieselbe NativeHashMap</b> mit nur wenigen Werten unter einem Schlüssel. <br>  <b>NativeQueue</b>  Liste der Datenwarteschlangen. <br><br>  Da wir ohne Anschluss eines <b>ECS-</b> Systems arbeiten, stehen <b>uns</b> nur <b>NativeArray</b> und <b>NativeSlice</b> zur Verfügung. <br><br>  Bevor Sie mit dem praktischen Teil fortfahren, müssen Sie den wichtigsten Punkt analysieren - die Erstellung von Instanzen. <br><br><h3>  Erstellen Sie Container </h3><br>  Wie bereits erwähnt, stellen diese Container eine Brücke dar, über die Daten zwischen Threads synchronisiert werden.  Das Task-System öffnet diese Brücke vor Arbeitsbeginn und schließt sie nach Abschluss.  Der Öffnungsprozess wird als " <i>Zuweisung</i> " ( <b>Zuweisung</b> ) oder <i>"Zuweisung von Speicher" bezeichnet</i> , der Schließvorgang als " <i>Freigabe von Ressourcen</i> " ( <b>Entsorgen</b> ). <br><br>  Die Zuordnung bestimmt, wie lange die Aufgabe die Daten im Container verwenden kann - mit anderen Worten, wie lange die Brücke geöffnet sein wird. <br><br>  Um diese beiden Prozesse besser zu verstehen, schauen wir uns das folgende Bild an. <br><br><img src="https://lh4.googleusercontent.com/6yL2x_ynGZj1C1ukkQlfDZuYKzlvJ4ceAYU9Zyb40xwDzuASeUNB__Od067_3xZkYANEOPl84JoKLyqTPn4hrvQNogbksb7akoQvcWjDLg2yyUJY9eF37uj7TO0YkOL3cQyMsXPu" alt="Bild"><br><br>  Der untere Teil zeigt den Lebenszyklus des Hauptthreads ( <b>Hauptthread</b> ), der in der Anzahl der Frames berechnet wird. Im ersten Frame erstellen wir einen weiteren parallelen Thread ( <b>Neuer Thread),</b> der für eine bestimmte Anzahl von Frames vorhanden ist, und schließen dann sicher. <br>  Im selben <b>neuen Thread kommt die</b> Aufgabe mit dem Container an. <br><br>  Schauen Sie sich jetzt den oberen Rand des Bildes an. <br><br><img src="https://lh5.googleusercontent.com/1IZ_CMZhX4JfBWBLEuAijf1st_6e7p96EncPomR_jLNhQVbJDvS_o_-gf1emw3glwEGt8y3xXARp4xJJ9qu0WjYTH4asrblwul2rHa_SqQiLzrTTOoDJ5DlomcPBP8qkfCI3w9R8" alt="Bild"><br><br>  Der weiße Balken <b>Allocation</b> zeigt die Lebensdauer des Containers an.  Im ersten Frame wird der Container <i>zugewiesen</i> - die Brücke wird geöffnet, bis zu diesem Zeitpunkt der Container nicht vorhanden war. Nachdem alle Berechnungen in der Aufgabe abgeschlossen wurden, wird der Container aus dem Speicher freigegeben und im 9. Frame wird die Brücke geschlossen. <br><br>  Auch auf diesem Streifen ( <b>Zuordnung</b> ) befinden sich <b>Zeitsegmente</b> ( <b>Temp</b> , <b>TempJob</b> und <b>Presistent</b> ). Jedes dieser Segmente zeigt die geschätzte Lebensdauer des Containers. <br><br>  Warum werden diese Segmente benötigt?  Tatsache ist, dass die Ausführung einer Aufgabe nach Dauer unterschiedlich sein kann, wir können sie direkt in derselben Methode ausführen, in der wir sie erstellt haben, oder wir können die Ausführungszeit der Aufgabe verlängern, wenn sie recht kompliziert ist, und diese Segmente zeigen, wie dringend und wie lange die Aufgabe die Daten verwenden kann im Behälter. <br><br>  <i>Wenn es immer noch nicht klar ist, werde ich jede Art der Zuordnung anhand eines Beispiels analysieren.</i> <br><br>  Jetzt können wir mit dem praktischen Teil des Erstellens von Containern <b>fortfahren.</b> Dazu kehren wir zur <b>Start-</b> Methode des <b>TestJob-</b> Skripts zurück und erstellen eine neue Instanz des <b>NativeArray-</b> Containers. Vergessen Sie nicht, die erforderlichen Bibliotheken zu verbinden. <br><br><h3>  Temp </h3><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; using Unity.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); } }</code> </pre> <br></div></div><br>  Um eine neue Containerinstanz zu erstellen, müssen Sie die Größe und den Typ der Zuordnung in ihrem Konstruktor angeben.  In diesem Beispiel wird der <b>Temp-</b> Typ verwendet, da die Aufgabe nur in der <b>Start-</b> Methode ausgeführt wird. <br><br>  Initialisieren Sie nun genau dieselbe Array-Variable in der Struktur der <b>SimpleJob-</b> Task. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Fertig.  Jetzt können Sie die Aufgabe selbst erstellen und eine Array-Instanz an sie übergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; }</code> </pre> <br></div></div><br>  Um die Aufgabe dieses Mal <b>auszuführen</b> , verwenden wir das <b>JobHandle-</b> Handle, um sie durch Aufrufen derselben <b>Schedule-</b> Methode <b>abzurufen</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); }</code> </pre> <br></div></div><br>  Jetzt können Sie die <b>Complete-</b> Methode an ihrem Handle aufrufen und prüfen, ob die Aufgabe abgeschlossen ist, um den Text in der Konsole anzuzeigen. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">" "</span></span>); }</code> </pre> <br></div></div><br>  Wenn Sie die Aufgabe in dieser Form ausführen, wird nach dem Start des Spiels ein fetter roter Fehler angezeigt, der besagt, dass Sie den Array-Container nach Abschluss der Aufgabe nicht aus den Ressourcen freigegeben haben. <br><br>  So etwas in der Art. <br><br><img src="https://lh3.googleusercontent.com/EewKhLiPm0_qidpB0-YnlUfbTcIlzOhPw_OXgJqcmm-m9MpAaq96PHSc-FlN7GNArl9JkThBUZEGM9YFIHR5BkkMRUBwTAM6awQAEYGOw45i31irFlXtkT7peTOmjFfoEq_ASONA" alt="Bild"><br><br>  Um dies zu vermeiden, rufen Sie nach Abschluss der Aufgabe die <b>Dispose-</b> Methode für den Container auf. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">"Complete"</span></span>); array.Dispose(); }</code> </pre> <br></div></div><br>  Dann können Sie es sicher neu starten. <br>  Aber die Aufgabe macht nichts!  - Fügen Sie dann einige Aktionen hinzu. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { array[i] = i * i; } } }</code> </pre> <br></div></div><br>  Bei der <b>Execute-</b> Methode multipliziere ich den Index jedes Elements des Arrays mit mir selbst und schreibe ihn zurück in das Array- <b>Array</b> , um das Ergebnis in der <b>Start-</b> Methode an die Konsole zu drucken. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(job.array[job.array.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]); array.Dispose(); }</code> </pre> <br></div></div><br><blockquote>  Was ist das Ergebnis in der Konsole, wenn wir das letzte Element des Arrays im Quadrat drucken? </blockquote><br>  Auf diese Weise können Sie Container erstellen, in Aufgaben einfügen und Aktionen für sie ausführen. <br><br>  Dies war ein Beispiel für die Verwendung des <b>Temp-</b> Zuordnungstyps, bei dem eine Aufgabe innerhalb eines Frames ausgeführt wird.  Dieser Typ wird am besten verwendet, wenn Sie schnell Berechnungen durchführen müssen, ohne den Hauptthread zu laden. Sie müssen jedoch vorsichtig sein, wenn die Aufgabe zu kompliziert ist oder wenn viele davon auftreten, kann es zu einem Durchhängen kommen. In diesem Fall ist es besser, den <b>TempJob-</b> Typ zu verwenden <b>,</b> den ich später analysieren werde. <br><br><h3>  Tempjob </h3><br>  In diesem Beispiel werde ich <b>die</b> Struktur der <b>SimpleJob-</b> Task leicht <b>ändern</b> und von einer anderen <b>IJobParallelFor-</b> Schnittstelle erben. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Da die Aufgabe länger als ein Frame ausgeführt wird, werden die Ergebnisse der Aufgabe in verschiedenen <b>Awake-</b> und <b>Start-</b> Methoden ausgeführt und <b>gesammelt</b> , die in Form einer Coroutine dargestellt werden.  Ändern Sie dazu das Erscheinungsbild der <b>TestJob-</b> Klasse ein <b>wenig</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() {} IEnumerator Start() {} }</code> </pre> <br></div></div><br>  In der <b>Awake-</b> Methode erstellen wir eine Aufgabe und einen Container mit Vektoren und geben in der <b>Start-</b> Methode die empfangenen Daten aus und geben Ressourcen frei. <br><br><div class="spoiler">  <b class="spoiler_title">Wach auf</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; }</code> </pre> <br></div></div><br>  Auch hier wird ein <b>Array-</b> Container mit der Art der Zuordnung <b>TempJob</b> erstellt. <b>Anschließend</b> erstellen wir eine Aufgabe und erhalten ihr Handle, indem wir die <b>Schedule-</b> Methode mit geringfügigen Änderungen aufrufen. <br><br><div class="spoiler">  <b class="spoiler_title">Wach auf</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br></div></div><br>  Der erste Parameter in der <b>Schedule-</b> Methode gibt an, wie oft die Aufgabe ausgeführt wird. Hier ist dieselbe Zahl wie die Größe des Array- <b>Arrays</b> . <br>  Der zweite Parameter gibt an, wie viele Blöcke die Aufgabe gemeinsam nutzen sollen. <br><br>  <i>Welche anderen Blöcke?</i> <br>  Früher, um eine Aufgabe abzuschließen, hat ein Thread die <b>Execute-</b> Methode nur einmal aufgerufen. Jetzt muss diese Methode 100 Mal aufgerufen werden, sodass der Scheduler diese 100-maligen Wiederholungen in Blöcke aufteilt, die er zwischen den Threads verteilt, um keinen separaten Thread zu laden.  In diesem Beispiel werden hundert Wiederholungen in 5 Blöcke mit jeweils 20 Wiederholungen unterteilt, dh der Scheduler verteilt diese 5 Blöcke vermutlich auf 5 Threads, wobei jeder Thread die <b>Execute-</b> Methode 20 Mal <b>aufruft</b> .  In der Praxis ist es natürlich keine Tatsache, dass der Scheduler genau das tut, es hängt alles von der Arbeitslast des Systems ab, sodass möglicherweise alle 100 Wiederholungen in einem Thread stattfinden. <br><br>  Jetzt können Sie die <b>Complete-</b> Methode im Task-Handle aufrufen. <br><br><div class="spoiler">  <b class="spoiler_title">Wach auf</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  In der <b>Start-</b> Coroutine überprüfen wir die Ausführung der Aufgabe und bereinigen dann den Container. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.isCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Fahren wir nun mit den Aktionen in der Aufgabe selbst fort. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) { float x = index; float y = index; Vector2 vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x * x, y * y / (y * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array[index] = vector; } }</code> </pre> <br></div></div><br>  Zeigen Sie nach Abschluss der Aufgabe in der <b>Start-</b> Methode alle Elemente des Arrays in der Konsole an. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } foreach(Vector2 vector <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array) { print(vector); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Wenn Sie fertig sind, können Sie das Ergebnis anzeigen. <br><br>  Schauen Sie sich die folgenden Bilder an <b>,</b> um den Unterschied zwischen <b>IJob</b> und <b>IJobParallelFor</b> zu verstehen. <br>  In <b>IJob können</b> Sie beispielsweise eine einfache <b>for-</b> Schleife verwenden, um Berechnungen mehrmals durchzuführen. In jedem Fall kann ein Thread die <b>Execute-</b> Methode jedoch nur einmal für die gesamte Dauer der Aufgabe aufrufen. Auf diese Weise kann eine Person Hunderte derselben Aktionen hintereinander ausführen. <br><br><img src="https://lh3.googleusercontent.com/qUadSqRojz1W8kiqtm-xgi-TYeJ9IlVh38o0MrG0mTWnU3j0qTjtTOWa8pkPc0kjPQcTKoqOJtNl6E4Olb5MKCNgUhrsAXGujN0flm_YVoFfEVS9kCCjFOucANAw74Kjq2W_Zzho" alt="Bild"><br><br>  <b>IJobParallelFor</b> bietet nicht nur die <b>Möglichkeit</b> , eine Aufgabe in einem Thread mehrmals auszuführen, sondern diese Wiederholungen auch auf andere Threads zu verteilen. <br><br><img src="https://lh5.googleusercontent.com/-5ggH4tUKWvhz6I8UUi2eGzqY_B_QqA1PA_298vp89xg4v2yC3wn3N9D8TlVOMwWuDM593H_Aw9WZOU-_esyT7vyL4MM17bZaevfiOiYSEUb0I1oT2Fi3cXbBtoc9SuMYIhVnMc7" alt="Bild"><br><br>  Im Allgemeinen ist die Art der Zuordnung <b>TempJob</b> perfekt für die meisten Aufgaben, die über mehrere Frames ausgeführt werden. <br><br>  Was aber, wenn Sie Daten auch nach Abschluss einer Aufgabe speichern müssen, was ist, wenn Sie sie nach Erhalt des Ergebnisses nicht sofort zerstören müssen?  Hierzu ist es erforderlich, die Art der Zuordnung <b>Persistent zu verwenden</b> , was die Freigabe von Ressourcen dann „ <i>bei Bedarf!“ Impliziert.</i>  . <br><br><h3>  Hartnäckig </h3><br>  <b>Kehren wir</b> zur <b>TestJob-</b> Klasse zurück und ändern sie.  Jetzt erstellen wir Aufgaben in der <b>OnEnable-</b> Methode, überprüfen deren Ausführung in der <b>Update-</b> Methode und bereinigen Ressourcen in der <b>OnDisable-</b> Methode. <br>  In diesem Beispiel verschieben wir das Objekt in der <b>Update-</b> Methode. Zur Berechnung der Trajektorie verwenden wir zwei Vektorcontainer - <b>inputArray,</b> in die wir die aktuelle Position und <b>outputArray einfügen,</b> von wo aus wir die Ergebnisse erhalten. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; inputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() {} }</code> </pre> <br></div></div><br>  <b>Wir werden</b> auch <b>die</b> Struktur der <b>SimpleJob-</b> Task leicht <b>ändern,</b> indem <b>wir</b> sie von der <b>IJob-</b> Schnittstelle erben, um sie einmal auszuführen. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  In der Aufgabe selbst werden wir auch zwei Vektorcontainer verraten, einen Positionsvektor und ein numerisches Delta, die das Objekt zum Ziel bewegen. <br><br><div class="spoiler">  <b class="spoiler_title">Simplejob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; inputArray; [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float delta; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Die Attribute <b>ReadOnly</b> und <b>WriteOnly</b> zeigen die <b>Flussbeschränkungen</b> für die Aktionen an, die den Daten in den Containern zugeordnet sind.  <b>ReadOnly</b> bietet den Stream nur zum Lesen von Daten aus dem Container an. Das <b>WriteOnly-</b> Attribut hingegen ermöglicht es dem Stream, nur Daten in den Container zu schreiben.  Wenn Sie diese beiden Aktionen gleichzeitig mit einem Container ausführen müssen, müssen Sie ihn überhaupt nicht mit einem Attribut markieren. <br><br>  <b>Fahren</b> wir mit der <b>OnEnable-</b> Methode der <b>TestJob-</b> Klasse fort, in der die Container initialisiert werden. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); }</code> </pre> <br></div></div><br>  Die Abmessungen der Container sind einfach, da Parameter nur einmal gesendet und empfangen werden müssen.  Die Art der Zuordnung ist <b>dauerhaft</b> . <br>  Bei der <b>OnDisable-</b> Methode geben <b>wir</b> die Ressourcen der Container frei. <br><br><div class="spoiler">  <b class="spoiler_title">Ondisable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray.Dispose(); }</code> </pre> <br></div></div><br>  Erstellen wir eine separate <b>CreateJob-</b> Methode, in der wir eine Aufgabe mit ihrem Handle erstellen und dort mit Daten füllen. <br><br><div class="spoiler">  <b class="spoiler_title">CreateJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateJob() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.delta = Time.deltaTime; Vector2 position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position; job.position = position; Vector2 newPosition = position + Vector2.right; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; job.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray; job.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  <i>Eigentlich wird <b>inputArray</b> hier nicht wirklich benötigt, da es möglich ist, einen Richtungsvektor nur auf die Aufgabe zu übertragen, aber ich denke, es ist besser zu verstehen, warum diese <b>ReadOnly-</b> und <b>WriteOnly-</b> Attribute überhaupt benötigt werden.</i> <br><br>  In der <b>Update-</b> Methode prüfen wir, ob die Aufgabe abgeschlossen ist. Anschließend wenden wir das erhaltene Ergebnis auf die Objekttransformation an und führen es erneut aus. <br><br><div class="spoiler">  <b class="spoiler_title">Update</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position = newPosition; CreateJob(); } }</code> </pre> <br></div></div><br>  Bevor wir beginnen, werden wir die <b>OnEnable-</b> Methode leicht <b>anpassen</b> , sodass die Aufgabe unmittelbar nach der Initialisierung der Container erstellt wird. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); CreateJob(); }</code> </pre> <br></div></div><br>  Fertig, jetzt können Sie zur Aufgabe selbst gehen und die erforderlichen Berechnungen in der <b>Execute-</b> Methode durchführen. <br><br><div class="spoiler">  <b class="spoiler_title">Ausführen</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; newPosition = Vector2.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position, newPosition, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; }</code> </pre> <br></div></div><br>  Um das Ergebnis der Arbeit zu sehen, können Sie das <b>TestJob-</b> Skript auf ein Objekt werfen und das Spiel ausführen. <br><br>  Zum Beispiel verschiebt sich mein Sprite nur allmählich nach rechts. <br><br><div class="spoiler">  <b class="spoiler_title">Animation</b> <div class="spoiler_text"><img src="https://lh3.googleusercontent.com/YCf68msYSI0w6ARjOAeAWsPPhpPOrXC-3jWTfqtlnu1pS1xa9m6FCjTD3DdvcvWi5KSEh_-q6X2yUf62j1FOgSU6d0plX603FOQiydF-yLRQFvbd2YBY-mp8I5p5V4cQH9t7SKPR" alt="Bild"><br></div></div><br>  Im Allgemeinen <b>eignet sich</b> die Art der Zuordnung <b>Persistent</b> hervorragend für wiederverwendbare Container, die nicht jedes Mal zerstört und neu erstellt werden müssen. <br><br>  <i>Also, welche Art zu verwenden !?</i> <br>  Der <b>Temp-</b> Typ eignet sich am besten für die schnelle Durchführung von Berechnungen. Wenn die Aufgabe jedoch zu komplex und zu groß ist, kann es zu einem Durchhang kommen. <br>  Der <b>TempJob-</b> Typ <b>eignet sich</b> hervorragend für die Arbeit mit <b>Unity-</b> Objekten, sodass Sie die Parameter von Objekten ändern und sie beispielsweise im nächsten Frame anwenden können. <br>  Der Typ <b>Persistent</b> kann verwendet werden, wenn die Geschwindigkeit für Sie nicht wichtig ist, Sie jedoch nur ständig Daten nebenbei berechnen müssen, z. B. Daten über ein Netzwerk verarbeiten oder die Arbeit einer KI. <br><br><div class="spoiler">  <b class="spoiler_title">Ungültig und keine</b> <div class="spoiler_text">  <i>Es gibt zwei weitere Arten der Zuweisung: <b>Ungültig</b> und <b>Keine</b> . Sie werden jedoch häufiger zum Debuggen benötigt und nehmen nicht an der Arbeit teil.</i> <br></div></div><br><br><h3>  Jobhandle </h3><br>  Unabhängig davon lohnt es sich, die Funktionen des Aufgabenhandles zu analysieren, da dieses kleine Handle nicht nur den Prozess der Aufgabenausführung überprüft, sondern auch ganze Netzwerke von Aufgaben durch Abhängigkeiten erstellen kann (obwohl ich sie lieber eher als Warteschlangen bezeichne). <br><br>  Wenn Sie beispielsweise zwei Aufgaben in einer bestimmten Reihenfolge ausführen müssen, müssen Sie dazu nur das Handle einer Aufgabe an das Handle einer anderen anhängen. <br><br>  Es sieht ungefähr so ​​aus. <br><br><img src="https://lh3.googleusercontent.com/K62BSMljveR8lED8wCuCUCuLN6zyNlXS8RQybQuztrT_FMalHHSP7oMGIDf6xUcjXAMqRG3njvHIJ4FPL_tU1uSZr5XQDmCOPyM_YJye2i_z58lIPAkflcia511L2ILI72In61aT" alt="Bild"><br><br>  Jedes einzelne Handle enthält zunächst eine eigene Aufgabe. In Kombination erhalten wir jedoch ein neues Handle mit zwei Aufgaben. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { Job jobA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleA = jobA.Schedule(); Job jobB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleB = jobB.Schedule(); JobHandle result = JobHandle.CombineDependecies(handleA, handleB); result.Complete(); }</code> </pre> <br></div></div><br>  Oder so. <br><br><div class="spoiler">  <b class="spoiler_title">Starten Sie</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); handle = job.Schedule(handle); } handle.Complete(); }</code> </pre> <br></div></div><br>  Die Ausführungssequenz wird gespeichert und der Scheduler startet die nächste Aufgabe erst, wenn er von der vorherigen überzeugt ist. Beachten Sie jedoch, dass die <b>Handle-</b> Eigenschaft IsCompleted auf den Abschluss aller darin enthaltenen Aufgaben wartet. <br><br><h2>  Fazit </h2><br><h3>  Container </h3><br><ol><li>  Vergessen Sie beim Arbeiten mit Daten in Containern nicht, dass es sich um Strukturen handelt. Wenn Sie also Daten im Container überschreiben, werden diese nicht geändert, sondern erneut erstellt. </li><li>  <i>Was passiert, wenn Sie die Art der Zuordnung Temp festlegen und die Ressourcen nach Abschluss der Aufgabe nicht löschen?</i>  Der Fehler. </li><li>  <i>Kann ich meine eigenen Container erstellen?</i>  Es ist möglich, dass die Unites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Prozess der Erstellung benutzerdefinierter Container hier ausführlich beschrieben haben, aber es ist besser, ein paar Mal darüber nachzudenken: Lohnt es sich, vielleicht gibt es genug normale Container! </li></ol><br><h4>  Sicherheit! </h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statische Daten.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versuchen Sie nicht, statische Daten in einer Aufgabe zu verwenden ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zufällig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und andere). Jeder Zugriff auf statische Daten verletzt die Sicherheit des Systems. Momentan können Sie auf statische Daten zugreifen, aber nur, wenn Sie sicher sind, dass sie sich während der Arbeit nicht ändern - das heißt, sie sind vollständig statisch und schreibgeschützt. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann soll das Task-System verwendet werden?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle diese Beispiele, die hier im Artikel aufgeführt sind, sind nur bedingt und zeigen, wie Sie mit diesem System arbeiten und nicht wann Sie es verwenden. Das Task-System kann ohne </font><b><font style="vertical-align: inherit;">ECS</font></b><font style="vertical-align: inherit;"> verwendet werden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen verstehen, dass das System auch bei der Arbeit Ressourcen verbraucht und dass es aus jedem Grund einfach sinnlos ist, sofort Aufgaben zu schreiben und Containerhaufen zu erstellen - alles wird noch schlimmer. Zum Beispiel ist die Neuberechnung eines Arrays mit einer Größe von 10 Tausend Elementen nicht korrekt. Es dauert länger, bis der Scheduler funktioniert. Wenn Sie jedoch alle Polygone eines riesigen Terrans neu berechnen oder sogar generieren, ist dies die richtige Lösung. Sie können den Terran in Aufgaben aufteilen und jedes in einem separaten Stream verarbeiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie ständig in komplexe Berechnungen in Projekten involviert sind und ständig nach neuen Möglichkeiten suchen, um diesen Prozess weniger ressourcenintensiv zu gestalten, dann ist </font><b><font style="vertical-align: inherit;">Job System</font></b><font style="vertical-align: inherit;"> genau das Richtige für Sie</font></font><b><font style="vertical-align: inherit;"></font></b>      .                      ,  <b>ECS</b>     .       <b>WebGL</b>     ,    <b>Job System</b>     ,      ,    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.google.com/url%3Fq%3D">   </a> <cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420829/">https://habr.com/ru/post/de420829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420815/index.html">Wie "die digitale Welt entschlüsseln" die Halle in die Luft jagte: Top 10 Berichte von DotNext 2018 Piter</a></li>
<li><a href="../de420819/index.html">Top 10 Python-Tools für maschinelles Lernen und Datenwissenschaft</a></li>
<li><a href="../de420821/index.html">Regel 10: 1 beim Programmieren und Schreiben</a></li>
<li><a href="../de420825/index.html">Heute ist das erste Spiel zwischen OpenAI- und Dota 2-Profis (Menschen haben gewonnen). Wir verstehen, wie der Bot funktioniert</a></li>
<li><a href="../de420827/index.html">Erstellen Sie ein einfaches Maven-Projekt mit Java EE + WildFly10 + JPA (Ruhezustand) + Postgresql + EJB + IntelliJ IDEA</a></li>
<li><a href="../de420831/index.html">Das Gerät zur Ausgabe von Cookies "Cook 3000"</a></li>
<li><a href="../de420833/index.html">Wichtige Monetarisierungsfehler bei Anwendungen [und wie man sie behebt]</a></li>
<li><a href="../de420837/index.html">Testen von Software-RAID-Arrays für NVMe-Geräte mithilfe der SNIA-Methode</a></li>
<li><a href="../de420841/index.html">Hotfix vor dem Krankenhaus oder „Hey Swagger! Wo sind meine Fehler? "</a></li>
<li><a href="../de420843/index.html">7. September, Jekaterinburg - ein Treffen für .NET-Entwickler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>