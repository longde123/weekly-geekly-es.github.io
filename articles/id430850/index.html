<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥¨ ğŸ˜„ ğŸ“‰ Apple Metal di MAPS.ME ğŸ‚ğŸ½ ğŸšŸ ğŸ‘¨ğŸ¼â€ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Di dunia ada sejumlah besar aplikasi di OpenGL, dan tampaknya Apple tidak setuju dengan ini. Dimulai dengan iOS 12 dan MacOS Mojave,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apple Metal di MAPS.ME</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/430850/"><img src="https://habrastorage.org/webt/jf/bk/ix/jfbkixzquc9k0dnnqnaorskj4bk.png" alt="gambar" align="left">  Halo semuanya! <br><br>  Di dunia ada sejumlah besar aplikasi di OpenGL, dan tampaknya Apple tidak setuju dengan ini.  Dimulai dengan iOS 12 dan MacOS Mojave, OpenGL telah ditinggalkan.  Kami telah mengintegrasikan Apple Metal di MAPS.ME dan siap untuk berbagi pengalaman dan hasil kami.  Kami akan memberi tahu Anda bagaimana mesin grafis kami refactored, kesulitan apa yang harus kami hadapi dan, yang paling penting, berapa banyak FPS yang kami miliki sekarang. <br><br>  Semua orang yang tertarik atau mempertimbangkan untuk menambahkan dukungan Apple Metal ke mesin grafis dipersilakan untuk kucing. <br><a name="habracut"></a><br><h2>  Masalah </h2><br>  Mesin grafis kami dirancang sebagai lintas-platform, dan karena OpenGL, pada kenyataannya, satu-satunya API grafis lintas-platform untuk set platform yang kami minati (iOS, Android, MacOS dan Linux), kami memilihnya sebagai dasarnya.  Kami tidak membuat level abstraksi tambahan yang akan menyembunyikan fitur-fitur khusus untuk OpenGL, tetapi, untungnya, meninggalkan potensi untuk implementasinya. <br><br>  Dengan munculnya generasi baru API grafis Apple Metal dan Vulkan, kami, tentu saja, mempertimbangkan kemungkinan kemunculannya dalam aplikasi kami, namun, kami dihentikan oleh yang berikut: <br><br><ol><li>  Vulkan hanya bisa bekerja di Android dan Linux, dan Apple Metal hanya bisa bekerja di iOS dan MacOS.  Kami tidak ingin kehilangan lintas-platformness pada tingkat API grafik, ini akan mempersulit pengembangan dan proses debugging, akan meningkatkan jumlah pekerjaan. </li><li>  Aplikasi di Apple Metal tidak dapat dibangun dan dijalankan pada simulator iOS (omong-omong, sampai sekarang), yang juga akan mempersulit pengembangan kami dan tidak akan memungkinkan kami untuk sepenuhnya menyingkirkan OpenGL. </li><li>  Kerangka Qt, yang kami gunakan untuk membuat alat internal, hanya mendukung OpenGL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vulkan sekarang didukung</a> ). </li><li>  Apple Metal tidak memiliki dan tidak memiliki C ++ API, yang akan memaksa kami untuk membuat abstraksi tidak hanya untuk runtime, tetapi juga untuk fase pembuatan aplikasi, ketika bagian dari mesin dikompilasi dalam Objective-C ++, dan yang lain, secara substansial lebih besar, di C ++. </li><li>  Kami tidak siap untuk membuat mesin terpisah atau cabang kode terpisah khusus untuk iOS. </li><li>  Implementasi dievaluasi setidaknya enam bulan dalam pekerjaan satu pengembang grafis. </li></ol><br>  Ketika pada musim semi tahun 2018 Apple mengumumkan transfer OpenGL ke status yang ditinggalkan, menjadi jelas bahwa tidak mungkin lagi untuk menunda, dan masalah di atas perlu dipecahkan dengan satu atau lain cara.  Selain itu, kami telah lama berupaya mengoptimalkan kecepatan aplikasi dan konsumsi daya, dan Apple Metal tampaknya dapat membantu. <br><br><h2>  Pemilihan keputusan </h2><br>  Hampir segera kami memperhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MoltenVK</a> .  Kerangka kerja ini mengemulasi Vulkan API menggunakan Apple Metal, dan kode sumbernya baru-baru ini dibuka.  Menggunakan MoltenVK, tampaknya, akan memungkinkan penggantian OpenGL dengan Vulkan, dan tidak harus berurusan dengan integrasi Apple Metal yang terpisah sama sekali.  Selain itu, pengembang Qt telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menolak dukungan terpisah untuk rendering di Apple Metal yang</a> mendukung MoltenVK.  Namun, kami dihentikan: <br><br><ul><li>  kebutuhan untuk mendukung perangkat Android di mana Vulkan tidak tersedia; </li><li>  ketidakmampuan untuk memulai pada simulator iOS tanpa kehadiran fallback pada OpenGL; </li><li>  ketidakmampuan untuk menggunakan alat Apple untuk debugging, profil dan mengkompilasi shader, karena MoltenVK menghasilkan shader real-time untuk Apple Metal dari kode sumber SPIR-V atau GLSL; </li><li>  kebutuhan untuk menunggu pembaruan dan perbaikan bug MoltenVK ketika versi baru Logam dirilis; </li><li>  ketidakmungkinan pengoptimalan halus khusus untuk Logam, tetapi tidak spesifik atau tidak ada untuk Vulkan. </li></ul><br>  Ternyata kami perlu menyimpan OpenGL, yang berarti kami tidak dapat melakukannya tanpa mengabstraksikan mesin dari API grafis.  Apple Metal, OpenGL ES, dan di masa depan Vulkan, akan digunakan untuk membuat komponen internal independen dari mesin grafis, yang dapat sepenuhnya dipertukarkan.  OpenGL akan memainkan peran opsi mundur ketika Metal atau Vulkan tidak tersedia karena satu dan lain alasan. <br><br>  Rencana implementasi adalah sebagai berikut: <br><br><ol><li>  Refactoring mesin grafis untuk abstrak API grafik yang digunakan. </li><li>  Render ke Apple Metal untuk versi aplikasi iOS. </li><li>  Buat tolok ukur yang tepat untuk kecepatan render dan konsumsi daya untuk melihat apakah API grafik modern tingkat rendah dapat menguntungkan produk. </li></ol><br><h2>  Perbedaan utama antara OpenGL dan Logam </h2><br>  Untuk memahami bagaimana cara abstrak API grafis, pertama mari kita tentukan apa perbedaan konseptual utama antara OpenGL dan Logam. <br><br><ol><li>  Dipercaya, dan bukan tanpa alasan, bahwa Logam adalah API tingkat rendah.  Namun, ini tidak berarti bahwa Anda harus menulis di assembler atau mengimplementasikan rasterisasi sendiri.  Logam dapat disebut API tingkat rendah dalam arti bahwa ia melakukan sejumlah kecil tindakan implisit, yaitu, hampir semua tindakan harus ditulis kepada programmer sendiri.  OpenGL melakukan banyak hal secara implisit, mulai dari mendukung referensi implisit ke konteks OpenGL dan menghubungkan konteks ini ke aliran di mana ia dibuat. </li><li>  Dalam Logam, "tidak" validasi waktu-nyata dari tim.  Dalam mode debug, validasi, tentu saja, ada dan dibuat jauh lebih baik daripada di banyak API lain, sebagian besar karena integrasi yang erat dengan Xcode.  Tetapi ketika program dikirim ke pengguna, maka tidak ada validasi lagi, program hanya crash pada kesalahan pertama.  Tidak perlu dikatakan, OpenGL hanya crash dalam kasus yang paling ekstrim.  Praktik yang paling umum: untuk mengabaikan kesalahan dan terus bekerja. </li><li>  Logam dapat mengkompilasi shader dan membangun perpustakaan dari mereka.  Di OpenGL, shader dikompilasi dari sumber dalam proses program, karena ini bertanggung jawab atas implementasi OpenGL tingkat rendah yang spesifik pada perangkat tertentu.  Perbedaan dan / atau kesalahan dalam implementasi shader compiler kadang-kadang menyebabkan bug yang fantastis, terutama pada perangkat Android merek Cina. </li><li>  OpenGL aktif menggunakan mesin negara, yang menambahkan efek samping ke hampir setiap fungsi.  Dengan demikian, fungsi OpenGL bukan fungsi murni, dan urutan dan riwayat panggilan seringkali penting.  Logam tidak menggunakan status secara implisit dan tidak mempertahankannya lebih lama dari yang diperlukan untuk rendering.  Negara ada sebagai objek yang dibuat sebelumnya dan gagal. </li></ol><br><h2>  Mesin grafis refactoring dan embedding Metal </h2><br>  Proses refactoring mesin grafis pada dasarnya terdiri dari menemukan solusi terbaik untuk menghilangkan fitur OpenGL yang telah digunakan mesin kami secara aktif.  Embedding Metal, mulai dari salah satu tahapan, berjalan paralel. <br><br><ul><li>  Seperti yang sudah disebutkan, OpenGL API memiliki entitas implisit yang disebut konteks.  Konteksnya dikaitkan dengan utas tertentu, dan fungsi OpenGL yang dipanggil utas itu sendiri menemukan dan menggunakan konteks ini.  Logam, Vulkan (ya, dan API lainnya, misalnya, Direct3D) tidak berfungsi dengan cara ini, mereka memiliki objek eksplisit serupa yang disebut perangkat atau instance.  Pengguna sendiri menciptakan objek-objek ini dan bertanggung jawab atas transfer mereka ke berbagai subsistem.  Melalui objek-objek ini semua panggilan ke perintah grafis dilakukan. <br><br>  Kami menyebut objek abstrak kami konteks grafis, dan dalam kasus OpenGL itu hanya menghiasi panggilan perintah OpenGL, dan dalam kasus Logam itu berisi antarmuka MTLDevice root melalui mana perintah Logam dipanggil. <br><br>  Tentu saja, saya harus mendistribusikan objek ini (dan karena kami memiliki rendering multi-threaded, maka bahkan beberapa objek seperti itu) di semua subsistem. <br><br>  Kami menyembunyikan penciptaan antrian perintah, penyandi, dan manajemennya di dalam konteks grafik, agar tidak menyebar entitas yang tidak ada di OpenGL. </li><li>  Prospek hilangnya validasi perintah grafis pada perangkat pengguna tidak secara terbuka menyenangkan bagi kami.  Berbagai perangkat dan versi OS tidak dapat sepenuhnya dicakup oleh departemen QA kami.  Oleh karena itu, kami harus menambahkan log terperinci di mana kami sebelumnya menerima kesalahan yang berarti dari API grafis.  Tentu saja, validasi ini ditambahkan hanya ke lokasi yang berpotensi berbahaya dan kritis dari mesin grafis, karena mencakup seluruh mesin dengan kode diagnostik praktis tidak mungkin dan umumnya berbahaya bagi kinerja.  Kenyataan baru adalah bahwa pengujian pengguna dan debugging dengan log sekarang di masa lalu, setidaknya dalam hal rendering. </li><li>  Sistem shader kami sebelumnya tidak cocok untuk refactoring, saya harus menulis ulang sepenuhnya.  Intinya di sini bukan hanya kompilasi dari shader dan validasinya pada tahap perakitan proyek.  OpenGL menggunakan apa yang disebut variabel seragam untuk meneruskan parameter ke shader.  Transfer data terstruktur hanya tersedia dengan OpenGL ES 3.0, dan karena kami masih mendukung OpenGL ES 2.0, kami sama sekali tidak menggunakan metode ini.  Logam membuat kami menggunakan struktur data untuk melewati parameter, dan untuk OpenGL kami harus membuat bidang struktur pemetaan ke variabel yang seragam.  Selain itu, saya harus menulis ulang setiap shader dalam Bahasa Shading Metal. </li><li>  Saat menggunakan objek keadaan, kami harus mencari trik.  Di OpenGL, semua negara, sebagai aturan, ditetapkan segera sebelum rendering, dan dalam Metal ini harus objek yang dibuat dan divalidasi sebelumnya.  Mesin kami, jelas, menggunakan pendekatan OpenGL, dan refactoring dengan penciptaan awal objek negara sebanding dengan penulisan ulang lengkap mesin.  Untuk memotong simpul ini, kami membuat cache negara di dalam konteks grafis.  Pertama kali kombinasi unik dari parameter status dihasilkan, objek state dibuat dalam Logam dan ditempatkan di cache.  Untuk waktu kedua dan selanjutnya, objek hanya diambil dari cache.  Ini berfungsi di peta kami, karena jumlah kombinasi parameter negara yang berbeda tidak terlalu besar (sekitar 20-30).  Untuk mesin grafis gim yang kompleks, metode ini tidak cocok. </li></ul><br>  Hasilnya, setelah sekitar 5 bulan bekerja, kami dapat meluncurkan MAPS.ME untuk pertama kalinya dengan perenderan penuh pada Apple Metal.  Sudah waktunya untuk mencari tahu apa yang terjadi. <br><br><h2>  Pengujian Kecepatan Rendering </h2><br><h4>  Teknik eksperimental </h4><br>  Kami menggunakan berbagai generasi perangkat Apple dalam percobaan.  Semuanya diperbarui ke iOS 12. Skrip pengguna yang sama dijalankan pada semua - navigasi peta (bergerak dan penskalaan).  Script ditulis untuk menjamin identitas proses yang hampir lengkap dalam aplikasi setiap kali dimulai pada setiap perangkat.  Sebagai lokasi pengujian, kami memilih area Los Angeles - salah satu area yang paling banyak dimuat di MAPS.ME. <br><br>  Pertama, skrip dijalankan dengan rendering pada OpenGL ES 3.0, kemudian pada perangkat yang sama dengan rendering pada Apple Metal.  Antara awal, aplikasi benar-benar dibongkar dari memori. <br>  Indikator-indikator berikut diukur: <br><br><ul><li>  FPS (bingkai per detik) untuk seluruh bingkai; </li><li>  FPS untuk bagian frame yang hanya bergerak dalam rendering, tidak termasuk persiapan data dan operasi frame-by-frame lainnya; </li><li>  Persentase frame lambat (lebih dari ~ 30 ms), mis.  yang oleh mata manusia bisa dianggap sebagai tersentak. </li></ul><br>  Saat mengukur FPS, menggambar langsung pada layar perangkat tidak termasuk, karena sinkronisasi vertikal dengan kecepatan refresh layar tidak memungkinkan memperoleh hasil yang andal.  Karena itu, bingkai itu ditarik ke dalam tekstur dalam memori.  Untuk menyinkronkan CPU dan GPU, OpenGL menggunakan panggilan tambahan untuk <code>glFinish</code> , sementara Apple Metal menggunakan <code>waitUntilCompleted</code> untuk <code>MTLFrameCommandBuffer</code> . <br><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100"></th><th width="100">  iPhone 7+ </th><th width="100"></th><th width="100">  iPhone 8 </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  Logam </th><th>  Opengl </th><th>  Logam </th><th>  Opengl </th><th>  Logam </th></tr><tr><td>  Fps </td><td>  106 </td><td>  160 </td><td>  159 </td><td>  221 </td><td>  196 </td><td>  298 </td></tr><tr><td>  FPS (render saja) </td><td>  157 </td><td>  596 </td><td>  247 </td><td>  597 </td><td>  271 </td><td>  833 </td></tr><tr><td>  Fraksi bingkai lambat (&lt;30 fps) </td><td>  4,13% </td><td>  1,25% </td><td>  5,45% </td><td>  0,76% </td><td>  1,5% </td><td>  0,29% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone X </th><th width="100"></th><th width="100">  iPad Pro 12.9 ' </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  Logam </th><th>  Opengl </th><th>  Logam </th></tr><tr><td>  Fps </td><td>  145 </td><td>  210 </td><td>  104 </td><td>  137 </td></tr><tr><td>  FPS (render saja) </td><td>  248 </td><td>  705 </td><td>  147 </td><td>  463 </td></tr><tr><td>  Fraksi bingkai lambat (&lt;30 fps) </td><td>  0,15% </td><td>  0,15% </td><td>  17,52% </td><td>  4,46% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100">  iPhone 7+ </th><th width="100">  iPhone 8 </th><th width="100">  iPhone X </th><th width="100">  iPad Pro 12.9 ' </th></tr><tr><td>  Akselerasi bingkai pada Logam (N kali) </td><td>  1,5 </td><td>  1.39 </td><td>  1,52 </td><td>  1.45 </td><td>  1.32 </td></tr><tr><td>  Akselerasi rendering pada Logam (N kali) </td><td>  3.78 </td><td>  2.41 </td><td>  3.07 </td><td>  2.84 </td><td>  3.15 </td></tr><tr><td>  Peningkatan frame lambat (N kali) </td><td>  3.3 </td><td>  7.17 </td><td>  5.17 </td><td>  1 </td><td>  3.93 </td></tr></tbody></table><br><h4>  Analisis Hasil </h4><br>  Rata-rata, peningkatan kinerja bingkai menggunakan Apple Metal adalah 43%.  Nilai minimum ditetapkan pada iPad Pro 12.9 '- 32%, maksimum - 52% di iPhone 8. Ada ketergantungan: semakin rendah resolusi layar, semakin Apple Metal melampaui OpenGL ES 3.0. <br><br>  Jika kami mengevaluasi bagian frame yang secara langsung bertanggung jawab untuk rendering, maka kecepatan rendering rata-rata pada Apple Metal telah meningkat 3 kali lipat.  Ini menunjukkan organisasi yang jauh lebih baik, dan, sebagai hasilnya, efisiensi Apple Metal API dibandingkan dengan OpenGL ES 3.0. <br><br>  Jumlah frame lambat (lebih dari ~ 30 ms) pada Apple Metal berkurang sekitar 4 kali.  Ini berarti bahwa persepsi animasi dan bergerak di sekitar peta menjadi lebih halus.  Hasil terburuk tercatat pada iPad Pro 12.9 'dengan resolusi 2732 x 2048 piksel: OpenGL ES 3.0 memberikan sekitar 17,5% bingkai lambat, sementara Apple Metal - hanya 4,5%. <br><br><h2>  Pengujian daya </h2><br><h4>  Teknik eksperimental </h4><br>  Konsumsi daya diuji pada iPhone 8 di iOS 12. Skenario pengguna yang sama dijalankan - navigasi peta (bergerak dan penskalaan) selama 1 jam.  Script ditulis untuk menjamin identitas proses yang hampir lengkap dalam aplikasi pada setiap permulaan.  Wilayah Los Angeles juga dipilih sebagai lokasi uji. <br><br>  Kami menggunakan pendekatan berikut untuk mengukur konsumsi energi.  Perangkat tidak terhubung ke pengisian daya.  Dalam pengaturan pengembang, pencatatan daya diaktifkan.  Sebelum memulai percobaan, perangkat terisi penuh.  Percobaan berakhir di akhir skrip.  Pada akhir percobaan, kondisi pengisian baterai dicatat, dan log konsumsi daya diimpor ke utilitas untuk membuat profil baterai dalam Xcode.  Kami mencatat berapa banyak biaya yang dihabiskan untuk GPU.  Selain itu, di sini kami juga mempertimbangkan rendering dengan memasukkan tampilan skema metro dan antialiasing layar penuh. <br><br>  Kecerahan layar tidak berubah dalam semua kasus.  Tidak ada proses lain kecuali sistem dan MAPS.ME dieksekusi.  Mode pesawat dihidupkan, Wi-Fi dan GPS dimatikan.  Selain itu, beberapa pengukuran kontrol dilakukan. <br><br>  Akibatnya, untuk masing-masing indikator, perbandingan Logam dengan OpenGL dibentuk, dan kemudian rasio dirata-rata untuk mendapatkan satu perkiraan agregat. <br><br><table><tbody><tr><th width="100"></th><th width="100">  Opengl </th><th width="100">  Logam </th><th width="100">  Keuntungan </th></tr><tr><td>  Menguras baterai </td><td>  32% </td><td>  28% </td><td>  12,5% </td></tr><tr><td>  Membuat Profil Penggunaan Baterai di Xcode </td><td>  1,95% </td><td>  1,83% </td><td>  6,16% </td></tr></tbody></table><br><h4>  Analisis Hasil </h4><br>  Rata-rata, konsumsi daya versi rendering pada Apple Metal telah sedikit meningkat.  Konsumsi daya aplikasi GPU kami tidak terlalu terpengaruh, sekitar 2%, karena MAPS.ME tidak dapat disebut sangat sarat dalam hal menggunakan GPU.  Keuntungan kecil mungkin dicapai dengan mengurangi biaya komputasi ketika menyiapkan instruksi untuk GPU pada CPU, yang, sayangnya, tidak dapat dibedakan dengan bantuan alat profiling. <br><br><h2>  Ringkasan </h2><br>  Menanamkan logam menghabiskan biaya 5 bulan untuk pengembangan.  Namun, dua pengembang melakukan ini hampir selalu bergantian.  Jelas, kami menang secara signifikan dalam menghasilkan kinerja, kami memenangkan sedikit dalam konsumsi energi.  Selain itu, kami mendapat kesempatan untuk menyematkan API grafis baru, khususnya Vulkan, dengan upaya yang jauh lebih sedikit.  Hampir sepenuhnya "memilah" mesin grafis, sebagai hasilnya, kami menemukan dan memperbaiki beberapa bug lama dan masalah kinerja. <br><br>  Untuk pertanyaan apakah proyek kami benar-benar perlu dirender di Apple Metal, kami siap menjawab dengan persetujuan.  Bukan karena kita mencintai inovasi, atau Apple akhirnya dapat meninggalkan OpenGL.  Ini hanya 2018, dan OpenGL muncul di tahun 1997 yang jauh, sekarang saatnya untuk mengambil langkah berikutnya. <br><br>  <b>PS</b> Sampai kami meluncurkan fitur di semua perangkat iOS.  Untuk mengaktifkannya secara manual, ketik <code>?metal</code> di bilah pencarian dan mulai ulang aplikasi.  Untuk mengembalikan rendering ke OpenGL, masukkan perintah <code>?gl</code> dan restart aplikasi. <br><br>  <b>PPS</b> MAPS.ME adalah proyek sumber terbuka.  Anda dapat membaca kode sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430850/">https://habr.com/ru/post/id430850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430838/index.html">Keajaiban pemasaran orang banyak, atau bagaimana mempromosikan bisnis dengan ulasan</a></li>
<li><a href="../id430840/index.html">Bukti apa yang dapat meyakinkan ahli matematika jika tidak ada bukti yang kuat?</a></li>
<li><a href="../id430842/index.html">Kami menggunakan blockchain untuk memerangi korupsi dan cyberbullying</a></li>
<li><a href="../id430844/index.html">Bagaimana memilih baterai untuk UPS</a></li>
<li><a href="../id430846/index.html">Apa yang baru: detail tentang implementasi arsitektur Zen 2 baru mulai dikenal</a></li>
<li><a href="../id430852/index.html">Konsistensi dan jaminan ACID dalam sistem penyimpanan terdistribusi</a></li>
<li><a href="../id430854/index.html">"JS menjadi lebih dewasa": sebuah wawancara dengan komite program HolyJS 2018 Moskow</a></li>
<li><a href="../id430856/index.html">Seluruh kebenaran tentang RTOS. Artikel # 21. Kotak Surat: Pengantar dan Layanan Dasar</a></li>
<li><a href="../id430860/index.html">Unduh, simpan, dan lihat PDF dalam Swift</a></li>
<li><a href="../id430862/index.html">"Monster dalam game - cara membuat pemain membencimu"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>