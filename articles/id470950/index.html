<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¸ğŸ¼ ğŸˆšï¸ ğŸ‘¨ğŸ¾â€ğŸ¨ bear_hug: game dalam seni ASCII dengan Python3.6 + ğŸ™ğŸ½ ğŸ‘©ğŸ¼â€ğŸš€ ğŸ‘¨ğŸ¿â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk permainan saya dalam seni ASCII, saya menulis perpustakaan bear_hug dengan antrian acara, koleksi widget, dukungan ECS, dan hal-hal kecil berman...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bear_hug: game dalam seni ASCII dengan Python3.6 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470950/"><img src="https://habrastorage.org/webt/b0/zu/vj/b0zuvjk4xdzcznbys9oslxl_veo.png"><br><br>  Untuk permainan saya dalam seni ASCII, saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan bear_hug</a> dengan antrian acara, koleksi widget, dukungan ECS, dan hal-hal kecil bermanfaat lainnya.  Pada artikel ini kita akan melihat bagaimana menggunakannya untuk membuat game yang berfungsi minimal. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Penafian</b> <div class="spoiler_text"><ul><li>  Saya adalah satu-satunya pengembang perpustakaan, jadi saya bisa menjadi bias. </li><li>  bear_hug pada dasarnya adalah pembungkus di sekitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bearlibterminal</a> , sehingga tidak akan ada operasi tingkat rendah dengan mesin terbang. </li><li>  Ada fungsi serupa di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clubsandwich</a> , tapi saya tidak menggunakannya dan saya tidak bisa membandingkannya. </li></ul></div></div><br>  Di bawah kap bear_hug adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bearlibterminal</a> , perpustakaan SDL untuk membuat jendela pseudo-konsol.  Artinya, dalam TTY murni, seperti beberapa ncurses, itu tidak akan berfungsi.  Tapi kemudian gambarnya sama di Linux, di Windows, dan tidak tergantung pada pengaturan terminal pengguna.  Ini penting, terutama untuk game, karena ketika Anda mengubah font ASCII-art, Tuhan mungkin berubah menjadi apa: <br><br><img src="https://habrastorage.org/webt/ys/rh/6f/ysrh6fhay5u9slnpwvqn53is1ek.png"><br>  <i>Gambar yang sama dalam bentuk aslinya dan setelah salin-tempel ke program yang berbeda</i> <br><br>  Tentu saja, perpustakaan itu ditulis untuk proyek-proyek berskala relatif besar.  Tetapi agar tidak terganggu oleh desain dan arsitektur game, dalam artikel ini kita akan membuat sesuatu yang sederhana.  Proyek satu malam, di mana ada sesuatu untuk menunjukkan fungsi dasar perpustakaan.  Yaitu - tiruan sederhana dari tank yang sama dengan Dandy (mereka juga Battle City).  Akan ada tank pemain, tank musuh, dinding yang dapat dirusak, suara dan skor.  Tetapi menu utama, level dan bonus yang dipilih tidak akan.  Bukan karena tidak mungkin menambahkannya, tetapi karena proyek ini tidak lebih dari Halloworld. <br><br><img src="https://habrastorage.org/webt/8k/e7/my/8ke7mymnrejpei7isjbxtbwvyjs.png"><br>  <i>Akan ada gameover, tetapi tidak akan ada kemenangan.</i>  <i>Karena hidup adalah rasa sakit.</i> <br><br>  Semua bahan yang digunakan dalam artikel ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di github</a> ;  perpustakaan itu sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di PyPI</a> (di bawah lisensi MIT). <br><br>  Pertama-tama, kita membutuhkan aset.  Untuk menggambar seni ASCII, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">REXpaint</a> dari Josh Ge (alias Kyzrati), pengembang bagel fiksi ilmiah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cogmind</a> .  Editor gratis, meskipun bukan open source;  versi resmi hanya untuk Windows, tetapi semuanya berfungsi dengan baik di bawah anggur.  Antarmuka cukup jelas dan nyaman: <br><br><img src="https://habrastorage.org/webt/jf/x-/bi/jfx-bigu3sedblmkuspxh_pd4d4.png"><br><br>  Kami menyimpan dalam format biner lokal .xp dan menyalin dari <code>/path/to/rexpaint/images</code> ke folder dengan game masa depan.  Pada prinsipnya, memuat gambar dari file .txt juga didukung, tetapi jelas tidak mungkin untuk menyimpan warna masing-masing karakter dalam file teks.  Ya, dan mengedit seni ASCII di notebook tidak nyaman bagi saya secara pribadi.  Agar tidak melakukan hardcode koordinat dan ukuran setiap elemen, data ini disimpan dalam file JSON yang terpisah: <br><br><div class="spoiler">  <b class="spoiler_title">battlecity.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_r"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"player_l"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"xsize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ysize"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }, ... ]</code> </pre> <br></div></div><br>  Suara di bawah lisensi unduhan gratis dari Internet.  Sejauh ini, hanya .wav yang didukung.  Itu semua dengan aset, Anda dapat mulai mengkodekan.  Pertama-tama, Anda perlu menginisialisasi terminal dan antrian acara. <br><br><div class="spoiler">  <b class="spoiler_title">game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  terminal = BearTerminal(font_path='cp437_12x12.png', size='91x60', title='AsciiCity', filter=['keyboard', 'mouse']) #   dispatcher = BearEventDispatcher() # ,         loop = BearLoop(terminal, dispatcher)</span></span></code> </pre> <br></div></div><br>  Terminal adalah jendela sebenarnya dari game.  Anda dapat menempatkan widget di atasnya, dan ia melempar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">acara yang</a> diperlukan.  Sebagai kunci saat membuat terminal, Anda dapat menggunakan semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi terminal bearlibterminal</a> ;  dalam hal ini, kami mengatur font, ukuran jendela (dalam karakter), judul jendela, dan metode input yang menarik bagi kami. <br><br>  Adapun antrian acara, ia memiliki antarmuka yang sangat sederhana: dispatcher.add_event (event) menambahkan acara ke antrian, dan dispatcher.register_listener (listener, event_types) memungkinkan Anda untuk berlangganan.  Penanda tangan (misalnya, widget atau komponen) harus memiliki panggilan balik on_event, yang menganggap suatu peristiwa sebagai argumen tunggal dan tidak mengembalikan apa pun atau mengembalikan acara atau rangkaian acara lainnya.  Acara itu sendiri terdiri dari jenis dan nilai;  jenis di sini bukan dalam arti str atau int, tetapi dalam arti "variasi", misalnya 'key_down' atau 'centang'.  Antrean hanya menerima peristiwa dari tipe yang diketahui itu (bawaan atau dibuat oleh pengguna) dan mengirimkannya ke on_event semua orang yang berlangganan jenis ini.  Itu tidak memeriksa nilai dengan cara apa pun, tetapi ada konvensi dalam perpustakaan tentang apa nilai yang valid untuk setiap jenis acara. <br><br>  Pertama, kami mengantri beberapa pendengar.  Ini adalah kelas dasar untuk objek yang dapat berlangganan acara, tetapi bukan widget atau komponen.  Pada prinsipnya, tidak perlu untuk menggunakannya, selama penandatangan memiliki metode on_event. <br><br><div class="spoiler">  <b class="spoiler_title">Pendengar</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       dispatcher.register_listener(ClosingListener(), ['misc_input', 'tick']) #       dispatcher.register_listener(EntityTracker(), ['ecs_create', 'ecs_destroy']) #   jukebox = SoundListener({'shot': 'shot.wav', 'explosion': 'explosion.wav'}) # https://freesound.org/people/EMSIarma/sounds/108852/ # https://freesound.org/people/FlashTrauma/sounds/398283/ dispatcher.register_listener(jukebox, 'play_sound')</span></span></code> </pre> <br></div></div><br>  Daftar lengkap tipe acara bawaan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di dokumentasi</a> .  Sangat mudah untuk melihat bahwa ada peristiwa untuk penciptaan dan penghancuran entitas, tetapi tidak untuk kerusakan.  Karena kita akan memiliki objek yang tidak terlepas dari satu tembakan (dinding dan tangki pemain), kita akan membuatnya: <br><br><div class="spoiler">  <b class="spoiler_title">Registrasi Jenis Acara</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,    #   dispatcher.register_event_type('ac_damage') #       logger = LoggingListener(sys.stderr) dispatcher.register_listener(logger, ['ac_damage', 'play_sound'])</span></span></code> </pre> <br></div></div><br>  Kami setuju bahwa, sebagai nilai, acara ini akan memiliki tuple dari ID entitas yang menderita kerusakan, dan nilai kerusakan.  LoggingListener hanyalah alat debugging yang mencetak semua acara yang diterima di mana pun mereka mengatakan, dalam hal ini di stderr.  Dalam hal ini, saya ingin memastikan bahwa kerusakan lewat dengan benar, dan bahwa suara diminta selalu ketika seharusnya. <br><br>  Dengan Pendengar untuk saat ini, Anda dapat menambahkan widget pertama.  Kami memiliki lapangan bermain kelas ECSLayout ini.  Layout seperti ini, yang dapat menempatkan widget pada entitas dan memindahkannya sebagai respons terhadap peristiwa ecs_move, dan pada saat yang sama mempertimbangkan tabrakan.  Seperti kebanyakan widget, ia memiliki dua argumen yang diperlukan: daftar karakter bersarang (mungkin kosong - ruang atau Tidak ada) dan daftar warna untuk setiap karakter.  Warna yang dinamai diterima sebagai warna, RGB dalam format `0xAARRGGBB` (atau` 0xARGB`, `0xRGB`,` 0xRRGGBB`) dan dalam format '#fff'.  Ukuran kedua daftar harus cocok;  jika tidak, pengecualian dilemparkan. <br><br><div class="spoiler">  <b class="spoiler_title">Widget pertama</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   .  8460,   9160. # 7         chars = [[' ' for x in range(84)] for y in range(60)] colors = copy_shape(chars, 'gray') layout = ECSLayout(chars, colors) # 'all' -  ,      dispatcher.register_listener(layout, 'all')</span></span></code> </pre> <br></div></div><br>  Karena sekarang kita memiliki objek untuk ditempatkan di dalam game, kita dapat mulai membuat entitas.  Semua kode entitas dan komponen dipindahkan ke file terpisah.  Yang paling sederhana adalah dinding bata yang bisa dirusak.  Dia tahu bagaimana berada di tempat tertentu, menampilkan widgetnya, berfungsi sebagai objek tabrakan dan menerima kerusakan.  Setelah cukup banyak kerusakan, dinding menghilang. <br><br><div class="spoiler">  <b class="spoiler_title">entitas.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatcher, atlas, entity_id, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   wall = Entity(entity_id) #  wall.add_component(PositionComponent(dispatcher, x, y)) wall.add_component(CollisionComponent(dispatcher)) wall.add_component(PassingComponent(dispatcher)) wall.add_component(DestructorComponent(dispatcher)) #     ,      #    -  /   images_dict = {'wall_3': atlas.get_element('wall_3'), 'wall_2': atlas.get_element('wall_2'), 'wall_1': atlas.get_element('wall_1')} wall.add_component(SwitchWidgetComponent(dispatcher, SwitchingWidget(images_dict=images_dict, initial_image='wall_3'))) wall.add_component(VisualDamageHealthComponent(dispatcher, hitpoints=3, widgets_dict={3: 'wall_3', 2: 'wall_2', 1: 'wall_1'})) #     dispatcher.add_event(BearEvent('ecs_create', wall)) dispatcher.add_event(BearEvent('ecs_add', (wall.id, wall.position.x, wall.position.y)))</span></span></code> </pre> <br></div></div><br>  Pertama-tama, objek entitas itu sendiri dibuat.  Ini hanya berisi nama (yang harus unik) dan satu set komponen.  Mereka dapat ditransfer sekaligus pada saat penciptaan, atau, seperti di sini, ditambahkan satu per satu.  Kemudian semua komponen yang diperlukan dibuat.  Sebagai widget, SwitchWidget digunakan, yang berisi beberapa gambar dengan ukuran yang sama dan dapat mengubahnya dengan perintah.  Omong-omong, gambar dimuat dari atlas saat membuat widget.  Dan, akhirnya, pengumuman penciptaan entitas dan perintah untuk menggambarnya pada koordinat yang diperlukan masuk ke antrian. <br><br>  Dari komponen non-built-in, hanya ada kesehatan.  Saya membuat komponen dasar "Komponen kesehatan" dan mewarisi "widget perubahan komponen Kesehatan" (untuk menunjukkan dinding utuh dan pada beberapa tahap kehancuran). <br><br><div class="spoiler">  <b class="spoiler_title">komponen HealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Component)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, hitpoints=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, name=<span class="hljs-string"><span class="hljs-string">'health'</span></span>, **kwargs) self.dispatcher.register_listener(self, <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>) self._hitpoints = hitpoints <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> event.event_value[<span class="hljs-number"><span class="hljs-number">0</span></span>] == self.owner.id: self.hitpoints -= event.event_value[<span class="hljs-number"><span class="hljs-number">1</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._hitpoints @hitpoints.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(value, int): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> BearECSException( <span class="hljs-string"><span class="hljs-string">f'Attempting to set hitpoints of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.owner.id}</span></span></span><span class="hljs-string"> to non-integer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{value}</span></span></span><span class="hljs-string">'</span></span>) self._hitpoints = value <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._hitpoints &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: self._hitpoints = <span class="hljs-number"><span class="hljs-number">0</span></span> self.process_hitpoint_update() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Should be overridden by child classes. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError(<span class="hljs-string"><span class="hljs-string">'HP update processing should be overridden'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#           return dumps({'class': self.__class__.__name__, 'hitpoints': self.hitpoints})</span></span></code> </pre> <br></div></div><br>  Saat membuat komponen, kunci 'nama' dilewatkan ke super () .__ init__.  Ketika komponen ditambahkan ke entitas, di bawah nama dari kunci ini akan ditambahkan ke __dict__ entitas dan dapat diakses melalui entity_object.health.  Selain kenyamanan antarmuka, pendekatan ini bagus karena melarang penerbitan entitas dari beberapa komponen yang homogen.  Dan fakta bahwa hardcoded di dalam komponen tidak memungkinkan Anda untuk memasukkan, misalnya, WidgetComponent ke dalam slot komponen kesehatan.  Segera setelah pembuatan, komponen berlangganan ke kelas acara yang menarik untuknya, dalam hal ini ac_damage.  Setelah menerima peristiwa semacam itu, metode on_event akan memeriksa apakah itu tentang pemiliknya selama satu jam.  Jika demikian, ia akan mengurangi nilai yang diinginkan dari poin hit dan menarik panggilan balik untuk mengubah kesehatan, kelas dasar abstrak.  Ada juga metode __repr__, yang digunakan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serialisasi di JSON</a> (misalnya, untuk menyimpan).  Tidak perlu menambahkannya, tetapi semua komponen bawaan dan sebagian besar widget bawaan memilikinya. <br><br>  Mewarisi dari komponen kesehatan yang mendasari VisualDamageHealthComponent mengesampingkan panggilan balik pada perubahan kesehatan: <br><br><div class="spoiler">  <b class="spoiler_title">kelas VisualDamageHealthComponent</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VisualDamageHealthComponent</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(HealthComponent)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       .    HP=0 """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, widgets_dict={}, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self.widgets_dict = OrderedDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(widgets_dict.keys()): self.widgets_dict[int(x)] = widgets_dict[x] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_hitpoint_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hasattr(self.owner, <span class="hljs-string"><span class="hljs-string">'destructor'</span></span>): self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.widgets_dict: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hitpoints &gt;= x: self.owner.widget.switch_to_image(self.widgets_dict[x])</code> </pre> <br></div></div><br>  Sementara kesehatan di atas 0, ia meminta komponen yang bertanggung jawab atas widget untuk menggambar dinding dalam kondisi yang diinginkan.  Di sini, panggilan yang dijelaskan di atas digunakan melalui atribut objek entitas.  Setelah hitpoint selesai, komponen yang bertanggung jawab atas penghancuran entitas yang benar dan semua komponen akan dipanggil dengan cara yang sama. <br><br>  Untuk entitas lain, semuanya serupa, hanya komponen yang berbeda.  Tank ditambahkan dengan pengontrol (input untuk pemain, AI untuk lawan) dan widget yang berputar, untuk kerang - komponen tabrakan yang menyebabkan kerusakan pada yang mereka pukul.  Saya tidak akan menganalisis masing-masing, karena besar dan agak sepele;  hanya melihat collider proyektil.  Ini memiliki metode collided_into, dipanggil ketika entitas host menabrak sesuatu: <br><br><div class="spoiler">  <b class="spoiler_title">collider komponen peluru</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collided_into</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, entity)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> entity: self.owner.destructor.destroy() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> hasattr(EntityTracker().entities[entity], <span class="hljs-string"><span class="hljs-string">'collision'</span></span>): self.dispatcher.add_event(BearEvent(event_type=<span class="hljs-string"><span class="hljs-string">'ac_damage'</span></span>, event_value=( entity, self.damage))) self.owner.destructor.destroy()</code> </pre> <br></div></div><br>  Untuk memastikan bahwa sangat mungkin untuk mendapatkan korban (yang mungkin salah untuk, misalnya, elemen latar belakang), proyektil tersebut menggunakan EntityTracker ().  Ini adalah singleton yang melacak semua entitas yang dibuat dan dihancurkan;  melaluinya, Anda bisa mendapatkan objek entitas dengan nama dan melakukan sesuatu dengan komponennya.  Dalam hal ini, diverifikasi bahwa entitas.collision (korban collision handler) ada sama sekali. <br><br>  Sekarang di file utama gim, kami cukup memanggil semua fungsi yang diperlukan untuk membuat entitas: <br><br><div class="spoiler">  <b class="spoiler_title">Kembali ke game.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  , -     atlas = Atlas(XpLoader('battlecity.xp'), 'battlecity.json') #   create_player_tank(dispatcher, atlas, 30, 50) #    wall_array = [[0 for _ in range(14)], [0 for _ in range(14)], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0 for _ in range(14)], [0 for _ in range(14)], [0 for _ in range(14)] ] for y in range(10): for x in range(14): if wall_array[y][x] == 1: create_wall(dispatcher, atlas, f'wall{x}{y}', x*6, y*6) #   -  .     . create_spawner_house(dispatcher, atlas, 35, 0)</span></span></code> </pre> <br></div></div><br>  Counter point dan hit point bukan entitas dan tidak di medan perang.  Oleh karena itu, mereka tidak ditambahkan ke ECSLayout, tetapi langsung ke terminal di sebelah kanan peta.  Widget yang relevan mewarisi dari Label (widget keluaran teks) dan memiliki metode on_event untuk mengetahui minat mereka.  Tidak seperti Layout, terminal tidak secara otomatis memperbarui widget setiap tick, jadi setelah mengubah teks, widget memberitahunya untuk melakukan ini: <br><br><div class="spoiler">  <b class="spoiler_title">listeners.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScoreLabel</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Label)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(text=<span class="hljs-string"><span class="hljs-string">'Score:\n0'</span></span>) self.score = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.event_type == <span class="hljs-string"><span class="hljs-string">'ecs_destroy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'enemy'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'bullet'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> event.event_value: <span class="hljs-comment"><span class="hljs-comment">#    self.score += 10 self.text = f'Score:\n{self.score}' self.terminal.update_widget(self) class HPLabel(Label): """   """ def __init__(self, *args, **kwargs): super().__init__(text='HP:\n5') self.hp = 5 def on_event(self, event): if event.event_type == 'ac_damage' and event.event_value[0] == 'player': self.hp -= event.event_value[1] self.text = f'HP:\n{self.hp}' self.terminal.update_widget(self)</span></span></code> </pre> <br></div></div><br>  Generator musuh dan objek yang bertanggung jawab untuk output "GAME OVER" tidak ditampilkan sama sekali, sehingga mereka mewarisi dari Listener.  Prinsipnya sama: objek mendengarkan antrian, menunggu saat yang tepat, dan kemudian membuat entitas atau widget. <br><br><div class="spoiler">  <b class="spoiler_title">gameover</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    - . . . class GameOverListener(Listener): """       """ def __init__(self, *args, widget=None, **kwargs): print (args) super().__init__(*args, *kwargs) self.widget = widget def on_event(self, event): if event.event_type == 'ecs_destroy' and event.event_value == 'player': self.terminal.add_widget(self.widget, pos=(20, 20), layer=5)</span></span></code> </pre><br></div></div><br>  Sekarang kami telah menciptakan semua yang kami butuhkan, dan kami dapat memulai permainan. <br><br><div class="spoiler">  <b class="spoiler_title">Kami meluncurkan</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,   Listeners    terminal.start() terminal.add_widget(layout) terminal.add_widget(score, pos=(85, 10)) terminal.add_widget(hp, pos=(85, 15))</span></span></code> </pre> <br></div></div><br>  Widget ditambahkan ke layar hanya setelah dimulai.  Entitas dapat ditambahkan ke peta sebelum - acara penciptaan (di mana seluruh entitas disimpan, termasuk widget) hanya diakumulasikan dalam antrian dan diselesaikan pada centang pertama.  Tetapi terminal dapat menambahkan widget hanya setelah jendela berhasil dibuat untuk itu. <br><br>  Pada titik ini, kami memiliki prototipe yang berfungsi, Anda dapat <s>mengeluarkan di Early Access selama dua puluh dolar</s> menambahkan fitur dan memoles gameplay.  Tapi ini sudah di luar ruang lingkup halloworld, dan karenanya artikel.  Saya hanya akan menambahkan bahwa build independent dari sistem python dapat dibangun menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pyinstaller</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470950/">https://habr.com/ru/post/id470950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470930/index.html">Gamifikasi produk. Riwayat Ratatype</a></li>
<li><a href="../id470934/index.html">Menyembuhkan sebelum pernikahan: proliferasi sel dan kemampuan regenerasi ubur-ubur</a></li>
<li><a href="../id470938/index.html">Cara membuka tautan dengan Python. Bekerja dengan WebBrowser dan memecahkan masalah dengan Internet Explorer</a></li>
<li><a href="../id470940/index.html">Pertemuan MSK VUE.JS # 3 di Mail.ru Group: bahan dari mitap</a></li>
<li><a href="../id470942/index.html">Dari Pemula hingga Ikon Gaya: bagaimana kami membuat penghargaan di 2GIS</a></li>
<li><a href="../id470952/index.html">Tip & Trik Forensik Digital: Forensik aplikasi "Telepon Anda"</a></li>
<li><a href="../id470954/index.html">Instal Zimbra OSE 8.8.15 dan Zextras Suite Pro di Ubuntu 18.04 LTS</a></li>
<li><a href="../id470958/index.html">Probe kehidupan di Kubernetes bisa berbahaya</a></li>
<li><a href="../id470962/index.html">JSConf Budapest 2019</a></li>
<li><a href="../id470964/index.html">Mainan kayu - tulisan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>