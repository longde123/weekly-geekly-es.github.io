<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏻 🏣 👩🏾‍🔧 تمديد UObject في محرك غير واقعي 4 ♠️ 😣 🔠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا بالجميع! اسمي ألكساندر ، لقد عملت مع Unreal Engine منذ أكثر من 5 سنوات ، وتقريباً كل هذا الوقت - مع مشاريع الشبكات. 

 نظرًا لاختلاف مشاريع الشب...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تمديد UObject في محرك غير واقعي 4</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/475622/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  مرحبا بالجميع!  اسمي ألكساندر ، لقد عملت مع Unreal Engine منذ أكثر من 5 سنوات ، وتقريباً كل هذا الوقت - مع مشاريع الشبكات. <br><br>  نظرًا لاختلاف مشاريع الشبكة في متطلبات التطوير والأداء الخاصة بها ، فمن الضروري في الغالب العمل مع كائنات أبسط ، مثل فئات UObject ، ولكن يتم اقتطاع وظائفها مبدئيًا ، والتي يمكن أن تخلق إطارًا قويًا.  في هذه المقالة ، سأتحدث عن كيفية تنشيط الوظائف المختلفة في الفئة الأساسية UObject في Unreal Engine 4. <br><br><img src="https://habrastorage.org/webt/fe/7o/ui/fe7ouisyxz09hjfen72lsdvx5ae.png"><br><br></p><p style=";text-align:right;direction:rtl">  في الواقع ، لقد كتبت المقالة أكثر كمرجع.  من الصعب للغاية العثور على معظم المعلومات في الوثائق أو في المجتمع ، وهنا يمكنك بسرعة فتح الرابط ونسخ الرمز المطلوب.  قررت في نفس الوقت أن أشاطركم!  هذه المقالة موجهة إلى أولئك الذين هم بالفعل على دراية UE4.  سيتم النظر في رمز C ++ ، على الرغم من أنه ليس من الضروري معرفة ذلك.  يمكنك ببساطة اتباع التعليمات إذا كنت بحاجة إلى شيء للحديث عنه.  علاوة على ذلك ، ليس من الضروري نسخ كل شيء ، يمكنك لصق الكود من القسم بالخصائص اللازمة ويجب أن يعمل. <a name="habracut"></a></p><br><br><h2 style=";text-align:right;direction:rtl">  قليلا عن UObject </h2><br>  <b>UObject</b> هي الفئة الأساسية لكل شيء تقريبًا في Unreal Engine 4. يتم توريث الغالبية العظمى من الكائنات التي تم إنشاؤها في عالمك أو في الذاكرة فقط: الكائنات على المسرح (AActor) ، والمكونات (UActorComponent) ، وأنواع مختلفة للعمل مع البيانات وغيرها. <br><br>  الطبقة نفسها ، على الرغم من أنها أسهل من المشتقات ، تعمل في نفس الوقت تمامًا.  على سبيل المثال ، يحتوي على العديد من الأحداث المفيدة ، مثل تغيير قيم المتغيرات في المحرر والوظائف الأساسية للشبكة ، والتي ليست نشطة افتراضيًا. <br><br>  لا يمكن أن تكون الكائنات التي أنشأتها هذه الفئة على خشبة المسرح وتوجد بشكل حصري في الذاكرة.  لا يمكن إضافتها كمكونات إلى الفاعلين ، على الرغم من أنه يمكن أن يكون نوعًا من المكونات إذا قمت بتنفيذ الوظيفة اللازمة بنفسك. <br><br><p style=";text-align:right;direction:rtl">  لماذا أحتاج إلى UObject إذا كان AActor يدعم كل ما أحتاجه بالفعل؟  بشكل عام ، هناك الكثير من الأمثلة للاستخدام.  أسهل العناصر المخزون.  على المسرح ، في مكان ما في السماء ، يكون تخزينها غير عملي ، بحيث يمكنك تخزينها في الذاكرة دون تحميل التجسيد ودون إنشاء خصائص غير ضرورية.  بالنسبة لأولئك الذين يحبون المقارنات التقنية ، تأخذ AActor كيلوبايت (1016 بايت) ، ويبلغ UObject الفارغ 56 بايت فقط. </p><br><br><h2 style=";text-align:right;direction:rtl">  ما هي مشكلة UObject؟ </h2><br>  لا توجد مشاكل بشكل عام ، حسناً ، أو لم أتطرق إليها.  كل ما يزعج UObject هو الافتقار إلى العديد من الميزات المتوفرة افتراضيًا في AActor أو في المكونات.  فيما يلي المشكلات التي حددتها لممارستي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا يتم نسخ UObjects عبر الشبكة؛ </li><li style=";text-align:right;direction:rtl">  بسبب النقطة الأولى ، لا يمكننا تشغيل أحداث RPC ؛ </li><li style=";text-align:right;direction:rtl">  لا يمكنك استخدام مجموعة واسعة من الوظائف التي تتطلب ارتباطًا بالعالم في المخططات ؛ </li><li style=";text-align:right;direction:rtl">  ليس لديهم أحداث قياسية مثل BeginPlay و Tick؛ </li><li style=";text-align:right;direction:rtl">  لا يمكنك إضافة مكونات من UObjects إلى AActor في المخططات. </li></ul><br><p style=";text-align:right;direction:rtl">  معظم الأشياء يمكن حلها بسهولة.  ولكن البعض سوف تضطر إلى العبث. </p><br><br><h2 style=";text-align:right;direction:rtl">  إنشاء UObject </h2><br>  قبل توسيع فئتنا بالميزات ، نحتاج إلى إنشائها.  دعنا نستخدم المحرر بحيث يقوم المولد تلقائيًا بكتابة كل ما هو مطلوب للعمل على الرأس (.h). <br><br>  يمكننا إنشاء فئة جديدة في محرر Content Browser بالنقر فوق الزر " <i>جديد"</i> واختيار <i>فئة C ++ جديدة</i> . <br><br><img src="https://habrastorage.org/webt/x3/7r/8d/x37r8d1ahvstuxtpdnafshrnp9m.png"><br><br>  بعد ذلك ، نحن بحاجة إلى اختيار الفصل نفسه.  قد لا يكون في القائمة العامة ، وبالتالي ، فتحه وحدد UObject. <br><br><img src="https://habrastorage.org/webt/p2/7d/dh/p27ddhbtq9bxgmjzobmozoa1tlk.png"><br><br>  حدد فصلك وحدد المجلد الذي سيتم تخزينه فيه.  عندما أنشأنا الفصل ، يمكنك الذهاب إلى الاستوديو والعثور عليه هناك والبدء في تضمين جميع الوظائف اللازمة. <br><br>  <i>للمبتدئين ، لاحظ أنه يتم إنشاء ملفين: .h و .ccp.</i>  <i>في .h ، ستعلن المتغيرات والوظائف ، وفي .cpp ستحدد منطقها.</i>  <i>ابحث عن كلا الملفين في مشروعك.</i>  <i>إذا لم تقم بتغيير المسار ، فيجب أن يكونوا في مشروع / مصدر / مشروع /.</i> <br><br>  إلى أن نستمر ، دعنا نكتب المعلمة <i>Blueprintable</i> في ماكرو UCLASS () أعلى تعريف الفئة.  يجب أن تحصل على شيء مثل هذا: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() }</code> </pre> <br><p style=";text-align:right;direction:rtl">  بفضل هذا ، يمكنك إنشاء مخططات ترث كل ما نقوم به مع هذا الكائن. </p><br><br><h2 style=";text-align:right;direction:rtl">  UObject النسخ المتماثل </h2><br>  بشكل افتراضي ، لا يتم نسخ UObjects عبر الشبكة.  كما هو موضح أعلاه ، يتم إنشاء عدد من القيود عندما تحتاج إلى مزامنة البيانات أو المنطق بين الأطراف ، ولكن لا تقم بتخزين البيانات المهملة في العالم. <br><br>  في Unreal Engine 4 ، يحدث النسخ المتماثل بدقة بسبب الكائنات العالمية.  يعني ذلك ببساطة إنشاء كائن في الذاكرة وتكراره سيفشل.  في أي حال ، سوف تحتاج إلى مالك يقوم بإدارة نقل بيانات الكائن بين الخادم والعملاء.  على سبيل المثال ، إذا كان الكائن الخاص بك مهارة شخصية ، فيجب أن تصبح الشخصية نفسها هي المالك.  سيكون أيضًا موصلًا لنقل المعلومات عبر الشبكة. <br><br>  تحضير كائن لدينا للنسخ المتماثل.  حتى الآن في الرأس نحتاج إلى تعيين وظيفة واحدة فقط: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }</code> </pre><br>  <i>سيحدد IsSupportedForNetworking ()</i> أن الكائن يدعم الشبكة ويمكن نسخه. <br><br>  ومع ذلك ، ليس كل شيء في غاية البساطة.  كما كتبت أعلاه ، تحتاج إلى مالك يتحكم في نقل الكائن.  من أجل نقاء التجربة ، قم بإنشاء AActor يقوم بتكرارها.  يمكن القيام بذلك بنفس طريقة UObject ، فقط الفئة الأصل ، وبطبيعة الحال ، AActor. <br><br>  <i>بالنسبة للمبتدئين ، إذا كنت بحاجة إلى نسخ كائن في حرف أو وحدة تحكم أو في أي مكان آخر ، قم بإنشاء الفئة الأساسية المناسبة من خلال المحرر وإضافة المنطق اللازم إليها ورثها بالفعل من هذه الفئة في المخططات.</i> <br><br>  في الداخل ، نحتاج إلى 3 وظائف: مُنشئ ، دالة لتكرار الكائنات الفرعية ، دالة تحدد ما يتم نسخه داخل AActor (المتغيرات ، مراجع الكائن ، إلخ) والمكان الذي ننشئ فيه كائننا. <br><br>  لا تنس إنشاء متغير يتم به تخزين كائننا: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AMyActor(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplicateSubobjects</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginPlay</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; UPROPERTY(Replicated, BlueprintReadOnly, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObject</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br>  داخل الملف المصدر ، علينا أن نكتب كل شيء: <br><br>  <b>.CPP</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyActor.h" #include "Net/UnrealNetwork.h" #include "Engine/World.h" #include "Engine/ActorChannel.h" #include "   UObject/MyObject.h" AMyActor::AMyActor() { //  Actor  . bReplicates = true // . NetCullDistanceSquared = 99999; //  (  ). NetUpdateFrequency = 1.f; } void AMyActor::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //       .           . DOREPLIFETIME(AMyActor, MyObject); } bool AMyActor::ReplicateSubobjects(UActorChannel * Channel, FOutBunch * Bunch, FReplicationFlags * RepFlags) { bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags); //   . if (MyObject ) WroteSomething |= Channel-&gt;ReplicateSubobject(MyObject , *Bunch, *RepFlags); return WroteSomething; } AMyActor::BeginPlay() { /*       (  )  .    this.        . ,       ,     . */ if(HasAuthority()) { MyObject = NewObject&lt;UMyObject&gt;(this); //       if(MyObject) UE_LOG(LogTemp, Log, TEXT("%s created"), *MyObject-&gt;GetName()); } }</span></span></code> </pre><br><p style=";text-align:right;direction:rtl">  الآن سيتم نسخ الكائن الخاص بك مع هذا الممثل.  يمكنك عرض اسمه على القراد ، ولكن بالفعل على العميل.  يرجى ملاحظة أنه من غير المرجح أن يصل كائن قبل بدء تشغيله إلى العميل ، لذلك لا فائدة من كتابة سجل عليه. </p><br><br><h2 style=";text-align:right;direction:rtl">  تكرار المتغيرات في UObject </h2><br>  في معظم الحالات ، لا معنى لتكرار كائن ما إذا كان لا يحتوي على معلومات ستتم مزامنتها أيضًا بين الخادم والعملاء.  منذ أن تم نسخ كائننا بالفعل ، فإن تمرير المتغيرات ليس بالأمر الصعب.  يتم ذلك بالطريقة نفسها داخل ممثلنا: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; UPROPERTY(Replicated, BlueprintReadWrite, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MyInteger; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  <b>.CPP</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyObject.h" #include "Net/UnrealNetwork.h" UMyObject ::UMyObject () { //  Object  .     . bReplicates = true //       ,     . } void UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //   Integer  . DOREPLIFETIME(UMyObject, MyInteger); } }</span></span></code> </pre><br>  بإضافة متغير ووضع علامة عليه للنسخ المتماثل ، يمكننا تكراره.  كل شيء بسيط والشيء نفسه كما في AActor. <br><br>  ومع ذلك ، هناك مأزق صغير لا يمكن رؤيته على الفور ، ولكن يمكن أن يكون مضللاً.  سيكون هذا ملحوظًا بشكل خاص إذا كنت تقوم بإنشاء UObject الخاص بك ليس للعمل في C ++ ، ولكن إعداده للميراث والعمل في المخططات. <br><br>  خلاصة القول هي أنه لن يتم نسخ المتغيرات التي تم إنشاؤها في وريث المخططات.  لا يقوم المحرك بوضع علامة عليها تلقائيًا وتغيير المعلمة على الخادم في BP لا يغير أي شيء في القيمة على العميل.  ولكن هناك علاج لهذا.  للنسخ المتماثل الصحيح لمتغيرات BP ، تحتاج إلى وضع علامة عليها مسبقًا.  إضافة سطرين إلى GetLifetimeReplicatedProps (): <br><br>  <b>.CPP</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); <span class="hljs-comment"><span class="hljs-comment">//   Integer  . DOREPLIFETIME(UMyObject, MyInteger); //       UBlueprintGeneratedClass* BPClass = Cast&lt;UBlueprintGeneratedClass&gt;(GetClass()); if (BPClass) BPClass-&gt;GetLifetimeBlueprintReplicationList(OutLifetimeProps); }</span></span></code> </pre><br><p style=";text-align:right;direction:rtl">  سيتم الآن نسخ متغيرات في فصول Blueprint التابعة كما هو متوقع. </p><br><br><h2 style=";text-align:right;direction:rtl">  أحداث RPC في UObject </h2><br>  أحداث RPC (استدعاء الإجراء البعيد) هي وظائف خاصة يتم استدعاؤها على الجانب الآخر من تفاعل شبكة المشروع.  باستخدامها ، يمكنك استدعاء الوظيفة من الخادم على العملاء الآخرين ومن العميل على الخادم.  مفيدة جدا وغالبا ما تستخدم عند كتابة مشاريع الشبكة. <br><br>  <i>إذا لم تكن على دراية بهم ، أوصي بقراءة مقال واحد.</i>  <i>يصف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الاستخدام في C ++ وفي المخططات</a> .</i> <br><br>  على الرغم من عدم وجود مشاكل في Actor أو في المكونات الخاصة بمكالمتهم ، فإن أحداث UObject تُطلق النار على نفس الجانب الذي تم الاتصال به ، مما يجعل من المستحيل إجراء مكالمة عن بُعد عند الحاجة. <br><br>  بالنظر إلى رمز المكون (UActorComponent) ، يمكننا العثور على العديد من الوظائف التي تتيح لك نقل المكالمات عبر الشبكة.  نظرًا لأن UActorComponent موروث من UObject ، فيمكننا ببساطة نسخ المقاطع الضرورية من التعليمات البرمجية ولصقها في كائننا بحيث يعمل كما يجب: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/EngineTypes.h" UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() public: virtual bool CallRemoteFunction (UFunction * Function, void * Parms, struct FOutParmRec * OutParms, FFrame * Stack) override; virtual int32 GetFunctionCallspace (UFunction* Function, void* Parameters, FFrame* Stack) override; //   }</span></span></code> </pre><br>  <b>.CPP</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/NetDriver.h" //       . bool UMyObject::CallRemoteFunction(UFunction * Function, void * Parms, FOutParmRec * OutParms, FFrame * Stack) { if (!GetOuter()) return false; UNetDriver* NetDriver = GetOuter()-&gt;GetNetDriver(); if (!NetDriver) return false; NetDriver-&gt;ProcessRemoteFunction(GetOuter(), Function, Parms, OutParms, Stack, this); return true; } int32 UMyObject::GetFunctionCallspace(UFunction * Function, void * Parameters, FFrame * Stack) { return (GetOuter() ? GetOuter()-&gt;GetFunctionCallspace(Function, Parameters, Stack) : FunctionCallspace::Local); }</span></span></code> </pre><br>  باستخدام هذه الوظائف ، سنكون قادرين على تشغيل أحداث RPC ليس فقط في الكود ، ولكن أيضًا في المخططات. <br><br><p style=";text-align:right;direction:rtl">  يرجى ملاحظة أنه من أجل إطلاق أحداث العميل أو الخادم ، فإنك تحتاج إلى مالك يكون مالكه هو لاعبنا.  على سبيل المثال ، الكائن مملوك من قِبل شخصية المستخدم أو الكائن الذي يكون فيه المالك هو المشغل الخاص بالمشغل. </p><br><br><h2 style=";text-align:right;direction:rtl">  الميزات العالمية في المخططات </h2><br>  إذا قمت بإنشاء "مخطط كائن" من أي وقت مضى ، فقد تكون لاحظت أنه لا يمكنك استدعاء وظائف عمومية (ثابتة ، ولكن من أجل الوضوح نسميها) المتوفرة في فئات أخرى ، على سبيل المثال ، GetGamemode ().  يبدو أنه لا يمكنك ببساطة القيام بالفصول في فئات الكائنات ، والتي بسببها يجب عليك إما تمرير كل الروابط عند الإنشاء ، أو الانحراف بطريقة أو بأخرى ، وفي بعض الأحيان يقع الاختيار تمامًا في فئة الممثل الذي تم إنشاؤه على المسرح و يدعم كل شيء. <br><br>  لكن في C ++ ، بالطبع ، لا توجد مثل هذه المشكلات.  ومع ذلك ، لا يستطيع مصمم اللعبة ، الذي يلعب بالإعدادات ويضيف أشياء صغيرة مختلفة ، أن يقول إنك بحاجة إلى فتح Visual Studio ، والعثور على الفئة المناسبة والحصول على وضع اللعبة في وظيفة doSomething () عن طريق تغيير النقاط الموجودة فيه.  لذلك ، من الضروري أن يتمكن المصمم من تسجيل الدخول إلى Bluprint وبنقرتين ، يقوم بعمله.  حفظ كل وقته وخاصتك.  ومع ذلك ، تم اختراع المخططات لهذا الغرض. <br><br>  خلاصة القول هي أنه عندما تبحث عن وظائف أو تستدعيها في قائمة السياق في Bluprint ، فإن نفس الوظائف العامة التي تتطلب إشارة إلى العالم تحاول استدعاء وظيفة داخل كائنك الذي يشير إليها.  وإذا رأى المحرر أنه لا توجد وظيفة ، فهو يفهم أنه لا يستطيع استخدامها ولا يعرضها في القائمة. <br><br><img src="https://habrastorage.org/webt/bb/mj/gu/bbmjguakea7gkb-roirojnwnrsg.png"><br><br>  ومع ذلك ، هناك علاج لهذا.  حتى اثنين. <br><br>  لننظر أولاً في خيار للاستخدام الأكثر ملاءمة في المحرر.  سوف نحتاج إلى إعادة تعريف وظيفة تُرجع رابطًا للعالم ، ثم سيتفهم المحرر أنه في اللعبة نفسها يمكنه العمل: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//  GetWorld()    . virtual UWorld* GetWorld() const override; //   }</span></span></code> </pre><br>  <b>.CPP</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">UWorld* UMyObject::GetWorld() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       ,    . if (GIsEditor &amp;&amp; !GIsPlayInEditorWorld) return nullptr; else if (GetOuter()) return GetOuter()-&gt;GetWorld(); else return nullptr; }</span></span></code> </pre><br>  الآن يتم تعريفه وسوف يفهم المحرر أن الكائن قادر عمومًا على الحصول على المؤشر المرغوب (على الرغم من أنه غير صالح) واستخدام الوظائف العامة في BP. <br><br>  <i>يرجى ملاحظة أن المالك (GetOuter ()) يجب أن يتمتع أيضًا بحق الوصول إلى العالم.</i>  <i>قد يكون UObject آخر مع كائن GetWorld () أو مكون أو ممثل معين في المشهد.</i> <br><br><img src="https://habrastorage.org/webt/7x/wu/w3/7xwuw3u7qkekz9m6-bnhdfd0o10.png"><br><br>  هناك طريقة أخرى.  يكفي إضافة تسمية إلى ماكرو UCLASS () عند الإعلان للفئة التي ستتم إضافة المعلمة WorldContextObject منها إلى الوظائف الثابتة في BP ، والتي يتم فيها تغذية أي كائن يعمل كموصل إلى "العالم" ويتم تغذية الوظائف العالمية للمحرك.  هذا الخيار مناسب لأولئك الذين في المشروع يمكن أن يكون لهم عوالم متعددة في نفس الوقت (على سبيل المثال ، عالم اللعبة والعالم للمتفرج): <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   WorldContext      UCLASS(Blueprintable, meta=(ShowWorldContextPin)) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() //   }</span></span></code> </pre><br>  إذا أدخلت GetGamemode في البحث في BP ، فستظهر في القائمة ، مثل الوظائف الأخرى المماثلة ، وستكون المعلمة هي WorldContextObject ، التي تحتاج إلى تمرير رابط إلى ممثل. <br><br><img src="https://habrastorage.org/webt/nn/uo/xg/nnuoxgsfj912bnoa5fheedsz3yk.png"><br><br>  بالمناسبة ، يمكنك فقط تقديم ملف مالك فنادقنا هناك.  أوصي بإنشاء وظيفة على ممثل ، وسوف يكون دائما مفيدا للكائن: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">UCLASS(Blueprintable, meta=(ShowWorldContextPin)) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      ,     . public: UFUNCTION(BlueprintPure) AActor* GetOwner() const {return Cast&lt;AActor&gt;(GetOuter());}; //   }</span></span></code> </pre><br>  الآن يمكنك ببساطة استخدام الوظائف العالمية بالاقتران مع وظيفة Pure للحصول على المالك. <br><br><img src="https://habrastorage.org/webt/ux/22/7w/ux227wpx_b6yp8l8vnlutwxywu8.png"><br><br>  إذا قمت أيضًا بتعريف GetWorld () في المتغير الثاني كما في المتغير الأول ، فيمكنك إرسال مرجع إلى نفسك (Self أو This) في معلمة WorldContextObject. <br><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/op/jh/mb/opjhmbcmm5jsktm_gtxk-jkgzyy.png"></p><br><br><h2 style=";text-align:right;direction:rtl">  أحداث BeginPlay والقراد </h2><br>  هناك مشكلة أخرى قد يواجهها مطورو Blueprint وهي أنه لا توجد أحداث BeginPlay و Tick في فئة Object.  بالطبع ، يمكنك إنشاءها بنفسك والاتصال من فصل آخر.  ولكن يجب أن تعترف أنه أكثر ملاءمة عندما يعمل كل شيء خارج الصندوق. <br><br>  لنبدأ بفهم كيفية بدء اللعب.  يمكننا إنشاء وظيفة متاحة لإعادة كتابتها في BP واستدعاؤها في مُنشئ الفصل ، ولكن هناك عددًا من المشكلات ، لأنه في وقت المُنشئ لم يتم تهيئة الكائن بالكامل بعد. <br><br>  في كل الفئات ، توجد وظيفة PostInitProperties () ، والتي تسمى بعد تهيئة معظم المعلمات وتسجيل الكائن في الأنظمة الداخلية المختلفة ، على سبيل المثال ، لمجمع البيانات المهملة.  في ذلك ، يمكنك فقط الاتصال بالحدث الخاص بنا ، والذي سيتم استخدامه في المخططات: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      . virtual void PostInitProperties() override; // ,      . UFUNCTION(BlueprintImplementableEvent) void BeginPlay(); //   }</span></span></code> </pre><br>  <b>.CPP</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::PostInitProperties() { Super::PostInitProperties(); <span class="hljs-comment"><span class="hljs-comment">//   ,   .   BeginPlay    if(GetOuter() &amp;&amp; GetOuter()-&gt;GetWorld()) BeginPlay(); }</span></span></code> </pre><br>  <i>بدلاً من if (GetOuter () &amp;&amp; GetOuter () -&gt; GetWorld ()) يمكنك ببساطة وضع (GetWorld ()) إذا كنت قد أعدت تعريفه بالفعل.</i> <i><br><br></i>  <i>كن حذرا!</i>  <i>بشكل افتراضي ، يتم استدعاء PostInitProperties () أيضًا في المحرر.</i> <i><br></i> <br>  الآن يمكننا الانتقال إلى كائن BP الخاص بنا واستدعاء حدث BeginPlay.  سيتم استدعاؤه عندما يتم إنشاء الكائن. <br><br>  دعنا ننتقل إلى حدث الأحداث.  لا توجد وظيفة بسيطة بالنسبة لنا.  تستدعي الكائنات المحددة في المحرك مديرًا خاصًا ، تحتاج إلى التقاطه بطريقة أو بأخرى.  ومع ذلك ، هناك خدعة مريحة للغاية هنا - وراثة إضافية من FTickableGameObject.  سيسمح لك ذلك بالقيام تلقائيًا بكل ما تحتاجه ، وبعد ذلك سيكون كافياً فقط لالتقاط الوظائف الضرورية: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Tickable.h" //   c FTickableGameObject UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject, public FTickableGameObject { GENERATED_BODY() public: //   virtual void Tick(float DeltaTime) override; virtual bool IsTickable() const override; virtual TStatId GetStatId() const override; protected: //     UFUNCTION(BlueprintImplementableEvent) void EventTick(float DeltaTime); //   }</span></span></code> </pre><br>  <b>.CPP</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::Tick(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime) { <span class="hljs-comment"><span class="hljs-comment">//       . EventTick(DeltaTime); //     . } //     bool UMyObject::IsTickable() const { return true; } TStatId UMyObject::GetStatId() const { return TStatId(); }</span></span></code> </pre><br><p style=";text-align:right;direction:rtl">  إذا كنت ترث من الكائن وقمت بإنشاء فئة BP ، فسيكون حدث EventTick متاحًا ، مما سيتسبب في منطق كل إطار. </p><br><br><h2 style=";text-align:right;direction:rtl">  إضافة مكونات من UObjects </h2><br>  في مخططات UObject ، لا يمكنك تكوين مكونات للممثلين.  نفس المشكلة متأصلة في مخططات ActorComponent.  منطق Epic Games غير واضح للغاية ، لأنه في C ++ يمكن القيام بذلك.  علاوة على ذلك ، يمكنك إضافة مكون من ممثل إلى كائن ممثل آخر عن طريق تحديد رابط.  ولكن هذا لا يمكن القيام به. <br><br>  لسوء الحظ ، لم أستطع معرفة هذا البند.  إذا كان لدى أي شخص تعليمات حول كيفية القيام بذلك ، سأكون سعيدًا لنشرها هنا. <br><br><p style=";text-align:right;direction:rtl">  الخيار الوحيد الذي يمكنني تقديمه في الوقت الحالي هو صنع غلاف في فئة UObject ، مما يتيح الوصول إلى إضافة بسيطة من المكونات.  وبالتالي ، سيكون من الممكن إضافة مكونات إلى الفاعل ، لكنك لن تكون قد قمت بإنشاء معلمات إدخال ديناميكية للفرخ.  في كثير من الأحيان ، يمكن إهمال هذا. </p><br><br><h2 style=";text-align:right;direction:rtl">  إعداد مثيل من خلال المحرر </h2><br>  في UE4 ، هناك ميزة أخرى ملائمة للعمل مع الكائنات - وهي القدرة على إنشاء مثيل أثناء التهيئة وتغيير المعلمات من خلال المحرر ، وبالتالي تحديد خصائصه ، دون إنشاء فئة فرعية فقط من أجل الإعدادات.  مفيدة بشكل خاص لمصممي اللعبة. <br><br>  افترض أن لديك مدير معدل لأحد الشخصيات وأن المعدلات نفسها ممثلة بفئات تصف التأثيرات المتراكبة.  قام مصمم اللعبة بإنشاء زوج من المعدلات ويشير في المدير إلى تلك المستخدمة. <br><br>  في الوضع الطبيعي ، سيبدو كما يلي: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere) TSubclassOf&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObjectClass</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br><img src="https://habrastorage.org/webt/hd/rx/zc/hdrxzc1qsu2d9htiydsmgfy1t-0.png"><br><br>  ومع ذلك ، هناك مشكلة في أنه لا يمكن تكوين المعدلات وعليك إنشاء فئة إضافية للقيم الأخرى.  موافق ، ليس من المريح جدًا وجود عشرات الفئات في متصفح المحتوى تختلف فقط في القيم.  إصلاح هذا أمر سهل.  يمكنك إضافة حقلين داخل USTRUCT () ، وكذلك الإشارة في كائن الحاوية إلى أن كائناتنا ستكون مثيلات ، وليس مجرد إشارات إلى كائنات أو فئات غير موجودة: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">UCLASS(Blueprintable, DefaultToInstanced, EditInlineNew) <span class="hljs-comment"><span class="hljs-comment">//  -        class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() UPROPERTY(EditAnywhere) //       uint8 MyValue; // ,    //   }</span></span></code> </pre><br>  هذا وحده لا يكفي ، والآن من الضروري الإشارة إلى أن نفس المتغير مع الفصل سيكون نسخة.  يتم ذلك بالفعل حيث تقوم بتخزين الكائن ، على سبيل المثال ، في مدير معدل الأحرف: <br><br>  <b>.H</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere, Instanced) <span class="hljs-comment"><span class="hljs-comment">//   Instanced    class UMyObject* MyObject; //    }</span></span></code> </pre><br>  يرجى ملاحظة أننا نستخدم الإشارة إلى الكائن ، وليس إلى الفصل ، حيث سيتم إنشاء المثيل فور التهيئة.  الآن يمكننا الانتقال إلى نافذة المحرر لتحديد فئة وضبط القيم داخل المثيل.  هو أكثر ملاءمة وأكثر مرونة. <br><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/ee4/1cd/e76/ee41cde76aed943c03f0a15ff2e903f6.png" alt="صورة"></p><br><br><h2 style=";text-align:right;direction:rtl">  معلومات </h2><br>  هناك فئة أخرى مثيرة للاهتمام في Unreal Engine.  هذا هو AInfo.  فئة موروثة من AActor ليس لها تمثيل مرئي في العالم.  تستخدم Info فئات مثل: وضع اللعبة ، و GameState ، و PlayState ، وغيرها.  وهذا هو ، الطبقات التي تدعم شرائح مختلفة من AActor ، على سبيل المثال ، النسخ المتماثل ، ولكن لا يتم وضعها على الساحة. <br><br>  إذا كنت بحاجة إلى إنشاء مدير عالمي إضافي يجب أن يدعم الشبكة وجميع فئات Actor الناتجة ، فيمكنك استخدامها.  ليس لديك لمعالجة فئة UObject كما هو موضح أعلاه لإجبارها ، على سبيل المثال ، لتكرار البيانات. <br><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، ضع في اعتبارك أنه على الرغم من أن الكائن لا يحتوي على إحداثيات ، ولا يحتوي على عناصر مرئية ولا يتم عرضه على الشاشة ، إلا أنه لا يزال سليل فئة الممثل ، مما يعني أنه ثقيل مثل الأصل.  تستخدم بشكل معقول بكميات صغيرة والراحة. </p><br><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br>  هناك حاجة إلى استخدام UObject في كثير من الأحيان ، وأنا أنصحك باستخدامه عندما لا تكون هناك حاجة إلى الممثل بالفعل.  إنه لأمر مؤسف أنه محدود بعض الشيء ، لكنه زائد أيضًا.  في بعض الأحيان ، يجب عليك العبث عندما تحتاج إلى استخدام قالب مخصص ، ولكن الأهم من ذلك أنه يمكن إزالة جميع القيود الرئيسية. <br><br>         ,            ,      UObject,   ,      ,           . <br><br> ,    ,      Unreal Engine 4.   -   ,          .    ,  -    ,   UObject. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar475622/">https://habr.com/ru/post/ar475622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar475608/index.html">مدير علامات Google: إعدادات مشغل غير واضحة ومفيدة</a></li>
<li><a href="../ar475610/index.html">مصابيح الطاولة LED الآمنة التي تحتفظ بالرؤية</a></li>
<li><a href="../ar475612/index.html">تعطى ، متى ، التأكيدات والثقة في التنفيذ</a></li>
<li><a href="../ar475614/index.html">أتمتة أصغر. الجزء الثاني. تصميم الشبكات</a></li>
<li><a href="../ar475618/index.html">كيفية كتابة عقد بيثون ذكي على شبكة الأنطولوجيا. الجزء 2: التخزين API</a></li>
<li><a href="../ar475624/index.html">PHP-Watcher: أداة تعمل على تبسيط عملية تطوير التطبيقات طويلة العمر</a></li>
<li><a href="../ar475626/index.html">يمكن استبدال autotests شخص بحثًا عن نقاط الضعف: مقابلة مع Alexandra Svatikova</a></li>
<li><a href="../ar475630/index.html">Knative - نظام أساسي يستند إلى k8s كخدمة مع دعم بدون خادم</a></li>
<li><a href="../ar475636/index.html">زيادة ناقلات العناصر</a></li>
<li><a href="../ar475640/index.html">إذا كنت تقوم بإنشاء شيء ما ، فتجنب جدول المدير.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>