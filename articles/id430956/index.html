<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•’ ğŸ§šğŸ½ ğŸ­ Kami mengajar seekor babi pada monoids untuk percaya pada diri mereka sendiri dan terbang ğŸš½ ğŸ›€ğŸ¼ ğŸ‘©ğŸ¼â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam salah satu artikel sebelumnya, saya berbicara tentang bagaimana Anda dapat membangun pelaksana program untuk mesin tumpukan virtual menggunakan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mengajar seekor babi pada monoids untuk percaya pada diri mereka sendiri dan terbang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430956/"><p> Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu</a> artikel sebelumnya, saya berbicara tentang bagaimana Anda dapat membangun pelaksana program untuk mesin tumpukan virtual menggunakan pendekatan pemrograman fungsional dan berorientasi bahasa.  Struktur matematika bahasa menyarankan struktur dasar untuk implementasi penerjemahnya, berdasarkan konsep semi-grup dan monoids.  Pendekatan ini memungkinkan saya untuk membangun implementasi yang indah dan dapat diperluas dan untuk mematahkan tepuk tangan, tetapi pertanyaan pertama dari audiensi membuat saya keluar dari mimbar dan naik ke Emacs lagi. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/ln/ne/n2lnneohm_d4rsc-qkw_n4cguyw.png" width="80%"></div><br><p>  Saya melakukan tes sederhana dan memastikan bahwa pada tugas-tugas sederhana yang hanya menggunakan stack, mesin virtual bekerja dengan cerdas, dan ketika menggunakan "memori" - sebuah array dengan akses acak - masalah besar dimulai.  Bagaimana kami berhasil menyelesaikannya tanpa mengubah prinsip dasar arsitektur program dan mencapai percepatan ribuan kali program akan dibahas dalam artikel yang akan menarik perhatian Anda. </p><a name="habracut"></a><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>âˆ—</mo><mtext>&nbsp;</mtext><mo>âˆ—</mo><mtext>&nbsp;</mtext><mo>âˆ—</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> * \ * \ * </script></p><br><p>  Haskell adalah bahasa khusus dengan ceruk khusus.  Tujuan utama penciptaan dan pengembangannya adalah perlunya lingua franca untuk mengekspresikan dan menguji ide-ide pemrograman fungsional.  Ini membenarkan fitur-fiturnya yang paling mencolok: kemalasan, kemurnian tertinggi, penekanan pada jenis dan manipulasi dengannya.  Itu tidak dirancang untuk pengembangan sehari-hari, tidak untuk pemrograman industri, bukan untuk penggunaan luas.  Fakta bahwa itu benar-benar digunakan untuk membuat proyek skala besar di industri jaringan dan dalam pemrosesan data adalah niat baik dari pengembang, bukti konsep, jika Anda mau.  Namun sejauh ini, produk yang paling penting, banyak digunakan dan luar biasa kuat yang ditulis dalam Haskell adalah ... kompiler ghc.  Dan ini sepenuhnya dibenarkan dari sudut pandang tujuannya - untuk menjadi alat untuk penelitian di bidang ilmu komputer.  Prinsip yang diproklamirkan oleh Simon Payton-Johnson: "Hindari kesuksesan dengan segala cara" diperlukan agar bahasa tetap menjadi instrumen seperti itu.  Haskell seperti ruang steril di laboratorium pusat penelitian yang mengembangkan teknologi semikonduktor atau nanomaterial.  Sangat tidak nyaman untuk bekerja, dan untuk praktik sehari-hari itu juga membatasi kebebasan bertindak, tetapi tanpa ketidaknyamanan ini, tanpa kepatuhan tanpa kompromi terhadap pembatasan, tidak akan mungkin untuk mengamati dan mempelajari efek halus yang nantinya akan menjadi dasar perkembangan industri.  Pada saat yang sama, dalam sterilitas industri hanya akan diperlukan dalam volume yang paling diperlukan, dan hasil percobaan ini akan muncul di kantong kita dalam bentuk gadget.  Kita mempelajari bintang dan galaksi bukan karena kita berharap menerima manfaat langsung darinya, tetapi karena, pada skala objek-objek yang tidak praktis ini, efek kuantum dan relativistik menjadi dapat diamati dan dipelajari, sedemikian rupa sehingga nantinya kita dapat menggunakan pengetahuan ini untuk mengembangkan sesuatu yang sangat bermanfaat.  Jadi Haskell dengan garis "salah", kemalasan perhitungan yang tidak praktis, kekakuan beberapa algoritma inferensi tipe, dengan kurva input yang sangat curam, akhirnya tidak memungkinkan Anda untuk dengan mudah membuat aplikasi pintar pada lutut atau sistem operasi.  Namun, lensa, monad, parsing kombinatorial, meluasnya penggunaan monoids, metode pembuktian teorema otomatis, manajer paket fungsional deklaratif, tipe linier dan dependen mendekati dunia praktis.  Aplikasi ini ditemukan dalam kondisi yang kurang steril dalam bahasa Python, Scala, Kotlin, F #, Rust, dan banyak lainnya.  Tetapi saya tidak akan menggunakan salah satu dari bahasa yang luar biasa ini untuk mengajarkan prinsip-prinsip pemrograman fungsional: Saya akan membawa siswa ke laboratorium, menunjukkan cara kerjanya dalam contoh yang cerah dan bersih, dan kemudian Anda dapat melihat prinsip-prinsip ini bekerja di pabrik mesin yang besar dan tidak bisa dipahami, tetapi sangat cepat.  Menghindari kesuksesan dengan segala cara adalah perlindungan terhadap upaya memasukkan pembuat kopi dalam mikroskop elektron untuk mempopulerkannya.  Dan di kompetisi mana bahasa lebih keren, Haskell akan selalu berada di luar nominasi yang biasa. </p><br><p>  Namun, orang itu lemah, dan iblis juga tinggal di dalam saya, yang membuat saya ingin membandingkan, mengevaluasi, dan membela "bahasa favorit saya" di depan orang lain.  Jadi, setelah menulis implementasi mesin stacked yang elegan, berdasarkan komposisi monoid, dengan satu-satunya tujuan untuk melihat apakah ide ini bekerja untuk saya, saya langsung kesal karena saya menyadari bahwa implementasinya bekerja dengan cemerlang, tetapi sangat tidak efisien!  Seolah-olah saya benar-benar akan menggunakannya untuk tugas-tugas serius, atau untuk menjual mesin bertumpuk saya di pasar yang sama di mana mesin virtual Python atau Java ditawarkan.  Tapi sialnya, artikel tentang anak babi yang dengannya seluruh percakapan ini dimulai mulai memberikan angka-angka lezat: ratusan milidetik untuk anak babi itu, detik untuk Python ... dan monoid cantikku tidak dapat mengatasi tugas yang sama dalam satu jam!  Saya harus berhasil!  Mikroskop saya akan menyeduh espresso tidak lebih buruk daripada mesin kopi di lorong institut!  Istana Kristal dapat tersebar dan diluncurkan ke luar angkasa! </p><br><p>  Tapi apa yang Anda siap menyerah, malaikat matematika bertanya kepada saya?  Kemurnian dan transparansi arsitektur istana?  Fleksibilitas dan ekstensibilitas yang diberikan homomorfisme dari program ke solusi lain?  Iblis dan malaikat itu keras kepala, dan penganut Tao yang bijak, yang saya juga izinkan untuk hidup, mengusulkan untuk mengambil jalan yang sesuai dengan keduanya, dan mengikutinya selama mungkin.  Namun, tidak dengan tujuan mengidentifikasi pemenang, tetapi untuk mengetahui jalan itu sendiri, untuk mengetahui sejauh mana itu mengarah, dan untuk mendapatkan pengalaman baru.  Jadi saya tahu kesedihan dan sukacita optimisasi yang sia-sia. </p><br><p> Sebelum kita mulai, kami menambahkan bahwa perbandingan <em>bahasa</em> dalam hal efektivitas tidak ada gunanya.  Anda perlu membandingkan penerjemah (juru bahasa atau penyusun), atau kinerja seorang programmer yang menggunakan bahasa tersebut.  Pada akhirnya, pernyataan bahwa program C adalah yang tercepat mudah disangkal dengan menulis juru bahasa C lengkap dalam BASIC, misalnya.  Jadi, kami tidak membandingkan Haskell dan javascript, tetapi kinerja program yang dijalankan oleh penerjemah yang dikompilasi oleh <code>ghc</code> dan program yang dijalankan, katakanlah, di browser tertentu.  Semua terminologi babi berasal dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> inspirasional tentang mesin bertumpuk.  Semua kode Haskell yang menyertai artikel dapat dipelajari di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> . </p><br><h3 id="vyhodim-iz-zony-komforta">  Kami meninggalkan zona nyaman </h3><br><p>  Posisi awal akan menjadi implementasi mesin tumpukan monoid dalam bentuk <abbr title="Bahasa Berorientasi Domain Tertanam">EDSL</abbr> - bahasa sederhana kecil yang memungkinkan menggabungkan dua lusin primitif untuk membuat program untuk mesin tumpukan virtual.  Begitu dia masuk ke artikel kedua, kami memberinya nama <code>monopig</code> .  Hal ini didasarkan pada fakta bahwa bahasa untuk mesin yang ditumpuk membentuk sebuah <em>monoid</em> dengan operasi gabungan dan operasi kosong sebagai satu unit.  Dengan demikian, ia sendiri dibangun dalam bentuk transformasi monoid dari kondisi mesin.  Negara termasuk tumpukan, memori dalam bentuk vektor (struktur menyediakan akses acak ke elemen), bendera berhenti darurat, dan baterai monoid untuk mengumpulkan informasi debug.  Seluruh struktur ini ditransmisikan di sepanjang rantai endomorfisme dari operasi ke operasi, melakukan proses komputasi.  Struktur isomorfik <em>kode</em> program dibangun dari struktur yang dibentuk oleh program, dan darinya homomorfisme menjadi struktur berguna lainnya yang mewakili persyaratan program dalam hal jumlah argumen dan memori.  Tahap akhir konstruksi adalah penciptaan monoids transformasi dalam kategori Claysley, yang memungkinkan Anda untuk merendam perhitungan dalam monad yang arbitrer.  Jadi mesin mendapat kemampuan input-output dan perhitungan yang ambigu.  Kami akan mulai dengan implementasi ini.  Kode nya dapat ditemukan di <a href="">sini</a> . </p><br><p>  Kami akan menguji efektivitas program pada implementasi naif dari saringan Eratosthenes, yang mengisi memori (array) dengan nol dan satu, yang menunjukkan bilangan prima dengan nol.  Kami memberikan kode prosedural dari algoritma dalam <code>javascript</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; memSize; i++) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n*n &lt; memSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!arr[n]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = n; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; memSize) { k+=n; arr[k] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } n++; } }</code> </pre> <br><p>  Algoritma ini segera sedikit dioptimalkan.  Ini menghilangkan berjalan buruk melalui sel-sel memori yang sudah terisi.  Malaikat matematikawan saya tidak setuju dengan versi yang <em>benar</em> - <em>benar</em> naif dari contoh dalam proyek <code>PorosenokVM</code> , karena pengoptimalan ini hanya memakan biaya lima instruksi bahasa tumpukan.  Begini cara algoritma menerjemahkan ke <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve</span></span> = push <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; while (dup &lt;&gt; dup &lt;&gt; mul &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; get &lt;&gt; branch mempty fill &lt;&gt; inc) &lt;&gt; pop fill = dup &lt;&gt; dup &lt;&gt; add &lt;&gt; while (dup &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; push <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; swap &lt;&gt; put &lt;&gt; exch &lt;&gt; add) &lt;&gt; pop</code> </pre> <br><p>  Dan di sini adalah bagaimana Anda dapat menulis implementasi yang setara dari algoritma ini pada Haskell idiomatik, menggunakan tipe yang sama seperti di <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> sieve' km | k*k &lt; memSize = sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m ! k == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m | otherwise = m fill' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> fill' knm | n &lt; memSize = fill' k (n+k) $ m // [(n,<span class="hljs-number"><span class="hljs-number">1</span></span>)] | otherwise = m</code> </pre> <br><p>  Menggunakan tipe <code>Data.Vector</code> dan alat untuk bekerja dengannya, yang tidak terlalu umum untuk pekerjaan sehari-hari di Haskell.  Ekspresi <code>m ! k</code>  <code>m ! k</code> mengembalikan elemen <code>k</code> dari vektor <code>m</code> , dan <code>m // [(n,1)]</code> - mengatur elemen dengan angka <code>n</code> ke 1. Saya menulis ini di sini karena saya harus pergi ke mereka untuk meminta bantuan, walaupun saya bekerja di Haskell hampir setiap hari.  Faktanya adalah bahwa struktur dengan akses acak dalam implementasi fungsional tidak efisien dan karena alasan ini tidak dicintai. </p><br><p>  Menurut kondisi kompetisi yang ditentukan dalam artikel tentang anak babi, algoritme dijalankan 100 kali.  Dan untuk menyingkirkan komputer tertentu, mari kita bandingkan kecepatan eksekusi ketiga program ini, merujuknya pada kinerja program <code>javascript</code> yang dijalankan di Chrome. </p><br><p><img src="https://habrastorage.org/webt/ir/hi/mj/irhimjjtdgec7vw1vduvivmzonm.png"></p><br><p>  Horor horor !!!  <code>monopig</code> tidak hanya memperlambat kecepatan tanpa dewa, jadi versi asli tidak jauh lebih baik!  Haskell, tentu saja, keren, tapi tidak kalah dengan program yang berjalan di browser ?!  Seperti yang pelatih ajarkan kepada kami, Anda tidak bisa hidup seperti itu, saatnya meninggalkan zona nyaman yang disediakan Haskell! </p><br><h3 id="preodolevaem-len">  Atasi kemalasan </h3><br><p>  Mari kita perbaiki.  Untuk melakukan ini, kompilasi program pada <code>monopig</code> dengan flag <code>-rtsopts</code> untuk <code>-rtsopts</code> statistik run-time dan lihat apa yang perlu kita jalankan saringan Eratosthenes sekali: </p><br><pre> <code class="plaintext hljs">$ ghc -O -rtsopts ./Monopig4.hs [1 of 1] Compiling Main ( Monopig4.hs, Monopig4.o ) Linking Monopig4 ... $ ./Monopig4 -RTS -sstderr "Ok" 68,243,040,608 bytes allocated in the heap 6,471,530,040 bytes copied during GC 2,950,952 bytes maximum residency (30667 sample(s)) 42,264 bytes maximum slop 15 MB total memory in use (7 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 99408 colls, 0 par 2.758s 2.718s 0.0000s 0.0015s Gen 1 30667 colls, 0 par 57.654s 57.777s 0.0019s 0.0133s INIT time 0.000s ( 0.000s elapsed) MUT time 29.008s ( 29.111s elapsed) GC time 60.411s ( 60.495s elapsed) &lt;--   ! EXIT time 0.000s ( 0.000s elapsed) Total time 89.423s ( 89.607s elapsed) %GC time 67.6% (67.5% elapsed) Alloc rate 2,352,591,525 bytes per MUT second Productivity 32.4% of total user, 32.4% of total elapsed</code> </pre> <br><p>  Baris terakhir memberi tahu kita bahwa program ini bergerak dalam bidang komputasi produktif hanya sepertiga dari waktu.  Selama sisa waktu itu, pengumpul sampah lari dari ingatan dan dibersihkan untuk perhitungan yang malas.  Berapa kali kita diberitahu di masa kanak-kanak bahwa kemalasan tidak baik!  Di sini, fitur utama Haskell membuat kami tidak puas, mencoba membuat beberapa miliar transformasi vektor dan tumpukan yang ditangguhkan. </p><br><p>  Malaikat matematika pada saat ini mengangkat jarinya dan dengan senang hati berbicara tentang fakta bahwa sejak zaman Gereja Alonzo, ada teorema yang menyatakan bahwa strategi perhitungan tidak mempengaruhi hasil mereka, yang berarti bahwa kita bebas memilihnya karena alasan efisiensi.  Mengubah perhitungan menjadi ketat tidak sulit sama sekali - beri tanda <code>!</code>  dalam deklarasi jenis stack dan memori, dan dengan demikian membuat bidang-bidang ini ketat. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Kami tidak akan mengubah apa pun dan segera memeriksa hasilnya: </p><br><pre> <code class="plaintext hljs">$ ./Monopig41 +RTS -sstderr "Ok" 68,244,819,008 bytes allocated in the heap 7,386,896 bytes copied during GC 528,088 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 16 MB total memory in use (14 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 129923 colls, 0 par 0.666s 0.654s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.001s 0.001s 0.0006s 0.0007s INIT time 0.000s ( 0.000s elapsed) MUT time 13.029s ( 13.048s elapsed) GC time 0.667s ( 0.655s elapsed) EXIT time 0.001s ( 0.001s elapsed) Total time 13.700s ( 13.704s elapsed) %GC time 4.9% (4.8% elapsed) Alloc rate 5,238,049,412 bytes per MUT second Productivity 95.1% of total user, 95.1% of total elapsed</code> </pre> <br><p>  Produktivitas telah tumbuh secara signifikan.  Total biaya memori masih tetap mengesankan karena data tidak dapat diubah, tetapi yang paling penting, sekarang kita telah membatasi kemalasan data, pengumpul sampah memiliki peluang untuk malas, hanya 5% pekerjaan yang tersisa.  Masukkan entri baru di peringkat. </p><br><p><img src="https://habrastorage.org/webt/6z/z4/6j/6zz46jgmso3w95efydonusy8pok.png"></p><br><p>  Nah, perhitungan yang ketat telah membawa kita lebih dekat ke kecepatan kode Haskell asli, yang memalukan melambat tanpa mesin virtual.  Ini berarti bahwa biaya overhead menggunakan vektor yang tidak dapat diubah <em>secara signifikan</em> melebihi biaya pemeliharaan mesin yang ditumpuk.  Dan ini berarti bahwa sudah waktunya untuk mengucapkan selamat tinggal pada kekekalan memori. </p><br><h3 id="vpuskaem-izmeneniya-v-zhizn">  Membiarkan Perubahan Menjadi Hidup </h3><br><p>  Tipe <code>Data.Vector</code> baik, tetapi menggunakannya, kami menghabiskan banyak waktu menyalin, atas nama menjaga kemurnian proses komputasi.  Menggantinya dengan tipe <code>Data.Vector.Unpacked</code> kita setidaknya menghemat kemasan struktur, tetapi ini tidak secara mendasar mengubah gambar.  Solusi yang benar adalah dengan menghapus memori dari keadaan mesin dan memberikan akses ke vektor eksternal menggunakan kategori Kleisley.  Pada saat yang sama, bersama dengan vektor murni, Anda dapat menggunakan apa yang disebut <code>Data.Vector.Mutable</code> vektor (bisa berubah-ubah). <code>Data.Vector.Mutable</code> . </p><br><p>  Kami akan menghubungkan modul-modul yang sesuai dan memikirkan bagaimana menangani data yang bisa berubah dalam program fungsional yang bersih. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Primitive <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M</code> </pre> <br><p>  Jenis kotor ini seharusnya diisolasi dari masyarakat murni.  Mereka terkandung dalam monad kelas <code>PrimMonad</code> (ini termasuk <code>ST</code> atau <code>IO</code> ), di mana program bersih hati-hati memasukkan instruksi untuk tindakan yang ditulis dalam bahasa fungsional kristal pada perkamen berharga.  Dengan demikian, perilaku hewan-hewan haram ini ditentukan oleh skenario yang benar-benar ortodoks dan tidak berbahaya.  Tidak semua program untuk mesin kami menggunakan memori, jadi tidak perlu mengutuk seluruh arsitektur untuk pencelupan di monad <code>IO</code> .  Seiring dengan subset bersih dari bahasa <code>monopig</code> kami akan membuat empat instruksi yang memberikan akses ke memori, dan hanya mereka yang akan memiliki akses ke wilayah berbahaya. </p><br><p>  Jenis mesin bersih semakin pendek: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Desainer program dan program itu sendiri hampir tidak akan melihat perubahan ini, tetapi tipenya akan berubah.  Selain itu, masuk akal untuk mendefinisikan beberapa jenis sinonim untuk menyederhanakan tanda tangan. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVector</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrimState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Code</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program'</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> ma</span></span></code> </pre> <br><p>  Konstruktor akan memiliki argumen lain yang mewakili akses memori.  Pelaksana akan berubah secara signifikan, terutama mereka yang menyimpan log perhitungan, karena sekarang mereka perlu menanyakan keadaan vektor variabel untuk itu.  <a href="">Kode</a> lengkap dapat dilihat dan dipelajari dalam repositori, tetapi di sini saya akan memberikan yang paling menarik: implementasi komponen dasar untuk bekerja dengan memori untuk menunjukkan bagaimana ini dilakukan. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">geti</span></span> :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma geti i = programM (<span class="hljs-type"><span class="hljs-type">GETI</span></span> i) $ \mem -&gt; \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mem i setStack (x:s) vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> puti :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma puti i = programM (<span class="hljs-type"><span class="hljs-type">PUTI</span></span> i) $ \mem -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (x:s) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mem ix setStack s vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> get :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma get = programM (<span class="hljs-type"><span class="hljs-type">GET</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:s) -&gt; \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.read mi setStack (x:s) vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> put :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma put = programM (<span class="hljs-type"><span class="hljs-type">PUT</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:x:s) -&gt; \vm -&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>.write mix &gt;&gt; setStack s vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected two elemets"</span></span></code> </pre> <br><p>  Daemon optimizer segera menawarkan sedikit lebih banyak untuk memeriksa nilai indeks yang diperbolehkan dalam memori, karena untuk <code>geti</code> <code>puti</code> dan <code>geti</code> indeks dikenal pada tahap pembuatan program dan nilai yang salah dapat dihilangkan terlebih dahulu.  Indeks yang ditentukan secara dinamis untuk perintah <code>put</code> dan <code>get</code> tidak menjamin keamanan, dan malaikat matematika tidak mengizinkan panggilan berbahaya dilakukan kepada mereka. </p><br><p>  Semua ini ribut dengan menempatkan memori ke dalam argumen terpisah yang tampaknya rumit.  Tapi itu sangat jelas menunjukkan data yang akan diubah oleh tempat <em>mereka</em> - <em>mereka harus di luar</em> .  Saya mengingatkan Anda bahwa kami mencoba membawa seorang pengantar pizza ke laboratorium steril.  Fungsi murni tahu apa yang harus dilakukan dengan mereka, tetapi benda-benda ini tidak akan pernah menjadi warga negara kelas satu, dan tidak layak menyiapkan pizza tepat di laboratorium. </p><br><p>  Mari kita periksa apa yang kita beli dengan perubahan ini: </p><br><pre> <code class="plaintext hljs">$ ./Monopig5 +RTS -sstderr "Ok" 9,169,192,928 bytes allocated in the heap 2,006,680 bytes copied during GC 529,608 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 2 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 17693 colls, 0 par 0.094s 0.093s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.000s 0.000s 0.0002s 0.0003s INIT time 0.000s ( 0.000s elapsed) MUT time 7.228s ( 7.232s elapsed) GC time 0.094s ( 0.093s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 7.325s ( 7.326s elapsed) %GC time 1.3% (1.3% elapsed) Alloc rate 1,268,570,828 bytes per MUT second Productivity 98.7% of total user, 98.7% of total elapsed</code> </pre> <br><p>  Ini sudah berlangsung!  Penggunaan memori berkurang delapan kali, kecepatan eksekusi program meningkat 180 kali, dan pengumpul sampah hampir sepenuhnya tidak bekerja. </p><br><p><img src="https://habrastorage.org/webt/o7/cw/f8/o7cwf8ptddtz8x1gdy0lunionis.png"></p><br><p>  Solusinya muncul <em>monopig st.</em>  <em>mut.</em>  , yang sepuluh kali lebih lambat dari solusi asli pada <code>js</code> , tetapi selain itu, solusi asli pada Haskell, menggunakan vektor bisa berubah.  Ini kodenya: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fill'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) fill' knm | n &gt; memSize-k = return m | otherwise = <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mn <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; fill' k (n+k) m sieve' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) sieve' km | k*k &lt; memSize = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m &gt;&gt;= sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) m | otherwise = return m</code> </pre> <br><p>  Dimulai sebagai berikut </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.replicate memSize <span class="hljs-number"><span class="hljs-number">0</span></span> stimes <span class="hljs-number"><span class="hljs-number">100</span></span> (sieve' <span class="hljs-number"><span class="hljs-number">2</span></span> m &gt;&gt; return ()) print <span class="hljs-string"><span class="hljs-string">"Ok"</span></span></code> </pre> <br><p>  Dan sekarang Haskell akhirnya menunjukkan bahwa dia bukan bahasa mainan.  Anda hanya perlu menggunakannya dengan bijak.  Ngomong-ngomong, kode di atas menggunakan fakta bahwa tipe <code>IO ()</code> membentuk semigroup dengan operasi eksekusi berurutan program <code>(&gt;&gt;)</code> , dan dengan bantuan <code>stimes</code> kami mengulangi 100 kali perhitungan masalah pengujian. </p><br><p>  Sekarang sudah jelas mengapa ada ketidaksukaan terhadap array fungsional dan mengapa tidak ada yang ingat bagaimana bekerja dengan mereka: begitu seorang programmer Haskell benar-benar membutuhkan struktur akses acak, ia memfokuskan kembali pada data yang dapat diubah dan bekerja di monad ST atau IO. </p><br><p>  Membawa sebagian perintah ke dalam zona khusus mempertanyakan legalitas isomorfisme <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.072ex" height="2.419ex" viewBox="0 -780.1 8642 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6C" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-65" x="2413" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-66" x="2880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-74" x="3430" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-72" x="3792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-69" x="4243" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-67" x="4589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-68" x="5069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-74" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-61" x="6007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-72" x="6537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-72" x="6988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6F" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-77" x="7925" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> \ longleftrightarrow </script>  <em>programnya</em> .  Bagaimanapun, kita tidak dapat secara bersamaan mengubah kode menjadi program murni dan yang monadik, ini tidak memungkinkan sistem tipe untuk melakukannya.  Namun, kelas tipe cukup fleksibel agar isomorfisma ini ada.  <em>Kode</em> homomorfisme <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.177ex" height="2.419ex" viewBox="0 -780.1 6965 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-72" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-69" x="2566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-67" x="2912" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-68" x="3392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-74" x="3969" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-61" x="4330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-72" x="4860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-72" x="5311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-6F" x="5763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMATHI-77" x="6248" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ longrightarrow </script>  <em>program ini</em> sekarang dibagi menjadi beberapa homomorfisma untuk himpunan bagian bahasa yang berbeda.  Bagaimana tepatnya ini dilakukan dapat dilihat pada [kode] () program secara lengkap. </p><br><h3 id="ne-ostanavlivaysya-na-dostignutom">  Jangan berhenti di situ </h3><br><p>  Menghilangkan panggilan fungsi yang tidak perlu dan menyematkan kodenya secara langsung menggunakan pragma <code>{-# INLINE #-}</code> akan membantu sedikit mengubah produktivitas program.  Metode ini tidak cocok untuk fungsi rekursif, tetapi bagus untuk komponen dasar dan fungsi penyetel.  Ini mengurangi waktu eksekusi program uji dengan 25% lainnya (lihat <a href="">Monopig51.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/0k/-l/hu/0k-lhu49_zsiihqoom7c5g0ize8.png"></p><br><p>  Langkah masuk akal berikutnya adalah menyingkirkan alat logging ketika mereka tidak dibutuhkan.  Pada tahap pembentukan endomorfisme yang mewakili program, kami menggunakan argumen eksternal, yang kami tentukan saat startup.  <code>program</code> konstruktor cerdas dan <code>programM</code> dapat diperingatkan bahwa mungkin tidak ada argumen-logger.  Dalam hal ini, kode konverter tidak mengandung sesuatu yang berlebihan: hanya fungsionalitas dan memeriksa status mesin. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">program</span></span> code f = programM code (const f) programM code f (<span class="hljs-type"><span class="hljs-type">Just</span></span> logger) mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; logger mem code =&lt;&lt; f mem (stack vm) vm _ -&gt; return vm programM code f _ mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; f mem (stack vm) vm _ -&gt; return vm</code> </pre> <br><p>  Sekarang, menjalankan fungsi harus secara eksplisit menunjukkan ada atau tidaknya penebangan tidak menggunakan tidak <code>none</code> rintisan, tetapi menggunakan jenis <code>Maybe (Logger ma)</code> .  Mengapa ini harus bekerja, karena jika ada logging atau tidak, komponen program akan mencari tahu "pada saat terakhir", sebelum eksekusi?  Bukankah kode yang tidak perlu dijahit pada tahap penyusunan komposisi program?  Haskell adalah bahasa yang malas dan di sini memainkannya ke tangan kita.  Sebelum eksekusi kode final dioptimalkan untuk tugas tertentu.  Pengoptimalan ini mengurangi waktu pelaksanaan program hingga 40% (lihat <a href="">Monopig52.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/co/gd/vy/cogdvyw-zsyliuiwsmhxs5gadhe.png"></p><br><p>  Dengan ini, kami akan menyelesaikan pekerjaan untuk mempercepat babi monoid.  Dia sudah berlari cukup cepat sehingga malaikat dan iblis bisa tenang.  Ini, tentu saja, bukan C, kami masih menggunakan daftar bersih sebagai tumpukan, tetapi menggantinya dengan array akan mengarah pada penggalian kode secara menyeluruh, dan penolakan untuk menggunakan template yang elegan dalam definisi perintah dasar.  Saya ingin bertahan dengan perubahan minimal, dan terutama pada tingkat jenis. </p><br><p>  Beberapa masalah tetap ada dengan logging.  Hitungan sederhana jumlah langkah atau menggunakan tumpukan berfungsi dengan baik (kami membuat bidang log menjadi ketat), tetapi memasangkannya sudah mulai memakan memori, Anda harus mengacaukan tendangan menggunakan <code>seq</code> , yang sudah cukup mengganggu.  Tapi katakan padaku, siapa yang akan mencatat 14 miliar langkah, jika Anda dapat men-debug tugas dalam ratusan pertama?  Jadi saya tidak akan menghabiskan waktu untuk mempercepat akselerasi. </p><br><p>  Tetap hanya menambahkan bahwa dalam artikel tentang anak babi, sebagai salah satu metode untuk mengoptimalkan perhitungan, pelacakan diberikan: alokasi bagian kode linier, <em>jejak</em> di mana perhitungan dapat dilakukan dengan melewati siklus pengiriman perintah utama (blok <code>switch</code> ).  Dalam kasus kami, komposisi monoid komponen program menciptakan jejak seperti itu baik selama pembentukan program dari komponen EDSL, atau selama pengoperasian homomorfisme <code>fromCode</code> .  Metode pengoptimalan ini berlaku gratis untuk kami, dengan kata lain, dengan konstruksi. </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhgSbI7ia_dUBNh3jE1010zfR3yemA#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>âˆ—</mo><mtext>&nbsp;</mtext><mo>âˆ—</mo><mtext>&nbsp;</mtext><mo>âˆ—</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> * \ * \ * </script></p><br><p>  Ada banyak solusi <code>Conduits</code> dan cepat dalam ekosistem Haskell, seperti <code>Conduits</code> atau <code>Pipes</code> stream, ada penggantian <code>String</code> sangat baik dan pencipta XML lincah seperti blaze-html, dan parser <code>attoparsec</code> adalah standar untuk analisis kombinasi untuk tata bahasa LL (âˆ).  Semua ini diperlukan untuk operasi normal.  Tetapi yang lebih dibutuhkan adalah penelitian yang mengarah pada keputusan ini.  Haskell telah dan tetap menjadi alat penelitian yang memenuhi persyaratan khusus yang tidak diperlukan oleh masyarakat umum.  Saya melihat di Kamchatka bagaimana kartu As pada helikopter Mi-4 menutup kotak korek api pada suatu argumen, mendorong roda pendarat dengan roda sambil menggantung di udara.  Ini bisa dilakukan, dan itu keren, tetapi tidak perlu. </p><br><p>  Tapi, bagaimanapun, ini keren !! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430956/">https://habr.com/ru/post/id430956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430944/index.html">NASA telah memutuskan para peserta untuk kompetisi mini-moon rover</a></li>
<li><a href="../id430948/index.html">Kementerian Komunikasi mengusulkan untuk memperketat kendali atas data pribadi</a></li>
<li><a href="../id430950/index.html">Membuat Bangunan Modern</a></li>
<li><a href="../id430952/index.html">Mobil listrik dan mobil hibrida harus membuat suara tambahan: mengapa ini diperlukan</a></li>
<li><a href="../id430954/index.html">Qt Everywhere: WebAssembly dan WebGL Streaming</a></li>
<li><a href="../id430958/index.html">Kami meluncurkan wadah dengan unit test di Azure DevOps (VSTS)</a></li>
<li><a href="../id430960/index.html">Tentang gamedev dari pameran desktop</a></li>
<li><a href="../id430962/index.html">Dukungan Razor dalam Visual Studio Code</a></li>
<li><a href="../id430964/index.html">Pemikiran deklaratif</a></li>
<li><a href="../id430966/index.html">Sprint umum di Perangkat Lunak Atlassian Jira</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>