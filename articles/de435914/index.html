<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêß ü•• ü§∑üèΩ Packen von ASP.NET Core-Anwendungen mit Docker ‚úåÔ∏è üö† ü¶è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ASP.NET Core-Anwendungen sind wirklich plattform√ºbergreifend und k√∂nnen unter Nixen und entsprechend in Docker ausgef√ºhrt werden. Mal sehen, wie sie g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Packen von ASP.NET Core-Anwendungen mit Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/435914/"><p>  ASP.NET Core-Anwendungen sind wirklich plattform√ºbergreifend und k√∂nnen unter Nixen und entsprechend in Docker ausgef√ºhrt werden.  Mal sehen, wie sie gepackt werden k√∂nnen, um unter Linux bereitgestellt und in Verbindung mit Nginx verwendet zu werden.  Details unter dem Schnitt! </p><br><p><img src="https://habrastorage.org/webt/rv/zy/xx/rvzyxxq8mg8yreoka2rkkukpr3i.jpeg"><a name="habracut"></a></p><br><p>  <em>Hinweis: Wir setzen die Reihe der Ver√∂ffentlichungen von Vollversionen von Artikeln aus dem Hacker-Magazin fort.</em>  <em>Rechtschreibung und Zeichensetzung des Autors gespeichert.</em> </p><br><h2>  √úber Docker </h2><br><p>  Fast jeder hat von Microservice-Architektur geh√∂rt.  Das Konzept, die Anwendung in Teile zu zerlegen, bedeutet nicht, dass sie neu ist.  Aber das Neue ist das gut vergessene und recycelte Alte. </p><br><p>  Wenn Sie versuchen, in wenigen Worten √ºber Architektur zu sprechen, ist die Webanwendung in separate einheitliche Teile unterteilt - Dienste.  Dienste interagieren nicht direkt miteinander und haben keine gemeinsamen Datenbanken.  Dies geschieht, um jeden Dienst ohne Konsequenzen f√ºr andere √§ndern zu k√∂nnen.  Dienstleistungen werden in Containern verpackt.  Unter den Containern regiert Docker den Ball. </p><br><p>  Um zu beschreiben, was Docker sehr oft vereinfacht wird, verwenden Sie den Begriff "virtuelle Maschine".  Es gibt definitiv eine √Ñhnlichkeit, aber es ist falsch, dies zu sagen.  Der einfachste Weg, diesen Unterschied zu verstehen, besteht darin, die folgenden Bilder aus der offiziellen Docker-Dokumentation zu betrachten: </p><br><p><img src="https://habrastorage.org/webt/xf/os/nu/xfosnujlxyttzdhimiuzf8tmcd8.png"></p><br><p><img src="https://habrastorage.org/webt/w4/y4/6e/w4y46e4boi3u-l8pwo70rs-7xmm.png"></p><br><p>  Container verwenden den Kern des aktuellen Betriebssystems und teilen ihn unter sich auf.  W√§hrend virtuelle Maschinen, die Hypervisor verwenden, Hardwareressourcen verwenden. <br>  Docker Image ist ein schreibgesch√ºtztes Objekt, in dem im Wesentlichen eine Vorlage zum Erstellen eines Containers gespeichert ist.  Ein Container ist eine Umgebung, in der Code ausgef√ºhrt wird.  Bilder werden in Repositories gespeichert.  Im offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker Hub-</a> Repository k√∂nnen Sie beispielsweise nur ein Bild privat speichern.  Es ist jedoch kostenlos. Selbst daf√ºr m√ºssen Sie sich bei ihnen bedanken. </p><br><h1>  INFO </h1><br><p>  Docker ist nicht der einzige Vertreter der Containerisierung.  Dar√ºber hinaus gibt es weitere Technologien.  Zum Beispiel: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rkt</a> (ausgesprochen 'Rakete') von CoreOS </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LXD</a> (ausgesprochen 'lexdi') von Ubuntu </p><br><p>  Windows-Container - Sie werden es von niemandem erraten. </p><br><p>  Nachdem wir uns mit der Theorie vertraut gemacht haben, gehen wir zur Praxis √ºber. </p><br><p>  Es macht keinen Sinn, die Docker-Installation zu zerlegen, da sie auf vielen Betriebssystemen installiert werden kann.  Ich werde nur darauf hinweisen, dass Sie es f√ºr Ihre Plattform aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker Store herunterladen k√∂nnen</a> .  Wenn Sie Docker unter Windows installieren, muss die Virtualisierung im BIOS und im Betriebssystem aktiviert sein.  Informationen zum Aktivieren in 10-ke finden Sie im folgenden Artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installieren von Hyper-V unter Windows</a> 10 </p><br><h2>  Erstellen eines Docker-f√§higen Projekts </h2><br><p> Docker ist nat√ºrlich ein Linux-Produkt, aber bei Bedarf k√∂nnen Sie es bei der Entwicklung f√ºr Mac oder Windows verwenden.  Wenn Sie ein Projekt in Visual Studio erstellen, um Docker-Unterst√ºtzung hinzuzuf√ºgen, aktivieren Sie einfach das Kontrollk√§stchen Docker-Unterst√ºtzung aktivieren. </p><br><p>  Docker-Unterst√ºtzung kann zu einem vorhandenen Projekt hinzugef√ºgt werden.  Es wird dem Projekt auf die gleiche Weise hinzugef√ºgt, wie verschiedene neue Komponenten hinzugef√ºgt werden.  Kontextmen√º Hinzuf√ºgen - Docker-Unterst√ºtzung. </p><br><p>  Wenn Docker auf Ihrem Computer installiert ist und ausgef√ºhrt wird, wird die Konsole automatisch ge√∂ffnet und der Befehl ausgef√ºhrt </p><br><pre><code class="lua hljs">docker pull microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p>  Dadurch wird der Vorgang zum Herunterladen des Bildes gestartet.  Dieses Bild ist eigentlich ein Leerzeichen, auf dessen Grundlage Ihr Bild erstellt wird.  ASP.NET Core 2.1 verwendet ein anderes Bild - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft / Dotnet: SDK</a> </p><br><p>  Die folgenden Dateien werden automatisch im Verzeichnis mit der f√ºr Sie geeigneten L√∂sung erstellt: <br>  .dockerignore (ohne Dateien und Verzeichnisse aus dem Docker-Image), docker-compose.yml (mit dieser Datei k√∂nnen Sie die Ausf√ºhrung mehrerer Dienste konfigurieren), docker-compose.override.yml (Zusatzkonfiguration docker-compose), docker-compose.dcproj ( Projektdatei f√ºr Visual Studio). </p><br><p>  Eine Dockerfile-Datei wird im Projektverzeichnis erstellt.  Mit Hilfe dieser Datei erstellen wir unser Bild.  Standardm√§√üig (falls das Projekt DockerServiceDemo hei√üt) sieht es m√∂glicherweise folgenderma√üen aus: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo/DockerServiceDemo.csproj DockerServiceDemo/ RUN dotnet restore DockerServiceDemo/DockerServiceDemo.csproj COPY . . WORKDIR /src/DockerServiceDemo RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  Bei der Erstkonfiguration f√ºr .NET Core 2.0 k√∂nnen Sie das Image nicht sofort mit dem Docker-Build-Befehl erstellen.  Es ist so konfiguriert, dass die Docker-Compose-Datei aus einem Verzeichnis auf einer Ebene h√∂her gestartet wird.  Damit der Bau erfolgreich verl√§uft, kann das Dockerfile in ein √§hnliches Aussehen gebracht werden: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo.csproj DockerServiceDemo.csproj RUN dotnet restore DockerServiceDemo.csproj COPY . . WORKDIR /src RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  Ich habe lediglich das zus√§tzliche DockerServiceDemo-Verzeichnis entfernt. </p><br><p>  Wenn Sie Visual Studio Code verwenden, m√ºssen Sie die Dateien manuell generieren.  Obwohl VS Code √ºber Zusatzfunktionen in Form einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> Erweiterung verf√ºgt, werde ich einen Link zum Handbuch zur Arbeit mit dem Docker von VS Code - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten mit Docker</a> hinzuf√ºgen.  Ja, der Artikel ist in Englisch, aber es ist mit Bildern </p><br><h2>  Docker mit drei Akkorden </h2><br><p>  F√ºr die t√§gliche Arbeit mit dem Docker reichen nur wenige Befehle aus, um sich zu erinnern. </p><br><p>  Das wichtigste Team ist nat√ºrlich der Aufbau eines Images.  Dazu m√ºssen Sie bash / CMD / PowerShell verwenden, um in das Verzeichnis zu wechseln, in dem sich die Docker-Datei befindet, und den folgenden Befehl ausf√ºhren: </p><br><pre> <code class="python hljs">docker build -t your_image_name .</code> </pre> <br><p>  Hier wird nach der Option -t der Name Ihres Bildes festgelegt.  Achtung - am Ende des Befehls ein Leerzeichen nach dem Leerzeichen.  Dieser Punkt bedeutet, dass das aktuelle Verzeichnis verwendet wird.  Ein Bild kann mit einem Tag (Nummer oder Name) versehen werden.  F√ºgen Sie dazu nach dem Namen einen Doppelpunkt ein und geben Sie ein Tag an.  Wenn das Tag nicht angegeben ist, wird es standardm√§√üig mit dem neuesten Namen festgelegt.  Um ein Bild an das Repository zu senden, muss der Bildname den Namen des Repositorys enthalten.  Ungef√§hr so: </p><br><pre> <code class="python hljs">docker build -t docker_account_name/image_name:your_tag .</code> </pre> <br><p>  Hier ist Ihr_Docker_Kontoname der Name Ihres Docker-Hub-Kontos. </p><br><p>  Wenn Sie das Image nur mit einem lokalen Namen erstellt haben, der das Repository nicht enth√§lt, k√∂nnen Sie das Image nach der Erstellung mit dem folgenden Befehl mit einem anderen Namen markieren: </p><br><pre> <code class="python hljs">docker tag image_name docker_account_name/image_name:your_tag</code> </pre> <br><p>  Um √Ñnderungen an den Hub zu senden, m√ºssen Sie jetzt den folgenden Befehl ausf√ºhren: </p><br><pre> <code class="python hljs">docker push docker_account_name/image_name:your_tag</code> </pre> <br><p>  Zuvor m√ºssen Sie sich bei Ihrem Docker-Konto anmelden.  Unter Windows erfolgt dies √ºber die Benutzeroberfl√§che der Anwendung, unter * nix jedoch √ºber den folgenden Befehl: </p><br><pre> <code class="python hljs">docker login</code> </pre> <br><p>  In der Tat sind drei Teams nicht genug.  Sie m√ºssen auch in der Lage sein, den Betrieb des Containers zu √ºberpr√ºfen.  Der Befehl, mit dem Sie den Container starten k√∂nnen, sieht folgenderma√üen aus: </p><br><pre> <code class="python hljs">docker run -it -p <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> image_name</code> </pre> <br><p>  Die Option -it erstellt ein Pseudo-TTY und Ihr Container reagiert auf Anforderungen.  Nach dem Ausf√ºhren des Befehls ist der Dienst unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 5000 /</a> verf√ºgbar. </p><br><p>  -p 5000: 80 ordnet Port 5000 des Containers Port 80 des Hosts zu. </p><br><p>  Dar√ºber hinaus gibt es solche Befehle: </p><br><pre> <code class="python hljs">docker ps ‚Äìa</code> </pre> <br><p>  Zeigen Sie eine Liste der Container.  Da der Schalter -a hinzugef√ºgt wurde, werden alle Container angezeigt, nicht nur die aktuell ausgef√ºhrten. </p><br><pre> <code class="python hljs">docker rm container_name</code> </pre> <br><p>  Dieser Befehl entfernt den Container mit dem Namen container_name.  rm - kurz zum entfernen </p><br><pre> <code class="python hljs">docker logs container_name</code> </pre> <br><p>  Containerprotokolle anzeigen </p><br><pre> <code class="python hljs">docker rmi image_name</code> </pre> <br><p>  L√∂scht ein Bild mit dem Namen image_name </p><br><h2>  Starten eines Containers √ºber einen Reverse-Proxy-Server </h2><br><p>  Tatsache ist, dass .NET Core-Anwendungen selbst ihren Kestrel-Webserver verwenden.  Dieser Server wird f√ºr die Produktion nicht empfohlen.  Warum?  Es gibt mehrere Erkl√§rungen. <br>  Wenn mehrere Anwendungen IP und Port gemeinsam nutzen, kann Kestrel den Datenverkehr nicht verteilen.  Dar√ºber hinaus bietet der Reverse-Proxy-Server eine zus√§tzliche Sicherheitsebene, vereinfacht den Lastausgleich und die SSL-Einstellungen und l√§sst sich besser in die vorhandene Infrastruktur integrieren.  F√ºr die meisten Entwickler ist zus√§tzliche Sicherheit der wichtigste Grund f√ºr die Notwendigkeit von Reverse-Proxys. </p><br><p>  Stellen Sie zun√§chst die urspr√ºngliche Dockerfile-Konfiguration wieder her.  Danach werden wir uns mit der Datei docker-compose.yml befassen und versuchen, unseren Dienst alleine auszuf√ºhren.  Das yml-Dateiformat wird als "yaml" gelesen und ist eine Abk√ºrzung f√ºr "Noch eine andere Markup-Sprache" oder "YAML ist keine Markup-Sprache".  Entweder eine andere Auszeichnungssprache oder √ºberhaupt keine Auszeichnungssprache.  Irgendwie ist nicht alles sicher. </p><br><p>  Meine Standard-Docker-Compose-Datei sieht folgenderma√üen aus: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile</code> </pre> <br><p>  Die Datei docker-compose.override.yml f√ºgt der Konfiguration mehrere Einstellungen hinzu: <br>  Version: '3.4' </p><br><pre> <code class="python hljs">services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development ports: - <span class="hljs-string"><span class="hljs-string">"80"</span></span></code> </pre> <br><p>  Wir k√∂nnen die erstellte L√∂sung mit Docker-Compose-Build erstellen. Durch Aufrufen des Docker-Compose-Up-Befehls starten wir unseren Container.  Alles arbeitet?  Fahren Sie dann mit dem n√§chsten Schritt fort.  Erstellen Sie die Datei nginx.info.  Die Konfiguration ist ungef√§hr wie folgt: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">80</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">80</span></span>; location / { proxy_pass http://app_servers; proxy_http_version <span class="hljs-number"><span class="hljs-number">1.1</span></span>; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Hier geben wir an, dass nginx Port 80 abh√∂rt (listen 80;).  Die empfangenen Anforderungen werden an den 80. Port des Hosts im Dockerservicedemo-Container umgeleitet.  Au√üerdem teilen wir nginx mit, welche Header weitergegeben werden sollen. </p><br><p>  Wir k√∂nnen http in nginx verwenden und √ºber https auf die Website zugreifen.  Wenn eine https-Anforderung √ºber einen http-Proxy gesendet wird, werden viele Informationen von https nicht an http √ºbergeben.  Bei Verwendung eines Proxys geht au√üerdem die externe IP-Adresse verloren.  Damit diese Informationen in den Headern √ºbertragen werden k√∂nnen, m√ºssen Sie den Code unseres ASP.NET-Projekts √§ndern und den folgenden Code am Anfang der Configure-Methode der Datei Startup.cs hinzuf√ºgen: </p><br><pre> <code class="python hljs"> app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto });</code> </pre> <br><p>  Die meisten Proxyserver verwenden die Header X-Forwarded-For und X-Forwarded-Proto.  Diese Header werden jetzt in der Nginx-Konfiguration angegeben. </p><br><p>  F√ºgen Sie nun das Nginx-Image und die Datei nginx.conf in die Doker-Compose-Konfiguration ein.  Vorsicht in YAML-R√§umen ist wichtig: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf ports: - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span></code> </pre> <br><p>  Hier f√ºgen wir unserer Konfiguration Proxys als Nginx-Image hinzu.  Wir f√ºgen diesem Bild eine externe Einstellungsdatei bei.  Wir mounten es mithilfe eines Mechanismus namens Volume in das Container-Dateisystem.  Wenn Sie am Ende hinzuf√ºgen: ro, wird das Objekt schreibgesch√ºtzt gemountet. </p><br><p>  Der Proxy √ºberwacht den externen 80. Port des Computers, auf dem der Container ausgef√ºhrt wird, und sendet eine Anforderung an den internen 80. Port des Containers. </p><br><p>  Durch Ausf√ºhren des Befehls doker-compose up f√ºllen wir das Nginx-Image aus dem Repository und starten unseren Container zusammen mit dem Proxy-Container.  Jetzt unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 80 /</a> wird es √ºber nginx zug√§nglich sein.  Auf dem 5000. Port ‚Äûdreht‚Äú sich die Anwendung auch unter Kestrel. </p><br><p>  Wir k√∂nnen √ºberpr√ºfen, ob die Anforderung an die Webanwendung √ºber den Reverse-Proxy erfolgt.  √ñffnen Sie die Entwicklertools im Chrome-Browser und wechseln Sie zur Registerkarte Netzwerk.  Klicken Sie hier auf localhost und w√§hlen Sie die Registerkarte Header. </p><br><p><img src="https://habrastorage.org/webt/zx/xi/sp/zxxisp6hjwtbza8u5wlmgu54jqq.png"></p><br><h2>  Wir starten den Container √ºber Proxys und HTTPS </h2><br><p>  ASP.NET Core 2.1 brachte Verbesserungen in der HTTPS-Unterst√ºtzung mit sich. <br>  Angenommen, mit der folgenden Middleware k√∂nnen Sie von einer ungesicherten Verbindung zu einer sicheren umleiten: </p><br><pre> <code class="python hljs">app.UseHttpsRedirection();</code> </pre> <br><p>  Mit dem n√§chsten k√∂nnen Sie das HTTP Strict Transport Security Protocol (HSTS) verwenden. </p><br><pre> <code class="python hljs">app.UseHsts();</code> </pre> <br><p>  HSTS ist eine Funktion aus dem HTTP / 2-Protokoll, dessen Spezifikation 2015 ver√∂ffentlicht wurde.  Diese Funktionalit√§t wird von modernen Browsern unterst√ºtzt und informiert, dass die Website nur https verwendet.  Somit besteht ein Schutz gegen einen Downgrade-Angriff, bei dem der Angreifer die Situation ausnutzen kann, indem er den √úbergang zu einem unsicheren http-Protokoll verwendet.  F√ºhren Sie beispielsweise ein Downgrade von TLS durch oder ersetzen Sie sogar ein Zertifikat. </p><br><p>  In der Regel wird diese Art von Angriff in Verbindung mit Man-in-the-Middle-Angriffen verwendet.  Sie sollten wissen und sich daran erinnern, dass HSTS Sie nicht vor einer Situation bewahrt, in der ein Benutzer die Site mithilfe des http-Protokolls besucht und dann zu https umleitet.  Es gibt die sogenannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrome-Preload-Liste</a> , die Links zu Websites enth√§lt, die https unterst√ºtzen.  Andere Browser (Firefox, Opera, Safari, Edge) unterst√ºtzen ebenfalls Listen von https-Sites, die basierend auf der Chrome-Liste erstellt wurden.  Alle diese Listen sind jedoch weit von allen Websites entfernt. </p><br><p>  Wenn Sie zum ersten Mal eine Core-Anwendung unter Windows ausf√ºhren, erhalten Sie eine Meldung, dass ein Entwicklerzertifikat erstellt und installiert wurde.  Wenn Sie auf die Schaltfl√§che klicken und das Zertifikat installieren, wird es als vertrauensw√ºrdig eingestuft.  √úber die Befehlszeile unter macOS k√∂nnen Sie dem Zertifikat mit dem folgenden Befehl Vertrauen hinzuf√ºgen: <br>  dotnet dev-certs https ‚Äìtrust </p><br><p>  Wenn das Dienstprogramm dev-certs nicht installiert ist, k√∂nnen Sie es mit dem folgenden Befehl installieren: </p><br><pre> <code class="python hljs">dotnet tool install --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> dotnet-dev-certs</code> </pre> <br><p>  Wie Sie ein vertrauensw√ºrdiges Zertifikat unter Linux hinzuf√ºgen, h√§ngt von der Verteilung ab. <br>  Zu Testzwecken verwenden wir das Entwicklerzertifikat.  Aktionen mit einem von CA signierten Zertifikat sind √§hnlich.  Auf Wunsch k√∂nnen Sie kostenlose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LetsEncrypt-</a> Zertifikate verwenden </p><br><p>  Mit dem Befehl k√∂nnen Sie das Entwicklerzertifikat in eine Datei exportieren </p><br><pre> <code class="python hljs">dotnet dev-certs https -ep ___.pfx</code> </pre> <br><p>  Die Datei muss unter Windows in das Verzeichnis% APPDATA% / ASP.NET / Https / oder unter macOS / Linux nach /root/.aspnet/https/ kopiert werden. </p><br><p>  Erstellen Sie Benutzergeheimnisse mit den folgenden Inhalten, damit der Container den Pfad zum Zertifikat und sein Kennwort abruft: </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"Kestrel"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Certificates"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Default"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/.aspnet/https/__.pfx"</span></span>, <span class="hljs-string"><span class="hljs-string">"Password"</span></span>: <span class="hljs-string"><span class="hljs-string">"___"</span></span> } } } }</code> </pre> <br><p>  Diese Datei speichert unverschl√ºsselte Daten und wird daher nur w√§hrend der Entwicklung verwendet.  Eine Datei wird in Visual Studio erstellt, indem Sie das Kontextmen√º auf dem Projektsymbol aufrufen oder das Dienstprogramm f√ºr Benutzergeheimnisse unter Linux verwenden. </p><br><p>  Unter Windows wird die Datei im Verzeichnis% APPDATA% \ Microsoft \ UserSecrets \ &lt;Benutzer-Sekret_ID&gt; \ Secrets.json gespeichert, und unter MacOS und Linux wird sie in ~ / .microsoft / usersecrets / &lt;Benutzer_Sekret_ID&gt; /Sekret.json gespeichert </p><br><p>  Um die Einstellungen f√ºr die Produktion zu speichern, verwenden einige Linux-Distributionen m√∂glicherweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd. Die</a> Einstellungen werden unter dem Attribut Service gespeichert.  Zum Beispiel so: </p><br><pre> <code class="python hljs">[Service] Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Path=/root/.aspnet/https/__.pfx"</span></span> Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Password=___"</span></span></code> </pre> <br><p>  Als n√§chstes werde ich sofort die Arbeitsversion der Docker-Konfiguration f√ºr den Proxy und den Container √ºber https geben und analysieren. </p><br><p>  Docker-Compose-Datei: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo21: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile  override: version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=https://+:<span class="hljs-number"><span class="hljs-number">44392</span></span>;http://+:<span class="hljs-number"><span class="hljs-number">80</span></span> - ASPNETCORE_HTTPS_PORT=<span class="hljs-number"><span class="hljs-number">44392</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"59404:80"</span></span> - <span class="hljs-string"><span class="hljs-string">"44392:44392"</span></span> volumes: - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf - ./DockerServiceDemo/cert.crt:/etc/nginx/cert.crt - ./DockerServiceDemo/cert.rsa:/etc/nginx/cert.rsa ports: - <span class="hljs-string"><span class="hljs-string">"5001:44392"</span></span></code> </pre> <br><p>  Jetzt werde ich unverst√§ndliche Momente beschreiben.  Mit ASPNETCORE_URLS k√∂nnen wir im Anwendungscode nicht mit app.UseUrl den Port angeben, den die Anwendung √ºberwacht. </p><br><p>  ASPNETCORE_HTTPS_PORT f√ºhrt eine Umleitung durch, √§hnlich wie der folgende Code: <br>  services.AddHttpsRedirection (options =&gt; options.HttpsPort = 44392) </p><br><p>  Das hei√üt, der Datenverkehr von http-Anforderungen wird an einen bestimmten Port von https-Anforderungen umgeleitet. <br>  Bei Verwendung von Ports wird angezeigt, dass die Anforderung vom externen 59404. Port an den 80. Container und vom 44392. externen Port an den 44392. umgeleitet wird.  Da wir einen Reverse-Proxy-Server konfiguriert haben, k√∂nnen wir theoretisch Ports mit diesen Weiterleitungen entfernen. <br>  Mithilfe von Volumes werden ein Verzeichnis mit einem pfx-Zertifikat und eine UserSecrets-Anwendung mit einem Kennwort und einem Link zum Zertifikat bereitgestellt. </p><br><p>  Der Proxy-Abschnitt gibt an, dass Anforderungen vom 5001. externen Port an den 44392. Nginx-Port umgeleitet werden.  Dar√ºber hinaus werden eine Nginx-Konfigurationsdatei sowie ein Zertifikat und ein Zertifikatschl√ºssel bereitgestellt. </p><br><p>  Damit sie ein einzelnes pfx-Zertifikat (das wir bereits haben) zum Erstellen von CRT- und RSA-Dateien erstellen k√∂nnen, k√∂nnen Sie OpenSSL verwenden.  Zuerst m√ºssen Sie das Zertifikat extrahieren: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -clcerts -nokeys -out domain.crt</code> </pre> <br><p>  Und dann der private Schl√ºssel: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -nocerts -nodes -out domain.rsa</code> </pre> <br><p>  Die Nginx-Konfiguration lautet wie folgt: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">44392</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">44392</span></span> ssl; ssl_certificate /etc/nginx/cert.crt; ssl_certificate_key /etc/nginx/cert.rsa; location / { proxy_pass https://app_servers; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Der Proxyserver √ºberwacht Port 44392.  Dieser Port empf√§ngt Anforderungen vom 5001. Host-Port.  Als N√§chstes leitet der Proxy Anforderungen an den 44392. Port des Dockerdemoservice-Containers weiter. </p><br><p>  Wenn Sie diese Beispiele verstanden haben, erhalten Sie einen guten Hintergrund f√ºr die Arbeit mit Docker, Microservices und Nginx. </p><br><p>  Wir erinnern Sie daran, dass dies die Vollversion eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikels aus dem Hacker-Magazin ist</a> .  Sein Autor ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexey Sommer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435914/">https://habr.com/ru/post/de435914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435904/index.html">KI √ºbersetzte Gehirnaktivit√§t in Sprache</a></li>
<li><a href="../de435906/index.html">Schrittmacher-Cluster-Speicher + DRBD (Dual Primary) + ctdb</a></li>
<li><a href="../de435908/index.html">Asketisches Netz: Prototyp-Flohm√§rkte f√ºr unterwegs und js</a></li>
<li><a href="../de435910/index.html">Warum hat BSD den Kampf mit GNU / Linux verloren?</a></li>
<li><a href="../de435912/index.html">Die Hauptprobleme bei der Entwicklung moderner Schnittstellen</a></li>
<li><a href="../de435916/index.html">Wenn Sie VK hacken, wird die Zwei-Faktor-Authentifizierung nicht gespeichert</a></li>
<li><a href="../de435920/index.html">Entwicklerkochbuch: DDD-Rezepte (Teil 4, Strukturen)</a></li>
<li><a href="../de435922/index.html">Java, Spring, Kurento und Mediendienste. Teil 2</a></li>
<li><a href="../de435924/index.html">Das neuronale Netzwerk erzeugt Bilder von Gerichten nach Rezepten f√ºr ihre Zubereitung</a></li>
<li><a href="../de435926/index.html">Das neuronale Netz sammelt Fragmente arch√§ologischer Funde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>