<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍣 👩🏿‍🚀 🙎🏻 Monólito para centenas de versões de clientes: como escrevemos e suportamos testes 👋🏿 🥦 😓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal! 

 Sou desenvolvedor de back-end na equipe de servidores do Badoo. Na conferência HighLoad do ano passado, fiz uma apresentação , cuja ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monólito para centenas de versões de clientes: como escrevemos e suportamos testes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/443768/"><img src="https://habrastorage.org/webt/tz/sv/jv/tzsvjvswjax_rsrd3fjcriulb-8.jpeg"><br><br>  Olá pessoal! <br><br>  Sou desenvolvedor de back-end na equipe de servidores do Badoo.  Na conferência HighLoad do ano passado, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fiz uma apresentação</a> , cuja versão em texto quero compartilhar com você.  Esta postagem será mais útil para aqueles que escrevem testes para o back-end e enfrentam problemas com o teste de código legado, bem como para quem deseja testar lógica de negócios complexa. <br><br>  Sobre o que vamos falar?  Primeiro, falarei brevemente sobre nosso processo de desenvolvimento e como isso afeta nossa necessidade de testes e o desejo de escrevê-los.  Em seguida, subiremos e desceremos a pirâmide de automação de testes, discutiremos os tipos de testes que usamos, falaremos sobre as ferramentas dentro de cada um deles e quais problemas resolveremos com a ajuda deles.  No final, considere como manter e executar todas essas coisas. <br><a name="habracut"></a><br><h2>  Nosso processo de desenvolvimento </h2><br>  Ilustramos nosso processo de desenvolvimento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/hv/jr/erhvjrnkf7zncdxhlgjusogzmyk.png" width="600"></div><br>  Um jogador de golfe é um desenvolvedor de back-end.  Em algum momento, uma tarefa de desenvolvimento chega a ele, geralmente na forma de dois documentos: requisitos do lado comercial e um documento técnico que descreve as alterações em nosso protocolo de interação entre o back-end e os clientes (aplicativos móveis e o site). <br><br>  O desenvolvedor grava o código e o coloca em operação, e antes de todos os aplicativos clientes.  Toda a funcionalidade é protegida por alguns sinalizadores de recurso ou testes A / B, conforme prescrito em um documento técnico.  Depois disso, de acordo com as prioridades atuais e o roteiro do produto, os aplicativos clientes são liberados.  Para nós, desenvolvedores de back-end, é completamente imprevisível quando um recurso específico será implementado nos clientes.  O ciclo de lançamento para aplicativos clientes é um pouco mais complicado e mais longo que o nosso, portanto nossos gerentes de produto literalmente fazem malabarismos com prioridades. <br><br>  A cultura de desenvolvimento adotada pela empresa é de grande importância: o desenvolvedor de back-end é responsável pelo recurso desde o momento de sua implementação no back-end até a última integração na última plataforma em que foi originalmente planejado para implementar esse recurso. <br><br>  Essa situação é bem possível: seis meses atrás, você lançou algum recurso, as equipes dos clientes não o implementaram por um longo tempo, porque as prioridades da empresa mudaram, você já está ocupado trabalhando em outras tarefas, tem novos prazos, prioridades - e aqui seus colegas vêm correndo e eles dizem: “Você se lembra dessa coisa que lavou seis meses atrás?  Ela não está trabalhando.  E, em vez de se envolver em novas tarefas, você apaga os incêndios. <br><br><img src="https://habrastorage.org/files/e22/ebe/15c/e22ebe15c2174a4d99ebf0da46fbe950.gif" width="600"><br><br>  Portanto, nossos desenvolvedores têm uma motivação incomum para programadores PHP - para garantir que haja o mínimo de problemas possível durante a fase de integração. <br><br>  O que você deseja fazer antes de tudo para garantir que o recurso funcione? <br><br>  Obviamente, a primeira coisa que vem à mente é realizar testes manuais.  Você escolhe o aplicativo, mas ele não sabe como - como o recurso é novo, os clientes cuidam dele em seis meses.  Bem, o teste manual não garante que, durante o tempo decorrido entre o lançamento do back-end e o início da integração, ninguém quebrará nada nos clientes. <br><br>  E aqui os testes automatizados vêm em nosso auxílio. <br><br><h2>  Testes unitários </h2><br>  Os testes mais simples que escrevemos são testes de unidade.  Usamos PHP como idioma principal para o back-end e PHPUnit como estrutura para teste de unidade.  Olhando para o futuro, direi que todos os nossos testes de back-end foram escritos com base nessa estrutura. <br><br>  Testes de unidade na maioria das vezes cobrimos alguns pequenos pedaços de código isolados, verificamos o desempenho de métodos ou funções, ou seja, estamos falando de pequenas unidades da lógica de negócios.  Nossos testes de unidade não devem interagir com nada, acessar bancos de dados ou serviços. <br><br><h3>  Softmocks </h3><br>  A principal dificuldade que os desenvolvedores enfrentam ao escrever testes de unidade é um código não testável, e geralmente esse é um código legado. <br><br>  Um exemplo simples.  O Badoo tem 12 anos, uma vez que era uma startup muito pequena, desenvolvida por várias pessoas.  A inicialização existiu com sucesso sem nenhum teste.  Então ficamos grandes o suficiente e percebemos que você não pode viver sem testes.  Mas, nessa época, havia sido escrito muito código que funcionava.  Não o reescreva apenas para testar!  Isso não seria muito razoável do ponto de vista comercial. <br><br>  Portanto, desenvolvemos uma pequena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca de software livre SoftMocks</a> , que torna nosso processo de gravação de testes mais barato e mais rápido.  Ele intercepta todos incluem / requer arquivos PHP e on-the-fly substitui o arquivo de origem pelo conteúdo modificado, ou seja, código reescrito.  Isso nos permite criar stubs para qualquer código.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ele</a> detalha como a biblioteca funciona. <br><br>  Isto é o que parece para um desenvolvedor: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//mock  \Badoo\SoftMocks::redefineConstant($constantName, $newValue); //mock  : , ,  \Badoo\SoftMocks::redefineMethod( $class, $method, $method_args, $fake_code ); //mock  \Badoo\SoftMocks::redefineFunction( $function, $function_args, $fake_code );</span></span></code> </pre> <br>  Com a ajuda de construções simples, podemos redefinir globalmente tudo o que queremos.  Em particular, eles nos permitem contornar as limitações do criador padrão do PHPUnit.  Ou seja, podemos zombar de métodos estáticos e privados, redefinir constantes e fazer muito mais, o que é impossível no PHPUnit comum. <br><br>  No entanto, encontramos um problema: parece aos desenvolvedores que, se houver SoftMocks, não há necessidade de escrever o código testado - você sempre pode “pentear” o código com nossos mocks globais, e tudo funcionará bem.  Mas essa abordagem leva a um código mais complexo e ao acúmulo de "muletas".  Portanto, adotamos várias regras que nos permitem manter a situação sob controle: <br><br><ol><li>  Todo novo código deve ser facilmente testado com zombarias padrão do PHPUnit.  Se essa condição for atendida, o código poderá ser testado e você poderá selecionar facilmente um pequeno pedaço e testá-lo apenas. <br></li><li>  O SoftMocks pode ser usado com código antigo escrito de uma maneira que não é adequada para testes de unidade, bem como nos casos em que é muito caro / longo / difícil de fazer o contrário (enfatize o necessário). <br></li></ol><br>  A conformidade com essas regras é cuidadosamente monitorada no estágio de revisão do código. <br><br><h3>  Teste de mutação </h3><br>  Separadamente, quero dizer sobre a qualidade dos testes de unidade.  Eu acho que muitos de vocês usam métricas como cobertura de código.  Mas ela, infelizmente, não responde a uma pergunta: "Eu escrevi um bom teste de unidade?"  É possível que você tenha escrito esse teste, que na verdade não verifica nada, não contém uma única declaração, mas gera excelente cobertura de código.  Obviamente, o exemplo é exagerado, mas a situação não está tão longe da realidade. <br><br>  Recentemente, começamos a introduzir testes mutacionais.  Este é um conceito bastante antigo, mas não muito conhecido.  O algoritmo para esses testes é bastante simples: <br><br><ul><li>  pegue o código e a cobertura do código; <br></li><li>  analisar e começar a mudar o código: verdadeiro para falso,&gt; para&gt; =, + para - (em geral, prejudicar de todas as formas); <br></li><li>  para cada alteração de mutação, execute conjuntos de testes que cubram a sequência alterada; <br></li><li>  se os testes caem, eles são bons e realmente não nos permitem quebrar o código; <br></li><li>  se os testes foram aprovados, provavelmente, eles não são eficazes o suficiente, apesar da cobertura, e pode valer a pena examiná-los mais de perto, para dar alguma afirmação (ou se houver uma área não coberta pelo teste). <br></li></ul><br>  Existem várias estruturas prontas para PHP, como Humbug e Infection.  Infelizmente, eles não nos agradaram, porque são incompatíveis com o SoftMocks.  Portanto, criamos nosso próprio pequeno utilitário de console, que faz o mesmo, mas usa nosso formato de cobertura de código interno e é amigo do SoftMocks.  Agora, o desenvolvedor o inicia manualmente e analisa os testes escritos por ele, mas estamos trabalhando para introduzir a ferramenta em nosso processo de desenvolvimento. <br><br><h2>  Teste de integração </h2><br>  Com a ajuda dos testes de integração, verificamos a interação com vários serviços e bancos de dados. <br><br>  Para entender melhor a história, vamos desenvolver uma promoção fictícia e cobri-la com testes.  Imagine que nossos gerentes de produto decidiram distribuir tickets de conferência para nossos usuários mais dedicados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/72/us/3f/72us3fyuuclhm8c1erh3qk42yra.png" width="300"></div><br>  A promoção deve ser exibida se: <br><br><ul><li>  o usuário no campo "Trabalho" indica "programador", <br></li><li>  o usuário participa do teste A / B HL18_promo, <br></li><li>  O usuário está registrado há mais de dois anos. <br></li></ul><br>  Ao clicar no botão "Obter um ticket", precisamos salvar os dados deste usuário em alguma lista para transferi-los para nossos gerentes que distribuem os tickets. <br><br>  Mesmo neste exemplo bastante simples, há algo que não pode ser verificado usando testes de unidade - interação com o banco de dados.  Para fazer isso, precisamos usar testes de integração. <br><br>  Considere a maneira padrão de testar a interação do banco de dados oferecida pelo PHPUnit: <br><br><ol><li>  Aumente o banco de dados de teste. <br></li><li>  Preparamos DataTables e DataSets. <br></li><li>  Execute o teste. <br></li><li>  Limpamos o banco de dados de teste. <br></li></ol><br>  Que dificuldades estão à espera de tal abordagem? <br><br><ul><li>  Você precisa dar suporte às estruturas do DataTables e DataSets.  Se alteramos o layout da tabela, é necessário refletir essas alterações no teste, o que nem sempre é conveniente e requer tempo adicional. <br></li><li>  Leva tempo para preparar o banco de dados.  Sempre que configuramos o teste, precisamos fazer o upload de algo lá, criar algumas tabelas, e isso é longo e problemático se houver muitos testes. <br></li><li>  E a desvantagem mais importante: executar esses testes em paralelo os torna instáveis.  Começamos o teste A, ele começou a escrever na tabela de teste que ele criou.  Ao mesmo tempo, lançamos o teste B, que deseja trabalhar com a mesma tabela de teste.  Como resultado, surgem bloqueios mútuos e outras situações imprevistas. <br></li></ul><br>  Para evitar esses problemas, desenvolvemos nossa própria pequena biblioteca DBMocks. <br><br><h3>  DBMocks </h3><br>  O princípio de operação é o seguinte: <br><br><ol><li>  Com a ajuda do SoftMocks, interceptamos todos os wrappers pelos quais trabalhamos com bancos de dados. <br></li><li>  Quando <br>  a consulta passa por simulação, analisa a consulta SQL e extrai DB + TableName dela e obtém o host da conexão. <br></li><li>  No mesmo host em tmpfs, criamos uma tabela temporária com a mesma estrutura que a original (copiamos a estrutura usando SHOW CREATE TABLE). <br></li><li>  Depois disso, redirecionaremos todas as solicitações que passarão por simulação para esta tabela para uma temporária recém-criada. <br></li></ol><br>  O que isso nos dá: <br><br><ul><li>  não há necessidade de cuidar constantemente das estruturas; <br></li><li>  os testes não podem mais corromper dados nas tabelas de origem, porque os redirecionamos para tabelas temporárias em tempo real; <br></li><li>  ainda estamos testando a compatibilidade com a versão do MySQL com a qual estamos trabalhando e, se a solicitação deixar de ser compatível com a nova versão de repente, nosso teste a verá e trará. <br></li><li>  e o mais importante, agora os testes estão isolados e, mesmo que você os execute paralelamente, os threads serão dispersos em diferentes tabelas temporárias, pois adicionamos uma chave exclusiva para cada teste nos nomes das tabelas de teste. <br></li></ul><br><h2>  Teste de API </h2><br>  A diferença entre os testes de unidade e API é bem ilustrada por este GIF: <br><br><img src="https://habrastorage.org/webt/ho/zb/me/hozbmexeumir1wdsjsgnlobh5xs.gif"><br>  <i>A fechadura funciona bem, mas está presa à porta errada.</i> <br><br>  Nossos testes simulam uma sessão do cliente, são capazes de enviar solicitações ao back-end, seguindo nosso protocolo, e o back-end responde a eles como um cliente real. <br><br><h3>  Pool de usuários de teste </h3><br>  O que precisamos para escrever com sucesso esses testes?  Vamos voltar às condições do show da nossa promoção: <br><br><ul><li>  o usuário no campo "Trabalho" indica "programador", <br></li><li>  o usuário participa do teste A / B HL18_promo, <br></li><li>  O usuário está registrado há mais de dois anos. <br></li></ul><br>  Aparentemente, aqui tudo é sobre o usuário.  E, na realidade, 99% dos testes de API requerem um usuário registrado autorizado, presente em todos os serviços e bancos de dados. <br><br>  Onde conseguir?  Você pode tentar registrá-lo no momento do teste, mas: <br><br><ul><li>  é longo e consome recursos; <br></li><li>  após a conclusão do teste, esse usuário precisa ser removido de alguma forma, o que é uma tarefa não trivial se estivermos falando de grandes projetos; <br></li><li>  finalmente, como em muitos outros projetos altamente carregados, realizamos muitas operações em segundo plano (adicionando um usuário a vários serviços, replicação para outros data centers etc.);  os testes não sabem nada sobre esses processos, mas se eles implicitamente dependem dos resultados de sua execução, há um risco de instabilidade. <br></li></ul><br><br>  Desenvolvemos uma ferramenta chamada Test Users Pool.  É baseado em duas idéias: <br><br><ol><li>  Não registramos usuários o tempo todo, mas o usamos muitas vezes. <br></li><li>  Após o teste, redefinimos os dados do usuário para seu estado original (no momento do registro).  Se isso não for feito, os testes se tornarão instáveis ​​ao longo do tempo, porque os usuários serão "poluídos" com informações de outros testes. <br></li></ol><br><br>  Funciona mais ou menos assim: <br><br><img src="https://habrastorage.org/webt/yg/db/p5/ygdbp5rwmfrbd2ssyiejb3bp8fs.png"><br><br>  Em algum momento, queríamos executar nossos testes de API em um ambiente de produção.  Por que queremos isso?  Porque a infraestrutura de desenvolvimento não é a mesma que produção. <br><br>  Embora tentemos repetir constantemente a infraestrutura de produção em um tamanho reduzido, o desenvolvimento nunca será uma cópia completa dela.  Para ter certeza absoluta de que a nova compilação atende às expectativas e não há problemas, carregamos o novo código no cluster de pré-produção, que trabalha com dados e serviços de produção, e executamos nossos testes de API lá. <br><br>  Nesse caso, é muito importante pensar em como isolar usuários de teste dos reais. <br><br><div class="spoiler">  <b class="spoiler_title">O que acontecerá se os usuários de teste começarem a parecer reais em nosso aplicativo.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/io/wg/gkiowghhl3b4hzazgj9u5e_wf4s.gif" width="300"></div><br></div></div><br>  Como isolar?  Cada um de nossos usuários tem um sinalizador <code>is_test_user</code> .  No estágio de registro, torna-se <code>yes</code> ou <code>no</code> e não muda mais.  Com esse sinalizador, isolamos os usuários em todos os serviços.  Também é importante excluirmos os usuários de teste das análises de negócios e dos resultados dos testes A / B para não distorcer as estatísticas. <br><br>  Você pode seguir de uma maneira mais simples: começamos com o fato de que todos os usuários de teste foram "realocados" para a Antártica.  Se você possui um serviço geográfico, esta é uma maneira completamente funcional. <br><br><h3>  API de controle de qualidade </h3><br>  Não precisamos apenas de um usuário - precisamos dele com certos parâmetros: trabalhar como programador, participar de um determinado teste A / B e foi registrado há mais de dois anos.  Para usuários de teste, podemos facilmente atribuir uma profissão usando nossa API de back-end, mas entrar nos testes A / B é probabilístico.  E a condição de registro há mais de dois anos atrás é geralmente difícil de cumprir, porque não sabemos quando o usuário apareceu no pool. <br><br>  Para resolver esses problemas, temos uma API de controle de qualidade.  Na verdade, esse é um backdoor para testes, que é um método API bem documentado que permite gerenciar de maneira rápida e fácil os dados do usuário e alterar seu estado, ignorando o protocolo principal de nossa comunicação com os clientes.  Os métodos são escritos por desenvolvedores de back-end para engenheiros de controle de qualidade e para uso em testes de interface do usuário e API. <br><br>  A API de controle de qualidade pode ser aplicada apenas no caso de usuários de teste: se não houver um sinalizador correspondente, o teste cairá imediatamente.  Aqui está um dos métodos da API de controle de qualidade que permite alterar a data de registro do usuário para uma data arbitrária: <br><br><img src="https://habrastorage.org/webt/gw/mf/ws/gwmfwsbej3rtmytvaxdoxbzrvaa.png"><br><br>  E assim parecerão três chamadas que permitirão alterar rapidamente os dados do usuário de teste, para que eles satisfaçam as condições de exibição da promoção: <br><br><ul><li>  No campo "Trabalho", o "programador" é indicado: <br> <code>addUserWorkEducation?user_id=ID&amp;works[]=Badoo, <br> </code> <br> </li><li>  O usuário participa do teste A / B HL18_promo: <br> <code>forceSplitTest?user_id=ID&amp;test=HL18_promo</code> <br> </li><li>  Registrado há mais de dois anos: <br> <code>userCreatedChange?user_id=ID&amp;created=2016-09-01</code> <br> </li></ul><br><br>  Como esse é um backdoor, é imperativo pensar em segurança.  Protegemos nosso serviço de várias maneiras: <br><br><ul><li>  isolado no nível da rede: os serviços podem ser acessados ​​somente a partir da rede do escritório; <br></li><li>  com cada solicitação, passamos um segredo, sem o qual é impossível acessar a API de controle de qualidade, mesmo a partir da rede do escritório; <br></li><li>  Os métodos funcionam apenas com usuários de teste. <br></li></ul><br><br><h3>  Remotemocks </h3><br>  Para trabalhar com o back-end remoto de testes de API, podemos precisar de zombarias.  Para que?  Por exemplo, se o teste da API no ambiente de produção começar a acessar o banco de dados, precisamos garantir que os dados contidos nele sejam limpos dos dados de teste.  Além disso, as zombarias ajudam a tornar a resposta do teste mais adequada para o teste. <br><br>  Temos três textos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/66/dc/jo66dczs4sbrfuzaohyqy7izy6e.png" width="300"></div><br><br>  O Badoo é um aplicativo multilíngue, temos um componente de localização complexo que permite traduzir e receber traduções rapidamente para a localização atual do usuário.  Nossos localizadores estão trabalhando constantemente para melhorar as traduções, realizar testes A / B com tokens e procurar formulações mais bem-sucedidas.  E, durante a realização do teste, não podemos saber qual texto será retornado pelo servidor - ele pode ser alterado a qualquer momento.  Mas podemos usar o RemoteMocks para verificar se o componente de localização é acessado corretamente. <br><br>  Como o RemoteMocks funciona?  O teste solicita que o back-end os inicialize para sua sessão e, após o recebimento de todas as solicitações subsequentes, o back-end verifica zombarias para a sessão atual.  Se estiverem, basta inicializá-los usando o SoftMocks. <br><br>  Se queremos criar uma simulação remota, indicamos qual classe ou método precisa ser substituído e com o quê.  Todas as solicitações de back-end subsequentes serão executadas levando em consideração este mock: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;remoteInterceptMethod( \Promo\HighLoadConference::class, <span class="hljs-string"><span class="hljs-string">'saveUserEmailToDb'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> );</code> </pre><br>  Bem, agora vamos coletar nosso teste de API: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       $app_startup = [ 'supported_promo_blocks' =&gt; [\Mobile\Proto\Enum\PromoBlockType::GENERIC_PROMO] ]; $Client = $this-&gt;getLoginedConnection(BmaFunctionalConfig::USER_TYPE_NEW, $app_startup); //  $Client-&gt;getQaApiClient()-&gt;addUserWorkEducation(['Badoo, ']); $Client-&gt;getQaApiClient()-&gt;forceSplitTest('HL18_promo'); $Client-&gt;getQaApiClient()-&gt;userCreatedChange('2016-09-01'); //     $this-&gt;remoteInterceptMethod(\Promo\HighLoadConference::class, 'saveUserEmail', true); //,   ,   $Resp = $Client-&gt;ServerGetPromoBlocks([]); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_NEXT_PROMO_BLOCKS')); $PromoBlock = $Resp-&gt;CLIENT_NEXT_PROMO_BLOCKS; … //   CTA, ,   ,   $Resp = $Client-&gt;ServerPromoAccepted($PromoBlock-&gt;getPromoId()); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_ACKNOWLEDGE_COMMAND'));</span></span></code> </pre><br><br>  De uma maneira tão simples, podemos testar qualquer funcionalidade que venha ao desenvolvimento no back-end e exija alterações no protocolo móvel. <br><br><h3>  Regras de uso de teste da API </h3><br>  Tudo parece estar bem, mas novamente encontramos um problema: os testes da API se mostraram muito convenientes para o desenvolvimento e houve uma tentação de usá-los em qualquer lugar.  Como resultado, uma vez que percebemos que estávamos começando a resolver problemas com a ajuda de testes de API para os quais eles não eram destinados. <br><br>  Por que isso é ruim?  Porque os testes da API são muito lentos.  Eles acessam a rede, recorrem ao back-end, que inicia a sessão, acessam o banco de dados e vários serviços.  Portanto, desenvolvemos um conjunto de regras para o uso de testes de API: <br><ul><li>  O objetivo dos testes de API é verificar o protocolo de interação entre o cliente e o servidor, bem como a correta integração do novo código; <br><br></li><li>  é permitido cobrir processos complexos com eles, por exemplo, cadeias de ações; <br></li><li>  eles não podem ser usados ​​para testar a pequena variabilidade da resposta do servidor - esta é a tarefa dos testes de unidade; <br></li><li>  durante a revisão do código, verificamos incluindo os testes. <br></li></ul><br><h2>  Testes de interface do usuário </h2><br>  Como estamos considerando uma pirâmide de automação, vou falar um pouco sobre os testes de interface do usuário. <br><br>  Os desenvolvedores de back-end do Badoo não escrevem testes de interface do usuário - para isso, temos uma equipe dedicada no departamento de controle de qualidade.  Cobrimos o recurso com testes de interface do usuário quando ele já é lembrado e estabilizado, porque acreditamos que não é razoável gastar recursos em uma automação bastante cara do recurso, que talvez não vá além do teste A / B. <br><br>  Usamos o Calabash para testes automáticos para dispositivos móveis e o Selenium para a web.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ele</a> fala sobre a nossa plataforma para automação e teste. <br><br><h2>  Execução de teste </h2><br>  Agora, temos 100.000 testes de unidade, 6.000 - testes de integração e 14.000 testes de API.  Se você tentar executá-los em um encadeamento, mesmo em nossa máquina mais poderosa, uma execução completa levará: modular - 40 minutos, integração - 90 minutos, testes de API - dez horas.  É muito longo. <br><br><h3>  Paralelização </h3><br>  <i>Falamos sobre nossa experiência de testes de unidade paralelos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> .</i> <br><br>  A primeira solução, que parece óbvia, é executar testes em vários threads.  Mas fomos além e criamos uma nuvem para o lançamento paralelo para poder escalar recursos de hardware.  Simplificado, seu trabalho se parece com o seguinte: <br><br><img src="https://habrastorage.org/webt/2q/s8/v7/2qs8v7eoyhw_-e3iv-igmt_xui0.png"><br><br>  A tarefa mais interessante aqui é a distribuição de testes entre os threads, ou seja, sua divisão em partes. <br><br>  Você pode dividi-los igualmente, mas todos os testes são diferentes, portanto, pode haver um forte viés no tempo de execução de um encadeamento: todos os encadeamentos já foram atingidos e um trava por meia hora, pois teve "sorte" com testes muito lentos. <br><br>  Você pode iniciar vários threads e alimentá-los com um teste de cada vez.  Nesse caso, a desvantagem é menos óbvia: há custos indiretos para inicializar o ambiente que, com um grande número de testes e essa abordagem, começam a desempenhar um papel importante. <br><br>  O que fizemos?  Começamos a coletar estatísticas sobre o tempo necessário para executar cada teste e, em seguida, começamos a compor partes de maneira que, de acordo com as estatísticas, um encadeamento fosse executado por não mais que 30 segundos.  Ao mesmo tempo, empacotamos os testes em pedaços para torná-los menores. <br><br>  No entanto, nossa abordagem também tem uma desvantagem.  Está associado a testes de API: eles são muito lentos e consomem muitos recursos, impedindo a execução de testes rápidos. <br><br>  Portanto, dividimos a nuvem em duas partes: na primeira, apenas os testes rápidos são lançados; na segunda, os rápidos e os lentos podem ser lançados.  Com essa abordagem, sempre temos um pedaço da nuvem que pode lidar com testes rápidos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6z/py/0n/6zpy0n5tqvqmqjsf7huyqiu5ogo.png" width="600"></div><br><br>  Como resultado, os testes de unidade começaram a ser executados em um minuto, os testes de integração em cinco minutos e os testes de API em 15 minutos.  Ou seja, uma execução completa em vez de 12 horas não leva mais que 22 minutos. <br><br><h3>  Execução do teste de cobertura de código </h3><br>  Temos um grande monólito complexo e, de uma maneira boa, precisamos executar todos os testes constantemente, pois uma mudança em um lugar pode quebrar algo em outro.  Essa é uma das principais desvantagens da arquitetura monolítica. <br><br>  Em algum momento, chegamos à conclusão de que você não precisa executar todos os testes todas as vezes - você pode executar com base na cobertura do código: <br><br><ol><li>  Veja o nosso diferencial. <br></li><li>  Criamos uma lista de arquivos modificados. <br></li><li>  Para cada arquivo, obtemos uma lista de testes, <br>  que cobrem isso. <br></li><li>  A partir desses testes, criamos um conjunto e o executamos em uma nuvem de teste. <br></li></ol><br>  Onde obter cobertura?  Coletamos dados uma vez por dia quando a infraestrutura do ambiente de desenvolvimento está ociosa.  O número de testes executados diminuiu acentuadamente, a velocidade de receber feedback deles, pelo contrário, aumentou significativamente.  Lucro! <br><br>  Um bônus adicional foi a capacidade de executar testes de patches.  Apesar de o Badoo não ser uma startup há muito tempo, ainda podemos implementar rapidamente mudanças na produção, aplicar hot fix, distribuir recursos rapidamente e alterar a configuração.  Como regra, a velocidade de lançamento de patches é muito importante para nós.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A nova abordagem deu um grande aumento na velocidade de feedback dos testes, porque agora não precisamos esperar muito tempo para uma execução completa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas sem as falhas, em lugar nenhum. </font><font style="vertical-align: inherit;">Lançaremos o back-end duas vezes por dia, e a cobertura é relevante apenas para o primeiro lançamento, até o primeiro build, após o qual ele fica para trás em um build. </font><font style="vertical-align: inherit;">Portanto, para compilações, executamos um conjunto de testes completo. </font><font style="vertical-align: inherit;">Para nós, isso é uma garantia de que a cobertura do código não está muito atrás e que todos os testes necessários foram concluídos. </font><font style="vertical-align: inherit;">O pior que pode acontecer é que pegaremos alguns testes caídos no estágio de criação do build, e não nos estágios anteriores. </font><font style="vertical-align: inherit;">Mas isso acontece muito raramente.</font></font><br><br>         API-,      code coverage.         ,   ,    .       - ,  API-         . <br><br><h2>  Conclusão </h2><br><ul><li>       ,       .    - , , -    . <br></li><li>   ≠ .    code review    ,   . <br></li><li>       , ,     .         . <br></li><li>   .              . <br></li><li> ,    !     ,         . <br></li></ul><br><br><blockquote> <b> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Badoo PHP Meetup 16 </a> .         PHP-.    ,   .   ! <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  12:00,  —   YouTube-</a></b> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443768/">https://habr.com/ru/post/pt443768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443754/index.html">Sobre a adequação do Selenium WebDriverWait</a></li>
<li><a href="../pt443756/index.html">Design da classe: O que é bom?</a></li>
<li><a href="../pt443758/index.html">Reconhecimento rápido do Doodle de desenho: Como fazer amigos R, C ++ e redes neurais</a></li>
<li><a href="../pt443764/index.html">O que o designer fumava: uma arma de fogo incomum</a></li>
<li><a href="../pt443766/index.html">Tentando a programação de contratos C ++ 20 agora</a></li>
<li><a href="../pt443770/index.html">Design Orientado a Domínio: Objetos de Valor e Núcleo da Estrutura de Entidades na Prática</a></li>
<li><a href="../pt443772/index.html">Antiguidades: IBM ThinkPad T40, o primeiro sistema sem fio</a></li>
<li><a href="../pt443774/index.html">Como a neurobiologia interfere nas eleições presidenciais nos EUA</a></li>
<li><a href="../pt443776/index.html">China introduz um sistema experimental de reconhecimento facial ao pagar metrô</a></li>
<li><a href="../pt443780/index.html">Projeto MCDM. Parte 1. Conceito</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>