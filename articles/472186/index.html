<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Principio abierto-cerrado   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Aqu铆 hay una traducci贸n de un art铆culo de Robert Martin del Principio Abierto-Cerrado , que public贸 en enero de 1996. El art铆culo, por deci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principio abierto-cerrado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Hola Habr!  Aqu铆 hay una traducci贸n de un art铆culo de Robert Martin del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20060822033314/">Principio Abierto-Cerrado</a> , que public贸 en enero de 1996.  El art铆culo, por decirlo suavemente, no es el 煤ltimo.  Pero en RuNet, los art铆culos del t铆o Bob sobre SOLID se vuelven a contar solo en forma truncada, por lo que pens茅 que una traducci贸n completa no ser铆a superflua. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  Decid铆 comenzar con la letra O, ya que el principio de apertura-cierre, de hecho, es central.  Entre otras cosas, hay muchas sutilezas importantes a las que vale la pena prestarles atenci贸n: </p><br><ul><li>  Ning煤n programa puede ser "cerrado" al 100%. </li><li>  La programaci贸n orientada a objetos (OOP) opera no con objetos f铆sicos del mundo real, sino con conceptos, por ejemplo, el concepto de "ordenar". <a name="habracut"></a></li></ul><br><p>  Este es el primer art铆culo en mi columna de <em>Notas del ingeniero</em> para <em>The C ++ Report</em> .  Los art铆culos publicados en esta columna se centrar谩n en el uso de C ++ y OOP y abordar谩n las dificultades en el desarrollo de software.  Intentar茅 hacer que los materiales sean pragm谩ticos y 煤tiles para los ingenieros en ejercicio.  Para la documentaci贸n del dise帽o orientado a objetos en estos art铆culos, usar茅 la notaci贸n de Buch. </p><br><p>  Hay muchas heur铆sticas asociadas con la programaci贸n orientada a objetos.  Por ejemplo, "todas las variables miembro deben ser privadas", o "se deben evitar las variables globales", o "la determinaci贸n de tipo en tiempo de ejecuci贸n es peligrosa".  驴Cu谩l es la raz贸n de tales heur铆sticas?  驴Por qu茅 son verdad?  驴Son <em>siempre</em> ciertas?  Esta columna explora el principio de dise帽o que subyace a estas heur铆sticas: el principio de apertura-cierre. <br>  Ivar Jacobson dijo: Todos los sistemas cambian durante el ciclo de vida.  Esto debe tenerse en cuenta al dise帽ar un sistema que tenga m谩s de una versi贸n esperada ".  驴C贸mo podemos dise帽ar un sistema para que sea estable frente al cambio y que tenga m谩s de una versi贸n esperada?  Bertrand Meyer nos cont贸 sobre esto en 1988, cuando se formul贸 el ahora famoso principio de apertura-cercan铆a: </p><br><p>  <strong>Las entidades del programa (clases, m贸dulos, funciones, etc.) deben estar abiertas para expansi贸n y cerradas para cambios.</strong> </p><br><p>  Si un cambio en el programa implica una cascada de cambios en los m贸dulos dependientes, entonces aparecen signos indeseables de un dise帽o "malo" en el programa. </p><br><p>  El programa se vuelve fr谩gil, inflexible, impredecible y sin uso.  El principio de apertura-cercan铆a resuelve estos problemas de una manera muy directa.  l dice que es necesario dise帽ar m贸dulos que nunca <em>cambien</em> .  Cuando los requisitos cambian, debe expandir el comportamiento de dichos m贸dulos agregando un c贸digo nuevo, en lugar de cambiar el c贸digo antiguo que ya funciona. </p><br><h1>  Descripci贸n </h1><br><p>  Los m贸dulos que cumplen con el principio de apertura-cercan铆a tienen dos caracter铆sticas principales: </p><br><ol><li> <strong>Abierto a la expansi贸n.</strong>  Esto significa que el comportamiento del m贸dulo se puede ampliar.  Es decir, podemos agregar un nuevo comportamiento al m贸dulo de acuerdo con los requisitos cambiantes para la aplicaci贸n o para satisfacer las necesidades de las nuevas aplicaciones. </li><li>  <strong>Cerrado por cambio.</strong>  El c贸digo fuente de dicho m贸dulo es intocable.  Nadie tiene derecho a hacerle cambios. </li></ol><br><p>  Parece que estos dos signos no encajan entre s铆.  La forma est谩ndar de extender el comportamiento de un m贸dulo es hacer cambios en 茅l.  Un m贸dulo que no se puede cambiar generalmente se considera un m贸dulo con comportamiento fijo.  驴C贸mo se pueden cumplir estas dos condiciones opuestas? </p><br><h1>  La clave de la soluci贸n es la abstracci贸n. </h1><br><p>  En C ++, utilizando los principios del dise帽o orientado a objetos, es posible crear abstracciones fijas que pueden representar un conjunto ilimitado de posibles comportamientos. </p><br><p>  Las abstracciones son clases base abstractas, y todas las posibles clases sucesoras representan un conjunto ilimitado de posibles comportamientos.  Un m贸dulo puede manipular la abstracci贸n.  Dicho m贸dulo est谩 cerrado por cambios, ya que depende de una abstracci贸n fija.  Adem谩s, el comportamiento del m贸dulo se puede ampliar creando nuevos descendientes de abstracci贸n. </p><br><p> El siguiente diagrama muestra una opci贸n de dise帽o simple que no cumple con el principio de apertura-cercan铆a.  Ambas clases, <code>Client</code> y <code>Server</code> , no son abstractas.  No hay garant铆a de que las funciones que son miembros de la clase <code>Server</code> sean virtuales.  La clase <code>Client</code> usa la clase <code>Server</code> .  Si queremos que el objeto de la clase <code>Client</code> use un objeto de servidor diferente, debemos cambiar la clase <code>Client</code> para hacer referencia a la nueva clase de servidor. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="imagen"><br>  <em>Cliente cerrado</em> </p><br><p>  Y el siguiente diagrama muestra la opci贸n de dise帽o correspondiente, que cumple con el principio de apertura-cercan铆a.  En este caso, la clase <code>AbstractServer</code> es una clase abstracta, cuyas funciones miembro son virtuales.  La clase <code>Client</code> usa abstracci贸n.  Sin embargo, los objetos de la clase <code>Client</code> utilizar谩n objetos de la clase sucesora del <code>Server</code> .  Si queremos que los objetos de la clase <code>Client</code> utilicen una clase de servidor diferente, presentaremos un nuevo descendiente de la clase <code>AbstractServer</code> .  La clase del <code>Client</code> permanecer谩 sin cambios. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="imagen"><br>  <em>Cliente abierto</em> </p><br><h1>  Resumen de <code>Shape</code> </h1><br><p>  Considere una aplicaci贸n que deber铆a dibujar c铆rculos y cuadrados en una GUI est谩ndar.  Los c铆rculos y cuadrados se deben dibujar en un orden espec铆fico.  En el orden correspondiente, se compilar谩 una lista de c铆rculos y cuadrados, el programa debe revisar esta lista en el orden y dibujar cada c铆rculo o cuadrado. </p><br><p>  En C, utilizando t茅cnicas de programaci贸n de procedimientos que no cumplen con el principio de apertura y cierre, podr铆amos resolver este problema como se muestra en el Listado 1. Aqu铆 vemos muchas estructuras de datos con el mismo primer elemento.  Este elemento es un c贸digo de tipo que identifica la estructura de datos como un c铆rculo o cuadrado.  La funci贸n <code>DrawAllShapes</code> pasa a trav茅s de una matriz de punteros a estas estructuras de datos, reconociendo el c贸digo de tipo y luego llamando a la funci贸n correspondiente ( <code>DrawCircle</code> o <code>DrawSquare</code> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  La funci贸n <code>DrawAllShapes</code> no cumple el principio de apertura-cierre, ya que no se puede "cerrar" a partir de nuevos tipos de formas.  Si quisiera expandir esta funci贸n con la capacidad de dibujar formas de una lista que incluye tri谩ngulos, entonces necesitar铆a cambiar la funci贸n.  De hecho, tengo que cambiar la funci贸n para cada nuevo tipo de forma que necesito dibujar. </p><br><p>  Por supuesto, este programa es solo un ejemplo.  En la vida real, el operador del <code>switch</code> de la funci贸n <code>DrawAllShapes</code> se repetir铆a una y otra vez en varias funciones a lo largo de la aplicaci贸n, y cada una har铆a algo diferente.  Agregar nuevas formas a una aplicaci贸n de este tipo significa encontrar todos los lugares donde se usan tales <code>switch</code> (o cadenas <code>if/else</code> ) y agregar una nueva forma a cada una de ellas.  Adem谩s, es muy poco probable que todas las <code>switch</code> y las cadenas <code>if/else</code> est茅n tan bien estructuradas como en <code>DrawAllShapes</code> .  Es mucho m谩s probable que los predicados en <code>if</code> se combinen con operadores l贸gicos, o los bloques de <code>case</code> y <code>case</code> de las <code>switch</code> de <code>switch</code> se combinen de tal manera que "simplifiquen" un lugar particular en el c贸digo.  Por lo tanto, el problema de encontrar y comprender todos los lugares donde necesita agregar una nueva figura no puede ser trivial. </p><br><p>  En el Listado 2, mostrar茅 el c贸digo que demuestra una soluci贸n cuadrada / circular que cumple con el principio de apertura-cierre.  Se introduce una clase de <code>Shape</code> abstracta.  Esta clase abstracta contiene una funci贸n de <code>Draw</code> virtual pura.  Las clases <code>Circle</code> y <code>Square</code> son descendientes de la clase <code>Shape</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Tenga en cuenta que si queremos extender el comportamiento de la funci贸n <code>DrawAllShapes</code> en el Listado 2 para dibujar un nuevo tipo de forma, todo lo que tenemos que hacer es agregar un nuevo descendiente de la clase <code>Shape</code> .  No es necesario cambiar la funci贸n <code>DrawAllShapes</code> .  Por lo tanto, <code>DrawAllShapes</code> cumple con el principio de apertura-cercan铆a.  Su comportamiento se puede ampliar sin cambiar la funci贸n en s铆. </p><br><p>  En el mundo real, la clase <code>Shape</code> contendr铆a muchos otros m茅todos.  Y, sin embargo, agregar una nueva forma a la aplicaci贸n sigue siendo muy simple, ya que todo lo que necesita hacer es ingresar un nuevo heredero e implementar estas funciones.  No es necesario explorar toda la aplicaci贸n en busca de lugares que requieran cambios. </p><br><p>  Por lo tanto, los programas que cumplen con el principio de apertura-cercan铆a se cambian agregando un nuevo c贸digo, y no cambiando el existente; no cambian en cascada los cambios caracter铆sticos de los programas que no corresponden a este principio. </p><br><h1>  Estrategia de entrada cerrada </h1><br><p>  Obviamente, ning煤n programa puede estar 100% cerrado.  Por ejemplo, 驴qu茅 le sucede a la funci贸n <code>DrawAllShapes</code> en el Listado 2 si decidimos que primero deben dibujarse c铆rculos y luego cuadrados?  La funci贸n <code>DrawAllShapes</code> no <code>DrawAllShapes</code> cerrada por este tipo de cambio.  En general, no importa cu谩n "cerrado" est茅 el m贸dulo, siempre hay alg煤n tipo de cambio desde el cual no est谩 cerrado. </p><br><p>  Como el cierre no puede ser completo, debe ser introducido estrat茅gicamente.  Es decir, el dise帽ador debe elegir los tipos de cambios a partir de los cuales se cerrar谩 el programa.  Esto requiere algo de experiencia.  Un desarrollador experimentado conoce a los usuarios y la industria lo suficientemente bien como para calcular la probabilidad de varios cambios.  Luego se asegura de que se respete el principio de apertura-cercan铆a para los cambios m谩s probables. </p><br><h2>  Uso de la abstracci贸n para lograr una cercan铆a adicional. </h2><br><p>  驴C贸mo podemos cerrar la funci贸n <code>DrawAllShapes</code> de los cambios en el orden de dibujo?  Recuerde que el cierre se basa en la abstracci贸n.  Por lo tanto, para cerrar <code>DrawAllShapes</code> del pedido, necesitamos alg煤n tipo de "abstracci贸n de pedido".  Un caso especial de pedido, presentado anteriormente, es dibujar figuras de un tipo frente a figuras de otro tipo. </p><br><p>  La pol铆tica de pedidos implica que con dos objetos, puede determinar cu谩l debe dibujarse primero.  Por lo tanto, podemos definir un m茅todo para la clase <code>Shape</code> llamado <code>Precedes</code> , que toma otro objeto <code>Shape</code> como argumento y devuelve un valor booleano <code>true</code> si el objeto <code>Shape</code> que recibi贸 este mensaje necesita ser ordenado antes que el objeto <code>Shape</code> que fue Pasado como argumento. </p><br><p>  En C ++, esta funci贸n se puede representar como una sobrecarga del operador "&lt;".  El Listado 3 muestra la clase <code>Shape</code> con m茅todos de clasificaci贸n. </p><br><p>  Ahora que tenemos una manera de determinar el orden de los objetos de la clase <code>Shape</code> , podemos ordenarlos y luego dibujarlos.  El Listado 4 muestra el c贸digo C ++ correspondiente.  Utiliza las clases <code>Set</code> , <code>OrderedSet</code> e <code>OrderedSet</code> de la categor铆a <code>Components</code> desarrollada en mi libro (Dise帽o de aplicaciones C ++ orientadas a objetos utilizando el m茅todo Booch, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Entonces, hemos implementado el orden de los objetos de la clase <code>Shape</code> y dibuj谩ndolos en el orden apropiado.  Pero todav铆a no tenemos una implementaci贸n de la abstracci贸n del orden.  Obviamente, cada objeto <code>Shape</code> debe anular el m茅todo <code>Precedes</code> para determinar el orden.  驴C贸mo puede funcionar esto?  驴Qu茅 c贸digo se debe escribir en <code>Circle::Precedes</code> para que los c铆rculos se dibujen en cuadrados?  Presta atenci贸n al listado 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  Est谩 claro que esta funci贸n no cumple con el principio de apertura-cercan铆a.  No hay forma de cerrarlo de los nuevos descendientes de la clase <code>Shape</code> .  Cada vez que aparece un nuevo descendiente de la clase <code>Shape</code> , esta funci贸n debe cambiarse. </p><br><h2>  Uso de un enfoque basado en datos para lograr el cierre </h2><br><p>  La cercan铆a de los herederos de la clase <code>Shape</code> se puede lograr utilizando un enfoque tabular que no provoca cambios en cada clase heredada.  Un ejemplo de este enfoque se muestra en el Listado 6. </p><br><p>  Usando este enfoque, cerramos con 茅xito la funci贸n <code>DrawAllShapes</code> de los cambios relacionados con el pedido, y cada descendiente de la clase <code>Shape</code> , desde la introducci贸n de un nuevo descendiente o de un cambio en la pol铆tica de pedidos para los objetos de la clase <code>Shape</code> dependiendo de su tipo (por ejemplo, los objetos de la clase <code>Squares</code> deber铆an ser dibujado primero). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  El 煤nico elemento que no est谩 cerrado al cambiar el orden de las formas de dibujo es una tabla.  La tabla se puede colocar en un m贸dulo separado, separado de todos los dem谩s m贸dulos y, por lo tanto, sus cambios no afectar谩n a otros m贸dulos. </p><br><h2>  Cierre adicional </h2><br><p>  Este no es el final de la historia.  Cerramos la jerarqu铆a de la clase <code>Shape</code> y la funci贸n <code>DrawAllShapes</code> de cambiar la pol铆tica de ordenamiento en funci贸n del tipo de formas.  Sin embargo, los descendientes de la clase <code>Shape</code> no est谩n excluidos de las pol铆ticas de pedido que no est谩n asociadas con los tipos de <code>Shape</code> .  Parece que necesitamos organizar el dibujo de formas de acuerdo con una estructura de nivel superior.  Un estudio completo de tales problemas est谩 m谩s all谩 del alcance de este art铆culo;  sin embargo, un lector interesado podr铆a pensar c贸mo resolver este problema utilizando la clase abstracta <code>OrderedObject</code> contenida en la clase <code>OrderedShape</code> , que hereda de las <code>OrderedObject</code> <code>Shape</code> y <code>OrderedObject</code> . </p><br><h1>  Heur铆stica y Convenciones </h1><br><p>  Como se mencion贸 al principio del art铆culo, el principio de apertura-cercan铆a es la motivaci贸n clave detr谩s de muchas heur铆sticas y convenciones que han surgido durante los a帽os de desarrollo del paradigma OOP.  Los siguientes son los m谩s importantes. </p><br><h2>  Hacer que todas las variables miembro sean privadas </h2><br><p>  Esta es una de las convenciones m谩s duraderas de la OLP.  Las variables miembro solo deben ser conocidas por los m茅todos de la clase en la que se definen.  Los miembros variables no deben ser conocidos por ninguna otra clase, incluidas las clases derivadas.  Por lo tanto, deben declararse con un modificador de acceso <code>private</code> , no <code>public</code> o <code>protected</code> . <br>  A la luz del principio de apertura-cercan铆a, la raz贸n de tal convenci贸n es comprensible.  Cuando las variables miembro de la clase cambian, cada funci贸n que depende de ellas debe cambiar.  Es decir, la funci贸n no est谩 cerrada por cambios en estas variables. </p><br><p>  En OOP, esperamos que los m茅todos de una clase no est茅n cerrados a los cambios en las variables que son miembros de esta clase.  Sin embargo, esperamos que cualquier otra clase, incluidas las subclases, est茅 cerrada por cambios en estas variables.  Esto se llama encapsulaci贸n. </p><br><p>  Pero, 驴qu茅 sucede si tiene una variable sobre la que est谩 seguro de que nunca cambiar谩?  驴Tiene sentido hacerlo <code>private</code> ?  Por ejemplo, el Listado 7 muestra la clase de <code>Device</code> que contiene el <code>bool status</code> miembro variable.  Almacena el estado de la 煤ltima operaci贸n.  Si la operaci贸n fue exitosa, entonces el valor de la variable de <code>status</code> ser谩 <code>true</code> , de lo contrario <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Sabemos que el tipo o significado de esta variable nunca cambiar谩.  Entonces, 驴por qu茅 no hacerlo <code>public</code> y darle acceso directo al cliente?  Si la variable realmente nunca cambia, si todos los clientes siguen las reglas y solo leen de esta variable, entonces no hay nada de malo en el hecho de que la variable es p煤blica.  Sin embargo, considere lo que suceder谩 si uno de los clientes aprovecha la oportunidad para escribir en esta variable y cambiar su valor. </p><br><p>  De repente, este cliente puede afectar el funcionamiento de cualquier otro cliente de la clase <code>Device</code> .  Esto significa que es imposible cerrar clientes de la clase <code>Device</code> por cambios en este m贸dulo incorrecto.  Esto es demasiado riesgo. </p><br><p>  Por otro lado, supongamos que tenemos la clase <code>Time</code> , que se muestra en el Listado 8. 驴Cu谩l es el peligro de la publicidad de las variables que son miembros de esta clase?  Es muy poco probable que cambien.  Adem谩s, no importa si los m贸dulos del cliente cambian los valores de estas variables o no, ya que se supone un cambio en estas variables.  Tambi茅n es muy poco probable que las clases heredadas puedan depender del valor de una variable miembro en particular.  Entonces, 驴hay un problema? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  La 煤nica queja que podr铆a hacerle al c贸digo en el Listado 8 es que el cambio de hora no es at贸mico.  Es decir, el cliente puede cambiar el valor de la variable <code>minutes</code> sin cambiar el valor de la variable <code>hours</code> .  Esto puede hacer que un objeto de la clase <code>Time</code> contenga datos inconsistentes.  Preferir铆a introducir una sola funci贸n para configurar el tiempo, que tomar铆a tres argumentos, lo que har铆a que configurar el tiempo sea una operaci贸n at贸mica.  Pero este es un argumento d茅bil. </p><br><p>  Es f谩cil encontrar otras condiciones bajo las cuales la publicidad de estas variables pueda generar problemas.  Sin embargo, en 煤ltima instancia, no hay una raz贸n convincente para hacerlos <code>private</code> .  Sigo pensando que hacer p煤blicas tales variables es un mal estilo, pero tal vez no sea un mal dise帽o.  Creo que este es un mal estilo, porque no cuesta casi nada ingresar a las funciones apropiadas para acceder a estos miembros, y definitivamente vale la pena protegerse del peque帽o riesgo asociado con la posible aparici贸n de problemas con el cierre. </p><br><p>  Por lo tanto, en casos tan raros, cuando no se viola el principio de apertura-cierre, la prohibici贸n de <code>public</code> variables <code>public</code> y <code>protected</code> depende m谩s del estilo y no del contenido. </p><br><h2>  No hay variables globales ... en absoluto! </h2><br><p>  El argumento contra las variables globales es el mismo que el argumento contra las variables de miembros p煤blicos.  Ning煤n m贸dulo que dependa de una variable global puede cerrarse desde un m贸dulo que pueda escribir en 茅l.  Cualquier m贸dulo que use esta variable de una manera no prevista por otros m贸dulos los romper谩.  Es demasiado arriesgado tener muchos m贸dulos, dependiendo de los caprichos de un solo m贸dulo malicioso. <br>  Por otro lado, en los casos en que las variables globales tienen una peque帽a cantidad de m贸dulos que dependen de ellos o no se pueden usar de manera incorrecta, no causan da帽o.  El dise帽ador debe evaluar cu谩nta privacidad se sacrifica y determinar si la conveniencia que brinda la variable global vale la pena. </p><br><p>  Aqu铆 nuevamente, los problemas de estilo entran en juego.  Las alternativas al uso de variables globales suelen ser de bajo costo.  En tales casos, el uso de una t茅cnica que introduce, aunque peque帽o, pero un riesgo de cierre en lugar de una t茅cnica que elimina por completo ese riesgo, es una se帽al de mal estilo.  Sin embargo, a veces usar variables globales es realmente conveniente.  Un ejemplo t铆pico son las variables globales cout y cin.  En tales casos, si no se viola el principio de apertura-cercan铆a, puede sacrificar el estilo por conveniencia. </p><br><h2>  RTTI es peligroso </h2><br><p>  Otra prohibici贸n com煤n es el uso de <code>dynamic_cast</code> .  Muy a menudo, <code>dynamic_cast</code> o alguna otra forma de determinaci贸n del tipo de tiempo de ejecuci贸n (RTTI) es acusado de ser una t茅cnica extremadamente peligrosa y, por lo tanto, debe evitarse.  Al mismo tiempo, a menudo dan un ejemplo del Listado 9, que obviamente viola el principio de apertura-cercan铆a.  Sin embargo, el Listado 10 muestra un ejemplo de un programa similar que usa <code>dynamic_cast</code> sin violar el principio de abrir-cerrar. </p><br><p>  La diferencia entre ellos es que, en el primer caso, que se muestra en el Listado 9, el c贸digo debe cambiarse cada vez que aparece un nuevo descendiente de la clase <code>Shape</code> (sin mencionar que esta es una soluci贸n absolutamente rid铆cula).  Sin embargo, en el Listado 10, no se requieren cambios en este caso.  Por lo tanto, el c贸digo en el Listado 10 no viola el principio de abrir-cerrar. <br>  En este caso, la regla general es que RTTI se puede usar si no se viola el principio de apertura-cierre. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Conclusi贸n </h1><br><p>  Podr铆a hablar durante mucho tiempo sobre el principio de apertura-cercan铆a.  En muchos sentidos, este principio es m谩s importante para la programaci贸n orientada a objetos.  El cumplimiento de este principio particular proporciona las ventajas clave de la tecnolog铆a orientada a objetos, a saber, reutilizaci贸n y soporte. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472186/">https://habr.com/ru/post/472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472174/index.html">Personalidad y sonido: Paul Voight - "Sennheiser 30s", el padre de la banda ancha, un crossover mec谩nico y l铆neas de transmisi贸n</a></li>
<li><a href="../472176/index.html">Museo virtual de Pushkin</a></li>
<li><a href="../472178/index.html">Holivar Historia de Runet. Parte 7. YouTube: comediantes, chillidos y Silicon Valley</a></li>
<li><a href="../472182/index.html">Anuncio de .NET Core 3.1 Preview 1</a></li>
<li><a href="../472184/index.html">SSH remoto: consejos y trucos</a></li>
<li><a href="../472188/index.html">Lo que necesita saber sobre la verificaci贸n de cheques de la tienda de aplicaciones (recibo de la tienda de aplicaciones)</a></li>
<li><a href="../472190/index.html">Ejecute scripts PHP a trav茅s de php-fpm sin un servidor web. O su cliente FastCGI (bajo el cap贸)</a></li>
<li><a href="../472196/index.html">"Sugar" hecho en casa para un proyecto de Android o "C贸mo no hacerlo"</a></li>
<li><a href="../472198/index.html">Localizaci贸n de mensajes push en aplicaciones m贸viles.</a></li>
<li><a href="../472200/index.html">Modernizaci贸n de la clase de inform谩tica en una escuela rusa sobre frambuesa: barata y alegre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>