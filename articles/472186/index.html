<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏻 🚠 🆔 Principio abierto-cerrado 🏇🏽 🧑🏻 👢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Aquí hay una traducción de un artículo de Robert Martin del Principio Abierto-Cerrado , que publicó en enero de 1996. El artículo, por deci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principio abierto-cerrado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Hola Habr!  Aquí hay una traducción de un artículo de Robert Martin del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20060822033314/">Principio Abierto-Cerrado</a> , que publicó en enero de 1996.  El artículo, por decirlo suavemente, no es el último.  Pero en RuNet, los artículos del tío Bob sobre SOLID se vuelven a contar solo en forma truncada, por lo que pensé que una traducción completa no sería superflua. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  Decidí comenzar con la letra O, ya que el principio de apertura-cierre, de hecho, es central.  Entre otras cosas, hay muchas sutilezas importantes a las que vale la pena prestarles atención: </p><br><ul><li>  Ningún programa puede ser "cerrado" al 100%. </li><li>  La programación orientada a objetos (OOP) opera no con objetos físicos del mundo real, sino con conceptos, por ejemplo, el concepto de "ordenar". <a name="habracut"></a></li></ul><br><p>  Este es el primer artículo en mi columna de <em>Notas del ingeniero</em> para <em>The C ++ Report</em> .  Los artículos publicados en esta columna se centrarán en el uso de C ++ y OOP y abordarán las dificultades en el desarrollo de software.  Intentaré hacer que los materiales sean pragmáticos y útiles para los ingenieros en ejercicio.  Para la documentación del diseño orientado a objetos en estos artículos, usaré la notación de Buch. </p><br><p>  Hay muchas heurísticas asociadas con la programación orientada a objetos.  Por ejemplo, "todas las variables miembro deben ser privadas", o "se deben evitar las variables globales", o "la determinación de tipo en tiempo de ejecución es peligrosa".  ¿Cuál es la razón de tales heurísticas?  ¿Por qué son verdad?  ¿Son <em>siempre</em> ciertas?  Esta columna explora el principio de diseño que subyace a estas heurísticas: el principio de apertura-cierre. <br>  Ivar Jacobson dijo: “Todos los sistemas cambian durante el ciclo de vida.  Esto debe tenerse en cuenta al diseñar un sistema que tenga más de una versión esperada ".  ¿Cómo podemos diseñar un sistema para que sea estable frente al cambio y que tenga más de una versión esperada?  Bertrand Meyer nos contó sobre esto en 1988, cuando se formuló el ahora famoso principio de apertura-cercanía: </p><br><p>  <strong>Las entidades del programa (clases, módulos, funciones, etc.) deben estar abiertas para expansión y cerradas para cambios.</strong> </p><br><p>  Si un cambio en el programa implica una cascada de cambios en los módulos dependientes, entonces aparecen signos indeseables de un diseño "malo" en el programa. </p><br><p>  El programa se vuelve frágil, inflexible, impredecible y sin uso.  El principio de apertura-cercanía resuelve estos problemas de una manera muy directa.  Él dice que es necesario diseñar módulos que nunca <em>cambien</em> .  Cuando los requisitos cambian, debe expandir el comportamiento de dichos módulos agregando un código nuevo, en lugar de cambiar el código antiguo que ya funciona. </p><br><h1>  Descripción </h1><br><p>  Los módulos que cumplen con el principio de apertura-cercanía tienen dos características principales: </p><br><ol><li> <strong>Abierto a la expansión.</strong>  Esto significa que el comportamiento del módulo se puede ampliar.  Es decir, podemos agregar un nuevo comportamiento al módulo de acuerdo con los requisitos cambiantes para la aplicación o para satisfacer las necesidades de las nuevas aplicaciones. </li><li>  <strong>Cerrado por cambio.</strong>  El código fuente de dicho módulo es intocable.  Nadie tiene derecho a hacerle cambios. </li></ol><br><p>  Parece que estos dos signos no encajan entre sí.  La forma estándar de extender el comportamiento de un módulo es hacer cambios en él.  Un módulo que no se puede cambiar generalmente se considera un módulo con comportamiento fijo.  ¿Cómo se pueden cumplir estas dos condiciones opuestas? </p><br><h1>  La clave de la solución es la abstracción. </h1><br><p>  En C ++, utilizando los principios del diseño orientado a objetos, es posible crear abstracciones fijas que pueden representar un conjunto ilimitado de posibles comportamientos. </p><br><p>  Las abstracciones son clases base abstractas, y todas las posibles clases sucesoras representan un conjunto ilimitado de posibles comportamientos.  Un módulo puede manipular la abstracción.  Dicho módulo está cerrado por cambios, ya que depende de una abstracción fija.  Además, el comportamiento del módulo se puede ampliar creando nuevos descendientes de abstracción. </p><br><p> El siguiente diagrama muestra una opción de diseño simple que no cumple con el principio de apertura-cercanía.  Ambas clases, <code>Client</code> y <code>Server</code> , no son abstractas.  No hay garantía de que las funciones que son miembros de la clase <code>Server</code> sean virtuales.  La clase <code>Client</code> usa la clase <code>Server</code> .  Si queremos que el objeto de la clase <code>Client</code> use un objeto de servidor diferente, debemos cambiar la clase <code>Client</code> para hacer referencia a la nueva clase de servidor. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="imagen"><br>  <em>Cliente cerrado</em> </p><br><p>  Y el siguiente diagrama muestra la opción de diseño correspondiente, que cumple con el principio de apertura-cercanía.  En este caso, la clase <code>AbstractServer</code> es una clase abstracta, cuyas funciones miembro son virtuales.  La clase <code>Client</code> usa abstracción.  Sin embargo, los objetos de la clase <code>Client</code> utilizarán objetos de la clase sucesora del <code>Server</code> .  Si queremos que los objetos de la clase <code>Client</code> utilicen una clase de servidor diferente, presentaremos un nuevo descendiente de la clase <code>AbstractServer</code> .  La clase del <code>Client</code> permanecerá sin cambios. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="imagen"><br>  <em>Cliente abierto</em> </p><br><h1>  Resumen de <code>Shape</code> </h1><br><p>  Considere una aplicación que debería dibujar círculos y cuadrados en una GUI estándar.  Los círculos y cuadrados se deben dibujar en un orden específico.  En el orden correspondiente, se compilará una lista de círculos y cuadrados, el programa debe revisar esta lista en el orden y dibujar cada círculo o cuadrado. </p><br><p>  En C, utilizando técnicas de programación de procedimientos que no cumplen con el principio de apertura y cierre, podríamos resolver este problema como se muestra en el Listado 1. Aquí vemos muchas estructuras de datos con el mismo primer elemento.  Este elemento es un código de tipo que identifica la estructura de datos como un círculo o cuadrado.  La función <code>DrawAllShapes</code> pasa a través de una matriz de punteros a estas estructuras de datos, reconociendo el código de tipo y luego llamando a la función correspondiente ( <code>DrawCircle</code> o <code>DrawSquare</code> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  La función <code>DrawAllShapes</code> no cumple el principio de apertura-cierre, ya que no se puede "cerrar" a partir de nuevos tipos de formas.  Si quisiera expandir esta función con la capacidad de dibujar formas de una lista que incluye triángulos, entonces necesitaría cambiar la función.  De hecho, tengo que cambiar la función para cada nuevo tipo de forma que necesito dibujar. </p><br><p>  Por supuesto, este programa es solo un ejemplo.  En la vida real, el operador del <code>switch</code> de la función <code>DrawAllShapes</code> se repetiría una y otra vez en varias funciones a lo largo de la aplicación, y cada una haría algo diferente.  Agregar nuevas formas a una aplicación de este tipo significa encontrar todos los lugares donde se usan tales <code>switch</code> (o cadenas <code>if/else</code> ) y agregar una nueva forma a cada una de ellas.  Además, es muy poco probable que todas las <code>switch</code> y las cadenas <code>if/else</code> estén tan bien estructuradas como en <code>DrawAllShapes</code> .  Es mucho más probable que los predicados en <code>if</code> se combinen con operadores lógicos, o los bloques de <code>case</code> y <code>case</code> de las <code>switch</code> de <code>switch</code> se combinen de tal manera que "simplifiquen" un lugar particular en el código.  Por lo tanto, el problema de encontrar y comprender todos los lugares donde necesita agregar una nueva figura no puede ser trivial. </p><br><p>  En el Listado 2, mostraré el código que demuestra una solución cuadrada / circular que cumple con el principio de apertura-cierre.  Se introduce una clase de <code>Shape</code> abstracta.  Esta clase abstracta contiene una función de <code>Draw</code> virtual pura.  Las clases <code>Circle</code> y <code>Square</code> son descendientes de la clase <code>Shape</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Tenga en cuenta que si queremos extender el comportamiento de la función <code>DrawAllShapes</code> en el Listado 2 para dibujar un nuevo tipo de forma, todo lo que tenemos que hacer es agregar un nuevo descendiente de la clase <code>Shape</code> .  No es necesario cambiar la función <code>DrawAllShapes</code> .  Por lo tanto, <code>DrawAllShapes</code> cumple con el principio de apertura-cercanía.  Su comportamiento se puede ampliar sin cambiar la función en sí. </p><br><p>  En el mundo real, la clase <code>Shape</code> contendría muchos otros métodos.  Y, sin embargo, agregar una nueva forma a la aplicación sigue siendo muy simple, ya que todo lo que necesita hacer es ingresar un nuevo heredero e implementar estas funciones.  No es necesario explorar toda la aplicación en busca de lugares que requieran cambios. </p><br><p>  Por lo tanto, los programas que cumplen con el principio de apertura-cercanía se cambian agregando un nuevo código, y no cambiando el existente; no cambian en cascada los cambios característicos de los programas que no corresponden a este principio. </p><br><h1>  Estrategia de entrada cerrada </h1><br><p>  Obviamente, ningún programa puede estar 100% cerrado.  Por ejemplo, ¿qué le sucede a la función <code>DrawAllShapes</code> en el Listado 2 si decidimos que primero deben dibujarse círculos y luego cuadrados?  La función <code>DrawAllShapes</code> no <code>DrawAllShapes</code> cerrada por este tipo de cambio.  En general, no importa cuán "cerrado" esté el módulo, siempre hay algún tipo de cambio desde el cual no está cerrado. </p><br><p>  Como el cierre no puede ser completo, debe ser introducido estratégicamente.  Es decir, el diseñador debe elegir los tipos de cambios a partir de los cuales se cerrará el programa.  Esto requiere algo de experiencia.  Un desarrollador experimentado conoce a los usuarios y la industria lo suficientemente bien como para calcular la probabilidad de varios cambios.  Luego se asegura de que se respete el principio de apertura-cercanía para los cambios más probables. </p><br><h2>  Uso de la abstracción para lograr una cercanía adicional. </h2><br><p>  ¿Cómo podemos cerrar la función <code>DrawAllShapes</code> de los cambios en el orden de dibujo?  Recuerde que el cierre se basa en la abstracción.  Por lo tanto, para cerrar <code>DrawAllShapes</code> del pedido, necesitamos algún tipo de "abstracción de pedido".  Un caso especial de pedido, presentado anteriormente, es dibujar figuras de un tipo frente a figuras de otro tipo. </p><br><p>  La política de pedidos implica que con dos objetos, puede determinar cuál debe dibujarse primero.  Por lo tanto, podemos definir un método para la clase <code>Shape</code> llamado <code>Precedes</code> , que toma otro objeto <code>Shape</code> como argumento y devuelve un valor booleano <code>true</code> si el objeto <code>Shape</code> que recibió este mensaje necesita ser ordenado antes que el objeto <code>Shape</code> que fue Pasado como argumento. </p><br><p>  En C ++, esta función se puede representar como una sobrecarga del operador "&lt;".  El Listado 3 muestra la clase <code>Shape</code> con métodos de clasificación. </p><br><p>  Ahora que tenemos una manera de determinar el orden de los objetos de la clase <code>Shape</code> , podemos ordenarlos y luego dibujarlos.  El Listado 4 muestra el código C ++ correspondiente.  Utiliza las clases <code>Set</code> , <code>OrderedSet</code> e <code>OrderedSet</code> de la categoría <code>Components</code> desarrollada en mi libro (Diseño de aplicaciones C ++ orientadas a objetos utilizando el método Booch, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Entonces, hemos implementado el orden de los objetos de la clase <code>Shape</code> y dibujándolos en el orden apropiado.  Pero todavía no tenemos una implementación de la abstracción del orden.  Obviamente, cada objeto <code>Shape</code> debe anular el método <code>Precedes</code> para determinar el orden.  ¿Cómo puede funcionar esto?  ¿Qué código se debe escribir en <code>Circle::Precedes</code> para que los círculos se dibujen en cuadrados?  Presta atención al listado 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  Está claro que esta función no cumple con el principio de apertura-cercanía.  No hay forma de cerrarlo de los nuevos descendientes de la clase <code>Shape</code> .  Cada vez que aparece un nuevo descendiente de la clase <code>Shape</code> , esta función debe cambiarse. </p><br><h2>  Uso de un enfoque basado en datos para lograr el cierre </h2><br><p>  La cercanía de los herederos de la clase <code>Shape</code> se puede lograr utilizando un enfoque tabular que no provoca cambios en cada clase heredada.  Un ejemplo de este enfoque se muestra en el Listado 6. </p><br><p>  Usando este enfoque, cerramos con éxito la función <code>DrawAllShapes</code> de los cambios relacionados con el pedido, y cada descendiente de la clase <code>Shape</code> , desde la introducción de un nuevo descendiente o de un cambio en la política de pedidos para los objetos de la clase <code>Shape</code> dependiendo de su tipo (por ejemplo, los objetos de la clase <code>Squares</code> deberían ser dibujado primero). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  El único elemento que no está cerrado al cambiar el orden de las formas de dibujo es una tabla.  La tabla se puede colocar en un módulo separado, separado de todos los demás módulos y, por lo tanto, sus cambios no afectarán a otros módulos. </p><br><h2>  Cierre adicional </h2><br><p>  Este no es el final de la historia.  Cerramos la jerarquía de la clase <code>Shape</code> y la función <code>DrawAllShapes</code> de cambiar la política de ordenamiento en función del tipo de formas.  Sin embargo, los descendientes de la clase <code>Shape</code> no están excluidos de las políticas de pedido que no están asociadas con los tipos de <code>Shape</code> .  Parece que necesitamos organizar el dibujo de formas de acuerdo con una estructura de nivel superior.  Un estudio completo de tales problemas está más allá del alcance de este artículo;  sin embargo, un lector interesado podría pensar cómo resolver este problema utilizando la clase abstracta <code>OrderedObject</code> contenida en la clase <code>OrderedShape</code> , que hereda de las <code>OrderedObject</code> <code>Shape</code> y <code>OrderedObject</code> . </p><br><h1>  Heurística y Convenciones </h1><br><p>  Como se mencionó al principio del artículo, el principio de apertura-cercanía es la motivación clave detrás de muchas heurísticas y convenciones que han surgido durante los años de desarrollo del paradigma OOP.  Los siguientes son los más importantes. </p><br><h2>  Hacer que todas las variables miembro sean privadas </h2><br><p>  Esta es una de las convenciones más duraderas de la OLP.  Las variables miembro solo deben ser conocidas por los métodos de la clase en la que se definen.  Los miembros variables no deben ser conocidos por ninguna otra clase, incluidas las clases derivadas.  Por lo tanto, deben declararse con un modificador de acceso <code>private</code> , no <code>public</code> o <code>protected</code> . <br>  A la luz del principio de apertura-cercanía, la razón de tal convención es comprensible.  Cuando las variables miembro de la clase cambian, cada función que depende de ellas debe cambiar.  Es decir, la función no está cerrada por cambios en estas variables. </p><br><p>  En OOP, esperamos que los métodos de una clase no estén cerrados a los cambios en las variables que son miembros de esta clase.  Sin embargo, esperamos que cualquier otra clase, incluidas las subclases, esté cerrada por cambios en estas variables.  Esto se llama encapsulación. </p><br><p>  Pero, ¿qué sucede si tiene una variable sobre la que está seguro de que nunca cambiará?  ¿Tiene sentido hacerlo <code>private</code> ?  Por ejemplo, el Listado 7 muestra la clase de <code>Device</code> que contiene el <code>bool status</code> miembro variable.  Almacena el estado de la última operación.  Si la operación fue exitosa, entonces el valor de la variable de <code>status</code> será <code>true</code> , de lo contrario <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Sabemos que el tipo o significado de esta variable nunca cambiará.  Entonces, ¿por qué no hacerlo <code>public</code> y darle acceso directo al cliente?  Si la variable realmente nunca cambia, si todos los clientes siguen las reglas y solo leen de esta variable, entonces no hay nada de malo en el hecho de que la variable es pública.  Sin embargo, considere lo que sucederá si uno de los clientes aprovecha la oportunidad para escribir en esta variable y cambiar su valor. </p><br><p>  De repente, este cliente puede afectar el funcionamiento de cualquier otro cliente de la clase <code>Device</code> .  Esto significa que es imposible cerrar clientes de la clase <code>Device</code> por cambios en este módulo incorrecto.  Esto es demasiado riesgo. </p><br><p>  Por otro lado, supongamos que tenemos la clase <code>Time</code> , que se muestra en el Listado 8. ¿Cuál es el peligro de la publicidad de las variables que son miembros de esta clase?  Es muy poco probable que cambien.  Además, no importa si los módulos del cliente cambian los valores de estas variables o no, ya que se supone un cambio en estas variables.  También es muy poco probable que las clases heredadas puedan depender del valor de una variable miembro en particular.  Entonces, ¿hay un problema? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  La única queja que podría hacerle al código en el Listado 8 es que el cambio de hora no es atómico.  Es decir, el cliente puede cambiar el valor de la variable <code>minutes</code> sin cambiar el valor de la variable <code>hours</code> .  Esto puede hacer que un objeto de la clase <code>Time</code> contenga datos inconsistentes.  Preferiría introducir una sola función para configurar el tiempo, que tomaría tres argumentos, lo que haría que configurar el tiempo sea una operación atómica.  Pero este es un argumento débil. </p><br><p>  Es fácil encontrar otras condiciones bajo las cuales la publicidad de estas variables pueda generar problemas.  Sin embargo, en última instancia, no hay una razón convincente para hacerlos <code>private</code> .  Sigo pensando que hacer públicas tales variables es un mal estilo, pero tal vez no sea un mal diseño.  Creo que este es un mal estilo, porque no cuesta casi nada ingresar a las funciones apropiadas para acceder a estos miembros, y definitivamente vale la pena protegerse del pequeño riesgo asociado con la posible aparición de problemas con el cierre. </p><br><p>  Por lo tanto, en casos tan raros, cuando no se viola el principio de apertura-cierre, la prohibición de <code>public</code> variables <code>public</code> y <code>protected</code> depende más del estilo y no del contenido. </p><br><h2>  No hay variables globales ... en absoluto! </h2><br><p>  El argumento contra las variables globales es el mismo que el argumento contra las variables de miembros públicos.  Ningún módulo que dependa de una variable global puede cerrarse desde un módulo que pueda escribir en él.  Cualquier módulo que use esta variable de una manera no prevista por otros módulos los romperá.  Es demasiado arriesgado tener muchos módulos, dependiendo de los caprichos de un solo módulo malicioso. <br>  Por otro lado, en los casos en que las variables globales tienen una pequeña cantidad de módulos que dependen de ellos o no se pueden usar de manera incorrecta, no causan daño.  El diseñador debe evaluar cuánta privacidad se sacrifica y determinar si la conveniencia que brinda la variable global vale la pena. </p><br><p>  Aquí nuevamente, los problemas de estilo entran en juego.  Las alternativas al uso de variables globales suelen ser de bajo costo.  En tales casos, el uso de una técnica que introduce, aunque pequeño, pero un riesgo de cierre en lugar de una técnica que elimina por completo ese riesgo, es una señal de mal estilo.  Sin embargo, a veces usar variables globales es realmente conveniente.  Un ejemplo típico son las variables globales cout y cin.  En tales casos, si no se viola el principio de apertura-cercanía, puede sacrificar el estilo por conveniencia. </p><br><h2>  RTTI es peligroso </h2><br><p>  Otra prohibición común es el uso de <code>dynamic_cast</code> .  Muy a menudo, <code>dynamic_cast</code> o alguna otra forma de determinación del tipo de tiempo de ejecución (RTTI) es acusado de ser una técnica extremadamente peligrosa y, por lo tanto, debe evitarse.  Al mismo tiempo, a menudo dan un ejemplo del Listado 9, que obviamente viola el principio de apertura-cercanía.  Sin embargo, el Listado 10 muestra un ejemplo de un programa similar que usa <code>dynamic_cast</code> sin violar el principio de abrir-cerrar. </p><br><p>  La diferencia entre ellos es que, en el primer caso, que se muestra en el Listado 9, el código debe cambiarse cada vez que aparece un nuevo descendiente de la clase <code>Shape</code> (sin mencionar que esta es una solución absolutamente ridícula).  Sin embargo, en el Listado 10, no se requieren cambios en este caso.  Por lo tanto, el código en el Listado 10 no viola el principio de abrir-cerrar. <br>  En este caso, la regla general es que RTTI se puede usar si no se viola el principio de apertura-cierre. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Conclusión </h1><br><p>  Podría hablar durante mucho tiempo sobre el principio de apertura-cercanía.  En muchos sentidos, este principio es más importante para la programación orientada a objetos.  El cumplimiento de este principio particular proporciona las ventajas clave de la tecnología orientada a objetos, a saber, reutilización y soporte. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472186/">https://habr.com/ru/post/472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472174/index.html">Personalidad y sonido: Paul Voight - "Sennheiser 30s", el padre de la banda ancha, un crossover mecánico y líneas de transmisión</a></li>
<li><a href="../472176/index.html">Museo virtual de Pushkin</a></li>
<li><a href="../472178/index.html">Holivar Historia de Runet. Parte 7. YouTube: comediantes, chillidos y Silicon Valley</a></li>
<li><a href="../472182/index.html">Anuncio de .NET Core 3.1 Preview 1</a></li>
<li><a href="../472184/index.html">SSH remoto: consejos y trucos</a></li>
<li><a href="../472188/index.html">Lo que necesita saber sobre la verificación de cheques de la tienda de aplicaciones (recibo de la tienda de aplicaciones)</a></li>
<li><a href="../472190/index.html">Ejecute scripts PHP a través de php-fpm sin un servidor web. O su cliente FastCGI (bajo el capó)</a></li>
<li><a href="../472196/index.html">"Sugar" hecho en casa para un proyecto de Android o "Cómo no hacerlo"</a></li>
<li><a href="../472198/index.html">Localización de mensajes push en aplicaciones móviles.</a></li>
<li><a href="../472200/index.html">Modernización de la clase de informática en una escuela rusa sobre frambuesa: barata y alegre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>