<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔑 🚎 📝 Kubernetes Operator-Entwicklung mit Operator Framework 🙂 📌 🤷🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie im Artikel über Radartechnologie erwähnt, bewegt sich Lamoda aktiv in Richtung Microservice-Architektur. Die meisten unserer Dienste werden mit He...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Operator-Entwicklung mit Operator Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/446648/"><p><img src="https://habrastorage.org/getpro/habr/post_images/352/5c8/f16/3525c8f16510afa2b61b0ff9b8434a02.png" alt="Bild"></p><br><p>  Wie im Artikel über Radartechnologie erwähnt, bewegt sich Lamoda aktiv in Richtung Microservice-Architektur.  Die meisten unserer Dienste werden mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm</a> verpackt und auf Kubernetes bereitgestellt.  Dieser Ansatz entspricht in 99% der Fälle voll und ganz unseren Anforderungen.  1% verbleibt, wenn die Standardfunktionalität von Kubernetes nicht ausreicht, z. B. wenn Sie eine Sicherung konfigurieren oder einen Dienst für ein bestimmtes Ereignis aktualisieren müssen.  Um dieses Problem zu lösen, verwenden wir das Operatormuster.  In dieser Artikelserie werde ich - Grigory Mikhalkin, der Entwickler des Forschungs- und Entwicklungsteams bei Lamoda - über die Lehren sprechen, die ich aus meinen Erfahrungen bei der Entwicklung von K8-Operatoren mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator Framework gezogen habe</a> . </p><a name="habracut"></a><br><h2 id="chto-takoe-operator">  Was ist ein Operator? </h2><br><p>  Eine Möglichkeit, die Kubernetes-Funktionalität zu erweitern, besteht darin, eigene Controller zu erstellen.  Die Hauptabstraktionen in Kubernetes sind Objekte und Controller.  Objekte beschreiben den gewünschten Status des Clusters.  Ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pod</a> beschreibt beispielsweise, welche Container gestartet und welche Parameter gestartet werden müssen, und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReplicaSet-</a> Objekt gibt an, wie viele Replikate eines bestimmten Pod gestartet werden müssen.  Die Controller steuern den Status des Clusters basierend auf der Beschreibung der Objekte. In dem oben beschriebenen Fall unterstützt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReplicationController</a> die Anzahl der im ReplicaSet angegebenen Pod-Replikate.  Mithilfe neuer Controller können Sie zusätzliche Logik implementieren, z. B. das Senden von Benachrichtigungen für Ereignisse, die Wiederherstellung nach einem Fehler oder die Verwaltung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ressourcen Dritter</a> . </p><br><p> Ein Operator ist eine Kubernetes-Anwendung, die einen oder mehrere Controller enthält, die eine Ressource eines Drittanbieters bedienen.  Das Konzept wurde 2016 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vom CoreOS-Team erfunden. In</a> letzter Zeit hat die Beliebtheit von Betreibern rapide zugenommen.  Sie können versuchen, den gewünschten Operator in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste auf kubedex</a> (hier sind mehr als 100 öffentlich verfügbare Operatoren aufgeführt) sowie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OperatorHub zu finden</a> .  Es gibt 3 beliebte Tools für die Operatorentwicklung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubebuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator SDK</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Metacontroller</a> .  In Lamoda verwenden wir das Operator SDK, daher werden wir später darüber sprechen. </p><br><h2 id="operator-sdk">  Operator SDK </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7e/56d/194/f7e56d1948a2f5291ef189e7a03df9be.png" alt="Bild"></p><br><p>  Das Operator SDK ist Teil des Operator Frameworks, das zwei weitere wichtige Teile enthält: Operator Lifecycle Manager und Operator Metering. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Operator SDK</a> ist ein Wrapper für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Controller-Laufzeit</a> , eine beliebte Bibliothek für die Entwicklung von Controllern (die wiederum ein Wrapper für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client-Go ist</a> ), ein Codegenerator + Framework zum Schreiben von E2E-Tests. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator Lifecycle Manager</a> - ein Framework für die Verwaltung vorhandener Operatoren;  Behebt Situationen, in denen der Bediener in den Zombie-Modus wechselt oder eine neue Version eingeführt wird. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedienermessung</a> - Wie der Name schon sagt, werden Daten zur Arbeit des Bedieners erfasst und basierend darauf können auch Berichte erstellt werden. </li></ul><br><h2 id="sozdanie-novogo-proekta">  Erstellen Sie ein neues Projekt </h2><br><p>  Ein Beispiel ist ein Operator, der eine Datei mit Konfigurationen im Repository überwacht und bei Aktualisierung die Bereitstellung des Dienstes mit neuen Konfigurationen neu startet.  Den vollständigen Beispielcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4c0/e84/ebc/4c0e84ebcba8cad49b2bea8506f79d32.png" alt="Bild"></p><br><p>  Erstellen Sie ein Projekt mit einem neuen Operator: </p><br><pre><code class="plaintext hljs">operator-sdk new config-monitor</code> </pre> <br><p>  Der Codegenerator erstellt Code für den Operator, der im zugewiesenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namespace arbeitet</a> .  Dieser Ansatz ist dem Zugriff auf den gesamten Cluster vorzuziehen, da im Fehlerfall die Probleme innerhalb desselben Namespace isoliert werden.  Der <code>cluster-wide</code> Operator kann durch Hinzufügen von <code>--cluster-scoped</code> generiert werden.  Die folgenden Verzeichnisse befinden sich im erstellten Projekt: </p><br><ul><li>  cmd - enthält das <code>main package</code> , in dem <code>Manager</code> initialisiert und gestartet wird; </li><li>  deploy - enthält Deklarationen des Operators, der CRD und der Objekte, die zum Einrichten des RBAC-Operators erforderlich sind. </li><li>  pkg - hier ist unser Hauptcode für neue Objekte und Controller. </li></ul><br><p>  Es gibt nur eine <a href=""><code>cmd/manager/main.go</code></a> Datei in <a href=""><code>cmd/manager/main.go</code></a> . </p><br><div class="spoiler">  <b class="spoiler_title">Code-Snippet</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// Become the leader before proceeding err = leader.Become(ctx, "config-monitor-lock") if err != nil { log.Error(err, "") os.Exit(1) } // Create a new Cmd to provide shared dependencies and start components mgr, err := manager.New(cfg, manager.Options{ Namespace: namespace, MetricsBindAddress: fmt.Sprintf("%s:%d", metricsHost, metricsPort), }) ... // Setup Scheme for all resources if err := apis.AddToScheme(mgr.GetScheme()); err != nil { log.Error(err, "") os.Exit(1) } // Setup all Controllers if err := controller.AddToManager(mgr); err != nil { log.Error(err, "") os.Exit(1) } ... // Start the Cmd if err := mgr.Start(signals.SetupSignalHandler()); err != nil { log.Error(err, "Manager exited non-zero") os.Exit(1) }</code> </pre> </div></div><br><p>  In der ersten Zeile: <code>err = leader.Become(ctx, "config-monitor-lock")</code> - ein Leader wird ausgewählt.  In den meisten Szenarien wird nur eine aktive Instanz einer Anweisung für Namespace / Cluster benötigt.  Standardmäßig verwendet das Operator SDK die <a href="">Leader for Life-</a> Strategie. Die erste gestartete Instanz des Operators bleibt der Leader, bis sie aus dem Cluster entfernt wird. </p><br><p>  Nachdem diese Operatorinstanz zum Leader ernannt wurde, wird ein neuer <code>Manager</code> initialisiert - <code>mgr, err := manager.New(...)</code> .  Zu seinen Aufgaben gehören: </p><br><ul><li>  <code>err := apis.AddToScheme(mgr.GetScheme())</code> - Registrierung neuer Ressourcenschemata; </li><li>  <code>err := controller.AddToManager(mgr)</code> - Registrierung von Controllern; </li><li>  <code>err := mgr.Start(signals.SetupSignalHandler())</code> - Starten und Steuern der Controller. </li></ul><br><p>  Im Moment haben wir weder neue Ressourcen noch Controller für die Registrierung.  Sie können eine neue Ressource mit dem folgenden Befehl hinzufügen: </p><br><pre> <code class="plaintext hljs">operator-sdk add api --api-version=services.example.com/v1alpha1 --kind=MonitoredService</code> </pre> <br><p>  Dieser Befehl fügt die Definition des <code>MonitoredService</code> Ressourcenschemas zum Verzeichnis <code>pkg/apis</code> sowie yaml mit der <code>CRD</code> Definition in <code>deploy/crds</code> .  Von allen generierten Dateien sollten Sie nur die Schemadefinition in <a href=""><code>monitoredservice_types.go</code></a> manuell ändern.  Der Typ <code>MonitoredServiceSpec</code> definiert den gewünschten Status der Ressource: Was der Benutzer in yaml mit der Definition der Ressource angibt.  Im Kontext unseres Operators bestimmt das Feld <code>Size</code> die gewünschte Anzahl von Replikaten. <code>ConfigRepo</code> gibt an, woher die aktuellen Konfigurationen abgerufen werden können.  <code>MonitoredServiceStatus</code> ermittelt den beobachteten Status der Ressource. Beispielsweise werden die Namen der zu dieser Ressource gehörenden Pods und die aktuellen <code>spec</code> Pods gespeichert. </p><br><p>  Nach dem Bearbeiten des Schemas müssen Sie den folgenden Befehl ausführen: </p><br><pre> <code class="plaintext hljs">operator-sdk generate k8s</code> </pre> <br><p>  Die <code>CRD</code> Definition in <code>deploy/crds</code> wird aktualisiert. </p><br><p>  Erstellen wir nun den Hauptteil unseres Operators, den Controller: </p><br><pre> <code class="plaintext hljs">operator-sdk add controller --api-version=services.example.com/v1alpha1 --kind=Monitor</code> </pre> <br><p>  Die Datei <a href=""><code>monitor_controller.go</code></a> wird im <a href=""><code>monitor_controller.go</code></a> <code>pkg/controller</code> <a href=""><code>monitor_controller.go</code></a> , in das wir die benötigte Logik <a href=""><code>monitor_controller.go</code></a> . </p><br><h2 id="razrabotka-kontrollera">  Controller-Entwicklung </h2><br><p>  Die Steuerung ist die Hauptarbeitseinheit des Bedieners.  In unserem Fall gibt es zwei Controller: </p><br><ul><li>  Monitor Controller überwacht Änderungen der Servicekonfiguration. </li><li>  Der Upgrade-Controller aktualisiert den Dienst und hält ihn im gewünschten Zustand. </li></ul><br><p>  Im Kern ist der Controller ein Regelkreis, er überwacht die Warteschlange mit den Ereignissen, die er abonniert hat, und verarbeitet sie: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/220/2e6/a09/2202e6a0931df3e5b87c4442dd839615.png" alt="Bild"></p><br><p>  Ein neuer Controller wird vom Manager in der <code>add</code> Methode erstellt und registriert: </p><br><pre> <code class="plaintext hljs">c, err := controller.New("monitor-controller", mgr, controller.Options{Reconciler: r})</code> </pre> <br><p>  Mit der <code>Watch</code> Methode abonnieren wir Ereignisse bezüglich der Erstellung einer neuen Ressource oder der <code>Spec</code> einer vorhandenen <code>MonitoredService</code> Ressource: </p><br><pre> <code class="plaintext hljs">err = c.Watch(&amp;source.Kind{Type: &amp;servicesv1alpha1.MonitoredService{}}, &amp;handler.EnqueueRequestForObject{}, common.CreateOrUpdateSpecPredicate)</code> </pre> <br><p>  Der Ereignistyp kann mithilfe der Parameter <code>src</code> und <code>predicates</code> konfiguriert werden.  <code>src</code> akzeptiert Objekte vom Typ <code>Source</code> . </p><br><ul><li>  <code>Informer</code> - fragt den <code>apiserver</code> nach Ereignissen ab, die mit dem Filter übereinstimmen. Wenn ein solches Ereignis <code>apiserver</code> , wird es in die Warteschlange des Controllers gestellt.  In der <code>controller-runtime</code> dies ein Wrapper über den <code>SharedIndexInformer</code> von <code>client-go</code> . </li><li>  <code>Kind</code> ist auch ein Wrapper über <code>SharedIndexInformer</code> , erstellt jedoch im Gegensatz zu <code>Informer</code> unabhängig eine Informer-Instanz basierend auf den übergebenen Parametern (Schema der überwachten Ressource). </li><li>  <code>Channel</code> - akzeptiert <code>chan event.GenericEvent</code> als Parameter, die durch ihn kommenden Ereignisse werden in die Warteschlange des Controllers gestellt. </li></ul><br><p>  <code>redicates</code> erwarten Objekte, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Predicate</code></a> erfüllen.  Tatsächlich ist dies ein zusätzlicher Filter für Ereignisse. <code>UpdateEvent</code> Sie beispielsweise <code>UpdateEvent</code> filtern <code>UpdateEvent</code> können Sie genau sehen, welche Änderungen in der Ressourcenspezifikation vorgenommen wurden. </p><br><p>  Wenn ein Ereignis eintrifft, akzeptiert es ein <code>EventHandler</code> - das zweite Argument der <code>Watch</code> Methode -, das das Ereignis in das vom <code>Reconciler</code> erwartete Anforderungsformat <code>EventHandler</code> : </p><br><ul><li>  <code>EnqueueRequestForObject</code> - <code>EnqueueRequestForObject</code> eine Anforderung mit dem Namen und dem Namespace des Objekts, das das Ereignis verursacht hat. </li><li>  <code>EnqueueRequestForOwner</code> - <code>EnqueueRequestForOwner</code> eine Anforderung mit den Daten des übergeordneten Objekts.  Dies ist beispielsweise erforderlich, wenn der ressourcengesteuerte <code>Pod</code> gelöscht wurde und Sie mit dem Ersetzen beginnen müssen. </li><li>  <code>EnqueueRequestsFromMapFunc</code> - verwendet als Parameter die <code>map</code> Funktion, die ein Ereignis empfängt (in <code>MapObject</code> ) und eine Liste von Anforderungen zurückgibt.  <a href="">Ein Beispiel, wenn dieser Handler benötigt wird</a> - es gibt einen Timer, für den Sie für jeden Tick neue Konfigurationen für alle verfügbaren Dienste abrufen müssen. </li></ul><br><p>  Anforderungen werden in die Controller-Warteschlange gestellt, und einer der Worker (standardmäßig hat der Controller eine) zieht das Ereignis aus der Warteschlange und übergibt es an <code>Reconciler</code> . </p><br><p>  <strong>Reconciler</strong> implementiert nur eine Methode - <code>Reconcile</code> , die die grundlegende Logik der Ereignisverarbeitung enthält: </p><br><div class="spoiler">  <b class="spoiler_title">Methode abgleichen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">func (r *ReconcileMonitor) Reconcile(request reconcile.Request) (reconcile.Result, error) { reqLogger := log.WithValues("Request.Namespace", request.Namespace, "Request.Name", request.Name) reqLogger.Info("Checking updates in repo for MonitoredService") // fetch the Monitor instance instance := &amp;servicesv1alpha1.MonitoredService{} err := r.client.Get(context.Background(), request.NamespacedName, instance) if err != nil { if errors.IsNotFound(err) { // Request object not found, could have been deleted after reconcile request. // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers. // Return and don't requeue return reconcile.Result{}, nil } // Error reading the object - requeue the request. return reconcile.Result{}, err } // check if service's config was updated // if it was, send event to upgrade controller if podSpec, ok := r.isServiceConfigUpdated(instance); ok { // Update instance Spec instance.Status.PodSpec = *podSpec instance.Status.ConfigChanged = true err = r.client.Status().Update(context.Background(), instance) if err != nil { reqLogger.Error(err, "Failed to update service status", "Service.Namespace", instance.Namespace, "Service.Name", instance.Name) return reconcile.Result{}, err } r.eventsChan &lt;- event.GenericEvent{Meta: &amp;servicesv1alpha1.MonitoredService{}, Object: instance} } return reconcile.Result{}, nil }</code> </pre> </div></div><br><p>  Die Methode akzeptiert ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Request</code></a> mit dem Feld <code>NamespacedName</code> , mit dem die Ressource aus dem Cache <code>r.client.Get(context.TODO(), request.NamespacedName, instance)</code> kann: <code>r.client.Get(context.TODO(), request.NamespacedName, instance)</code> .  In diesem Beispiel wird eine Anforderung an die Datei mit der Dienstkonfiguration gestellt, auf die <code>ConfigRepo</code> Feld <code>ConfigRepo</code> in der Ressourcenspezifikation verwiesen wird.  Wenn die Konfiguration aktualisiert wird, wird ein neues Ereignis vom Typ <code>GenericEvent</code> und an den Kanal gesendet, den der <code>Upgrade</code> Controller abhört. </p><br><p>  Nach der Verarbeitung der Anforderung gibt <code>Reconcile</code> ein Objekt vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Result</code></a> und <code>error</code> .  Wenn das <code>Result</code> <code>Requeue: true</code> oder <code>error != nil</code> , gibt der Controller die Anforderung mithilfe der Methode <code>queue.AddRateLimited</code> an die Warteschlange <code>queue.AddRateLimited</code> .  Die Anforderung wird mit einer Verzögerung an die Warteschlange zurückgesendet, die von <code>RateLimiter</code> festgelegt wird.  Standardmäßig wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>ItemExponentialFailureRateLimiter</code></a> verwendet, wodurch die Verzögerungszeit exponentiell mit einer Erhöhung der Anzahl der "Rückgaben" von Anforderungen erhöht wird.  Wenn das Feld " <code>Requeue</code> nicht festgelegt ist und während der Verarbeitung der Anforderung kein Fehler aufgetreten ist, ruft der Controller die <code>Queue.Forget</code> Methode auf, mit der die Anforderung aus dem Cache des <code>RateLimiter</code> (wodurch die Anzahl der Rückgaben zurückgesetzt wird).  Am Ende der Anforderungsverarbeitung entfernt der Controller sie mithilfe der <code>Queue.Done</code> Methode aus der Warteschlange. </p><br><h2 id="zapusk-operatora">  Bedienerstart </h2><br><p>  Die Komponenten des Bedieners wurden oben beschrieben, und eine Frage blieb offen: wie man es startet.  Zuerst müssen Sie sicherstellen, dass alle erforderlichen Ressourcen installiert sind (für lokale Tests empfehle ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einrichtung</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">minikube</a> ): </p><br><pre> <code class="plaintext hljs"># Setup Service Account kubectl create -f deploy/service_account.yaml # Setup RBAC kubectl create -f deploy/role.yaml kubectl create -f deploy/role_binding.yaml # Setup the CRD kubectl create -f deploy/crds/services_v1alpha1_monitoredservice_crd.yaml # Setup custom resource kubectl create -f deploy/crds/services_v1alpha1_monitoredservice_cr.yaml</code> </pre> <br><p>  Sobald die Voraussetzungen erfüllt sind, gibt es zwei einfache Möglichkeiten, die Anweisung zum Testen auszuführen.  Am einfachsten ist es, es außerhalb des Clusters mit dem folgenden Befehl zu starten: </p><br><pre> <code class="plaintext hljs">operator-sdk up local --namespace=default</code> </pre> <br><p>  Die zweite Möglichkeit besteht darin, den Operator im Cluster bereitzustellen.  Zuerst müssen Sie mit dem Operator ein Docker-Image erstellen: </p><br><pre> <code class="plaintext hljs">operator-sdk build config-monitor-operator:latest</code> </pre> <br><p>  Ersetzen <code>REPLACE_IMAGE</code> in der Datei <code>deploy/operator.yaml</code> <code>REPLACE_IMAGE</code> durch <code>config-monitor-operator:latest</code> : </p><br><pre> <code class="plaintext hljs">sed -i "" 's|REPLACE_IMAGE|config-monitor-operator:latest|g' deploy/operator.yaml</code> </pre> <br><p>  Bereitstellung mit Anweisung erstellen: </p><br><pre> <code class="plaintext hljs">kubectl create -f deploy/operator.yaml</code> </pre> <br><p>  Jetzt sollte in der Liste der <code>Pod</code> im Cluster <code>Pod</code> mit einem Testdienst angezeigt werden, und im zweiten Fall ein weiterer mit einem Operator. </p><br><h2 id="vmesto-zaklyucheniya-ili-best-practices">  Anstelle einer Schlussfolgerung oder Best Practices </h2><br><p>  Die Hauptprobleme der Bedienerentwicklung im Moment sind die schwache Dokumentation der Tools und das Fehlen etablierter Best Practices.  Wenn ein neuer Entwickler beginnt, einen Operator zu entwickeln, kann er sich Beispiele für die Implementierung einer bestimmten Anforderung praktisch nicht ansehen, sodass Fehler unvermeidlich sind.  Im Folgenden finden Sie einige Lehren, die wir aus unseren Fehlern gezogen haben: </p><br><ul><li>  Wenn es zwei verwandte Anwendungen gibt, sollten Sie den Wunsch vermeiden, sie mit einem einzigen Operator zu kombinieren.  Andernfalls wird das Prinzip der losen Kopplungsdienste verletzt. </li><li>  Sie müssen sich an die Trennung von Bedenken erinnern: Sie sollten nicht versuchen, die gesamte Logik in einem Controller zu implementieren.  Zum Beispiel lohnt es sich, die Funktionen der Überwachung von Konfigurationen und der Erstellung / Aktualisierung einer Ressource zu erweitern. </li><li>  Das Blockieren von Anrufen sollte bei der <code>Reconcile</code> Methode vermieden werden.  Sie können beispielsweise Konfigurationen von einer externen Quelle abrufen. Wenn der Vorgang jedoch länger dauert, erstellen Sie hierfür eine Goroutine und senden Sie die Anforderung an die Warteschlange zurück. <code>Requeue: true</code> in der Antwort <code>Requeue: true</code> . </li></ul><br><p>  In den Kommentaren wäre es interessant, von Ihren Erfahrungen bei der Entwicklung von Betreibern zu hören.  Und im nächsten Teil werden wir über Bedienertests sprechen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446648/">https://habr.com/ru/post/de446648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446638/index.html">Cisco HyperFlex vs. Wettbewerber: Testleistung</a></li>
<li><a href="../de446640/index.html">20 Projekte, 20 Sprachen, Frist gestern. Teil 2</a></li>
<li><a href="../de446642/index.html">Checkliste zum Erstellen und Veröffentlichen von Webanwendungen</a></li>
<li><a href="../de446644/index.html">So führen Sie SMM 2019 aus: 17 Diagramme von Neil Patel</a></li>
<li><a href="../de446646/index.html">InterSystems IRIS 2019.1 Release</a></li>
<li><a href="../de446650/index.html">Wie viel kosten Tester und wovon hängen ihre Gehälter ab? Erstellen eines Porträts eines erfolgreichen QS-Spezialisten</a></li>
<li><a href="../de446652/index.html">MVCC-4. Datenschnappschüsse</a></li>
<li><a href="../de446654/index.html">Wie wir die Codeüberprüfung gespeichert haben</a></li>
<li><a href="../de446656/index.html">1600bit / s Sprachcodierung mit dem neuronalen Vocoder LPCNet</a></li>
<li><a href="../de446658/index.html">Interview mit Andrei Stankevich über Sportprogrammierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>