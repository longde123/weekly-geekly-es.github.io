<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîë üöé üìù Kubernetes Operator-Entwicklung mit Operator Framework üôÇ üìå ü§∑üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie im Artikel √ºber Radartechnologie erw√§hnt, bewegt sich Lamoda aktiv in Richtung Microservice-Architektur. Die meisten unserer Dienste werden mit He...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Operator-Entwicklung mit Operator Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/446648/"><p><img src="https://habrastorage.org/getpro/habr/post_images/352/5c8/f16/3525c8f16510afa2b61b0ff9b8434a02.png" alt="Bild"></p><br><p>  Wie im Artikel √ºber Radartechnologie erw√§hnt, bewegt sich Lamoda aktiv in Richtung Microservice-Architektur.  Die meisten unserer Dienste werden mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm</a> verpackt und auf Kubernetes bereitgestellt.  Dieser Ansatz entspricht in 99% der F√§lle voll und ganz unseren Anforderungen.  1% verbleibt, wenn die Standardfunktionalit√§t von Kubernetes nicht ausreicht, z. B. wenn Sie eine Sicherung konfigurieren oder einen Dienst f√ºr ein bestimmtes Ereignis aktualisieren m√ºssen.  Um dieses Problem zu l√∂sen, verwenden wir das Operatormuster.  In dieser Artikelserie werde ich - Grigory Mikhalkin, der Entwickler des Forschungs- und Entwicklungsteams bei Lamoda - √ºber die Lehren sprechen, die ich aus meinen Erfahrungen bei der Entwicklung von K8-Operatoren mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator Framework gezogen habe</a> . </p><a name="habracut"></a><br><h2 id="chto-takoe-operator">  Was ist ein Operator? </h2><br><p>  Eine M√∂glichkeit, die Kubernetes-Funktionalit√§t zu erweitern, besteht darin, eigene Controller zu erstellen.  Die Hauptabstraktionen in Kubernetes sind Objekte und Controller.  Objekte beschreiben den gew√ºnschten Status des Clusters.  Ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pod</a> beschreibt beispielsweise, welche Container gestartet und welche Parameter gestartet werden m√ºssen, und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReplicaSet-</a> Objekt gibt an, wie viele Replikate eines bestimmten Pod gestartet werden m√ºssen.  Die Controller steuern den Status des Clusters basierend auf der Beschreibung der Objekte. In dem oben beschriebenen Fall unterst√ºtzt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReplicationController</a> die Anzahl der im ReplicaSet angegebenen Pod-Replikate.  Mithilfe neuer Controller k√∂nnen Sie zus√§tzliche Logik implementieren, z. B. das Senden von Benachrichtigungen f√ºr Ereignisse, die Wiederherstellung nach einem Fehler oder die Verwaltung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ressourcen Dritter</a> . </p><br><p> Ein Operator ist eine Kubernetes-Anwendung, die einen oder mehrere Controller enth√§lt, die eine Ressource eines Drittanbieters bedienen.  Das Konzept wurde 2016 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vom CoreOS-Team erfunden. In</a> letzter Zeit hat die Beliebtheit von Betreibern rapide zugenommen.  Sie k√∂nnen versuchen, den gew√ºnschten Operator in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste auf kubedex</a> (hier sind mehr als 100 √∂ffentlich verf√ºgbare Operatoren aufgef√ºhrt) sowie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OperatorHub zu finden</a> .  Es gibt 3 beliebte Tools f√ºr die Operatorentwicklung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubebuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator SDK</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Metacontroller</a> .  In Lamoda verwenden wir das Operator SDK, daher werden wir sp√§ter dar√ºber sprechen. </p><br><h2 id="operator-sdk">  Operator SDK </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7e/56d/194/f7e56d1948a2f5291ef189e7a03df9be.png" alt="Bild"></p><br><p>  Das Operator SDK ist Teil des Operator Frameworks, das zwei weitere wichtige Teile enth√§lt: Operator Lifecycle Manager und Operator Metering. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Operator SDK</a> ist ein Wrapper f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Controller-Laufzeit</a> , eine beliebte Bibliothek f√ºr die Entwicklung von Controllern (die wiederum ein Wrapper f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client-Go ist</a> ), ein Codegenerator + Framework zum Schreiben von E2E-Tests. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator Lifecycle Manager</a> - ein Framework f√ºr die Verwaltung vorhandener Operatoren;  Behebt Situationen, in denen der Bediener in den Zombie-Modus wechselt oder eine neue Version eingef√ºhrt wird. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bedienermessung</a> - Wie der Name schon sagt, werden Daten zur Arbeit des Bedieners erfasst und basierend darauf k√∂nnen auch Berichte erstellt werden. </li></ul><br><h2 id="sozdanie-novogo-proekta">  Erstellen Sie ein neues Projekt </h2><br><p>  Ein Beispiel ist ein Operator, der eine Datei mit Konfigurationen im Repository √ºberwacht und bei Aktualisierung die Bereitstellung des Dienstes mit neuen Konfigurationen neu startet.  Den vollst√§ndigen Beispielcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4c0/e84/ebc/4c0e84ebcba8cad49b2bea8506f79d32.png" alt="Bild"></p><br><p>  Erstellen Sie ein Projekt mit einem neuen Operator: </p><br><pre><code class="plaintext hljs">operator-sdk new config-monitor</code> </pre> <br><p>  Der Codegenerator erstellt Code f√ºr den Operator, der im zugewiesenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namespace arbeitet</a> .  Dieser Ansatz ist dem Zugriff auf den gesamten Cluster vorzuziehen, da im Fehlerfall die Probleme innerhalb desselben Namespace isoliert werden.  Der <code>cluster-wide</code> Operator kann durch Hinzuf√ºgen von <code>--cluster-scoped</code> generiert werden.  Die folgenden Verzeichnisse befinden sich im erstellten Projekt: </p><br><ul><li>  cmd - enth√§lt das <code>main package</code> , in dem <code>Manager</code> initialisiert und gestartet wird; </li><li>  deploy - enth√§lt Deklarationen des Operators, der CRD und der Objekte, die zum Einrichten des RBAC-Operators erforderlich sind. </li><li>  pkg - hier ist unser Hauptcode f√ºr neue Objekte und Controller. </li></ul><br><p>  Es gibt nur eine <a href=""><code>cmd/manager/main.go</code></a> Datei in <a href=""><code>cmd/manager/main.go</code></a> . </p><br><div class="spoiler">  <b class="spoiler_title">Code-Snippet</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// Become the leader before proceeding err = leader.Become(ctx, "config-monitor-lock") if err != nil { log.Error(err, "") os.Exit(1) } // Create a new Cmd to provide shared dependencies and start components mgr, err := manager.New(cfg, manager.Options{ Namespace: namespace, MetricsBindAddress: fmt.Sprintf("%s:%d", metricsHost, metricsPort), }) ... // Setup Scheme for all resources if err := apis.AddToScheme(mgr.GetScheme()); err != nil { log.Error(err, "") os.Exit(1) } // Setup all Controllers if err := controller.AddToManager(mgr); err != nil { log.Error(err, "") os.Exit(1) } ... // Start the Cmd if err := mgr.Start(signals.SetupSignalHandler()); err != nil { log.Error(err, "Manager exited non-zero") os.Exit(1) }</code> </pre> </div></div><br><p>  In der ersten Zeile: <code>err = leader.Become(ctx, "config-monitor-lock")</code> - ein Leader wird ausgew√§hlt.  In den meisten Szenarien wird nur eine aktive Instanz einer Anweisung f√ºr Namespace / Cluster ben√∂tigt.  Standardm√§√üig verwendet das Operator SDK die <a href="">Leader for Life-</a> Strategie. Die erste gestartete Instanz des Operators bleibt der Leader, bis sie aus dem Cluster entfernt wird. </p><br><p>  Nachdem diese Operatorinstanz zum Leader ernannt wurde, wird ein neuer <code>Manager</code> initialisiert - <code>mgr, err := manager.New(...)</code> .  Zu seinen Aufgaben geh√∂ren: </p><br><ul><li>  <code>err := apis.AddToScheme(mgr.GetScheme())</code> - Registrierung neuer Ressourcenschemata; </li><li>  <code>err := controller.AddToManager(mgr)</code> - Registrierung von Controllern; </li><li>  <code>err := mgr.Start(signals.SetupSignalHandler())</code> - Starten und Steuern der Controller. </li></ul><br><p>  Im Moment haben wir weder neue Ressourcen noch Controller f√ºr die Registrierung.  Sie k√∂nnen eine neue Ressource mit dem folgenden Befehl hinzuf√ºgen: </p><br><pre> <code class="plaintext hljs">operator-sdk add api --api-version=services.example.com/v1alpha1 --kind=MonitoredService</code> </pre> <br><p>  Dieser Befehl f√ºgt die Definition des <code>MonitoredService</code> Ressourcenschemas zum Verzeichnis <code>pkg/apis</code> sowie yaml mit der <code>CRD</code> Definition in <code>deploy/crds</code> .  Von allen generierten Dateien sollten Sie nur die Schemadefinition in <a href=""><code>monitoredservice_types.go</code></a> manuell √§ndern.  Der Typ <code>MonitoredServiceSpec</code> definiert den gew√ºnschten Status der Ressource: Was der Benutzer in yaml mit der Definition der Ressource angibt.  Im Kontext unseres Operators bestimmt das Feld <code>Size</code> die gew√ºnschte Anzahl von Replikaten. <code>ConfigRepo</code> gibt an, woher die aktuellen Konfigurationen abgerufen werden k√∂nnen.  <code>MonitoredServiceStatus</code> ermittelt den beobachteten Status der Ressource. Beispielsweise werden die Namen der zu dieser Ressource geh√∂renden Pods und die aktuellen <code>spec</code> Pods gespeichert. </p><br><p>  Nach dem Bearbeiten des Schemas m√ºssen Sie den folgenden Befehl ausf√ºhren: </p><br><pre> <code class="plaintext hljs">operator-sdk generate k8s</code> </pre> <br><p>  Die <code>CRD</code> Definition in <code>deploy/crds</code> wird aktualisiert. </p><br><p>  Erstellen wir nun den Hauptteil unseres Operators, den Controller: </p><br><pre> <code class="plaintext hljs">operator-sdk add controller --api-version=services.example.com/v1alpha1 --kind=Monitor</code> </pre> <br><p>  Die Datei <a href=""><code>monitor_controller.go</code></a> wird im <a href=""><code>monitor_controller.go</code></a> <code>pkg/controller</code> <a href=""><code>monitor_controller.go</code></a> , in das wir die ben√∂tigte Logik <a href=""><code>monitor_controller.go</code></a> . </p><br><h2 id="razrabotka-kontrollera">  Controller-Entwicklung </h2><br><p>  Die Steuerung ist die Hauptarbeitseinheit des Bedieners.  In unserem Fall gibt es zwei Controller: </p><br><ul><li>  Monitor Controller √ºberwacht √Ñnderungen der Servicekonfiguration. </li><li>  Der Upgrade-Controller aktualisiert den Dienst und h√§lt ihn im gew√ºnschten Zustand. </li></ul><br><p>  Im Kern ist der Controller ein Regelkreis, er √ºberwacht die Warteschlange mit den Ereignissen, die er abonniert hat, und verarbeitet sie: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/220/2e6/a09/2202e6a0931df3e5b87c4442dd839615.png" alt="Bild"></p><br><p>  Ein neuer Controller wird vom Manager in der <code>add</code> Methode erstellt und registriert: </p><br><pre> <code class="plaintext hljs">c, err := controller.New("monitor-controller", mgr, controller.Options{Reconciler: r})</code> </pre> <br><p>  Mit der <code>Watch</code> Methode abonnieren wir Ereignisse bez√ºglich der Erstellung einer neuen Ressource oder der <code>Spec</code> einer vorhandenen <code>MonitoredService</code> Ressource: </p><br><pre> <code class="plaintext hljs">err = c.Watch(&amp;source.Kind{Type: &amp;servicesv1alpha1.MonitoredService{}}, &amp;handler.EnqueueRequestForObject{}, common.CreateOrUpdateSpecPredicate)</code> </pre> <br><p>  Der Ereignistyp kann mithilfe der Parameter <code>src</code> und <code>predicates</code> konfiguriert werden.  <code>src</code> akzeptiert Objekte vom Typ <code>Source</code> . </p><br><ul><li>  <code>Informer</code> - fragt den <code>apiserver</code> nach Ereignissen ab, die mit dem Filter √ºbereinstimmen. Wenn ein solches Ereignis <code>apiserver</code> , wird es in die Warteschlange des Controllers gestellt.  In der <code>controller-runtime</code> dies ein Wrapper √ºber den <code>SharedIndexInformer</code> von <code>client-go</code> . </li><li>  <code>Kind</code> ist auch ein Wrapper √ºber <code>SharedIndexInformer</code> , erstellt jedoch im Gegensatz zu <code>Informer</code> unabh√§ngig eine Informer-Instanz basierend auf den √ºbergebenen Parametern (Schema der √ºberwachten Ressource). </li><li>  <code>Channel</code> - akzeptiert <code>chan event.GenericEvent</code> als Parameter, die durch ihn kommenden Ereignisse werden in die Warteschlange des Controllers gestellt. </li></ul><br><p>  <code>redicates</code> erwarten Objekte, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Predicate</code></a> erf√ºllen.  Tats√§chlich ist dies ein zus√§tzlicher Filter f√ºr Ereignisse. <code>UpdateEvent</code> Sie beispielsweise <code>UpdateEvent</code> filtern <code>UpdateEvent</code> k√∂nnen Sie genau sehen, welche √Ñnderungen in der Ressourcenspezifikation vorgenommen wurden. </p><br><p>  Wenn ein Ereignis eintrifft, akzeptiert es ein <code>EventHandler</code> - das zweite Argument der <code>Watch</code> Methode -, das das Ereignis in das vom <code>Reconciler</code> erwartete Anforderungsformat <code>EventHandler</code> : </p><br><ul><li>  <code>EnqueueRequestForObject</code> - <code>EnqueueRequestForObject</code> eine Anforderung mit dem Namen und dem Namespace des Objekts, das das Ereignis verursacht hat. </li><li>  <code>EnqueueRequestForOwner</code> - <code>EnqueueRequestForOwner</code> eine Anforderung mit den Daten des √ºbergeordneten Objekts.  Dies ist beispielsweise erforderlich, wenn der ressourcengesteuerte <code>Pod</code> gel√∂scht wurde und Sie mit dem Ersetzen beginnen m√ºssen. </li><li>  <code>EnqueueRequestsFromMapFunc</code> - verwendet als Parameter die <code>map</code> Funktion, die ein Ereignis empf√§ngt (in <code>MapObject</code> ) und eine Liste von Anforderungen zur√ºckgibt.  <a href="">Ein Beispiel, wenn dieser Handler ben√∂tigt wird</a> - es gibt einen Timer, f√ºr den Sie f√ºr jeden Tick neue Konfigurationen f√ºr alle verf√ºgbaren Dienste abrufen m√ºssen. </li></ul><br><p>  Anforderungen werden in die Controller-Warteschlange gestellt, und einer der Worker (standardm√§√üig hat der Controller eine) zieht das Ereignis aus der Warteschlange und √ºbergibt es an <code>Reconciler</code> . </p><br><p>  <strong>Reconciler</strong> implementiert nur eine Methode - <code>Reconcile</code> , die die grundlegende Logik der Ereignisverarbeitung enth√§lt: </p><br><div class="spoiler">  <b class="spoiler_title">Methode abgleichen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">func (r *ReconcileMonitor) Reconcile(request reconcile.Request) (reconcile.Result, error) { reqLogger := log.WithValues("Request.Namespace", request.Namespace, "Request.Name", request.Name) reqLogger.Info("Checking updates in repo for MonitoredService") // fetch the Monitor instance instance := &amp;servicesv1alpha1.MonitoredService{} err := r.client.Get(context.Background(), request.NamespacedName, instance) if err != nil { if errors.IsNotFound(err) { // Request object not found, could have been deleted after reconcile request. // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers. // Return and don't requeue return reconcile.Result{}, nil } // Error reading the object - requeue the request. return reconcile.Result{}, err } // check if service's config was updated // if it was, send event to upgrade controller if podSpec, ok := r.isServiceConfigUpdated(instance); ok { // Update instance Spec instance.Status.PodSpec = *podSpec instance.Status.ConfigChanged = true err = r.client.Status().Update(context.Background(), instance) if err != nil { reqLogger.Error(err, "Failed to update service status", "Service.Namespace", instance.Namespace, "Service.Name", instance.Name) return reconcile.Result{}, err } r.eventsChan &lt;- event.GenericEvent{Meta: &amp;servicesv1alpha1.MonitoredService{}, Object: instance} } return reconcile.Result{}, nil }</code> </pre> </div></div><br><p>  Die Methode akzeptiert ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Request</code></a> mit dem Feld <code>NamespacedName</code> , mit dem die Ressource aus dem Cache <code>r.client.Get(context.TODO(), request.NamespacedName, instance)</code> kann: <code>r.client.Get(context.TODO(), request.NamespacedName, instance)</code> .  In diesem Beispiel wird eine Anforderung an die Datei mit der Dienstkonfiguration gestellt, auf die <code>ConfigRepo</code> Feld <code>ConfigRepo</code> in der Ressourcenspezifikation verwiesen wird.  Wenn die Konfiguration aktualisiert wird, wird ein neues Ereignis vom Typ <code>GenericEvent</code> und an den Kanal gesendet, den der <code>Upgrade</code> Controller abh√∂rt. </p><br><p>  Nach der Verarbeitung der Anforderung gibt <code>Reconcile</code> ein Objekt vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Result</code></a> und <code>error</code> .  Wenn das <code>Result</code> <code>Requeue: true</code> oder <code>error != nil</code> , gibt der Controller die Anforderung mithilfe der Methode <code>queue.AddRateLimited</code> an die Warteschlange <code>queue.AddRateLimited</code> .  Die Anforderung wird mit einer Verz√∂gerung an die Warteschlange zur√ºckgesendet, die von <code>RateLimiter</code> festgelegt wird.  Standardm√§√üig wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>ItemExponentialFailureRateLimiter</code></a> verwendet, wodurch die Verz√∂gerungszeit exponentiell mit einer Erh√∂hung der Anzahl der "R√ºckgaben" von Anforderungen erh√∂ht wird.  Wenn das Feld " <code>Requeue</code> nicht festgelegt ist und w√§hrend der Verarbeitung der Anforderung kein Fehler aufgetreten ist, ruft der Controller die <code>Queue.Forget</code> Methode auf, mit der die Anforderung aus dem Cache des <code>RateLimiter</code> (wodurch die Anzahl der R√ºckgaben zur√ºckgesetzt wird).  Am Ende der Anforderungsverarbeitung entfernt der Controller sie mithilfe der <code>Queue.Done</code> Methode aus der Warteschlange. </p><br><h2 id="zapusk-operatora">  Bedienerstart </h2><br><p>  Die Komponenten des Bedieners wurden oben beschrieben, und eine Frage blieb offen: wie man es startet.  Zuerst m√ºssen Sie sicherstellen, dass alle erforderlichen Ressourcen installiert sind (f√ºr lokale Tests empfehle ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einrichtung</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">minikube</a> ): </p><br><pre> <code class="plaintext hljs"># Setup Service Account kubectl create -f deploy/service_account.yaml # Setup RBAC kubectl create -f deploy/role.yaml kubectl create -f deploy/role_binding.yaml # Setup the CRD kubectl create -f deploy/crds/services_v1alpha1_monitoredservice_crd.yaml # Setup custom resource kubectl create -f deploy/crds/services_v1alpha1_monitoredservice_cr.yaml</code> </pre> <br><p>  Sobald die Voraussetzungen erf√ºllt sind, gibt es zwei einfache M√∂glichkeiten, die Anweisung zum Testen auszuf√ºhren.  Am einfachsten ist es, es au√üerhalb des Clusters mit dem folgenden Befehl zu starten: </p><br><pre> <code class="plaintext hljs">operator-sdk up local --namespace=default</code> </pre> <br><p>  Die zweite M√∂glichkeit besteht darin, den Operator im Cluster bereitzustellen.  Zuerst m√ºssen Sie mit dem Operator ein Docker-Image erstellen: </p><br><pre> <code class="plaintext hljs">operator-sdk build config-monitor-operator:latest</code> </pre> <br><p>  Ersetzen <code>REPLACE_IMAGE</code> in der Datei <code>deploy/operator.yaml</code> <code>REPLACE_IMAGE</code> durch <code>config-monitor-operator:latest</code> : </p><br><pre> <code class="plaintext hljs">sed -i "" 's|REPLACE_IMAGE|config-monitor-operator:latest|g' deploy/operator.yaml</code> </pre> <br><p>  Bereitstellung mit Anweisung erstellen: </p><br><pre> <code class="plaintext hljs">kubectl create -f deploy/operator.yaml</code> </pre> <br><p>  Jetzt sollte in der Liste der <code>Pod</code> im Cluster <code>Pod</code> mit einem Testdienst angezeigt werden, und im zweiten Fall ein weiterer mit einem Operator. </p><br><h2 id="vmesto-zaklyucheniya-ili-best-practices">  Anstelle einer Schlussfolgerung oder Best Practices </h2><br><p>  Die Hauptprobleme der Bedienerentwicklung im Moment sind die schwache Dokumentation der Tools und das Fehlen etablierter Best Practices.  Wenn ein neuer Entwickler beginnt, einen Operator zu entwickeln, kann er sich Beispiele f√ºr die Implementierung einer bestimmten Anforderung praktisch nicht ansehen, sodass Fehler unvermeidlich sind.  Im Folgenden finden Sie einige Lehren, die wir aus unseren Fehlern gezogen haben: </p><br><ul><li>  Wenn es zwei verwandte Anwendungen gibt, sollten Sie den Wunsch vermeiden, sie mit einem einzigen Operator zu kombinieren.  Andernfalls wird das Prinzip der losen Kopplungsdienste verletzt. </li><li>  Sie m√ºssen sich an die Trennung von Bedenken erinnern: Sie sollten nicht versuchen, die gesamte Logik in einem Controller zu implementieren.  Zum Beispiel lohnt es sich, die Funktionen der √úberwachung von Konfigurationen und der Erstellung / Aktualisierung einer Ressource zu erweitern. </li><li>  Das Blockieren von Anrufen sollte bei der <code>Reconcile</code> Methode vermieden werden.  Sie k√∂nnen beispielsweise Konfigurationen von einer externen Quelle abrufen. Wenn der Vorgang jedoch l√§nger dauert, erstellen Sie hierf√ºr eine Goroutine und senden Sie die Anforderung an die Warteschlange zur√ºck. <code>Requeue: true</code> in der Antwort <code>Requeue: true</code> . </li></ul><br><p>  In den Kommentaren w√§re es interessant, von Ihren Erfahrungen bei der Entwicklung von Betreibern zu h√∂ren.  Und im n√§chsten Teil werden wir √ºber Bedienertests sprechen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446648/">https://habr.com/ru/post/de446648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446638/index.html">Cisco HyperFlex vs. Wettbewerber: Testleistung</a></li>
<li><a href="../de446640/index.html">20 Projekte, 20 Sprachen, Frist gestern. Teil 2</a></li>
<li><a href="../de446642/index.html">Checkliste zum Erstellen und Ver√∂ffentlichen von Webanwendungen</a></li>
<li><a href="../de446644/index.html">So f√ºhren Sie SMM 2019 aus: 17 Diagramme von Neil Patel</a></li>
<li><a href="../de446646/index.html">InterSystems IRIS 2019.1 Release</a></li>
<li><a href="../de446650/index.html">Wie viel kosten Tester und wovon h√§ngen ihre Geh√§lter ab? Erstellen eines Portr√§ts eines erfolgreichen QS-Spezialisten</a></li>
<li><a href="../de446652/index.html">MVCC-4. Datenschnappsch√ºsse</a></li>
<li><a href="../de446654/index.html">Wie wir die Code√ºberpr√ºfung gespeichert haben</a></li>
<li><a href="../de446656/index.html">1600bit / s Sprachcodierung mit dem neuronalen Vocoder LPCNet</a></li>
<li><a href="../de446658/index.html">Interview mit Andrei Stankevich √ºber Sportprogrammierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>