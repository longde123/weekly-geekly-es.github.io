<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìì ‚õ≤Ô∏è üåâ Funktionale Programmierung aus Sicht von EcmaScript. Rekursion und ihre Typen üò∑ üîï üìº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 

 Heute setzen wir unsere Forschung zur funktionalen Programmierung im Kontext von EcmaScript fort, dessen Spezifikation auf JavaScript ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionale Programmierung aus Sicht von EcmaScript. Rekursion und ihre Typen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480520/">  Hallo habr <br><br>  Heute setzen wir unsere Forschung zur funktionalen Programmierung im Kontext von EcmaScript fort, dessen Spezifikation auf JavaScript basiert.  In den vorhergehenden Artikeln des Zyklus wurden folgende Themen behandelt: <br><br><ol><li>  <a href="https://habr.com/ru/post/474702/">Reine Funktionen, Lambdas, Immunit√§t</a> </li><li>  <a href="https://habr.com/ru/post/475324/">Zusammensetzung, Currying, Teilanwendung</a> </li></ol><a name="habracut"></a><br><h2>  Rekursion </h2><br>  Wie immer hilft uns Wikipedia bei der Suche nach einer Definition: <br><blockquote>  Rekursion - die Definition, Beschreibung, Abbildung eines Objekts oder Prozesses innerhalb dieses Objekts oder Prozesses selbst, dh die Situation, in der das Objekt Teil von sich selbst ist.  Der Begriff "Rekursion" wird in verschiedenen Spezialgebieten des Wissens verwendet - von der Linguistik bis zur Logik, findet jedoch in Mathematik und Informatik die gr√∂√üte Anwendung. </blockquote>  Rekursion bezieht sich f√ºr die Programmierung auf <b>Prozesse, die sich in ihrem K√∂rper selbst aufrufen</b> .  Eine rekursive Funktion hat mehrere obligatorische Komponenten: <br><br><ul><li>  <b>Terminalbedingung</b> - Beendigungsbedingung </li><li>  Die Regel, die <b>sich tief in die</b> Rekursion hineinbewegt </li></ul><br>  Betrachten Sie das beliebteste Beispiel f√ºr eine rekursionsfaktorielle Berechnung. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factorial = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Wir unterscheiden die charakteristischen Komponenten einer rekursiven Funktion.  Endzustand <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  und Rekursionsregel <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Es ist wichtig zu wissen, dass Rekursion kein spezifisches Merkmal von JS ist, sondern eine in der Programmierung weit verbreitete Technik. <br><br><h4>  Rekursive und iterative Prozesse </h4><br>  Rekursion kann auf zwei Arten organisiert werden: durch einen rekursiven Prozess oder durch einen iterativen. <br><br>  Wir haben den rekursiven Prozess bereits gesehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factorial = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Eine iterative L√∂sung des Fakult√§tsproblems w√ºrde folgenderma√üen aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factorial = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter, acc</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter(counter - <span class="hljs-number"><span class="hljs-number">1</span></span>, counter * acc); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter(n, <span class="hljs-number"><span class="hljs-number">1</span></span>); };</code> </pre><br>  Beide Optionen sind Rekursionen.  Beide L√∂sungen weisen Merkmale auf, die f√ºr eine Rekursion charakteristisch sind: die Endbedingung und die Bewegungsregel entlang der Rekursion.  Schauen wir uns ihre Unterschiede an. <br><br>  Der rekursive Prozess bei jedem Schritt erinnert sich an die Aktion.  was getan werden muss.  Wenn er die thermischen Bedingungen erreicht hat, f√ºhrt er alle erinnerten Aktionen in umgekehrter Reihenfolge durch.  Lassen Sie uns mit einem Beispiel veranschaulichen.  Wenn der rekursive Prozess Fakult√§t 6 ber√ºcksichtigt, muss er sich 5 Zahlen merken, um sie am Ende zu z√§hlen, wenn Sie nicht weiterkommen und nicht rekursiv tiefer in die Tiefe vordringen k√∂nnen.  Wenn wir uns beim n√§chsten Funktionsaufruf irgendwo au√üerhalb dieses Aufrufs befinden, werden diese gespeicherten Nummern gespeichert. <br><br>  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="javascript hljs">factorial(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 6  ,    3 3 * factorial(2); 3 * 2 * factorial(1); 3 * 2 * 1; 3 * 2; 6;</span></span></code> </pre><br>  Wie Sie sehen, besteht die Grundidee eines rekursiven Prozesses darin, die Berechnung auf das Ende zu verschieben. <br>  Ein solcher Prozess erzeugt <b>einen zeitvariablen Zustand</b> , der "irgendwo" au√üerhalb des aktuellen Funktionsaufrufs gespeichert ist. <br><br>  Ich denke, Sie erinnern sich, dass wir im ersten Artikel der Reihe √ºber <a href="https://habr.com/ru/post/474702/">funktionale Programmierung</a> √ºber die Bedeutung von Immunit√§t und Zustandsmangel gesprochen haben.  Ein Zustand verursacht viele Probleme, die nicht immer einfach zu handhaben sind. <br><br>  <b>Ein iterativer Prozess</b> unterscheidet sich von einem <b>rekursiven in einer</b> festen Anzahl von Zust√§nden.  Bei jedem Schritt ber√ºcksichtigt der iterative Prozess alles, was er berechnen kann, sodass jeder Schritt der Rekursion unabh√§ngig vom vorherigen erfolgt. <br><br>  Es sieht so aus: <br><br><pre> <code class="javascript hljs">iter(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// iter(3 - 1, 1 * 3); // ,      6, iter(2, 3); // iter(2 - 1, 2 * 3);//   ,      3 iter(1, 6); // counter === 1, return 6 6;</span></span></code> </pre><br>  Ich denke, es ist offensichtlich, dass ein iterativer Prozess weniger Speicher verbraucht.  Daher sollten Sie es immer verwenden, wenn Sie eine Rekursion erstellen.  Einzige Ausnahme: Wenn wir den Wert erst berechnen k√∂nnen, wenn der thermische Zustand erreicht ist. <br><br><h3>  Baumrekursion </h3><br>  Viele Leute denken, dass B√§ume und die Arbeit mit ihnen etwas sehr Abstruses, Komplexes und f√ºr blo√üe Sterbliche unverst√§ndliches sind.  Dies ist eigentlich nicht der Fall.  Jede hierarchische Struktur kann in Form eines Baumes dargestellt werden.  Auch menschliches Denken ist wie ein Baum. <br><br>  Um die Baumrekursion besser zu verstehen, schauen wir uns ein einfaches und beliebtes Beispiel an: Fibonacci-Zahlen. <br><br><blockquote>  Fibonacci-Zahlen - Elemente einer numerischen Folge 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, ... (Sequenz A000045 in OEIS), wobei die ersten beiden Zahlen entweder 1 und 1 oder 0 und 1 sind und jede nachfolgende Zahl gleich der Summe der beiden vorherigen Zahlen ist.  Benannt nach dem mittelalterlichen Mathematiker Leonardo von Pisa (bekannt als Fibonacci). </blockquote><br>  Mathematisch ist es recht einfach, eine Beschreibung (und deklarative Programmierung ist die Beschreibung) dieser Sequenz zu formulieren: <br><br><pre> <code class="plaintext hljs">fib(n) = [  0  n = 0,//(1)  1  n = 1,//(2) fib(n-1) + fib(n-2)     ]</code> </pre><br>  Gehen wir nun von der Mathematik zum logischen Denken √ºber (schlie√ülich m√ºssen wir Programmlogik schreiben).  Um fib (5) zu berechnen, m√ºssen wir fib (4) und fib (3) berechnen.  Um fib (4) zu berechnen, m√ºssen wir fib (3) und fib (2) berechnen.  Um fib (3) zu berechnen, m√ºssen wir fib (2) usw. berechnen, bis wir in unserem mathematischen Modell zu den bekannten Werten (1) und (2) gelangen. <br><br>  Zu welchen Gedanken sollte unser Denken f√ºhren?  Nat√ºrlich sollten wir die Rekursion verwenden.  Die thermische Bedingung kann als n &lt;= 1 formuliert werden. Anstelle eines Rekursionszweigs (wie in den vorherigen Beispielen) werden wir jedoch zwei Zweige haben: fib (n-1), fib (n-2). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fib = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) =&gt;</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ? n : fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre><br>  Diese L√∂sung hat ein deutliches Minus!  Es wird das Ergebnis desselben Wertes von n mehrmals in verschiedenen Zweigen ber√ºcksichtigt.  Um dieses Problem zu l√∂sen, gibt es eine funktionale Programmiertechnik namens <b>Memoization</b> , √ºber die wir in einem der folgenden Artikel sprechen. <br><br><h3>  Fazit </h3><br>  Rekursion ist ein sehr leistungsf√§higes Programmierwerkzeug.  Lassen Sie mich daran erinnern, dass wir in der Regel einen iterativen Prozess verwenden.  Die Verwendung eines rekursiven Prozesses lohnt sich nur, wenn das Zwischenergebnis nicht bei jedem Schritt der Rekursion berechnet werden kann. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480520/">https://habr.com/ru/post/de480520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480508/index.html">AI Journey: Berichte und Wettbewerbsergebnisse</a></li>
<li><a href="../de480510/index.html">Chronik der Konfrontation zwischen Rambler und Nginx (aktualisiert am 23. Dezember um 12:00 Uhr)</a></li>
<li><a href="../de480512/index.html">Chronik der Konfrontation zwischen Rambler Group und Nginx (aktualisiert am 23. Dezember, 12 Uhr)</a></li>
<li><a href="../de480514/index.html">Domain Name System History: Die ersten DNS-Server</a></li>
<li><a href="../de480518/index.html">Programmier-Tutor: Warum sollten Sie einer werden und wie?</a></li>
<li><a href="../de480526/index.html">Intel-Prozessoren spucken einen privaten Schl√ºssel aus, wenn Sie mit Spannung spielen</a></li>
<li><a href="../de480528/index.html">Warum Facebook es Ihnen erm√∂glicht, Benutzerdaten an andere Dienste zu √ºbertragen</a></li>
<li><a href="../de480530/index.html">IoT ist kein Spielzeug f√ºr Kinder. Wie Hackerangriffe auf das Internet der Dinge nicht nur gro√üe Unternehmen, sondern auch gew√∂hnliche Familien erschrecken</a></li>
<li><a href="../de480534/index.html">16 Entwicklungstipps f√ºr Android in Kotlin. Teil 2</a></li>
<li><a href="../de480538/index.html">Was ist besser f√ºr Spiele: Intel Optane oder SSD?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>