<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèª üèáüèΩ üö≤ Arranque del kernel de Linux. Parte 1 üéé ü¶è üë©üèΩ‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Del gestor de arranque al kernel 

 Si lees los art√≠culos anteriores, conoces mi nuevo pasatiempo para la programaci√≥n de bajo nivel. Escrib√≠ varios a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arranque del kernel de Linux. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428664/"> <b>Del gestor de arranque al kernel</b> <br><br>  Si lees los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> anteriores, conoces mi nuevo pasatiempo para la programaci√≥n de bajo nivel.  Escrib√≠ varios art√≠culos sobre programaci√≥n de ensambladores para <code>x86_64</code> Linux y al mismo tiempo comenc√© a sumergirme en el c√≥digo fuente del kernel de Linux. <br><br>  Estoy muy interesado en comprender c√≥mo funcionan las cosas de bajo nivel: c√≥mo se ejecutan los programas en mi computadora, c√≥mo se ubican en la memoria, c√≥mo el n√∫cleo gestiona los procesos y la memoria, c√≥mo funciona la pila de red en un nivel bajo y mucho m√°s.  Entonces, decid√≠ escribir otra serie de art√≠culos sobre el kernel de Linux para la <b>arquitectura x86_64</b> . <br><br>  Tenga en cuenta que no soy un desarrollador de kernel profesional y no escribo c√≥digo de kernel en el trabajo.  Esto es solo un pasatiempo.  Simplemente me gustan las cosas de bajo nivel y es interesante profundizar en ellas.  Por lo tanto, si nota alguna confusi√≥n o aparecen preguntas / comentarios, cont√°cteme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Twitter</a> , por <a href="">correo</a> o simplemente cree un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ticket</a> .  Estar√≠a agradecido <br><a name="habracut"></a><br>  Todos los art√≠culos se publican en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio de GitHub</a> , y si algo est√° mal con mi ingl√©s o el contenido del art√≠culo, no dude en enviar una solicitud de extracci√≥n. <br><br>  <i>Tenga en cuenta que esto no es documentaci√≥n oficial, sino simplemente capacitaci√≥n e intercambio de conocimientos.</i> <br><br>  <b>Conocimiento requerido</b> <br><br><ul><li>  Entendiendo el C√≥digo C </li><li>  Comprender el c√≥digo del ensamblador (sintaxis de AT&amp;T) </li></ul><br>  En cualquier caso, si reci√©n est√° comenzando a aprender tales herramientas, intentar√© explicar algo en este y en los art√≠culos posteriores.  Bien, con la introducci√≥n terminada, es hora de sumergirse en el kernel de Linux y las cosas de bajo nivel. <br><br>  Comenc√© a escribir este libro en los d√≠as del n√∫cleo Linux 3.18, y mucho ha cambiado desde entonces.  Si hay cambios, actualizar√© los art√≠culos en consecuencia. <br><br><h1>  Bot√≥n de encendido m√°gico, ¬øqu√© sigue? </h1><br>  Aunque estos son art√≠culos sobre el kernel de Linux, a√∫n no lo hemos alcanzado, al menos en esta secci√≥n.  Tan pronto como presiona el bot√≥n de encendido m√°gico en su computadora port√°til o de escritorio, comienza a funcionar.  La placa base env√≠a una se√±al a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente de alimentaci√≥n</a> .  Despu√©s de recibir la se√±al, proporciona a la computadora la cantidad necesaria de electricidad.  Tan pronto como la placa base recibe una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se√±al de "Power OK"</a> , intenta iniciar la CPU.  Vuelca todos los datos restantes en sus registros y establece valores predefinidos para cada uno de ellos. <br><br>  Los procesadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">80386</a> y versiones posteriores deben tener los siguientes valores en los registros de la CPU despu√©s de un reinicio: <br><br><pre>  IP 0xfff0
 Selector CS 0xf000
 CS base 0xffff0000 </pre><br>  El procesador comienza a funcionar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modo real</a> .  Volvamos un poco e intentemos entender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la segmentaci√≥n de la memoria</a> en este modo.  El modo real es compatible con todos los procesadores compatibles con x86: desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8086</a> hasta los modernos procesadores Intel de 64 bits.  El procesador 8086 utiliza un bus de direcciones de 20 bits, es decir, puede funcionar con un espacio de direcciones de <code>0-0xFFFFF</code> o <code>1 </code> .  Pero solo tiene registros de 16 bits con una direcci√≥n m√°xima de <code>2^16-1</code> o <code>0xffff</code> (64 kilobytes). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La segmentaci√≥n de memoria es</a> necesaria para usar todo el espacio de direcciones disponible.  Toda la memoria se divide en peque√±os segmentos de un tama√±o fijo de <code>65536</code> bytes (64 KB).  Dado que con los registros de 16 bits no podemos acceder a la memoria por encima de 64 KB, se desarroll√≥ un m√©todo alternativo. <br><br>  La direcci√≥n consta de dos partes: 1) un selector de segmento con una direcci√≥n base;  2) desplazamiento de la direcci√≥n base.  En modo real, la direcci√≥n base del <code>  * 16</code> segmento <code>  * 16</code> .  Por lo tanto, para obtener la direcci√≥n f√≠sica en la memoria, debe multiplicar parte del selector de segmento por 16 y agregarle el desplazamiento: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Por ejemplo, si el registro <code>CS:IP</code> tiene el valor <code>0x2000:0x0010</code> , la direcci√≥n f√≠sica correspondiente ser√° as√≠: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0x2000</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x0010</span></span>) <span class="hljs-string"><span class="hljs-string">'0x20010'</span></span></code> </pre> <br>  Pero si toma el selector del segmento m√°s grande y el desplazamiento <code>0xffff:0xffff</code> , obtiene la direcci√≥n: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  es decir, <code>65520</code> bytes despu√©s del primer megabyte.  Como solo un megabyte est√° disponible en modo real, <code>0x10ffef</code> convierte en <code>0x00ffef</code> con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la l√≠nea A20</a> desactivada. <br><br>  Bueno, ahora sabemos un poco sobre el modo real y el direccionamiento de memoria en este modo.  Volvamos a la discusi√≥n de los valores de registro despu√©s del reinicio. <br><br>  El registro <code>CS</code> consta de dos partes: un selector de segmento visible y una direcci√≥n base oculta.  Aunque la direcci√≥n base generalmente se forma multiplicando el valor del selector de segmento por 16, durante un reinicio de hardware, el selector de segmento en el registro CS es <code>0xf000</code> , y la direcci√≥n base es <code>0xffff0000</code> .  El procesador usa esta direcci√≥n base especial hasta que cambie el CS. <br><br>  La direcci√≥n inicial se forma agregando la direcci√≥n base al valor en el registro EIP: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span> + <span class="hljs-number"><span class="hljs-number">0xfff0</span></span> <span class="hljs-string"><span class="hljs-string">'0xfffffff0'</span></span></code> </pre> <br>  Obtenemos <code>0xfffffff0</code> , que es 16 bytes por debajo de 4 GB.  Este punto se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un vector de reinicio</a> .  Esta es la ubicaci√≥n en la memoria donde la CPU espera a que se ejecute la primera instrucci√≥n despu√©s de un reinicio: una operaci√≥n de salto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jmp</a> ), que generalmente indica el punto de entrada del BIOS.  Por ejemplo, si observa el c√≥digo fuente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">coreboot</a> ( <code>src/cpu/x86/16bit/reset16.inc</code> ), veremos: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> "<span class="hljs-selector-class"><span class="hljs-selector-class">.reset</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">ax</span></span>", %<span class="hljs-selector-tag"><span class="hljs-selector-tag">progbits</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.code16</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xe9</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.int</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start16bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> ( . + 2 ) ...</code> </pre> <br>  Aqu√≠ vemos el c√≥digo de operaci√≥n ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">opcode</a> ) <code>jmp</code> , concretamente <code>0xe9</code> , y la direcci√≥n de destino <code>_start16bit - ( . + 2)</code> . <br><br>  Tambi√©n vemos que la secci√≥n de <code>reset</code> tiene 16 bytes, y se compila para ejecutarse desde la direcci√≥n <code>0xfffff0</code> ( <code>src/cpu/x86/16bit/reset16.ld</code> ): <br><br><pre> <code class="hljs pgsql">SECTIONS { <span class="hljs-comment"><span class="hljs-comment">/* Trigger an error if I have an unuseable start address */</span></span> _bogus = <span class="hljs-keyword"><span class="hljs-keyword">ASSERT</span></span>(_start16bit &gt;= <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span>, "_start16bit too low. Please report."); _ROMTOP = <span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span>; . = _ROMTOP; .<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> . : { *(.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>); . = <span class="hljs-number"><span class="hljs-number">15</span></span>; BYTE(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); } }</code> </pre> <br>  El BIOS ahora se inicia;  Despu√©s de inicializar y verificar el hardware del BIOS, debe encontrar el dispositivo de arranque.  El orden de arranque se guarda en la configuraci√≥n del BIOS.  Al intentar arrancar desde el disco duro, el BIOS intenta encontrar el sector de arranque.  En los discos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">particionados MBR</a> , el sector de arranque se almacena en los primeros 446 bytes del primer sector, donde cada sector es de 512 bytes.  Los dos √∫ltimos bytes del primer sector son <code>0x55</code> y <code>0xaa</code> .  Le muestran al BIOS que es un dispositivo de arranque. <br><br>  Por ejemplo: <br><br><pre> <code class="hljs powershell">; ; :       Intel x86 ; [<span class="hljs-type"><span class="hljs-type">BITS</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>] boot: mov al, <span class="hljs-string"><span class="hljs-string">'!'</span></span> mov ah, <span class="hljs-number"><span class="hljs-number">0</span></span>x0e mov bh, <span class="hljs-number"><span class="hljs-number">0</span></span>x00 mov bl, <span class="hljs-number"><span class="hljs-number">0</span></span>x07 int <span class="hljs-number"><span class="hljs-number">0</span></span>x10 jmp <span class="hljs-variable"><span class="hljs-variable">$</span></span> times <span class="hljs-number"><span class="hljs-number">510</span></span>-(<span class="hljs-variable"><span class="hljs-variable">$</span></span>-<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span>) db <span class="hljs-number"><span class="hljs-number">0</span></span> db <span class="hljs-number"><span class="hljs-number">0</span></span>x55 db <span class="hljs-number"><span class="hljs-number">0</span></span>xaa</code> </pre> <br>  Recopilamos y ejecutamos: <br><br> <code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot</code> <br> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">QEMU</a> recibe un comando para usar el binario de <code>boot</code> que acabamos de crear como imagen de disco.  Dado que el archivo binario generado anteriormente satisface los requisitos del sector de arranque (comenzando en <code>0x7c00</code> y terminando con una secuencia m√°gica), QEMU considerar√° el binario como el registro de arranque maestro (MBR) de la imagen del disco. <br><br>  Ver√°s <br><br><img src="https://habrastorage.org/webt/e1/rk/nw/e1rknwgwcuouazuhzrmco1b8szg.png"><br><br>  En este ejemplo, vemos que el c√≥digo se ejecuta en modo real de 16 bits y comienza en la direcci√≥n <code>0x7c00</code> en la memoria.  Despu√©s de comenzar, provoca una interrupci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">0x10</a> , ¬°que simplemente imprime un personaje <code>!</code>  ;  llena los 510 bytes restantes con ceros y termina con dos bytes m√°gicos <code>0xaa</code> y <code>0x55</code> . <br><br>  Puede ver el volcado binario con la utilidad <code>objdump</code> : <br><br> <code>nasm -f bin boot.nasm <br> objdump -D -b binary -mi386 -Maddr16,data16,intel boot</code> <br> <br>  Por supuesto, en el sector de arranque real, hay un c√≥digo para continuar el proceso de arranque y una tabla de partici√≥n en lugar de un mont√≥n de ceros y un signo de exclamaci√≥n :).  Desde este momento, el BIOS transfiere el control al gestor de arranque. <br><br>  <i>Nota</i> : como se explic√≥ anteriormente, la CPU est√° en modo real;  donde el c√°lculo de la direcci√≥n f√≠sica en la memoria es el siguiente: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  Tenemos solo registros de prop√≥sito general de 16 bits, y el valor m√°ximo del registro de 16 bits es <code>0xffff</code> , por lo que en los valores m√°s grandes el resultado ser√°: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  donde <code>0x10ffef</code> es <code>1  + 64  - 16 </code> .  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">procesador 8086</a> (el primer procesador con modo real) tiene una l√≠nea de direcci√≥n de 20 bits.  Como <code>2^20 = 1048576</code> , la memoria disponible real es de 1 MB. <br><br>  En general, el direccionamiento de memoria en modo real es el siguiente: <br><br><pre>  0x00000000 - 0x000003FF - tabla de vectores de interrupci√≥n del modo real
 0x00000400 - 0x000004FF - √Årea de datos del BIOS
 0x00000500 - 0x00007BFF - no utilizado
 0x00007C00 - 0x00007DFF - nuestro gestor de arranque
 0x00007E00 - 0x0009FFFF - no utilizado
 0x000A0000 - 0x000BFFFF - RAM de video (VRAM) 
 0x000B0000 - 0x000B7777 - memoria de video monocroma
 0x000B8000 - 0x000BFFFF - memoria de video en modo color
 0x000C0000 - 0x000C7FFF - BIOS de video ROM
 0x000C8000 - 0x000EFFFF - √°rea de sombra (BIOS Shadow)
 0x000F0000 - 0x000FFFFF - BIOS del sistema </pre><br>  Al comienzo del art√≠culo, est√° escrito que la primera instrucci√≥n para el procesador se encuentra en <code>0xFFFFFFF0</code> , que es mucho m√°s que <code>0xFFFFF</code> (1 MB).  ¬øC√≥mo puede la CPU acceder a esta direcci√≥n en modo real?  Responda en la documentaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">coreboot</a> : <br><br> <code>0xFFFE_0000 - 0xFFFF_FFFF: 128  ROM    </code> <br> <br>  Al comienzo de la ejecuci√≥n, el BIOS no est√° en RAM, sino en ROM. <br><br><h1>  Cargador de arranque </h1><br>  El kernel de Linux se puede cargar con diferentes cargadores de arranque, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GRUB 2</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">syslinux</a> .  El kernel tiene un protocolo de arranque que define los requisitos del cargador de arranque para implementar el soporte de Linux.  En este ejemplo, estamos trabajando con GRUB 2. <br><br>  Continuando con el proceso de arranque, el BIOS seleccion√≥ el dispositivo de arranque y transfiri√≥ el control al sector de arranque, la ejecuci√≥n comienza con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">boot.img</a> .  Debido a su tama√±o limitado, este es un c√≥digo muy simple.  Contiene un puntero para ir a la imagen principal de GRUB 2. Comienza con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diskboot.img</a> y generalmente se almacena inmediatamente despu√©s del primer sector en el espacio no utilizado antes de la primera partici√≥n.  El c√≥digo anterior carga en la memoria el resto de la imagen que contiene el n√∫cleo GRUB 2 y los controladores para procesar los sistemas de archivos.  Despu√©s de eso, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecuta la</a> funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grub_main</a> . <br><br>  La funci√≥n <code>grub_main</code> inicializa la consola, devuelve la direcci√≥n base de los m√≥dulos, establece el dispositivo ra√≠z, carga / analiza el archivo de configuraci√≥n de grub, carga los m√≥dulos, etc.  Al final de la ejecuci√≥n, pone grub en modo normal.  La funci√≥n <code>grub_normal_execute</code> (del archivo fuente <code>grub-core/normal/main.c</code> ) completa los √∫ltimos preparativos y muestra un men√∫ para elegir el sistema operativo.  Cuando seleccionamos uno de los elementos del men√∫ grub, se <code>grub_menu_execute_entry</code> funci√≥n <code>grub_menu_execute_entry</code> , que ejecuta el comando de <code>boot</code> grub y carga el sistema operativo seleccionado. <br><br>  Como se indica en el protocolo de arranque del n√∫cleo, el gestor de arranque debe leer y completar algunos campos del encabezado de instalaci√≥n del n√∫cleo, que comienza en el desplazamiento <code>0x01f1</code> del c√≥digo de instalaci√≥n del n√∫cleo.  Este desplazamiento se indica en el <a href="">script del vinculador</a> .  El encabezado del n√∫cleo <a href="">arch / x86 / boot / header.S</a> comienza con: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup_sects</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_flags</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ROOT_RDONLY</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">syssize</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ram_size</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">vid_mode</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SVGA_MODE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_dev</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">boot_flag</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xAA55</span></span></code> </pre> <br>  El gestor de arranque debe llenar este y otros encabezados (que est√°n marcados solo como <code>write</code> tipo en el protocolo de arranque de Linux, como en este ejemplo) con valores que se reciben desde la l√≠nea de comandos o se calculan en el momento del arranque.  Ahora no nos detendremos en las descripciones y explicaciones para todos los campos de encabezado.  M√°s adelante discutiremos c√≥mo los usa el n√∫cleo.  Para obtener una descripci√≥n de todos los campos, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el protocolo de descarga</a> . <br><br>  Como puede ver en el protocolo de arranque del n√∫cleo, la memoria se mostrar√° de la siguiente manera: <br><br><pre>  El |  Modo Kernel protegido |
 100000 + ------------------------ +
          El |  Mapeo de E / S |
 0A0000 + ------------------------ +
          El |  Reserva  para BIOS |  Deja todo lo posible libre
          ~ ~
          El |  L√≠nea de comando |  (tambi√©n puede estar por debajo de X + 10000)
 X + 10000 + ------------------------ +
          El |  Pila / Mont√≥n |  Para usar c√≥digo de modo de n√∫cleo real
 X + 08000 + ------------------------ +
          El |  Instalaci√≥n de Kernel |  C√≥digo de modo real del kernel
          El |  Sector de arranque del n√∫cleo |  Sector de arranque de kernel heredado
        X + ------------------------ +
          El |  Cargador |  &lt;- Punto de entrada 0x7C00 sector de arranque
 001000 + ------------------------ +
          El |  Reserva  para MBR / BIOS |
 000800 + ------------------------ +
          El |  Usualmente uso  MBR |
 000600 + ------------------------ +
          El |  Usado  Solo BIOS |
 000000 + ------------------------ +
</pre><br>  Entonces, cuando el cargador transfiere el control al n√∫cleo, comienza con la direcci√≥n: <br><br><pre> <code class="hljs lisp">X + sizeof (<span class="hljs-name"><span class="hljs-name">KernelBootSector</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  donde <code>X</code> es la direcci√≥n del sector de arranque del kernel.  En nuestro caso, <code>X</code> es <code>0x10000</code> , como se ve en el volcado de memoria: <br><br><img src="https://habrastorage.org/webt/ot/1u/ep/ot1uepwbgvghzktwcbwwskwwjbs.png"><br><br>  El gestor de arranque movi√≥ el kernel de Linux a la memoria, rellen√≥ los campos de encabezado y luego se movi√≥ a la direcci√≥n de memoria correspondiente.  Ahora podemos ir directamente al c√≥digo de instalaci√≥n del n√∫cleo. <br><br><h1>  Comienzo de la fase de instalaci√≥n del n√∫cleo. </h1><br>  ¬°Finalmente estamos en el centro!  Aunque t√©cnicamente a√∫n no se est√° ejecutando.  Primero, la parte de instalaci√≥n del kernel necesita configurar algo, incluido un descompresor y algunas cosas con la administraci√≥n de memoria.  Despu√©s de todo esto, ella desempaquetar√° el n√∫cleo real e ir√° a √©l.  La instalaci√≥n comienza en <a href="">arch / x86 / boot / header.S</a> con el car√°cter <a href="">_start</a> . <br><br>  A primera vista, esto puede parecer un poco extra√±o, ya que hay varias instrucciones en frente de √©l.  Pero hace mucho tiempo, el kernel de Linux ten√≠a su propio gestor de arranque.  Ahora si corres, por ejemplo, <br><br> <code>qemu-system-x86_64 vmlinuz-3.18-generic</code> <br> <br>  ver√°s: <br><br><img src="https://habrastorage.org/webt/4r/5f/xg/4r5fxgpwl4l2vwlw9muscl3ygie.png"><br><br>  En realidad, el archivo de <code>header.S</code> comienza con el n√∫mero m√°gico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MZ</a> (vea la captura de pantalla del volcado anterior), el texto del mensaje de error y el encabezado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PE</a> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#ifdef</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CONFIG_EFI_STUB</span></span> # "<span class="hljs-selector-tag"><span class="hljs-selector-tag">MZ</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">MS-DOS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x4d</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x5a</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span> ... ... ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">pe_header</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.ascii</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">PE</span></span>" <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0</code> </pre> <br>  Es necesario cargar un sistema operativo con soporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UEFI</a> .  Consideraremos su dispositivo en los siguientes cap√≠tulos. <br><br>  Punto de entrada real para instalar el n√∫cleo: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// header.S line 292 .globl _start _start:</span></span></code> </pre> <br>  El gestor de arranque (grub2 y otros) conoce este punto (desplazamiento <code>0x200</code> de <code>MZ</code> ) y va directamente a √©l, aunque el <code>header.S</code> comienza desde la secci√≥n <code>.bstext</code> , donde se encuentra el texto del mensaje de error: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ arch/x</span></span>86/boot/setup.ld /<span class="hljs-regexp"><span class="hljs-regexp">/ . = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ current position .bstext : { *(.bstext) } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ put .bstext section to position 0 .bsdata : { *(.bsdata) }</span></span></code> </pre> <br>  Punto de entrada de instalaci√≥n del n√∫cleo: <br><br><pre> <code class="hljs go"> .globl _start _start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// // rest of the header //</span></span></code> </pre> <br>  Aqu√≠ vemos el c√≥digo de operaci√≥n <code>jmp</code> ( <code>0xeb</code> ), que va al punto <code>start_of_setup-1f</code> .  En la notaci√≥n <code>Nf</code> , por ejemplo, <code>2f</code> refiere a la etiqueta local <code>2:</code>  En nuestro caso, esta es la etiqueta <code>1</code> , que est√° presente inmediatamente despu√©s de la transici√≥n, y contiene el resto del encabezado de configuraci√≥n.  Inmediatamente despu√©s del encabezado de instalaci√≥n, vemos la secci√≥n <code>.entrytext</code> , que comienza con la etiqueta <code>start_of_setup</code> . <br><br>  Este es el primer c√≥digo realmente ejecutado (aparte de las instrucciones de salto anteriores, por supuesto).  Despu√©s de que parte de la instalaci√≥n del n√∫cleo recibe el control del cargador, la primera instrucci√≥n <code>jmp</code> se encuentra en el desplazamiento <code>0x200</code> desde el comienzo del modo de n√∫cleo real, es decir, despu√©s de los primeros 512 bytes.  Esto se puede ver tanto en el protocolo de arranque del kernel de Linux como en el c√≥digo fuente de grub2: <br><br><pre> <code class="hljs ruby">segment = grub_linux_real_target <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">4</span></span>; state.gs = state.fs = state.es = state.ds = state.ss = segment; state.cs = segment + <span class="hljs-number"><span class="hljs-number">0x20</span></span>;</code> </pre> <br>  En nuestro caso, el kernel arranca en la direcci√≥n <code>0x10000</code> .  Esto significa que despu√©s de comenzar la instalaci√≥n del n√∫cleo, los registros de segmento tendr√°n los siguientes valores: <br><br> <code>gs = fs = es = ds = ss = 0x10000 <br> cs = 0x10200</code> <br> <br>  Despu√©s de ir a <code>start_of_setup</code> n√∫cleo debe hacer lo siguiente: <br><br><ul><li>  Aseg√∫rese de que todos los valores de registro de segmento sean iguales </li><li>  Si es necesario, configure la pila correcta </li><li>  Configurar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bss</a> </li><li>  Vaya al c√≥digo C en <a href="">arch / x86 / boot / main.c</a> </li></ul><br>  Veamos c√≥mo se implementa esto. <br><br><h1>  Alineaci√≥n de may√∫sculas y min√∫sculas </h1><br>  En primer lugar, el n√∫cleo verifica que los registros del segmento <code>ds</code> y <code>es</code> apuntan a la misma direcci√≥n.  Luego borra la bandera de direcci√≥n usando la <code>cld</code> : <br><br><pre> <code class="hljs perl"> movw %ds, %ax movw %ax, %es cld</code> </pre> <br>  Como escrib√≠ anteriormente, grub2 por defecto carga el c√≥digo de instalaci√≥n del n√∫cleo en <code>0x10000</code> y <code>cs</code> en <code>0x10200</code> , porque la ejecuci√≥n no comienza desde el principio del archivo, sino desde la transici√≥n aqu√≠: <br><br><pre> <code class="hljs go">_start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span></code> </pre> <br>  Este es un desplazamiento de <code>512</code> bytes de <a href="">4d 5a</a> .  Tambi√©n es necesario alinear <code>cs</code> de <code>0x10200</code> a <code>0x10000</code> , como todos los dem√°s registros de segmento.  Despu√©s de eso, instale la pila: <br><br><pre> <code class="hljs perl"> pushw %ds pushw $6f lretw</code> </pre> <br>  Esta instrucci√≥n empuja el valor <code>ds</code> a la pila, seguido de la direcci√≥n de la etiqueta <a href="">6</a> y la instrucci√≥n <code>lretw</code> , que carga la direcci√≥n de la etiqueta <code>6</code> en el registro del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contador de comandos</a> y carga <code>cs</code> con el valor <code>ds</code> .  Despu√©s de eso, <code>ds</code> y <code>cs</code> tendr√°n los mismos valores. <br><br><h1>  Configuraci√≥n de pila </h1><br>  Casi todo este c√≥digo es parte del proceso de preparaci√≥n del entorno C en modo real.  El siguiente paso es verificar el valor del registro <code>ss</code> y crear la pila correcta si el valor <code>ss</code> es incorrecto: <br><br><pre> <code class="hljs perl"> movw %ss, %dx cmpw %ax, %dx movw %sp, %dx je <span class="hljs-number"><span class="hljs-number">2</span></span>f</code> </pre> <br>  Esto puede desencadenar tres escenarios diferentes: <br><br><ul><li>  <code>ss</code> valor v√°lido de <code>0x1000</code> (como con todos los dem√°s registros excepto <code>cs</code> ) </li><li>  <code>ss</code> valor no v√°lido y se establece el indicador <code>CAN_USE_HEAP</code> (ver m√°s abajo) </li><li>  <code>ss</code> valor no v√°lido y el indicador <code>CAN_USE_HEAP</code> no <code>CAN_USE_HEAP</code> configurado (ver m√°s abajo) </li></ul><br>  Considere todos los escenarios en orden: <br><br><ul><li>  <code>ss</code> valor v√°lido ( <code>0x1000</code> ).  En este caso, vamos a la etiqueta 2: </li></ul><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">2</span></span>: andw $~<span class="hljs-number"><span class="hljs-number">3</span></span>, %dx jnz <span class="hljs-number"><span class="hljs-number">3</span></span>f movw $0xfffc, %dx <span class="hljs-number"><span class="hljs-number">3</span></span>: movw %ax, %ss movzwl %dx, %esp sti</code> </pre> <br>  Aqu√≠ establecemos la alineaci√≥n del registro <code>dx</code> (que contiene el valor <code>sp</code> indicado por el gestor de arranque) en <code>4</code> bytes y verificamos si hay cero.  Si es cero, entonces ponemos el valor <code>0xfffc</code> <code>dx</code> (direcci√≥n alineada de <code>4</code> bytes antes del tama√±o m√°ximo de segmento de 64 KB).  Si no es igual a cero, entonces continuamos usando el valor <code>sp</code> especificado por el gestor de arranque ( <code>0xf7f4</code> en nuestro caso).  Luego colocamos el valor del <code>0x1000</code> en <code>ss</code> , que guarda la direcci√≥n de segmento correcta <code>0x1000</code> y establece el <code>sp</code> correcto.  Ahora tenemos la pila correcta: <br><br><img src="https://habrastorage.org/webt/wf/dp/bl/wfdpblqpiltzdrprytvnoj3kygo.png"><br><br><ul><li>  En el segundo escenario, <code>ss != ds</code> .  Primero colocamos el valor <a href="">_end</a> (la direcci√≥n del final del c√≥digo de instalaci√≥n) en <code>dx</code> y verificamos los <code>loadflags</code> campo de <code>loadflags</code> , usando la instrucci√≥n <code>testb</code> para verificar si se puede usar el mont√≥n.  <a href="">loadflags</a> es un encabezado de m√°scara de bits que se define de la siguiente manera: </li></ul><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOADED_HIGH (1&lt;&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUIET_FLAG (1&lt;&lt;5) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEEP_SEGMENTS (1&lt;&lt;6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAN_USE_HEAP (1&lt;&lt;7)</span></span></code> </pre> <br>  y como se indica en el protocolo de arranque: <br><br> <code> : loadflags <br> <br>     . <br> <br>  7 (): CAN_USE_HEAP <br>     1,  ,   <br> heap_end_ptr .    ,   <br>   .</code> <br> <br>  Si se establece el bit <code>CAN_USE_HEAP</code> , en <code>dx</code> establecemos el valor <code>heap_end_ptr</code> (que apunta a <code>_end</code> ) y le agregamos <code>STACK_SIZE</code> (el tama√±o m√≠nimo de la pila es <code>1024</code> bytes).  Despu√©s de eso, vaya a la etiqueta <code>2</code> (como en el caso anterior) y haga la pila correcta. <br><br><img src="https://habrastorage.org/webt/1n/be/nw/1nbenww3ncnipvbi1g-jqdvsmok.png"><br><br><ul><li>  Si <code>CAN_USE_HEAP</code> no <code>CAN_USE_HEAP</code> configurado, solo use la pila m√≠nima de <code>_end</code> a <code>_end + STACK_SIZE</code> : </li></ul><br><img src="https://habrastorage.org/webt/5x/xg/fi/5xxgfikk1iskr_6pgjzvmcwhpjy.png"><br><br><h1>  Configuraci√≥n de BSS </h1><br>  Se necesitan dos pasos m√°s antes de pasar al c√≥digo C principal: esto es configurar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rea BSS</a> y verificar la firma "m√°gica".  Verificaci√≥n de firma primero: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">cmpl</span></span> <span class="hljs-variable"><span class="hljs-variable">$0</span></span>x5a5aaa55, setup_sig jne setup_bad</code> </pre> <br>  La instrucci√≥n simplemente compara <a href="">setup_sig</a> con el n√∫mero m√°gico 0x5a5aaa55.  Si no son iguales, se informa un error fatal. <br><br>  Si el n√∫mero m√°gico coincide y tenemos un conjunto de registros de segmento correctos y una pila, todo lo que queda es configurar la secci√≥n BSS antes de pasar al c√≥digo C. <br><br>  La secci√≥n BSS se utiliza para almacenar datos no inicializados asignados est√°ticamente.  Linux comprueba cuidadosamente que esta √°rea de memoria se restablece: <br><br><pre> <code class="hljs perl"> movw $__bss_start, %di movw $_end+<span class="hljs-number"><span class="hljs-number">3</span></span>, %cx xorl %eax, %eax subw %di, %cx shrw $2, %cx rep; stosl</code> </pre> <br>  Primero, la direcci√≥n de inicio de <a href="">__bss_start se</a> mueve a <code>di</code> .  Luego, la direcci√≥n <code>_end + 3</code> (+3 para la alineaci√≥n de 4 bytes) se mueve a <code>cx</code> .  El registro <code>eax</code> se borra (usando la instrucci√≥n <code>xor</code> ), se calcula el tama√±o de la partici√≥n bss ( <code>cx-di</code> ) y se coloca en <code>cx</code> .  Luego, <code>cx</code> se divide en cuatro (el tama√±o de la "palabra") y la instrucci√≥n <code>stosl</code> se usa <code>stosl</code> , almacenando el valor <code></code> (cero) en la direcci√≥n que apunta a <code>di</code> , aumentando autom√°ticamente <code>di</code> por cuatro y repitiendo esto hasta que <code></code> llegue a cero).  El efecto neto de este c√≥digo es que los ceros se escriben en todas las palabras en la memoria desde <code>__bss_start</code> hasta <code>_end</code> : <br><br><img src="https://habrastorage.org/webt/2s/bw/ym/2sbwymhai1qislpkru0btkrolcy.png"><br><br><h1>  Ir a principal </h1><br>  Eso es todo: tenemos una pila y BSS, por lo que puede ir a la funci√≥n <code>main()</code> C: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">calll</span></span> main</code> </pre> <br>  La funci√≥n <code>main()</code> se encuentra en <a href="">arch / x86 / boot / main.c.</a>  Hablaremos de ella en la pr√≥xima parte. <br><br><h1>  Conclusi√≥n </h1><br>  Este es el final de la primera parte sobre el dispositivo kernel de Linux.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tiene preguntas o sugerencias, cont√°cteme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">correo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o simplemente cree un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ticket</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En la siguiente parte veremos el primer c√≥digo en C, que se realiza durante la instalaci√≥n del kernel de Linux, la ejecuci√≥n de los subprogramas de memoria, como </font></font><code>memset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>earlyprintk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aplicaci√≥n temprana y la inicializaci√≥n de la consola, y m√°s.</font></font><br><br><h1>  Referencias </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel 80386 Referencia del programador 1986</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√≠nimo gestor de arranque para arquitectura Intel</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8086</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80386</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Restablecer vector</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modo real</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolo de arranque del kernel de Linux</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gu√≠a para desarrolladores de Coreboot</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de interrupciones de Ralph Brown</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente de poder</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se√±al "El poder est√° bien"</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428664/">https://habr.com/ru/post/es428664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428654/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 15: Software m√©dico, Parte 2</a></li>
<li><a href="../es428656/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 15: Software m√©dico, Parte 3</a></li>
<li><a href="../es428658/index.html">Talleres educativos gratuitos en la oficina de Mail.Ru Group</a></li>
<li><a href="../es428660/index.html">Habilitaci√≥n de pol√≠ticas de solicitud de extracci√≥n extensible en VSTS para respaldar el proceso de desarrollo</a></li>
<li><a href="../es428662/index.html">Tarea de programaci√≥n minorista</a></li>
<li><a href="../es428666/index.html">C√≥mo cre√© animaciones que cambian el estado de √°nimo usando m√°scaras CSS</a></li>
<li><a href="../es428668/index.html">Blizzard anunci√≥ el lanzamiento del relanzamiento de WarCraft III en 2019. Pre-pedido abierto</a></li>
<li><a href="../es428672/index.html">Descripci√≥n general del silenciador activo QuietOn</a></li>
<li><a href="../es428674/index.html">Creaci√≥n de enrutamiento de clientes / b√∫squeda sem√°ntica en Profi.ru</a></li>
<li><a href="../es428676/index.html">Romper los fundamentos fundamentales de C #: asignar memoria para un tipo de referencia en la pila</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>