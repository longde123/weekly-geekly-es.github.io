<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛅 🌫️ 🅿️ Rahasia bekerja dengan kain di game Alan Wake 🗄️ 👌🏼 ✊🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Pemulihan program animasi Henrik Enquist menggambarkan bagaimana timnya menciptakan simulasi jas wol yang menarik dari protagonis thriller horor Alan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rahasia bekerja dengan kain di game Alan Wake</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458486/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/18e/a10/c1818ea10be738aafeb51e0157ad247b.jpg"></div><br>  <em>[Pemulihan program animasi Henrik Enquist menggambarkan bagaimana timnya menciptakan simulasi jas wol yang menarik dari protagonis thriller horor Alan Wake.]</em> <br><br>  Karakter utama dari action thriller kami adalah Alan Wake, seorang penulis yang jatuh ke dalam mimpi buruk, di mana ia dipaksa untuk bertarung dengan kekuatan gelap dan memecahkan misteri kepergian istrinya.  Dia bukan pahlawan aksi yang terlatih, tetapi orang biasa. <br><br>  Untuk menekankan karakternya, direktur seni kami ingin mendandaninya dengan jaket wol tua dengan tambalan di sikunya.  Permainan berlangsung di rombongan dunia nyata, oleh karena itu, tidak seperti permainan fantasi atau penembak ruang, karakter terbatas pada alat yang digunakan.  Dan ini berarti bahwa pakaian karakter kita menjadi jauh lebih penting. <br><br>  Untuk menyampaikan ilusi atmosfer thriller, jaket Alan Wake harus bisa dipercaya semaksimal mungkin.  Jaket harus berkibar di angin dan menambahkan gerakan tambahan ke karakter saat bergerak melalui hutan.  Sebagai seorang programmer, saya segera mulai berpikir tentang menggunakan simulasi jaringan. <br><br>  Simulasi kain digunakan di banyak permainan sebelum kita, tetapi teknik yang sering digunakan di sana memberi perasaan sutra atau karet - bahan yang tidak cocok untuk kita.  Hanya baru-baru ini sistem simulasi jaringan yang sangat baik dari perusahaan pihak ketiga mulai muncul, tetapi pada saat kami membutuhkan solusi yang stabil, alat-alat seperti itu belum ada, atau mereka tidak memenuhi kebutuhan kami. <br><br>  Pada artikel ini, saya akan berbicara tentang masalah yang harus kita hadapi, dan tentang solusi untuk membuat simulasi jaringan kita sendiri. <br><a name="habracut"></a><br><h1>  Rig jaket </h1><br>  Jaket dimodelkan bersama dengan sisa karakter seperti jala skinning biasa.  Tulang yang mengendalikan jala jaket adalah lapisan terpisah di atas kerangka biasa.  Lengan jaket menggunakan pola biasa untuk bahu dan lengan.  Baik bahu dan lengan dibagi menjadi satu tulang utama dan satu tulang bengkok.  Bagian atas jaket dikontrol oleh kendala penglihatan, dan bagian bawah dikontrol oleh simulasi Verlet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c2/6a6/63c/0c26a663c171f554b18e4bd555601477.png"></div><br>  <strong>Gambar 1. Jaket rig di atas kerangka permainan biasa.</strong> <br><br><h1>  Jaket atas </h1><br>  Tulang jaket memiliki hierarki yang berjalan dari atas ke bawah (yang lebih rendah adalah anak-anak dari yang atas), jadi ketika tulang atas bergerak, tulang yang lebih rendah mengikutinya.  Kami tergoda untuk membuat tulang bawah anak perempuan langsung ke dada, tetapi itu akan menyebabkan hilangnya gerakan, terutama gerakan vertikal, ketika karakter mengangkat bahunya. <br><br>  Di bagian atas jaket, kami mensimulasikan gerakan bantalan di bahu, menggerakkan tulang pundak dengan bantuan melihat kendala ke arah tulang pundak.  Berkat ini, bantalan mengikuti bahu, dan ketika Anda mengangkat tangan, bantalan mengangkat sisa tulang, seperti di jaket sungguhan. <br><br><div class="spoiler">  <b class="spoiler_title">Seperti apa kendala melihat-lihat costraint</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/206/2a0/3af/2062a03af21d6458b3d9b2a278223b83.gif" alt="gambar"></div><br>  <b>Lihat biaya yang diterapkan pada kerucut merah</b> </div></div><br>  Tulang berikutnya dalam rantai adalah lapisan antara bagian atas jaket dan bagian bawah yang disimulasikan.  Tulang-tulang ini digerakkan langsung oleh kendala penglihatan ke bawah untuk mengimbangi rotasi yang dibuat bahu.  Kami juga menambahkan batasan posisi antara tulang kiri dan kanan untuk mengimbangi peregangan yang terjadi ketika bantalan bahu bergerak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/085/686/dc2/085686dc265664fe90ab7659a199f7e0.png"></div><br>  <strong>Gambar 2. Gerakan tulang saat mengangkat karakter tangan.</strong> <br><br>  Ini bisa cukup untuk menerapkan pembatasan dalam pengekspor animasi dan memanggang hasilnya dalam data animasi, tetapi kami masih mencoba untuk mengontrol tulang-tulang di mesin game secara real time. <br><br>  Berkat ini, kami dapat menyimpan beberapa byte dalam data animasi, serta dengan mudah mentransfer animasi antar karakter, terlepas dari apakah ada jaket di dalamnya.  Selain itu, gerakan bahu yang dihasilkan oleh kinematika terbalik permainan (misalnya, pada saat membidik) ketika menyelesaikan kendala waktu nyata akan diterapkan dengan benar. <br><br><h1>  Bagian bawah jaket </h1><br>  Setelah menyelesaikan masalah dengan bagian atas jaket, kami melanjutkan untuk mensimulasikan bagian bawah.  Sebagian besar game simulasi kain menggunakan satu-ke-satu yang mengikat antara simpul dalam simulasi jaringan dan simpul dari mesh yang diberikan. <br><br>  Kami ingin menjaga keakuratan jaket agar tidak mengganggu batasan yang ditentukan oleh programmer.  Sebagai contoh, jika kami memutuskan untuk menggunakan mesh yang sama untuk simulasi kain seperti untuk rendering, maka siluet kantong dan bagian depan jaket akan hilang. <br><br>  Peta normal dapat digunakan untuk memberikan volume pada jaket, tetapi kami merasa itu tidak akan cukup.  Kami ingin seniman kami membuat model jaket seperti yang mereka inginkan, dan kemudian membiarkan mereka menggunakan peta normal untuk menambahkan lipatan atau detail lainnya, alih-alih mengimbangi hilangnya geometri. <br><br>  Kami sampai pada keputusan ini: membuat mesh kain resolusi rendah untuk mensimulasikan jaket, dan kemudian menempelkannya pada tulang kerangka yang digunakan untuk mengontrol mesh skinning. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/011/cf3/4e2/011cf34e28fedf303ecc5a62ee15a7b0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f4/bd8/582/2f4bd8582bc2c876c24a6a0663784938.png"></div><br>  <strong>Gambar 3. Perbandingan siluet jaket dan kain kami yang memiliki simpul yang sama dengan simulasi.</strong> <br><br><h1>  Fisika Werle </h1><br>  Pertama kita melihat fisika Verlet, dan kemudian kita belajar cara membuat kecocokan untuk simulasi tulang.  Verlé Physics saat ini merupakan solusi standar untuk mensimulasikan kain dalam permainan.  Jika Anda tidak terbiasa dengan teknik Verlet, maka pertama-tama saya sarankan membaca salah satu artikel ini di Gamasutra: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Iblis dalam Gaun Berwajah Biru: Animasi Kain Real Time</u></a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Fisika Karakter Tingkat Lanjut</u></a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/348/0d0/c623480d0de44a9ae1041f6c2ba9a5e0.png"></div><br>  <strong>Gambar 4. Kisi simpul 4x4 dan batasan untuk salah satu simpul.</strong> <br><br>  Selebihnya, saya akan mengulangi prinsip kerja secara singkat.  Gambar 4 menunjukkan mesh kain dan kendala pegas untuk salah satu simpulnya.  Seperti yang dapat Anda lihat dari gambar, setiap simpul jala terhubung ke semua simpul tetangga, serta ke tetangga mereka. <br><br>  Batasan dari tetangga terdekat disebut stretch stretch dan ditandai dengan warna biru.  Batasan panjang yang ditunjukkan dengan warna merah disebut batasan geser / tikungan. <br><br>  Penting untuk menyimpan pembatasan ini dalam dua grup, karena nanti kita akan menyelesaikannya dengan parameter yang berbeda.  Harap dicatat bahwa di jaket kami, baris teratas dari titik-titik kain terikat pada karakter dengan menguliti dan tidak akan dikendalikan oleh simulasi. <br><br>  Kehadiran mesh mesh bukan persyaratan algoritma itu sendiri, namun, untuk mensimulasikan kain dengan topologi seperti itu, paling mudah untuk bekerja dengannya.  Landasan simulasi jaringan terdiri dari dua bagian.  Bagian pertama adalah integrasi Verlet, di mana kami menghitung kecepatan untuk setiap titik dan menerapkannya pada posisi. <br><br><pre><code class="cpp hljs">Vector3 vVelocity = vertex.vCurrentPosition - vertex.vPreviousPosition; vertex.vPreviousPosition = vertex.vCurrentPosition; vertex.vCurrentPosition += vVelocity * ( <span class="hljs-number"><span class="hljs-number">1.0f</span></span> - fDampingFactor ) + vAcceleration * fDeltaTime * fDeltaTime;</code> </pre> <br>  Dalam proyek kami, <code>vAcceleration</code> ditentukan oleh jumlah gaya gravitasi dan angin.  Atenuasi digunakan untuk menyesuaikan tampilan jaket, dan untuk menstabilkan simulasi.  Faktor redaman tinggi <code>fDampingFactor</code> memberi jaket perasaan kain yang sangat ringan turun perlahan dan mulus, sementara faktor redaman rendah membuat jaket lebih berat, menyebabkannya bergoyang / berosilasi lebih lama setelah gerakan. <br><br>  Bagian kedua dari algoritma adalah resolusi kendala pegas (proses ini disebut relaksasi).  Untuk setiap kendala, kami menarik atau menolak simpul dari satu sama lain sehingga mereka memenuhi panjang aslinya.  Berikut ini cuplikan kode yang dapat dibaca. <br><br><pre> <code class="cpp hljs">Vector3 vDelta = constraint.m_vertex1.m_vCurPos - constraint.m_vertex0.m_vCurPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fLength = vDelta.length(); vDelta.normalize(); Vector3 vOffset = vDelta * ( fLength - constraint.m_fRestLength ); constraint.m_vertex0.m_vCurrentPosition += vOffset / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; constraint.m_vertex1.m_vCurrentPosition -= vOffset / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>;</code> </pre> <br>  Batasan regangan menahan bagian atas kain bersamaan, dan batasan kemiringan / tekukan membantu mempertahankan bentuk kain.  Seperti yang Anda lihat, dengan solusi ideal untuk sistem ini, kain akan bergerak terlalu keras.  Itulah sebabnya, sebelum menyelesaikan posisi baru, kami menambahkan koefisien pada batasan kemiringan / tikungan. <br><br><pre> <code class="cpp hljs">vOffset *= fStiffness; constraint.m_vertex0.m_vCurrentPosition += vOffset / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; constraint.m_vertex1.m_vCurrentPosition -= vOffset / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>;</code> </pre> <br>  Dengan koefisien kekakuan 1,0, kain akan menjadi tidak fleksibel, dan pada 0,0, kain akan menekuk tanpa batasan. <br><br><h1>  Memperbaiki langkah waktu </h1><br>  Anda pasti sudah memperhatikan bahwa integrasi Verlet menunjukkan bahwa langkah waktu sebelumnya persis sama dengan yang saat ini;  jika tidak, kecepatan yang dihitung akan salah.  Saat menggunakan integrasi Verlet, langkah waktu variabel dapat diabaikan, tetapi resolusi kendala sangat sensitif terhadap perubahan dalam langkah waktu. <br><br>  Karena pemecah menyelesaikan masalah dengan iteratif menghindari pembatasan, mereka tidak pernah bisa diselesaikan secara ideal.  Dalam permainan, ketidaktepatan ini akan memanifestasikan dirinya sebagai peregangan, dan semakin pendek langkah waktunya, semakin sedikit peregangan yang akan dilihat pemain. <br><br>  Pada akhirnya, ini akan menjadi kompromi antara akurasi dan jumlah waktu prosesor yang dapat Anda habiskan untuk pakaian.  Jika langkah waktu tidak konstan, maka peregangan pakaian akan bervariasi, dan kami akan memasukkan getaran yang tidak diinginkan ke dalam sistem.  Lebih penting lagi, langkah waktu akan mempengaruhi indikator kekakuan dan parameter kain lainnya: semakin pendek langkah waktu, semakin kaku kain akan, bahkan ketika menggunakan koefisien kekakuan yang sama. <br><br>  Dalam praktiknya, ini berarti bahwa sebelum Anda mulai menyesuaikan penampilan pakaian dengan bantuan parameter kain, Anda sendiri harus memutuskan langkah waktu yang tetap.  Saya tahu bahwa ada permainan di mana langkah waktu variabel digunakan untuk fisika, tetapi pengalaman pribadi saya memberi tahu saya bahwa hidup menjadi lebih mudah ketika langkah waktu diperbaiki untuk fisika dan logika permainan. <br><br><h1>  Kap mesin </h1><br>  Sebelum kita masuk ke detail simulasi jaringan, mari kita lihat sekilas bagaimana kap disimulasikan.  Untuk menguliti bagian atas sungkup, kami menggunakan tulang tambahan.  Kami menciptakan pendulum dari tengah tulang ke posisi di belakang kap.  Ujung pendulum adalah satu partikel yang dikendalikan oleh fisika Verlet.  Kemudian, dengan menggunakan batasan pandang, tulang diarahkan ke pendulum. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/fdf/57a/090fdf57a84edb44d5db943b1430f2b8.png"></div><br>  <strong>Gambar 5. Hood dan pendulum.</strong> <br><br><h1>  Membuat matriks tulang </h1><br>  Tudung memberi kami petunjuk tentang apa yang harus dilakukan selanjutnya dengan bagian bawah jaket.  Kami akan menggunakan posisi vertex dalam mesh simulasi untuk menghitung transformasi tulang. <br><br>  Hal pertama yang kita lakukan adalah memetakan tulang sehingga engsel setiap tulang cocok dengan bagian atas jala yang disimulasikan.  Karena itu, tugas dari bagian matriks yang terkait dengan perpindahan akan menjadi proses yang sepele. <br><br>  Maka kita perlu menghitung matriks rotasi 3x3.  Setiap baris (atau kolom, tergantung pada konfigurasi matriks) ditentukan oleh sumbu x, y, dan z tulang. <br><br>  Kami mendefinisikan sumbu x tulang sebagai arah dari simpul dasar ke berikutnya di bawahnya.  Kemudian, sumbu y ditentukan oleh vektor dari titik di sebelah kiri ke titik di sebelah kanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/ba1/428/c0dba1428673d304dc5119e43e96e92e.png"></div><br>  <strong>Gambar 6. Tulang yang menempel pada mesh kain.</strong> <br><br>  Pada Gambar 6, sumbu x ditunjukkan dengan warna merah, dan sumbu y ditunjukkan dengan warna hijau.  Kemudian, sumbu z dihitung sebagai produk vektor dari vektor-vektor ini.  Pada akhirnya, kami juga ortonormalisasi matriks untuk menghilangkan distorsi dalam data perpindahan. <br><br>  Seperti yang Anda lihat, dalam arah vertikal, kami menggunakan setiap baris dari jalinan kain (kecuali yang terakhir) untuk menyesuaikan tulang, tetapi dalam arah horizontal hanya setiap kolom kedua digunakan.  Selain karena memberikan keunggulan artistik seperti dijelaskan di atas, metode ini juga cukup cepat.  Berkat ini, teknik skinning tradisional dapat digunakan pada sisi GPU untuk membuat mesh, karena jika tidak kita harus memperbarui buffer vertex dinamis yang besar. <br><br>  Jala kain dapat memiliki resolusi yang cukup rendah, yang mengurangi beban pada CPU.  Satu-satunya biaya tambahan untuk solusi kami adalah untuk mengkonversi simulasi resolusi rendah ke mesh resolusi tinggi, tetapi dalam skema kami biaya ini akan diabaikan dibandingkan dengan sisa simulasi. <br><br><h1>  Tabrakan </h1><br>  Untuk mengatasi masalah pemangkasan jaringan dengan kaki dan tubuh, kami menggunakan pengenalan tabrakan antara ellipsoid dan sebuah partikel.  Gambar 7 menunjukkan ellipsoids yang dibutuhkan untuk menyelesaikan pemotongan jaket oleh model karakter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4a/277/f0c/a4a277f0c2991b0a013d821a8879ecea.jpg"></div><br>  <strong>Gambar 7. Sistem ellipsoid untuk model Wake.</strong> <br><br>  Pengenalan tabrakan ellipsoid dengan partikel sangat cepat.  Tabrakan dapat diselesaikan dengan mengubah ruang di mana ellipsoid dan partikel ada, sehingga ellipsoid berubah menjadi bola.  Anda kemudian dapat melakukan uji tabrakan cepat pada bola dan partikel. <br><br>  Dalam praktiknya, ini disertai dengan penciptaan transformasi terbalik berdasarkan nilai-nilai panjang, lebar dan tinggi ellipsoid dengan penerapannya pada posisi partikel.  Satu-satunya masalah di sini adalah bahwa tabrakan normal yang kita dapatkan setelah mengkonversi kembali ke sistem koordinat asli terdistorsi. <br><br>  Kami memutuskan bahwa kami bisa berdamai dengan sedikit ketidakakuratan dalam menghitung arah tumbukan.  Dalam kasus di mana ellipsoid yang terentang kuat dapat menyebabkan reaksi yang salah, kami membaginya menjadi dua yang lebih homogen. <br><br><h1>  Jarak maksimum ke partikel </h1><br>  Masalah lain yang perlu dipecahkan adalah stabilitas jaket.  Jaringan selama gerakan cepat dapat menyebabkan pembentukan kelenjar getah bening atau muncul di sisi lain volume tumbukan dan melewati tubuh.  Kami memecahkan masalah ini dengan menetapkan jarak yang aman untuk setiap simpul jaringan yang disimulasikan. <br><br>  Untuk setiap titik, posisi istirahat awal dengan menguliti melekat pada tulang terdekat dan kami menggunakannya sebagai titik referensi.  Jika simulasi melebihi nilai ambang batas, maka kita cukup memindahkan titik lebih dekat ke titik referensi.  Dalam desain kami, kami membiarkan puncak di bawah bergerak lebih jauh dari puncak lebih dekat ke bahu. <br><br>  Jarak maksimum yang kita bisa memungkinkan puncak untuk bergerak adalah sekitar 40 cm, ketika nilai ini terlampaui, kasus langka node dan pemotongan mulai muncul.  Kami juga mencoba menggunakan teknik lain, misalnya, pesawat bertabrakan, tetapi metode jarak maksimum ternyata yang terbaik.  Itu cepat, mudah diatur dan memberikan kebebasan bergerak terbesar sebelum kesalahan yang terlihat mulai muncul dalam jalinan. <br><br><h1>  Lebih Banyak Tweed, Lebih Sedikit Karet </h1><br>  Sejauh ini, kami telah dapat menemukan cara yang baik untuk mencapai tujuan kami.  Artis kami memodelkan jaketnya sesuai keinginannya;  untuk menghidupkan jaket, animator tidak diperlukan, karena semuanya disimulasikan dalam permainan, dan prosesor senang bahwa kami memiliki sumber daya yang cukup untuk perhitungan dalam game lainnya.  Tapi satu hal yang mengganggu kami - kainnya terlihat seperti karet. <br><br><h1>  Berjuang Peregangan </h1><br>  Pertama, kita harus menyingkirkan peregangan.  Seperti yang saya katakan di atas, fenomena peregangan disebabkan oleh kesalahan yang muncul karena sifat berulang dari algoritma.  Ini adalah topik penelitian yang populer dan banyak metode dapat ditemukan untuk menyelesaikan masalah ini. <br><br>  Sayangnya, semua solusi yang tersedia akan memaksa kita untuk mengalokasikan sumber daya CPU yang jauh lebih langka untuk perhitungan jaringan.  Oleh karena itu, kami memecahkan masalah peregangan dengan menambahkan langkah terakhir ke simulasi jaringan, di mana apa yang disebut "kendala keras" diterapkan. <br><br>  Kami membuat batasan ketat pada batasan regangan (semuanya diarahkan secara vertikal).  Pembatasan ini diurutkan dari atas ke bawah sehingga pembatasan di dekat bahu diselesaikan untuk pembatasan di dekat kaki. <br><br>  Karena kita mengulangi kendala dari atas, kita tahu bahwa simpul atas pada pasangan telah diselesaikan dan tidak menyebabkan peregangan, jadi kita hanya perlu memindahkan simpul bawah ke arah atas.  Berkat ini, kita dapat yakin bahwa setelah satu iterasi, panjang dari atas ke bawah akan sama persis dengan panjang saat istirahat. <br><br><pre> <code class="cpp hljs">Vector3 vDelta = constraint.m_vertexTop.m_vCurPos - constraint.m_vertexDown.m_vCurPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fLength = vDelta.length(); vDelta.normalize(); Vector3 vOffset = vDelta * ( fLength - constraint.m_fRestLength ); constraint.m_vertexDown.m_vCurrentPosition += vOffset;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7e/84c/a2a/c7e84ca2afe73e36a6c4c89a01fbec14.png"></div><br>  <strong>Gambar 8. Pembatasan ketat.</strong> <br><br>  Seperti yang Anda lihat, kami tidak memperhitungkan peregangan jaket secara horizontal.  Tidak mungkin untuk menerapkan batasan ketat pada arah horizontal, karena dalam hal ini titik akan diselesaikan dua kali, yaitu, kita akan kehilangan hasil tahap perhitungan vertikal dan panjang kain tidak akan disimpan saat istirahat. <br><br>  Namun, kami memperhatikan bahwa dalam kasus jaket, peregangan horizontal sebenarnya tetap tidak terlihat oleh mata manusia, dan karena peregangan vertikal, jaket terlihat sangat buruk.  Solusi ini ternyata cukup bagus. <br><br><h1>  Tepi jaket </h1><br>  Kedua, kami ingin tepi jaket bergerak sedikit lebih dari yang lain.  Misalnya, jika Anda menggunakan jaket terbuka lebar, Anda akan melihat bahwa hambatan udara memengaruhi tepi jaket lebih dari bagian tengah.  Ini karena tubuh Anda menutupi sisa jaket dari angin. <br><br>  Tepi dapat dengan mudah ditemukan oleh sejumlah kendala yang melekat padanya.  Setiap simpul yang memiliki batasan regangan kurang dari empat adalah tepi.  Oleh karena itu, kita dapat menandai simpul ini dan mensimulasikannya dengan parameter lain. <br><br><ul><li>  Redaman yang berkurang. </li><li>  Angin global memiliki dampak yang lebih besar. </li><li>  Gerakan di ruang dunia memiliki dampak yang lebih besar (untuk lebih banyak tentang pergerakan di ruang dunia, lihat di bawah). </li><li>  Jarak aman maksimum yang diizinkan lebih tinggi. </li></ul><br>  Karena ini, frekuensi internal tepi akan berbeda dari sisa jaket.  Sekarang seluruh jaket tidak menanggapi impuls seperti pendulum besar, dan hanya ujung-ujungnya menambahkan gerakan tambahan yang indah untuk gerakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d8/31a/db6/8d831adb6fe8481e9b05830abf71e555.png"></div><br>  <strong>Gambar 9. Bagian atas tepi.</strong> <br><br><h1>  Gerakan di ruang dunia dan di ruang lokal </h1><br>  Kemudian kami perhatikan bahwa ketika memindahkan karakter, gerakan di ruang dunia memiliki efek yang agak besar pada simulasi, sementara tubuh lokal kecil berubah atau gerakan bahu tidak diperhatikan. <br><br>  Dalam simulasi jaringan tradisional, posisi simpul disimulasikan di ruang dunia.  Seseorang mungkin mengatakan bahwa mensimulasikan kain itu benar, tetapi rasanya tidak wajar.  Oleh karena itu, kami mensimulasikan jaket pada karakter di ruang lokal dan secara terpisah menambahkan sedikit gerakan di ruang dunia.  Kami memperhatikan bahwa hasil yang kami butuhkan diperoleh dengan animasi kerangka lokal 100% dengan gerakan 10-30% di ruang dunia. <br><br><h1>  Gesekan </h1><br>  Dan akhirnya, kami ingin melebih-lebihkan kontras antara jaket dalam gerakan lambat dan cepat.  Kami ingin jaket menjadi relatif tidak bergerak ketika berjalan, dan ketika Alan melompat atau menghindar, gerakan itu harus lebih hidup. <br><br>  Kami berpikir bahwa ketika jaket menyentuh tubuh, itu harus bergerak kurang karena gesekan antara jaket dan kemeja, dan ketika jaket naik, itu harus bergerak lebih karena tidak ada yang membatasi itu.  Kami mensimulasikan ini dengan menerapkan nilai atenuasi yang meningkat pada setiap titik yang menyentuh ellipsoid.  Berkat ini, atasan yang menyentuh tubuh akan tampak agak lengket, menciptakan kontras yang cukup antara jaket dalam situasi normal dan dalam gerakan cepat. <br><br><h1>  Kesimpulan dan pekerjaan lebih lanjut </h1><br>  Perwujudan pertama simulasi jaringan cukup sederhana untuk diterapkan: kami hanya mencari kata "fabric" dalam literatur pengembangan game dan menerapkan algoritma yang kami temukan.  Tahap kedua, di mana kami mencoba untuk mencapai sensasi yang meyakinkan dari jaket wol, membutuhkan studi artikel ilmiah, banyak trial and error, dan bahkan penghapusan bagian dari kode. <br><br>  Tentu saja, Anda selalu dapat meningkatkan sesuatu.  Misalnya, menggunakan simulasi resolusi rendah dan menautkannya ke mesh resolusi tinggi mempersulit solusi untuk masalah semua pemotongan.  Kami tidak punya cukup waktu untuk perincian kecil lainnya: misalnya, ini adalah kartu lipatan di tempat lipatan jaket atau penerapan interaksi jaket dan tornado yang benar. <br><br>  Pada akhirnya, upaya kami terbayar - kain kami sangat berbeda dari simulasi jaringan di game lain.  Dia lebih mirip tweed daripada sutra atau karet.  Selain itu, sistem kami terbukti sangat fleksibel dan memungkinkan kami untuk mensimulasikan kain lain, misalnya, jaket bawah Barry Wheeler dan kerudung wanita tua itu.  Tampaknya dengan menyesuaikan parameter Anda dapat mencapai simulasi dan jenis jaringan lainnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/18e/a10/c1818ea10be738aafeb51e0157ad247b.jpg"></div><br>  <strong>Gambar 10. Jaket wol.</strong> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458486/">https://habr.com/ru/post/id458486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458468/index.html">Bagaimana Menjalankan Rapat Kanban yang Mengesankan?</a></li>
<li><a href="../id458470/index.html">Tekstur, atau apa yang perlu Anda ketahui untuk menjadi Artis Permukaan. Bagian 2. Topeng dan tekstur</a></li>
<li><a href="../id458472/index.html">Kompilasi peringkat wilayah dengan metode potensi termal menggunakan data terbuka</a></li>
<li><a href="../id458474/index.html">Laporan terbaik dengan HighLoad ++ 2018</a></li>
<li><a href="../id458482/index.html">Bagian 3: Hampir memuat Linux dari kartu SD ke RocketChip</a></li>
<li><a href="../id458488/index.html">Intisari Ilmu Data (Juli 2019)</a></li>
<li><a href="../id458490/index.html">Pegang erat-erat ke roda kemudi ... Proyek kami untuk memantau kondisi pengemudi</a></li>
<li><a href="../id458492/index.html">“Kami selalu percaya pada kompetisi dan hak untuk memilih pengguna” © Yandex</a></li>
<li><a href="../id458494/index.html">Contoh praktis menggunakan fungsi render Vue: membuat kisi tipografi untuk sistem desain</a></li>
<li><a href="../id458496/index.html">Pedoman praktis untuk mengembangkan aplikasi Bereaksi skala besar. Perencanaan, Tindakan, Sumber Data, dan API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>