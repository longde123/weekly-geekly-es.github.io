<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏿 🕴🏾 🐅 Andrew Eun "Paixão pelo aprendizado de máquina". Tradução dos capítulos 36-46 🤲🏾 👰🏿 🤸🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Três anos se passaram desde a publicação dos primeiros capítulos do Machine Learning Yearning, de Andrew Ng. Se você se inscreveu no hub "Machine Lear...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Andrew Eun "Paixão pelo aprendizado de máquina". Tradução dos capítulos 36-46</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485070/">  Três anos se passaram desde a publicação dos primeiros capítulos do Machine Learning Yearning, de Andrew Ng.  Se você se inscreveu no hub "Machine Learning", não há necessidade de apresentá-lo ao autor, e provavelmente você já leu o livro em si há muito tempo, no idioma da fonte original.  A tradução da primeira metade do livro para o russo foi feita por <a href="https://habr.com/ru/users/alexey_nichnikov/" class="user_link">alexey_nichnikov</a> ; neste momento, foi publicada em Habré em uma <a href="https://habr.com/ru/post/419757/">série de artigos</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/87/qr/4t87qrmbsuxfltahjbm9iunonx4.png"></div><br>  Apresento a você minha versão da tradução da segunda metade do livro, os capítulos 36-58.  Está planejado dividi-lo em dois artigos para facilitar a publicação.  Além disso, você pode baixar uma tradução completa desses capítulos, <a href="https://drive.google.com/open%3Fid%3D1SofaOohXwySM_6UM8wnH9J3tBmO6dMGu">compilada em pdf</a> ; talvez alguém ache esse formato mais conveniente para a leitura. <br><br>  O primeiro artigo se concentrará no treinamento e teste em diferentes distribuições, bem como nos algoritmos de saída de depuração. <br><a name="habracut"></a><br><h1>  Treinamento e teste em diferentes distribuições </h1><br><hr><h3>  <font color="#548dd4">Capítulo 36. Quando você deve treinar e testar em diferentes distribuições</font> </h3><hr><br>  Os usuários do seu aplicativo Cat Photo carregaram 10.000 imagens que você rotulou manualmente como contendo ou não gatos.  Você também tem um conjunto maior de 200.000 imagens baixadas da Internet.  Como definir treinamento (conjunto de trens), validação (conjunto de desenvolvedores) e seleção de testes (conjunto de testes)? <br><br>  Como 10.000 imagens de usuários refletem de perto a distribuição de probabilidade real dos dados com os quais você deseja trabalhar com êxito no futuro, você pode usá-lo para suas amostras de validação e teste.  Se você treinar um algoritmo de aprendizado profundo exigente no número de exemplos de treinamento, poderá fornecer 200.000 imagens adicionais baixadas da Internet para treinamento.  Assim, os dados nas amostras de validação e teste terão diferentes distribuições de probabilidade.  Como isso afetará o resultado do seu trabalho? <br><br>  Em vez de dividir nossos dados em amostras de treinamento, validação e teste, podemos coletar todas as 210.000 imagens disponíveis e embaralhá-las aleatoriamente em amostras de treinamento, validação e teste.  Nesse caso, todos os dados entram com a mesma distribuição.  Mas eu não recomendo usar esse método, porque aproximadamente 97,6% (205.000 / 210.000) de suas amostras de validação e teste consistirão em imagens baixadas da Internet que não refletem a distribuição real na qual você deseja obter êxito. <br><br>  Recomendação para a definição de validação e amostras de teste: <br><br><ul><li>  selecione validação e amostras de teste para refletir os dados que você espera receber no futuro e com os quais deseja trabalhar com êxito. </li></ul><br>  A maior parte da literatura acadêmica de aprendizado de máquina sugere que o treinamento, a validação e as amostras de teste têm a mesma distribuição.  <sup>1</sup> No início do aprendizado de máquina, os dados eram escassos.  Normalmente, tínhamos apenas um conjunto de dados com alguma distribuição de probabilidade.  Portanto, dividimos aleatoriamente todo o conjunto em amostras de treinamento, validação e teste, assumindo que todos os dados vieram da mesma fonte, que geralmente correspondia à realidade. <br><blockquote>  <sup>1</sup> Existem vários estudos científicos sobre o treinamento e teste de modelos em várias distribuições.  Os exemplos incluem Adaptação de Domínio, Transfer Learning e Multitarefa.  Mas ainda existe uma enorme lacuna entre teoria e prática.  Se você treinar um modelo no conjunto de dados A e testar no conjunto de dados B, que é muito diferente, a sorte poderá ter um enorme impacto no desempenho do seu algoritmo.  (Aqui, “sorte” inclui a seleção manual de atributos por um pesquisador para uma tarefa específica, além de outros fatores que ainda não entendemos.) Isso dificulta a realização de um estudo acadêmico sistemático de treinamento e testes em várias distribuições. </blockquote><br>  Mas na era do big data, agora temos acesso a enormes conjuntos de treinamento, como imagens com gatos da Internet.  Mesmo que a amostra de treinamento tenha uma distribuição diferente da distribuição das amostras de validação e teste, ainda queremos usá-la para treinamento, pois isso pode fornecer muitas informações adicionais. <br><br>  No exemplo com um detector de gato, em vez de colocar todas as 10.000 imagens carregadas pelos usuários nas amostras de validação e teste, poderíamos colocar apenas 5.000 imagens nelas.  E os restantes 5.000 exemplos que podemos colocar no conjunto de treinamento.  Assim, a amostra de treinamento consistirá em 205.000 exemplos e incluirá dados com a mesma distribuição das amostras de validação e teste, além de 200.000 imagens da Internet.  No próximo capítulo, discutiremos por que esse método é útil. <br><br>  Vejamos um segundo exemplo.  Suponha que você esteja criando um sistema de reconhecimento de fala para transcrever endereços para o aplicativo de voz Navigator.  Você tem 20.000 exemplos, em cada um dos quais o usuário nomeia algum endereço.  Mas você também tem 500.000 outras gravações de áudio nas quais os usuários falam sobre tópicos gratuitos.  Você pode obter 10.000 exemplos com endereços para validação e amostras de teste, e os 10.000 exemplos restantes, além de 500.000 exemplos adicionais a serem incluídos no conjunto de treinamento. <br><br>  Continuaremos assumindo que nossos dados de amostra de validação e teste têm a mesma distribuição.  Mas é importante entender e lembrar que diferentes distribuições nas amostras de treinamento e validação / teste levarão a problemas especiais. <br><br><hr><h3>  <font color="#548dd4">Capítulo 37. Como decidir se deseja usar todos os seus dados ou apenas parte</font> </h3><hr><br>  Suponha que a amostra de treinamento do seu detector de gato inclua 10.000 imagens enviadas por usuários.  Permita que esses dados tenham a mesma distribuição das amostras de validação e teste e é para essa distribuição que você deseja obter o resultado máximo.  Você também tem 20.000 imagens adicionais baixadas da Internet.  É necessário incluir todas as 20.000 + 10.000 = 30.000 imagens no conjunto de treinamento ou é melhor eliminar 20.000 imagens da Internet por medo de introduzir erros no algoritmo de aprendizado? <br><br>  Usando gerações anteriores de algoritmos de aprendizado (como um algoritmo de visão computacional projetado manualmente, seguido de um classificador linear simples), havia um risco real de que a combinação de dados de ambas as fontes pudesse prejudicar os resultados.  Assim, alguns engenheiros o alertam contra a inclusão de 20.000 imagens online. <br><br>  Mas na era moderna de algoritmos de aprendizado poderosos e flexíveis, como grandes redes neurais, esse risco foi reduzido significativamente.  Se você puder construir uma rede neural com um número suficientemente grande de camadas ocultas, poderá adicionar com segurança 20.000 imagens da Internet ao seu conjunto de treinamento.  A adição de imagens provavelmente aumentará seus resultados. <br><br>  Essa observação é baseada no fato de que existe alguma correspondência <b>x</b> → <b>y</b> que funciona bem para os dois tipos de dados.  Em outras palavras, existe algum tipo de sistema que, tendo recebido uma imagem da Internet ou uma imagem de um aplicativo móvel, prevê com segurança um rótulo sem nem mesmo saber a origem da imagem. <br><br>  A adição de 20.000 imagens adicionais da Internet terá os seguintes efeitos: <br><br><ol><li>  Isso dará à sua rede neural mais exemplos de como os gatos se parecem / não se parecem.  Isso é útil porque as imagens da Web e as imagens carregadas pelos usuários de um aplicativo móvel têm algumas semelhanças.  Sua rede neural pode aplicar parte do conhecimento obtido das imagens on-line às imagens de um aplicativo móvel. </li><li>  Isso força a rede neural a gastar parte de seus recursos no reconhecimento de propriedades específicas para imagens da Internet (por exemplo, maior resolução, vários métodos de design etc.) Se essas propriedades forem significativamente diferentes das imagens de um aplicativo móvel, isso será "drenado" parte das capacidades representativas da rede neural.  Assim, haverá menos oportunidades para o reconhecimento de dados recebidos de um aplicativo móvel, e é isso que deve realmente preocupá-lo.  Teoricamente, isso pode prejudicar o desempenho do seu algoritmo. </li></ol><br>  Para explicar o segundo efeito em outras palavras, podemos nos voltar para um personagem fictício, Sherlock Holmes, que diz que seu cérebro se parece com um sótão que tem uma quantidade limitada de espaço.  Ele diz que “com cada adição de conhecimento você esquece o que sabia antes.  Portanto, é extremamente importante não permitir que fatos inúteis substituam fatos úteis. ”  <sup>2</sup> <br><blockquote>  <sup>2</sup> “Etude in Scarlet”, Arthutre Conan Doyle, 1887 </blockquote><br>  Felizmente, se você tem o poder de computação necessário para construir uma rede neural suficientemente grande, ou seja, um “sótão suficientemente grande”, essa “exclusão” descrita acima não é um problema sério.  Você tem oportunidades de treinamento suficientes em imagens da Internet e em imagens de um aplicativo móvel, enquanto os dois tipos de dados não competem pela capacidade de reconhecimento.  O "cérebro" do seu algoritmo é grande o suficiente para que você não precise se preocupar que de repente não tenha espaço suficiente no sótão. <br><br>  Mas se você não possui uma rede neural suficientemente grande (ou outro algoritmo de aprendizado muito flexível), preste mais atenção aos dados de treinamento que correspondem à sua validação e amostra de teste. <br><br>  Se você acha que possui dados que não trazem nenhum benefício, basta excluí-los para acelerar os cálculos.  Por exemplo, suponha que suas amostras de validação e teste contenham principalmente fotografias aleatórias de pessoas, lugares, sinais e ponteiros, além de animais.  Suponha que você também tenha uma grande coleção de documentos históricos digitalizados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/ct/fz/lhctfzvvbuqngsuaz-uk_d-nfyu.png"></div><br><br>  Esses documentos não contêm nada como um gato.  Eles também parecem completamente diferentes dos dados de suas amostras de validação e teste.  Não faz sentido incluir esses dados como exemplos negativos, pois nesse caso os benefícios descritos no primeiro efeito serão desprezíveis.  Com base nesses dados, sua rede neural não poderá descobrir quase nada que possa ser aplicado à sua validação e amostra de teste.  A inclusão desses exemplos levará a uma perda de recursos de computação e a uma diminuição da capacidade representativa da rede neural. <br><br><hr><h3>  <font color="#548dd4">Capítulo 38. Como decidir se deve incluir dados conflitantes</font> </h3><hr><br>  Suponha que você queira aprender como prever os preços da habitação em Nova York.  Dado o tamanho da casa (entrada <b>x</b> ), você deseja prever o preço (etiqueta de destino <b>y</b> ). <br><br>  Os preços da habitação em Nova York são muito altos.  Suponha que você tenha um segundo conjunto de dados - preços da habitação em Detroit, Michigan, onde os preços da habitação são muito mais baixos.  Devo incluir esses dados no meu conjunto de treinamento? <br><br>  Dado o mesmo tamanho <b>x</b> , o preço de uma casa <b>y</b> é muito diferente dependendo se é em Nova York ou em Detroit.  Se você se preocupa apenas em prever preços de imóveis em Nova York, a combinação dos dois conjuntos de dados prejudicará sua produtividade.  Nesse caso, seria melhor não usar dados conflitantes do conjunto de Detroit.  <sup>3</sup> <br><blockquote>  <sup>3</sup> Há uma maneira de resolver o problema de incompatibilidade dos dados de Detroit com os dados de Nova York, a saber, adicionar um recurso adicional a cada exemplo de treinamento, ou seja,  indicação da cidade.  Dado o valor de entrada de <b>x</b> , que agora indica a cidade, o valor alvo de <b>y</b> agora <b>é</b> determinado exclusivamente.  No entanto, na prática, ainda não vejo isso sendo feito com frequência. </blockquote><br>  Como este exemplo de moradia em Nova York e Detroit difere do nosso exemplo de imagens na Internet de gatos e imagens de um aplicativo móvel? <br><br>  O exemplo com as imagens de gatos difere em que, dada a imagem de entrada <b>x</b> , é possível prever com segurança o rótulo <b>y</b> , indicando se há um gato nele, mesmo sem saber se recebemos a imagem da Internet ou de um aplicativo móvel.  I.e.  existe uma função f (x) que reflete de forma confiável a correspondência da entrada <b>x</b> com a saída alvo <b>y</b> , sem ao menos conhecer a fonte de origem de <b>x</b> .  Assim, a tarefa de reconhecer imagens da Internet "corresponde" à tarefa de reconhecer imagens de um aplicativo móvel.  Isso significa que houve um pequeno sinal de menos (exceto os custos computacionais) da inclusão de todos os dados e algumas vantagens significativas possíveis.  Em contraste com o exemplo de dados conflitantes de Nova York e Detroit, nos quais, para o mesmo valor de entrada <b>x</b> (tamanho da casa), o preço é muito diferente dependendo da cidade em que essa casa está localizada. <br><br><hr><h3>  <font color="#548dd4">Capítulo 39. Pesando Dados</font> </h3><hr><br>  Suponha que você tenha 200.000 imagens online e 5.000 imagens de usuários do seu aplicativo móvel.  Há uma proporção de 40: 1 entre os tamanhos desses conjuntos de dados.  Teoricamente, desde que você construa uma rede neural enorme e a treine por tempo suficiente com todos os 205.000 exemplos disponíveis, não há nada de errado em fazer o algoritmo funcionar bem em imagens da Internet e em imagens móveis. <br><br>  Mas, na prática, tendo 40 vezes mais imagens da Internet do que imagens de um aplicativo móvel, talvez você precise gastar 40 vezes mais recursos de computação do que quando treinou uma rede para apenas 5.000 imagens. <br><br>  Se você não possui enormes recursos de computação, pode dar muito menos peso às imagens da Internet como compromisso. <br><br>  Por exemplo, suponha que sua meta de otimização seja o erro ao quadrado (essa não é uma boa opção para o problema de classificação, mas simplificará nossa explicação).  Portanto, seu algoritmo de aprendizado está tentando otimizar: <br><p><math> </math> $$ display $$ \ min_θ \ sum _ {(x, y) ∈MobileImg} (h_θ (x) -y) ^ 2 + \ sum _ {(x, y) ∈InternetImg} (h_θ (x) -y) ^ 2 $$ display $$ </p><br>  A primeira quantia acima é o erro total de 5.000 imagens para celular e a segunda quantia é o erro total de 200.000 imagens da Internet.  Em vez disso, você pode otimizar com um parâmetro adicional <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-74"><span class="MJXp-mtext" id="MJXp-Span-75">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.731ex" height="2.057ex" viewBox="0 -780.1 2037 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-62" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-65" x="679" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-74" x="1146" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-61" x="1507" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> \ beta </script>  : <br><p><math> </math> $$ display $$ \ min_θ \ sum _ {(x, y) obileMobileImg} (h_θ (x) -y) ^ 2 + \ beta \ sum _ {(x, y) ∈InternetImg} (h_θ (x) -y) ^ 2 $$ exibir $$ </p><br>  Se você instalar <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-151"><span class="MJXp-mtext" id="MJXp-Span-152">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-155">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.731ex" height="2.057ex" viewBox="0 -780.1 2037 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-62" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-65" x="679" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-74" x="1146" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-61" x="1507" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> \ beta </script>  = 1/40, o algoritmo atribuirá peso igual a 5.000 imagens móveis e 200.000 imagens da Internet.  Você também pode definir o parâmetro <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-157"><span class="MJXp-mtext" id="MJXp-Span-158">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-161">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.731ex" height="2.057ex" viewBox="0 -780.1 2037 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-62" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-65" x="679" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-74" x="1146" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-61" x="1507" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> \ beta </script>  outros valores, possivelmente ajustando-o à amostra de validação. <br><br>  Atribuindo menor peso às imagens da Internet, você não precisa criar uma rede neural maciça para garantir que o algoritmo lide bem com os dois tipos de tarefas.  Esse método de "reponderação" é necessário apenas se você suspeitar que dados adicionais (imagens da Internet) tenham uma distribuição muito diferente dos dados nas amostras de validação e teste ou se houver muito mais dados adicionais do que os dados obtidos com a mesma distribuição como nas amostras de validação e teste (imagens para celular). <br><br><hr><h3>  <font color="#548dd4">Capítulo 40. Generalização da amostra de treinamento para uma amostra de validação</font> </h3><hr><br>  Suponha que você aplique ML em uma situação em que a amostra de treinamento seja diferente da amostra de validação / teste.  Por exemplo, uma amostra de treinamento contém imagens da Internet + imagens para celular e as amostras de validação / teste contêm apenas imagens para celular.  No entanto, o algoritmo não funciona muito bem: há um erro muito maior na amostra de validação / teste do que gostaríamos.  Aqui estão algumas razões pelas quais esse pode não ser o caso: <br><br><ol><li>  O algoritmo não funciona muito bem no conjunto de treinamento.  Esse é um problema de alto viés (evitável) da distribuição da amostra de treinamento. </li><li>  O algoritmo funciona bem no conjunto de treinamento, mas generaliza mal para dados novos (anteriormente não mostrados) obtidos com a mesma distribuição que no conjunto de treinamento.  Essa é uma alta variação. </li><li>  O algoritmo generaliza bem para dados novos (anteriormente não mostrados) obtidos com a mesma distribuição que na amostra de treinamento, mas não para dados da validação / amostra de teste.  Chamamos esse problema de incompatibilidade de dados devido ao fato de que os dados da amostra de treinamento estão pouco correlacionados com os dados das amostras de validação / teste. </li></ol><br>  Por exemplo, suponha que as pessoas alcancem um resultado quase perfeito na tarefa de identificar gatos.  E seu algoritmo atingiu: <br><br><ul><li>  1% de erros na amostra de treinamento </li><li>  1,5% de erros nos dados novos (anteriormente não mostrados no algoritmo) com a mesma distribuição que a amostra de treinamento </li><li>  10% de erros na amostra de validação </li></ul><br>  Nesse caso, você definitivamente tem um problema de incompatibilidade de dados.  Para habilitá-lo, você pode tentar tornar a amostra de treinamento mais semelhante à validação / teste.  Discutiremos algumas técnicas dessa técnica posteriormente. <br><br>  Para diagnosticar até que ponto o algoritmo sofre com cada um dos problemas 1-3 descritos acima, será útil ter um conjunto de dados diferente.  Em particular, em vez de fornecer ao algoritmo todos os dados disponíveis para treinamento, você pode dividi-lo em duas partes: a amostra de treinamento real na qual o algoritmo será treinado e um conjunto separado, que chamaremos de validação de treinamento (conjunto "trainig dev" ), que não usaremos em treinamento. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assim, você tem 4 conjuntos de dados: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conjunto de treinamento (conjunto de treinamento). </font><font style="vertical-align: inherit;">Esses são os dados nos quais o algoritmo será treinado (por exemplo, imagens da Internet + imagens de um aplicativo móvel). </font><font style="vertical-align: inherit;">Esses dados não precisam ser coletados com a mesma distribuição, cujo resultado final enfocamos (amostras de validação / teste).</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amostra de treinamento e validação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (conjunto de "treinamento dev"). </font><font style="vertical-align: inherit;">Esses dados são obtidos com a mesma distribuição que na amostra de treinamento (por exemplo, imagens da Internet + imagens de um aplicativo móvel). </font><font style="vertical-align: inherit;">Esse conjunto geralmente é menor que o conjunto de treinamento e deve ser grande o suficiente para avaliar e acompanhar o progresso do nosso algoritmo de treinamento.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amostragem de validação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (conjunto de desenvolvedores). </font><font style="vertical-align: inherit;">Esses dados são coletados com a mesma distribuição que na amostra de teste e devem refletir totalmente a distribuição dos dados nos quais nos esforçamos para obter o máximo aprimoramento (por exemplo, imagens de um aplicativo móvel).</font></font></li><li> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjunto de </font><b><font style="vertical-align: inherit;">teste </font></b><font style="vertical-align: inherit;">Esses dados são obtidos com a mesma distribuição que na amostra de validação (por exemplo, imagens de um aplicativo móvel).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Armado com esses quatro conjuntos de dados separados, você pode avaliar: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O erro de treinamento (erro de treinamento), avaliando a amostra de treinamento. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A capacidade do algoritmo de generalizar para novos dados, com a mesma distribuição que no conjunto de treinamento, avaliando o conjunto de validação de treinamento. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A eficiência do algoritmo como um todo para o problema a ser resolvido, avaliando uma validação e (ou) amostra de teste. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A maioria das recomendações fornecidas nos capítulos 5-7 deste livro para a escolha do tamanho da amostra de validação também é aplicável à amostra de treinamento e validação. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 41. Determinação de erro de desvio, desvio e incompatibilidade de dados</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que as pessoas alcancem eficiência quase perfeita (erro de ± 0%) nas tarefas de detecção de gatos e, portanto, a taxa de erro ideal é de cerca de 0%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que você tenha:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1% de erros na amostra de treinamento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5% de erros na amostra de treinamento e validação </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5% de erros na amostra de validação </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que isso nos diz? </font><font style="vertical-align: inherit;">Você sabe que tem uma alta variação. </font><font style="vertical-align: inherit;">Os métodos de redução de dispersão descritos anteriormente devem permitir algum progresso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, suponha que seu algoritmo tenha atingido:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10% de erros na amostra de treinamento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11% de erros na amostra de treinamento e validação </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12% de erros na amostra de validação </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso sugere que você tem um viés evitável alto no conjunto de treinamento. </font></font> I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o algoritmo produz maus resultados no conjunto de treinamento, mas os métodos de redução de deslocamento devem ajudar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos dois exemplos acima, o algoritmo sofre apenas um viés alto (viável evitável) ou apenas uma alta dispersão (variação). </font><font style="vertical-align: inherit;">Além disso, o algoritmo pode sofrer qualquer combinação de alto viés, alta dispersão e inconsistência de dados.</font></font> Por exemplo: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10% de erros na amostra de treinamento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11% de erros na amostra de treinamento e validação </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20% de erros na amostra de validação </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse algoritmo sofre viés alto (viável evitável) e incompatibilidade de dados e, ao mesmo tempo, não apresenta problemas com alta dispersão na amostra de treinamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode ser mais fácil entender como os diferentes tipos de erros se relacionam escrevendo-os na tabela a seguir:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/w0/iv/m2w0iviqecnkhlm2_icdxlzhzfy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuando com o exemplo do detector de imagem de gato, você pode ver que existem duas distribuições de dados diferentes (distribuição A e distribuição B) ao longo do eixo X. </font><font style="vertical-align: inherit;">No eixo Y, temos três tipos de erros: erro humano, erro nos exemplos a partir dos quais o algoritmo foi treinado e erro nos exemplos nos quais o algoritmo não foi treinado. </font><font style="vertical-align: inherit;">Podemos preencher as células da tabela com os vários tipos de erros que identificamos no capítulo anterior.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se desejar, também é possível preencher as duas células restantes nesta tabela: você pode preencher o campo no canto superior direito (“A eficiência é acessível para pessoas em imagens de um aplicativo móvel”), pedindo a alguém para marcar as imagens de gatos de um aplicativo móvel e depois medir seu erro . Você pode preencher o campo a seguir, capturando imagens de gatos de um aplicativo móvel (distribuição B) e colocando uma pequena parte deles no conjunto de treinamento, para que a rede neural também aprenda com ele. Então você mede o erro do modelo treinado nesse subconjunto de dados. O preenchimento desses dois campos adicionais pode às vezes fornecer uma compreensão adicional de como o algoritmo funciona em duas distribuições diferentes (distribuição A e B) de dados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para entender quais tipos de erros o algoritmo mais sofre, é possível determinar melhor se você deve se concentrar na redução do viés, na variação ou na inconsistência dos dados. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 42. Resolvendo erro de incompatibilidade de dados</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que você tenha desenvolvido um sistema de reconhecimento de fala que funcione muito bem em uma amostra de treinamento e em uma amostra de validação de treinamento. </font><font style="vertical-align: inherit;">No entanto, o algoritmo não funciona bem na sua amostra de validação: você tem um problema de incompatibilidade de dados. </font><font style="vertical-align: inherit;">O que você pode fazer? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu recomendo que você: (i) tente entender quais propriedades diferem nos dados das amostras de treinamento e validação; </font><font style="vertical-align: inherit;">(ii) tente encontrar mais dados de treinamento que melhor correspondam aos exemplos da amostra de validação com a qual seu algoritmo tem problemas. </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup> <br><blockquote> <sup>4</sup>    « » (domain adaptation) —            .              ,  ,    . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, suponha que você esteja executando uma análise de erro de validação para um sistema de reconhecimento de fala: você passa manualmente por 100 exemplos e tenta entender onde o algoritmo comete erros. Você descobrirá que seu sistema não funciona bem, porque a maioria das gravações de áudio da amostra de validação foi feita enquanto estava dentro do carro, enquanto a maioria dos exemplos da amostra de treinamento foi gravada no contexto de silêncio. O ruído do motor e da estrada prejudica drasticamente o desempenho do seu sistema de reconhecimento de fala. Nesse caso, você pode tentar obter mais exemplos de treinamento contendo gravações de áudio feitas no carro. O objetivo da análise de erros é entender as diferenças significativas entre as amostras de treinamento e validação, que levam à incompatibilidade de dados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se sua amostra de treinamento e validação de treinamento incluir o som gravado no carro, verifique também a eficácia do seu sistema neste conjunto de dados. Se funciona bem em exemplos "automotivos" de uma amostra de treinamento, mas não em exemplos "automotivos" de uma amostra de validação de treinamento, isso confirma mais uma vez a hipótese de que obter mais exemplos "automotivos" ajudará. Por isso, no capítulo anterior, discutimos a possibilidade de incluir em seu conjunto de treinamento um conjunto de alguns dados com a mesma distribuição que nas amostras de validação / teste. Isso permite comparar a eficácia do sistema com exemplos “automotivos” no conjunto de treinamento versus exemplos semelhantes de amostras de validação / teste.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, não há garantias nesta questão. </font><font style="vertical-align: inherit;">Por exemplo, se você não tiver a oportunidade de obter mais dados de treinamento que correspondam melhor aos dados da amostra de validação, talvez não tenha um caminho claro para melhorar a eficiência.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 43. Sintetizando Dados Artificiais</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu sistema de reconhecimento de fala precisa de mais dados que soem como se as gravações de áudio desses exemplos fossem feitas em um carro. </font><font style="vertical-align: inherit;">Em vez de coletar muitos dados durante a condução, pode haver uma maneira mais fácil de obter esses dados: gerando-os artificialmente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que você receba um grande número de gravações de áudio com ruído na estrada / carro. Você pode baixar esses dados de vários sites. Suponha que você também tenha um grande conjunto de treinamento, nos exemplos dos quais as pessoas conversam em uma sala silenciosa. Se você fizer uma gravação de áudio de uma pessoa que fala e "adicionar" os sons do ruído do carro / estrada, você receberá uma gravação de áudio que soa como se essa pessoa estivesse falando em um carro barulhento. Usando esse processo, você pode sintetizar uma enorme quantidade de dados que soa como se fossem coletados dentro de um carro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, existem várias circunstâncias em que a geração de dados artificiais permite criar um grande conjunto de dados que corresponde razoavelmente à amostra de validação. Vamos dar um detector de imagem de gato como um segundo exemplo. Você notou que as imagens na amostra de validação têm muito mais desfoque ao se mover, porque geralmente são obtidas de usuários de telefones celulares que movem o telefone levemente durante a filmagem. Você pode tirar imagens nítidas da Internet do conjunto de treinamento e adicionar imitação de desfoque de movimento, tornando-as mais semelhantes às imagens no conjunto de validação.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que a síntese de dados artificiais tem seus próprios problemas: às vezes é mais fácil criar dados sintéticos que parecem realistas para uma pessoa do que criar dados que parecem realistas para um computador. Por exemplo, suponha que você tenha 1000 horas de gravações de fala em um conjunto de treinamento, mas apenas 1 hora de ruído no carro. Se você usar repetidamente a mesma hora de ruído do carro com outras peças além das 1000 horas originais do conjunto de treinamento, receberá um conjunto de dados sintético no qual o mesmo ruído do carro é repetido repetidamente. Embora a pessoa que está ouvindo esse som provavelmente não consiga nomear seus recursos - todos os ruídos do carro soam iguais para a maioria de nós, é possível que o algoritmo de aprendizado seja treinado novamente por 1 hora de ruído no carro. Desta maneirapode mal generalizar para novas gravações de áudio nas quais o ruído do carro soa diferente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como alternativa, suponha que você tenha 1000 horas únicas de ruído no carro, mas apenas 10 carros diferentes foram usados ​​para gravá-los. Nesse caso, o algoritmo pode treinar novamente os registros desses 10 carros e mostrar um desempenho ruim ao testar registros de outro carro. Infelizmente, esses problemas são difíceis de detectar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7v/_5/wv/7v_5wvoffrpw4pj34pdpcbueflg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomemos outro exemplo, suponha que você crie um sistema de visão por computador para reconhecer carros. Suponha que você esteja colaborando com uma empresa de videogame que possui vários modelos de carros feitos com gráficos de computador. Para treinar seu algoritmo, use esses modelos para gerar imagens sintéticas de carros. Mesmo que as imagens sintetizadas pareçam muito realistas, essa abordagem (sugerida de forma independente por muitas pessoas) provavelmente não funcionará bem. Um videogame pode ter aproximadamente 20 modelos de carros. Criar um modelo 3D de carro de alta qualidade é muito caro. Se você estivesse jogando, provavelmente não perceberia que vê os mesmos carros repetidamente, talvez apenas em cores diferentes.</font></font> I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses dados parecem muito realistas para você. Mas comparado com a variedade de todos os carros na estrada e, portanto, com o conjunto que você provavelmente verá na amostra de validação / teste, este conjunto de 20 modelos sintetizados captura apenas uma pequena fração de toda a variedade global de carros. Portanto, se seus 100.000 exemplos de treinamento forem baseados inteiramente nesses 20 carros, seu sistema será treinado novamente por esses modelos específicos e não poderá generalizar bem as amostras de validação / teste que incluem outros modelos de carros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao sintetizar dados, considere se você está realmente gerando um conjunto representativo de exemplos. Tente não fornecer propriedades de dados sintetizadas que</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permita que o algoritmo de aprendizado diferencie um exemplo sintetizado de um não sintetizado, como nos casos em que todos os dados sintetizados são obtidos com base em um dos 20 modelos de carros ou todos os sons sintetizados são obtidos com apenas 1 hora de ruído do carro. </font><font style="vertical-align: inherit;">Seguir este conselho pode ser muito difícil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao trabalhar na síntese de dados, às vezes, nossa equipe levava semanas para criar dados com detalhes próximos o suficiente para que a distribuição real dos dados sintetizados tivesse um efeito significativo. </font><font style="vertical-align: inherit;">Mas se você conseguir os detalhes certos, de repente, você terá acesso a um conjunto de treinamento muito maior do que antes.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmos de saída de depuração </font></font></h1><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 44. Referência de Otimização</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine que você está desenvolvendo um sistema de reconhecimento de fala. Seu sistema funciona usando o áudio A como entrada e calcula uma pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S) para cada sentença de saída possível S. Por exemplo, você pode tentar avaliar a pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S) = P (S | A), ou seja, a probabilidade de a sentença S ser a transcrição correta da saída, uma vez que o áudio foi enviado para a entrada A. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado o método de cálculo da pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S), você precisa encontrar uma sentença em inglês com a classificação máxima:</font></font><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-163"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-164">O</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-165">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-166">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169">t</span><span class="MJXp-mo" id="MJXp-Span-170" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-173">g</span><span class="MJXp-munderover" id="MJXp-Span-174"><span class=""><span class="MJXp-mo" id="MJXp-Span-175" style="margin-left: 0.333em; margin-right: 0.333em;">max</span></span><span class=" MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-176" style="margin-left: 0px;">S</span></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177">S</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180">r</span><span class="MJXp-msubsup" id="MJXp-Span-181"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182" style="margin-right: 0.05em;">e</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-183" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-184">A</span></span></span><span class="MJXp-mo" id="MJXp-Span-185" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186">S</span><span class="MJXp-mo" id="MJXp-Span-187" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processed" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.413ex" height="3.985ex" viewBox="0 -832 12664.1 1715.8" role="img" focusable="false" style="vertical-align: -2.053ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-75" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-74" x="1336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-70" x="1697" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-75" x="2201" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-74" x="2773" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMAIN-3D" x="3412" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-61" x="4469" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-72" x="4998" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-67" x="5450" y="0"></use><g transform="translate(6097,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMAIN-6D"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMAIN-61" x="833" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMAIN-78" x="1334" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-53" x="994" y="-959"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-53" x="8126" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-63" x="8771" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-6F" x="9205" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-72" x="9690" y="0"></use><g transform="translate(10142,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-41" x="659" y="-230"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMAIN-28" x="11239" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMATHI-53" x="11629" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/485070/&amp;xid=17259,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhgrP4KEdMuLA1SQNk0PDFiN_xPn0g#MJMAIN-29" x="12274" y="0"></use></g></svg></span></div><script type="math/tex;mode=display" id="MathJax-Element-6">Output = arg \max_S Score_{A}(S)</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como calcular o "arg max" do exemplo acima? Existem 50.000 palavras em inglês; nesse caso, existem (50.000) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> frases possíveis com tamanho N. Isso é demais para listar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, você precisa aplicar um algoritmo de pesquisa aproximado para tentar encontrar o valor de S que otimiza (maximiza) a pontuação da Pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S). Um exemplo desse algoritmo é a pesquisa por feixe, que salva apenas os </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melhores candidatos no processo de pesquisa. (Para os fins deste capítulo, você não precisa entender os detalhes da operação de busca de raios.) Esses algoritmos não garantem a localização do valor de S, o que maximiza a pontuação da pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine que, em uma fita de áudio, alguém dissesse "Adoro aprendizado de máquina". </font><font style="vertical-align: inherit;">Mas, em vez da transcrição correta, seu sistema gera o erro "Eu amo robôs". </font><font style="vertical-align: inherit;">Há duas razões possíveis para o que pode dar errado:</font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas no algoritmo de busca</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O algoritmo de busca de vigas encontrou incorretamente o valor de S, o que maximiza a pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S).</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um problema objetivo com a função de avaliação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nossa estimativa do escore </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S) = P (S | A) não foi precisa. </font><font style="vertical-align: inherit;">Em particular, a pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S) </font><font style="vertical-align: inherit;">selecionada </font><font style="vertical-align: inherit;">não permitiu reconhecer corretamente a transcrição correta "Adoro aprendizado de máquina".</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependendo de qual delas foi a causa do erro do sistema, você deve priorizar de forma diferente para esforços adicionais. No primeiro caso, você deve trabalhar para melhorar o algoritmo de pesquisa; no segundo caso, trabalhar em um algoritmo de aprendizado que calcule uma pontuação da Pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diante de uma situação semelhante, alguns pesquisadores decidem aleatoriamente trabalhar em um algoritmo de busca, enquanto outros optam aleatoriamente por trabalhar na melhoria da aprendizagem da função de classificação Score </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S). Mas até você descobrir as verdadeiras causas de um erro no sistema, todos os seus esforços podem ser desperdiçados. Como tomar uma decisão mais sistemática sobre o que vale a pena trabalhar? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sair</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">será a transcrição da saída ("Eu amo robôs"). Seja S * a transcrição correta ("Adoro aprendizado de máquina"). Para entender qual dos dois problemas listados acima está enfrentando, é possível realizar um teste de verificação de otimização: primeiro calcule as pontuações para a Pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S *) e para a Pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fora</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Em seguida, verifique qual das duas classificações será mais importante. Existem duas probabilidades:</font></font><br><br><ol><li> Score <sub>A</sub> (S*) &gt; Score <sub>A</sub> (S <sub>out</sub> ), ..         (). <br><br>               S*.          S <sub>out</sub> .    ,         S,    Score <sub>A</sub> (S).            ,       . ,           (beam search). </li><li> Score <sub>A</sub> (S*) ≤ Score <sub>A</sub> (S <sub>out</sub> ), ..          (). <br><br>     ,     Score <sub>A</sub> (.):         S <sub>out</sub> .         .              Score <sub>A</sub> (S)     S. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa discussão tocou em um único exemplo. Para colocar o teste de controle de otimização em prática, você deve verificar os erros da sua amostra de validação. Para cada erro, você deve verificar se a estimativa para a transcrição esperada (correta) é superior à estimativa da transcrição (incorreta) de saída, ou seja, Escore </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S *)&gt; Escore </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">out</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Cada exemplo da amostra de validação para a qual essa desigualdade persiste será marcado como um erro causado pelo algoritmo de otimização. Cada exemplo para o qual essa desigualdade não persistir será considerado um erro devido ao método incorreto de calcular a Pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (.). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, você descobre que 95% dos erros são causados ​​pelo trabalho da função de avaliação ao calcular a Pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(.) e apenas 5% dos erros são causados ​​pelo algoritmo de otimização. </font><font style="vertical-align: inherit;">Agora você sabe que não importa o quanto melhore sua função de otimização, na realidade, ajudará a eliminar não mais que 5% dos erros. </font><font style="vertical-align: inherit;">Portanto, você deve se concentrar em melhorar o método de cálculo da Pontuação </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (.).</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capítulo 45. Procedimento Geral de Teste de Controle de Otimização</font></font></font> </h3><hr><br>  Você pode aplicar o teste de controle de otimização ao obter x como entrada, sabe como calcular a Pontuação <sub>X</sub> (y), que indica quão bem a saída <b>y</b> corresponde ao <b>x</b> fornecido na entrada.  Além disso, você usa o algoritmo de pesquisa aproximado para encontrar arg max <sub>Y</sub> Score <sub>X</sub> (y), mas suspeita que o algoritmo de pesquisa esteja errado ao encontrar o máximo.  No exemplo anterior, com um sistema de reconhecimento de fala, <b>x</b> = A era uma gravação de áudio e <b>y</b> = S era uma transcrição de saída. <br><br>  Suponha que y * seja o valor de saída correto, mas o algoritmo retornará você.  Então, o principal é verificar como a Pontuação <sub>X</sub> (y *) e a Pontuação <sub>X</sub> (y <sub>out</sub> ) estão relacionadas.  Se a primeira estimativa for maior que a segunda, a causa do erro está no algoritmo de otimização; caso contrário, a falha está na função de cálculo da pontuação Score <sub>X</sub> (y). <br><br>  Vejamos outro exemplo.  Suponha que você esteja criando um sistema de tradução automática do chinês para o inglês.  Seu sistema funciona recebendo uma frase C como entrada, calcula a pontuação <sub>C</sub> (E) para cada versão possível da tradução E. Por exemplo, você pode usar a pontuação <sub>C</sub> (E) = P (E | C), ou seja,  a probabilidade de a transferência ser E, considerando que a sentença C foi enviada. <br><br>  Seu mecanismo de tradução automática está tentando calcular: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-188"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189">S</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190">a</span><span class="MJXp-mrow" id="MJXp-Span-191"><span class="MJXp-mo" id="MJXp-Span-192" style="margin-left: 0em; margin-right: 0em;">í</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-193">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-194">a</span><span class="MJXp-mo" id="MJXp-Span-195" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198">g</span><span class="MJXp-mtext" id="MJXp-Span-199">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201">a</span><span class="MJXp-msubsup" id="MJXp-Span-202"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-204" style="vertical-align: -0.4em;">E</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-205">P</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-207">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-208">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-209">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210">a</span><span class="MJXp-mrow" id="MJXp-Span-211"><span class="MJXp-mo" id="MJXp-Span-212" style="margin-left: 0em; margin-right: 0em;">ç</span></span><span class="MJXp-mrow" id="MJXp-Span-213"><span class="MJXp-mo" id="MJXp-Span-214" style="margin-left: 0em; margin-right: 0em;">ã</span></span><span class="MJXp-msubsup" id="MJXp-Span-215"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-216" style="margin-right: 0.05em;">o</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-217" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-218">C</span></span></span><span class="MJXp-mo" id="MJXp-Span-219" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-220">E</span><span class="MJXp-mo" id="MJXp-Span-221" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-7"> Saída = arg \ max_E Pontuação_ {C} (E) </script></p><br><br>  No entanto, o conjunto de todas as sentenças E possíveis em inglês é tão grande que você precisa contar com um algoritmo heurístico de pesquisa. <br><br>  Suponha que seu algoritmo produza a tradução errada E <sub>com</sub> mais frequência do que uma tradução correta E *.  Em seguida, o teste de controle de otimização permitirá calcular a desigualdade Escore <sub>C</sub> (E *)&gt; Escore <sub>C</sub> (E <sub>out</sub> ).  Se estiver salvo, a Pontuação <sub>C</sub> (.) Reconhece corretamente E * como a melhor saída E, portanto, você atribuirá esse erro ao compartilhamento do algoritmo de pesquisa aproximado, caso contrário, à função de cálculo Pontuação <sub>C</sub> (.). <br><br>  Este é um padrão muito geral no AI: primeiro, treinamos a função de estimativa aproximada Score <sub>x</sub> (.), Depois usamos o algoritmo de maximização aproximado.  Se você se lembrar desse padrão, poderá usar o teste de controle de otimização para encontrar a fonte dos erros. <br><br><hr><h3>  <font color="#548dd4">Capítulo 46. Exemplo de aprendizado por reforço</font> </h3><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0a/gn/mt/0agnmtdytfehwg-iryyvdd6kv7w.png"></div><br>  Suponha que você use o aprendizado de máquina para ensinar um helicóptero a executar manobras complexas.  Acima está uma imagem de lapso de tempo de um helicóptero controlado por um computador que pousa com o motor desligado. <br><br>  Essa manobra é chamada de pouso na autorotação.  Ele permite que o helicóptero aterre, mesmo se o motor travar repentinamente.  Pilotos humanos praticam essa manobra como parte de seu treinamento.  Seu objetivo é usar o algoritmo de aprendizado de máquina para que o helicóptero possa voar ao longo de uma trajetória T e aterrissar com segurança no final. <br><br>  Para aplicar o treinamento de reforço, você deve desenvolver uma “função de recompensa” R (.) Que produza uma estimativa que mostre quão boa cada trajetória possível de T. foi, por exemplo, se a trajetória T levou a um acidente de helicóptero, deixe a recompensa R (T) = - 1000, ou seja,  tem um grande valor negativo.  A trajetória T, que terminou com um pouso bem-sucedido, terá uma estimativa positiva de R (T), que reflete com precisão a dependência de quão suave o pouso foi.  A função de recompensa R (.) Geralmente é selecionada manualmente para quantificar o quanto as várias trajetórias de T. são desejáveis. Deve compensar vários fatores: o quanto ela tremeu durante o pouso, se o helicóptero aterrissou exatamente no lugar certo, o quão difícil foi a descida para os passageiros e assim por diante.  Não é fácil desenvolver bons recursos de recompensa. <br><br>  Dada a função de recompensa R (T), a tarefa do algoritmo de aprendizado por reforço é controlar o helicóptero de modo a atingir o máximo de <sub>TR</sub> (T).  No entanto, os algoritmos de aprendizado por reforço fazem muitas aproximações e podem não ter sucesso em alcançar essa maximização. <br><br>  Suponha que você defina uma função R (.) Reward e execute seu algoritmo de aprendizado.  No entanto, sua eficácia é muito pior do que a de um piloto humano - treme muito durante o pouso e parece menos seguro.  Como determinar se o erro está relacionado ao algoritmo de aprendizado por reforço que está tentando seguir a trajetória max <sub>TR</sub> (T), ou o erro está relacionado à função de recompensa que está tentando medir e determinar a relação ideal entre o choque aceitável durante o pouso e a precisão do local de pouso? <br><br>  Aplicamos o teste de controle de otimização.  Seja T <sub>humano</sub> o caminho seguido pelo piloto e T seja o caminho escolhido pelo algoritmo.  Seguindo a descrição acima, concordamos que a trajetória de T <sub>humano é</sub> melhor que T <sub>out</sub> , então a questão-chave do teste será se R (T <sub>humano</sub> )&gt; R (T <sub>out</sub> ) corresponde à realidade. <br><br>  Opção 1: se essa desigualdade persistir, a função de recompensa R (.) Estima corretamente a trajetória de T <sub>humano</sub> .  Mas o algoritmo de aprendizado por reforço escolheu a trajetória com pior classificação T <sub>out</sub> .  Isso significa que vale a pena trabalhar para melhorar nosso algoritmo de aprendizado por reforço. <br><br>  Opção 2: essa desigualdade não é preservada, ou seja,  R (T <sub>humano</sub> ) ≤ R (T <sub>out</sub> ).  Isso significa que a função de recompensa R (.) Atribuiu o pior resultado para T <sub>humano</sub> , embora essa seja de longe a melhor trajetória.  Você deve trabalhar para melhorar R (.) Para encontrar a melhor proporção de fatores que correspondem a um bom ajuste. <br><br>  Muitos aplicativos de aprendizado de máquina possuem esse "modelo" para otimizar a função Pontuação <sub>x</sub> (.), Usando o algoritmo de pesquisa aproximado.  Às vezes, não temos exatamente a entrada x fornecida, portanto a otimização é reduzida apenas à função de avaliação Pontuação (.).  No exemplo acima, a função de recompensa era a função de recompensa Score (T) = R (T), e o algoritmo de otimização era o algoritmo de aprendizado por reforço tentando calcular uma boa trajetória T. <br><br>  A única diferença entre este exemplo e os anteriores é que, em vez de comparar com o resultado “ideal”, o comparamos com a eficiência humana para o T <sub>humano</sub> .  Assumimos que a trajetória <sub>humana</sub> T seja razoavelmente boa, mesmo que não seja ótima.  Em geral, desde que você tenha algum y * (T <sub>humano</sub> neste exemplo), que é a melhor saída em termos de eficiência para o seu algoritmo de aprendizado atual (mesmo que não seja "ideal"), o teste de controle de otimização pode mostrar se haverá mais prometendo melhorar o algoritmo de otimização ou a função de avaliação. <br><br><br>  [ <a href="https://habr.com/ru/post/485190/">Continuação</a> ] </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485070/">https://habr.com/ru/post/pt485070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485050/index.html">Hypercube. Como fornecemos aos desenvolvedores dispositivos de teste e não os perdemos</a></li>
<li><a href="../pt485052/index.html">Quem é um bom QA?</a></li>
<li><a href="../pt485056/index.html">Dividir e conquistar</a></li>
<li><a href="../pt485058/index.html">“Verifique o relógio”: o que se sabe sobre o novo protocolo de sincronização de horário do servidor</a></li>
<li><a href="../pt485068/index.html">Código Limpo para TypeScript - Parte 2</a></li>
<li><a href="../pt485074/index.html">Como não morrer em um projeto ou 5 hacks de vida</a></li>
<li><a href="../pt485078/index.html">Difícil, vulnerável, subconfigurado: ameaças cibernéticas 2020</a></li>
<li><a href="../pt485080/index.html">Patos NgRx | Fachadas dinâmicas</a></li>
<li><a href="../pt485084/index.html">Plâncton de escritório - Evolução</a></li>
<li><a href="../pt485088/index.html">Ancinho retrospectivo. Como uma solução criada por si mesma foi mais fria do que paga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>