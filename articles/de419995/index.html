<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêó üåï üò¢ Eine Studie von Ivy, dem neuen Angular-Compiler üî≥ üç≥ üè¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="" Ich denke, Compiler sind sehr interessant ", sagt Uri Shaked, der Autor des Materials, das wir heute ver√∂ffentlichen. Letztes Jahr schrieb er einen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Studie von Ivy, dem neuen Angular-Compiler</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419995/">  " <i>Ich denke, Compiler sind sehr interessant</i> ", sagt Uri Shaked, der Autor des Materials, das wir heute ver√∂ffentlichen.  Letztes Jahr schrieb er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> √ºber das Reverse Engineering des Angular-Compilers und die Simulation einiger Phasen des Kompilierungsprozesses, um die Merkmale der internen Struktur dieses Mechanismus besser zu verstehen.  Es sollte beachtet werden, dass das, wor√ºber der Autor dieses Materials als ‚ÄûCompiler‚Äú spricht, normalerweise als ‚ÄûRendering-Engine‚Äú bezeichnet wird. <br><br>  Als Uri h√∂rte, dass eine neue Version des Angular-Compilers namens Ivy ver√∂ffentlicht wurde, wollte er sofort genauer hinschauen und herausfinden, was sich daran gegen√ºber der alten Version ge√§ndert hatte.  Hier erh√§lt der Compiler nach wie vor die von Angular erstellten Vorlagen und Komponenten, die in regul√§ren HTML- und JavaScript-Code konvertiert werden, der f√ºr Chrome und andere Browser verst√§ndlich ist. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/6o/ha/fa/6ohafariunj4046cd6nokfypam0.jpeg"></a> <br><br>  Wenn Sie die neue Version des Compilers mit der vorherigen vergleichen, stellt sich heraus, dass Ivy den Tree-Shaking-Algorithmus verwendet.  Dies bedeutet, dass der Compiler nicht verwendete Codefragmente automatisch l√∂scht (dies gilt auch f√ºr Angular-Code), wodurch die Gr√∂√üe der Projektpakete verringert wird.  Eine weitere Verbesserung betrifft die Tatsache, dass jetzt jede Datei unabh√§ngig kompiliert wird, was die Zeit f√ºr die Neukompilierung verk√ºrzt.  Kurz gesagt, dank des neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compilers erhalten</a> wir kleinere Assemblys, eine beschleunigte Neukompilierung von Projekten und einfacheren vorgefertigten Code. <br><br>  Zu verstehen, wie der Compiler funktioniert, ist an und f√ºr sich interessant (zumindest der Autor des Materials hofft dies), aber es hilft auch, die internen Mechanismen von Angular besser zu verstehen.  Dies f√ºhrt zu einer Verbesserung der F√§higkeiten des "Angular-Denkens", wodurch Sie dieses Framework effektiver f√ºr die Webentwicklung nutzen k√∂nnen. <br><br>  Wissen Sie √ºbrigens, warum der neue Compiler Ivy hei√üt?  Tatsache ist, dass dieses Wort wie eine Kombination von vorgelesenen Buchstaben ‚ÄûIV‚Äú klingt, die die Zahl 4 darstellt, die in r√∂mischen Ziffern geschrieben ist.  "4" ist die vierte Generation von Angular-Compilern. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Efeu-Anwendung</font> </h2><br>  Ivy befindet sich noch in einer intensiven Entwicklung, dieser Prozess kann hier beobachtet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Obwohl der Compiler selbst noch nicht f√ºr den Kampfeinsatz geeignet ist, ist die Abstraktion von RendererV3, die er verwenden wird, bereits recht funktionsf√§hig und wird mit Angular 6.x geliefert. <br><br>  Obwohl Ivy noch nicht ganz fertig ist, k√∂nnen wir uns noch die Ergebnisse seiner Arbeit ansehen.  Wie kann man das machen?  Durch Erstellen eines neuen Angular-Projekts: <br><br><pre><code class="hljs cs">ng <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ivy-internals</code> </pre> <br>  Danach m√ºssen Sie Ivy aktivieren, indem Sie der Datei <code>tsconfig.json</code> im neuen Projektordner die folgenden Zeilen hinzuf√ºgen: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  <code>ngc</code> Schluss starten wir den Compiler, indem wir den Befehl <code>ngc</code> im neu erstellten Projektordner ausf√ºhren: <br><br><pre> <code class="hljs">node_modules/.bin/ngc</code> </pre> <br>  Das ist alles.  Jetzt k√∂nnen Sie den generierten Code im <code>dist/out-tsc</code> .  Sehen Sie sich beispielsweise das folgende Fragment der <code>AppComponent</code> Vorlage an: <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"‚Ä¶"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Hier sind einige Links, die Ihnen den Einstieg erleichtern:</font> </h2><br>  Den f√ºr diese Vorlage generierten Code finden Sie in der <code>dist/out-tsc/src/app/app.component.js</code> : <br><br><pre> <code class="hljs smalltalk">i0.…µ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">"div"</span></span>, _c0); i0.…µ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h1"</span></span>); i0.…µ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); i0.…µe(); i0.…µ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-comment"><span class="hljs-comment">"img"</span></span>, _c1); i0.…µe(); i0.…µe(); i0.…µ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h2"</span></span>); i0.…µ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"Here are some links to help you start: "</span></span>); i0.…µe();</code> </pre> <br>  In dieser Art von JavaScript-Code transformiert Ivy die Komponentenvorlage.  So wurde in der vorherigen Version des Compilers dasselbe gemacht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/d3a/278/1f4d3a278708237e5558f313b316e780.png"></div><br>  <i><font color="#999999">Code, der von einer fr√ºheren Version des Angular-Compilers erstellt wurde</font></i> <br><br>  Es besteht das Gef√ºhl, dass der von Ivy generierte Code viel einfacher ist.  Sie k√∂nnen mit der Komponentenvorlage experimentieren (sie befindet sich in <code>src/app/app.component.html</code> ), sie erneut kompilieren und sehen, wie sich die daran vorgenommenen √Ñnderungen auf den generierten Code auswirken. <br><br><h2>  <font color="#3AC1EF">Generierten Code analysieren</font> </h2><br>  Versuchen wir, den generierten Code zu analysieren und genau zu sehen, welche Aktionen er ausf√ºhrt.  <code>i0.…µE</code> <code>i0.…µT</code> beispielsweise nach einer Antwort auf eine Frage zur Bedeutung von Anrufen wie <code>i0.…µE</code> und <code>i0.…µT</code> <br><br>  Wenn Sie sich den Anfang der generierten Datei ansehen, finden Sie dort den folgenden Ausdruck: <br><br><pre> <code class="hljs perl">var i<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>);</code> </pre> <br>  <code>i0</code> ist also nur das Angular-Kernmodul, und all dies sind die von Angular exportierten Funktionen.  Der Buchstabe <code>…µ</code> vom Angular-Entwicklungsteam verwendet, um anzugeben, dass einige Methoden ausschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interne</a> Framework- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mechanismen</a> bereitstellen sollen, dh Benutzer sollten sie nicht direkt aufrufen, da die Invarianz der API dieser Methoden nicht garantiert wird, wenn neue Versionen von Angular ver√∂ffentlicht werden (tats√§chlich) Ich w√ºrde sagen, dass sich ihre APIs fast garantiert √§ndern werden. <br><br>  Alle diese Methoden sind also private APIs, die von Angular exportiert werden.  Es ist einfach, ihre Funktionalit√§t herauszufinden, indem Sie das Projekt in VS Code √∂ffnen und die Tooltips analysieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3df/800/ffb/3df800ffb5948fa113362e73f7d7b54c.png"></div><br>  <i><font color="#999999">Code-Analyse in VS-Code</font></i> <br><br>  Obwohl hier eine JavaScript-Datei analysiert wird, verwendet VS Code Typinformationen von TypeScript, um die Anrufsignatur zu identifizieren und Dokumentation f√ºr eine bestimmte Methode zu finden.  Wenn Sie nach Auswahl des Methodennamens die Kombination Strg + Klick (Cmd + Klick auf Mac) verwenden, stellen wir fest, dass der tats√§chliche Name dieser Methode <code>elementStart</code> . <br><br>  Diese Technik erm√∂glichte es herauszufinden, dass der Methodenname <code>…µT</code> <code>text</code> , der Methodenname <code>…µe</code> ist <code>elementEnd</code> .  Mit diesem Wissen k√∂nnen wir den generierten Code ‚Äû√ºbersetzen‚Äú und ihn in etwas verwandeln, das bequemer zu lesen ist.  Hier ist ein kleines Fragment einer solchen "√úbersetzung": <br><br><pre> <code class="hljs ruby">var core = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"angular/core"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... core.elementStart(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>, _c<span class="hljs-number"><span class="hljs-number">0</span></span>); core.elementStart(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"h1"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">2</span></span>); core. (); core.elementStart(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"img"</span></span>, _c1); core.elementEnd(); core.elementEnd(); core.elementStart(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"h2"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"Here are some links to help you start: "</span></span>); core.elementEnd();</code> </pre> <br>  Und wie bereits erw√§hnt, entspricht dieser Code dem folgenden Text aus der HTML-Vorlage: <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"‚Ä¶"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Hier sind einige Links, die Ihnen den Einstieg erleichtern:</font> </h2><br>  Nach all dieser Analyse f√§llt Folgendes leicht auf: <br><br><ul><li>  Jedes √∂ffnende HTML-Tag hat einen Aufruf von <code>core.elementStart()</code> . </li><li>  Die schlie√üenden Tags entsprechen Aufrufen von <code>core.elementEnd()</code> . </li><li>  <code>core.text()</code> entsprechen Aufrufen von <code>core.text()</code> . </li></ul><br>  Das erste Argument f√ºr die Methoden <code>elementStart</code> und <code>text</code> ist eine Zahl, deren Wert mit jedem Aufruf zunimmt.  Es stellt wahrscheinlich einen Index in einem Array dar, in dem Angular Links zu erstellten Elementen speichert. <br><br>  Das dritte Argument wird ebenfalls an die <code>elementStart</code> Methode √ºbergeben.  Nachdem wir die obigen Materialien untersucht haben, k√∂nnen wir schlie√üen, dass das Argument optional ist und eine Liste von Attributen f√ºr den DOM-Knoten enth√§lt.  Sie k√∂nnen dies √ºberpr√ºfen, indem Sie den Wert von <code>_c0</code> und feststellen, dass er eine Liste von Attributen und deren Werten f√ºr das <code>div</code> Element enth√§lt: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _c0 = [<span class="hljs-string"><span class="hljs-string">"style"</span></span>, <span class="hljs-string"><span class="hljs-string">"text-align:center"</span></span>];</code> </pre> <br><h2>  <font color="#3AC1EF">NgComponentDef Hinweis</font> </h2><br>  Bisher haben wir den Teil des generierten Codes analysiert, der f√ºr das Rendern der Vorlage f√ºr die Komponente verantwortlich ist.  Dieser Code befindet sich tats√§chlich in einem gr√∂√üeren Codeteil, der <code>AppComponent.ngComponentDef</code> zugewiesen <code>AppComponent.ngComponentDef</code> - einer statischen Eigenschaft, die alle Metadaten zu der Komponente enth√§lt, z. B. CSS-Selektoren, ihre √Ñnderungserkennungsstrategie (falls angegeben) und die Vorlage.  Wenn Sie Lust auf Abenteuer haben, k√∂nnen Sie jetzt selbstst√§ndig herausfinden, wie es funktioniert, obwohl wir weiter unten darauf eingehen werden. <br><br><h2>  <font color="#3AC1EF">Hausgemachter Efeu</font> </h2><br>  Nachdem wir nun allgemein verstanden haben, wie der generierte Code aussieht, k√∂nnen wir versuchen, unsere eigene Komponente mit derselben RendererV3-API, die Ivy verwendet, von Grund auf neu zu erstellen. <br><br>  Der Code, den wir erstellen werden, √§hnelt dem Code, den der Compiler erstellt, aber wir werden ihn so gestalten, dass er leichter zu lesen ist. <br><br>  Beginnen wir mit dem Schreiben einer einfachen Komponente und √ºbersetzen sie dann manuell in Code, der dem von Ivy √§hnelt: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>, template: <span class="hljs-string"><span class="hljs-string">'&lt;h2&gt;&lt;font color="#3AC1EF"&gt;Hello, Component&lt;/font&gt;&lt;/h2&gt;'</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br>  Der Compiler verwendet die Eingabe des <code>@component</code> Dekorators als <code>@component</code> , erstellt Anweisungen und ordnet sie dann als statische Eigenschaft der Komponentenklasse an.  Um die Aktivit√§t von Ivy zu simulieren, entfernen wir daher den <code>@component</code> Dekorator und ersetzen ihn durch die statische <code>ngComponent</code> Eigenschaft: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.…µdefineComponent({   <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ManualComponent,   <span class="hljs-attr"><span class="hljs-attr">selectors</span></span>: [[<span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>]],   <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ManualComponent(),   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rf: core.…µRenderFlags, ctx: ManualComponent</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-comment"><span class="hljs-comment">//       }, }); }</span></span></code> </pre> <br>  Wir definieren Metadaten f√ºr die kompilierte Komponente, indem <code>…µdefineComponent</code> aufrufen.  Zu den Metadaten geh√∂ren der Komponententyp (der zuvor zum Implementieren der Abh√§ngigkeit verwendet wurde), der CSS-Selektor (oder die Selektoren), der diese Komponente aufruft (in unserem Fall ist die <code>manual-component</code> der Name der Komponente in der HTML-Vorlage), die Factory, die die neue Instanz zur√ºckgibt Komponente und dann die Funktion, die die Vorlage f√ºr die Komponente definiert.  Diese Vorlage zeigt eine visuelle Darstellung der Komponente an und aktualisiert sie, wenn sich die Eigenschaften der Komponente √§ndern.  Um diese Vorlage zu erstellen, verwenden wir die oben gefundenen Methoden: <code>…µE</code> , <code>…µe</code> und <code>…µT</code> . <br><br><pre> <code class="hljs ruby">    <span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.…µRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; {     core.…µE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);                 <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2     core.…µT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, Component'</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       core.…µe();                        <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2   },</code> </pre> <br>  Zu diesem Zeitpunkt verwenden wir nicht die von unserer Vorlagenfunktion bereitgestellten <code>ctf</code> oder <code>ctf</code> Parameter.  Wir werden auf sie zur√ºckkommen.  Schauen wir uns zun√§chst an, wie unsere erste selbstgemachte Komponente auf dem Bildschirm angezeigt wird. <br><br><h2>  <font color="#3AC1EF">Erste Bewerbung</font> </h2><br>  Um Komponenten auf dem Bildschirm anzuzeigen, exportiert Angular eine Methode namens <code>…µrenderComponent</code> .  Sie m√ºssen <code>index.html</code> √ºberpr√ºfen, ob die Datei <code>index.html</code> ein HTML-Tag enth√§lt, das der Elementauswahl <code>&lt;manual-component&gt;</code> , und am Ende der Datei Folgendes hinzuf√ºgen: <br><br><pre> <code class="hljs">core.…µrenderComponent(ManualComponent);</code> </pre> <br>  Das ist alles.  Jetzt haben wir eine minimale selbst erstellte Angular-Anwendung, die nur aus 16 Codezeilen besteht.  Sie k√∂nnen mit der fertigen Anwendung auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StackBlitz experimentieren</a> . <br><br><h2>  <font color="#3AC1EF">√Ñnderungserkennungsmechanismus</font> </h2><br>  Wir haben also ein funktionierendes Beispiel.  K√∂nnen Sie dem Interaktivit√§t hinzuf√ºgen?  Sagen wir, wie w√§re es mit etwas Interessantem, wie der Verwendung des √Ñnderungserkennungssystems von Angular hier? <br><br>  √Ñndern Sie die Komponente so, dass der Benutzer den Begr√º√üungstext anpassen kann.  Das hei√üt, anstatt dass die Komponente immer den Text <code>Hello, Component</code> anzeigt, lassen wir den Benutzer den Teil des Textes √§ndern, der nach <code>Hello</code> . <br><br>  Wir beginnen mit dem Hinzuf√ºgen der Eigenschaft <code>name</code> und einer Methode zum Aktualisieren des Werts dieser Eigenschaft f√ºr die Komponentenklasse: <br><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ManualComponent</span></span> { name = <span class="hljs-string"><span class="hljs-string">'Component'</span></span>; updateName(newName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Das alles sieht zwar nicht besonders beeindruckend aus, aber das Interessanteste liegt vor uns. <br><br>  Als N√§chstes bearbeiten wir die Vorlagenfunktion so, dass anstelle von unver√§nderlichem Text der Inhalt der Eigenschaft <code>name</code> angezeigt wird: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.…µRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :        core.…µE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.…µT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.…µT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;--   name   core.…µe(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :       core.…µt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ctx -     } },</code> </pre> <br>  M√∂glicherweise haben Sie bemerkt, dass wir die Vorlagenanweisungen in <code>if</code> , die die <code>rf</code> Werte √ºberpr√ºfen.  Dieser Parameter wird von Angular verwendet, um anzugeben, ob die Komponente zum ersten Mal erstellt wird (das niedrigstwertige Bit wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesetzt</a> ), oder wir m√ºssen nur den dynamischen Inhalt aktualisieren, um √Ñnderungen zu erkennen (dies ist das Ziel der zweiten <code>if</code> ). <br><br>  Wenn die Komponente zum ersten Mal angezeigt wird, erstellen wir alle Elemente. Wenn √Ñnderungen erkannt werden, aktualisieren wir nur die √Ñnderungen.  <code>…µt</code> interne Methode <code>…µt</code> verantwortlich (beachten Sie den Kleinbuchstaben <code>t</code> ), die der von Angular exportierten Funktion <code>textBinding</code> entspricht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/347/c31/e48347c31b7532a1268509cf0825a031.png"></div><br>  <i><font color="#999999">Funktion textBinding</font></i> <br><br>  Der erste Parameter ist also der Index des zu aktualisierenden Elements, der zweite der Wert.  In diesem Fall erstellen wir mit dem Befehl <code>core.…µT(2);</code> ein leeres Textelement mit Index <code>core.…µT(2);</code>  .  Es fungiert als Platzhalter f√ºr den <code>name</code> .  Wir aktualisieren es mit dem Befehl <code>core.…µt(2, ctx.name);</code>  bei Erkennung einer √Ñnderung der entsprechenden Variablen. <br><br>  Im Moment zeigt die Ausgabe dieser Komponente weiterhin den Text <code>Hello, Component</code> , obwohl wir den Wert der Eigenschaft <code>name</code> √§ndern k√∂nnen, was zu einer √Ñnderung des Textes auf dem Bildschirm f√ºhrt. <br><br>  Damit die Anwendung wirklich interaktiv wird, f√ºgen wir hier ein Dateneingabefeld mit einem Ereignis-Listener hinzu, der die Komponentenmethode <code>updateName()</code> : <br><br><pre> <code class="hljs php">template: (rf: core.…µRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.…µE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.…µT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.…µT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   core.…µe();   core.…µT(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'Your name: '</span></span>);   core.…µE(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'input'</span></span>);   core.…µL(<span class="hljs-string"><span class="hljs-string">'input'</span></span>, $event =&gt; ctx.updateName($event.target.value));   core.…µe(); } <span class="hljs-comment"><span class="hljs-comment">// ... },</span></span></code> </pre> <br>  Die Ereignisbindung wird in der Zeile <code>core.…µL('input', $event =&gt; ctx.updateName($event.target.value));</code>  .  Die <code>…µL</code> Methode <code>…µL</code> verantwortlich, den Ereignis-Listener f√ºr das aktuellste der deklarierten Elemente <code>…µL</code> .  Das erste Argument ist der Name des Ereignisses (in diesem Fall ist die <code>input</code> das Ereignis, das ausgel√∂st wird, wenn sich der Inhalt des <code>&lt;input&gt;</code> -Elements √§ndert), das zweite Argument ist ein R√ºckruf.  Dieser R√ºckruf akzeptiert Ereignisdaten als Argument.  Dann extrahieren wir den aktuellen Wert aus dem Zielelement des Ereignisses, dh aus dem <code>&lt;input&gt;</code> -Element, und √ºbergeben ihn an die Funktion in der Komponente. <br><br>  Der obige Code entspricht dem Schreiben des folgenden HTML-Codes in eine Vorlage: <br><br><pre> <code class="hljs pgsql">Your <span class="hljs-type"><span class="hljs-type">name</span></span>: &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>)="updateName($event.target.value)" /&gt;</code> </pre> <br>  Jetzt k√∂nnen Sie den Inhalt des <code>&lt;input&gt;</code> -Elements bearbeiten und beobachten, wie sich der Text in der Komponente √§ndert.  Das Eingabefeld wird jedoch beim Laden der Komponente nicht ausgef√ºllt.  Damit alles auf diese Weise funktioniert, m√ºssen Sie dem Vorlagenfunktionscode eine weitere Anweisung hinzuf√ºgen, die ausgef√ºhrt wird, wenn eine √Ñnderung festgestellt wird: <br><br><pre> <code class="hljs coffeescript">template: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.…µRenderFlags, ctx: ManualComponent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   core.…µt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);   core.…µp(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, ctx.name); } }</code> </pre> <br>  Hier verwenden wir eine andere integrierte Methode des Renderingsystems, <code>…µp</code> , die die Eigenschaft eines Elements mit einem bestimmten Index aktualisiert.  In diesem Fall wird Index 4 an die Methode √ºbergeben, bei der es sich um den Index handelt, der dem <code>input</code> zugewiesen ist, und wir <code>ctx.name</code> Methode an, den Wert <code>ctx.name</code> in die <code>value</code> Eigenschaft dieses Elements <code>ctx.name</code> . <br><br>  Jetzt ist unser Beispiel endlich fertig.  Wir haben die bidirektionale Datenbindung mithilfe der Ivy-Rendering-System-API von Grund auf implementiert.  Das ist einfach toll. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier k√∂nnen</a> Sie mit dem fertigen Code experimentieren. <br><br>  Wir sind jetzt mit den meisten Grundbausteinen des neuen Ivy-Compilers vertraut.  Wir wissen, wie man Elemente und Textknoten erstellt, Eigenschaften bindet und Ereignis-Listener konfiguriert und wie man das √Ñnderungserkennungssystem verwendet. <br><br><h2>  <font color="#3AC1EF">Informationen zu den Bl√∂cken * ngIf und * ngFor</font> </h2><br>  Bevor wir die Ivy-Studie beenden, schauen wir uns ein anderes interessantes Thema an.  Lassen Sie uns n√§mlich dar√ºber sprechen, wie der Compiler mit Untermustern arbeitet.  Dies sind die Muster, die f√ºr <code>*ngIf</code> oder <code>*ngFor</code> .  Sie werden auf besondere Weise verarbeitet.  Schauen wir uns an, wie Sie <code>*ngIf</code> in unserem hausgemachten Vorlagencode verwenden. <br><br>  Zuerst m√ºssen Sie das npm-Paket <code>@angular/common</code> <code>*ngIf</code> <code>@angular/common</code> installieren - hier wird <code>*ngIf</code> .  Als n√§chstes m√ºssen Sie die Direktive aus diesem Paket importieren: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">import</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">NgIf</span></span> } from <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@angular</span></span></span><span class="hljs-string">/common'</span></span>;</code> </pre> <br>  Um <code>NgIf</code> in der Vorlage verwenden zu k√∂nnen, m√ºssen Sie einige Metadaten bereitstellen, da das Modul <code>@angular/common</code> nicht mit Ivy kompiliert wurde (zumindest beim Schreiben des Materials, und dies wird sich in Zukunft wahrscheinlich √§ndern Einf√ºhrung von <a href="">ngcc</a> ). <br><br>  Wir werden die <code>…µdefineDirective</code> Methode verwenden, die mit der bekannten <code>…µdefineComponent</code> Methode zusammenh√§ngt.  Es definiert Metadaten f√ºr Direktiven: <br><br><pre> <code class="hljs coffeescript">(NgIf <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).ngDirectiveDef = core.…µdefineDirective({ type: NgIf, selectors: [[<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]], factory: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NgIf(core.…µinjectViewContainerRef(), core.…µinjectTemplateRef()), inputs: {ngIf: <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, ngIfThen: <span class="hljs-string"><span class="hljs-string">'ngIfThen'</span></span>, ngIfElse: <span class="hljs-string"><span class="hljs-string">'ngIfElse'</span></span>} });</code> </pre> <br>  Ich habe diese Definition im <a href="">Angular-Quellcode</a> zusammen mit der <code>ngFor</code> .  <code>NgIf</code> wir <code>NgIf</code> f√ºr die Verwendung in Ivy vorbereitet haben, k√∂nnen wir der Liste der Anweisungen f√ºr die Komponente Folgendes hinzuf√ºgen: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.…µdefineComponent({ directives: [<span class="hljs-type"><span class="hljs-type">NgIf</span></span>], // ... });</code> </pre> <br>  Als N√§chstes definieren wir das Untermuster nur f√ºr die durch <code>*ngIf</code> begrenzte <code>*ngIf</code> . <br><br>  Angenommen, Sie m√ºssen ein Bild anzeigen.  Lassen Sie uns eine neue Funktion f√ºr diese Vorlage innerhalb der Vorlagenfunktion festlegen: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.…µRenderFlags, ctx: ManualComponent)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.…µE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'div'</span></span>);   core.…µE(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'img'</span></span>, [<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://pbs.twimg.com/tweet_video_thumb/C80o289UQAAKIqp.jpg'</span></span>]);   core.…µe(); } }</code> </pre> <br>  Diese Vorlagenfunktion unterscheidet sich nicht von der bereits geschriebenen.  Es verwendet dieselben Konstrukte, um ein <code>img</code> Element innerhalb eines <code>div</code> Elements zu erstellen. <br><br>  Und schlie√ülich k√∂nnen wir alles zusammenf√ºgen, indem <code>ngIf</code> der Komponentenvorlage die Direktive <code>ngIf</code> hinzuf√ºgen: <br><br><pre> <code class="hljs powershell">template: (rf: core.…µRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   // ...   core.…µC(<span class="hljs-number"><span class="hljs-number">5</span></span>, ifTemplate, null, [<span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   // ...   core.…µp(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, (ctx.name === <span class="hljs-string"><span class="hljs-string">'Igor'</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.…µRenderFlags, ctx: ManualComponent)</span></span></span></span> {   // ... } },</code> </pre> <br>  Beachten Sie den Aufruf der neuen Methode am Anfang des Codes ( <code>core.…µC(5, ifTemplate, null, ['ngIf']);</code> ).  Es deklariert ein neues Containerelement, dh ein Element mit einer Vorlage.  Das erste Argument ist der Index des Elements, wir haben solche Indizes bereits gesehen.  Das zweite Argument ist die soeben definierte Untermusterfunktion.  Es wird als Vorlage f√ºr das Containerelement verwendet.  Der dritte Parameter ist der Tag-Name f√ºr das Element, was hier nicht sinnvoll ist, und schlie√ülich gibt es eine Liste von Anweisungen und Attributen, die diesem Element zugeordnet sind.  Hier kommt <code>ngIf</code> ins <code>ngIf</code> . <br><br>  In der Zeile <code>core.…µp(5, 'ngIf', (ctx.name === 'Igor'));</code>  Der Status des Elements wird aktualisiert, indem das Attribut <code>ngIf</code> an den Wert des logischen Ausdrucks <code>ctx.name === 'Igor'</code> .  Dies pr√ºft, ob die <code>name</code> Eigenschaft der Komponente gleich <code>Igor</code> . <br><br>  Der obige Code entspricht dem folgenden HTML-Code: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name === 'Igor'"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Hier kann festgestellt werden, dass der neue Compiler nicht den kompaktesten Code erzeugt, aber im Vergleich zu dem, was er jetzt ist, nicht so schlecht ist. <br><br>  Hier k√∂nnen Sie mit einem neuen Beispiel experimentieren.  <code>NgIf</code> den Namen <code>Igor</code> in das Feld <code>Your name</code> , um den Abschnitt <code>NgIf</code> in Aktion zu sehen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wir haben uns ziemlich viel mit den Funktionen des Ivy-Compilers besch√§ftigt.  Hoffentlich hat diese Reise Ihr Interesse an einer weiteren Erkundung von Angular geweckt.  Wenn ja, dann haben Sie jetzt alles, was Sie brauchen, um mit Ivy zu experimentieren.  Jetzt wissen Sie, wie Sie Vorlagen in JavaScript ‚Äû√ºbersetzen‚Äú und auf dieselben Winkelmechanismen zugreifen, die Ivy verwendet, ohne diesen Compiler zu verwenden.  Ich nehme an, all dies gibt Ihnen die M√∂glichkeit, die neuen Winkelmechanismen so tief zu erkunden, wie Sie m√∂chten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="">hier</a> - drei Materialien, in denen Sie n√ºtzliche Informationen √ºber Ivy finden.  Und <a href="">hier</a> ist der Quellcode f√ºr Render3. <br><br>  <b>Liebe Leser!</b>  Wie denkst du √ºber die neuen Funktionen von Ivy? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419995/">https://habr.com/ru/post/de419995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419985/index.html">Klats, klats: die Geschichte von Cherry, die f√ºr Tastaturschalter ber√ºhmt wurde</a></li>
<li><a href="../de419987/index.html">Was Blutstropfen sagen werden: Trigonometrie von Verbrechen</a></li>
<li><a href="../de419989/index.html">Neuseeland verbietet Plastikt√ºten</a></li>
<li><a href="../de419991/index.html">Autonome Drohnen werden Vogelschw√§rme von Flugh√§fen treiben</a></li>
<li><a href="../de419993/index.html">TypeScript-Interview: 20 Fragen und Antworten</a></li>
<li><a href="../de419997/index.html">Analysieren des Musters "Modul" in JavaScript</a></li>
<li><a href="../de419999/index.html">Freigabe der Yii1 / yii2-Authentifizierung</a></li>
<li><a href="../de420001/index.html">Einf√ºhrung in 3CX v15.5 Update 6 BETA und WebRTC Browser Softphone</a></li>
<li><a href="../de420003/index.html">Fenster mit Schaltfl√§chen in JavaFX:</a></li>
<li><a href="../de420005/index.html">Die unprofessionelle Video√ºberwachung der Wohnung ist unterhaltsam und kosteng√ºnstig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>