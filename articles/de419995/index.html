<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐗 🌕 😢 Eine Studie von Ivy, dem neuen Angular-Compiler 🔳 🍳 🏢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="" Ich denke, Compiler sind sehr interessant ", sagt Uri Shaked, der Autor des Materials, das wir heute veröffentlichen. Letztes Jahr schrieb er einen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Studie von Ivy, dem neuen Angular-Compiler</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419995/">  " <i>Ich denke, Compiler sind sehr interessant</i> ", sagt Uri Shaked, der Autor des Materials, das wir heute veröffentlichen.  Letztes Jahr schrieb er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> über das Reverse Engineering des Angular-Compilers und die Simulation einiger Phasen des Kompilierungsprozesses, um die Merkmale der internen Struktur dieses Mechanismus besser zu verstehen.  Es sollte beachtet werden, dass das, worüber der Autor dieses Materials als „Compiler“ spricht, normalerweise als „Rendering-Engine“ bezeichnet wird. <br><br>  Als Uri hörte, dass eine neue Version des Angular-Compilers namens Ivy veröffentlicht wurde, wollte er sofort genauer hinschauen und herausfinden, was sich daran gegenüber der alten Version geändert hatte.  Hier erhält der Compiler nach wie vor die von Angular erstellten Vorlagen und Komponenten, die in regulären HTML- und JavaScript-Code konvertiert werden, der für Chrome und andere Browser verständlich ist. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/6o/ha/fa/6ohafariunj4046cd6nokfypam0.jpeg"></a> <br><br>  Wenn Sie die neue Version des Compilers mit der vorherigen vergleichen, stellt sich heraus, dass Ivy den Tree-Shaking-Algorithmus verwendet.  Dies bedeutet, dass der Compiler nicht verwendete Codefragmente automatisch löscht (dies gilt auch für Angular-Code), wodurch die Größe der Projektpakete verringert wird.  Eine weitere Verbesserung betrifft die Tatsache, dass jetzt jede Datei unabhängig kompiliert wird, was die Zeit für die Neukompilierung verkürzt.  Kurz gesagt, dank des neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compilers erhalten</a> wir kleinere Assemblys, eine beschleunigte Neukompilierung von Projekten und einfacheren vorgefertigten Code. <br><br>  Zu verstehen, wie der Compiler funktioniert, ist an und für sich interessant (zumindest der Autor des Materials hofft dies), aber es hilft auch, die internen Mechanismen von Angular besser zu verstehen.  Dies führt zu einer Verbesserung der Fähigkeiten des "Angular-Denkens", wodurch Sie dieses Framework effektiver für die Webentwicklung nutzen können. <br><br>  Wissen Sie übrigens, warum der neue Compiler Ivy heißt?  Tatsache ist, dass dieses Wort wie eine Kombination von vorgelesenen Buchstaben „IV“ klingt, die die Zahl 4 darstellt, die in römischen Ziffern geschrieben ist.  "4" ist die vierte Generation von Angular-Compilern. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Efeu-Anwendung</font> </h2><br>  Ivy befindet sich noch in einer intensiven Entwicklung, dieser Prozess kann hier beobachtet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Obwohl der Compiler selbst noch nicht für den Kampfeinsatz geeignet ist, ist die Abstraktion von RendererV3, die er verwenden wird, bereits recht funktionsfähig und wird mit Angular 6.x geliefert. <br><br>  Obwohl Ivy noch nicht ganz fertig ist, können wir uns noch die Ergebnisse seiner Arbeit ansehen.  Wie kann man das machen?  Durch Erstellen eines neuen Angular-Projekts: <br><br><pre><code class="hljs cs">ng <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ivy-internals</code> </pre> <br>  Danach müssen Sie Ivy aktivieren, indem Sie der Datei <code>tsconfig.json</code> im neuen Projektordner die folgenden Zeilen hinzufügen: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  <code>ngc</code> Schluss starten wir den Compiler, indem wir den Befehl <code>ngc</code> im neu erstellten Projektordner ausführen: <br><br><pre> <code class="hljs">node_modules/.bin/ngc</code> </pre> <br>  Das ist alles.  Jetzt können Sie den generierten Code im <code>dist/out-tsc</code> .  Sehen Sie sich beispielsweise das folgende Fragment der <code>AppComponent</code> Vorlage an: <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"…"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Hier sind einige Links, die Ihnen den Einstieg erleichtern:</font> </h2><br>  Den für diese Vorlage generierten Code finden Sie in der <code>dist/out-tsc/src/app/app.component.js</code> : <br><br><pre> <code class="hljs smalltalk">i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">"div"</span></span>, _c0); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h1"</span></span>); i0.ɵ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); i0.ɵe(); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-comment"><span class="hljs-comment">"img"</span></span>, _c1); i0.ɵe(); i0.ɵe(); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h2"</span></span>); i0.ɵ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"Here are some links to help you start: "</span></span>); i0.ɵe();</code> </pre> <br>  In dieser Art von JavaScript-Code transformiert Ivy die Komponentenvorlage.  So wurde in der vorherigen Version des Compilers dasselbe gemacht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/d3a/278/1f4d3a278708237e5558f313b316e780.png"></div><br>  <i><font color="#999999">Code, der von einer früheren Version des Angular-Compilers erstellt wurde</font></i> <br><br>  Es besteht das Gefühl, dass der von Ivy generierte Code viel einfacher ist.  Sie können mit der Komponentenvorlage experimentieren (sie befindet sich in <code>src/app/app.component.html</code> ), sie erneut kompilieren und sehen, wie sich die daran vorgenommenen Änderungen auf den generierten Code auswirken. <br><br><h2>  <font color="#3AC1EF">Generierten Code analysieren</font> </h2><br>  Versuchen wir, den generierten Code zu analysieren und genau zu sehen, welche Aktionen er ausführt.  <code>i0.ɵE</code> <code>i0.ɵT</code> beispielsweise nach einer Antwort auf eine Frage zur Bedeutung von Anrufen wie <code>i0.ɵE</code> und <code>i0.ɵT</code> <br><br>  Wenn Sie sich den Anfang der generierten Datei ansehen, finden Sie dort den folgenden Ausdruck: <br><br><pre> <code class="hljs perl">var i<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>);</code> </pre> <br>  <code>i0</code> ist also nur das Angular-Kernmodul, und all dies sind die von Angular exportierten Funktionen.  Der Buchstabe <code>ɵ</code> vom Angular-Entwicklungsteam verwendet, um anzugeben, dass einige Methoden ausschließlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interne</a> Framework- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mechanismen</a> bereitstellen sollen, dh Benutzer sollten sie nicht direkt aufrufen, da die Invarianz der API dieser Methoden nicht garantiert wird, wenn neue Versionen von Angular veröffentlicht werden (tatsächlich) Ich würde sagen, dass sich ihre APIs fast garantiert ändern werden. <br><br>  Alle diese Methoden sind also private APIs, die von Angular exportiert werden.  Es ist einfach, ihre Funktionalität herauszufinden, indem Sie das Projekt in VS Code öffnen und die Tooltips analysieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3df/800/ffb/3df800ffb5948fa113362e73f7d7b54c.png"></div><br>  <i><font color="#999999">Code-Analyse in VS-Code</font></i> <br><br>  Obwohl hier eine JavaScript-Datei analysiert wird, verwendet VS Code Typinformationen von TypeScript, um die Anrufsignatur zu identifizieren und Dokumentation für eine bestimmte Methode zu finden.  Wenn Sie nach Auswahl des Methodennamens die Kombination Strg + Klick (Cmd + Klick auf Mac) verwenden, stellen wir fest, dass der tatsächliche Name dieser Methode <code>elementStart</code> . <br><br>  Diese Technik ermöglichte es herauszufinden, dass der Methodenname <code>ɵT</code> <code>text</code> , der Methodenname <code>ɵe</code> ist <code>elementEnd</code> .  Mit diesem Wissen können wir den generierten Code „übersetzen“ und ihn in etwas verwandeln, das bequemer zu lesen ist.  Hier ist ein kleines Fragment einer solchen "Übersetzung": <br><br><pre> <code class="hljs ruby">var core = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"angular/core"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... core.elementStart(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>, _c<span class="hljs-number"><span class="hljs-number">0</span></span>); core.elementStart(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"h1"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">2</span></span>); core. (); core.elementStart(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"img"</span></span>, _c1); core.elementEnd(); core.elementEnd(); core.elementStart(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"h2"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"Here are some links to help you start: "</span></span>); core.elementEnd();</code> </pre> <br>  Und wie bereits erwähnt, entspricht dieser Code dem folgenden Text aus der HTML-Vorlage: <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"…"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Hier sind einige Links, die Ihnen den Einstieg erleichtern:</font> </h2><br>  Nach all dieser Analyse fällt Folgendes leicht auf: <br><br><ul><li>  Jedes öffnende HTML-Tag hat einen Aufruf von <code>core.elementStart()</code> . </li><li>  Die schließenden Tags entsprechen Aufrufen von <code>core.elementEnd()</code> . </li><li>  <code>core.text()</code> entsprechen Aufrufen von <code>core.text()</code> . </li></ul><br>  Das erste Argument für die Methoden <code>elementStart</code> und <code>text</code> ist eine Zahl, deren Wert mit jedem Aufruf zunimmt.  Es stellt wahrscheinlich einen Index in einem Array dar, in dem Angular Links zu erstellten Elementen speichert. <br><br>  Das dritte Argument wird ebenfalls an die <code>elementStart</code> Methode übergeben.  Nachdem wir die obigen Materialien untersucht haben, können wir schließen, dass das Argument optional ist und eine Liste von Attributen für den DOM-Knoten enthält.  Sie können dies überprüfen, indem Sie den Wert von <code>_c0</code> und feststellen, dass er eine Liste von Attributen und deren Werten für das <code>div</code> Element enthält: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _c0 = [<span class="hljs-string"><span class="hljs-string">"style"</span></span>, <span class="hljs-string"><span class="hljs-string">"text-align:center"</span></span>];</code> </pre> <br><h2>  <font color="#3AC1EF">NgComponentDef Hinweis</font> </h2><br>  Bisher haben wir den Teil des generierten Codes analysiert, der für das Rendern der Vorlage für die Komponente verantwortlich ist.  Dieser Code befindet sich tatsächlich in einem größeren Codeteil, der <code>AppComponent.ngComponentDef</code> zugewiesen <code>AppComponent.ngComponentDef</code> - einer statischen Eigenschaft, die alle Metadaten zu der Komponente enthält, z. B. CSS-Selektoren, ihre Änderungserkennungsstrategie (falls angegeben) und die Vorlage.  Wenn Sie Lust auf Abenteuer haben, können Sie jetzt selbstständig herausfinden, wie es funktioniert, obwohl wir weiter unten darauf eingehen werden. <br><br><h2>  <font color="#3AC1EF">Hausgemachter Efeu</font> </h2><br>  Nachdem wir nun allgemein verstanden haben, wie der generierte Code aussieht, können wir versuchen, unsere eigene Komponente mit derselben RendererV3-API, die Ivy verwendet, von Grund auf neu zu erstellen. <br><br>  Der Code, den wir erstellen werden, ähnelt dem Code, den der Compiler erstellt, aber wir werden ihn so gestalten, dass er leichter zu lesen ist. <br><br>  Beginnen wir mit dem Schreiben einer einfachen Komponente und übersetzen sie dann manuell in Code, der dem von Ivy ähnelt: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>, template: <span class="hljs-string"><span class="hljs-string">'&lt;h2&gt;&lt;font color="#3AC1EF"&gt;Hello, Component&lt;/font&gt;&lt;/h2&gt;'</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br>  Der Compiler verwendet die Eingabe des <code>@component</code> Dekorators als <code>@component</code> , erstellt Anweisungen und ordnet sie dann als statische Eigenschaft der Komponentenklasse an.  Um die Aktivität von Ivy zu simulieren, entfernen wir daher den <code>@component</code> Dekorator und ersetzen ihn durch die statische <code>ngComponent</code> Eigenschaft: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.ɵdefineComponent({   <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ManualComponent,   <span class="hljs-attr"><span class="hljs-attr">selectors</span></span>: [[<span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>]],   <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ManualComponent(),   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rf: core.ɵRenderFlags, ctx: ManualComponent</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-comment"><span class="hljs-comment">//       }, }); }</span></span></code> </pre> <br>  Wir definieren Metadaten für die kompilierte Komponente, indem <code>ɵdefineComponent</code> aufrufen.  Zu den Metadaten gehören der Komponententyp (der zuvor zum Implementieren der Abhängigkeit verwendet wurde), der CSS-Selektor (oder die Selektoren), der diese Komponente aufruft (in unserem Fall ist die <code>manual-component</code> der Name der Komponente in der HTML-Vorlage), die Factory, die die neue Instanz zurückgibt Komponente und dann die Funktion, die die Vorlage für die Komponente definiert.  Diese Vorlage zeigt eine visuelle Darstellung der Komponente an und aktualisiert sie, wenn sich die Eigenschaften der Komponente ändern.  Um diese Vorlage zu erstellen, verwenden wir die oben gefundenen Methoden: <code>ɵE</code> , <code>ɵe</code> und <code>ɵT</code> . <br><br><pre> <code class="hljs ruby">    <span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.ɵRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; {     core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);                 <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2     core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, Component'</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       core.ɵe();                        <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2   },</code> </pre> <br>  Zu diesem Zeitpunkt verwenden wir nicht die von unserer Vorlagenfunktion bereitgestellten <code>ctf</code> oder <code>ctf</code> Parameter.  Wir werden auf sie zurückkommen.  Schauen wir uns zunächst an, wie unsere erste selbstgemachte Komponente auf dem Bildschirm angezeigt wird. <br><br><h2>  <font color="#3AC1EF">Erste Bewerbung</font> </h2><br>  Um Komponenten auf dem Bildschirm anzuzeigen, exportiert Angular eine Methode namens <code>ɵrenderComponent</code> .  Sie müssen <code>index.html</code> überprüfen, ob die Datei <code>index.html</code> ein HTML-Tag enthält, das der Elementauswahl <code>&lt;manual-component&gt;</code> , und am Ende der Datei Folgendes hinzufügen: <br><br><pre> <code class="hljs">core.ɵrenderComponent(ManualComponent);</code> </pre> <br>  Das ist alles.  Jetzt haben wir eine minimale selbst erstellte Angular-Anwendung, die nur aus 16 Codezeilen besteht.  Sie können mit der fertigen Anwendung auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StackBlitz experimentieren</a> . <br><br><h2>  <font color="#3AC1EF">Änderungserkennungsmechanismus</font> </h2><br>  Wir haben also ein funktionierendes Beispiel.  Können Sie dem Interaktivität hinzufügen?  Sagen wir, wie wäre es mit etwas Interessantem, wie der Verwendung des Änderungserkennungssystems von Angular hier? <br><br>  Ändern Sie die Komponente so, dass der Benutzer den Begrüßungstext anpassen kann.  Das heißt, anstatt dass die Komponente immer den Text <code>Hello, Component</code> anzeigt, lassen wir den Benutzer den Teil des Textes ändern, der nach <code>Hello</code> . <br><br>  Wir beginnen mit dem Hinzufügen der Eigenschaft <code>name</code> und einer Methode zum Aktualisieren des Werts dieser Eigenschaft für die Komponentenklasse: <br><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ManualComponent</span></span> { name = <span class="hljs-string"><span class="hljs-string">'Component'</span></span>; updateName(newName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Das alles sieht zwar nicht besonders beeindruckend aus, aber das Interessanteste liegt vor uns. <br><br>  Als Nächstes bearbeiten wir die Vorlagenfunktion so, dass anstelle von unveränderlichem Text der Inhalt der Eigenschaft <code>name</code> angezeigt wird: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.ɵRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :        core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;--   name   core.ɵe(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :       core.ɵt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ctx -     } },</code> </pre> <br>  Möglicherweise haben Sie bemerkt, dass wir die Vorlagenanweisungen in <code>if</code> , die die <code>rf</code> Werte überprüfen.  Dieser Parameter wird von Angular verwendet, um anzugeben, ob die Komponente zum ersten Mal erstellt wird (das niedrigstwertige Bit wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesetzt</a> ), oder wir müssen nur den dynamischen Inhalt aktualisieren, um Änderungen zu erkennen (dies ist das Ziel der zweiten <code>if</code> ). <br><br>  Wenn die Komponente zum ersten Mal angezeigt wird, erstellen wir alle Elemente. Wenn Änderungen erkannt werden, aktualisieren wir nur die Änderungen.  <code>ɵt</code> interne Methode <code>ɵt</code> verantwortlich (beachten Sie den Kleinbuchstaben <code>t</code> ), die der von Angular exportierten Funktion <code>textBinding</code> entspricht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/347/c31/e48347c31b7532a1268509cf0825a031.png"></div><br>  <i><font color="#999999">Funktion textBinding</font></i> <br><br>  Der erste Parameter ist also der Index des zu aktualisierenden Elements, der zweite der Wert.  In diesem Fall erstellen wir mit dem Befehl <code>core.ɵT(2);</code> ein leeres Textelement mit Index <code>core.ɵT(2);</code>  .  Es fungiert als Platzhalter für den <code>name</code> .  Wir aktualisieren es mit dem Befehl <code>core.ɵt(2, ctx.name);</code>  bei Erkennung einer Änderung der entsprechenden Variablen. <br><br>  Im Moment zeigt die Ausgabe dieser Komponente weiterhin den Text <code>Hello, Component</code> , obwohl wir den Wert der Eigenschaft <code>name</code> ändern können, was zu einer Änderung des Textes auf dem Bildschirm führt. <br><br>  Damit die Anwendung wirklich interaktiv wird, fügen wir hier ein Dateneingabefeld mit einem Ereignis-Listener hinzu, der die Komponentenmethode <code>updateName()</code> : <br><br><pre> <code class="hljs php">template: (rf: core.ɵRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   core.ɵe();   core.ɵT(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'Your name: '</span></span>);   core.ɵE(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'input'</span></span>);   core.ɵL(<span class="hljs-string"><span class="hljs-string">'input'</span></span>, $event =&gt; ctx.updateName($event.target.value));   core.ɵe(); } <span class="hljs-comment"><span class="hljs-comment">// ... },</span></span></code> </pre> <br>  Die Ereignisbindung wird in der Zeile <code>core.ɵL('input', $event =&gt; ctx.updateName($event.target.value));</code>  .  Die <code>ɵL</code> Methode <code>ɵL</code> verantwortlich, den Ereignis-Listener für das aktuellste der deklarierten Elemente <code>ɵL</code> .  Das erste Argument ist der Name des Ereignisses (in diesem Fall ist die <code>input</code> das Ereignis, das ausgelöst wird, wenn sich der Inhalt des <code>&lt;input&gt;</code> -Elements ändert), das zweite Argument ist ein Rückruf.  Dieser Rückruf akzeptiert Ereignisdaten als Argument.  Dann extrahieren wir den aktuellen Wert aus dem Zielelement des Ereignisses, dh aus dem <code>&lt;input&gt;</code> -Element, und übergeben ihn an die Funktion in der Komponente. <br><br>  Der obige Code entspricht dem Schreiben des folgenden HTML-Codes in eine Vorlage: <br><br><pre> <code class="hljs pgsql">Your <span class="hljs-type"><span class="hljs-type">name</span></span>: &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>)="updateName($event.target.value)" /&gt;</code> </pre> <br>  Jetzt können Sie den Inhalt des <code>&lt;input&gt;</code> -Elements bearbeiten und beobachten, wie sich der Text in der Komponente ändert.  Das Eingabefeld wird jedoch beim Laden der Komponente nicht ausgefüllt.  Damit alles auf diese Weise funktioniert, müssen Sie dem Vorlagenfunktionscode eine weitere Anweisung hinzufügen, die ausgeführt wird, wenn eine Änderung festgestellt wird: <br><br><pre> <code class="hljs coffeescript">template: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   core.ɵt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);   core.ɵp(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, ctx.name); } }</code> </pre> <br>  Hier verwenden wir eine andere integrierte Methode des Renderingsystems, <code>ɵp</code> , die die Eigenschaft eines Elements mit einem bestimmten Index aktualisiert.  In diesem Fall wird Index 4 an die Methode übergeben, bei der es sich um den Index handelt, der dem <code>input</code> zugewiesen ist, und wir <code>ctx.name</code> Methode an, den Wert <code>ctx.name</code> in die <code>value</code> Eigenschaft dieses Elements <code>ctx.name</code> . <br><br>  Jetzt ist unser Beispiel endlich fertig.  Wir haben die bidirektionale Datenbindung mithilfe der Ivy-Rendering-System-API von Grund auf implementiert.  Das ist einfach toll. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können</a> Sie mit dem fertigen Code experimentieren. <br><br>  Wir sind jetzt mit den meisten Grundbausteinen des neuen Ivy-Compilers vertraut.  Wir wissen, wie man Elemente und Textknoten erstellt, Eigenschaften bindet und Ereignis-Listener konfiguriert und wie man das Änderungserkennungssystem verwendet. <br><br><h2>  <font color="#3AC1EF">Informationen zu den Blöcken * ngIf und * ngFor</font> </h2><br>  Bevor wir die Ivy-Studie beenden, schauen wir uns ein anderes interessantes Thema an.  Lassen Sie uns nämlich darüber sprechen, wie der Compiler mit Untermustern arbeitet.  Dies sind die Muster, die für <code>*ngIf</code> oder <code>*ngFor</code> .  Sie werden auf besondere Weise verarbeitet.  Schauen wir uns an, wie Sie <code>*ngIf</code> in unserem hausgemachten Vorlagencode verwenden. <br><br>  Zuerst müssen Sie das npm-Paket <code>@angular/common</code> <code>*ngIf</code> <code>@angular/common</code> installieren - hier wird <code>*ngIf</code> .  Als nächstes müssen Sie die Direktive aus diesem Paket importieren: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">import</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">NgIf</span></span> } from <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@angular</span></span></span><span class="hljs-string">/common'</span></span>;</code> </pre> <br>  Um <code>NgIf</code> in der Vorlage verwenden zu können, müssen Sie einige Metadaten bereitstellen, da das Modul <code>@angular/common</code> nicht mit Ivy kompiliert wurde (zumindest beim Schreiben des Materials, und dies wird sich in Zukunft wahrscheinlich ändern Einführung von <a href="">ngcc</a> ). <br><br>  Wir werden die <code>ɵdefineDirective</code> Methode verwenden, die mit der bekannten <code>ɵdefineComponent</code> Methode zusammenhängt.  Es definiert Metadaten für Direktiven: <br><br><pre> <code class="hljs coffeescript">(NgIf <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).ngDirectiveDef = core.ɵdefineDirective({ type: NgIf, selectors: [[<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]], factory: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NgIf(core.ɵinjectViewContainerRef(), core.ɵinjectTemplateRef()), inputs: {ngIf: <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, ngIfThen: <span class="hljs-string"><span class="hljs-string">'ngIfThen'</span></span>, ngIfElse: <span class="hljs-string"><span class="hljs-string">'ngIfElse'</span></span>} });</code> </pre> <br>  Ich habe diese Definition im <a href="">Angular-Quellcode</a> zusammen mit der <code>ngFor</code> .  <code>NgIf</code> wir <code>NgIf</code> für die Verwendung in Ivy vorbereitet haben, können wir der Liste der Anweisungen für die Komponente Folgendes hinzufügen: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.ɵdefineComponent({ directives: [<span class="hljs-type"><span class="hljs-type">NgIf</span></span>], // ... });</code> </pre> <br>  Als Nächstes definieren wir das Untermuster nur für die durch <code>*ngIf</code> begrenzte <code>*ngIf</code> . <br><br>  Angenommen, Sie müssen ein Bild anzeigen.  Lassen Sie uns eine neue Funktion für diese Vorlage innerhalb der Vorlagenfunktion festlegen: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'div'</span></span>);   core.ɵE(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'img'</span></span>, [<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://pbs.twimg.com/tweet_video_thumb/C80o289UQAAKIqp.jpg'</span></span>]);   core.ɵe(); } }</code> </pre> <br>  Diese Vorlagenfunktion unterscheidet sich nicht von der bereits geschriebenen.  Es verwendet dieselben Konstrukte, um ein <code>img</code> Element innerhalb eines <code>div</code> Elements zu erstellen. <br><br>  Und schließlich können wir alles zusammenfügen, indem <code>ngIf</code> der Komponentenvorlage die Direktive <code>ngIf</code> hinzufügen: <br><br><pre> <code class="hljs powershell">template: (rf: core.ɵRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   // ...   core.ɵC(<span class="hljs-number"><span class="hljs-number">5</span></span>, ifTemplate, null, [<span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   // ...   core.ɵp(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, (ctx.name === <span class="hljs-string"><span class="hljs-string">'Igor'</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span></span> {   // ... } },</code> </pre> <br>  Beachten Sie den Aufruf der neuen Methode am Anfang des Codes ( <code>core.ɵC(5, ifTemplate, null, ['ngIf']);</code> ).  Es deklariert ein neues Containerelement, dh ein Element mit einer Vorlage.  Das erste Argument ist der Index des Elements, wir haben solche Indizes bereits gesehen.  Das zweite Argument ist die soeben definierte Untermusterfunktion.  Es wird als Vorlage für das Containerelement verwendet.  Der dritte Parameter ist der Tag-Name für das Element, was hier nicht sinnvoll ist, und schließlich gibt es eine Liste von Anweisungen und Attributen, die diesem Element zugeordnet sind.  Hier kommt <code>ngIf</code> ins <code>ngIf</code> . <br><br>  In der Zeile <code>core.ɵp(5, 'ngIf', (ctx.name === 'Igor'));</code>  Der Status des Elements wird aktualisiert, indem das Attribut <code>ngIf</code> an den Wert des logischen Ausdrucks <code>ctx.name === 'Igor'</code> .  Dies prüft, ob die <code>name</code> Eigenschaft der Komponente gleich <code>Igor</code> . <br><br>  Der obige Code entspricht dem folgenden HTML-Code: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name === 'Igor'"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Hier kann festgestellt werden, dass der neue Compiler nicht den kompaktesten Code erzeugt, aber im Vergleich zu dem, was er jetzt ist, nicht so schlecht ist. <br><br>  Hier können Sie mit einem neuen Beispiel experimentieren.  <code>NgIf</code> den Namen <code>Igor</code> in das Feld <code>Your name</code> , um den Abschnitt <code>NgIf</code> in Aktion zu sehen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wir haben uns ziemlich viel mit den Funktionen des Ivy-Compilers beschäftigt.  Hoffentlich hat diese Reise Ihr Interesse an einer weiteren Erkundung von Angular geweckt.  Wenn ja, dann haben Sie jetzt alles, was Sie brauchen, um mit Ivy zu experimentieren.  Jetzt wissen Sie, wie Sie Vorlagen in JavaScript „übersetzen“ und auf dieselben Winkelmechanismen zugreifen, die Ivy verwendet, ohne diesen Compiler zu verwenden.  Ich nehme an, all dies gibt Ihnen die Möglichkeit, die neuen Winkelmechanismen so tief zu erkunden, wie Sie möchten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="">hier</a> - drei Materialien, in denen Sie nützliche Informationen über Ivy finden.  Und <a href="">hier</a> ist der Quellcode für Render3. <br><br>  <b>Liebe Leser!</b>  Wie denkst du über die neuen Funktionen von Ivy? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419995/">https://habr.com/ru/post/de419995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419985/index.html">Klats, klats: die Geschichte von Cherry, die für Tastaturschalter berühmt wurde</a></li>
<li><a href="../de419987/index.html">Was Blutstropfen sagen werden: Trigonometrie von Verbrechen</a></li>
<li><a href="../de419989/index.html">Neuseeland verbietet Plastiktüten</a></li>
<li><a href="../de419991/index.html">Autonome Drohnen werden Vogelschwärme von Flughäfen treiben</a></li>
<li><a href="../de419993/index.html">TypeScript-Interview: 20 Fragen und Antworten</a></li>
<li><a href="../de419997/index.html">Analysieren des Musters "Modul" in JavaScript</a></li>
<li><a href="../de419999/index.html">Freigabe der Yii1 / yii2-Authentifizierung</a></li>
<li><a href="../de420001/index.html">Einführung in 3CX v15.5 Update 6 BETA und WebRTC Browser Softphone</a></li>
<li><a href="../de420003/index.html">Fenster mit Schaltflächen in JavaFX:</a></li>
<li><a href="../de420005/index.html">Die unprofessionelle Videoüberwachung der Wohnung ist unterhaltsam und kostengünstig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>