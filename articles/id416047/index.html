<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😁 🎀 🌓 Kursus MIT "Keamanan Sistem Komputer". Kuliah 2: "Kontrol serangan hacker", bagian 2 🔏 ㊗️ 👦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 2: "Kontrol serangan hacker", bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416047/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: “Pendahuluan: model ancaman” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Jadi, kami memiliki penyangga tempat kami meletakkan "kenari".  Di atas itu adalah penunjuk breakpoint yang <b>disimpan menyimpan</b> nilai <b>EBP</b> dan alamat pengirim ditempatkan di atasnya.  Jika Anda ingat, luapan meluap dari bawah ke atas, jadi sebelum Anda sampai ke alamat pengirim, itu akan menghancurkan "kenari" terlebih dahulu. <br><br><img src="https://habrastorage.org/webt/va/0q/i_/va0qi_40d-7cknrooq7olqwfbga.jpeg"><br><br>  <b>Hadirin:</b> mengapa hal itu memengaruhi "kenari"? <br><br>  <b>Profesor:</b> karena diasumsikan bahwa penyerang tidak tahu bagaimana sewenang-wenang "melompat" dalam memori.  Serangan memory overflow tradisional dimulai dengan seorang hacker memeriksa batas ukuran buffer, setelah itu overflow dimulai dari garis bawah.  Tapi Anda benar - jika penyerang bisa langsung masuk ke bilah alamat pengirim, tidak ada "kenari" yang akan membantu kami.  Namun, dengan serangan buffer overflow tradisional, semuanya harus terjadi persis seperti itu - dari bawah ke atas. <br><br>  Dengan demikian, ide utama menggunakan "kenari" adalah bahwa kami memungkinkan eksploit jahat meluap buffer memori.  Kami memiliki kode run-time yang, ketika kembali dari suatu fungsi, memeriksa "kenari" untuk memastikan bahwa ia memiliki nilai yang benar. <br><br>  <b>Hadirin:</b> Dapatkah penyerang menulis ulang alamat pengirim dan mengubah "kenari"?  Bagaimana dia dapat memverifikasi bahwa itu telah dimodifikasi, tetapi terus memenuhi fungsinya? <br><br>  <b>Profesor:</b> ya, mungkin.  Dengan demikian, Anda harus memiliki beberapa kode yang benar-benar akan memeriksa ini sebelum fungsinya kembali.  Artinya, dalam hal ini, perlu mendapat dukungan dari kompiler, yang sebenarnya akan memperluas <b>konvensi pemanggilan konvensi pemanggilan</b> .  Sehingga bagian dari urutan pengembalian terjadi sebelum kita mempertimbangkan validitas dari nilai ini untuk memastikan bahwa "kenari" belum dihancurkan.  Hanya setelah itu kita bisa memikirkan hal lain. <br><br>  <b>Hadirin:</b> Tidak bisakah penyerang tahu atau menebak apa arti "kenari"? <br><br>  <b>Profesor:</b> inilah tepatnya yang akan saya bicarakan!  Apa masalah dengan sirkuit ini?  Bagaimana jika, misalnya, kita menempatkan nilai A di setiap program?  Atau seluruh cabang 4 nilai A?  Tentu saja, setiap hacker dapat mengetahui ukuran buffer, kapasitasnya, dan dengan demikian menentukan posisi "kenari" dalam sistem apa pun.  Karena itu, kita dapat menggunakan berbagai jenis kuantitas yang kita masukkan ke dalam "kenari" untuk mencegah hal ini. <br><br>  Ada satu hal yang dapat Anda lakukan dengan "kenari" kami.  Ini akan menjadi tipe "kenari" yang sangat lucu, yang menggunakan fungsi program C dan memproses karakter khusus, yang disebut tipe deterministik "kenari". <br><br><img src="https://habrastorage.org/webt/ww/nu/7w/wwnu7wtc-tnfgf7iwtux0guvoli.jpeg"><br><br>  Bayangkan Anda menggunakan karakter 0 untuk "kenari". Nilai biner nol adalah byte nol, karakter nol di ASCII.  Nilai -1 berarti kembali ke posisi sebelumnya dan seterusnya.  Banyak fungsi menghentikan atau mengubah operasi ketika mereka menemukan karakter atau nilai-nilai seperti 0, CR, LF, -1.  Bayangkan bahwa Anda, sebagai peretas, menggunakan beberapa fungsi manajemen string untuk naik buffer, menemukan karakter 0 di "kenari" dan proses berhenti!  Jika Anda menggunakan fungsi “carriage return” -1, yang sering digunakan sebagai terminator garis, prosesnya juga akan berhenti.  Jadi -1 adalah tanda ajaib lain. <br><br>  Ada satu hal lagi yang dapat digunakan dalam "kenari" - ini adalah nilai acak yang sulit ditebak untuk penyerang.  Kekuatan nilai acak didasarkan pada seberapa sulit bagi seorang penyerang untuk menebaknya.  Misalnya, jika penyerang menyadari bahwa hanya ada 3 bit entropi di sistem Anda, maka ia akan dapat menggunakan serangan brute-force.  Oleh karena itu, kemungkinan menggunakan angka acak untuk melindungi dari serangan sangat terbatas. <br><br><img src="https://habrastorage.org/webt/a0/qf/au/a0qfauye6kmbnvhhfifmesgudy0.jpeg"><br><br>  <b>Audiens:</b> Biasanya saya membaca dari buffer lain dan menulis apa yang saya baca di buffer tumpukan ini.  Dalam situasi ini, tampaknya nilai acak "kenari" tidak berguna, karena saya membaca data dari buffer lain dan saya tahu di mana "kenari" itu.  Saya memiliki buffer lain yang saya kontrol dan yang tidak pernah saya periksa.  Dan di buffer ini saya bisa memasukkan apa yang ingin saya masukkan.  Saya tidak memerlukan “kenari” acak, karena saya dapat menulis ulang dengan aman.  Jadi saya tidak melihat cara kerjanya - dalam skenario yang Anda usulkan, ketika fungsi berhenti saat membaca data dari buffer. <br><br>  <b>Profesor:</b> Saya mengerti pertanyaan Anda - maksud Anda bahwa kami menggunakan "kenari" deterministik, tetapi jangan gunakan salah satu fungsi perpustakaan standar yang dapat "ditipu" oleh karakter kami 0, CR, LF, -1.  Maka ya, dalam situasi yang Anda jelaskan, "kenari" tidak diperlukan. <br><br>  Idenya adalah Anda dapat mengisi buffer ini dengan byte dari mana saja, tetapi apa pun yang memungkinkan Anda untuk menebak nilai-nilai ini atau mendapatkannya secara acak akan menyebabkan kegagalan. <br><br>  <b>Hadirin:</b> Apakah mungkin menggunakan sesuatu seperti jumlah detik atau milidetik sebagai angka acak dan menggunakannya dalam "kenari"? <br><br>  <b>Profesor:</b> Panggilan data tidak mengandung kecelakaan sebanyak yang Anda pikirkan.  Karena program memiliki log atau fungsi yang dapat Anda hubungi untuk mengetahui kapan program itu diunduh, dan hal-hal serupa lainnya.  Tetapi secara umum, Anda benar - dalam praktiknya, jika Anda dapat menggunakan perangkat perangkat keras, biasanya dari level rendah, dengan pengaturan waktu sistem yang lebih baik, pendekatan semacam ini mungkin berhasil. <br><br>  <b>Hadirin:</b> bahkan jika kami berhasil melihat log tentang awal buffer overflow, masih penting kapan kami menolak permintaan tersebut.  Dan jika kita tidak bisa mendapatkan kontrol atas berapa lama permintaan komputer ke server, diragukan bahwa waktu yang tepat dapat ditebak secara deterministik. <br><br>  <b>Profesor:</b> benar sekali, saya sudah mengatakan bahwa kejahatan terletak pada perincian, ini hanya kasus seperti itu.  Dengan kata lain, jika Anda memiliki beberapa cara untuk, misalnya, menentukan jenis saluran waktu, Anda mungkin menemukan bahwa jumlah entropi, atau jumlah keacakan, tidak mengisi seluruh timestamp, tetapi lebih sedikit.  Oleh karena itu, seorang penyerang dapat menentukan jam dan menit kapan Anda melakukan ini, tetapi tidak satu detik. <br><br>  <b>Hadirin:</b> sebagai catatan, mencoba mengurangi keacakan Anda sendiri adalah ide yang buruk? <br><br>  <b>Profesor:</b> benar sekali! <br><br>  <b>Hadirin:</b> yaitu, biasanya kita hanya perlu menggunakan segala sesuatu yang didukung sistem kita, bukan? <br><br>  <b>Profesor:</b> ya, itu benar.  Ini seperti penemuan cryptosystem kita sendiri, yang merupakan hal populer yang kadang-kadang ingin dilakukan oleh lulusan kita.  Tapi kami bukan NSA, kami bukan ahli matematika, jadi ini biasanya gagal.  Jadi Anda benar tentang itu. <br><br>  Tetapi bahkan jika Anda menggunakan keacakan sistem, Anda masih bisa mendapatkan lebih sedikit entropi daripada yang Anda harapkan.  Biarkan saya memberi Anda contoh pengacakan fase alamat.  Pada prinsip inilah pendekatan <b>stack canaries bekerja</b> .  Karena kita terlibat dalam keamanan komputer, Anda mungkin bertanya-tanya dalam kasus apa "burung kenari" tidak dapat mengatasi tugas mereka dan apakah ada cara untuk gagal "kenari". <br><br>  Salah satu caranya adalah serangan dengan menulis ulang pointer fungsi.  Karena jika pukulan mengenai pointer fungsi, "kenari" tidak dapat melakukan apa pun. <br><br>  Misalkan Anda memiliki kode bentuk <b>int * ptr ... ..</b> , pointer awal, tidak peduli bagaimana, maka Anda memiliki buffer <b>buf char [128]</b> , fungsi <b>mendapat (buf)</b> , dan di paling bawah pointer yang diberi nilai tertentu : <b>* ptr = 5</b> . <br><br>  Saya perhatikan bahwa kami tidak mencoba menyerang alamat pengirim dari fungsi yang berisi kode ini.  Seperti yang Anda lihat, ketika buffer meluap, alamat pointer yang terletak di atasnya akan rusak.  Jika seorang penyerang dapat merusak pointer ini, maka ia kemudian dapat menetapkan 5 ke salah satu alamat yang ia kontrol.  Bisakah semua orang melihat bahwa "kenari" tidak akan membantu di sini?  Karena kita tidak menyerang jalur di mana fungsi kembali. <br><br><img src="https://habrastorage.org/webt/hz/oq/em/hzoqemqhfljf4w6rzownchcppbc.jpeg"><br><br>  <b>Pemirsa:</b> dapatkah penunjuk berada di bawah buffer? <br><br>  <b>Profesor: memang</b> bisa, tetapi urutan variabel tertentu bergantung pada banyak hal berbeda, pada cara kompiler mengatur konten, pada ukuran kolom perangkat keras, dan sebagainya.  Tapi Anda benar, jika buffer overflow naik, dan pointer terletak di bawah buffer, maka overflow tidak dapat merusaknya. <br><br>  <b>Hadirin:</b> mengapa Anda tidak dapat mengaitkan "kenari" dengan fungsi "kenari", seperti yang Anda lakukan dengan alamat pengirim? <br><br>  <b>Profesor:</b> ini adalah momen yang menarik!  Anda dapat melakukan hal-hal seperti itu.  Bahkan, Anda dapat mencoba membayangkan kompiler yang setiap kali memiliki pointer, selalu mencoba untuk menambahkan add-on untuk beberapa hal.  Namun, memeriksa semua hal ini akan terlalu mahal.  Karena setiap kali Anda ingin menggunakan pointer atau memanggil fungsi apa pun, Anda harus memiliki kode yang akan memeriksa apakah "kenari" ini benar.  Pada dasarnya, Anda bisa melakukan hal serupa, tetapi apakah itu masuk akal?  Kami melihat bahwa "kenari" tidak membantu dalam situasi ini. <br><br>  Dan satu hal lagi yang kita bahas sebelumnya adalah bahwa jika penyerang dapat menebak keacakan, maka, pada prinsipnya, "kenari" acak tidak akan berfungsi.  Membuat sumber daya keamanan berdasarkan keacakan adalah topik terpisah, sangat kompleks, jadi kami tidak akan membahasnya. <br><br><img src="https://habrastorage.org/webt/1v/iw/s5/1viws5-axjes3hud4zigpabrxas.jpeg"><br><br>  <b>Hadirin:</b> Jadi kenari mengandung bit lebih sedikit dari alamat pengirim?  Karena kalau tidak, Anda tidak bisa hanya mengingat alamat ini dan memeriksa apakah alamatnya sudah berubah? <br><br>  <b>Profesor:</b> mari kita lihat.  Anda berbicara tentang skema ini ketika "kenari" terletak di atas buffer, dan Anda berarti bahwa sistem tidak dapat aman jika tidak mungkin untuk melihat alamat pengirim dan memeriksa apakah sudah diubah. <br><br><img src="https://habrastorage.org/webt/xg/nf/1m/xgnf1mj-jvjf1g1lu27xu7di4pm.jpeg"><br><br>  Ya dan tidak  Harap perhatikan bahwa jika serangan buffer overflow terjadi, apa pun di atasnya akan ditimpa, jadi ini masih dapat menyebabkan masalah.  Tetapi pada dasarnya, jika hal-hal ini tidak dapat diubah dengan cara apa pun, maka Anda dapat melakukan sesuatu seperti ini.  Tetapi masalahnya adalah bahwa dalam banyak kasus, memanipulasi alamat pengirim adalah hal yang agak rumit.  Karena Anda dapat membayangkan bahwa fungsi khusus dapat dipanggil dari tempat yang berbeda, dan seterusnya.  Dalam hal ini, kami berlari sedikit di depan, dan jika ada waktu di akhir kuliah, kami akan kembali ke ini. <br><br>  Ini adalah situasi di mana "kenari" mungkin gagal.  Ada tempat-tempat lain di mana kegagalan dimungkinkan, misalnya, ketika menyerang <b>malloc</b> dan fungsi-fungsi <b>gratis</b> .  Fungsi malloc mengalokasikan blok memori dengan ukuran tertentu dalam byte dan mengembalikan pointer ke awal blok.  Isi blok memori yang dialokasikan tidak diinisialisasi, tetap dengan nilai yang tidak ditentukan.  Dan fungsi <b>bebas</b> membebaskan memori yang sebelumnya dialokasikan secara dinamis. <br><br>  Ini adalah serangan unik dalam gaya C. Mari kita lihat apa yang terjadi di sini.  Bayangkan Anda memiliki dua pointer di sini, p dan q, yang kami gunakan <b>malloc untuk</b> mengalokasikan 1,024 byte memori untuk masing-masing pointer ini.  Misalkan kita membuat fungsi <b>strcpy</b> untuk p dari beberapa jenis kesalahan buffer yang dikendalikan oleh penyerang.  Di sinilah terjadi overflow.  Dan kemudian kita jalankan perintah <b>free q</b> dan <b>free p</b> .  Ini kode yang cukup sederhana, bukan? <br><br><img src="https://habrastorage.org/webt/dt/o7/rt/dto7rtltvhx7lcdnytlifp7cvzw.jpeg"><br><br>  Kami memiliki 2 pointer yang mengalokasikan memori, kami menggunakan salah satunya untuk fungsi tertentu, terjadi buffer overflow, dan kami membebaskan memori kedua pointer. <br><br>  Misalkan garis memori p dan q keduanya terletak bersebelahan dalam ruang memori.  Dalam hal ini, hal-hal buruk dapat terjadi, bukan?  Karena fungsi <b>strcpy</b> digunakan untuk menyalin isi <b>str2</b> ke <b>str1</b> .  <b>Str2</b> harus berupa pointer ke string yang diakhiri dengan nol, dan <b>strcpy</b> mengembalikan pointer ke <b>str1</b> .  Jika garis <b>str1</b> dan <b>str2</b> tumpang tindih, maka perilaku fungsi <b>strcpy</b> tidak ditentukan. <br><br>  Oleh karena itu, fungsi <b>strycpy</b> yang memproses memori <b>p</b> dapat secara bersamaan memengaruhi memori yang dialokasikan untuk <b>q</b> .  Dan itu bisa menyebabkan masalah. <br><br>  Ada kemungkinan bahwa Anda melakukan sesuatu seperti itu dalam kode Anda sendiri secara tidak sengaja ketika Anda menggunakan beberapa jenis pointer aneh.  Dan semuanya tampaknya berfungsi, tetapi ketika Anda perlu memanggil fungsi <b>bebas</b> , gangguan seperti itu terjadi.  Dan seorang penyerang dapat memanfaatkannya, saya akan menjelaskan mengapa ini terjadi. <br><br>  Bayangkan di dalam implementasi fungsi <b>bebas</b> dan <b>malloc</b> , blok yang disorot akan terlihat seperti ini. <br><br>  Mari kita asumsikan bahwa di bagian atas blok ada data aplikasi yang terlihat, dan di bawah ini kita memiliki ukuran variabel.  Ukuran ini bukan apa yang dilihat langsung oleh aplikasi, tetapi semacam "penghitungan" yang dilakukan oleh <b>gratis</b> atau <b>malloc</b> , sehingga Anda tahu ukuran buffer memori yang dialokasikan.  Blok gratis terletak di sebelah blok yang disorot.  Misalkan blok bebas memiliki beberapa metadata yang terlihat seperti ini: kita memiliki ukuran blok di atas, ada ruang kosong di bawahnya, penunjuk belakang dan penunjuk maju di bawahnya.  Dan di bagian paling bawah blok, ukuran ditampilkan lagi. <br><br><img src="https://habrastorage.org/webt/vx/q5/-w/vxq5-wfiisbatr5dzny9xaqd7vk.jpeg"><br><br>  Mengapa kita memiliki 2 petunjuk di sini?  Karena sistem alokasi memori dalam kasus ini menggunakan daftar tertaut ganda untuk melacak bagaimana blok bebas saling terkait.  Karena itu, ketika Anda memilih blok gratis, Anda mengecualikannya dari daftar yang ditautkan dua kali lipat ini.  Dan kemudian, ketika Anda membebaskannya, Anda akan melakukan beberapa aritmatika untuk pointer dan mengatur semuanya.  Setelah itu, Anda menambahkannya ke daftar tertaut ini, bukan? <br><br>  Setiap kali Anda mendengar tentang pointer aritmatika, Anda harus berpikir bahwa ini adalah "kenari" Anda.  Karena akan ada banyak masalah.  Biarkan saya mengingatkan Anda bahwa kami memiliki buffer overflow <b>p</b> .  Jika kita berasumsi bahwa <b>p</b> dan <b>q</b> bersebelahan, atau sangat dekat dalam ruang memori, maka pada akhirnya mungkin terjadi bahwa buffer overflow dapat menimpa beberapa data ukuran untuk pointer yang dialokasikan <b>q</b> - ini adalah bagian bawah dari blok yang dialokasikan untuk kita.  Jika Anda terus mengikuti pemikiran saya dari awal, maka imajinasi Anda akan memberi tahu Anda di mana semuanya mulai salah.  Memang, pada dasarnya, apa yang akhirnya terjadi dengan operasi ini adalah <b>q bebas</b> dan <b>bebas p</b> - mereka melihat metadata ini di blok yang dipilih untuk melakukan semua manipulasi yang diperlukan dengan pointer. <br><br><img src="https://habrastorage.org/webt/an/mo/ug/anmouglu2dii_itv9qshxsu4qes.jpeg"><br><br>  Yaitu, pada titik tertentu dalam eksekusi, fungsi bebas akan mendapatkan pointer tertentu berdasarkan nilai ukuran: <b>p = get.free.block (size)</b> , dan ukurannya adalah apa yang <b>diserang</b> oleh penyerang, karena ia melakukan buffer overflow, dengan benar ? <br><br>  Dia melakukan banyak perhitungan aritmatika, melihat fungsi <b>belakang</b> dan pointer dari blok ini dan sekarang akan melakukan sesuatu seperti memperbarui pointer "kembali" dan "maju" - ini adalah dua baris terbawah. <br><br><img src="https://habrastorage.org/webt/bv/dt/x_/bvdtx_om6lkusoykjinpssiqro8.jpeg"><br><br>  Tetapi pada kenyataannya ini seharusnya tidak mengganggu Anda.  Ini hanyalah contoh dari kode yang terjadi dalam kasus ini.  Tetapi faktanya adalah, karena ukuran yang ditulis ulang oleh hacker, ia sekarang mengontrol pointer ini, yang melewati fungsi <b>bebas</b> .  Dan karena ini, dua status di sini di baris paling bawah sebenarnya adalah pembaruan pointer.  Dan karena penyerang mampu mengendalikan <b>p</b> ini, sebenarnya mengontrol dua petunjuk ini.  Di tempat inilah serangan dapat terjadi. <br><br>  Karena itu, ketika berlari <b>bebas</b> dan mencoba melakukan sesuatu seperti menggabungkan dua blok ini, Anda memiliki daftar yang ditautkan dua kali lipat.  Karena jika Anda memiliki dua blok yang saling bertabrakan dan keduanya gratis, Anda ingin menggabungkannya menjadi satu blok besar. <br><br>  Tetapi jika kita mengontrol ukurannya, itu berarti kita mengendalikan keseluruhan proses dari empat baris di atas.  Ini berarti bahwa jika kita memahami cara kerja overflow, maka kita dapat menulis data ke memori dengan cara yang kita pilih.  Seperti yang saya katakan, hal-hal seperti itu sering terjadi dengan kode Anda sendiri, jika Anda tidak pintar dengan pointer.  Ketika Anda membuat beberapa kesalahan bebas ganda seperti <b>q</b> <b>gratis</b> dan <b>p gratis</b> atau sesuatu yang lain, fungsi Anda macet.  Karena Anda mengacaukan metadata yang hidup di setiap blok yang dipilih ini, dan pada titik tertentu perhitungan ini akan menunjukkan beberapa jenis nilai "sampah", setelah itu Anda akan "mati".  Tetapi jika Anda seorang penyerang, Anda dapat memilih nilai ini dan menggunakannya untuk keuntungan Anda. <br><br>  Mari kita beralih ke pendekatan lain untuk mencegah serangan buffer overflow.  Pendekatan ini untuk memeriksa batas.  Tujuan pemeriksaan batas adalah untuk memastikan bahwa ketika Anda menggunakan pointer tertentu, itu hanya akan merujuk pada apa yang merupakan objek memori.  Dan pointer ini berada dalam batas yang diizinkan dari objek memori ini.  Ini adalah ide utama verifikasi.       —   .  ,    C,      . ,      : ,         ,    ? <br><br>   ,        –    .      1024    ,         : <b>char  [1024]</b> , <b>char *y = &amp;  [108].</b> <br><br><img src="https://habrastorage.org/webt/ms/_z/bq/ms_zbqzotz_bt7ya9dpcfsuftxq.jpeg"><br><br>    ?    ?  Sulit dikatakan.       ,  ,     .      ,  ,   -    . <br>       - , ,      ,   .         .  ,    ,      ,   .  ,   ,      .     ,     ,    . <br><br>    ,     ,      <b>struct</b>   <b>union</b> . ,     .     :     <b>integer</b> ,   <b>struct</b> ,      <b>int</b> . <br><br>  ,  <b>union</b>  ,           .        ,    <b>integer</b>  ,   <b>struct</b> ,    . <br><br> ,     ,   -  : <b>int  p: &amp; (u,s,k)</b> ,      :  u,   s,  k. <br><br><img src="https://habrastorage.org/webt/rp/5p/ph/rp5pphcqpcdmmzhfs6tfy6yhtvg.jpeg"><br><br>  ,    ,    ,     ,    .     ,  ,  <b>union</b>   <b>integer</b> ,   <b>struct</b> .  ,       ,    ,           .      . <br><br>      <b>p'</b> ,     <b>p</b> ,   <b>p'</b>      ,    . <br><br><img src="https://habrastorage.org/webt/_j/hb/d1/_jhbd1twr0i0fex98ytm7bdzfu8.jpeg"><br><br> ,     ,       .          , ,   <b>union</b> .   ,   -    -        <b>union</b> , ,  ,      .        ,        ,   X. ,   ,      ,  ,    .   ,    ,   .        . <br><br>         ,        .      ,      <b>p</b>  <b>p'</b> ,     .        . <br><br>     ?        Electric fencing –  .    ,    ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/eg/c5/bp/egc5bpv_lhcf6c6vgy_i5z5_zgo.jpeg"><br><br>       ,    -    ,    .   ,      ,     .    ,   .       ,   ,        ,    . <br><br>   -     C  C++,    ,     ,      .      - ,  ,  -   .      ,    .    ,   «» —  ,          ,   ,     .    ,      ,       . <br><br>       ,         guard page – !  ,   . <br><br> 59:00  <br><br> : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> MIT «  ».  2: «  »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Versi lengkap dari kursus ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416047/">https://habr.com/ru/post/id416047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416029/index.html">Computer Liquid: Capture of Ion dalam Graphene</a></li>
<li><a href="../id416035/index.html">Pemindai 3D gigi Shining 3D Autoscan DS EX (Tanpa Box) oleh 3Dtool</a></li>
<li><a href="../id416037/index.html">Startup of the day (April-Juni 2018)</a></li>
<li><a href="../id416043/index.html">Negara-negara berkembang semakin mengeksplorasi luar angkasa.</a></li>
<li><a href="../id416045/index.html">APC Smart-UPS On-Line UPS SRC1KI: Keandalan Di Atas Semua</a></li>
<li><a href="../id416049/index.html">AV1 Next Generation Codec: CDEF Directional Correction Filter</a></li>
<li><a href="../id416051/index.html">Musim panas mitap Apache Ignite di Moskow</a></li>
<li><a href="../id416053/index.html">Modulasi amplitudo dari sinyal arbitrer</a></li>
<li><a href="../id416055/index.html">Penugasan dan dukungan FQDN server 3QX</a></li>
<li><a href="../id416059/index.html">Mobio Talks dengan Daniil Shuleiko (Yandex.Taxi) tentang merger dengan Uber, pasar taksi, dan persaingan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>