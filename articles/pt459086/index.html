<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïó üßíüèΩ üçá Distribui√ß√£o est√°tica dos objetos FreeRTOS üëÇüèæ üéÆ ‚ôíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por padr√£o, todos os objetos no sistema FreeRTOS s√£o distribu√≠dos dinamicamente - filas, sem√°foros, cron√¥metros, tarefas (threads) e mutexes. O progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Distribui√ß√£o est√°tica dos objetos FreeRTOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459086/">  Por padr√£o, todos os objetos no sistema FreeRTOS s√£o distribu√≠dos dinamicamente - filas, sem√°foros, cron√¥metros, tarefas (threads) e mutexes.  O programador v√™ apenas o "heap" - a √°rea em que a mem√≥ria √© alocada dinamicamente a pedido de um programa ou sistema, e o que est√° acontecendo l√° dentro n√£o √© claro.  Quanto resta?  Desconhecido  Algo leva mais do que voc√™ precisa?  Quem sabe  Pessoalmente, prefiro resolver os problemas de organiza√ß√£o da mem√≥ria, mesmo na fase de escrever o firmware, sem gerar erros de tempo de execu√ß√£o quando a mem√≥ria inesperadamente termina. <br><br>  Este artigo √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">continua√ß√£o</a> l√≥gica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de ontem</a> sobre a distribui√ß√£o est√°tica de objetos na mem√≥ria do microcontrolador, somente agora em rela√ß√£o aos objetos FreeRTOS.  Hoje vamos aprender como colocar objetos FreeRTOS estaticamente, o que nos permitir√° entender mais claramente o que est√° acontecendo na RAM do microcontrolador, como exatamente nossos objetos est√£o localizados e quanto eles ocupam. <br><br>  Mas apenas pegar e come√ßar a colocar objetos do FreeRTOS estaticamente n√£o requer muita intelig√™ncia - a partir da vers√£o 9.0, o FreeRTOS fornece fun√ß√µes para criar objetos colocados estaticamente.  Tais fun√ß√µes t√™m um sufixo est√°tico no nome e essas fun√ß√µes possuem excelente documenta√ß√£o com exemplos.  Escreveremos wrappers C ++ convenientes e bonitos sobre as fun√ß√µes do FreeRTOS que n√£o apenas colocar√£o objetos estaticamente, mas tamb√©m ocultar√£o todos os giblets, al√©m de fornecer uma interface mais conveniente. <br><br>  Este artigo √© destinado a programadores iniciantes, mas que j√° est√£o familiarizados com o b√°sico do FreeRTOS e com as primitivas da sincroniza√ß√£o de programas multithread.  Vamos l√° <br><a name="habracut"></a><br>  O FreeRTOS √© um sistema operacional para microcontroladores.  Bem, ok, n√£o um sistema operacional completo, mas uma biblioteca que permite executar v√°rias tarefas em paralelo.  O FreeRTOS tamb√©m permite que as tarefas troquem mensagens atrav√©s de filas de mensagens, usem cron√¥metros e sincronizem tarefas usando sem√°foros e mutexes. <br><br>  Na minha opini√£o, qualquer firmware em que voc√™ precise executar duas (ou mais) tarefas simultaneamente pode ser resolvido com muito mais facilidade e eleg√¢ncia se voc√™ usar o FreeRTOS.  Por exemplo, leituras de leitura de sensores lentos e, ao mesmo tempo, servem ao display.  Somente para que sem freios, enquanto os sensores s√£o lidos.  Em geral, deve ter!  Eu recomendo fortemente para o estudo. <br><br>  Como disse e escrevi em um artigo anterior, n√£o gosto muito da abordagem de criar objetos dinamicamente, se soubermos seu n√∫mero e tamanho no est√°gio de compila√ß√£o.  Se esses objetos s√£o colocados estaticamente, podemos obter uma imagem mais clara e compreens√≠vel da aloca√ß√£o de mem√≥ria no microcontrolador e, portanto, evitar surpresas quando a mem√≥ria terminar repentinamente. <br><br>  Consideraremos os problemas de organiza√ß√£o de mem√≥ria do FreeRTOS usando a placa BluePill no microcontrolador STM32F103C8T6 como exemplo.  Para n√£o se preocupar com o compilador e o sistema de compila√ß√£o, trabalharemos no ambiente do ArduinoIDE, instalando o suporte para esta placa.  Existem v√°rias implementa√ß√µes do Arduino para STM32 - em princ√≠pio, qualquer uma serve.  Instalei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">stm32duino de</a> acordo com as instru√ß√µes do projeto Readme.md, um gerenciador de inicializa√ß√£o conforme mencionado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> .  O FreeRTOS vers√£o 10.0 √© instalado atrav√©s do gerenciador de bibliotecas do ArduinoIDE.  Compilador - gcc 8.2 <br><br>  Criaremos uma pequena tarefa experimental.  Pode n√£o haver muito sentido pr√°tico nessa tarefa, mas todas as primitivas de sincroniza√ß√£o que est√£o no FreeRTOS ser√£o usadas.  Algo assim: <br><br><ul><li>  2 tarefas (threads) funcionam em paralelo </li><li>  um temporizador tamb√©m funciona, que de tempos em tempos envia uma notifica√ß√£o para a primeira tarefa usando um sem√°foro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no modo de espera de sinal</a> </li><li>  a primeira tarefa, ap√≥s receber a notifica√ß√£o do cron√¥metro, envia uma mensagem (n√∫mero aleat√≥rio) para a segunda tarefa pela fila </li><li>  o segundo, depois de receber a mensagem, imprime-a no console </li><li>  deixe que a primeira tarefa tamb√©m imprima algo no console e, para que eles n√£o lutem, o console ser√° protegido pelo mutex. </li><li>  o tamanho da fila pode ser limitado a um elemento, mas, para torn√°-lo mais interessante, colocamos 1000 </li></ul><br>  A implementa√ß√£o padr√£o (de acordo com a documenta√ß√£o e os tutoriais) pode ser assim. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;STM32FreeRTOS.h&gt; TimerHandle_t xTimer; xSemaphoreHandle xSemaphore; xSemaphoreHandle xMutex; xQueueHandle xQueue; void vTimerCallback(TimerHandle_t pxTimer) { xSemaphoreGive(xSemaphore); } void vTask1(void *) { while(1) { xSemaphoreTake(xSemaphore, portMAX_DELAY); int value = random(1000); xQueueSend(xQueue, &amp;value, portMAX_DELAY); xSemaphoreTake(xMutex, portMAX_DELAY); Serial.println("Test"); xSemaphoreGive(xMutex); } } void vTask2(void *) { while(1) { int value; xQueueReceive(xQueue, &amp;value, portMAX_DELAY); xSemaphoreTake(xMutex, portMAX_DELAY); Serial.println(value); xSemaphoreGive(xMutex); } } void setup() { Serial.begin(9600); vSemaphoreCreateBinary(xSemaphore); xQueue = xQueueCreate(1000, sizeof(int)); xMutex = xSemaphoreCreateMutex(); xTimer = xTimerCreate("Timer", 1000, pdTRUE, NULL, vTimerCallback); xTimerStart(xTimer, 0); xTaskCreate(vTask1, "Task 1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL); xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL); vTaskStartScheduler(); } void loop() {}</span></span></span></span></code> </pre> <br>  Vamos ver o que acontece na mem√≥ria do microcontrolador, se voc√™ compilar esse c√≥digo.  Por padr√£o, todos os objetos do FreeRTOS s√£o colocados na mem√≥ria din√¢mica.  O FreeRTOS fornece at√© cinco implementa√ß√µes de gerenciadores de mem√≥ria, dif√≠ceis de implementar, mas em geral elas t√™m a mesma tarefa - cortar peda√ßos de mem√≥ria para as necessidades do FreeRTOS e do usu√°rio.  As pe√ßas s√£o cortadas da pilha geral do microcontrolador (usando malloc) ou usam sua pr√≥pria pilha separada.  Que tipo de pilha √© usada para n√≥s n√£o √© importante - de qualquer forma, n√£o podemos olhar para dentro da pilha. <br><br>  Por exemplo, para uma pilha do nome FreeRTOS, ela ser√° assim (sa√≠da do utilit√°rio objdump) <br><br><pre> <code class="plaintext hljs">... 200009dc l O .bss 00002000 ucHeap ...</code> </pre><br>  I.e.  vemos um peda√ßo grande, dentro do qual todos os objetos do FreeRTOS s√£o cortados - sem√°foros, mutexes, temporizadores, filas e at√© as pr√≥prias tarefas.  Os √∫ltimos 2 pontos s√£o muito importantes.  Dependendo do n√∫mero de elementos, a fila pode ser bastante grande e √© garantido que as tarefas ocupam muito espa√ßo devido √† pilha, que tamb√©m √© alocada junto com a tarefa. <br><br>  Sim, este √© um n√∫mero m√≠nimo de multitarefa - cada tarefa ter√° sua pr√≥pria pilha.  Al√©m disso, a pilha deve ser grande o suficiente para que n√£o contenha apenas as chamadas e vari√°veis ‚Äã‚Äãlocais da tarefa em si, mas tamb√©m a pilha de interrup√ß√£o, se isso ocorrer.  Bem, como uma interrup√ß√£o pode ocorrer a qualquer momento, todas as tarefas devem ter uma reserva na pilha em caso de interrup√ß√£o.  Al√©m disso, os microcontroladores CortexM podem ter interrup√ß√µes aninhadas, portanto a pilha deve ser grande o suficiente para acomodar todas as interrup√ß√µes, se ocorrerem simultaneamente. <br><br>  O tamanho da pilha de tarefas √© definido quando a tarefa √© criada pelo par√¢metro da fun√ß√£o xTaskCreate.  O tamanho da pilha n√£o pode ser menor que o par√¢metro configMINIMAL_STACK_SIZE (especificado no arquivo de configura√ß√£o FreeRTOSConfig.h) - essa √© a mesma reserva para interrup√ß√µes.  O tamanho da pilha √© definido pelo par√¢metro configTOTAL_HEAP_SIZE e, neste caso, √© 8kb. <br><br><div class="spoiler">  <b class="spoiler_title">Agora tente adivinhar se todos os nossos objetos caber√£o em um monte de 8kb?</b>  <b class="spoiler_title">E alguns objetos?</b>  <b class="spoiler_title">E mais algumas tarefas?</b> <div class="spoiler_text">  Com certas configura√ß√µes do FreeRTOS, todos os objetos n√£o cabiam no heap.  E fica assim: o programa simplesmente n√£o funciona.  I.e.  tudo √© compilado, derramado, mas o microcontrolador trava e √© isso.  E v√° adivinhar que o problema √© exatamente o tamanho da pilha.  Eu tive que aumentar um monte para 12kb. <br></div></div><br>  Pare, quais s√£o as vari√°veis ‚Äã‚ÄãxTimer, xQueue, xSemaphore e xMutex?  Eles n√£o descrevem os objetos que precisamos?  N√£o, s√£o apenas identificadores - ponteiros para uma determinada estrutura (opaca), que descreve os pr√≥prios objetos de sincroniza√ß√£o <br><br><pre> <code class="plaintext hljs">200009cc g O .bss 00000004 xTimer 200009d0 g O .bss 00000004 xSemaphore 200009cc g O .bss 00000004 xQueue 200009d4 g O .bss 00000004 xMutex</code> </pre><br>  Como j√° mencionei, proponho reparar toda essa bagun√ßa da mesma maneira que no artigo anterior - distribuiremos todos os nossos objetos estaticamente no est√°gio de compila√ß√£o.  As fun√ß√µes de distribui√ß√£o est√°tica ficam dispon√≠veis se o par√¢metro configSUPPORT_STATIC_ALLOCATION estiver definido como 1 no arquivo de configura√ß√£o do FreeRTOS. <br><br>  Vamos come√ßar com as linhas.  Aqui est√° como a documenta√ß√£o do FreeRTOS oferece para alocar filas <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMessage</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ucMessageID; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ucData[ <span class="hljs-number"><span class="hljs-number">20</span></span> ]; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUEUE_LENGTH 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ITEM_SIZE sizeof( uint32_t ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// xQueueBuffer will hold the queue structure. StaticQueue_t xQueueBuffer; // ucQueueStorage will hold the items posted to the queue. Must be at least // [(queue length) * ( queue item size)] bytes long. uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) { QueueHandle_t xQueue1; // Create a queue capable of containing 10 uint32_t values. xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold. ITEM_SIZE // The size of each item in the queue &amp;( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue. &amp;xQueueBuffer ); // The buffer that will hold the queue structure. // The queue is guaranteed to be created successfully as no dynamic memory // allocation is used. Therefore xQueue1 is now a handle to a valid queue. // ... Rest of task code. }</span></span></span></span></code> </pre> <br>  Neste exemplo, a fila √© descrita por tr√™s vari√°veis: <br><br><ul><li>  A matriz ucQueueStorage √© onde os elementos da fila ser√£o colocados.  O tamanho da fila √© definido pelo usu√°rio para cada fila individualmente. </li><li>  A estrutura xQueueBuffer - aqui vive a descri√ß√£o e o status da fila, tamanho atual, listas de tarefas pendentes, bem como outros atributos e campos necess√°rios para o FreeRTOS para trabalhar com a fila.  O nome da vari√°vel, na minha opini√£o, n√£o √© totalmente bem-sucedido; no FreeRTOS, isso se chama QueueDefinition (descri√ß√£o da fila). </li><li>  A vari√°vel xQueue1 √© o identificador da fila (identificador).  Todas as fun√ß√µes de gerenciamento de filas, bem como algumas outras (por exemplo, fun√ß√µes internas para trabalhar com cron√¥metros, sem√°foros e mutexes) aceitam esse identificador.  Na verdade, isso √© apenas um ponteiro para QueueDefinition, mas n√£o sabemos disso (por assim dizer) e, portanto, a al√ßa ter√° que ser puxada separadamente. </li></ul><br>  Fazer como no exemplo, √© claro, n√£o ser√° um problema.  Mas, pessoalmente, n√£o gosto de ter at√© tr√™s vari√°veis ‚Äã‚Äãpor entidade.  Uma classe que pode encapsular j√° est√° solicitando.  Apenas um problema - o tamanho de cada fila pode variar.  Em um lugar, voc√™ precisa de uma fila maior; em outro, alguns elementos s√£o suficientes.  Como queremos enfileirar estaticamente, devemos, de alguma forma, especificar esse tamanho no momento da compila√ß√£o.  Voc√™ pode usar o modelo para isso. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> QueueHandle_t xHandle; StaticQueue_t x QueueDefinition; T xStorage[size]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue() { xHandle = xQueueCreateStatic(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(xStorage), &amp;xQueueDefinition); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueReceive(xHandle, val, xTicksToWait); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueSend(xHandle, &amp;val, xTicksToWait); } };</code> </pre> <br>  Ao mesmo tempo, as fun√ß√µes de envio e recebimento de mensagens, que foram imediatamente convenientes para n√≥s, tamb√©m se estabeleceram nesta classe. <br><br>  A fila ser√° declarada como uma vari√°vel global, algo como isto <br><br><pre> <code class="cpp hljs">Queue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>&gt; xQueue;</code> </pre> <br>  Envio de mensagem <br><br><pre> <code class="cpp hljs"> xQueue.send(value);</code> </pre> <br>  Receber mensagem <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; xQueue.receive(&amp;value);</code> </pre><br>  Agora vamos lidar com sem√°foros.  E embora tecnicamente (dentro do FreeRTOS) sem√°foros e mutexes sejam implementados por meio de filas, semanticamente, essas s√£o tr√™s primitivas diferentes.  Portanto, iremos implement√°-los em classes separadas. <br><br>  A implementa√ß√£o da classe sem√°foro ser√° bastante trivial - ela simplesmente armazena v√°rias vari√°veis ‚Äã‚Äãe declara v√°rias fun√ß√µes. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sema</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xSema; StaticSemaphore_t xSemaControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sema() { xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xSema); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xSema, xTicksToWait); } };</code> </pre> <br>  Declara√ß√£o de sem√°foro <br><br><pre> <code class="cpp hljs">Sema xSema;</code> </pre> <br>  Captura de sem√°foro <br><br><pre> <code class="cpp hljs"> xSema.take();</code> </pre> <br>  Libera√ß√£o de sem√°foro <br><br><pre> <code class="cpp hljs"> xSema.give();</code> </pre> <br>  Agora mutex <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xMutex; StaticSemaphore_t xMutexControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() { xMutex = xSemaphoreCreateMutexStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xMutex, xTicksToWait); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xMutex); } };</code> </pre> <br>  Como voc√™ pode ver, a classe mutex √© quase id√™ntica √† classe sem√°foro.  Mas como eu disse semanticamente, essas s√£o entidades diferentes.  Al√©m disso, as interfaces dessas classes n√£o s√£o completas e se expandir√£o em dire√ß√µes completamente diferentes.  Portanto, os m√©todos giveFromISR () e takeFromISR () podem ser adicionados ao sem√°foro para trabalhar com o sem√°foro na interrup√ß√£o, enquanto o mutex apenas possui o m√©todo tryLock () adicionado - n√£o possui outras opera√ß√µes semanticamente. <br><br><div class="spoiler">  <b class="spoiler_title">Espero que voc√™ saiba a diferen√ßa entre um sem√°foro bin√°rio e um mutex.</b> <div class="spoiler_text">  Eu sempre fa√ßo essa pergunta em entrevistas e, infelizmente, 90% dos candidatos n√£o entendem essa diferen√ßa.  De fato, um sem√°foro pode ser capturado e liberado de diferentes threads.  Mencionei acima o modo sem√°foro de espera de sinal quando um thread envia um sinal (as chamadas d√£o ()) e o outro aguarda um sinal (com a fun√ß√£o take ()). <br><br>  O Mutex, pelo contr√°rio, s√≥ pode ser liberado do mesmo fluxo (tarefa) que o capturou.  N√£o tenho certeza de que o FreeRTOS monitore isso, mas alguns sistemas operacionais (por exemplo, Linux) seguem isso estritamente. </div></div><br>  O Mutex pode ser usado no estilo C, ou seja,  chame diretamente bloqueio () / desbloqueio ().  Por√©m, como estamos escrevendo em C ++, podemos tirar proveito dos encantos do RAII e escrever um wrapper mais conveniente que ir√° capturar e liberar o pr√≥prio mutex. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> Mutex &amp; mtx; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(Mutex &amp; mutex) : mtx(mutex) { mtx.lock(); } ~MutexLocker() { mtx.unlock(); } };</code> </pre> <br>  Ao sair do escopo, o mutex ser√° automaticamente liberado. <br><br>  Isso √© especialmente conveniente se houver v√°rias sa√≠das da fun√ß√£o e voc√™ n√£o precisar se lembrar constantemente da necessidade de liberar recursos. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(value); } <span class="hljs-comment"><span class="hljs-comment">// mutex will be unlocked here</span></span></code> </pre> <br>  Agora √© a vez dos temporizadores. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> TimerHandle_t xTimer; StaticTimer_t xTimerControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Timer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcTimerName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TickType_t xTimerPeriodInTicks, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UBaseType_t uxAutoReload, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvTimerID, TimerCallbackFunction_t pxCallbackFunction) { xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ xTimerStart(xTimer, xTicksToWait); } };</code> </pre> <br>  Em geral, tudo aqui √© semelhante √†s aulas anteriores, n√£o vou me deter em detalhes.  Talvez a API deixe muito a desejar, bem, ou pelo menos exija expans√£o.  Mas meu objetivo √© mostrar o princ√≠pio, e n√£o traz√™-lo para um estado pronto para produ√ß√£o. <br><br>  E, finalmente, as tarefas.  Cada tarefa tem uma pilha e deve ser colocada na mem√≥ria com anteced√™ncia.  Usaremos a mesma t√©cnica das filas - escreveremos uma classe de modelo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStackDepth&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: StaticTask_t xTaskControlBlock; StackType_t xStack[ ulStackDepth ]; TaskHandle_t xTask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Task(TaskFunction_t pxTaskCode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvParameters, UBaseType_t uxPriority) { xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock); } };</code> </pre> <br>  Como os objetos de tarefa agora s√£o declarados como vari√°veis ‚Äã‚Äãglobais, eles ser√£o inicializados como vari√°veis ‚Äã‚Äãglobais - antes de chamar main ().  Isso significa que os par√¢metros transferidos para as tarefas tamb√©m devem ser conhecidos neste est√°gio.  Essa nuance deve ser levada em considera√ß√£o se, no seu caso, for aprovado algo que precisa ser calculado antes da cria√ß√£o da tarefa (eu tenho NULL l√°).  Se isso ainda n√£o lhe agradar, considere a op√ß√£o com vari√°veis ‚Äã‚Äãest√°ticas locais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do artigo anterior</a> . <br><br>  Compile e obtenha o erro: <br><br><pre> <code class="plaintext hljs">tasks.c:(.text.vTaskStartScheduler+0x10): undefined reference to `vApplicationGetIdleTaskMemory' timers.c:(.text.xTimerCreateTimerTask+0x1a): undefined reference to `vApplicationGetTimerTaskMemory'</code> </pre> <br>  Aqui est√° a coisa.  Cada sistema operacional possui uma tarefa especial - Idle Task (a tarefa padr√£o, a tarefa de n√£o fazer nada).  O sistema operacional executa esta tarefa se todas as outras tarefas n√£o puderem ser executadas (por exemplo, dormindo ou aguardando algo).  Em geral, esta √© a tarefa mais comum, apenas com a menor prioridade.  Mas aqui est√° sendo criado dentro do kernel do FreeRTOS e n√£o podemos influenciar sua cria√ß√£o.  Mas desde que come√ßamos a colocar as tarefas estaticamente, precisamos dizer de alguma forma ao sistema operacional onde voc√™ deseja colocar a unidade de controle e a pilha dessa tarefa.  √â para isso que serve o FreeRTOS e nos pede para definir uma fun√ß√£o especial vApplicationGetIdleTaskMemory (). <br><br>  Uma situa√ß√£o semelhante √© com a tarefa de temporizadores.  Os cron√¥metros no sistema FreeRTOS n√£o vivem sozinhos - uma tarefa especial est√° girando no sistema operacional, que atende a esses cron√¥metros.  E essa tarefa tamb√©m requer um bloco de controle e uma pilha.  E assim, o sistema operacional nos pede para indicar onde eles est√£o usando a fun√ß√£o vApplicationGetTimerTaskMemory (). <br><br>  As pr√≥prias fun√ß√µes s√£o triviais e simplesmente retornam os ponteiros correspondentes aos objetos alocados estaticamente. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetIdleTaskMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulIdleTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Idle_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Idle_Stack[configMINIMAL_STACK_SIZE]; *ppxIdleTaskTCBBuffer = &amp;Idle_TCB; *ppxIdleTaskStackBuffer = Idle_Stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetTimerTaskMemory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulTimerTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Timer_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Timer_Stack[configTIMER_TASK_STACK_DEPTH]; *ppxTimerTaskTCBBuffer = &amp;Timer_TCB; *ppxTimerTaskStackBuffer = Timer_Stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; }</code> </pre> <br>  Vamos ver o que temos. <br><br><div class="spoiler">  <b class="spoiler_title">Vou esconder o c√≥digo dos ajudantes embaixo do spoiler, voc√™ acabou de ver</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> QueueHandle_t xHandle; StaticQueue_t xQueueDefinition; T xStorage[size]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue() { xHandle = xQueueCreateStatic(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(xStorage), &amp;xQueueDefinition); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueReceive(xHandle, val, xTicksToWait); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueSend(xHandle, &amp;val, xTicksToWait); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sema</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xSema; StaticSemaphore_t xSemaControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sema() { xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xSema); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xSema, xTicksToWait); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xMutex; StaticSemaphore_t xMutexControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() { xMutex = xSemaphoreCreateMutexStatic(&amp;xMutexControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xMutex, xTicksToWait); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xMutex); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> Mutex &amp; mtx; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(Mutex &amp; mutex) : mtx(mutex) { mtx.lock(); } ~MutexLocker() { mtx.unlock(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> TimerHandle_t xTimer; StaticTimer_t xTimerControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Timer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcTimerName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TickType_t xTimerPeriodInTicks, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UBaseType_t uxAutoReload, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvTimerID, TimerCallbackFunction_t pxCallbackFunction) { xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ xTimerStart(xTimer, xTicksToWait); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStackDepth&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: StaticTask_t xTaskControlBlock; StackType_t xStack[ ulStackDepth ]; TaskHandle_t xTask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Task(TaskFunction_t pxTaskCode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvParameters, UBaseType_t uxPriority) { xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock); } }; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetIdleTaskMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulIdleTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Idle_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Idle_Stack[configMINIMAL_STACK_SIZE]; *ppxIdleTaskTCBBuffer = &amp;Idle_TCB; *ppxIdleTaskStackBuffer = Idle_Stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetTimerTaskMemory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulTimerTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Timer_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Timer_Stack[configTIMER_TASK_STACK_DEPTH]; *ppxTimerTaskTCBBuffer = &amp;Timer_TCB; *ppxTimerTaskStackBuffer = Timer_Stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; }</code> </pre> </div></div><br><br>  O c√≥digo para todo o programa. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Timer"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">, pdTRUE, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params">, vTimerCallback)</span></span></span></span>; Sema xSema; Mutex xMutex; Queue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>&gt; xQueue; Task&lt;configMINIMAL_STACK_SIZE&gt; task1(vTask1, <span class="hljs-string"><span class="hljs-string">"Task 1"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY); Task&lt;configMINIMAL_STACK_SIZE&gt; task2(vTask2, <span class="hljs-string"><span class="hljs-string">"Task 2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTimerCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimerHandle_t pxTimer)</span></span></span><span class="hljs-function"> </span></span>{ xSema.give(); <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { xSema.take(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = random(<span class="hljs-number"><span class="hljs-number">1000</span></span>); xQueue.send(value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; xQueue.receive(&amp;value); <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); xTimer.start(); vTaskStartScheduler(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br>  Voc√™ pode desmontar o bin√°rio resultante e ver o que e como ele est√° localizado (a sa√≠da do objdump √© levemente matizada para melhor legibilidade): <br><br><pre> <code class="plaintext hljs">0x200000b0 .bss 512 vApplicationGetIdleTaskMemory::Idle_Stack 0x200002b0 .bss 92 vApplicationGetIdleTaskMemory::Idle_TCB 0x2000030c .bss 1024 vApplicationGetTimerTaskMemory::Timer_Stack 0x2000070c .bss 92 vApplicationGetTimerTaskMemory::Timer_TCB 0x200009c8 .bss 608 task1 0x20000c28 .bss 608 task2 0x20000e88 .bss 84 xMutex 0x20000edc .bss 4084 xQueue 0x20001ed0 .bss 84 xSema 0x20001f24 .bss 48 xTimer</code> </pre> <br>  O objetivo √© alcan√ßado - agora tudo est√° √† vista.  Cada objeto √© vis√≠vel e seu tamanho √© compreens√≠vel (bem, exceto que objetos compostos do tipo Tarefa consideram todas as suas pe√ßas de reposi√ß√£o em uma √∫nica pe√ßa).  As estat√≠sticas do compilador tamb√©m s√£o extremamente precisas e desta vez muito √∫teis. <br><br><pre> <code class="plaintext hljs">Sketch uses 20,800 bytes (15%) of program storage space. Maximum is 131,072 bytes. Global variables use 9,332 bytes (45%) of dynamic memory, leaving 11,148 bytes for local variables. Maximum is 20,480 bytes.</code> </pre> <br><h2>  Conclus√£o </h2><br>  Embora o FreeRTOS permita criar e excluir tarefas, filas, sem√°foros e mutexes em tempo real, em muitos casos isso n√£o √© necess√°rio.  Como regra, √© suficiente criar todos os objetos no in√≠cio uma vez e eles funcionar√£o at√© a pr√≥xima reinicializa√ß√£o.  E esse √© um bom motivo para distribuir esses objetos estaticamente no est√°gio de compila√ß√£o.  Como resultado, obtemos uma compreens√£o clara da mem√≥ria ocupada por nossos objetos, onde est√° o que est√° e quanto resta de mem√≥ria livre. <br><br>  √â √≥bvio que o m√©todo proposto √© adequado apenas para colocar objetos cuja vida √∫til √© compar√°vel √† vida √∫til de todo o aplicativo.  Caso contr√°rio, voc√™ deve usar mem√≥ria din√¢mica. <br><br>  Al√©m do posicionamento est√°tico dos objetos do FreeRTOS, tamb√©m escrevemos wrappers convenientes sobre as primitivas do FreeRTOS, o que nos permitiu simplificar um pouco o c√≥digo do cliente e tamb√©m encapsular <br><br>  A interface pode ser simplificada, se necess√°rio (por exemplo, n√£o verificando o c√≥digo de retorno ou n√£o usando tempos limite).  Tamb√©m √© importante notar que a implementa√ß√£o est√° incompleta - n√£o me preocupei com a implementa√ß√£o de todos os m√©todos poss√≠veis de envio e recebimento de mensagens pela fila (por exemplo, de uma interrup√ß√£o, envio para o in√≠cio ou o final da fila), n√£o trabalhei com primitivas de sincroniza√ß√£o de interrup√ß√µes, contando sem√°foros (n√£o bin√°rios), e muito mais <br><br>  Eu estava com pregui√ßa de trazer esse c√≥digo para o estado "pegar e usar", s√≥ queria mostrar a id√©ia.  Mas quem precisa de uma biblioteca pronta, acabei de me deparar com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca frt</a> .  Tudo nele √© praticamente o mesmo, apenas trazido √† mente.  Bem, a interface √© um pouco diferente. <br><br>  Um exemplo do artigo est√° <a href="">aqui</a> . <br><br>  Obrigado a todos por ler este artigo at√© o fim.  Ficarei feliz em receber cr√≠ticas construtivas.  Tamb√©m ser√° interessante para mim discutir as nuances nos coment√°rios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459086/">https://habr.com/ru/post/pt459086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459074/index.html">Petty little joy # 7: tr√™s pelo pre√ßo de um - anima√ß√£o do console, algoritmos e depura√ß√£o</a></li>
<li><a href="../pt459078/index.html">O CERN muda para o software de c√≥digo aberto - por qu√™?</a></li>
<li><a href="../pt459080/index.html">Recursos HttpUrlConnection de java.net</a></li>
<li><a href="../pt459082/index.html">Quem √© eid√©tica, como funcionam as falsas mem√≥rias e tr√™s mitos populares sobre mem√≥ria</a></li>
<li><a href="../pt459084/index.html">Um pouco sobre o Google Home Hub ou como comprei uma moldura por 130 euros</a></li>
<li><a href="../pt459088/index.html">M√©todos de segmenta√ß√£o de pontos nas nuvens de pontos</a></li>
<li><a href="../pt459090/index.html">Leve sua experi√™ncia de desenvolvimento Linux no Windows para o pr√≥ximo n√≠vel com o WSL e o Visual Studio Code Remote</a></li>
<li><a href="../pt459092/index.html">X.Spectator - monitoramento de estado no .NET</a></li>
<li><a href="../pt459094/index.html">C # ou Java? TypeScript ou JavaScript? Classifica√ß√£o baseada em aprendizado de m√°quina de linguagens de programa√ß√£o</a></li>
<li><a href="../pt459098/index.html">O GitHub Package Registry suportar√° pacotes Swift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>