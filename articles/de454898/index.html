<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÑ üïë ‚òùüèº Programmierung ist mehr als Codierung üë¶üèΩ ü§òüèΩ ü¶ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist ein √úbersetzungsartikel aus dem Stanford-Workshop . Aber vor ihr ist eine kleine Einf√ºhrung. Wie entstehen Zombies? Jeder ist in eine Situati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmierung ist mehr als Codierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/454898/"><p><img src="https://habrastorage.org/webt/ow/dt/zc/owdtzc1fkeq1an3-af8nvvntpvw.jpeg"></p><br><p>  Dies ist ein √úbersetzungsartikel aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stanford-Workshop</a> .  Aber vor ihr ist eine kleine Einf√ºhrung.  Wie entstehen Zombies?  Jeder ist in eine Situation geraten, in der Sie einen Freund oder Kollegen auf Ihr Niveau bringen m√∂chten, aber es funktioniert nicht.  Au√üerdem "klappt es nicht" bei Ihnen weniger als bei ihm: Auf der einen Seite der Waage steht ein normales Gehalt, Aufgaben usw. und auf der anderen Seite das Bed√ºrfnis zu denken.  Denken ist unangenehm und schmerzhaft.  Er gibt schnell auf und schreibt weiterhin Code, ohne das Gehirn einzubeziehen.  Sie stellen sich vor, wie viel Aufwand Sie aufwenden m√ºssen, um die Barriere der erlernten Hilflosigkeit zu √ºberwinden, und Sie tun es einfach nicht.  Auf diese Weise entstehen Zombies, die scheinbar geheilt werden k√∂nnen, aber es scheint, dass niemand dies tun wird. </p><br><p>  Als ich sah, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leslie Lampport</a> (ja, derselbe Freund aus den Lehrb√ºchern) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach Russland kam</a> und keinen Bericht, sondern eine Frage-und-Antwort-Sitzung gab, war ich etwas vorsichtig.  F√ºr alle F√§lle ist Leslie ein weltber√ºhmter Wissenschaftler, der Autor der grundlegenden Arbeiten im Bereich des verteilten Rechnens, und Sie k√∂nnen ihn auch an den Buchstaben La in LaTeX - ‚ÄûLamport TeX‚Äú erkennen.  Der zweite alarmierende Faktor ist seine Forderung: Jeder, der kommt, sollte (v√∂llig kostenlos) im Voraus ein paar seiner Berichte anh√∂ren, mindestens eine Frage zu ihnen stellen und erst dann kommen.  Ich beschloss zu sehen, was Lampport dort sendete - und es war gro√üartig!  Dies ist genau das, eine magische Verbindungspille zur Behandlung eines Zombies.  Ich warne Sie: Aus dem Text kann es insbesondere f√ºr Fans superflexibler Methoden und Nicht-Enthusiasten herausbrennen, zu testen, was geschrieben steht. </p><br><p>  Tats√§chlich beginnt nach Habrokat die √úbersetzung des Seminars.  Viel Spa√ü beim Lesen! <a name="habracut"></a></p><hr><br><p>  Unabh√§ngig davon, welche Aufgabe Sie √ºbernehmen, m√ºssen Sie immer drei Schritte ausf√ºhren: </p><br><ul><li>  Entscheiden Sie, welches Ziel Sie erreichen m√∂chten. </li><li>  Entscheiden Sie, wie Sie Ihr Ziel erreichen. </li><li>  Komm zu deinem Ziel. </li></ul><br><p> Dies gilt auch f√ºr die Programmierung.  Wenn wir den Code schreiben, brauchen wir: </p><br><ul><li>  entscheiden, was das Programm tun soll; </li><li>  genau bestimmen, wie es seine Aufgabe erf√ºllen soll; </li><li>  Schreiben Sie den entsprechenden Code. </li></ul><br><p>  Der letzte Schritt ist nat√ºrlich sehr wichtig, aber ich werde heute nicht dar√ºber sprechen.  Stattdessen diskutieren wir die ersten beiden.  Jeder Programmierer f√ºhrt sie aus, bevor er mit der Arbeit beginnt.  Sie setzen sich nicht zum Schreiben hin, wenn Sie nicht entschieden haben, was Sie schreiben: einen Browser oder eine Datenbank.  Eine genaue Vorstellung vom Ziel muss vorhanden sein.  Und Sie werden sicher dar√ºber nachdenken, was genau das Programm tun wird, und es nicht irgendwie schreiben, in der Hoffnung, dass der Code selbst irgendwie zu einem Browser wird. </p><br><p>  Wie genau findet diese vorl√§ufige √úberlegung des Codes statt?  Wie viel Aufwand sollten wir daf√ºr aufwenden?  Es h√§ngt alles davon ab, wie schwierig das Problem ist, das wir l√∂sen.  Angenommen, wir m√∂chten ein fehlertolerantes verteiltes System schreiben.  In diesem Fall sollten wir alles richtig betrachten, bevor wir uns f√ºr den Code setzen.  Und wenn wir nur die Ganzzahlvariable um 1 erh√∂hen m√ºssen?  Auf den ersten Blick ist hier alles trivial und es sind keine Gedanken erforderlich, aber dann erinnern wir uns, dass ein √úberlauf auftreten kann.  Selbst um zu verstehen, ob ein Problem einfach oder komplex ist, m√ºssen Sie daher zun√§chst √ºberlegen. </p><br><p>  Wenn Sie √ºber m√∂gliche L√∂sungen f√ºr das Problem nachdenken, k√∂nnen Sie Fehler vermeiden.  Dies setzt jedoch voraus, dass Sie klar denken.  Um dies zu erreichen, m√ºssen Sie Ihre Gedanken aufschreiben.  Ich mag Dick Gindons Zitat sehr: "Wenn Sie schreiben, zeigt Ihnen die Natur, wie schlampig Ihr Denken ist."  Wenn Sie nicht schreiben, scheint es Ihnen nur, dass Sie denken.  Und Sie m√ºssen Ihre Gedanken in Form von Spezifikationen aufschreiben. </p><br><p>  Spezifikationen erf√ºllen viele Funktionen, insbesondere bei gro√üen Projekten.  Aber ich werde nur √ºber einen von ihnen sprechen: Sie helfen uns, klar zu denken.  Klar zu denken ist sehr wichtig und ziemlich schwierig, deshalb brauchen wir hier jede Hilfe.  In welcher Sprache sollen wir die Spezifikationen schreiben?  Dies ist immer die erste Frage f√ºr Programmierer: In welcher Sprache werden wir schreiben?  Es gibt keine richtige Antwort darauf: Die Probleme, die wir l√∂sen, sind zu vielf√§ltig.  TLA + ist f√ºr einige n√ºtzlich - dies ist die Spezifikationssprache, die ich entwickelt habe.  F√ºr andere ist es bequemer, Chinesisch zu verwenden.  Es h√§ngt alles von der Situation ab. </p><br><p>  Eine andere Frage ist wichtiger: Wie kann man klarer denken?  Antwort: Wir m√ºssen wie Wissenschaftler denken.  Diese Denkweise hat sich in den letzten 500 Jahren bew√§hrt.  In der Wissenschaft bauen wir mathematische Modelle der Realit√§t.  Die Astronomie war vielleicht die erste Wissenschaft im engeren Sinne des Wortes.  In dem in der Astronomie verwendeten mathematischen Modell erscheinen Himmelsk√∂rper als Punkte mit Masse, Position und Impuls, obwohl sie in Wirklichkeit √§u√üerst komplexe Objekte mit Bergen und Ozeanen und Gezeiten sind.  Dieses Modell wurde wie jedes andere entwickelt, um bestimmte Probleme zu l√∂sen.  Es ist ideal, um festzustellen, wohin das Teleskop gerichtet werden soll, wenn Sie einen Planeten finden m√ºssen.  Wenn Sie jedoch das Wetter auf diesem Planeten vorhersagen m√∂chten, funktioniert dieses Modell nicht. </p><br><p>  Mithilfe der Mathematik k√∂nnen wir die Eigenschaften eines Modells bestimmen.  Und die Wissenschaft zeigt, wie diese Eigenschaften mit der Realit√§t zusammenh√§ngen.  Sprechen wir √ºber unsere Wissenschaft, die Informatik.  Die Realit√§t, mit der wir arbeiten, sind Computersysteme verschiedener Typen: Prozessoren, Spielekonsolen, Computer, Ausf√ºhren von Programmen und so weiter.  Ich werde √ºber das Ausf√ºhren eines Programms auf einem Computer sprechen, aber im Gro√üen und Ganzen gelten all diese Schlussfolgerungen f√ºr jedes Computersystem.  In unserer Wissenschaft verwenden wir viele verschiedene Modelle: eine Turing-Maschine, teilweise geordnete Ereigniss√§tze und viele andere. </p><br><p>  Was ist ein Programm?  Dies ist jeder Code, der unabh√§ngig betrachtet werden kann.  Angenommen, wir m√ºssen einen Browser schreiben.  Wir f√ºhren drei Aufgaben aus: Wir entwerfen die Pr√§sentation des Programms f√ºr den Benutzer, schreiben dann ein allgemeines Schema des Programms und schlie√ülich schreiben wir den Code.  W√§hrend wir den Code schreiben, verstehen wir, dass wir ein Werkzeug zum Formatieren des Textes schreiben m√ºssen.  Hier m√ºssen wir noch einmal drei Probleme l√∂sen: Bestimmen Sie, welchen Text dieses Tool zur√ºckgeben wird;  W√§hlen Sie einen Algorithmus f√ºr die Formatierung.  Code schreiben.  Diese Aufgabe hat eine eigene Unteraufgabe: F√ºgen Sie Bindestriche korrekt in W√∂rter ein.  Wir l√∂sen diese Unteraufgabe auch in drei Schritten - wie wir sehen, werden sie auf vielen Ebenen wiederholt. </p><br><p>  Betrachten wir den ersten Schritt genauer: Welches Problem l√∂st das Programm?  Hier modellieren wir meistens ein Programm als eine Funktion, die eine Eingabe empf√§ngt und eine Ausgabe gibt.  In der Mathematik wird eine Funktion normalerweise als geordnete Menge von Paaren beschrieben.  Beispielsweise wird die Quadrierungsfunktion f√ºr nat√ºrliche Zahlen als die Menge {&lt;0,0&gt;, &lt;1,1&gt;, &lt;2,4&gt;, &lt;3,9&gt;, ...} beschrieben.  Der Umfang einer solchen Funktion ist die Menge der ersten Elemente jedes Paares, dh nat√ºrlicher Zahlen.  Um eine Funktion zu definieren, m√ºssen wir ihren Umfang und ihre Formel angeben. </p><br><p> Funktionen in der Mathematik sind jedoch nicht dasselbe wie Funktionen in Programmiersprachen.  Mathematik ist viel einfacher.  Da ich keine Zeit f√ºr komplexe Beispiele habe, betrachten Sie eine einfache: eine Funktion in C oder eine statische Methode in Java, die den gr√∂√üten gemeinsamen Teiler von zwei Ganzzahlen zur√ºckgibt.  In der Spezifikation dieser Methode schreiben wir: Berechnet <code>GCD(M,N)</code> f√ºr die Argumente <code>M</code> und <code>N</code> , wobei <code>GCD(M,N)</code> eine Funktion ist, deren Dom√§ne die Menge von Ganzzahlpaaren ist und der R√ºckgabewert die gr√∂√üte Ganzzahl ist, die durch teilbar ist <code>M</code> und <code>N</code>  Wie h√§ngt die Realit√§t mit diesem Modell zusammen?  Das Modell arbeitet mit ganzen Zahlen, und in C oder Java haben wir ein 32-Bit- <code>int</code> .  Mit diesem Modell k√∂nnen wir entscheiden, ob der <code>GCD</code> Algorithmus korrekt ist, aber √úberlauffehler werden nicht verhindert.  Dies w√ºrde ein komplexeres Modell erfordern, f√ºr das keine Zeit bleibt. </p><br><p>  Lassen Sie uns √ºber die Einschr√§nkungen der Funktion als Modell sprechen.  Die Arbeit einiger Programme (z. B. Betriebssysteme) besteht nicht darin, einen bestimmten Wert f√ºr bestimmte Argumente zur√ºckzugeben, sondern kann kontinuierlich ausgef√ºhrt werden.  Dar√ºber hinaus ist die Funktion als Modell f√ºr den zweiten Schritt schlecht geeignet: die Planung einer Methode zur L√∂sung des Problems.  Schnelles Sortieren und Blasensortieren berechnen dieselbe Funktion, dies sind jedoch v√∂llig unterschiedliche Algorithmen.  Um zu beschreiben, wie das Ziel des Programms erreicht werden kann, verwende ich ein anderes Modell. Nennen wir es das Standard-Verhaltensmodell.  Das darin enthaltene Programm wird als die Menge aller zul√§ssigen Verhaltensweisen dargestellt, von denen jedes wiederum eine Folge von Zust√§nden ist und ein Zustand eine Zuweisung von Werten zu Variablen ist. </p><br><p>  Mal sehen, wie der zweite Schritt f√ºr den euklidischen Algorithmus aussehen wird.  Wir m√ºssen <code>GCD(M, N)</code> berechnen.  Wir initialisieren <code>M</code> als <code>x</code> und <code>N</code> als <code>y</code> und subtrahieren dann die kleinere dieser Variablen von der gr√∂√üeren, bis sie gleich sind.  Wenn beispielsweise <code>M = 12</code> und <code>N = 18</code> , k√∂nnen wir das folgende Verhalten beschreiben: </p><br><p> <code>[x = 12, y = 18] ‚Üí [x = 12, y = 6] ‚Üí [x = 6, y = 6]</code> </p> <br><p>  Und wenn <code>M = 0</code> und <code>N = 0</code> ?  Null ist durch alle Zahlen teilbar, daher gibt es in diesem Fall keinen gr√∂√üten Teiler.  In dieser Situation m√ºssen wir zum ersten Schritt zur√ºckkehren und fragen: M√ºssen wir die GCD wirklich f√ºr nicht positive Zahlen berechnen?  Wenn dies nicht erforderlich ist, m√ºssen Sie nur die Spezifikation √§ndern. </p><br><p>  Hier sollte ein kleiner Exkurs √ºber die Produktivit√§t gemacht werden.  Sie wird h√§ufig anhand der Anzahl der pro Tag geschriebenen Codezeilen gemessen.  Ihre Arbeit ist jedoch viel n√ºtzlicher, wenn Sie eine bestimmte Anzahl von Zeilen entfernen, da Sie weniger Platz f√ºr Fehler haben.  Der einfachste Weg, den Code loszuwerden, ist der erste Schritt.  Es ist m√∂glich, dass Sie einfach nicht alle Schnickschnack ben√∂tigen, die Sie implementieren m√∂chten.  Der schnellste Weg, ein Programm zu vereinfachen und Zeit zu sparen, besteht darin, keine Dinge zu tun, die es nicht wert sind, getan zu werden.  Der zweite Schritt steht hinsichtlich des Zeitsparpotenzials an zweiter Stelle.  Wenn Sie die Produktivit√§t an der Anzahl der geschriebenen Zeilen messen, werden Sie <em>weniger produktiv</em> , wenn Sie dar√ºber nachdenken, wie die Aufgabe ausgef√ºhrt werden soll, da Sie dasselbe Problem mit weniger Code l√∂sen k√∂nnen.  Ich kann hier keine genauen Statistiken angeben, da ich die Anzahl der Zeilen, die ich nicht geschrieben habe, nicht berechnen kann, weil ich Zeit mit der Spezifikation verbracht habe, dh mit dem ersten und zweiten Schritt.  Und das Experiment kann auch hier nicht platziert werden, da wir im Experiment kein Recht haben, den ersten Schritt abzuschlie√üen, die Aufgabe ist vorbestimmt. </p><br><p>  In informellen Spezifikationen werden viele Schwierigkeiten leicht √ºbersehen.  Es ist nicht kompliziert, strenge Spezifikationen f√ºr Funktionen zu schreiben, ich werde dies nicht diskutieren.  Stattdessen werden wir √ºber das Schreiben strenger Spezifikationen f√ºr Standardverhaltensmodelle sprechen.  Es gibt einen Satz, der besagt, dass jeder Satz von Verhaltensweisen unter Verwendung der <em>Sicherheitseigenschaft</em> und der <em>Lebendigkeitseigenschaft</em> beschrieben werden kann.  Sicherheit bedeutet, dass nichts Schlimmes passiert, das Programm gibt nicht die falsche Antwort.  Vitalit√§t bedeutet, dass fr√ºher oder sp√§ter etwas Gutes passieren wird, dh das Programm wird fr√ºher oder sp√§ter die richtige Antwort geben.  Sicherheit ist in der Regel ein wichtigerer Indikator, hier treten am h√§ufigsten Fehler auf.  Um Zeit zu sparen, werde ich daher nicht √ºber die √úberlebensf√§higkeit sprechen, obwohl dies nat√ºrlich auch wichtig ist. </p><br><p>  Wir erreichen Sicherheit, indem wir zum einen die vielen m√∂glichen Ausgangszust√§nde vorschreiben.  Und zweitens Beziehungen zu allen m√∂glichen n√§chsten Zust√§nden f√ºr jeden Zustand.  Wir werden uns als Wissenschaftler verhalten und die Zust√§nde mathematisch definieren.  Die Menge der Anfangszust√§nde wird beispielsweise im Fall des euklidischen Algorithmus durch die Formel beschrieben: <code>(x = M) ‚àß (y = N)</code> .  F√ºr bestimmte Werte von <code>M</code> und <code>N</code> gibt es nur einen Anfangszustand.  Die Beziehung zum n√§chsten Zustand wird durch eine Formel beschrieben, in der die Variablen des n√§chsten Zustands mit einem Bindestrich und der aktuelle Zustand ohne Bindestrich geschrieben werden.  Im Fall des euklidischen Algorithmus werden wir uns mit der Disjunktion zweier Formeln befassen, von denen eine der gr√∂√üte Wert ist und in der zweiten - <code>y</code> : </p><br><p><img width="400" src="https://habrastorage.org/webt/cy/uf/ny/cyufnyfpfzj-oe6jwdxr7p3jwn4.png"><br></p><br><p>  Im ersten Fall ist der neue Wert von y gleich dem vorherigen Wert von y, und wir erhalten den neuen Wert von x, indem wir den kleineren von der gr√∂√üeren Variablen subtrahieren.  Im zweiten Fall machen wir das Gegenteil. </p><br><p>  Kehren wir zum euklidischen Algorithmus zur√ºck.  Angenommen, <code>M = 12</code> , <code>N = 18</code> .  Dies bestimmt den einzigen Anfangszustand <code>(x = 12) ‚àß (y = 18)</code> .  Dann ersetzen wir diese Werte in der obigen Formel und erhalten: </p><br><p><img width="400" src="https://habrastorage.org/webt/r5/q7/wd/r5q7wdsl5ag5ivq_lj_aggn003i.png"><br></p><br><p>  Hier die einzig m√∂gliche L√∂sung: <code>x' = 18 - 12 ‚àß y' = 12</code> , und wir erhalten das Verhalten: <code>[x = 12, y = 18]</code> .  Auf die gleiche Weise k√∂nnen wir alle Zust√§nde in unserem Verhalten beschreiben: <code>[x = 12, y = 18] ‚Üí [x = 12, y = 6] ‚Üí [x = 6, y = 6]</code> . </p><br><p>  Im letzten Zustand <code>[x = 6, y = 6]</code> beide Teile des Ausdrucks falsch, daher hat er keinen n√§chsten Zustand.  Wir haben also die vollst√§ndige Spezifikation des zweiten Schritts - wie wir sehen, ist dies eine ganz normale Mathematik, wie die von Ingenieuren und Wissenschaftlern, und nicht seltsam, wie in der Informatik. </p><br><p>  Diese beiden Formeln k√∂nnen zu einer zeitlichen Logikformel kombiniert werden.  Sie ist elegant und leicht zu erkl√§ren, aber jetzt hat sie keine Zeit.  Zeitliche Logik, die wir m√∂glicherweise nur f√ºr das Eigentum der Lebendigkeit ben√∂tigen, f√ºr die Sicherheit wird sie nicht ben√∂tigt.  Zeitliche Logik als solche ist nicht angenehm, es ist keine ganz normale Mathematik, aber im Fall von Lebendigkeit ist es ein notwendiges √úbel. </p><br><p>  Im euklidischen Algorithmus gibt es f√ºr jeden Wert von <code>x</code> und <code>y</code> eindeutige Werte von <code>x'</code> und <code>y'</code> , die die Beziehung zum n√§chsten Zustand wahr machen.  Mit anderen Worten ist der euklidische Algorithmus deterministisch.  Um einen nicht deterministischen Algorithmus zu simulieren, ist es notwendig, dass der aktuelle Zustand mehrere m√∂gliche zuk√ºnftige Zust√§nde hat und dass jeder Wert der Variablen ohne Primzahl mehrere Werte der Variablen mit einem Strich hat, bei dem die Beziehung zum n√§chsten Zustand wahr ist.  Dies ist nicht schwer zu tun, aber ich werde jetzt keine Beispiele nennen. </p><br><p>  Um ein funktionierendes Werkzeug zu erstellen, ben√∂tigen Sie formale Mathematik.  Wie macht man die Spezifikation formal?  Dazu ben√∂tigen wir eine formale Sprache, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLA +</a> .  Die Spezifikation des euklidischen Algorithmus in dieser Sprache sieht folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/zo/lj/d_/zoljd_r8zrqhtvbxw2lsrfrowd0.png"></p><br><p>  Das Gleichheitszeichen mit einem Dreieck bedeutet, dass der Wert links vom Zeichen als gleich dem Wert rechts vom Zeichen definiert ist.  Im Wesentlichen ist eine Spezifikation eine Definition, in unserem Fall zwei Definitionen.  Sie m√ºssen der Spezifikation in TLA + Deklarationen und eine Syntax hinzuf√ºgen, wie in der obigen Folie.  In ASCII sieht es folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/mm/nr/oi/mmnroilzmfk9stt9ayv8lkzmo6w.png"></p><br><p>  Wie Sie sehen k√∂nnen, nichts kompliziertes.  Die Spezifikation f√ºr TLA + kann √ºberpr√ºft werden, d. H. Alle m√∂glichen Verhaltensweisen in einem kleinen Modell umgehen.  In unserem Fall ist dieses Modell bestimmte Werte von <code>M</code> und <code>N</code>  Dies ist eine sehr effiziente und einfache √úberpr√ºfungsmethode, die vollst√§ndig automatisch ausgef√ºhrt wird.  Dar√ºber hinaus k√∂nnen Sie formale Beweise f√ºr die Wahrheit schreiben und diese mechanisch √ºberpr√ºfen. Dies nimmt jedoch viel Zeit in Anspruch, sodass fast niemand dies tut. </p><br><p>  Der Hauptnachteil von TLA + ist, dass es sich um Mathematik handelt und Programmierer und Informatiker Angst vor Mathematik haben.  Auf den ersten Blick klingt das wie ein Witz, aber leider sage ich das in aller Ernsthaftigkeit.  Mein Kollege hat mir gerade erz√§hlt, wie er versucht hat, TLA + mehreren Entwicklern zu erkl√§ren.  Sobald die Formeln auf dem Bildschirm erschienen, hatten sie sofort Glasaugen.  Wenn TLA + also unheimlich ist, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PlusCal verwenden</a> , eine Art Programmiersprache f√ºr Spielzeug.  Ein Ausdruck in PlusCal kann ein beliebiger TLA + -Ausdruck sein, dh im Gro√üen und Ganzen ein beliebiger mathematischer Ausdruck.  PlusCal verf√ºgt auch √ºber eine Syntax f√ºr nicht deterministische Algorithmen.  Aufgrund der Tatsache, dass jeder TLA + -Ausdruck in PlusCal geschrieben werden kann, ist er f√ºr jede echte Programmiersprache viel ausdrucksvoller.  PlusCal ist weiter in die einfach zu lesende TLA + -Spezifikation kompiliert.  Dies bedeutet nat√ºrlich nicht, dass die komplexe PlusCal-Spezifikation in TLA + zu einer einfachen wird - nur die Entsprechung zwischen ihnen ist offensichtlich, es wird keine zus√§tzliche Komplexit√§t geben.  Schlie√ülich kann diese Spezifikation mit TLA + -Tools √ºberpr√ºft werden.  Im Allgemeinen kann PlusCal helfen, die Phobie der Mathematik zu √ºberwinden, und es ist selbst f√ºr Programmierer und Informatiker leicht zu verstehen.  In der Vergangenheit habe ich einige Zeit (ungef√§hr 10 Jahre) Algorithmen darauf ver√∂ffentlicht. </p><br><p>  Vielleicht wird jemand Einw√§nde erheben, dass TLA + und PlusCal Mathematik sind und Mathematik nur an erfundenen Beispielen funktioniert.  In der Praxis ben√∂tigen Sie eine echte Sprache mit Typen, Prozeduren, Objekten usw.  Es ist nicht so.  Chris Newcomb, der bei Amazon gearbeitet hat, schreibt: <em>‚ÄûWir haben TLA + in zehn gro√üen Projekten verwendet, und in jedem Fall hat seine Verwendung einen wesentlichen Beitrag zur Entwicklung geleistet, da wir gef√§hrliche Fehler erkennen konnten, bevor wir in Produktion gingen, und weil er uns gegeben hat Verst√§ndnis und Vertrauen, die f√ºr aggressive Leistungsoptimierungen erforderlich sind, die die Wahrheit des Programms nicht beeinflussen</em> . <em>‚Äú</em>  Sie k√∂nnen oft h√∂ren, dass wir bei Verwendung formaler Methoden einen ineffizienten Code erhalten - in der Praxis ist alles genau umgekehrt.  Dar√ºber hinaus wird angenommen, dass Manager nicht von der Notwendigkeit formaler Methoden √ºberzeugt werden k√∂nnen, selbst wenn Programmierer von ihrer N√ºtzlichkeit √ºberzeugt sind.  Und Newcomb schreibt: <em>‚ÄûManager bem√ºhen sich jetzt in jeder Hinsicht, Spezifikationen f√ºr TLA + zu schreiben, und sie widmen sich speziell der Zeit daf√ºr</em> . <em>‚Äú</em>  Wenn Manager sehen, dass TLA + funktioniert, akzeptieren sie dies gerne.  Chris Newcomb hat dies vor ungef√§hr sechs Monaten (im Oktober 2014) geschrieben, aber jetzt, soweit ich wei√ü, wird TLA + in 14 Projekten verwendet, nicht in 10. Ein weiteres Beispiel bezieht sich auf das Design der XBox 360. Ein Praktikant kam zu Charles Thacker und schrieb Spezifikation f√ºr ein Speichersystem.  Dank dieser Spezifikation wurde ein Fehler gefunden, der sonst nicht bemerkt worden w√§re und aufgrund dessen jede XBox 360 nach vier Stunden Betriebszeit fallen w√ºrde.  IBM Ingenieure haben best√§tigt, dass ihre Tests diesen Fehler nicht erkannt h√§tten. </p><br><p>  Sie k√∂nnen mehr √ºber TLA + im Internet lesen und jetzt √ºber informelle Spezifikationen sprechen.  Wir m√ºssen selten Programme schreiben, die den am wenigsten verbreiteten Teiler und dergleichen berechnen.  H√§ufiger schreiben wir Programme wie das h√ºbsche Druckertool, das ich f√ºr TLA + geschrieben habe.  Nach der einfachsten Verarbeitung w√ºrde der TLA + -Code folgenderma√üen aussehen: </p><br><p><img src="https://habrastorage.org/webt/mj/ec/pn/mjecpnkv3gl2fc19kkjx2b9efjc.png"></p><br><p>  Im obigen Beispiel wollte der Benutzer jedoch h√∂chstwahrscheinlich, dass die Konjunktion und die Gleichheitszeichen ausgerichtet werden.  Die richtige Formatierung w√ºrde also eher so aussehen: </p><br><p><img src="https://habrastorage.org/webt/ge/wv/hw/gewvhwsosox33onfpga4lhmygx8.png"></p><br><p>  Betrachten Sie ein anderes Beispiel: </p><br><p><img src="https://habrastorage.org/webt/bo/ld/b1/boldb1vyzar9r21bc4x2mwwhaju.png"></p><br><p>  Im Gegensatz dazu war die Ausrichtung von Gleichheitszeichen, Addition und Multiplikation in der Quelle zuf√§llig, so dass die einfachste Verarbeitung ausreicht.  Im Allgemeinen gibt es keine genaue mathematische Definition der korrekten Formatierung, da "richtig" in diesem Fall "was der Benutzer will" bedeutet und dies nicht mathematisch bestimmt werden kann. </p><br><p>  Es scheint, dass die Spezifikation nutzlos ist, wenn wir keine Definition der Wahrheit haben.  Aber das ist nicht so.  Wenn wir nicht genau wissen, was das Programm tun soll, hei√üt das nicht, dass wir seine Arbeit nicht durchdenken m√ºssen - im Gegenteil, wir sollten uns noch mehr darum bem√ºhen.  Die Spezifikation hier ist besonders wichtig.  Es ist unm√∂glich, das optimale Programm f√ºr die strukturelle Auflistung zu bestimmen, aber dies bedeutet nicht, dass wir es √ºberhaupt nicht durchf√ºhren sollten, und das Schreiben von Code als Bewusstseinsstrom ist keine Sache.  Am Ende habe ich eine Spezifikation von sechs Regeln mit Definitionen <strong>in Form von Kommentaren</strong> in einer Java-Datei geschrieben.  Hier ist ein Beispiel f√ºr eine der Regeln: <code>a left-comment token is LeftComment aligned with its covering token</code> .  Diese Regel ist beispielsweise in mathematischem Englisch geschrieben: <code>LeftComment aligned</code> , <code>left-comment</code> und <code>covering token</code> sind Begriffe mit Definitionen.  So beschreiben Mathematiker Mathematik: Sie schreiben Definitionen von Begriffen und auf deren Grundlage Regeln.  Der Vorteil dieser Spezifikation besteht darin, dass das Verstehen und Debuggen der sechs Regeln viel einfacher ist als 850 Codezeilen.  Ich muss sagen, dass das Schreiben dieser Regeln nicht einfach war, es wurde ziemlich viel Zeit f√ºr das Debuggen aufgewendet.  Speziell f√ºr diesen Zweck habe ich Code geschrieben, der angibt, welche Regel verwendet wurde.  Aufgrund der Tatsache, dass ich diese sechs Regeln anhand einiger Beispiele √ºberpr√ºft habe, musste ich keine 850 Codezeilen debuggen, und die Fehler erwiesen sich als recht leicht zu finden.  Java hat einige gro√üartige Tools daf√ºr.  Wenn ich nur den Code schreiben w√ºrde, w√ºrde es viel l√§nger dauern und die Formatierung w√ºrde sich als schlechter herausstellen. </p><br><p>  Warum war es unm√∂glich, eine formale Spezifikation zu verwenden?  Einerseits ist die korrekte Ausf√ºhrung hier nicht sehr wichtig.  Eine strukturelle Auflistung wird sicher niemandem gefallen, so dass ich nicht in allen ungew√∂hnlichen Situationen die richtige Arbeit finden musste.  Noch wichtiger ist die Tatsache, dass ich keine geeigneten Werkzeuge hatte.  Das Tool zum Testen von TLA + -Modellen ist hier nutzlos, daher m√ºsste ich manuell Beispiele schreiben. </p><br><p>  Die angegebene Spezifikation weist Merkmale auf, die allen Spezifikationen gemeinsam sind.  Es ist von einer h√∂heren Ebene als Code.  Sie k√∂nnen es in jeder Sprache implementieren.  Um es zu schreiben, sind alle Werkzeuge oder Methoden nutzlos.  Kein Programmierkurs hilft Ihnen beim Schreiben dieser Spezifikation.  Und es gibt keine Tools, die diese Spezifikation unn√∂tig machen k√∂nnten, es sei denn, Sie schreiben nat√ºrlich eine Sprache speziell f√ºr das Schreiben von Strukturlistenprogrammen auf TLA +.  Schlie√ülich sagt diese Spezifikation nichts dar√ºber aus, wie wir den Code genau schreiben werden, sondern gibt nur an, was dieser Code tut.  Wir schreiben eine Spezifikation, die uns hilft, das Problem zu durchdenken, bevor wir √ºber Code nachdenken. </p><br><p>  Diese Spezifikation weist jedoch auch Merkmale auf, die sie von anderen Spezifikationen unterscheiden.  95% der anderen Spezifikationen sind viel k√ºrzer und einfacher: </p><br><p><img src="https://habrastorage.org/webt/0e/h0/yc/0eh0yc0ql97fhbwkcc6l5opii8c.png"></p><br><p>  Ferner ist diese Spezifikation ein Satz von Regeln.  Dies ist normalerweise ein Zeichen f√ºr eine schlechte Spezifikation.  Das Verst√§ndnis der Auswirkungen des Regelsatzes ist ziemlich schwierig, weshalb ich viel Zeit damit verbringen musste, sie zu debuggen.  In diesem Fall konnte ich jedoch keinen besseren Weg finden. </p><br><p>  Es lohnt sich, ein paar Worte √ºber Programme zu sagen, die kontinuierlich arbeiten.  In der Regel arbeiten sie parallel, beispielsweise Betriebssysteme oder verteilte Systeme.  Sehr wenige k√∂nnen sie in ihren Gedanken oder auf dem Papier verstehen, und ich bin keiner von ihnen, obwohl ich es mir einmal leisten konnte.  Daher werden Tools ben√∂tigt, die unsere Arbeit testen - zum Beispiel TLA + oder PlusCal. </p><br><p>  Warum mussten Sie eine Spezifikation schreiben, wenn ich bereits wusste, was genau der Code tun sollte?  Tats√§chlich schien es mir nur, dass ich es wusste.  Wenn es eine Spezifikation gibt, muss ein Au√üenstehender nicht mehr in den Code einsteigen, um zu verstehen, was genau er tut.  Ich habe eine Regel: Es sollte keine allgemeinen Regeln geben.  Diese Regel hat nat√ºrlich eine Ausnahme. Dies ist die einzige allgemeine Regel, die ich befolge: Die Spezifikation des Codes besteht darin, den Leuten alles zu sagen, was sie wissen m√ºssen, wenn sie diesen Code verwenden. </p><br><p>  Was genau m√ºssen Programmierer √ºber das Denken wissen?  F√ºr den Anfang wie alle anderen: Wenn Sie nicht schreiben, denken Sie nur, dass Sie denken.  Dar√ºber hinaus m√ºssen Sie vor dem Codieren nachdenken, was bedeutet, dass Sie vor dem Codieren schreiben m√ºssen.  Eine Spezifikation schreiben wir, bevor wir mit dem Codieren beginnen.  Die Spezifikation wird f√ºr jeden Code ben√∂tigt, der von jedem verwendet oder ge√§ndert werden kann.  Und dieser ‚ÄûJemand‚Äú k√∂nnte sich einen Monat nach dem Schreiben als Autor des Codes herausstellen.  Die Spezifikation wird f√ºr gro√üe Programme und Systeme, f√ºr Klassen, f√ºr Methoden und manchmal sogar f√ºr komplexe Abschnitte einer einzelnen Methode ben√∂tigt.  Was genau muss √ºber den Code geschrieben werden?  Es ist notwendig zu beschreiben, was er tut, dh etwas, das f√ºr jede Person, die diesen Code verwendet, n√ºtzlich sein kann.  Manchmal kann es auch erforderlich sein, genau anzugeben, wie der Code sein Ziel erreicht.  Wenn wir diese Methode im Verlauf von Algorithmen bestanden haben, nennen wir sie einen Algorithmus.  Wenn es etwas Besonderes und Neues ist, dann nennen wir es High-Level-Design.  Es gibt keinen formalen Unterschied: Beide sind ein abstraktes Modell des Programms. </p><br><p>  Wie genau sollte eine Codespezifikation geschrieben werden?  Hauptsache: Es sollte eine Ebene h√∂her sein als der Code selbst.  Es sollte Zust√§nde und Verhaltensweisen beschreiben.  Es sollte so streng sein, wie es die Aufgabe erfordert.  Wenn Sie eine Spezifikation zur Implementierung der Aufgabe schreiben, kann diese in Pseudocode oder mit PlusCal geschrieben werden.  Das Lernen, Spezifikationen zu schreiben, ist f√ºr formale Spezifikationen erforderlich.  Dies gibt Ihnen die notwendigen F√§higkeiten, die helfen, auch diejenigen mit informellen.  Und wie lernt man, formale Spezifikationen zu schreiben?  Als wir das Programmieren gelernt haben, haben wir Programme geschrieben und sie dann debuggt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gleiche gilt hier: Sie m√ºssen eine Spezifikation schreiben, sie mit dem Modellpr√ºfwerkzeug √ºberpr√ºfen und Fehler beheben. </font><font style="vertical-align: inherit;">TLA + ist m√∂glicherweise nicht die beste Sprache f√ºr eine formale Spezifikation, und eine andere Sprache ist wahrscheinlich besser f√ºr Ihre spezifischen Anforderungen. </font><font style="vertical-align: inherit;">Der Vorteil von TLA + ist, dass es Ihnen gro√üartiges mathematisches Denken beibringt.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie verkn√ºpfe ich Spezifikation und Code? </font><font style="vertical-align: inherit;">Mit Hilfe von Kommentaren, die mathematische Konzepte und deren Umsetzung verbinden. </font><font style="vertical-align: inherit;">Wenn Sie mit Diagrammen arbeiten, haben Sie auf Programmebene Arrays von Knoten und Arrays von Links. </font><font style="vertical-align: inherit;">Daher m√ºssen Sie genau schreiben, wie der Graph von diesen Programmierstrukturen implementiert wird.</font></font></p><br><p>  ,           .    ,     ,       .      ,     .        .      ,  ,    .  ,           .      ,      . </p><br><p>   ‚Äî      .         ‚Äî        Amazon.      .          ?    .   ,      ,    .    ,  .       ‚Äî    ,    .        .  . </p><br><p>    .   -  ,    ,     .  ,  - ,  ,        .             .   ,     .      , ,  .       ,     ? -,  ,     ,         ,        .       ,    .     ,  . ,    ,    . -,      ,       .   .       ,      ,         . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> , <em>       ,         </em> .    -  .  ,    ‚Äî   .    ,    ,    .    , ,      ,  ,     .       .    ,     .   ,     ,   ‚Äî  .      ,    . </p><br><p>   TLA+  PlusCal     ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .     ,   . </p><br><blockquote> ,   .      ‚Äî ,     .       ,      Hydra 2019,   11-12  2019   -.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454898/">https://habr.com/ru/post/de454898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454884/index.html">Lesbare Testnamen in JS und im Verhaltensmuster</a></li>
<li><a href="../de454886/index.html">In der Leber sitzen. Warum die Entfernung von Lebertumoren ein Indikator f√ºr die √ºberlegenen F√§higkeiten des Chirurgen ist</a></li>
<li><a href="../de454892/index.html">Moto. Mock aws</a></li>
<li><a href="../de454894/index.html">WWDC 2019 :: was zu sehen</a></li>
<li><a href="../de454896/index.html">Warum ich freiberuflich zu einem Remote-Team gewechselt bin</a></li>
<li><a href="../de454900/index.html">So machen Sie Webformulare auf der Website bequem und sicher: Entwicklungstools und Konstruktoren</a></li>
<li><a href="../de454904/index.html">Samsung startet kostenlosen Online-Kurs f√ºr Computer Vision Neural Network</a></li>
<li><a href="../de454912/index.html">Die Zwergenfestung Tarn Adams spricht √ºber die Spieleentwicklung</a></li>
<li><a href="../de454916/index.html">Neuronale Netzwerkarchitektur zur Implementierung des RL-Algorithmus mit der F√§higkeit, gleichzeitig laufende Aktionen festzulegen</a></li>
<li><a href="../de454918/index.html">So kombinieren Sie den R√ºcken zweier Einzelh√§ndler in SAP in 12 Stunden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>