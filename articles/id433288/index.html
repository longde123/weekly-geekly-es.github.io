<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•´ğŸ¼ ğŸ“³ ğŸ’ªğŸ¿ Keamanan Web: Pengantar HTTP ğŸ« ğŸ‘§ ğŸ’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HTTP adalah hal yang indah: protokol yang telah ada selama lebih dari 20 tahun tanpa banyak perubahan. 



 Ini adalah bagian kedua dari seri keamanan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keamanan Web: Pengantar HTTP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/433288/">  HTTP adalah hal yang indah: protokol yang telah ada selama lebih dari 20 tahun tanpa banyak perubahan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e2/2aa/f27/7e22aaf27d44b0c3188c7918588b0a20.jpg" alt="gambar"><br><br>  <i>Ini adalah bagian kedua dari seri keamanan web: bagian satu adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana browser bekerja</a> .</i> <br><br>  Seperti yang kita lihat di artikel sebelumnya, browser berinteraksi dengan aplikasi web menggunakan protokol HTTP, dan ini adalah alasan utama kami mempelajari topik ini.  Jika pengguna memasukkan informasi kartu kredit mereka di situs web, dan penyerang dapat mencegat data sebelum mereka mencapai server, kami mungkin akan mengalami masalah. <br><br>  Memahami cara kerja HTTP, bagaimana kami dapat mengamankan komunikasi antara klien dan server, dan fitur-fitur terkait keamanan apa yang ditawarkan protokol adalah langkah pertama menuju peningkatan keamanan kami. <br><br>  Namun, ketika membahas HTTP, kita harus selalu membedakan antara semantik dan implementasi teknis, karena ini adalah dua aspek HTTP yang sama sekali berbeda. <br><a name="habracut"></a><br>  Perbedaan utama di antara mereka dapat dijelaskan dengan analogi yang sangat sederhana: 20 tahun yang lalu, orang-orang menjaga kerabat mereka dengan cara yang sama seperti yang mereka lakukan sekarang, meskipun cara mereka berinteraksi telah berubah secara signifikan.  Orang tua kita cenderung membawa mobil mereka dan pergi ke saudara perempuan mereka untuk mengejar ketinggalan dan menghabiskan waktu bersama keluarga mereka. <br><br>  Sebaliknya, akhir-akhir ini, mereka paling sering mengirim pesan ke WhatsApp, melakukan panggilan telepon atau menggunakan grup di Facebook, yang sebelumnya tidak mungkin dilakukan.  Ini tidak berarti bahwa orang berkomunikasi atau peduli kurang lebih, tetapi hanya karena interaksi mereka telah berubah. <br><br>  HTTP tidak berbeda: semantik protokol tidak banyak berubah, sementara implementasi teknis dari interaksi klien dan server telah dioptimalkan selama bertahun-tahun.  Jika Anda melihat permintaan HTTP 1996, itu akan sangat mirip dengan yang kita lihat di artikel sebelumnya, meskipun cara paket-paket ini melewati jaringan sangat berbeda. <br><br><h3>  Ulasan </h3><br>  Seperti yang telah kita lihat, HTTP mengikuti model permintaan / respons ketika klien yang terhubung ke server mengirim permintaan dan server meresponsnya. <br><br>  Pesan HTTP (permintaan atau respons) terdiri dari beberapa bagian: <br><br><ul><li>  "Baris pertama" (baris pertama) </li><li>  tajuk (tajuk permintaan) </li><li>  tubuh (tubuh permintaan) </li></ul><br>  Dalam permintaan, baris pertama menunjukkan metode yang digunakan oleh klien, jalur ke sumber daya yang ia inginkan, serta versi protokol yang akan ia gunakan: <br><br> <code>GET /players/lebron-james HTTP/1.1</code> <br> <br>  Dalam hal ini, klien mencoba untuk mendapatkan sumber daya ( <code>GET</code> ) di <code>/Players/Lebron-James</code> melalui protokol versi <code>1.1</code> - tidak ada yang rumit untuk dipahami. <br><br>  Setelah baris pertama, HTTP memungkinkan kita untuk menambahkan metadata ke pesan melalui header yang mengambil bentuk nilai kunci, dipisahkan oleh tanda titik dua: <br><br> <code>GET /players/lebron-james HTTP/1.1 <br> Host: nba.com <br> Accept: */* <br> Coolness: 9000</code> <br> <br>  Misalnya, dalam permintaan ini, klien menambahkan 3 header tambahan ke permintaan: <code>Host</code> , <code>Accept</code> , dan <code>Coolness</code> . <br><br>  Tunggu, <code>Coolness</code> ?!?! <br><br>  Header tidak boleh menggunakan nama khusus yang dicadangkan, tetapi biasanya disarankan untuk mengandalkan yang standar dalam spesifikasi HTTP: semakin Anda menyimpang dari standar, semakin sedikit Anda akan dipahami oleh peserta pertukaran lainnya. <br><br>  <code>Cache-Control</code> , misalnya, adalah tajuk yang digunakan untuk menentukan apakah (dan bagaimana) suatu respons dapat disimpan dalam cache: sebagian besar proksi dan proksi balik memahaminya dengan mengikuti spesifikasi HTTP pada surat itu.  Jika Anda harus mengganti nama header <code>Cache-Control</code> menjadi <code>Awesome-Cache-Control</code> , proksi tidak akan tahu bagaimana cara men-cache respons, karena mereka tidak dirancang untuk memenuhi spesifikasi yang baru saja Anda temukan. <br><br>  Namun, terkadang masuk akal untuk menyertakan tajuk "khusus" dalam pesan, karena Anda dapat menambahkan metadata yang sebenarnya bukan bagian dari spesifikasi HTTP: server dapat memutuskan untuk memasukkan informasi teknis dalam responsnya sehingga klien dapat secara bersamaan menjalankan permintaan dan menerima informasi penting tentang status server yang mengembalikan respons: <br><br> <code>... <br> X-Cpu-Usage: 40% <br> X-Memory-Available: 1% <br> ...</code> <br> <br>  Saat menggunakan tajuk khusus, selalu lebih baik untuk menempatkan awalan dengan kunci di depannya sehingga tidak bertentangan dengan tajuk lain yang mungkin menjadi standar di masa depan: secara historis ini berfungsi dengan baik hingga semua orang mulai menggunakan awalan <code>X</code> "non-standar", yang pada gilirannya menjadi norma.  Header <code>X-Forwarded-For</code> dan <code>X-Forwarded-Proto</code> adalah contoh header kustom yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak digunakan dan dipahami oleh load balancers dan proxy</a> , bahkan jika mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukan bagian dari standar HTTP</a> . <br><br>  Jika Anda perlu menambahkan tajuk khusus Anda sendiri, sekarang biasanya yang terbaik adalah menggunakan awalan berpemilik seperti <code>Acme-Custom-Header</code> atau <code>A-Custom-Header</code> . <br><br>  Setelah tajuk, permintaan dapat berisi badan yang dipisahkan dari tajuk oleh baris kosong: <br><br> <code>POST /players/lebron-james/comments HTTP/1.1 <br> Host: nba.com <br> Accept: */* <br> Coolness: 9000 <br> <br> Best Player Ever <br></code> <br><br>  Permintaan kami selesai: baris pertama (informasi lokasi dan protokol), tajuk dan badan.  Harap dicatat bahwa body sepenuhnya opsional dan, dalam banyak kasus, hanya digunakan ketika kami ingin mengirim data ke server, sehingga metode <code>POST</code> digunakan dalam contoh di atas. <br><br>  Jawabannya sangat tidak berbeda: <br><br> <code>HTTP/1.1 200 OK <br> Content-Type: application/json <br> Cache-Control: private, max-age=3600 <br> <br> {"name": "Lebron James", "birthplace": "Akron, Ohio", ...}</code> <br> <br>  Informasi pertama yang dikirim dalam respons adalah versi protokol yang digunakannya, bersama dengan status respons ini.  Berikut ini adalah tajuk dan, jika diperlukan, jeda baris diikuti oleh tubuh. <br><br>  Seperti yang telah disebutkan, protokol telah mengalami banyak revisi dan seiring waktu ditambahkan fungsi baru (header baru, kode status, dll.), Tetapi struktur utama tidak banyak berubah (baris pertama, header dan badan).  Apa yang benar-benar berubah adalah bagaimana klien dan server bertukar pesan ini - mari kita lihat lebih dekat. <br><br><h3>  HTTP vs HTTPS vs H2 </h3><br>  Ada 2 perubahan semantik yang signifikan dalam <code>HTTP / 1.0</code> : <code>HTTP / 1.0</code> dan <code>HTTP / 1.1.</code> <br><br>  "Di mana HTTPS dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://">HTTP2</a> ?", Anda bertanya. <br><br>  HTTPS dan HTTP2 (disingkat H2) adalah perubahan yang lebih teknis karena mereka memperkenalkan cara-cara baru untuk mengirimkan pesan melalui Internet, tanpa secara signifikan mempengaruhi semantik protokol. <br><br>  HTTPS adalah ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTTP</a> "aman" dan mencakup pembuatan kunci rahasia bersama antara klien dan server, memastikan bahwa kami berkomunikasi dengan pihak yang tepat dan mengenkripsi pesan yang bertukar kunci rahasia bersama (lebih lanjut tentang ini nanti).  Sementara HTTPS ditujukan untuk meningkatkan keamanan protokol HTTP, H2 ditujukan untuk memberikan kecepatan tinggi. <br><br>  H2 menggunakan biner daripada pesan teks, mendukung multiplexing, menggunakan algoritma HPACK untuk mengompres header ... ... Singkatnya, H2 meningkatkan kinerja melalui HTTP / 1.1. <br><br>  Pemilik situs web enggan untuk beralih ke HTTPS, karena ini termasuk jalan memutar tambahan antara klien dan server (seperti yang telah disebutkan, perlu untuk membuat kunci rahasia bersama antara kedua pihak), sehingga memperlambat pengguna: dengan H2, yang secara default dienkripsi, tidak ada alasan lagi karena fitur seperti multiplexing dan server push <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.troyhunt.com/i-wanna-go-fast-">membuatnya lebih baik daripada HTTP / 1.1 biasa</a> . <br><br><h3>  Https </h3><br>  HTTPS (HTTP Secure) memungkinkan klien dan server untuk berkomunikasi dengan aman melalui TLS (Transport Layer Security), penerus SSL (Secure Socket Layer). <br><br>  Masalah yang menjadi fokus TLS cukup sederhana dan dapat diilustrasikan dengan satu metafora sederhana: belahan jiwa Anda memanggil Anda di tengah hari ketika Anda sedang rapat dan meminta Anda untuk memberi tahu mereka kata sandi akun perbankan online Anda, karena harus menyelesaikan perbankan transfer untuk memastikan pembayaran tepat waktu untuk pendidikan putra Anda.  Sangat penting bagi Anda untuk melaporkannya sekarang, jika tidak, Anda akan menghadapi risiko anak Anda dikeluarkan dari sekolah keesokan paginya. <br><br>  Sekarang Anda dihadapkan pada dua masalah: <br><br><ul><li>  <b>membuktikan</b> bahwa Anda benar-benar berbicara dengan belahan jiwa Anda, karena mungkin seseorang berpura-pura menjadi dirinya </li><li>  <b>enkripsi</b> : mengirimkan kata sandi Anda sehingga kolega Anda tidak dapat memahami dan menuliskannya </li></ul><br>  Apa yang akan kamu lakukan  Inilah masalah yang coba dipecahkan oleh HTTPS. <br><br>  Untuk memverifikasi dengan siapa Anda berbicara, HTTPS menggunakan Sertifikat Kunci Publik (sertifikat kunci publik), yang tidak lebih dari sertifikat yang menunjukkan identitas server tertentu: ketika Anda terhubung melalui HTTPS ke alamat IP, server di belakang alamat itu menyajikan kepada Anda Sertifikatnya untuk membuktikan identitas Anda.  Kembali ke analogi kami, Anda bisa meminta belahan jiwa Anda untuk menyebutkan nomor jaminan sosial Anda.  Segera setelah Anda memverifikasi bahwa nomor itu benar, Anda mendapatkan tingkat kepercayaan tambahan. <br><br>  Namun, ini tidak mencegah "penyerang" menemukan nomor jaminan sosial korban, mencuri ponsel pintar belahan jiwa Anda dan memanggil Anda.  Bagaimana kami memverifikasi identitas penelepon? <br><br>  Alih-alih secara langsung meminta belahan jiwa Anda untuk menulis nomor jaminan sosial Anda, alih-alih Anda memanggil ibu Anda (yang tinggal di sebelah) dan memintanya untuk pergi ke apartemen Anda dan memastikan bahwa separuh lainnya mengatakan nomor jaminan sosial.  Ini menambah tingkat kepercayaan tambahan, karena Anda tidak menganggap ibu Anda ancaman dan bergantung padanya untuk memverifikasi identitas penelepon. <br><br>  Dalam hal HTTPS, ibumu disebut CA, kependekan dari Certificate Authority: pekerjaan CA adalah untuk memverifikasi identitas server tertentu dan mengeluarkan sertifikat dengan tanda tangan digital sendiri: ini berarti bahwa ketika saya terhubung ke domain tertentu saya tidak akan menerima sertifikat yang dihasilkan oleh pemilik domain (yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sendiri ditandatangani) sertifikat</a> ), dan CA. <br><br>  Tugas CA adalah untuk memverifikasi keaslian domain dan mengeluarkan sertifikat sesuai: ketika Anda "memesan" sertifikat (biasanya disebut sertifikat SSL, meskipun TLS saat ini digunakan sebagai gantinya - nama-nama itu benar-benar melekat!), CA dapat menghubungi Anda atau Minta untuk mengubah pengaturan DNS untuk memastikan bahwa Anda mengontrol domain ini.  Setelah proses verifikasi selesai, itu akan mengeluarkan sertifikat, yang kemudian dapat diinstal pada server web. <br><br>  Kemudian, klien, seperti browser, akan terhubung ke server Anda dan menerima sertifikat ini sehingga mereka dapat memverifikasi keasliannya: browser memiliki semacam "hubungan" dengan CA, dalam arti mereka melacak daftar domain tepercaya di CA untuk memastikan Sertifikat itu benar-benar dapat dipercaya.  Jika sertifikat tidak ditandatangani oleh otoritas tepercaya, browser akan menampilkan peringatan informasi besar untuk pengguna: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54a/8e8/5d9/54a8e85d9b26fd801a3eb8242f89d0da.png" alt="gambar"><br><br>  Kami setengah memastikan komunikasi antara Anda dan separuh lainnya: sekarang setelah kami melewati otentikasi (verifikasi identitas penelepon), kami perlu memastikan bahwa kami dapat berkomunikasi dengan aman tanpa campur tangan orang lain dalam proses.  Seperti yang saya sebutkan, Anda tepat di tengah-tengah pertemuan dan Anda perlu menuliskan kata sandi Anda untuk perbankan online.  Anda perlu menemukan cara untuk mengenkripsi komunikasi Anda sehingga hanya Anda dan jodoh Anda yang dapat memahami percakapan Anda. <br><br>  Anda dapat melakukan ini dengan menetapkan kunci rahasia umum antara Anda berdua dan mengenkripsi pesan dengan kunci ini: misalnya, Anda dapat menggunakan opsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cipher Caesar</a> berdasarkan tanggal pernikahan Anda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/386/647/99b/38664799bec1674e9204cd4b98afc8d6.png" alt="gambar"><br><br>  Ini akan bekerja dengan baik jika kedua belah pihak telah membangun hubungan, seperti Anda dan belahan jiwa Anda, karena mereka dapat membuat kunci berdasarkan memori bersama yang tidak ada yang tahu.  Browser dan server, bagaimanapun, tidak dapat menggunakan mekanisme yang sama, karena mereka tidak mengenal satu sama lain sebelumnya. <br><br>  Sebagai gantinya, variasi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol pertukaran kunci Diffie-Hellman</a> digunakan, yang memastikan bahwa pihak-pihak tanpa pengetahuan sebelumnya membuat kunci rahasia bersama dan tidak ada orang lain yang dapat "mencuri" itu.  Ini termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan matematika</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa3/67c/072/aa367c072a90788c9d3049e479c16b22.png" alt="gambar"><br><br>  Setelah kunci rahasia dipasang, klien dan server dapat berkomunikasi tanpa takut bahwa seseorang mungkin akan mencegat pesan mereka.  Bahkan jika penyerang melakukan ini, mereka tidak akan memiliki kunci rahasia bersama yang diperlukan untuk mendekripsi pesan. <br><br>  Untuk informasi lebih lanjut tentang HTTPS dan Diffie-Hellman, saya akan merekomendasikan membaca " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://blog.hartleybrody.com/">Bagaimana HTTPS Melindungi Koneksi</a> " oleh Hartley Brody dan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://robertheaton.com/2014/03/27/how-does-">Bagaimana HTTPS Benar-Benar Bekerja?"</a>  Â»Robert Heaton.  Selain itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sembilan Algoritma yang Mengubah Masa Depan</a> memiliki bab yang luar biasa menjelaskan enkripsi kunci publik, dan saya dengan hangat merekomendasikannya kepada para penggemar ilmu komputer yang tertarik pada algoritma asli. <br><br><h3>  Https di mana-mana </h3><br>  Masih memutuskan apakah Anda harus mendukung HTTPS di situs Anda?  Saya punya berita buruk untuk Anda: browser telah mulai melindungi pengguna dari situs web yang tidak mendukung HTTPS untuk â€œmemaksaâ€ pengembang web untuk menyediakan kemampuan penelusuran yang sepenuhnya dienkripsi. <br><br>  Mengikuti moto " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.eff.org/">HTTPS di mana-mana,</a> " browser mulai menentang koneksi yang tidak terenkripsi - Google adalah penyedia browser pertama yang memberikan batas waktu kepada pengembang web dengan mengumumkan bahwa mulai dengan Chrome 68 (Juli 2018), itu akan menandai situs web HTTP sebagai "tidak aman" : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/046/0c7/888/0460c78882293ad0cec11484f5130dda.png" alt="gambar"></div><br><br>  Yang lebih meresahkan bagi situs web yang tidak memanfaatkan HTTPS adalah kenyataan bahwa begitu pengguna mengetik sesuatu di halaman web, label "Tidak Aman" berubah merah - langkah ini harus mendorong pengguna untuk berpikir dua kali sebelum bertukar data. dengan situs web yang tidak mendukung HTTPS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/5ec/e7a/a7a5ece7ad2e8bf76f465bfda3d18414.png" alt="gambar"></div><br><br>  Bandingkan ini dengan seperti apa situs HTTPS dengan sertifikat yang valid: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d2/cf9/1dc/0d2cf91dc86c81e8c1562e86689a4db4.png" alt="gambar"></div><br><br>  Secara teoritis, sebuah situs web seharusnya tidak aman, tetapi dalam praktiknya itu membuat pengguna takut - dan memang demikian.  Pada hari-hari ketika H2 bukan kenyataan, masuk akal untuk tetap dengan lalu lintas HTTP sederhana yang tidak terenkripsi.  Sebenarnya tidak ada alasan untuk ini saat ini.  Bergabunglah dengan HTTPS Everywhere movement dan bantu jadikan Internet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.troyhunt.com/heres-why-your-static-website-needs-">tempat yang lebih aman untuk berselancar</a> . <br><br><h3>  DAPATKAN vs POST </h3><br>  Seperti yang kita lihat sebelumnya, permintaan HTTP dimulai dengan semacam "baris pertama": <br><br>  Pertama-tama, klien memberi tahu server metode mana yang digunakan untuk mengeksekusi permintaan: metode HTTP dasar termasuk <code>GET, POST, PUT  DELETE,</code> tetapi daftar dapat dilanjutkan dengan metode yang kurang umum (tapi masih standar) seperti <code>TRACE, OPTIONS</code> , atau <code>HEAD</code> <br><br>  Secara teoritis, tidak ada metode yang lebih aman daripada yang lain;  dalam praktiknya, semuanya tidak begitu sederhana. <br><br>  Permintaan GET biasanya tidak mengandung badan, sehingga parameter dimasukkan dalam URL (misalnya, <code>www.example.com/articles?article_id=1</code> ), sedangkan permintaan POST biasanya digunakan untuk mengirim ("menerbitkan") data yang disertakan dalam badan.  Perbedaan lainnya adalah efek samping yang dimiliki metode ini: <code>GET</code> adalah metode idempoten, artinya berapa pun banyaknya permintaan yang Anda kirim, Anda tidak akan mengubah status server web.  Sebaliknya, <code>POST</code> bukan idempoten: untuk setiap permintaan yang Anda kirim, Anda dapat mengubah status server (pikirkan, misalnya, tentang menempatkan pembayaran baru - sekarang Anda mungkin mengerti mengapa situs meminta Anda untuk tidak me-refresh halaman saat menyelesaikan transaksi). <br><br>  Untuk menggambarkan perbedaan penting antara metode-metode ini, kita perlu melihat log server web yang mungkin sudah Anda kenal: <br><br> <code>192.168.99.1 - [192.168.99.1] - - [29/Jul/2018:00:39:47 +0000] "GET /?token=1234 HTTP/1.1" 200 525 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36" 404 0.002 [example-local] 172.17.0.8:9090 525 0.002 200 <br> 192.168.99.1 - [192.168.99.1] - - [29/Jul/2018:00:40:47 +0000] "GET / HTTP/1.1" 200 525 "-" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36" 393 0.004 [example-local] 172.17.0.8:9090 525 0.004 200 <br> 192.168.99.1 - [192.168.99.1] - - [29/Jul/2018:00:41:34 +0000] "PUT /users HTTP/1.1" 201 23 "http://example.local/" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36" 4878 0.016 [example-local] 172.17.0.8:9090 23 0.016 201</code> <br> <br>  Seperti yang Anda lihat, server web mencatat jalur permintaan: ini berarti bahwa jika Anda memasukkan data sensitif dalam URL Anda, mereka akan dilewati oleh server web dan disimpan di suatu tempat di log Anda - data sensitif Anda akan berada di suatu tempat di teks biasa, yang harus kita hindari sepenuhnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bayangkan bahwa seorang penyerang bisa mendapatkan akses ke salah satu file log lama Anda</a> , yang mungkin berisi informasi kartu kredit, token akses untuk layanan pribadi Anda, dll., Ini akan menjadi bencana total. <br><br>  Server web tidak mencatat tajuk dan badan HTTP, karena data yang disimpan akan terlalu banyak - itulah sebabnya mengirim informasi melalui badan permintaan daripada URL umumnya lebih aman.  Dari sini kita dapat menyimpulkan bahwa <code>POST</code> (dan metode non-idempoten serupa) lebih aman daripada <code>GET</code> , bahkan jika itu lebih tergantung pada bagaimana data dikirim ketika menggunakan metode tertentu, dan bukan pada kenyataan bahwa metode tertentu pada dasarnya lebih aman daripada yang lain: jika Anda memasukkan informasi rahasia dalam badan permintaan <code>GET</code> , maka Anda tidak akan memiliki lebih banyak masalah daripada menggunakan <code>POST</code> , bahkan jika pendekatan seperti itu akan dianggap tidak biasa. <br><br><h3>  Kami percaya pada tajuk HTTP </h3><br>  Pada artikel ini, kami melihat HTTP, evolusinya, dan bagaimana ekstensi amannya menggabungkan otentikasi dan enkripsi untuk memungkinkan klien dan server berkomunikasi melalui saluran aman: ini tidak semua yang ditawarkan HTTP dalam hal keamanan. <br><br><hr><br>  <em><font color="#999999">Terjemahan didukung oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EDISON Software</a> , sebuah perusahaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan</a> profesional, dan juga mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem verifikasi medis elektronik</a> .</font></em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433288/">https://habr.com/ru/post/id433288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433276/index.html">Tentang manfaat menanamkan CSS di JS</a></li>
<li><a href="../id433278/index.html">WebGL-wind dan pemrograman GPU. Kuliah di FrontTalks 2018</a></li>
<li><a href="../id433280/index.html">Konferensi DEFCON 18. Teknik Reverse Trollim Menggunakan Matematika</a></li>
<li><a href="../id433282/index.html">Gateway protokol pertukaran industri di Linux. Kumpulkan dirimu</a></li>
<li><a href="../id433286/index.html">10 rapat IT dan hackathon terdekat di Moskow</a></li>
<li><a href="../id433292/index.html">Intisari materi menarik untuk pengembang ponsel # 279 (pada 10 - 16 Desember)</a></li>
<li><a href="../id433294/index.html">Beberapa rekomendasi kerja tim yang sederhana</a></li>
<li><a href="../id433296/index.html">Manajemen keuangan di perusahaan IT</a></li>
<li><a href="../id433298/index.html">Network Digest: 17 bahan ahli tentang Wi-Fi dan 5G</a></li>
<li><a href="../id433300/index.html">Membuat pusat media rumah. Prolog</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>