<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍲 🗒️ 🧒🏿 Kesalahan pengembangan teratas saat bekerja dengan PostgreSQL ⛎ 📄 ⛹🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HighLoad ++ sudah ada sejak lama, dan kami berbicara tentang bekerja dengan PostgreSQL secara teratur. Tetapi pengembang masih memiliki masalah yang s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kesalahan pengembangan teratas saat bekerja dengan PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/455248/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++</a> sudah ada sejak lama, dan kami berbicara tentang bekerja dengan PostgreSQL secara teratur.  Tetapi pengembang masih memiliki masalah yang sama dari bulan ke bulan, dari tahun ke tahun.  Ketika di perusahaan kecil tanpa DBA di negara bagian ada kesalahan dalam bekerja dengan database, ini tidak mengejutkan.  Perusahaan-perusahaan besar juga membutuhkan basis data, dan bahkan dengan proses debug, kesalahan masih terjadi dan basis data jatuh.  Tidak masalah apa ukuran perusahaan itu - kesalahan masih terjadi, database mengalami crash, crash secara berkala. <br><br><img src="https://habrastorage.org/webt/k7/dz/pb/k7dzpbs_rg2wat7ac4awvar2h-e.png"><br><br>  Tentu saja, ini tidak akan pernah terjadi pada Anda, tetapi memeriksa daftar periksa itu tidak sulit, dan akan sangat layak untuk menyelamatkan saraf di masa depan.  Di bawah cat, kami akan membuat daftar kesalahan khas teratas yang dibuat pengembang ketika bekerja dengan PostgreSQL, lihat mengapa kami tidak perlu melakukan ini, dan mencari tahu caranya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HjLnY0aPQZo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Tentang pembicara: Alexey Lesovsky</b> dimulai sebagai administrator sistem Linux.  Dari tugas-tugas sistem virtualisasi dan pemantauan secara bertahap datang ke PostgreSQL.  Sekarang PostgreSQL DBA di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data Egret</a> , sebuah perusahaan konsultan yang bekerja dengan banyak proyek berbeda dan melihat banyak contoh masalah berulang.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke penyajian laporan di HighLoad ++ 2018. <br><a name="habracut"></a><br><h2>  Dari mana datangnya masalah </h2><br>  Untuk pemanasan, beberapa cerita tentang bagaimana kesalahan terjadi. <br><br><h3>  Sejarah 1. Fitur </h3><br>  Salah satu masalah adalah fitur apa yang digunakan perusahaan ketika bekerja dengan PostgreSQL.  Semuanya dimulai sederhana: PostgreSQL, kumpulan data, pertanyaan sederhana dengan BERGABUNG.  Kami mengambil data, lakukan SELECT - semuanya sederhana. <br><br>  Kemudian kita mulai menggunakan fungsionalitas tambahan PostgreSQL, tambahkan fungsi baru, ekstensi.  Fiturnya semakin besar.  Kami menghubungkan replikasi streaming, sharding.  Berbagai utilitas dan body kit muncul di sekitar - pgbouncer, pgpool, patroni.  Sesuatu seperti itu. <br><br><img src="https://habrastorage.org/webt/_i/kr/an/_ikran7pf4ni9e4hyxiwptuhwy4.png"><br><br><blockquote>  Setiap kata kunci adalah alasan munculnya kesalahan. </blockquote><br><h3>  Sejarah 2. Penyimpanan Data </h3><br>  Cara kami menyimpan data juga merupakan sumber kesalahan. <br><br>  Ketika proyek pertama kali muncul, ada beberapa data dan tabel di dalamnya.  Permintaan sederhana sudah cukup untuk menerima dan merekam data.  Tetapi kemudian ada semakin banyak tabel.  Data dipilih dari tempat yang berbeda, BERGABUNG muncul.  Kueri rumit dan termasuk konstruksi CTE, SUBQUERY, IN, LATERAL.  Membuat kesalahan dan menulis kueri kurva menjadi lebih mudah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/37e/620/ff937e6202947bba4393531475868c74.png"><br><br>  Dan ini hanyalah puncak gunung es - di suatu tempat di sampingnya terdapat 400 tabel, partisi, dari mana data juga kadang-kadang dibaca. <br><br><h3>  Sejarah 3. Siklus Hidup </h3><br>  Kisah bagaimana produk itu diikuti.  Data selalu perlu disimpan di suatu tempat, jadi selalu ada database.  Bagaimana database berkembang ketika suatu produk berkembang? <br><br>  Di satu sisi, ada <b>pengembang</b> yang sibuk dengan bahasa pemrograman.  Mereka menulis aplikasi mereka dan mengembangkan keterampilan di bidang pengembangan perangkat lunak, tidak memperhatikan layanan.  Seringkali mereka tidak tertarik pada cara kerja Kafka atau PostgreSQL - mereka mengembangkan fitur baru dalam aplikasi mereka, dan mereka tidak peduli dengan yang lain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/056/1c3/00a/0561c300abe5623898768ad7d334a334.png"><br><br>  <b>Admin, di sisi</b> lain.  Mereka meningkatkan instance Amazon baru di Bare-metal dan sibuk dengan otomatisasi: mereka mengatur penyebaran untuk membuat tata letak berfungsi dengan baik, dan mengkonfigurasi agar layanan saling berinteraksi dengan baik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/3f5/8fb/9613f58fb950f69b235d5b80cc29e1b4.png"><br><br>  Ada situasi ketika tidak ada waktu atau keinginan untuk penyetelan komponen yang tipis, dan juga basis data.  Basis data bekerja dengan konfigurasi default, dan kemudian mereka benar-benar melupakannya - "berfungsi, jangan menyentuhnya". <br><br>  Akibatnya, garu tersebar di berbagai tempat, yang sekarang dan kemudian terbang ke dahi pengembang.  Pada artikel ini, kami akan mencoba untuk mengumpulkan semua garu ini dalam satu gudang sehingga Anda tahu tentang mereka dan tidak menginjaknya ketika bekerja dengan PostgreSQL. <br><br><h2>  Perencanaan dan pemantauan </h2><br>  Pertama, bayangkan kita memiliki proyek baru - selalu merupakan pengembangan aktif, pengujian hipotesis, dan implementasi fitur baru.  Pada saat aplikasi baru saja muncul dan sedang berkembang, ia memiliki sedikit lalu lintas, pengguna dan pelanggan, dan mereka semua menghasilkan sejumlah kecil data.  Basis data memiliki kueri sederhana yang cepat diproses.  Tidak perlu menyeret data dalam jumlah besar, tidak ada masalah. <br><br>  Tetapi ada lebih banyak pengguna, lalu lintas datang: data baru muncul, basis data bertambah dan permintaan lama berhenti berfungsi.  Anda perlu melengkapi indeks, menulis ulang, dan mengoptimalkan kueri.  Ada masalah kinerja.  Semua ini mengarah pada peringatan jam 4 pagi, tekanan untuk admin dan ketidakpuasan manajemen. <br><br><h3>  Apa yang salah </h3><br><blockquote>  Dalam pengalaman saya, paling sering tidak ada cukup disk. </blockquote><br>  <b>Contoh pertama</b> .  Kami membuka jadwal untuk memantau pemanfaatan disk, dan kami melihat bahwa <b>ruang kosong pada disk sudah habis</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/245/c83/65b245c834e20a94ed7e698b08cfabaf.png"><br><br>  Kami melihat berapa banyak ruang dan apa yang dimakan - ternyata ada direktori pg_xlog: <br><br><pre><code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 15G /pgdb/9.6/main/base 58G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Admin database biasanya tahu apa direktori ini, dan mereka tidak menyentuhnya - itu ada dan ada.  Tetapi pengembang, terutama jika dia melihat pementasan, menggaruk kepalanya dan berpikir: <br><br>  <i>- Beberapa jenis log ... Mari kita hapus pg_xlog!</i> <br><br>  <b>Menghapus direktori, basis data berhenti berfungsi</b> .  Segera Anda harus mencari cara meningkatkan database setelah Anda menghapus log transaksi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b8/1af/30c/2b81af30c865d529e6f7ff3fd66339ce.png"><br><br>  <b>Contoh kedua</b> .  Sekali lagi, kami membuka pemantauan dan melihat bahwa tidak ada cukup ruang.  Kali ini tempat itu ditempati semacam pangkalan. <br><br><pre> <code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 70G /pgdb/9.6/main/base 2G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Kami mencari basis data mana yang paling banyak memakan ruang, tabel dan indeks mana. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/ffc/4e9/d88ffc4e98ca1fd4648ac7aea1c8d019.png"><br><br>  Ternyata ini adalah tabel dengan log historis.  Kami tidak pernah membutuhkan catatan sejarah.  Mereka ditulis berjaga-jaga, dan jika bukan karena masalah dengan tempat, tidak ada yang akan melihat mereka sampai kedatangan kedua: <br><br>  <i>- Mari kita bersihkan semua yang mm ... lebih tua dari Oktober!</i> <br><br>  Buat permintaan pembaruan, jalankan, itu akan berhasil dan hapus beberapa baris. <br><br><pre> <code class="plaintext hljs">=# DELETE FROM history_log -# WHERE created_at &lt; «2018-10-01»; DELETE 165517399 Time: 585478.451 ms</code> </pre> <br>  Kueri berjalan selama 10 menit, tetapi tabel masih membutuhkan jumlah ruang yang sama. <br><br>  PostgreSQL menghapus baris dari tabel - semuanya benar, tetapi tidak mengembalikan tempat ke sistem operasi.  Perilaku PostgreSQL ini tidak diketahui oleh sebagian besar pengembang dan bisa sangat mengejutkan. <br><br>  <b>Contoh ketiga</b> .  Misalnya, ORM membuat permintaan yang menarik.  Biasanya semua orang menyalahkan ORM karena membuat kueri "buruk" yang membacakan beberapa tabel. <br><br>  Misalkan ada beberapa operasi BERGABUNG yang membaca tabel secara paralel di banyak utas.  PostgreSQL dapat memparalelkan operasi data dan dapat membaca tabel dalam banyak utas.  Tetapi, mengingat kami memiliki beberapa server aplikasi, kueri ini membaca semua tabel beberapa ribu kali per detik.  Ternyata server database kelebihan beban, disk tidak dapat mengatasinya, dan semua ini mengarah ke <b>502 Bad Gateway</b> error dari backend - database tidak tersedia. <br><br>  Tapi itu belum semuanya.  Anda dapat mengingat fitur-fitur PostgerSQL lainnya. <br><br><ul><li>  <b>Rem proses latar belakang DBMS</b> - PostgreSQL memiliki semua jenis pos pemeriksaan, vakum, dan replikasi. <br></li><li>  <b>Overhead virtualisasi</b> .  Ketika database berjalan pada mesin virtual, pada besi yang sama ada juga mesin virtual di samping, dan mereka dapat konflik sumber daya. <br></li><li>  <b>Penyimpanan berasal dari pabrikan Cina</b> , <b>NoName</b> , yang kinerjanya tergantung pada bulan di Capricorn atau posisi Saturnus, dan tidak ada cara untuk mengetahui mengapa ia bekerja dengan cara ini.  Basisnya adalah penderitaan. <br></li><li>  <b>Konfigurasi default</b> .  Ini adalah topik favorit saya: pelanggan mengatakan bahwa basis datanya melambat - Anda lihat, dan ia memiliki konfigurasi default.  Faktanya adalah konfigurasi default PostgreSQL dirancang untuk <b>dijalankan pada teko terlemah</b> .  Basis diluncurkan, ia bekerja, tetapi ketika sudah bekerja pada perangkat keras tingkat menengah, maka konfigurasi ini tidak cukup, perlu disetel. <br></li></ul><br><blockquote>  Paling sering, PostgreSQL tidak memiliki ruang disk atau kinerja disk.  Untungnya, dengan prosesor, memori, dan jaringan, sebagai aturan, semuanya kurang lebih teratur. </blockquote><br>  Bagaimana menjadi  Perlu pemantauan dan perencanaan!  Kelihatannya jelas, tetapi untuk beberapa alasan, dalam banyak kasus, tidak ada yang merencanakan basis, dan pemantauan tidak mencakup semua yang perlu dipantau selama operasi PostgreSQL.  Ada seperangkat aturan yang jelas, yang dengannya semuanya akan bekerja dengan baik, dan tidak "secara acak". <br><br><h3>  Perencanaan </h3><br>  <b>Host basis data pada SSD tanpa ragu-ragu</b> .  SSD telah lama menjadi andal, stabil, dan produktif.  Model SSD perusahaan telah ada selama bertahun-tahun. <br><br>  <b>Selalu rencanakan skema data</b> .  Jangan menulis ke database bahwa Anda meragukan apa yang dibutuhkan - dijamin tidak diperlukan.  Contoh sederhana adalah tabel yang sedikit dimodifikasi dari salah satu pelanggan kami. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/56f/9ec/9e156f9ec534a11c5e80180c1c72a987.png"><br><br>  Ini adalah tabel log di mana ada kolom data tipe json.  Secara relatif, Anda dapat menulis apa pun di kolom ini.  Dari catatan terakhir dari tabel ini jelas bahwa log menempati 8 MB.  PostgreSQL tidak memiliki masalah menyimpan catatan dengan panjang ini.  PostgreSQL memiliki penyimpanan yang sangat baik yang mengunyah catatan tersebut. <br><br>  Tetapi masalahnya adalah ketika server aplikasi membaca data dari tabel ini, mereka akan dengan mudah menyumbat seluruh bandwidth jaringan, dan permintaan lainnya akan menderita.  Ini adalah masalah perencanaan skema data. <br><br>  <b>Gunakan partisi untuk setiap petunjuk dari cerita yang perlu disimpan selama lebih dari dua tahun</b> .  Partisi terkadang tampak rumit - Anda perlu repot dengan pemicu, dengan fungsi yang akan membuat partisi.  Dalam versi baru PostgreSQL, situasinya lebih baik dan sekarang pengaturan partisi jauh lebih sederhana - setelah selesai, dan berfungsi. <br><br>  Dalam contoh penghapusan data yang dipertimbangkan dalam 10 menit, <code>DELETE</code> dapat diganti dengan <code>DROP TABLE</code> - operasi semacam itu dalam kondisi yang sama hanya akan memakan waktu beberapa milidetik. <br><br>  Ketika data diurutkan berdasarkan partisi, partisi tersebut dihapus secara harfiah dalam beberapa milidetik, dan OS langsung mengambil alih.  Mengelola data historis lebih mudah, lebih mudah, dan lebih aman. <br><br><h3>  Pemantauan </h3><br>  Pemantauan adalah topik besar yang terpisah, tetapi dari sudut pandang basis data ada rekomendasi yang dapat masuk ke dalam satu bagian artikel. <br><br>  Secara default, banyak sistem pemantauan menyediakan pemantauan prosesor, memori, jaringan, ruang disk, tetapi, sebagai aturannya, <b>tidak ada pembuangan perangkat disk</b> .  Informasi tentang seberapa dimuat disk, berapa bandwidth saat ini pada disk dan nilai latensi harus selalu ditambahkan ke pemantauan.  Ini akan membantu Anda dengan cepat mengevaluasi bagaimana drive dimuat. <br><br>  Ada banyak opsi pemantauan PostgreSQL, ada untuk setiap selera.  Inilah beberapa poin yang harus ada. <br><br><ul><li>  <b>Klien yang Terhubung</b> .  Penting untuk memantau status mereka bekerja, dengan cepat menemukan pelanggan "berbahaya" yang membahayakan database, dan mematikannya. </li><li>  <b>Kesalahan</b>  Penting untuk memantau kesalahan untuk melacak seberapa baik database berfungsi: tidak ada kesalahan - hebat, kesalahan telah muncul - alasan untuk melihat log dan mulai memahami apa yang salah. </li><li>  <b>Permintaan (pernyataan)</b> .  Kami memantau karakteristik permintaan kuantitatif dan kualitatif untuk menilai secara kasar apakah kami memiliki permintaan yang lambat, panjang, atau padat sumber daya. </li></ul><br>  Untuk informasi lebih lanjut, lihat laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Dasar-Dasar Pemantauan PostgreSQL"</a> dengan HighLoad ++ Siberia dan halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemantauan</a> di Wiki PostgreSQL. <br><br>  Ketika kami merencanakan semuanya dan "menutupi diri kami" dengan pemantauan, kami masih bisa menghadapi beberapa masalah. <br><br><h3>  Scaling </h3><br>  Biasanya, pengembang melihat garis database di konfigurasi.  Dia tidak terlalu tertarik pada bagaimana hal itu diatur secara internal - bagaimana pos pemeriksaan, replikasi, penjadwal bekerja.  Pengembang sudah memiliki sesuatu untuk dilakukan - selain itu ada banyak hal menarik yang ingin ia coba. <br><br><blockquote>  "Beri aku alamat pangkalan, lalu aku sendiri."  © Pengembang anonim. </blockquote><br>  Ketidaktahuan subjek menyebabkan konsekuensi yang cukup menarik ketika pengembang mulai menulis pertanyaan yang berfungsi dalam database ini.  Fantasi saat menulis kueri terkadang memberikan efek yang menakjubkan. <br><br>  Ada dua jenis transaksi.  <b>Transaksi OLTP</b> cepat, pendek, ringan yang mengambil pecahan satu milidetik.  Mereka bekerja sangat cepat, dan ada banyak dari mereka.  <b>OLAP - kueri analitis</b> - lambat, panjang, berat, baca array tabel besar dan baca statistik. <br><br>  <b>Selama</b> 2-3 tahun terakhir, singkatan <b>HTAP</b> sering berbunyi - Hybrid Transaction / Analytical Processing atau <b>hybrid transactional-analytical processing</b> .  Jika Anda tidak punya waktu untuk memikirkan penskalaan dan keragaman permintaan OLAP dan OLTP, Anda dapat mengatakan: "Kami memiliki HTAP!"  Tetapi pengalaman dan rasa sakit kesalahan menunjukkan bahwa, setelah semua, berbagai jenis permintaan harus hidup terpisah satu sama lain, karena permintaan OLAP lama memblokir permintaan OLTP ringan. <br><br>  Jadi kita sampai pada pertanyaan tentang bagaimana skala PostgreSQL untuk menyebarkan beban, dan semua orang puas. <br><br>  <b>Streaming replikasi</b> .  Opsi termudah adalah <b>replikasi streaming</b> .  Ketika aplikasi bekerja dengan database, kami menghubungkan beberapa replika ke database ini dan mendistribusikan beban.  Rekaman masih pergi ke pangkalan utama, dan membaca ke replika.  Metode ini memungkinkan Anda untuk skala sangat luas. <br><br>  Plus, Anda dapat menghubungkan lebih banyak replika ke replika individual dan mendapatkan <b>replikasi berjenjang</b> .  Grup pengguna atau aplikasi terpisah yang, misalnya, membaca analytics, dapat dipindahkan ke replika terpisah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f4/5b3/2d7/7f45b32d7eeb8dfcd7e19cfb38210134.png"><br><br>  <b>Publikasi logis, langganan</b> - mekanisme publikasi logis dan langganan menyiratkan adanya beberapa server PostgreSQL independen dengan basis data dan kumpulan tabel terpisah.  Kumpulan tabel ini dapat dihubungkan ke database tetangga, mereka akan terlihat oleh aplikasi yang dapat menggunakannya secara normal.  Artinya, semua perubahan yang terjadi pada sumber direplikasi ke basis tujuan dan terlihat di sana.  Bekerja sangat baik dengan PostgreSQL 10. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13a/4aa/068/13a4aa06893b4ae9f1a1b7523c407b06.png"><br><br>  <b>Tabel asing, Partisi Deklaratif - partisi deklaratif dan tabel eksternal</b> .  Anda dapat mengambil beberapa PostgreSQL dan membuat beberapa set tabel di sana yang akan menyimpan rentang data yang diinginkan.  Ini bisa berupa data untuk tahun tertentu atau data yang dikumpulkan dari rentang apa pun. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/929/cb9/109929cb936d0c040651ad30c130258b.png"><br><br>  Menggunakan mekanisme tabel eksternal, Anda dapat menggabungkan semua database ini dalam bentuk tabel dipartisi dalam PostgreSQL terpisah.  Aplikasi mungkin sudah berfungsi dengan tabel partisi ini, tetapi sebenarnya itu akan membaca data dari partisi jarak jauh.  Ketika volume data lebih dari kemampuan satu server, maka ini sharding. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/446/d13/a39/446d13a394143b988ec04f60e645ea21.png"><br><br>  Semua ini dapat digabungkan ke dalam penyebaran konfigurasi, untuk menghasilkan topologi replikasi PostgreSQL yang berbeda, tetapi bagaimana semuanya bekerja dan bagaimana mengelolanya adalah topik dari laporan terpisah. <br><br><h3>  Di mana untuk memulai? </h3><br>  Opsi termudah adalah <b>dengan replikasi</b> .  Langkah pertama adalah menyebarkan beban membaca dan menulis.  Yaitu, menulis kepada master, dan membaca dari replika.  Jadi kami skala beban dan melakukan pembacaan dari penyihir.  Selain itu, jangan lupakan analis.  Kueri analitik bekerja untuk waktu yang lama, mereka membutuhkan replika terpisah dengan pengaturan terpisah sehingga kueri analitik yang panjang tidak dapat mengganggu sisanya. <br><br>  Langkah selanjutnya adalah <b>menyeimbangkan</b> .  Kami masih memiliki baris yang sama dalam konfigurasi yang dioperasikan pengembang.  Dia membutuhkan tempat di mana dia akan menulis dan membaca.  Ada beberapa opsi di sini. <br><br>  Ideal adalah menerapkan penyeimbangan <b>pada tingkat aplikasi</b> , ketika aplikasi itu sendiri tahu dari mana membaca data, dan tahu bagaimana memilih replika.  Misalkan saldo akun selalu mutakhir dan perlu dibaca dari master, dan gambar produk atau informasi tentangnya dapat dibaca dengan penundaan dan dilakukan dari replika. <br><br><ul><li>  <b>DNS Round Robin</b> , menurut pendapat saya, bukan implementasi yang sangat nyaman, karena kadang-kadang itu bekerja untuk waktu yang lama dan tidak memberikan waktu yang diperlukan ketika berpindah peran wizard antara server dalam kasus failover. </li><li>  Opsi yang lebih menarik adalah menggunakan <b>Keepalived dan HAProxy</b> .  Alamat virtual untuk master dan set replika dilemparkan antara server HAProxy, dan HAProxy sudah menyeimbangkan lalu lintas. </li><li>  <b>Patroni, DCS</b> bersamaan dengan sesuatu seperti ZooKeeper, etcd, Consul - opsi yang paling menarik, menurut saya.  Artinya, penemuan layanan bertanggung jawab atas informasi siapa yang menjadi master sekarang dan siapa yang merupakan replika.  Patroni mengelola sekelompok PostgreSQL, melakukan switching - jika topologi telah berubah, informasi ini akan muncul dalam penemuan layanan, dan aplikasi dapat dengan cepat mengetahui topologi saat ini. </li></ul><br>  Dan ada nuansa dengan replikasi, yang paling umum adalah <b>lag replikasi</b> .  Anda dapat melakukannya seperti GitLab, dan ketika lag terakumulasi, cukup jatuhkan basis.  Tapi kami memiliki pemantauan komprehensif - kami melihatnya dan melihat transaksi panjang. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/619/9a0/fae/6199a0fae7ed88fb1646e232cc1f2953.png"><br><br><h3>  Aplikasi dan Transaksi DBMS </h3><br>  Secara umum, transaksi lambat dan menganggur menghasilkan: <br><br><ul><li>  <b>penurunan produktivitas</b> - bukan karena spasmodik yang tajam, tetapi halus; <br></li><li>  <b>kunci dan kebuntuan</b> , karena transaksi lama menahan kunci pada baris dan mencegah transaksi lainnya bekerja; <br></li><li>  <b>50 * Kesalahan HTTP pada backend</b> , kesalahan antarmuka, atau di tempat lain. <br></li></ul><br><br>  Mari kita lihat sedikit teori tentang bagaimana masalah ini muncul, dan mengapa mekanisme transaksi yang lama dan tak berguna itu berbahaya. <br><br>  PostgreSQL memiliki MVCC - secara relatif, mesin basis data.  Ini memungkinkan pelanggan untuk bekerja secara kompetitif dengan data tanpa mengganggu satu sama lain: pembaca tidak mengganggu pembaca, dan penulis tidak mengganggu penulis.  Tentu saja, ada beberapa pengecualian, tetapi dalam hal ini tidak penting. <br><br>  Ternyata dalam database untuk satu baris ada beberapa versi untuk transaksi yang berbeda.  Klien terhubung, basis data memberi mereka snapshot data, dan di dalam snapshot ini versi yang berbeda dari garis yang sama mungkin ada.  Dengan demikian, dalam siklus hidup basis data, transaksi digeser, diganti satu sama lain, dan versi baris muncul yang tidak diperlukan oleh siapa pun. <br><br>  Jadi ada <b>kebutuhan untuk pengumpul sampah - vakum otomatis</b> .  Transaksi lama ada dan mencegah vakum otomatis dari membersihkan versi baris yang tidak perlu.  Data sampah ini mulai mengembara dari memori ke disk, dari disk ke memori.  Untuk menyimpan sampah ini, sumber daya CPU dan memori terbuang sia-sia. <br><br><blockquote>  Semakin lama transaksi, semakin banyak sampah dan kinerja yang lebih rendah. </blockquote><br>  Dari sudut pandang "Siapa yang harus disalahkan?", Aplikasi ini harus disalahkan atas penampilan transaksi panjang.  Jika basis data akan ada dengan sendirinya, lama, transaksi apa pun tidak akan diambil dari mana pun.  Dalam praktiknya, ada opsi berikut untuk penampilan transaksi idle. <br><br>  <b>"Ayo pergi ke sumber eksternal</b> . <b>"</b>  Aplikasi membuka transaksi, melakukan sesuatu dalam database, kemudian memutuskan untuk beralih ke sumber eksternal, misalnya, Memcached atau Redis, dengan harapan akan kembali ke database, terus bekerja dan menutup transaksi.  Tetapi jika kesalahan terjadi pada sumber eksternal, aplikasi crash dan transaksi tetap ditutup sampai seseorang memperhatikan dan membunuhnya. <br><br>  <b>Tidak ada penanganan kesalahan</b> .  Di sisi lain, mungkin ada masalah dalam menangani kesalahan.  Ketika, sekali lagi, aplikasi membuka transaksi, memecahkan beberapa masalah dalam database, kembali ke eksekusi kode, melakukan beberapa fungsi dan perhitungan, untuk terus bekerja dalam transaksi dan menutupnya.  Ketika pada perhitungan ini operasi aplikasi terganggu dengan kesalahan, kode kembali ke awal siklus, dan transaksi tetap tidak tertutup. <br><br>  <b>Faktor manusia</b> .  Misalnya, administrator, pengembang, analis, bekerja di beberapa pgAdmin atau di DBeaver - membuka transaksi, melakukan sesuatu di dalamnya.  Kemudian orang itu terganggu, dia beralih ke tugas lain, lalu ke yang ketiga, lupa tentang transaksi, pergi untuk akhir pekan, dan transaksi terus menggantung.  Kinerja dasar menderita. <br><br>  Mari kita lihat apa yang harus dilakukan dalam kasus ini. <br><br><ul><li>  Kami memiliki pemantauan, oleh karena itu, kami membutuhkan <b>peringatan dalam pemantauan</b> .  Setiap transaksi yang hang lebih dari satu jam dan tidak melakukan apa-apa adalah kesempatan untuk melihat dari mana asalnya dan memahami apa yang salah. </li><li>  Langkah selanjutnya adalah <b>menembak transaksi seperti itu melalui tugas di mahkota</b> (pg_terminate_backend (pid)) atau mengkonfigurasi dalam konfigurasi PostgreSQL.  Diperlukan ambang batas 10-30 menit, setelah itu transaksi diselesaikan secara otomatis. </li><li>  <b>Aplikasi refactoring</b> .  Tentu saja, Anda perlu mencari tahu dari mana transaksi idle berasal, mengapa mereka terjadi dan menghilangkan tempat-tempat tersebut. </li></ul><br><blockquote>  Hindari transaksi lama dengan segala cara, karena sangat memengaruhi kinerja basis data. </blockquote><br>  Semuanya menjadi lebih menarik ketika tugas yang tertunda muncul, misalnya, Anda perlu menghitung unit dengan hati-hati.  Dan kita sampai pada masalah konstruksi sepeda. <br><br><h3>  Konstruksi sepeda </h3><br>  Topik sakit.  Bisnis di sisi aplikasi perlu melakukan pemrosesan latar belakang acara.  Misalnya, untuk menghitung agregat: minimum, maksimum, nilai rata-rata, mengirim pemberitahuan kepada pengguna, mengeluarkan faktur kepada pelanggan, mengatur akun pengguna setelah mendaftar atau mendaftar di layanan tetangga - lakukan pemrosesan yang tertunda. <br><br>  Esensi dari tugas-tugas tersebut adalah sama - mereka ditunda untuk nanti.  Tabel muncul di database yang hanya menjalankan antrian. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef4/bfa/f20/ef4bfaf20634c6d43941c9c8325a09ff.png"><br><br>  Berikut adalah pengidentifikasi tugas, waktu ketika tugas dibuat, saat diperbarui, pawang yang mengambilnya, jumlah upaya yang harus diselesaikan.  Jika Anda memiliki tabel yang bahkan jauh menyerupai yang ini, maka Anda memiliki <b>antrian yang ditulis sendiri</b> . <br><br>  Semua ini berfungsi dengan baik sampai transaksi panjang muncul.  Setelah itu, <b>tabel yang berfungsi dengan ukuran antrian membengkak</b> .  Pekerjaan baru ditambahkan setiap saat, yang lama dihapus, pembaruan terjadi - sebuah tabel dengan perekaman intensif diperoleh.  Ini harus dibersihkan secara teratur dari versi string yang usang sehingga kinerja tidak menderita. <br><br>  <b>Waktu pemrosesan bertambah</b> - transaksi panjang menahan kunci pada versi baris yang sudah ketinggalan zaman atau mencegah kekosongan untuk membersihkannya.  Ketika tabel bertambah besar, waktu pemrosesan juga meningkat, karena Anda perlu membaca banyak halaman dengan sampah.  Waktu meningkat, dan <b>antrian di beberapa titik berhenti berfungsi sama sekali</b> . <br><br>  Di bawah ini adalah contoh bagian atas dari salah satu pelanggan kami, yang memiliki antrian.  Semua permintaan hanya terkait dengan antrian. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/344/203/7ac/3442037ac837daec02ee89a83bd53dd7.png"><br><br>  Perhatikan waktu eksekusi permintaan ini - semuanya kecuali satu di antaranya bekerja lebih dari dua puluh detik. <br><br>  Untuk mengatasi masalah ini, <b>Skytools PgQ</b> , manajer antrian untuk PostgreSQL, telah ditemukan sejak lama.  Jangan menemukan kembali sepeda Anda - ambil PgQ, atur sekali dan lupakan garisnya. <br><br>  Benar, dia juga punya fitur.  Skytools PgQ memiliki <b>sedikit dokumentasi</b> .  Setelah membaca halaman resmi, orang merasa bahwa dia tidak mengerti apa-apa.  Perasaan itu tumbuh ketika Anda mencoba melakukan sesuatu.  Semuanya berfungsi, tetapi <b>cara kerjanya tidak jelas</b> .  Semacam sihir Jedi.  Tetapi banyak informasi dapat ditemukan di <b>milis</b> .  Ini bukan format yang sangat nyaman, tetapi ada banyak hal menarik di sana, dan Anda harus membaca lembar ini. <br><br>  Meskipun kontra, Skytools PgQ bekerja pada prinsip "mengatur dan melupakan."   ,    ,     ,    .   PgQ ,        .  PgQ ,      . <br><br><blockquote>    ,   -     —  ,   .     . </blockquote><br>              PgQ. ,    PostgreSQL, ,  ,   PgQ  .    ,   . <br><br><h3>  </h3><br>        ,          .   ,    , ,     - ,   , ,      . ,       ,       ,   alter. <br><br>     <b>auto-failover</b> —       PostgreSQL  - ,       ,        .      ,    auto-failover. <br><br> <b>Split-brain</b> .    PostgreSQL     ,     ,  —  .   ,   .   PostgreSQL     fencing,     Kubernets    .     -    ,         .   Split-brain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/327/239/97e/32723997e13e8427e4cddc59ea7c964f.png"><br><br>           .  GitHub   Split-brain,       . <br><br> <b>Cascade failover</b> . ,     .  ,         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea9/864/d63/ea9864d63b7cebd46ff8b185ddb5d639.png"><br><br>        ,       .    ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81d/243/fc1/81d243fc1500011f0f3c24576f81786a.png"><br><br>         —   failover. <br><br>      auto-failover,    . <br><br> <b>Bash </b> —  ,      .   ,     ,   .   - ,   ,   .     . <br><br> <b>Ansible playbooks</b> — bash-  .    ,   ,    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Patroni</b></a> —   ,    ,      auto-failover,   ,       service discovery. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>PAF</b></a> — <b>  Pacemaker</b> .     auto-failover  PostgreSQL,        Pacemaker. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Stolon</b></a>     .  Kubernetes, . Stolon  Patroni,        . <br><br><h3>    </h3><br>    Docker  Kubernetes .    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b99/aba/8c4/b99aba8c4f9c959cd96840bfcd3359b2.png"><br><br>        ,       . <i> «      Kubernetes...»</i>    . <br><br> <b> —   stateful</b> ,   - .  Dimana?      .   Open Source: CEPH, GlusterFS, LinStor DRBD.    ,       , ,     . <br><br>       — <b>    </b> . ,      Kubernetes,     CEPH.         —    .           ,       . <br><br><ul><li> <b>  </b> ,           . </li><li> <b>     latency</b> .  latency        —    . </li><li> <b>   </b> . Kubernetes ,    - . ,    shared storage  Kubernetes,       .  -         . </li></ul><br>     ,    Kubernetes  Docker    staging  dev-     .    ,   , Kubernetes      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b04/8dd/fd0/b048ddfd0b6212ef2d1eb49eda02386b.png"><br><br>    ,     <b>local volumes —  </b>     , <b>streaming replication —   </b> ,       <b>PostgreSQL-</b> ,       — ,   .       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zalando</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Crunchy</a> . <br><br>    ,     .    issues  pull requests.   ,     ,     . <br><br><h2>  Ringkasan </h2><br> <b>         SSD</b> —          ,    . <br><br> <b>     </b> .   JSON  8  —  ,   . <br><br> <b> </b> ,        .  PostgreSQL,   . <br><br> <b>  — Postgres is ready</b> .          . PostgreSQL   ,        .    : <b>streaming replication; publications, subscriptions; foreign Tables; declarative partitioning</b> . <br><br> <b>    </b> .      ,    . <br><br>    -,      ,   — <b>   </b> .    .    ,  Skytools PgQ! <br><br> <b>     Kubernetes,  local volumes, streaming replication  PostgreSQL </b> .     - ,   ,      . <br><br><blockquote>               .     ,   24  25   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad++ Siberia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ,    ,           .   38    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> —     ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455248/">https://habr.com/ru/post/id455248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455234/index.html">Jenis referensi dapat dihapus dalam C # 8.0 dan analisis statis</a></li>
<li><a href="../id455236/index.html">Comodo mencabut sertifikat tanpa alasan</a></li>
<li><a href="../id455240/index.html">Menggunakan tingkat cacat yang ditolak untuk meningkatkan pelaporan kesalahan</a></li>
<li><a href="../id455242/index.html">Kurang telinga atau bagaimana tidak merusak suara dalam game dari awal</a></li>
<li><a href="../id455244/index.html">Komik "Soldering is Easy" dalam versi yang diperbarui (2019)</a></li>
<li><a href="../id455250/index.html">Orang yang membangkitkan Duke Nukem: wawancara dengan Randy Pitchford, pesulap dari Gearbox</a></li>
<li><a href="../id455256/index.html">Habr Weekly # 4 / Computex, bagaimana kita beta Apple, Durov kelaparan, kucing BadComedian, mengapa jaringan saraf mencari aktor porno</a></li>
<li><a href="../id455258/index.html">Voting untuk laporan bagian Backend pada peringatan DevConfX dimulai, yang akan diselenggarakan pada 21-22 Juni di Moskow</a></li>
<li><a href="../id455260/index.html">Merkle Tree: berkarat dan cepat</a></li>
<li><a href="../id455264/index.html">Jadilah seperti Munch, atau beberapa kata tentang tugas teknis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>