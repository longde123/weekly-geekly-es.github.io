<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø üöæ üç∂ Pruebas unitarias en DBMS: c√≥mo lo hacemos en Sportmaster, segunda parte üë©üèª‚Äçü§ù‚Äçüë®üèø üìø üë®üèæ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La primera parte est√° aqu√≠ . 

  

 Imagina la situaci√≥n. Te enfrentas a la tarea de desarrollar una nueva funcionalidad. Tienes desarrollos de tus pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas unitarias en DBMS: c√≥mo lo hacemos en Sportmaster, segunda parte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/465047/">  <i>La primera parte est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/7s/_h/p0/7s_hp03wefqzcfhl0n867asfuge.png"></a> <br><br>  Imagina la situaci√≥n.  Te enfrentas a la tarea de desarrollar una nueva funcionalidad.  Tienes desarrollos de tus predecesores.  Suponiendo que no tienes obligaciones morales, ¬øqu√© har√≠as? <br><br>  Muy a menudo, todos los logros antiguos se olvidan y todo comienza de nuevo.  A nadie le gusta profundizar en el c√≥digo de otra persona, y si tiene tiempo, ¬øpor qu√© no comenzar a crear su propio sistema?  Este es un enfoque t√≠pico, y es en gran medida correcto.  Pero en nuestro proyecto hicimos mal.  Establecimos las bases para un futuro sistema de prueba automatizado basado en pruebas unitarias en utPLSQL de nuestros predecesores, y luego nos pusimos a trabajar en varias direcciones paralelas. <br><a name="habracut"></a><br><ol><li>  <b>Restaurar antiguas pruebas unitarias.</b>  La recuperaci√≥n se refiere a adaptar las pruebas al estado existente del sistema de lealtad y adaptar las pruebas a los est√°ndares utPLSQL. </li><li>  <b>La soluci√≥n al problema con la comprensi√≥n, y qu√© exactamente, qu√© m√©todos y procesos, estamos cubiertos por las pruebas autom√°ticas.</b>  Debe tener en cuenta esta informaci√≥n o sacar conclusiones basadas en el propio c√≥digo de autotest.  Por lo tanto, decidimos crear un cat√°logo.  Asignamos un c√≥digo mnemot√©cnico √∫nico a cada prueba autom√°tica, formamos una descripci√≥n y arreglamos la configuraci√≥n (por ejemplo, en qu√© condiciones deber√≠a comenzar o qu√© deber√≠a suceder si la prueba comienza a fallar).  Esencialmente, completamos los metadatos sobre las pruebas autom√°ticas y colocamos estos metadatos en las tablas de esquema est√°ndar utPLSQL. </li><li>  <b>Definir una estrategia de expansi√≥n, es decir</b>  <b>selecci√≥n de funcionalidad para ser verificada por autotest.</b>  Decidimos prestar atenci√≥n a tres cosas: nuevas mejoras del sistema, incidentes de producci√≥n y procesos clave del sistema.  Por lo tanto, estamos desarrollando en paralelo con el lanzamiento, proporcionando su mayor calidad, expandiendo simult√°neamente el volumen de regresi√≥n y asegurando la confiabilidad del sistema en lugares cr√≠ticos.  El primer obst√°culo fue el proceso de distribuci√≥n de descuentos y bonificaciones en un cheque. </li><li>  <b>Naturalmente, comenzamos a desarrollar nuevas pruebas autom√°ticas.</b>  Una de las primeras tareas de lanzamiento fue evaluar el rendimiento de muestras predefinidas del sistema de fidelizaci√≥n.  En nuestro proyecto, hay un bloque de consultas sql r√≠gidamente fijas que seleccionan clientes seg√∫n las condiciones.  Por ejemplo, obtenga una lista de todos los clientes cuya √∫ltima compra fue en una ciudad en particular, o una lista de clientes cuyo monto promedio de compra est√° por encima de cierto valor.  Despu√©s de escribir las pruebas autom√°ticas, verificamos las muestras predefinidas, arreglamos los par√°metros de rendimiento de referencia y, adem√°s, tuvimos pruebas de carga. </li><li> <b>El trabajo con autotest debe ser conveniente</b> .  Muy a menudo, se realizan dos acciones: ejecutar pruebas autom√°ticas y crear datos de prueba.  Entonces en nuestro sistema aparecieron dos m√≥dulos auxiliares: el m√≥dulo de lanzamiento y el m√≥dulo de generaci√≥n de datos. <br><br>  El iniciador se presenta como un procedimiento universal √∫nico con un par√°metro de texto de entrada.  Como par√°metro, puede pasar el c√≥digo mnem√≥nico de la prueba autom√°tica, el nombre del paquete, el nombre de la prueba, la configuraci√≥n de la prueba autom√°tica o una palabra clave reservada.  El procedimiento selecciona y ejecuta todas las pruebas autom√°ticas que satisfacen las condiciones. <br><br>  El m√≥dulo de generaci√≥n de datos se presenta en forma de un paquete en el que para cada objeto del sistema bajo prueba (tabla en la base de datos), se crea un procedimiento especial que inserta datos all√≠.  En este procedimiento, los valores predeterminados se completan tanto como sea posible, lo que garantiza la creaci√≥n de objetos con el clic de un dedo.  Y para facilitar su uso, se crearon plantillas para los datos generados.  Por ejemplo, cree un cliente de cierta edad con un tel√©fono de prueba y una compra perfecta. </li><li>  <b>Las pruebas autom√°ticas deben ejecutarse y ejecutarse en un momento aceptable para su sistema.</b>  Por lo tanto, se organiz√≥ un lanzamiento nocturno diario, cuyos resultados generan un informe sobre los resultados y lo env√≠an a todo el equipo de desarrollo por correo corporativo.  Despu√©s de restaurar las antiguas pruebas autom√°ticas y crear otras nuevas, el tiempo total de funcionamiento fue de 30 minutos.  Tal desempe√±o fue adecuado para todos, ya que el lanzamiento tuvo lugar despu√©s de las horas. <br><br>  Pero tuve que trabajar para optimizar la velocidad del trabajo.  La actualizaci√≥n del sistema de fidelizaci√≥n en producci√≥n se realiza de noche.  Como parte de uno de los lanzamientos, tuve que hacer cambios urgentes por la noche.  La media hora de espera de los resultados de las pruebas autom√°ticas a las tres de la ma√±ana no hizo feliz a la persona responsable de la liberaci√≥n (¬°saludos sinceros a Alexei Vasyukov!), Y a la ma√±ana siguiente se dijeron muchas palabras amables hacia nuestro sistema.  Pero seg√∫n los resultados, se estableci√≥ un est√°ndar de trabajo de 5 minutos. <br><br>  Para acelerar el rendimiento, utilizamos dos m√©todos: las pruebas autom√°ticas comenzaron a ejecutarse en tres subprocesos paralelos, lo cual es muy conveniente debido a la arquitectura de nuestro sistema de fidelizaci√≥n.  Y abandonamos el enfoque cuando la prueba autom√°tica no crea datos de prueba por s√≠ misma, sino que trata de encontrar algo adecuado en el sistema.  Despu√©s de hacer los cambios, el tiempo total de operaci√≥n se redujo a 3-4 minutos. </li><li>  <b>El proyecto con pruebas autom√°ticas deber√≠a poder implementarse en varios stands.</b>  Al comienzo del viaje, hubo intentos de escribir sus propios archivos por lotes, pero qued√≥ claro que una instalaci√≥n autom√°tica autoescrita era un completo horror, y recurrimos a soluciones industriales.  Debido al hecho de que el proyecto tiene mucho c√≥digo directo (en primer lugar, almacenamos el c√≥digo para las pruebas autom√°ticas) y muy pocos datos (los datos principales son metadatos sobre las pruebas autom√°ticas), result√≥ ser muy simple introducir Liquibase en el proyecto. <br><br>  Es una biblioteca de c√≥digo abierto independiente de la base de datos para rastrear, administrar y aplicar cambios en el esquema de la base de datos.  Gestionado a trav√©s de la l√≠nea de comandos o marcos como Apache Maven.  El principio de funcionamiento de Liquibase es bastante simple.  Tenemos un proyecto organizado de cierta manera, que consiste en cambios o scripts que deben implementarse en el servidor de destino, y archivos de control que determinan en qu√© secuencia y con qu√© par√°metros deben instalarse estos cambios. <br><br>  En el nivel DBMS, se crea una tabla especial en la que Liquibase almacena el registro de ejecuci√≥n.  Cada cambio tiene un hash calculado, que se compara cada vez entre el proyecto y el estado en la base de datos.  Gracias a Liquibase, podemos transferir f√°cilmente los cambios de nuestro sistema a cualquier circuito.  Las pruebas autom√°ticas ahora se ejecutan en bucles de prueba y lanzamiento, as√≠ como en contenedores (bucles personales de desarrolladores). </li></ol><br><br><img src="https://habrastorage.org/webt/n4/sl/nu/n4slnu-z9xje4obstq1glb8gfqi.png"><br><br>  Entonces, hablemos de los resultados de aplicar nuestro sistema de pruebas unitarias. <br><br><ol><li>  Por supuesto, antes que nada, estamos convencidos de que comenzamos a desarrollar un mejor software.  Las pruebas autom√°ticas se ejecutan diariamente y encuentran docenas de errores cada a√±o.  Adem√°s, algunos de estos errores est√°n relacionados indirectamente con la funcionalidad que realmente quer√≠amos cambiar.  Existen grandes dudas de que estos errores se encontraron mediante pruebas manuales. </li><li>  El equipo gan√≥ confianza en que la funcionalidad espec√≠fica funciona correctamente ... En primer lugar, se refiere a nuestros procesos cr√≠ticos.  Por ejemplo, en los √∫ltimos seis meses, no hemos tenido problemas con la distribuci√≥n de descuentos y bonificaciones en el cheque, a pesar de los cambios en los lanzamientos, aunque en los per√≠odos anteriores se produjeron errores en algunos intervalos </li><li>  Pudimos reducir el n√∫mero de iteraciones de prueba.  Debido al hecho de que las pruebas autom√°ticas se escriben para una nueva funcionalidad, los analizadores y los probadores a tiempo parcial obtienen un c√≥digo de mayor calidad, porque  Ya ha sido verificado. </li><li>  Los desarrolladores utilizan parte de los desarrollos de las pruebas automatizadas.  Por ejemplo, los datos de prueba en contenedores se crean utilizando el m√≥dulo de generaci√≥n de objetos. </li><li>  Es importante que hayamos desarrollado la "adopci√≥n" de un sistema de pruebas automatizadas por parte de los desarrolladores.  Hay un entendimiento de que esto es importante y √∫til.  Y desde mi propia experiencia puedo decir que esto est√° lejos de ser el caso.  Las pruebas autom√°ticas deben escribirse, deben mantenerse y desarrollarse, los resultados deben analizarse y, a menudo, estos costos de tiempo simplemente no valen la pena.  Es mucho m√°s f√°cil ir a la producci√≥n y lidiar con los problemas all√≠.  En nuestro lugar, los desarrolladores se alinean y solicitan cubrir su funcionalidad con pruebas autom√°ticas. </li></ol><br><br><h2>  Que sigue </h2><br><img src="https://habrastorage.org/webt/_u/mq/d4/_umqd4jtmujx7ugli9bwhgrhdj4.png"><br><br>  Hablemos de los planes de desarrollo para el proyecto de pruebas automatizadas. <br><br>  Por supuesto, si bien el sistema de lealtad de Sportmaster sigue vivo y contin√∫a desarroll√°ndose, tambi√©n es posible desarrollar autocomprobaciones casi sin fin.  Por lo tanto, la direcci√≥n principal del desarrollo es la expansi√≥n del √°rea de cobertura. <br><br>  A medida que aumenta el n√∫mero de autotests, el tiempo total de su trabajo crecer√° de manera constante y nuevamente tendremos que volver al tema de la productividad.  Lo m√°s probable es que la soluci√≥n sea aumentar el n√∫mero de hilos paralelos. <br><br>  Pero estos son caminos de desarrollo obvios.  Si hablamos de algo m√°s no trivial, destacamos lo siguiente: <br><br><ol><li>  Actualmente, las pruebas autom√°ticas se gestionan a nivel DBMS, es decir,  necesita conocimientos de PL / SQL para trabajar con √©xito.  Si es necesario, controle el sistema (por ejemplo, iniciando o creando metadatos), puede hacer alg√∫n tipo de panel de administraci√≥n usando Jenkins o algo similar. </li><li>  Todos aman los indicadores cuantitativos y cualitativos.  Para las pruebas automatizadas, dicha m√©trica universal es la Cobertura de c√≥digo o las m√©tricas de cobertura de c√≥digo.  Con este indicador, podemos determinar qu√© porcentaje del c√≥digo de nuestro sistema de prueba est√° cubierto por las pruebas autom√°ticas.  A partir de la versi√≥n 12.2, Oracle proporciona la capacidad de calcular esta m√©trica y sugiere utilizar el paquete est√°ndar DBMS_PLSQL_CODE_COVERAGE. <br><br>  Nuestro sistema de prueba autom√°tica tiene poco m√°s de un a√±o, y quiz√°s ahora sea el momento de evaluar la cobertura.  En mi proyecto anterior (un proyecto que no es de Sportmaster) sucedi√≥.  Un a√±o despu√©s de trabajar en las pruebas autom√°ticas, la gerencia estableci√≥ una meta para evaluar qu√© porcentaje del c√≥digo cubrimos.  Con una cobertura de m√°s del 1%, la administraci√≥n estar√≠a contenta.  Nosotros, los desarrolladores, esper√°bamos un resultado de aproximadamente el 10%.  C√≥digo de cobertura atornillado, medido, recibido 20%.  Para celebrar, fuimos por un premio, pero c√≥mo lo hicimos y d√≥nde fuimos m√°s tarde es una historia completamente diferente. </li><li>  Las pruebas autom√°ticas pueden verificar los servicios web expuestos.  Oracle le permite hacer esto, y ya no encontraremos una serie de problemas. </li><li>  Y, por supuesto, nuestro sistema de prueba automatizado puede aplicarse en otro proyecto.  Nuestra soluci√≥n es universal y solo requiere el uso de Oracle.  Escuch√© que en otros proyectos de Sportmaster hay un inter√©s en las pruebas autom√°ticas y, tal vez, iremos a ellos. </li></ol><br><h2>  Conclusiones </h2><br>  Resumamos  En el proyecto, el sistema de fidelizaci√≥n en Sportmaster logramos implementar un sistema de prueba automatizado.  Su base es la soluci√≥n utPLSQL de Stephen Feuerstein.  Alrededor de utPLSQL se encuentra el c√≥digo de autotest y los m√≥dulos auxiliares autoescritos: m√≥dulo de lanzamiento, m√≥dulo de generaci√≥n de datos y otros.  Las pruebas autom√°ticas se realizan a diario y, lo m√°s importante, funcionan y aportan beneficios.  Estamos convencidos de que hemos comenzado a lanzar software de mayor calidad.  Al mismo tiempo, la soluci√≥n resultante es universal y puede aplicarse libremente en cualquier proyecto donde sea necesario organizar pruebas automatizadas en Oracle DBMS. <br><br>  <i>PD Este art√≠culo no es muy espec√≠fico: hay mucho texto y casi no hay ejemplos t√©cnicos.</i>  <i>Si el tema es globalmente interesante, entonces estamos listos para continuarlo y regresar con una continuaci√≥n, donde le diremos qu√© ha cambiado en los √∫ltimos seis meses y le daremos ejemplos de c√≥digo.</i> <i><br><br></i>  <i>Escriba comentarios si hay puntos en los que vale la pena centrarse en el futuro, o preguntas que requieren divulgaci√≥n.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465047/">https://habr.com/ru/post/465047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465031/index.html">Vista interior: RFID en el mundo moderno. Parte 2: RFID chino</a></li>
<li><a href="../465033/index.html">Ven con la tecnolog√≠a Powercheck</a></li>
<li><a href="../465039/index.html">Semana de la seguridad 35: estad√≠sticas de contrase√±as y ataques filtrados a trav√©s de Google Drive</a></li>
<li><a href="../465041/index.html">C√≥mo hacer una transacci√≥n BTC sin depositar monedas peque√±as</a></li>
<li><a href="../465045/index.html">Kali Linux NetHunter en Android: por qu√© y c√≥mo instalar</a></li>
<li><a href="../465049/index.html">10 libros sobre gesti√≥n √°gil de proyectos que vale la pena llevar contigo en 2020</a></li>
<li><a href="../465055/index.html">Seis habilidades para llevar tu carrera de ciencia de datos al siguiente nivel.</a></li>
<li><a href="../465057/index.html">Contenedores y Ventanas. De Hello World a Kubernetes. Primera parte, introductoria</a></li>
<li><a href="../465059/index.html">PoE a una distancia de m√°s de 200 metros. Monitoreo y reinicio autom√°tico de clientes PoE</a></li>
<li><a href="../465061/index.html">¬øPor qu√©, en lugar de una semana laboral de cuatro d√≠as, es mejor pensar en un d√≠a laboral de seis horas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>