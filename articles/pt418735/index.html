<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèº üëºüèæ üöπ Foco na propriedade üö• üõÄüèº üó£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota tradutor: o registro √© datado de 13 de maio de 2014, portanto, alguns detalhes, incluindo o c√≥digo-fonte, podem n√£o corresponder ao estado atual ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Foco na propriedade</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418735/"><p>  <em>Nota</em>  <em>tradutor: o registro √© datado de 13 de maio de 2014, portanto, alguns detalhes, incluindo o c√≥digo-fonte, podem n√£o corresponder ao estado atual das coisas.</em>  <em>A resposta √† pergunta por que a tradu√ß√£o de um post t√£o longo √© necess√°ria ser√° o valor de seu conte√∫do para formar um entendimento de um dos conceitos fundamentais da linguagem Rust, como flu√™ncia.</em> </p><br><p>  Com o tempo, fiquei convencido de que seria melhor abandonar a distin√ß√£o entre vari√°veis ‚Äã‚Äãlocais mut√°veis ‚Äã‚Äãe imut√°veis ‚Äã‚Äãno Rust.  Pelo menos muitas pessoas s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√©ticas</a> sobre esse assunto.  Eu queria declarar minha posi√ß√£o em p√∫blico.  Darei v√°rios motivos: filos√≥ficos, t√©cnicos e pr√°ticos, al√©m de me voltar para a principal defesa do sistema atual.  (Observa√ß√£o: eu vi isso como Rust RFC, mas decidi que o tom √© melhor para uma postagem de blog e n√£o tenho tempo para reescrev√™-la agora.) </p><a name="habracut"></a><br><h2 id="poyasnenie">  Explica√ß√£o </h2><br><p>  Escrevi este artigo de maneira bastante decisiva e acredito que a linha que estou defendendo estar√° correta.  No entanto, se n√£o concluirmos o suporte ao sistema atual, isso n√£o ser√° um desastre ou algo assim.  Tem suas vantagens e, no geral, acho bastante agrad√°vel.  Eu apenas acho que podemos melhor√°-lo. </p><br><h2 id="odnim-slovom">  Em uma palavra </h2><br><p> Gostaria de remover a distin√ß√£o entre vari√°veis ‚Äã‚Äãlocais imut√°veis ‚Äã‚Äãe mut√°veis ‚Äã‚Äãe renomear <code>&amp;mut</code> ponteiros para <code>&amp;my</code> , <code>&amp;only</code> ou <code>&amp;uniq</code> (isso n√£o <code>&amp;uniq</code> diferen√ßa para mim).  Se ao menos n√£o houvesse palavra-chave <code>mut</code> . </p><br><h2 id="filosofskiy-motiv">  Motivo filos√≥fico </h2><br><p>  A principal raz√£o pela qual desejo fazer isso √© porque acredito que isso tornar√° a linguagem mais consistente e f√°cil de entender.  Essencialmente, isso nos reorientar√° de falar sobre <em>mutabilidade</em> para falar sobre o <em>uso de aliases</em> (que chamarei de "compartilhamento", veja abaixo). </p><br><p>  A variabilidade se torna uma conseq√º√™ncia da singularidade: "Voc√™ sempre pode alterar tudo o que tem acesso exclusivo. Os dados compartilhados geralmente s√£o imut√°veis, mas se voc√™ precisar, pode alter√°-los usando algum tipo de tipo de <code>Cell</code> ". </p><br><p>  Em outras palavras, com o tempo, ficou claro para mim que problemas com a corrida de dados e a seguran√ßa da mem√≥ria surgem quando voc√™ tem o uso de aliases e mutabilidade.  Uma abordagem funcional para resolver esse problema √© eliminar a mutabilidade.  A abordagem de Rust seria remover o uso de aliases.  Isso nos d√° uma hist√≥ria que pode ser contada e que nos ajudar√° a descobrir. </p><br><p>  Uma observa√ß√£o sobre terminologia: acho que devemos nos referir ao <em>uso de aliases</em> como <em>separa√ß√£o</em> ( <em>nota do tradutor: daqui em diante, em todo lugar, em vez de "aliasing", √© usado "sharing" no significado de "separa√ß√£o" ou "propriedade compartilhada", pois nenhum "uso de aliases", nenhuma "pseudonimiza√ß√£o" d√° uma compreens√£o do que est√° em jogo</em> ).  No passado, evit√°vamos isso devido √†s suas refer√™ncias multiencadeadas.  No entanto, se / quando implementarmos os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">planos de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paraleliza√ß√£o de dados</a> que propus, essa conota√ß√£o n√£o ser√° totalmente inapropriada.  De fato, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dada a estreita rela√ß√£o</a> entre seguran√ßa de mem√≥ria e corrida de dados, eu realmente quero promover essa conota√ß√£o. </p><br><h2 id="obrazovatelnyy-motiv">  Motivo educacional </h2><br><p>  Eu acho que as regras atuais s√£o mais dif√≠ceis de entender do que deveriam ser.  N√£o √© √≥bvio, por exemplo, que o <code>&amp;mut T</code> n√£o implica nenhuma propriedade compartilhada.  Al√©m disso, a designa√ß√£o <code>&amp;mut T</code> implica que <code>&amp;T</code> n√£o implica mutabilidade, que n√£o √© totalmente exata, devido a tipos como <code>Cell</code> .  E √© imposs√≠vel concordar sobre como cham√°-los ("links mut√°veis ‚Äã‚Äã/ imut√°veis" √© o mais comum, mas isso n√£o est√° totalmente correto). </p><br><p>  Por outro lado, um tipo como <code>&amp;my T</code> ou <code>&amp;only T</code> parece simplificar a explica√ß√£o.  Esse √© um <em>link exclusivo</em> - naturalmente, voc√™ n√£o pode for√ßar dois deles a apontar para o mesmo lugar.  E a <em>mutabilidade</em> √© uma coisa ortogonal: vem da singularidade, mas tamb√©m vale para as c√©lulas.  E o tipo <code>&amp;T</code> √© exatamente o oposto, um <em>link compartilhado</em> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O RFC PR # 58</a> fornece v√°rios argumentos semelhantes.  N√£o vou repeti-los aqui. </p><br><h2 id="prakticheskiy-motiv">  Motivo pr√°tico </h2><br><p>  Atualmente, existe uma lacuna entre ponteiros emprestados, que podem ser compartilhados ou mut√°veis ‚Äã‚Äã+ exclusivos e vari√°veis ‚Äã‚Äãlocais que s√£o sempre √∫nicas, mas que podem ser mut√°veis ‚Äã‚Äãou imut√°veis.  O resultado final disso √© que os usu√°rios devem postar an√∫ncios <code>mut</code> sobre coisas que n√£o s√£o diretamente edit√°veis. </p><br><h3 id="lokalnye-peremennye-ne-mogut-byt-smodelirovany-s-ispolzovaniem-ssylok">  Vari√°veis ‚Äã‚Äãlocais n√£o podem ser modeladas usando refer√™ncias </h3><br><p>  Esse fen√¥meno ocorre porque os links n√£o s√£o t√£o expressivos quanto as vari√°veis ‚Äã‚Äãlocais.  Em geral, isso impede a abstra√ß√£o.  Deixe-me dar alguns exemplos para explicar o que quero dizer.  Imagine que eu tenho uma estrutura de ambiente que armazena um ponteiro para um contador de erros: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span></span> { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Agora eu posso criar inst√¢ncias dessa estrutura (e us√°-las): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  OK, agora imagine que eu quero separar o c√≥digo que modifica <code>env.errors</code> em uma fun√ß√£o separada.  Eu poderia pensar que, como a vari√°vel <code>env</code> n√£o √© declarada como mut√°vel, posso usar o imut√°vel <code>&amp;</code> link: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;env); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(env: &amp;Env) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><p>  Mas isso n√£o √© verdade.  O problema √© que <code>&amp;Env</code> √© um tipo de propriedade compartilhada ( <em>nota do tradutor: como voc√™ sabe, mais de uma refer√™ncia imut√°vel de objeto pode existir por vez</em> ) e, portanto, <code>env.errors</code> aparece em um espa√ßo que permite a propriedade separada do objeto <code>env</code> .  Para que esse c√≥digo funcione, devo declarar <code>env</code> como mut√°vel e usar o link <code>&amp;mut</code> ( <em>nota do tradutor: <code>&amp;mut</code> ) para informar ao compilador que <code>env</code> √© √∫nico em propriedade, pois apenas uma refer√™ncia a objeto mut√°vel pode existir por vez e a corrida de dados √© exclu√≠da, mas <code>mut</code> porque voc√™ n√£o pode criar uma refer√™ncia mut√°vel para um objeto imut√°vel</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env);</code> </pre> <br><p>  Esse problema surge porque sabemos que as vari√°veis ‚Äã‚Äãlocais s√£o √∫nicas, mas n√£o podemos colocar esse conhecimento em uma refer√™ncia emprestada sem torn√°-lo mut√°vel. </p><br><p>  Esse problema ocorre em v√°rios outros lugares.  At√© agora, escrevemos sobre isso de maneiras diferentes, mas continuo sendo assombrado pelo sentimento de que estamos falando de uma pausa, o que simplesmente n√£o deveria ser. </p><br><h3 id="proverka-tipov-primenitelno-k-zamykaniyam">  Verifica√ß√£o de tipo para fechamentos </h3><br><p>  Tivemos que contornar essa limita√ß√£o no caso de fechamentos.  Os fechamentos <em>s√£o</em> abertos <em>principalmente</em> em estruturas como <code>Env</code> , mas n√£o completamente.  Isso ocorre porque eu n√£o quero exigir que vari√°veis ‚Äã‚Äãlocais sejam declaradas <code>mut</code> se forem usadas via <code>&amp;mut</code> em um fechamento.  Em outras palavras, pegue algum c√≥digo, por exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { do_something(|| *errors += <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  Uma express√£o que descreve o fechamento criar√° realmente uma inst√¢ncia da estrutura <code>Env</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClosureEnv</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt; { errors: &amp;uniq &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Confira o link <code>&amp;uniq</code> .  Isso n√£o √© algo que o usu√°rio final possa inserir.  Significa um ponteiro "√∫nico, mas n√£o necessariamente mut√°vel".  Isso √© necess√°rio para passar na verifica√ß√£o de tipo.  Se o usu√°rio tentasse escrever essa estrutura manualmente, ele teria que escrever <code>&amp;mut &amp;mut usize</code> , o que exigiria que o par√¢metro de <code>errors</code> fosse declarado como <code>mut errors: &amp;mut usize</code> . </p><br><h3 id="nezapakovannye-zamykaniya-i-procedury">  Fechamentos e procedimentos n√£o embalados </h3><br><p>  Prevejo que essa restri√ß√£o √© um problema para fechamentos descompactados.  Deixe-me elaborar o design que eu estava considerando.  Basicamente, a ideia era que a express√£o <code>||</code>  √© equivalente a algum novo tipo estrutural que implementa uma das caracter√≠sticas <code>Fn</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnMut</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnOnce</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); }</code> </pre> <br><p>  O tipo exato ser√° selecionado de acordo com o tipo esperado, a partir de hoje.  Nesse caso, os consumidores de fechamentos podem escrever uma de duas coisas: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: T) { ... }</code> </pre> <br><p>  N√≥s ... provavelmente queremos corrigir a sintaxe, talvez adicione a√ß√∫car como <code>FnMut(usize) -&gt; usize</code> ou salve | usize |  -&gt; usize etc.  N√£o √© t√£o importante, √© importante que aprovemos o fechamento <em>por valor</em> .  Observe que, de acordo com as regras atuais do DST (tipos de tamanho din√¢mico), √© permitido passar um tipo por valor como argumento para a <code>FnMut&lt;usize, usize&gt;</code> , portanto, o argumento <code>FnMut&lt;usize, usize&gt;</code> √© um DST v√°lido e n√£o √© um problema. </p><br><p>  <em>Al√©m</em> : este projeto n√£o est√° completo e descreverei todos os detalhes em uma mensagem separada. </p><br><p>  O problema √© que um link <code>&amp;mut</code> √© necess√°rio para encerrar.  Como o fechamento √© passado por valor, os usu√°rios novamente ter√£o que escrever <code>mut</code> onde parecer fora de lugar: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Esse √© o mesmo problema do exemplo <code>Env</code> acima: o que <em>realmente</em> acontece aqui √© que a <code>FnMut</code> do <code>FnMut</code> deseja apenas um link <em>exclusivo</em> , mas como n√£o faz parte do sistema de tipos, solicita um link <em>mut√°vel</em> . </p><br><p>  Agora talvez possamos contornar isso de maneiras diferentes.  Uma op√ß√£o que poder√≠amos fazer √© <code>||</code>  a sintaxe n√£o se expandiria para um "certo tipo estrutural", mas para um "tipo estrutural ou um ponteiro para um tipo estrutural, conforme ditado pela infer√™ncia de tipo".  Nesse caso, o chamador pode escrever: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Eu n√£o quero dizer que este √© o fim do mundo.  Mas este √© outro passo adiante nas crescentes distor√ß√µes pelas quais devemos passar para manter essa lacuna entre vari√°veis ‚Äã‚Äãe refer√™ncias locais. </p><br><h3 id="drugie-chasti-api">  Outras pe√ßas da API </h3><br><p>  N√£o fiz um estudo exaustivo, mas, √© claro, essa diferen√ßa aparece em outro lugar.  Por exemplo, para ler no <code>Socket</code> , preciso de um ponteiro exclusivo, portanto, devo declarar que √© mut√°vel.  Portanto, √†s vezes isso n√£o funciona: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = Socket::new(); socket.read() <span class="hljs-comment"><span class="hljs-comment">// :   </span></span></code> </pre> <br><p>  Naturalmente, de acordo com minha sugest√£o, esse c√≥digo funcionaria bem.  Voc√™ ainda receberia uma mensagem de erro se tentasse ler do <code>&amp;Socket</code> , mas seria exibido algo como "√© imposs√≠vel criar um link exclusivo para um link compartilhado", que eu pessoalmente considero mais compreens√≠vel. </p><br><h2 id="no-razve-nam-ne-nuzhen-mut-dlya-bezopasnosti">  Mas n√£o precisamos de <code>mut</code> por seguran√ßa? </h2><br><p>  N√£o, n√£o mesmo.  Os programas de ferrugem seriam igualmente bons se voc√™ declarasse todas as liga√ß√µes como <code>mut</code> .  O compilador √© perfeitamente capaz de rastrear quais vari√°veis ‚Äã‚Äãlocais est√£o sendo alteradas a qualquer momento - precisamente porque elas s√£o <em>locais</em> para a fun√ß√£o atual.  O que o sistema de tipos realmente se importa √© a singularidade. </p><br><p>  O significado que vejo nas atuais regras de aplica√ß√£o do <code>mut</code> , e n√£o negarei que tenha valor, √© principalmente o fato de ajudarem a declarar a inten√ß√£o.  Ou seja, quando leio o c√≥digo, sei quais vari√°veis ‚Äã‚Äãpodem ser reatribu√≠das.  Por outro lado, tamb√©m passo muito tempo lendo o c√≥digo C ++ e, francamente, nunca percebi que esse √© um grande obst√°culo.  (O mesmo vale para o tempo que passei lendo c√≥digo em Java, JavaScript, Python ou Ruby.) </p><br><p>  Tamb√©m √© verdade que √†s vezes encontro bugs porque declarei a vari√°vel como <code>mut</code> e esqueci de alter√°-la.  Penso que poder√≠amos obter benef√≠cios semelhantes com outras verifica√ß√µes mais agressivas (por exemplo, nenhuma das vari√°veis ‚Äã‚Äãusadas na condi√ß√£o do loop muda no corpo do loop).  Pessoalmente, n√£o me lembro de me deparar com a situa√ß√£o oposta: ou seja, se o compilador diz que algo deve ser mut√°vel, basicamente significa sempre que eu esqueci a palavra-chave <code>mut</code> algum lugar.  (Pense: quando foi a √∫ltima vez que voc√™ respondeu a um erro do compilador sobre uma altera√ß√£o inv√°lida, fazendo algo diferente de reestruturar o c√≥digo para validar a altera√ß√£o?) </p><br><h2 id="alternativy">  Alternativas </h2><br><p>  Eu vejo tr√™s alternativas ao sistema atual: </p><br><ol><li>  O que eu apresentei onde voc√™ simplesmente joga fora a ‚Äúmutabilidade‚Äù e rastreia apenas a singularidade. </li><li>  Um em que voc√™ tem tr√™s tipos de refer√™ncia: <code>&amp;</code> , <code>&amp;uniq</code> e <code>&amp;mut</code> .  (Como escrevi, esse √© realmente o sistema de tipos que temos hoje, pelo menos do ponto de vista de um verificador de empr√©stimos). </li><li><p>  Uma op√ß√£o mais rigorosa, na qual vari√°veis ‚Äã‚Äãn√£o mut s√£o sempre consideradas separadas.  Isso significaria que voc√™ teria que escrever: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors; <span class="hljs-comment"><span class="hljs-comment">// ,  `p`   ,  `mut`. *p += 1;</span></span></code> </pre> <br><p>  Voc√™ precisa declarar <code>p</code> como <code>mut</code> , porque, caso contr√°rio, a vari√°vel seria considerada separada, mesmo que seja uma vari√°vel local e, portanto, a altera√ß√£o <code>*p</code> n√£o <code>*p</code> permitida.  O que √© estranho nesse esquema √© que a vari√°vel local N√ÉO permite propriedade separada e sabemos com certeza, porque quando voc√™ tenta criar seu alias, ele se move, o destruidor inicia nela, etc.  Ou seja, ainda temos o conceito de "propriedade", que √© diferente de "n√£o permite propriedade separada". </p><br><p>  Por outro lado, se descrevemos esse sistema, dizendo que a mutabilidade √© herdada por meio de ponteiros <code>&amp;mut</code> , sem sequer gaguejar sobre propriedade compartilhada, isso pode fazer sentido. </p><br></li></ol><br><p>  Destes tr√™s, eu definitivamente prefiro o n√∫mero 1.  √â o mais simples, e agora estou mais interessado em como podemos simplificar o Rust preservando seu car√°ter.  Caso contr√°rio, dou prefer√™ncia √† que temos agora. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Basicamente, acho que as regras atuais sobre mutabilidade t√™m algum valor, mas s√£o caras.  Eles s√£o uma esp√©cie de abstra√ß√£o fluida: isto √©, eles contam uma hist√≥ria simples, que de fato se mostra incompleta.  Isso leva √† confus√£o quando as pessoas passam de um entendimento inicial, no qual o <code>&amp;mut</code> reflete como a mutabilidade funciona, para um entendimento completo: algumas vezes, <code>mut</code> necess√°rio apenas para garantir a exclusividade e outras, sem a palavra-chave <code>mut</code> . </p><br><p>  Al√©m disso, devemos agir com cautela para manter a fic√ß√£o, que <code>mut</code> denota mutabilidade, n√£o singularidade.  Adicionamos casos especiais para o mutu√°rio verificar os fechamentos.  Devemos tornar as regras sobre mutabilidade mut√°vel mais complexas em geral.  Devemos adicionar <code>mut</code> aos fechamentos para poder cham√°-los ou abrir a sintaxe dos fechamentos de uma maneira menos √≥bvia.  E assim por diante </p><br><p>  No final, tudo se transforma em uma linguagem mais complexa como um todo.  Em vez de apenas pensar em propriedade compartilhada e singularidade, o usu√°rio deve pensar em propriedade compartilhada e mutabilidade, e os dois est√£o de alguma forma confusos. </p><br><p>  Eu n√£o acho que vale a pena. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418735/">https://habr.com/ru/post/pt418735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418723/index.html">Patch AndroidX</a></li>
<li><a href="../pt418725/index.html">Constante m√°gica</a></li>
<li><a href="../pt418727/index.html">Onde e como participar de incorpora√ß√µes gr√°ficas</a></li>
<li><a href="../pt418729/index.html">Tudo o que voc√™ solicita h√° muito tempo em um release - CLion 2018.2</a></li>
<li><a href="../pt418733/index.html">Visualizar os coment√°rios dos canais do YouTube de comunidades touhou internacionais e locais</a></li>
<li><a href="../pt418737/index.html">Abla√ß√£o a laser, vidro telurito e dopante Er2O3</a></li>
<li><a href="../pt418739/index.html">Centro de tecnologia aditiva: Impressoras 3D industriais Sistemas 3D, Stratasys, SLM, EOS</a></li>
<li><a href="../pt418741/index.html">Adicione criptografia e envie para SIP regular</a></li>
<li><a href="../pt418743/index.html">Hist√≥ria do Primeiro Lugar no ML Boot Camp VI</a></li>
<li><a href="../pt418747/index.html">Solu√ß√£o de problemas: como efetivamente resolver problemas em equipe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>