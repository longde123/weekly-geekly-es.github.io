<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 👼🏾 🚹 Foco na propriedade 🚥 🛀🏼 🗣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota tradutor: o registro é datado de 13 de maio de 2014, portanto, alguns detalhes, incluindo o código-fonte, podem não corresponder ao estado atual ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Foco na propriedade</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418735/"><p>  <em>Nota</em>  <em>tradutor: o registro é datado de 13 de maio de 2014, portanto, alguns detalhes, incluindo o código-fonte, podem não corresponder ao estado atual das coisas.</em>  <em>A resposta à pergunta por que a tradução de um post tão longo é necessária será o valor de seu conteúdo para formar um entendimento de um dos conceitos fundamentais da linguagem Rust, como fluência.</em> </p><br><p>  Com o tempo, fiquei convencido de que seria melhor abandonar a distinção entre variáveis ​​locais mutáveis ​​e imutáveis ​​no Rust.  Pelo menos muitas pessoas são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">céticas</a> sobre esse assunto.  Eu queria declarar minha posição em público.  Darei vários motivos: filosóficos, técnicos e práticos, além de me voltar para a principal defesa do sistema atual.  (Observação: eu vi isso como Rust RFC, mas decidi que o tom é melhor para uma postagem de blog e não tenho tempo para reescrevê-la agora.) </p><a name="habracut"></a><br><h2 id="poyasnenie">  Explicação </h2><br><p>  Escrevi este artigo de maneira bastante decisiva e acredito que a linha que estou defendendo estará correta.  No entanto, se não concluirmos o suporte ao sistema atual, isso não será um desastre ou algo assim.  Tem suas vantagens e, no geral, acho bastante agradável.  Eu apenas acho que podemos melhorá-lo. </p><br><h2 id="odnim-slovom">  Em uma palavra </h2><br><p> Gostaria de remover a distinção entre variáveis ​​locais imutáveis ​​e mutáveis ​​e renomear <code>&amp;mut</code> ponteiros para <code>&amp;my</code> , <code>&amp;only</code> ou <code>&amp;uniq</code> (isso não <code>&amp;uniq</code> diferença para mim).  Se ao menos não houvesse palavra-chave <code>mut</code> . </p><br><h2 id="filosofskiy-motiv">  Motivo filosófico </h2><br><p>  A principal razão pela qual desejo fazer isso é porque acredito que isso tornará a linguagem mais consistente e fácil de entender.  Essencialmente, isso nos reorientará de falar sobre <em>mutabilidade</em> para falar sobre o <em>uso de aliases</em> (que chamarei de "compartilhamento", veja abaixo). </p><br><p>  A variabilidade se torna uma conseqüência da singularidade: "Você sempre pode alterar tudo o que tem acesso exclusivo. Os dados compartilhados geralmente são imutáveis, mas se você precisar, pode alterá-los usando algum tipo de tipo de <code>Cell</code> ". </p><br><p>  Em outras palavras, com o tempo, ficou claro para mim que problemas com a corrida de dados e a segurança da memória surgem quando você tem o uso de aliases e mutabilidade.  Uma abordagem funcional para resolver esse problema é eliminar a mutabilidade.  A abordagem de Rust seria remover o uso de aliases.  Isso nos dá uma história que pode ser contada e que nos ajudará a descobrir. </p><br><p>  Uma observação sobre terminologia: acho que devemos nos referir ao <em>uso de aliases</em> como <em>separação</em> ( <em>nota do tradutor: daqui em diante, em todo lugar, em vez de "aliasing", é usado "sharing" no significado de "separação" ou "propriedade compartilhada", pois nenhum "uso de aliases", nenhuma "pseudonimização" dá uma compreensão do que está em jogo</em> ).  No passado, evitávamos isso devido às suas referências multiencadeadas.  No entanto, se / quando implementarmos os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">planos de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paralelização de dados</a> que propus, essa conotação não será totalmente inapropriada.  De fato, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dada a estreita relação</a> entre segurança de memória e corrida de dados, eu realmente quero promover essa conotação. </p><br><h2 id="obrazovatelnyy-motiv">  Motivo educacional </h2><br><p>  Eu acho que as regras atuais são mais difíceis de entender do que deveriam ser.  Não é óbvio, por exemplo, que o <code>&amp;mut T</code> não implica nenhuma propriedade compartilhada.  Além disso, a designação <code>&amp;mut T</code> implica que <code>&amp;T</code> não implica mutabilidade, que não é totalmente exata, devido a tipos como <code>Cell</code> .  E é impossível concordar sobre como chamá-los ("links mutáveis ​​/ imutáveis" é o mais comum, mas isso não está totalmente correto). </p><br><p>  Por outro lado, um tipo como <code>&amp;my T</code> ou <code>&amp;only T</code> parece simplificar a explicação.  Esse é um <em>link exclusivo</em> - naturalmente, você não pode forçar dois deles a apontar para o mesmo lugar.  E a <em>mutabilidade</em> é uma coisa ortogonal: vem da singularidade, mas também vale para as células.  E o tipo <code>&amp;T</code> é exatamente o oposto, um <em>link compartilhado</em> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O RFC PR # 58</a> fornece vários argumentos semelhantes.  Não vou repeti-los aqui. </p><br><h2 id="prakticheskiy-motiv">  Motivo prático </h2><br><p>  Atualmente, existe uma lacuna entre ponteiros emprestados, que podem ser compartilhados ou mutáveis ​​+ exclusivos e variáveis ​​locais que são sempre únicas, mas que podem ser mutáveis ​​ou imutáveis.  O resultado final disso é que os usuários devem postar anúncios <code>mut</code> sobre coisas que não são diretamente editáveis. </p><br><h3 id="lokalnye-peremennye-ne-mogut-byt-smodelirovany-s-ispolzovaniem-ssylok">  Variáveis ​​locais não podem ser modeladas usando referências </h3><br><p>  Esse fenômeno ocorre porque os links não são tão expressivos quanto as variáveis ​​locais.  Em geral, isso impede a abstração.  Deixe-me dar alguns exemplos para explicar o que quero dizer.  Imagine que eu tenho uma estrutura de ambiente que armazena um ponteiro para um contador de erros: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span></span> { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Agora eu posso criar instâncias dessa estrutura (e usá-las): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  OK, agora imagine que eu quero separar o código que modifica <code>env.errors</code> em uma função separada.  Eu poderia pensar que, como a variável <code>env</code> não é declarada como mutável, posso usar o imutável <code>&amp;</code> link: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;env); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(env: &amp;Env) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><p>  Mas isso não é verdade.  O problema é que <code>&amp;Env</code> é um tipo de propriedade compartilhada ( <em>nota do tradutor: como você sabe, mais de uma referência imutável de objeto pode existir por vez</em> ) e, portanto, <code>env.errors</code> aparece em um espaço que permite a propriedade separada do objeto <code>env</code> .  Para que esse código funcione, devo declarar <code>env</code> como mutável e usar o link <code>&amp;mut</code> ( <em>nota do tradutor: <code>&amp;mut</code> ) para informar ao compilador que <code>env</code> é único em propriedade, pois apenas uma referência a objeto mutável pode existir por vez e a corrida de dados é excluída, mas <code>mut</code> porque você não pode criar uma referência mutável para um objeto imutável</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env);</code> </pre> <br><p>  Esse problema surge porque sabemos que as variáveis ​​locais são únicas, mas não podemos colocar esse conhecimento em uma referência emprestada sem torná-lo mutável. </p><br><p>  Esse problema ocorre em vários outros lugares.  Até agora, escrevemos sobre isso de maneiras diferentes, mas continuo sendo assombrado pelo sentimento de que estamos falando de uma pausa, o que simplesmente não deveria ser. </p><br><h3 id="proverka-tipov-primenitelno-k-zamykaniyam">  Verificação de tipo para fechamentos </h3><br><p>  Tivemos que contornar essa limitação no caso de fechamentos.  Os fechamentos <em>são</em> abertos <em>principalmente</em> em estruturas como <code>Env</code> , mas não completamente.  Isso ocorre porque eu não quero exigir que variáveis ​​locais sejam declaradas <code>mut</code> se forem usadas via <code>&amp;mut</code> em um fechamento.  Em outras palavras, pegue algum código, por exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { do_something(|| *errors += <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  Uma expressão que descreve o fechamento criará realmente uma instância da estrutura <code>Env</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClosureEnv</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt; { errors: &amp;uniq &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Confira o link <code>&amp;uniq</code> .  Isso não é algo que o usuário final possa inserir.  Significa um ponteiro "único, mas não necessariamente mutável".  Isso é necessário para passar na verificação de tipo.  Se o usuário tentasse escrever essa estrutura manualmente, ele teria que escrever <code>&amp;mut &amp;mut usize</code> , o que exigiria que o parâmetro de <code>errors</code> fosse declarado como <code>mut errors: &amp;mut usize</code> . </p><br><h3 id="nezapakovannye-zamykaniya-i-procedury">  Fechamentos e procedimentos não embalados </h3><br><p>  Prevejo que essa restrição é um problema para fechamentos descompactados.  Deixe-me elaborar o design que eu estava considerando.  Basicamente, a ideia era que a expressão <code>||</code>  é equivalente a algum novo tipo estrutural que implementa uma das características <code>Fn</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnMut</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnOnce</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); }</code> </pre> <br><p>  O tipo exato será selecionado de acordo com o tipo esperado, a partir de hoje.  Nesse caso, os consumidores de fechamentos podem escrever uma de duas coisas: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: T) { ... }</code> </pre> <br><p>  Nós ... provavelmente queremos corrigir a sintaxe, talvez adicione açúcar como <code>FnMut(usize) -&gt; usize</code> ou salve | usize |  -&gt; usize etc.  Não é tão importante, é importante que aprovemos o fechamento <em>por valor</em> .  Observe que, de acordo com as regras atuais do DST (tipos de tamanho dinâmico), é permitido passar um tipo por valor como argumento para a <code>FnMut&lt;usize, usize&gt;</code> , portanto, o argumento <code>FnMut&lt;usize, usize&gt;</code> é um DST válido e não é um problema. </p><br><p>  <em>Além</em> : este projeto não está completo e descreverei todos os detalhes em uma mensagem separada. </p><br><p>  O problema é que um link <code>&amp;mut</code> é necessário para encerrar.  Como o fechamento é passado por valor, os usuários novamente terão que escrever <code>mut</code> onde parecer fora de lugar: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Esse é o mesmo problema do exemplo <code>Env</code> acima: o que <em>realmente</em> acontece aqui é que a <code>FnMut</code> do <code>FnMut</code> deseja apenas um link <em>exclusivo</em> , mas como não faz parte do sistema de tipos, solicita um link <em>mutável</em> . </p><br><p>  Agora talvez possamos contornar isso de maneiras diferentes.  Uma opção que poderíamos fazer é <code>||</code>  a sintaxe não se expandiria para um "certo tipo estrutural", mas para um "tipo estrutural ou um ponteiro para um tipo estrutural, conforme ditado pela inferência de tipo".  Nesse caso, o chamador pode escrever: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  Eu não quero dizer que este é o fim do mundo.  Mas este é outro passo adiante nas crescentes distorções pelas quais devemos passar para manter essa lacuna entre variáveis ​​e referências locais. </p><br><h3 id="drugie-chasti-api">  Outras peças da API </h3><br><p>  Não fiz um estudo exaustivo, mas, é claro, essa diferença aparece em outro lugar.  Por exemplo, para ler no <code>Socket</code> , preciso de um ponteiro exclusivo, portanto, devo declarar que é mutável.  Portanto, às vezes isso não funciona: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = Socket::new(); socket.read() <span class="hljs-comment"><span class="hljs-comment">// :   </span></span></code> </pre> <br><p>  Naturalmente, de acordo com minha sugestão, esse código funcionaria bem.  Você ainda receberia uma mensagem de erro se tentasse ler do <code>&amp;Socket</code> , mas seria exibido algo como "é impossível criar um link exclusivo para um link compartilhado", que eu pessoalmente considero mais compreensível. </p><br><h2 id="no-razve-nam-ne-nuzhen-mut-dlya-bezopasnosti">  Mas não precisamos de <code>mut</code> por segurança? </h2><br><p>  Não, não mesmo.  Os programas de ferrugem seriam igualmente bons se você declarasse todas as ligações como <code>mut</code> .  O compilador é perfeitamente capaz de rastrear quais variáveis ​​locais estão sendo alteradas a qualquer momento - precisamente porque elas são <em>locais</em> para a função atual.  O que o sistema de tipos realmente se importa é a singularidade. </p><br><p>  O significado que vejo nas atuais regras de aplicação do <code>mut</code> , e não negarei que tenha valor, é principalmente o fato de ajudarem a declarar a intenção.  Ou seja, quando leio o código, sei quais variáveis ​​podem ser reatribuídas.  Por outro lado, também passo muito tempo lendo o código C ++ e, francamente, nunca percebi que esse é um grande obstáculo.  (O mesmo vale para o tempo que passei lendo código em Java, JavaScript, Python ou Ruby.) </p><br><p>  Também é verdade que às vezes encontro bugs porque declarei a variável como <code>mut</code> e esqueci de alterá-la.  Penso que poderíamos obter benefícios semelhantes com outras verificações mais agressivas (por exemplo, nenhuma das variáveis ​​usadas na condição do loop muda no corpo do loop).  Pessoalmente, não me lembro de me deparar com a situação oposta: ou seja, se o compilador diz que algo deve ser mutável, basicamente significa sempre que eu esqueci a palavra-chave <code>mut</code> algum lugar.  (Pense: quando foi a última vez que você respondeu a um erro do compilador sobre uma alteração inválida, fazendo algo diferente de reestruturar o código para validar a alteração?) </p><br><h2 id="alternativy">  Alternativas </h2><br><p>  Eu vejo três alternativas ao sistema atual: </p><br><ol><li>  O que eu apresentei onde você simplesmente joga fora a “mutabilidade” e rastreia apenas a singularidade. </li><li>  Um em que você tem três tipos de referência: <code>&amp;</code> , <code>&amp;uniq</code> e <code>&amp;mut</code> .  (Como escrevi, esse é realmente o sistema de tipos que temos hoje, pelo menos do ponto de vista de um verificador de empréstimos). </li><li><p>  Uma opção mais rigorosa, na qual variáveis ​​não mut são sempre consideradas separadas.  Isso significaria que você teria que escrever: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors; <span class="hljs-comment"><span class="hljs-comment">// ,  `p`   ,  `mut`. *p += 1;</span></span></code> </pre> <br><p>  Você precisa declarar <code>p</code> como <code>mut</code> , porque, caso contrário, a variável seria considerada separada, mesmo que seja uma variável local e, portanto, a alteração <code>*p</code> não <code>*p</code> permitida.  O que é estranho nesse esquema é que a variável local NÃO permite propriedade separada e sabemos com certeza, porque quando você tenta criar seu alias, ele se move, o destruidor inicia nela, etc.  Ou seja, ainda temos o conceito de "propriedade", que é diferente de "não permite propriedade separada". </p><br><p>  Por outro lado, se descrevemos esse sistema, dizendo que a mutabilidade é herdada por meio de ponteiros <code>&amp;mut</code> , sem sequer gaguejar sobre propriedade compartilhada, isso pode fazer sentido. </p><br></li></ol><br><p>  Destes três, eu definitivamente prefiro o número 1.  É o mais simples, e agora estou mais interessado em como podemos simplificar o Rust preservando seu caráter.  Caso contrário, dou preferência à que temos agora. </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  Basicamente, acho que as regras atuais sobre mutabilidade têm algum valor, mas são caras.  Eles são uma espécie de abstração fluida: isto é, eles contam uma história simples, que de fato se mostra incompleta.  Isso leva à confusão quando as pessoas passam de um entendimento inicial, no qual o <code>&amp;mut</code> reflete como a mutabilidade funciona, para um entendimento completo: algumas vezes, <code>mut</code> necessário apenas para garantir a exclusividade e outras, sem a palavra-chave <code>mut</code> . </p><br><p>  Além disso, devemos agir com cautela para manter a ficção, que <code>mut</code> denota mutabilidade, não singularidade.  Adicionamos casos especiais para o mutuário verificar os fechamentos.  Devemos tornar as regras sobre mutabilidade mutável mais complexas em geral.  Devemos adicionar <code>mut</code> aos fechamentos para poder chamá-los ou abrir a sintaxe dos fechamentos de uma maneira menos óbvia.  E assim por diante </p><br><p>  No final, tudo se transforma em uma linguagem mais complexa como um todo.  Em vez de apenas pensar em propriedade compartilhada e singularidade, o usuário deve pensar em propriedade compartilhada e mutabilidade, e os dois estão de alguma forma confusos. </p><br><p>  Eu não acho que vale a pena. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418735/">https://habr.com/ru/post/pt418735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418723/index.html">Patch AndroidX</a></li>
<li><a href="../pt418725/index.html">Constante mágica</a></li>
<li><a href="../pt418727/index.html">Onde e como participar de incorporações gráficas</a></li>
<li><a href="../pt418729/index.html">Tudo o que você solicita há muito tempo em um release - CLion 2018.2</a></li>
<li><a href="../pt418733/index.html">Visualizar os comentários dos canais do YouTube de comunidades touhou internacionais e locais</a></li>
<li><a href="../pt418737/index.html">Ablação a laser, vidro telurito e dopante Er2O3</a></li>
<li><a href="../pt418739/index.html">Centro de tecnologia aditiva: Impressoras 3D industriais Sistemas 3D, Stratasys, SLM, EOS</a></li>
<li><a href="../pt418741/index.html">Adicione criptografia e envie para SIP regular</a></li>
<li><a href="../pt418743/index.html">História do Primeiro Lugar no ML Boot Camp VI</a></li>
<li><a href="../pt418747/index.html">Solução de problemas: como efetivamente resolver problemas em equipe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>