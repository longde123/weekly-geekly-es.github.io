<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëñ ü•î üêã MVCC-1. Isolamento üôåüèΩ ü§ôüèº üôåüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Com este artigo, inicio uma s√©rie de loops (ou um loop de s√©ries? Em geral, uma √≥tima id√©ia) sobre a estrutura interna do PostgreSQL. 

 O m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-1. Isolamento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442804/">  Ol√° Habr!  Com este artigo, inicio uma s√©rie de loops (ou um loop de s√©ries? Em geral, uma √≥tima id√©ia) sobre a estrutura interna do PostgreSQL. <br><br>  O material ser√° baseado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cursos de treinamento</a> em administra√ß√£o que realizamos com Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">pluzanov</a> .  Nem todo mundo gosta de assistir a um v√≠deo (eu definitivamente n√£o gosto), mas ler slides, mesmo com coment√°rios, √© completamente "errado". <br><br>  Obviamente, os artigos n√£o repetir√£o o conte√∫do dos cursos individualmente.  Falarei apenas sobre como tudo est√° organizado, omitindo a administra√ß√£o real, mas tentarei fazer isso com mais detalhes e em detalhes.  E acredito que esse conhecimento √© √∫til para o desenvolvedor do aplicativo, n√£o menos que o administrador. <br><br>  Vou me concentrar naqueles que j√° t√™m alguma experi√™ncia com o PostgreSQL e, pelo menos em termos gerais, imaginam o que est√° acontecendo.  Para iniciantes, o texto ser√° um pouco pesado.  Por exemplo, n√£o direi uma palavra sobre como instalar o PostgreSQL e executar o psql. <br><br>  As coisas que ser√£o discutidas n√£o mudam muito de vers√£o para vers√£o, mas usarei o atual 11¬∫ PostgreSQL ‚Äúvanilla‚Äù. <br><br>  O primeiro ciclo √© dedicado a quest√µes relacionadas ao isolamento e √† multivers√£o, e seu plano √© o seguinte: <br><br><ol><li>  Isolamento, como entendido pelo padr√£o e PostgreSQL (este artigo); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camadas, arquivos, p√°ginas</a> - o que est√° acontecendo no n√≠vel f√≠sico; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vers√µes de linha, transa√ß√µes virtuais e aninhadas</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instant√¢neos de dados e visibilidade de vers√µes de linha, horizonte de eventos</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limpeza na p√°gina e atualiza√ß√µes HOT</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limpeza normal</a> (v√°cuo); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limpeza autom√°tica</a> (autovacuum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O contador de transa√ß√µes transborda e congela</a> . </li></ol><br>  Bem, vamos l√°. <br><a name="habracut"></a><br><h1>  O que √© isolamento e por que √© importante? </h1><br>  Provavelmente todo mundo pelo menos conhece a exist√™ncia de transa√ß√µes, conheceu o acr√¥nimo ACID e ouviu falar sobre os n√≠veis de isolamento.  Mas ainda √© preciso encontrar a opini√£o de que essa √© uma teoria que n√£o √© necess√°ria na pr√°tica.  Portanto, passarei algum tempo tentando explicar por que isso √© realmente importante. <br><br>  √â improv√°vel que voc√™ fique satisfeito se o aplicativo receber dados incorretos do banco de dados ou se o aplicativo gravar dados incorretos no banco de dados. <br><br>  Mas o que s√£o dados "corretos"?  √â sabido que, no n√≠vel do banco de dados, voc√™ pode criar restri√ß√µes de integridade (como NOT NULL ou UNIQUE).  Se os dados sempre satisfizerem as restri√ß√µes de integridade (e isso ocorre porque o DBMS garante isso), elas s√£o hol√≠sticas. <br><br>  <em>S√£o corretos</em> e <em>integrais</em> - a mesma coisa?  Na verdade n√£o.  Nem todas as restri√ß√µes podem ser formuladas no n√≠vel do banco de dados.  Parte das restri√ß√µes √© muito complicada, por exemplo, abrange v√°rias tabelas ao mesmo tempo.  E mesmo que a restri√ß√£o, em princ√≠pio, possa ser definida no banco de dados, mas por alguma raz√£o n√£o, isso n√£o significa que possa ser violada. <br><br>  Portanto, a <em>corre√ß√£o √©</em> mais rigorosa que a <em>integridade</em> , mas n√£o sabemos exatamente o que √©.  Resta reconhecer que o padr√£o de corre√ß√£o √© um aplicativo que, como queremos acreditar, foi escrito <em>corretamente</em> e nunca se engana.  De qualquer forma, se o aplicativo n√£o violar a integridade, mas violar a corre√ß√£o, o DBMS n√£o o saber√° e n√£o pegar√° sua m√£o. <br><br>  A partir de agora, chamaremos de corre√ß√£o o termo consist√™ncia. <br><br>  Vamos supor, no entanto, que o aplicativo execute apenas a sequ√™ncia correta de instru√ß√µes.  Qual √© o papel do DBMS, se o aplicativo estiver correto? <br><br>  Em primeiro lugar, verifica-se que uma sequ√™ncia correta de instru√ß√µes pode interromper temporariamente a consist√™ncia dos dados, e isso - por incr√≠vel que pare√ßa - √© normal.  Um exemplo banal, mas compreens√≠vel, √© transferir fundos de uma conta para outra.  A regra de consist√™ncia pode parecer assim: uma <em>transfer√™ncia nunca altera a quantidade total de dinheiro nas contas</em> (√© muito dif√≠cil escrever no SQL como uma restri√ß√£o de integridade, portanto, existe no n√≠vel do aplicativo e √© invis√≠vel para o DBMS).  Uma transfer√™ncia consiste em duas opera√ß√µes: a primeira reduz fundos em uma conta, a segunda - aumenta em outra.  A primeira opera√ß√£o viola a consist√™ncia dos dados, a segunda - restaura. <br><br><blockquote>  Um bom exerc√≠cio √© implementar a regra descrita acima no n√≠vel de restri√ß√µes de integridade.  Voc√™ √© fraco?  ¬© <br></blockquote><br>  E se a primeira opera√ß√£o for conclu√≠da e a segunda n√£o?  Afinal, √© f√°cil: durante a segunda opera√ß√£o, a eletricidade pode ser perdida, o servidor pode cair, a divis√£o por zero pode ocorrer - mas voc√™ nunca sabe.  √â claro que a consist√™ncia est√° sendo violada e isso n√£o deve ser permitido.  Em princ√≠pio, √© poss√≠vel resolver essas situa√ß√µes no n√≠vel da aplica√ß√£o ao custo de esfor√ßos incr√≠veis, mas, felizmente, n√£o √© necess√°rio: o DBMS cuida disso.  Mas, para isso, ela deve saber que duas opera√ß√µes constituem um todo indivis√≠vel.  Isso √© uma <em>transa√ß√£o</em> . <br><br>  Parece interessante: sabendo que as opera√ß√µes constituem uma transa√ß√£o, o DBMS ajuda a manter a consist√™ncia, garantindo a atomicidade das transa√ß√µes, sem saber nada sobre regras espec√≠ficas de consist√™ncia. <br><br>  Mas h√° um segundo ponto, mais sutil.  Assim que v√°rias transa√ß√µes simult√¢neas aparecem no sistema absolutamente corretas, uma a uma, juntas elas podem funcionar incorretamente.  Isso se deve ao fato de a ordem das opera√ß√µes ser mista: n√£o se pode presumir que todas as opera√ß√µes de uma transa√ß√£o sejam executadas primeiro e somente ent√£o todas as opera√ß√µes de outra. <br><br>  Uma observa√ß√£o sobre simultaneidade.  De fato, ao mesmo tempo, as transa√ß√µes podem funcionar em um sistema com um processador multin√∫cleo, com uma matriz de disco etc. Mas todas as mesmas considera√ß√µes s√£o verdadeiras para um servidor que executa comandos sequencialmente, no modo de compartilhamento de tempo: tantos ciclos, uma transa√ß√£o √© executada, tantos ciclos s√£o diferentes .  √Äs vezes, o termo execu√ß√£o <em>competitiva</em> √© usado para resumir. <br><br>  Situa√ß√µes em que transa√ß√µes corretas n√£o funcionam juntas corretamente s√£o chamadas <em>anomalias de</em> execu√ß√£o simult√¢nea. <br><br>  Um exemplo simples: se um aplicativo deseja obter os dados corretos do banco de dados, pelo menos ele n√£o deve ver altera√ß√µes em outras transa√ß√µes n√£o confirmadas.  Caso contr√°rio, voc√™ poder√° n√£o apenas obter dados inconsistentes, mas tamb√©m ver algo que nunca esteve no banco de dados (se a transa√ß√£o for cancelada).  Essa anomalia √© chamada de <em>leitura suja</em> . <br><br>  Se houver outras anomalias mais complexas, com as quais trataremos um pouco mais tarde. <br><br>  Obviamente, √© imposs√≠vel recusar a execu√ß√£o simult√¢nea: caso contr√°rio, que tipo de desempenho pode ser discutido?  Mas voc√™ n√£o pode trabalhar com dados incorretos. <br><br>  E novamente o DBMS vem em socorro.  Voc√™ pode executar transa√ß√µes <em>como se fossem</em> seq√ºencialmente, <em>como se</em> uma ap√≥s a outra.  Em outras palavras, <em>isoladamente</em> um do outro.  Na realidade, o DBMS pode executar opera√ß√µes misturadas, mas ao mesmo tempo garantir que o resultado da execu√ß√£o simult√¢nea coincida com o resultado de qualquer uma das poss√≠veis execu√ß√µes sequenciais.  E isso elimina quaisquer poss√≠veis anomalias. <br><br>  Ent√£o, chegamos √† defini√ß√£o: <br><br><blockquote>  Uma transa√ß√£o √© o conjunto de opera√ß√µes executadas por um aplicativo que transfere o banco de dados de um estado correto para outro estado correto (consist√™ncia), desde que a transa√ß√£o seja conclu√≠da (atomicidade) e sem interfer√™ncia de outras transa√ß√µes (isolamento). <br></blockquote><br>  Esta defini√ß√£o combina as tr√™s primeiras letras do acr√¥nimo ACID.  Eles est√£o t√£o intimamente relacionados entre si que simplesmente n√£o faz sentido considerar um sem o outro.  De fato, √© dif√≠cil destacar a letra D (durabilidade).  Afinal, no caso de uma falha no sistema, permanecem altera√ß√µes nas transa√ß√µes n√£o confirmadas, com as quais voc√™ precisa fazer algo para restaurar a consist√™ncia dos dados. <br><br>  Tudo ficaria bem, mas a implementa√ß√£o do isolamento completo √© uma tarefa tecnicamente dif√≠cil, juntamente com uma diminui√ß√£o na taxa de transfer√™ncia do sistema.  Portanto, na pr√°tica, muitas vezes (nem sempre, mas quase sempre) o isolamento enfraquecido √© aplicado, o que impede algumas, mas n√£o todas, anomalias.  E isso significa que parte do trabalho para garantir a corre√ß√£o dos dados recai sobre o aplicativo.  √â por isso que √© muito importante entender qual n√≠vel de isolamento √© usado no sistema, quais garantias ele oferece e quais n√£o e como escrever o c√≥digo correto nessas condi√ß√µes. <br><br><h1>  N√≠veis e anomalias de isolamento de SQL </h1><br>  O padr√£o SQL h√° muito descreveu quatro n√≠veis de isolamento.  Esses n√≠veis s√£o determinados listando as anomalias que s√£o permitidas ou n√£o durante a execu√ß√£o de transa√ß√µes nesse n√≠vel.  Portanto, para falar sobre esses n√≠veis, voc√™ precisa se familiarizar com as anomalias. <br><br>  Enfatizo que nesta parte estamos falando sobre o padr√£o, isto √©, sobre uma certa teoria sobre a qual a pr√°tica depende muito, mas que ao mesmo tempo est√° em desacordo.  Portanto, todos os exemplos aqui s√£o especulativos.  Eles usar√£o as mesmas opera√ß√µes nas contas dos clientes: isso √© bastante √≥bvio, embora, reconhecidamente, n√£o tenha nada a ver com a forma como as opera√ß√µes banc√°rias s√£o realmente organizadas. <br><br><h2>  Atualiza√ß√£o perdida </h2><br>  Vamos come√ßar com a <em>atualiza√ß√£o perdida</em> .  Essa anomalia ocorre quando duas transa√ß√µes l√™em a mesma linha na tabela, uma transa√ß√£o atualiza essa linha e, depois disso, a segunda transa√ß√£o tamb√©m atualiza a mesma linha, sem levar em conta as altera√ß√µes feitas pela primeira transa√ß√£o. <br><br>  Por exemplo, duas transa√ß√µes aumentar√£o o valor na mesma conta em 100 ‚ÇΩ.  A primeira transa√ß√£o l√™ o valor atual (1000 ‚ÇΩ), depois a segunda transa√ß√£o l√™ o mesmo valor.  A primeira transa√ß√£o aumenta a quantidade (resulta em 1100 ‚ÇΩ) e grava esse valor.  A segunda transa√ß√£o faz o mesmo - obt√©m os mesmos 1.100 ‚ÇΩ e os grava.  Como resultado, o cliente perdeu 100 ‚ÇΩ. <br><br>  As atualiza√ß√µes perdidas n√£o s√£o permitidas pelo padr√£o em nenhum n√≠vel de isolamento. <br><br><h2>  Leitura e leitura sujas n√£o confirmadas </h2><br>  Com a <em>leitura suja</em> , j√° nos encontramos acima.  Essa anomalia ocorre quando uma transa√ß√£o l√™ as altera√ß√µes pendentes feitas por outra transa√ß√£o. <br><br>  Por exemplo, a primeira transa√ß√£o transfere todo o dinheiro da conta do cliente para outra conta, mas n√£o registra a altera√ß√£o.  Outra transa√ß√£o l√™ o status da conta, recebe 0 ‚ÇΩ e se recusa a emitir dinheiro para o cliente - apesar do fato de a primeira transa√ß√£o ser interrompida e cancelar suas altera√ß√µes, para que o valor 0 nunca exista no banco de dados. <br><br>  A leitura suja √© permitida pelo padr√£o no n√≠vel Read Uncommitted. <br><br><h2>  Leitura n√£o repetida e leitura confirmada </h2><br>  A anomalia de <em>leitura sem repeti√ß√£o</em> ocorre quando uma transa√ß√£o l√™ a mesma linha duas vezes e, no intervalo entre as leituras, a segunda transa√ß√£o altera (ou exclui) essa linha e confirma as altera√ß√µes.  Em seguida, a primeira transa√ß√£o obter√° resultados diferentes. <br><br>  Por exemplo, permita que a regra de consist√™ncia <em>pro√≠ba montantes negativos nas contas dos clientes</em> .  A primeira transa√ß√£o reduzir√° o valor na conta em 100 ‚ÇΩ.  Ela verifica o valor atual, recebe 1000 ‚ÇΩ e decide que √© poss√≠vel uma redu√ß√£o.  No momento, a segunda transa√ß√£o reduz o valor da conta para zero e registra as altera√ß√µes.  Se agora a primeira transa√ß√£o verificar novamente o valor, ela receber√° 0 ‚ÇΩ (mas ela j√° havia decidido diminuir o valor e a conta "vai para menos"). <br><br>  A leitura n√£o repetida √© permitida pelo padr√£o nos n√≠veis Read Uncommitted e Read Committed.  Mas a leitura suja de Read Committed n√£o permite. <br><br><h2>  Leitura fantasma e leitura repetida </h2><br>  <em>A leitura fantasma</em> ocorre quando uma transa√ß√£o l√™ um conjunto de linhas duas vezes sob a mesma condi√ß√£o e, no intervalo entre as leituras, a segunda transa√ß√£o adiciona linhas que satisfazem essa condi√ß√£o (e confirma as altera√ß√µes).  Em seguida, a primeira transa√ß√£o receber√° diferentes conjuntos de linhas. <br><br>  Por exemplo, suponha que uma regra de consist√™ncia <em>pro√≠ba um cliente de ter mais de 3 contas</em> .  A primeira transa√ß√£o vai abrir uma nova conta, verifica seu n√∫mero atual (digamos, 2) e decide que a abertura √© poss√≠vel.  No momento, a segunda transa√ß√£o tamb√©m abre uma nova conta para o cliente e registra as altera√ß√µes.  Se agora a primeira transa√ß√£o verificar novamente a quantidade, ela receber√° 3 (mas j√° est√° abrindo outra conta e o cliente tem 4). <br><br>  A leitura fantasma √© permitida pelo padr√£o nos n√≠veis de leitura n√£o confirmada, leitura confirmada e leitura repetida.  Por√©m, no n√≠vel de leitura repetida, a leitura n√£o repetida n√£o √© permitida. <br><br><h2>  Falta de Anomalias e Serializ√°veis </h2><br>  O padr√£o define outro n√≠vel - serializ√°vel - no qual nenhuma anomalia √© permitida.  E isso n√£o √© o mesmo que proibir uma atualiza√ß√£o perdida e uma leitura suja, n√£o repetitiva e fantasma. <br><br>  O fato √© que existem anomalias significativamente mais conhecidas do que aquelas listadas no padr√£o, e um n√∫mero desconhecido ainda √© desconhecido. <br><br>  Serializable deve evitar <em>todas as</em> anormalidades <em>em geral</em> .  Isso significa que, nesse n√≠vel, o desenvolvedor de aplicativos n√£o precisa pensar em executar simultaneamente.  Se as transa√ß√µes executarem as seq√º√™ncias corretas de instru√ß√µes, trabalhando sozinhas, os dados ser√£o consistentes com a opera√ß√£o simult√¢nea dessas transa√ß√µes. <br><br><h2>  Placa de resumo </h2><br>  Agora voc√™ pode trazer uma tabela conhecida para todos.  Mas aqui, para maior clareza, a √∫ltima coluna √© adicionada a ela, que n√£o est√° no padr√£o. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  mudan√ßas perdidas </th><th>  leitura suja </th><th>  leitura sem repeti√ß√£o </th><th>  leitura fantasma </th><th>  outras anomalias </th></tr><tr><th>  Leitura n√£o confirmada </th><th>  - </th><th>  sim </th><th>  sim </th><th>  sim </th><th>  sim </th></tr><tr><th>  Leitura confirmada </th><th>  - </th><th>  - </th><th>  sim </th><th>  sim </th><th>  sim </th></tr><tr><th>  Leitura Repet√≠vel </th><th>  - </th><th>  - </th><th>  - </th><th>  sim </th><th>  sim </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  Por que exatamente essas anomalias? </h2><br>  Por que apenas algumas das muitas anomalias poss√≠veis no padr√£o s√£o listadas e por que s√£o? <br><br>  Aparentemente, ningu√©m parece saber disso com certeza.  Mas a pr√°tica aqui definitivamente superou a teoria, portanto, √© poss√≠vel que n√£o pens√°ssemos em outras anomalias (discurso sobre o padr√£o SQL: 92). <br><br>  Al√©m disso, assumiu-se que o isolamento deveria ser constru√≠do sobre intertravamentos.  A id√©ia do <em>protocolo de bloqueio de duas fases</em> (2PL) amplamente utilizado √© que, durante a transa√ß√£o, a transa√ß√£o bloqueia as linhas com as quais est√° trabalhando e, quando conclu√≠da, libera os bloqueios.  Simplificando bastante, quanto mais bloqueios uma transa√ß√£o captura, melhor √© isolada de outras transa√ß√µes.  Mas o desempenho do sistema sofre ainda mais, porque, em vez de trabalharem juntas, as transa√ß√µes come√ßam a se alinhar pelas mesmas linhas. <br><br>  Parece-me que a diferen√ßa entre os n√≠veis de isolamento do padr√£o √© explicada precisamente pelo n√∫mero de bloqueios necess√°rios. <br><br>  Se uma transa√ß√£o impedir que as linhas modificadas sejam alteradas, mas n√£o lidas, obtemos o n√≠vel Read Uncommitted: altera√ß√µes perdidas n√£o s√£o permitidas, mas dados n√£o confirmados podem ser lidos. <br><br>  Se a transa√ß√£o bloquear linhas mut√°veis ‚Äã‚Äãda leitura e da altera√ß√£o, obteremos o n√≠vel Read Committed: voc√™ n√£o poder√° ler dados n√£o confirmados, mas quando acessar a linha novamente, poder√° obter um valor diferente (leitura n√£o repetida). <br><br>  Se uma transa√ß√£o bloquear as linhas leg√≠veis e mut√°veis ‚Äã‚Äãda leitura e da altera√ß√£o, obteremos o n√≠vel de leitura repetida: a leitura repetida da linha produzir√° o mesmo valor. <br><br>  Mas h√° um problema com o Serializable: n√£o √© poss√≠vel bloquear uma linha que ainda n√£o existe.  Por esse motivo, a possibilidade de leitura fantasma permanece: outra transa√ß√£o pode adicionar (mas n√£o excluir) uma linha que se enquadre nas condi√ß√µes de uma consulta executada anteriormente e essa linha ser√° buscada novamente. <br><br>  Portanto, para implementar o n√≠vel de serializ√°vel, os bloqueios comuns n√£o s√£o suficientes - voc√™ precisa bloquear n√£o as linhas, mas as condi√ß√µes (predicados).  Esses bloqueios foram chamados de <em>predicado</em> .  Eles foram propostos em 1976, mas sua aplicabilidade pr√°tica √© limitada por condi√ß√µes bastante simples, para as quais √© claro como combinar dois predicados diferentes.  At√© onde eu sei, n√£o chegou √† implementa√ß√£o desses bloqueios em nenhum sistema. <br><br><h1>  N√≠veis de isolamento do PostgreSQL </h1><br>  Com o tempo, o isolamento de captura instant√¢nea substituiu os <em>protocolos de</em> gerenciamento de transa√ß√µes de bloqueio.  Sua id√©ia √© que cada transa√ß√£o funcione com um instant√¢neo consistente dos dados em um determinado momento, no qual apenas as altera√ß√µes que foram registradas antes da cria√ß√£o do instant√¢neo caem. <br><br>  Esse isolamento n√£o permite automaticamente leitura suja.  Formalmente, no PostgreSQL, voc√™ pode especificar o n√≠vel Read Uncommitted, mas ele funcionar√° exatamente como Read Committed.  Portanto, n√£o falaremos mais sobre o n√≠vel Read Uncommitted. <br><br>  O PostgreSQL implementa uma <em>multi-</em> vers√£o deste protocolo.  A id√©ia do multi-versioning √© que v√°rias vers√µes da mesma string podem coexistir em um DBMS.  Isso permite criar uma captura instant√¢nea dos dados usando as vers√µes dispon√≠veis e conviver com um m√≠nimo de bloqueios.  De fato, apenas altera√ß√µes repetidas na mesma linha s√£o bloqueadas.  Todas as outras opera√ß√µes s√£o executadas ao mesmo tempo: gravar transa√ß√µes nunca bloqueia transa√ß√µes de leitura e transa√ß√µes de leitura nunca bloqueiam ningu√©m. <br><br>  Usando snapshots de dados, o isolamento no PostgreSQL √© mais r√≠gido do que o padr√£o exige: o n√≠vel de leitura repetida n√£o permite n√£o apenas repeti√ß√µes, mas tamb√©m leituras fantasmas (embora n√£o forne√ßa isolamento completo).  E isso √© alcan√ßado sem perda de efic√°cia. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  mudan√ßas perdidas </th><th>  leitura suja </th><th>  leitura sem repeti√ß√£o </th><th>  leitura fantasma </th><th>  outras anomalias </th></tr><tr><th>  Leitura n√£o confirmada </th><th>  - </th><th>  - </th><th>  sim </th><th>  sim </th><th>  sim </th></tr><tr><th>  Leitura confirmada </th><th>  - </th><th>  - </th><th>  sim </th><th>  sim </th><th>  sim </th></tr><tr><th>  Leitura Repet√≠vel </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  sim </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  Como o multi-versioning √© implementado ‚Äúsob o cap√¥‚Äù, falaremos nos artigos a seguir e agora examinaremos detalhadamente cada um dos tr√™s n√≠veis atrav√©s dos olhos do usu√°rio (como voc√™ sabe, o mais interessante est√° oculto por tr√°s de ‚Äúoutras anomalias‚Äù).  Para fazer isso, crie um quadro de contas.  Alice e Bob t√™m US $ 1.000 cada, mas Bob tem duas contas abertas: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Leitura confirmada </h2><br><h3>  Falta de leitura suja </h3><br>  √â f√°cil verificar se os dados sujos n√£o podem ser lidos.  Vamos come√ßar a transa√ß√£o.  Por padr√£o, ele usar√° o n√≠vel de isolamento Read Committed: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Mais precisamente, o n√≠vel padr√£o √© definido pelo par√¢metro, podendo ser alterado se necess√°rio: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Portanto, em uma transa√ß√£o aberta, retiramos fundos da conta, mas n√£o registramos as altera√ß√µes.  A transa√ß√£o v√™ suas pr√≥prias altera√ß√µes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  Na segunda sess√£o, iniciamos outra transa√ß√£o com o mesmo n√≠vel Read Committed.  Para distinguir entre transa√ß√µes diferentes, os comandos da segunda transa√ß√£o ser√£o recuados e riscados. <br><br>  Para repetir os comandos acima (o que √© √∫til), voc√™ precisa abrir dois terminais e executar o psql em cada um.  No primeiro, voc√™ pode inserir os comandos de uma transa√ß√£o e no segundo - os comandos de outra. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Como esperado, outra transa√ß√£o n√£o v√™ altera√ß√µes n√£o confirmadas - a leitura suja n√£o √© permitida. <br><br><h3>  Leitura sem repeti√ß√£o </h3><br>  Agora deixe a primeira transa√ß√£o confirmar as altera√ß√µes e a segunda execute novamente a mesma solicita√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  A solicita√ß√£o j√° est√° recebendo novos dados - essa √© a anomalia da <em>leitura n√£o repetida</em> , que √© permitida no n√≠vel Read Committed. <br><br>  <em>Conclus√£o pr√°tica</em> : em uma transa√ß√£o, √© imposs√≠vel tomar decis√µes com base nos dados lidos pela instru√ß√£o anterior - porque tudo pode mudar entre os hor√°rios em que as instru√ß√µes s√£o executadas.  Aqui est√° um exemplo cujas varia√ß√µes s√£o t√£o comuns no c√≥digo do aplicativo que ele √© um antipadr√£o cl√°ssico: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Durante o tempo decorrido entre a verifica√ß√£o e a atualiza√ß√£o, outras transa√ß√µes podem alterar o estado da conta conforme desejado, para que esse ‚Äúcheque‚Äù n√£o salve nada.  √â conveniente imaginar que entre os operadores de uma transa√ß√£o quaisquer outros operadores de outras transa√ß√µes possam "cunhar", por exemplo, assim: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Se, reorganizando os operadores, voc√™ puder estragar tudo, o c√≥digo ser√° gravado incorretamente.  E n√£o se engane que tal combina√ß√£o de circunst√¢ncias n√£o acontecer√° - acontecer√°. <br><br>  Como escrever o c√≥digo corretamente?  As oportunidades, em regra, se resumem ao seguinte: <br><br><ul><li>  N√£o escreva c√≥digo. <br>  Isso n√£o √© uma piada.  Por exemplo, neste caso, a verifica√ß√£o se transforma facilmente em uma restri√ß√£o de integridade: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Agora, nenhuma verifica√ß√£o √© necess√°ria: basta executar a a√ß√£o e, se necess√°rio, lidar com a exce√ß√£o que surgir√° no caso de uma tentativa de violar a integridade. <br></li><li>  Use uma √∫nica instru√ß√£o SQL. <br>  Problemas de consist√™ncia surgem devido ao fato de que no intervalo entre operadores outra transa√ß√£o pode terminar e os dados vis√≠veis ser√£o alterados.  E se houver apenas um operador, n√£o haver√° lacunas. <br>  O PostgreSQL possui ferramentas suficientes para resolver problemas complexos com uma √∫nica instru√ß√£o SQL.  Observamos as express√µes gerais de tabela (CTE), nas quais, entre outras coisas, voc√™ pode usar as instru√ß√µes INSERT / UPDATE / DELETE, bem como a instru√ß√£o INSERT ON CONFLICT, que implementa a l√≥gica "inserir e, se j√° houver uma linha, atualizar" em uma instru√ß√£o. <br></li><li>  Bloqueios de usu√°rio. <br>  O √∫ltimo recurso √© definir manualmente um bloqueio exclusivo em todas as linhas necess√°rias (SELECT FOR UPDATE) ou em toda a tabela (LOCK TABLE).  Isso sempre funciona, mas nega os benef√≠cios do multi-versioning: em vez de executar simultaneamente, parte das opera√ß√µes ser√° executada sequencialmente. <br></li></ul><br><h3>  Leitura inconsistente </h3><br>  Antes de embarcar no pr√≥ximo n√≠vel de isolamento, √© preciso admitir que nem tudo √© t√£o simples.  A implementa√ß√£o do PostgreSQL √© tal que permite outras anomalias menos conhecidas que n√£o s√£o regulamentadas pelo padr√£o. <br><br>  Digamos que a primeira transa√ß√£o come√ßou a transferir fundos de uma conta Bob para outra: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  No momento, outra transa√ß√£o calcula o saldo de Bob, com o c√°lculo sendo executado em um ciclo em todas as contas de Bob.  De fato, a transa√ß√£o come√ßa na primeira conta (e, obviamente, v√™ o estado anterior): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  Neste ponto, a primeira transa√ß√£o √© conclu√≠da com √™xito: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  E o outro l√™ o estado da segunda conta (e j√° v√™ um novo valor): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Assim, a segunda transa√ß√£o recebeu um total de 1100 ‚ÇΩ, ou seja, dados incorretos.  Esta √© uma anomalia de <em>leitura inconsistente</em> . <br><br>  Como evitar essa anomalia, permanecendo no Read Committed?  Obviamente, use um operador.  Por exemplo, assim: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  At√© agora, argumentei que a visibilidade dos dados s√≥ pode mudar entre os operadores, mas √© t√£o √≥bvio?  E se a solicita√ß√£o for executada por um longo tempo, ela poder√° ver parte dos dados em um estado e parte em outro? <br><br>  Confira.  Uma maneira conveniente de fazer isso √© inserir um atraso artificial no operador chamando a fun√ß√£o pg_sleep.  Seu par√¢metro define o tempo de atraso em segundos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Enquanto essa constru√ß√£o estiver em andamento, em outra transa√ß√£o, transferimos fundos de volta: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  O resultado mostra que o operador v√™ os dados no estado em que estava no momento em que foi iniciado.  Isso certamente est√° correto. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Mas aqui n√£o √© t√£o simples.  O PostgreSQL permite definir fun√ß√µes, enquanto as fun√ß√µes t√™m o conceito de uma <em>categoria de variabilidade</em> .  Se uma fun√ß√£o <em>vol√°til</em> (com a categoria VOLATILE) for chamada em uma solicita√ß√£o e outra solicita√ß√£o for executada nessa fun√ß√£o, essa solicita√ß√£o dentro da fun√ß√£o ver√° dados que n√£o s√£o consistentes com os dados da solicita√ß√£o principal. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Nesse caso, obtemos dados incorretos - 100 ‚ÇΩ s√£o perdidos: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Enfatizo que esse efeito √© poss√≠vel apenas no n√≠vel de isolamento Read Committed e somente na categoria de variabilidade VOLATILE.  O problema √© que esse n√≠vel de isolamento e essa categoria de variabilidade s√£o usados ‚Äã‚Äãpor padr√£o, ent√£o devo admitir - o rake est√° muito bem.  N√£o pise! <br><br><h3>  Leitura inconsistente em troca de altera√ß√µes perdidas </h3><br>  Uma leitura inconsistente na estrutura de um operador pode - de uma maneira um tanto inesperada - ser obtida durante uma atualiza√ß√£o. <br><br>  Vamos ver o que acontece quando voc√™ tenta alterar a mesma linha com duas transa√ß√µes.  Bob agora tem 1000 ‚ÇΩ em duas contas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Iniciamos uma transa√ß√£o que reduz o saldo de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Ao mesmo tempo, outra transa√ß√£o acumula juros em todas as contas de clientes com um saldo total igual ou superior a 1000 ‚ÇΩ: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  A execu√ß√£o de uma instru√ß√£o UPDATE consiste em duas partes.  Primeiro, um SELECT √© realmente executado, o que seleciona as linhas correspondentes √† condi√ß√£o para atualiza√ß√£o.  Como a altera√ß√£o da primeira transa√ß√£o n√£o √© fixa, a segunda transa√ß√£o n√£o pode v√™-la e n√£o afeta a escolha das linhas para o c√°lculo dos juros.  Portanto, as contas de Bob se enquadram nessa condi√ß√£o e, ap√≥s a conclus√£o da atualiza√ß√£o, o saldo deve aumentar em 10 ‚ÇΩ. <br><br>  O segundo est√°gio da execu√ß√£o - as linhas selecionadas s√£o atualizadas uma ap√≥s a outra.  Aqui a segunda transa√ß√£o √© for√ßada a "congelar", porque o id da linha = 3 j√° est√° bloqueado pela primeira transa√ß√£o. <br><br>  Enquanto isso, a primeira transa√ß√£o confirma as altera√ß√µes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Qual ser√° o resultado? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Sim, por um lado, o comando UPDATE n√£o deve ver altera√ß√µes na segunda transa√ß√£o.  Mas, por outro lado, n√£o deve perder as altera√ß√µes registradas na segunda transa√ß√£o. <br><br>  Depois que o bloqueio √© liberado, UPDATE rel√™ a linha que est√° tentando atualizar (mas apenas uma!).  O resultado √© que Bob acumulou 9 ‚ÇΩ, com base na quantidade de 900 ‚ÇΩ.  Mas se Bob tivesse 900 ‚ÇΩ, suas contas n√£o deveriam ter sido inclu√≠das na amostra. <br><br>  Portanto, a transa√ß√£o recebe dados incorretos: algumas das linhas s√£o vis√≠veis em um ponto no tempo, outras no outro.  Em vez de uma atualiza√ß√£o perdida, novamente obtemos uma anomalia na <em>leitura inconsistente</em> . <br><br><blockquote>  Os leitores atentos observam que, com alguma ajuda do aplicativo no n√≠vel Read Committed, voc√™ pode obter uma atualiza√ß√£o perdida.  Por exemplo, assim: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  O banco de dados n√£o √© o culpado: ele recebe duas instru√ß√µes SQL e n√£o sabe nada que o valor de x + 100 esteja de alguma forma relacionado a accounts.amount.  N√£o escreva c√≥digo dessa maneira. <br></blockquote><br><h2>  Leitura Repet√≠vel </h2><br><h3>  Falta de leituras n√£o repetidas e fantasmas </h3><br>  O nome do pr√≥prio n√≠vel de isolamento indica que a leitura √© repet√≠vel.  Vamos verificar isso e, ao mesmo tempo, estaremos convencidos da aus√™ncia de leituras fantasmas.  Para fazer isso, na primeira transa√ß√£o, retorne as contas de Bob ao estado anterior e crie uma nova conta para Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Na segunda sess√£o, iniciamos a transa√ß√£o com o n√≠vel Leitura Repet√≠vel, indicando-a no comando BEGIN (o n√≠vel da primeira transa√ß√£o n√£o √© importante). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Agora, a primeira transa√ß√£o confirma as altera√ß√µes e a segunda executa novamente a mesma solicita√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  A segunda transa√ß√£o continua a ver exatamente os mesmos dados que no in√≠cio: nem as altera√ß√µes nas linhas existentes nem as novas linhas s√£o vis√≠veis. <br><br>  Nesse n√≠vel, voc√™ n√£o precisa se preocupar com alguma mudan√ßa entre os dois operadores. <br><br><h3>  Erro de serializa√ß√£o em troca de altera√ß√µes perdidas </h3><br>  Dissemos acima que, ao atualizar a mesma linha com duas transa√ß√µes no n√≠vel Read Committed, uma anomalia de leitura inconsistente pode ocorrer.  Isso se deve ao fato de a transa√ß√£o pendente reler a linha bloqueada e, portanto, n√£o a encontrar no mesmo ponto no tempo que o restante das linhas. <br><br>  No n√≠vel de Leitura Repet√≠vel, essa anomalia n√£o √© permitida, mas se ocorrer, nada poder√° ser feito - portanto, a transa√ß√£o termina com um erro de serializa√ß√£o.  Verificamos repetindo o mesmo cen√°rio com porcentagens: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Os dados permaneceram consistentes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  O mesmo erro ocorrer√° no caso de qualquer outra altera√ß√£o de linha competitiva, mesmo que as colunas de nosso interesse n√£o tenham realmente sido alteradas. <br><br>  <em>Conclus√£o pr√°tica</em> : se o aplicativo usar o n√≠vel de isolamento de Leitura Repet√≠vel para gravar transa√ß√µes, ele dever√° estar pronto para repetir as transa√ß√µes que terminaram em um erro de serializa√ß√£o.  Para transa√ß√µes somente leitura, esse resultado n√£o √© poss√≠vel. <br><br><h3>  Entrada inconsistente </h3><br>  Portanto, no PostgreSQL, no n√≠vel de isolamento de Leitura Repet√≠vel, todas as anomalias descritas no padr√£o s√£o evitadas.  Mas nem um pouco.  Acontece que existem <em>exatamente duas</em> anomalias que permanecem poss√≠veis.  (Isso √© verdade n√£o apenas no PostgreSQL, mas tamb√©m em outras implementa√ß√µes de isolamento baseadas em instant√¢neos.) <br><br>  A primeira dessas anomalias √© um <em>registro inconsistente</em> . <br><br>  Permita que esta regra de consist√™ncia se aplique: <em>valores negativos s√£o permitidos nas contas do cliente se o valor total em todas as contas desse cliente permanecer n√£o negativo</em> . <br><br>  A primeira transa√ß√£o recebe o valor nas contas de Bob: 900 ‚ÇΩ. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  A segunda transa√ß√£o recebe a mesma quantidade. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  A primeira transa√ß√£o acredita, com raz√£o, que o valor de uma das contas pode ser reduzido em 600 ‚ÇΩ. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  E a segunda transa√ß√£o chega √† mesma conclus√£o.  Mas reduz outra pontua√ß√£o: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Conseguimos reduzir o saldo de Bob, embora cada uma das transa√ß√µes funcione corretamente individualmente. <br><br><h3>  Anomalia somente leitura </h3><br>  Esta √© a segunda e a √∫ltima das anomalias poss√≠veis no n√≠vel de leitura repetida.  Para demonstr√°-lo, voc√™ precisar√° de tr√™s transa√ß√µes, duas das quais modificar√£o os dados e a terceira - somente leitura. <br><br>  Mas primeiro, restaure o status da conta de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  A primeira transa√ß√£o cobra juros de Bob sobre o valor dos fundos em todas as contas.  Os juros s√£o creditados em uma de suas contas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Em seguida, outra transa√ß√£o retira dinheiro de outra conta de Bob e captura suas altera√ß√µes: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Se, neste momento, a primeira transa√ß√£o for confirmada, n√£o haver√° anomalia: poder√≠amos supor que a primeira transa√ß√£o foi conclu√≠da primeiro e depois a segunda (mas n√£o vice-versa, porque a primeira transa√ß√£o viu o status do ID da conta = 3 antes que a conta fosse alterado pela segunda transa√ß√£o). <br><br>  Mas suponha que neste momento a terceira transa√ß√£o (somente leitura) comece, que l√™ o status de alguma conta que n√£o √© afetada pelas duas primeiras transa√ß√µes: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  E somente depois que a primeira transa√ß√£o for conclu√≠da: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Que estado a terceira transa√ß√£o deve ver agora? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Ap√≥s o in√≠cio, a terceira transa√ß√£o p√¥de ver altera√ß√µes na segunda transa√ß√£o (que j√° foi confirmada), mas n√£o na primeira (que ainda n√£o foi confirmada).  Por outro lado, j√° estabelecemos acima que a segunda transa√ß√£o deve ser considerada iniciada ap√≥s a primeira.  Qualquer que seja o estado que a terceira transa√ß√£o veja, ser√° inconsistente - essa √© a anomalia apenas da transa√ß√£o de leitura.  Mas no n√≠vel de Leitura Repet√≠vel, √© permitido: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serializable </h2><br>  No n√≠vel serializ√°vel, todas as poss√≠veis anomalias s√£o evitadas.  De fato, o Serializable √© implementado como um complemento no isolamento, com base em instant√¢neos de dados.  As anomalias que n√£o ocorrem durante a leitura repetida (como leitura fantasma suja, n√£o repet√≠vel e fantasma) tamb√©m n√£o ocorrem no n√≠vel serializ√°vel.  E aquelas anomalias que surgem (grava√ß√£o inconsistente e anomalia apenas da transa√ß√£o de leitura) s√£o detectadas e a transa√ß√£o √© abortada - o j√° conhecido erro de serializa√ß√£o n√£o pode serializar o acesso. <br><br><h3>  Entrada inconsistente </h3><br>  Para ilustrar, repetimos o cen√°rio com uma anomalia de grava√ß√£o inconsistente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Assim como no n√≠vel de leitura repetida, um aplicativo que usa o n√≠vel de isolamento serializ√°vel deve repetir transa√ß√µes que terminaram em um erro de serializa√ß√£o, o que tamb√©m √© relatado pela dica na mensagem de erro. <br><br>  Temos a simplicidade da programa√ß√£o, mas o pre√ßo √© a quebra for√ßada de uma certa propor√ß√£o de transa√ß√µes e a necessidade de repeti-las.  A quest√£o toda, √© claro, √© o tamanho dessa participa√ß√£o.  Se apenas essas transa√ß√µes fossem encerradas que realmente se cruzam incompativelmente nos dados com outras transa√ß√µes, tudo seria legal.  Mas essa implementa√ß√£o inevitavelmente acabaria consumindo muitos recursos e ineficiente, pois teria que rastrear opera√ß√µes com cada linha. <br><br>  De fato, a implementa√ß√£o do PostgreSQL √© tal que permite disparos falsos negativos: algumas transa√ß√µes completamente normais que simplesmente "n√£o t√™m sorte" ser√£o interrompidas.  Como veremos mais adiante, isso depende de v√°rios motivos, por exemplo, a disponibilidade de √≠ndices adequados ou a quantidade dispon√≠vel de RAM.  Al√©m disso, existem outras restri√ß√µes de implementa√ß√£o (bastante s√©rias), por exemplo, solicita√ß√µes no n√≠vel Serializable n√£o funcionar√£o em r√©plicas, planos de execu√ß√£o paralelos n√£o ser√£o usados ‚Äã‚Äãpara elas.  E, embora o trabalho para melhorar a implementa√ß√£o n√£o pare, as restri√ß√µes existentes reduzem a atratividade desse n√≠vel de isolamento. <br><blockquote>  Planos paralelos aparecer√£o no PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patch</a> ).  E consultas sobre r√©plicas podem ser obtidas no PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outro patch</a> ). <br></blockquote><br><h3>  Anomalia somente leitura </h3><br>  Para que apenas uma transa√ß√£o de leitura n√£o possa levar a uma anomalia e n√£o sofra dela, o PostgreSQL oferece um mecanismo interessante: essa transa√ß√£o pode ser bloqueada at√© que sua execu√ß√£o seja segura.  Este √© o √∫nico caso em que uma instru√ß√£o SELECT pode ser bloqueada por atualiza√ß√µes de linha.  Aqui est√° o que parece: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  A terceira transa√ß√£o √© declarada explicitamente apenas pelo leitor (SOMENTE LER) e adiada (DEFERRABLE): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Quando voc√™ tenta executar uma solicita√ß√£o, a transa√ß√£o √© bloqueada, porque, caso contr√°rio, sua execu√ß√£o levar√° a uma anomalia. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  E somente depois que a primeira transa√ß√£o √© confirmada, a terceira continua a executar: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Outra observa√ß√£o importante: se o isolamento serializ√°vel for usado, todas as transa√ß√µes no aplicativo dever√£o usar esse n√≠vel.  Voc√™ n√£o pode misturar transa√ß√µes Read Committed (ou Repeatable Read) com Serializable.  Ou seja, voc√™ pode misturar alguma coisa, mas o Serializable se comportar√° como uma Leitura Repet√≠vel sem aviso.   ,   ,     . <br><br>      Serializble ‚Äî       ( , ,      ): <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>    ,   ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>    ¬´   ¬ª. <br></blockquote><br><h1>    ? </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√≠vel de isolamento Read Committed √© usado por padr√£o no PostgreSQL, e parece que esse n√≠vel √© usado na grande maioria dos aplicativos. √â conveniente que uma quebra de transa√ß√£o seja poss√≠vel apenas no caso de uma falha, mas n√£o para evitar inconsist√™ncia. Em outras palavras, um erro de serializa√ß√£o n√£o pode ocorrer.</font></font><br><br>        ,     .          ,     .         SQL-,      .   ,       ,     ,              . <br><br>   Repeatable Read    , , ,  .        ,     ,      . , , .          Read Committed   , ,   ,   SQL-. <br><br> ,  Serializable      ,     . ,     ‚Äî        .    ,   ,           .   ,   Serializable    ,  ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442804/">https://habr.com/ru/post/pt442804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442790/index.html">As inscri√ß√µes est√£o abertas para o Allure Server Meetup em S√£o Petersburgo</a></li>
<li><a href="../pt442794/index.html">Convidamos voc√™ para a confer√™ncia ‚Äúarquiteto (TI) em projetos e organiza√ß√µes de TI‚Äù</a></li>
<li><a href="../pt442796/index.html">Pesquisa: Tecnologias em nuvem em servi√ßos de GIS e dados geogr√°ficos</a></li>
<li><a href="../pt442798/index.html">Monitorar pings entre hosts Kubernetes √© a nossa receita</a></li>
<li><a href="../pt442800/index.html">Bot simples de telegrama em Python em 30 minutos</a></li>
<li><a href="../pt442806/index.html">O programa preliminar DUMP-2019 est√° pronto. Palestrantes do Evil Marcianos, Tinkoff.ru, HTML Academy, SkyEng, 2GIS</a></li>
<li><a href="../pt442808/index.html">Convidamos voc√™ para a Festa Droid - uma reuni√£o dedicada a quest√µes pr√°ticas do desenvolvimento de aplicativos e dispositivos Android</a></li>
<li><a href="../pt442810/index.html">Mitos da F√≠sica Popular, continua√ß√£o: Gravidade</a></li>
<li><a href="../pt442812/index.html">"N√£o vejo raz√£o para usar o Python para trabalhar com o Spark, exceto a pregui√ßa"</a></li>
<li><a href="../pt442814/index.html">10 anos se passaram e ningu√©m descobriu como usar o blockchain. E aqui de novo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>