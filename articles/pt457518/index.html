<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëù ü¶ä üåê Cadeia de caixa de plasma como uma solu√ß√£o para o trilema da escalabilidade de blockchain üë®üèº‚Äç‚úàÔ∏è üëª ü¶Å</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boa tarde, queridos leitores! 

 Este artigo √© sobre a cadeia de caixa de plasma e esclarece os seguintes t√≥picos: 



- o trilema da escalabilidade e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cadeia de caixa de plasma como uma solu√ß√£o para o trilema da escalabilidade de blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457518/">  Boa tarde, queridos leitores! <br><br>  Este artigo √© sobre a cadeia de caixa de plasma e esclarece os seguintes t√≥picos: <br><br><ul><li>  o trilema da escalabilidade e os m√©todos para sua solu√ß√£o; </li><li>  estruturas de dados da cadeia filho e sua exibi√ß√£o na cadeia raiz; </li><li>  implementa√ß√£o de insumos para a cadeia raiz; </li><li>  implementa√ß√£o da retirada da cadeia radicular. </li></ul><br>  O Opporty usou a linguagem de programa√ß√£o Javascript para implementar a cadeia filho, bem como o Solidity para a cadeia raiz.  Exemplos de c√≥digo s√£o fornecidos nesses idiomas. <br><br><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><a name="habracut"></a><br>  A blockchain e a descentraliza√ß√£o possibilitam otimizar e melhorar o trabalho de quase todas as esferas da vida em que a Internet e as tecnologias da informa√ß√£o s√£o usadas.  Eles aumentam a confiabilidade, a efici√™ncia financeira e tamb√©m facilitam a digitaliza√ß√£o de coisas e bens reais. <br><br>  Contratos inteligentes trazem l√≥gica de neg√≥cios para redes descentralizadas.  Isso permite criar novos aplicativos DAPP. <br><br>  A execu√ß√£o de contratos inteligentes e a opera√ß√£o r√°pida de aplicativos com um banco de dados distribu√≠do s√≥ podem ser poss√≠veis se a condi√ß√£o de escalabilidade for atendida. <br><br>  As cadeias de blocos descentralizadas modernas t√™m v√°rias desvantagens.  O principal √© a escalabilidade.  O Ethereum processa cerca de 20 tx / s.  Isso n√£o √© suficiente nas realidades financeiras modernas.  Ao mesmo tempo, o Ethereum tem o mais alto n√≠vel poss√≠vel de prote√ß√£o contra hackers e falhas de rede.  Outras criptomoedas e sistemas constru√≠dos no blockchain n√£o possuem um alto grau de descentraliza√ß√£o, o que reduz a confian√ßa na rede. <br><br><h2>  O trilema da escalabilidade </h2><br>  H√° um trilema de escalabilidade de blockchain que inclui tr√™s componentes: <br><br><ul><li>  descentraliza√ß√£o; </li><li>  seguran√ßa </li><li>  escalabilidade. </li></ul><br><h3>  Descentraliza√ß√£o no Trilemma </h3><br>  A descentraliza√ß√£o, como o termo implica, reflete o grau de diversifica√ß√£o da propriedade da atividade na blockchain, bem como o grau de diversifica√ß√£o da cria√ß√£o de blocos e da gera√ß√£o de novas entradas no raz√£o. <br><br>  Para maior clareza, √© necess√°rio falar sobre as organiza√ß√µes mais centralizadas.  Geralmente, um banco de dados simples √© usado em vez do blockchain.  Essa organiza√ß√£o √© administrada por administradores especiais.  Todas as transa√ß√µes podem ser canceladas por interven√ß√£o manual. <br><br>  Em redes totalmente descentralizadas, cada usu√°rio pode participar da constru√ß√£o de uma rede. <br><br>  A consequ√™ncia mais importante da descentraliza√ß√£o √© que a maior parte do valor vai para a comunidade envolvida na cria√ß√£o da blockchain.  N√£o h√° uma equipe intermedi√°ria de gerentes que recebam todos os benef√≠cios, em vez daqueles que geram a pr√≥pria estrutura de rede.  De fato, a maioria dos projetos de criptografia √© de propriedade exclusiva de seus colaboradores ou usu√°rios, n√£o dos fundadores.  Este √© obviamente um modelo mais atraente para quem n√£o √© fundador. <br><br><h3>  Seguran√ßa no Trilemma </h3><br>  √â sobre a capacidade do blockchain de suportar ataques de fontes externas e manter o sistema em um estado inalterado.  A maioria das blockchains est√° sujeita a muitas amea√ßas potenciais √† seguran√ßa.  √â imperativo conhecer os vetores de ataque e op√ß√µes de defesa mais comuns. <br><br>  Nesse caso, descentraliza√ß√£o e seguran√ßa andam de m√£os dadas.  Quanto mais n√≥s, menos a rede depende do lado centralizado e, portanto, o risco de ter um ponto central de falha.  No entanto, existem muitos outros vetores de ataque que representam uma amea√ßa para redes descentralizadas, incluindo: <br>  &gt; <b>50% de ataque</b> - um objeto que possui mais de 50% do n√∫mero total de tokens n√£o pagos realmente possui a rede; <br>  &gt; <b>Sybil Attack</b> - o usu√°rio pode gerar muitos identificadores no sistema para controlar efetivamente uma parcela significativa da propriedade e / ou tomada de decis√£o na rede; <br>  &gt; <b>DDoS</b> - um ataque de nega√ß√£o de servi√ßo distribu√≠do (DDoS) ocorre quando existe a inten√ß√£o de interromper o tr√°fego na rede, enchendo a rede com transa√ß√µes maliciosas; <br>  &gt; <b>Ataque de conluio</b> - um ou v√°rios objetos (ou n√≥s) decidem se unir para executar qualquer opera√ß√£o maliciosa na rede. <br><br><h3>  Escalabilidade no Trilemma </h3><br>  O grau de escalabilidade √© importante porque determina a taxa de transfer√™ncia final, ou seja, o limite superior do tamanho da rede.  A pergunta mais importante a ser feita ao avaliar uma rede √©: "Quantos usu√°rios esse sistema suporta?"  Atualmente, o Bitcoin tem entre 2,9 e 5,8 milh√µes de portadores de carteira.  A EOS tem v√°rios milhares de membros. <br><br>  Escalabilidade e descentraliza√ß√£o podem coexistir, mas a seguran√ßa √© reduzida.  Os desenvolvedores escolhem as plataformas que melhor atendem √†s suas necessidades.  Usu√°rios fazem o mesmo.  As opini√µes dos dois lados √†s vezes diferem.  Alguns usu√°rios est√£o dispostos a sacrificar a seguran√ßa pela escalabilidade, outros est√£o dispostos a sacrificar a escalabilidade pela seguran√ßa, mas o equil√≠brio √© muito mais dif√≠cil. <br><br><h2>  "Santo Graal" na tecnologia blockchain </h2><br>  Por defini√ß√£o, uma blockchain possui apenas duas das tr√™s propriedades a seguir: <br><br><ul><li>  <b>Descentraliza√ß√£o</b> (cada participante tem acesso apenas aos recursos O ¬©, ou seja, a um laptop comum ou a um pequeno VPS); </li><li>  <b>Escalabilidade</b> (capacidade de processar transa√ß√µes O (n)&gt; O ¬©); </li><li>  <b>Seguran√ßa</b> (prote√ß√£o contra invasores usando recursos O (n)). </li></ul><br><img src="https://habrastorage.org/webt/ek/zg/zr/ekzgzredr00odj5mwae4f549hzs.png"><br>  Verde: um estado equilibrado de tr√™s condi√ß√µes. <br>  Vermelho: seguran√ßa forte, mas descentraliza√ß√£o e escalabilidade limitadas. <br>  Azul: a efici√™ncia √© alta, mas a seguran√ßa e a descentraliza√ß√£o s√£o limitadas. <br>  Preto: a descentraliza√ß√£o √© alta, mas n√£o h√° aspectos de escalabilidade e seguran√ßa. <br>  Cinza: descentraliza√ß√£o total, com qualidades m√≠nimas ou ausentes de seguran√ßa e escalabilidade. <br>  Violeta: equil√≠brio igual entre seguran√ßa e escalabilidade, a rejei√ß√£o da descentraliza√ß√£o. <br><br>  O "santo graal" na tecnologia blockchain significa combinar os tr√™s aspectos. <br>  Na maioria dos projetos atuais que trabalham com criptomoedas, duas propriedades b√°sicas s√£o obtidas: descentraliza√ß√£o e seguran√ßa.  A escalabilidade sofre. <br><br><h2>  Solu√ß√µes promissoras para o trilema </h2><br><h3>  Prova de participa√ß√£o (PoS) </h3><br>  A Prova de Estaca (PoS) fornece aprimoramentos em potencial de escalabilidade.  O POS substitui a minera√ß√£o de criptomoeda com base no sistema de Prova de Trabalho (PoW).  A escolha do validador √© muito r√°pida - de maneira determin√≠stica.  Ao mesmo tempo, n√£o h√° custo de energia e √© ecol√≥gico. <br><br><h3>  Sidechains </h3><br>  Na rede virtual Ethereum, existe a possibilidade de criar uma rede lateral na qual o projeto possa processar suas transa√ß√µes individuais e, em seguida, registrar apenas os resultados iniciais e finais na rede Ethereum.  Isso reduz a carga no EVM, mas oferece mais confian√ßa no gerenciamento da cadeia lateral.  Assim, a confian√ßa em terceiros reduz a descentraliza√ß√£o. <br><br><h3>  Sharding </h3><br>  O sharding divide as transa√ß√µes em peda√ßos menores de dados.  Em vez de cada n√≥ individual na rede processar transa√ß√µes inteiras, os n√≥s s√£o divididos em grupos e esses grupos de n√≥s processam determinadas partes de dados.  Mais tarde, durante o processamento, esses dados s√£o re-assimilados para armazenamento permanente na blockchain. <br><br><h3>  Aumentar tamanho do bloco </h3><br>  Litecoin e Bitcoin Cash (BCH) s√£o "garfos" para a blockchain Bitcoin.  Bifurca√ß√£o basicamente copia uma blockchain.  Ap√≥s a ramifica√ß√£o, voc√™ pode fazer altera√ß√µes.  LTC e BCH aumentaram o tamanho de cada bloco, o que permitiu armazenar mais transa√ß√µes por bloco, aumentando assim a velocidade de processamento das transa√ß√µes. <br><br><h3>  Rede Lightning </h3><br>  A primeira solu√ß√£o da cadeia lateral foi um raio.  A id√©ia principal da Lightning Network √© que nem todas as transa√ß√µes devem ser registradas no blockchain, pois isso sobrecarrega a rede.  Se os usu√°rios transferirem fundos um para o outro v√°rias vezes, o registro de cada transfer√™ncia √© opcional.  Basta abrir um tipo de canal de pagamento e anotar os dados sobre sua abertura no blockchain.  Este canal permanecer√° aberto conforme necess√°rio.  Quando for necess√°rio fech√°-lo, o resultado de todas as transa√ß√µes feitas neste canal √© simplesmente gravado no blockchain.  Seguindo essa ideia, voc√™ pode criar uma rede inteira de canais para pagamentos.  Em seguida, as transa√ß√µes na blockchain ser√£o usadas com muito menos frequ√™ncia. <br><br>  Um canal de pagamento √© apenas uma combina√ß√£o de v√°rias transa√ß√µes.  Um canal pode ser fechado por qualquer um de seus membros.  Essa a√ß√£o ser√° como abrir um cofre, que permite pegar os fundos pertencentes aos participantes e anotar os dados de sua transfer√™ncia para o blockchain. <br>  Essa tecnologia se torna realmente poderosa quando v√°rios desses canais s√£o combinados em uma rede chamada The Lightning Network.  Esta rede √© constru√≠da especialmente para Bitcoin. <br><br><h3>  Rede Raiden </h3><br>  Para a Ethereum, a contraparte mais conhecida do Lightning √© a Rede Raiden. <br>  Esta √© uma solu√ß√£o para dimensionar fora do blockchain principal.  √â compat√≠vel com a transfer√™ncia de tokens ERC-20 em canais de pagamento bidirecionais. <br><br>  Sua arquitetura b√°sica √© complexa, mas a intera√ß√£o com o Raiden exige que os desenvolvedores interajam apenas com a API para criar aplicativos escal√°veis ‚Äã‚Äãno Raiden. <br><br>  O Raiden foi projetado para fornecer pagamentos instant√¢neos e baixas comiss√µes, aumentar a confidencialidade da transa√ß√£o e micropagamentos.  A maioria dos canais de pagamento existe fora da rede e apenas ocasionalmente forma transa√ß√µes dentro da cadeia raiz, o que reduz significativamente a taxa de transfer√™ncia da cadeia filha. <br><br><h2>  Solu√ß√£o ideal </h2><br>  Os ide√≥logos de raios criaram um novo conceito de cadeia de crian√ßas que resolve problemas de velocidade da cadeia de blocos. <br><br>  O Opporty praticamente implementa o conceito de Plasma e Plasma Cash. <br><br>  O plasma √© um conjunto de contratos inteligentes que s√£o executados no topo da cadeia raiz do Ethereum e consistem em uma rede de cadeias filho conectadas √† cadeia raiz em uma estrutura hier√°rquica em √°rvore. <br><br>  Ou seja, a seguran√ßa do rootchain Ethereum √© usada para otimizar a escalabilidade. <br><br><h2>  Dinheiro de plasma: op√ß√£o oportuna </h2><br>  <b>O Opporty usa a implementa√ß√£o do Plasma Cash na primeira vers√£o.</b> <br><br>  Este modelo √© a implementa√ß√£o de plasma mais eficaz em termos de escalabilidade. <br>  O Plasma Cash √© um sistema baseado no uso de identificadores exclusivos para cada token na cadeia Plasma.  Ou seja, a NFT √© aplicada e os tokens na rede recebem n√∫meros de s√©rie exclusivos. <br><br>  Caracter√≠sticas do dinheiro de plasma: <br><br><ul><li>  Valida√ß√£o fragmentada no lado do cliente - os clientes precisam apenas monitorar sua cadeia de plasma para obter seus tokens.  Isso significa que o rendimento da transa√ß√£o pode aumentar sem aumentar a carga em usu√°rios individuais. </li><li>  Simplifica√ß√£o da sa√≠da em massa - as sa√≠das em massa tornam-se menos uma amea√ßa para a rede, pois o ladr√£o deve enviar uma transa√ß√£o de sa√≠da para cada token que ele deseja roubar. </li><li>  N√£o h√° confirma√ß√µes bidirecionais - as transa√ß√µes n√£o exigem mais envio e confirma√ß√£o em duas etapas.  Em vez disso, uma transa√ß√£o pode ser gasta assim que inclu√≠da na cadeia principal. </li></ul><br>  Desvantagem: <br><br>  Denomina√ß√µes grandes de tokens - como cada n√∫mero de s√©rie deve ser atribu√≠do a um token, √© imposs√≠vel produzir tokens arbitrariamente pequenos.  Isso se deve ao fato de que, em algum momento, o valor da compra do token ser√° maior que o valor do pr√≥prio token. <br><br><h3>  Estrutura da transa√ß√£o em dinheiro plasma oportuno </h3><br>  O Javascript usado oportuno para implementar childchain.  Cada transa√ß√£o no Opporty Plasma Cash √© uma estrutura semelhante: <br><br><pre><code class="plaintext hljs">const transactionFields = [ {name: 'prevHash'}, {name: 'prevBlock', int: true, default: 0}, {name: 'tokenId', isDecimal: true}, {name: 'newOwner'}, {name: 'type'}, {name: 'signature'}, ]</code> </pre> <br>  Os principais elementos aqui s√£o um link para o bloco prevBlock anterior (√© necess√°rio mover-se pela cadeia de blocos), o identificador de tokenId tokenId (deve ser exclusivo) e tamb√©m newOwner, o √∫ltimo propriet√°rio do token. <br><br>  Al√©m disso, para montar o bloco e obter o hash da cadeia raiz, √© usado um tipo especial da √°rvore Patricia Merkle Trie.  A mesma √°rvore √© usada no Ethereum.  Tem uma apar√™ncia compactada.  Ao mesmo tempo, voc√™ ainda pode receber provas de inclus√£o ou n√£o inclus√£o de uma transa√ß√£o em um bloco. <br>  Assinatura √© uma assinatura em curvas el√≠pticas. <br><br>  Uma transa√ß√£o que gasta um token com um determinado tokenId √© v√°lida apenas se for inclu√≠da na √°rvore Merkle na posi√ß√£o tokenId, ou seja, para cada token na √°rvore Merkle h√° apenas um "local" que gasta esse token onde transa√ß√µes s√£o permitidas.  Esse formato permite que os usu√°rios verifiquem o hist√≥rico completo da cadeia de plasma, al√©m de provar e refutar a propriedade de tokens espec√≠ficos. <br><br>  Para gastar um token, voc√™ precisa validar a cadeia, verificar se h√° blocos ausentes e s√≥ ent√£o assinar novamente a transa√ß√£o junto com todo o hist√≥rico. <br><br>  O bloco √© o seguinte: <br><br><pre> <code class="plaintext hljs">const blockFields = [ {name: 'prevHash'}, {name: 'blockNum', isDecimal: true}, {name: 'transactions'}, {name: 'merkleRoot'}, {name: 'time'} ]</code> </pre> <br>  Em um n√≠vel b√°sico, uma blockchain √© simplesmente uma cadeia de blocos com um link para o bloco anterior.  Essa estrutura torna poss√≠vel obter a propriedade de imutabilidade, ou seja, n√£o reescrever o hist√≥rico.  O merkleRoot torna poss√≠vel escrever pontos de verifica√ß√£o na cadeia raiz. <br><br>  Na cadeia raiz, no n√≠vel do contrato inteligente, √© assim (linguagem Solidity): <br><br><pre> <code class="plaintext hljs">/* * Block structure (represents one block in a chain) */ struct Block { uint block_num; bytes32 merkle_root; uint time; /* * Transaction structure (decoded from RLP form) */ struct Transaction { bytes32 prevhash; uint prev_block; uint token_id; address new_owner; }</code> </pre><br>  A codifica√ß√£o √© realizada usando as fun√ß√µes de codifica√ß√£o / decodifica√ß√£o - serializa√ß√£o / desserializa√ß√£o de RLP. <br><br><h3>  Maneiras de entrar no Plasma Cash </h3><br>  Qualquer pessoa pode depositar fundos no Plasma Cash simplesmente transferindo o √©ter para um contrato inteligente.  Como resultado, um token OPP ser√° recebido em uma posi√ß√£o tokenId espec√≠fica. <br><br>  Aqui est√° a implementa√ß√£o no Solidity: <br><br><pre> <code class="plaintext hljs">function deposit() public payable { uint token_id = uint(keccak256(msg.sender, msg.value, deposit_blk)); // token.index = deposit_blk; tokens[token_id] = msg.value; deposit_blk += 1; emit DepositAdded(msg.sender, msg.value, token_id, current_blk); }</code> </pre> <br>  Ou seja, tokenId √© gerado como um n√∫mero aleat√≥rio (hash).  Em seguida, √© gerado um evento que √© verificado na cadeia filho. <br><br><h3>  Formas de retirar para o Plasma Cash </h3><br>  Cada pessoa pode retirar seu token fornecendo as duas √∫ltimas transa√ß√µes no hist√≥rico de propriedade do token. <br><br>  Implementa√ß√£o de sa√≠da da cadeia raiz: <br><br><pre> <code class="plaintext hljs">function startExit(uint block_num, bytes tx1, bytes tx0, bytes proof1, bytes proof0) public returns (uint exit_id) { require(checkPatriciaProof(keccak256(tx1), childChain[block_num].merkle_root, proof1)); bytes32 prev_hash; uint prev_blk; uint token_id; address new_owner; (prev_hash, prev_blk, token_id, new_owner,) = getTransactionFromRLP(tx1); require(msg.sender == new_owner); require(tokens[token_id] &gt; 0); bytes32 hashPrevTx = keccak256(tx0); require(checkPatriciaProof(hashPrevTx, childChain[prev_blk].merkle_root, proof0)); require(prev_hash == hashPrevTx); Exit storage record = exitRecords[token_id]; require(record.block_num == 0); record.block_num = block_num; record.new_owner = msg.sender; record.prev_block = prev_blk; if (childChain[block_num].time &gt; block.timestamp - week) record.priority = childChain[block_num].time; else record.priority = block.timestamp - week; exits.add(record.priority); exit_ids[record.priority].push(token_id); emit ExitAdded(msg.sender, record.priority, token_id); return token_id; }</code> </pre><br>  Primeiro, duas transa√ß√µes s√£o verificadas.  Se o usu√°rio atual for o propriet√°rio da transa√ß√£o, basta adicionar sua sa√≠da √† estrutura e deixar duas semanas para a oportunidade de contestar a sa√≠da. <br><br>  A conclus√£o pode ser contestada de tr√™s maneiras: <br><br><ul><li>  Fornecendo confirma√ß√£o de gastos em transa√ß√µes: </li></ul><br><pre> <code class="plaintext hljs">function challengeSpent(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); require(prev_block == record.block_num &amp;&amp; record.block_num &lt; blk_num); require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Se houver uma transa√ß√£o que j√° esteja gastando o token exibido, essa retirada ser√° cancelada! <br><br><ul><li>  Comprova√ß√£o de despesas para a transa√ß√£o anterior: </li></ul><br><pre> <code class="plaintext hljs">/* * Challenge exit by providing * a proof of a transaction spending P(C) that appears before C */ function challengeDoubleSpend(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); // bytes32 prev_hash; uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); // check if token double spent require(prev_block == record.prev_block &amp;&amp; blk_num &lt; record.block_num); // require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  √â a mesma verifica√ß√£o como se o token tivesse sido gasto antes da retirada.  Primeiro, verifique se h√° uma transa√ß√£o no hash raiz.  Em seguida, excluiremos a sa√≠da, se ela j√° tiver sido gasta. <br><br><ul><li>  fornecendo uma transa√ß√£o no hist√≥rico de transa√ß√µes do token antes dele. </li></ul><br>  Esta pode ser uma hist√≥ria errada, por isso voc√™ precisa confirm√°-la com uma transa√ß√£o filho: <br><br><pre> <code class="plaintext hljs">// */ function challengeInvalidHistory(uint exit_id, uint blk_num, bytes tx0, bytes proof) public { // check if proof is valid require(checkPatriciaProof(keccak256(tx0), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); bytes32 prev_hash; uint token_id; (prev_hash, , token_id, ) = getTransactionFromRLP(tx0); //require(exit_id == token_id); require(tokens[token_id] &gt; 0); // transaction should be before exit tx in history require(blk_num &lt; record.block_num - 1); challenged[exit_id] = blk_num; emit ChallengedInvalidHistory(exit_id, token_id); }</code> </pre><br>  A chamada do primeiro e do segundo scripts bloqueia a sa√≠da imediatamente. <br><br>  A chamada para o terceiro cen√°rio pode ser atendida fornecendo um descendente direto.  Ele deve ser igual ou antes da transa√ß√£o pai. <br><br><pre> <code class="plaintext hljs">/* * Respond to invalid history challenge by providing * the direct child of C*, which must be either equal to or before P( C ) */ function respondChallenge(uint exit_id, uint blk_num, bytes childtx, bytes proof) public { require(challenged[exit_id] &gt; 0); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); require(checkPatriciaProof(keccak256(childtx), childChain[blk_num].merkle_root, proof)); // get transaction from rlpencoded form bytes32 prev_hash; uint prev_block; uint token_id; (prev_hash, prev_block, token_id, ) = getTransactionFromRLP(childtx); // if direct child if (prev_block == challenged[exit_id] ) { if (blk_num &lt;= record.prev_block &amp;&amp; token_id == exit_id ) { delete challenged[exit_id]; emit ExitRespondedEvent(exit_id); } else { exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); } } }</code> </pre><br>  Ou seja, se a transa√ß√£o filho correta for recebida, a sa√≠da ser√° contestada e permanecer√° na fila! <br>  Ap√≥s a constru√ß√£o de parte do protocolo Opporty Plasma Cash, foi feita a seguinte conclus√£o: <br>  Este protocolo fornece seguran√ßa atrav√©s da cadeia raiz do Ethereum. <br><br>  Ao complicar os procedimentos de entrada e sa√≠da da cadeia raiz e da compress√£o do estado (blocos de transa√ß√£o), todos os m√©todos de sa√≠da e entrada na cadeia raiz foram considerados e as estruturas b√°sicas de dados: transa√ß√µes e blocos foram investigados. <br><br>  Usando a cadeia lateral baseada na rede Ethereum, voc√™ pode acelerar significativamente as transa√ß√µes.  O Opporty recebeu at√© <b>300.000</b> transa√ß√µes por segundo em um √∫nico operador.  Isso √© muito mais do que os atuais sistemas de pagamento podem oferecer. <br><br>  Apesar de alguns problemas de disponibilidade de dados, a operadora fornece um alto n√≠vel de estabilidade do blockchain e possibilita a realiza√ß√£o de transa√ß√µes comerciais internacionais eficazes. <br><br>  O Plasma Cash traz um enorme aumento na escalabilidade.  Portanto, o Opporty usa o plasma como parte de seu protocolo PoE. <br><br><h3>  Links √∫teis </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Plasma de papel branco</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hub Git</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Casos de uso e descri√ß√£o da arquitetura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Papel de rede rel√¢mpago</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457518/">https://habr.com/ru/post/pt457518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457500/index.html">Como fizemos o piloto autom√°tico para uma esta√ß√£o de servi√ßo</a></li>
<li><a href="../pt457502/index.html">Como o modelo de pontua√ß√£o do RICE aprimora a prioriza√ß√£o de recursos do produto</a></li>
<li><a href="../pt457504/index.html">Por que escrever sua grade de dados de rea√ß√£o em 2019</a></li>
<li><a href="../pt457514/index.html">Nevanger</a></li>
<li><a href="../pt457516/index.html">Escrevendo um modelo de amea√ßa</a></li>
<li><a href="../pt457522/index.html">Levante seu servi√ßo de lista de discuss√£o ou use solu√ß√µes prontas? O que aprendi ao longo de 5 anos no UniSender</a></li>
<li><a href="../pt457524/index.html">C√¢meras de profundidade - revolu√ß√£o silenciosa (quando os rob√¥s ver√£o) Parte 1</a></li>
<li><a href="../pt457526/index.html">M√≠dia t√©cnica como bazar</a></li>
<li><a href="../pt457532/index.html">Est√° na hora de fazer parte de um projeto de c√≥digo aberto</a></li>
<li><a href="../pt457534/index.html">Vers√µes certificadas - o rake que escolhemos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>