<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🌾 📪 🎮 Mengikuti pertemuan "PostgreSQL 11 Fitur Baru" 🍚 📧 🦆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan berbicara tentang fitur-fitur terpenting PostgreSQL 11. Mengapa hanya tentang mereka - karena tidak semua orang membutuhkan beberap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengikuti pertemuan "PostgreSQL 11 Fitur Baru"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/414031/">  Hari ini kita akan berbicara tentang fitur-fitur terpenting PostgreSQL 11. Mengapa hanya tentang mereka - karena tidak semua orang membutuhkan beberapa fitur, jadi kami memilih yang paling populer. <br><br><h3>  Isi </h3><br><img src="https://habrastorage.org/webt/3l/ef/wk/3lefwko0funvsqwyvgcaqtf7ory.png" align="right" width="300"><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompilasi Jit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Partisi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Indeks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meliputi Indeks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SP GiST</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Performa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WAL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cadangkan dan replikasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksekusi paralel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengoptimal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perubahan Pencarian Teks Lengkap</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Json (b) dan teks lengkap</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prosedur PL / *</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pgbench</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peningkatan PSQL</a> </li></ul><a name="habracut"></a><br><a name="1"></a><h3>  Kompilasi Jit </h3><br>  PostgreSQL akhirnya memperkenalkan kompilasi JIT, yaitu, mengkompilasi kueri ke dalam kode biner.  Untuk melakukan ini, kompilasi PostgreSQL dengan dukungan untuk kompilasi JIT <code>(Compile time 1 (--with-llvm))</code> .  Pada saat yang sama, mesin harus memiliki versi LLVM tidak lebih rendah dari 3,9. <br><br>  Apa yang bisa mempercepat JIT? <br><br><ul><li>  Kueri dengan klausa WHERE, yaitu segala sesuatu yang muncul setelah kata kunci ini.  Ini tidak selalu diperlukan, tetapi kesempatan itu bermanfaat. </li><li>  Perhitungan daftar target: dalam terminologi PostgreSQL, ini adalah semua yang ada di antara pilih dan dari. </li><li>  Agregat. </li><li>  Konversi rekaman dari satu tampilan ke tampilan lainnya (Proyeksi).  Misalnya, saat Anda menerapkan penggabungan ke dua tabel, hasilnya adalah tupel baru yang berisi bidang dari kedua tabel. </li><li>  Tuple merusak bentuk.  Salah satu masalah dari setiap basis data, setidaknya huruf kecil, relasional, adalah bagaimana cara mendapatkan bidang dari catatan pada disk.  Bagaimanapun, mungkin ada nol, mereka memiliki catatan berbeda dan secara umum, ini bukan operasi termurah. </li></ul><br>  <code>Compile time 2</code> berarti bahwa JIT tidak digunakan.  Dalam PostgreSQL ada saat perencanaan permintaan, ketika sistem memutuskan apa yang bernilai JIT dan apa yang tidak.  Pada titik ini, itu JIT dan kemudian eksekutor mengeksekusi apa adanya. <br><br>  JIT dibuat pluggable.  Secara default, ini bekerja dengan LLVM, tetapi Anda dapat menghubungkan JIT lainnya. <br><br><img src="https://habrastorage.org/webt/hm/pk/lk/hmpklkbpxsi1qzqyvyx3drcl6_y.png" width="600"><br><br>  Jika Anda mengkompilasi PostgreSQL tanpa dukungan JIT, maka pengaturan pertama tidak berfungsi.  Opsi yang diterapkan untuk pengembang, ada pengaturan untuk fungsi JIT individu. <br><br>  Titik halus berikutnya terkait dengan jit_above_cost.  JIT sendiri tidak gratis.  Oleh karena itu, PostgreSQL default ke optimasi JIT jika biaya kueri melebihi 100 ribu burung beo bersyarat, di mana menjelaskan, menganalisis, dan sebagainya diukur.  Nilai ini dipilih secara acak, jadi perhatikanlah. <br><br>  Tetapi tidak selalu setelah menyalakan JIT semuanya bekerja segera.  Biasanya, semua orang mulai bereksperimen dengan JIT menggunakan pilih * dari tabel di mana id = 600 permintaan dan mereka gagal.  Mungkin, perlu untuk mempersulit permintaan, dan kemudian semua orang membuat basis data raksasa dan menyusun permintaan.  Akibatnya, PostgreSQL bersandar pada kemampuan disk, tidak memiliki kapasitas buffer dan cache bersama. <br><br>  Ini adalah contoh yang sepenuhnya abstrak.  Ada 9 bidang nol dengan frekuensi berbeda, sehingga Anda dapat melihat efek deformasi tuple. <br><br> <code>select i as x1, <br> case when i % 2 = 0 then i else null end as x2, <br> case when i % 3 = 0 then i else null end as x3, <br> case when i % 4 = 0 then i else null end as x4, <br> case when i % 5 = 0 then i else null end as x5, <br> case when i % 6 = 0 then i else null end as x6, <br> case when i % 7 = 0 then i else null end as x7, <br> case when i % 8 = 0 then i else null end as x8, <br> case when i % 9 = 0 then i else null end as x9 <br> into t <br> from generate_series(0, 10000000) i; <br> <br> vacuum t; <br> analyze t;</code> <br> <br>  PostgreSQL memiliki banyak kemungkinan, dan untuk melihat kelebihan JIT, nonaktifkan dua baris pertama agar tidak mengganggu, dan setel ulang ambangnya. <br><br> <code>set max_parallel_workers=0; <br> set max_parallel_workers_per_gather=0; <br> set jit_above_cost=0; <br> set jit_inline_above_cost=0; <br> set jit_optimize_above_cost=0;</code> <br> <br>  Ini permintaannya sendiri: <br><br> <code>set jit=off; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000; <br> <br> set jit=on; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000;</code> <br> <br>  Dan inilah hasilnya: <br><br> <code>Planning Time: 0.71 ms <br> Execution Time: <b>1986.323</b> ms <br> <br> VS <br> <br> Planning Time: 0.060 ms <br> JIT: <br> Functions: 4 <br> Generation Time: 0.911 ms <br> Inlining: true <br> Inlining Time: 23.876 ms <br> Optimization: true <br> Optimization Time: 41.399 ms <br> Emission Time: 21.856 ms <br> Execution Time: <b>949.112</b> ms</code> <br> <br>  JIT membantu mempercepat permintaan hingga setengahnya.  Merencanakan waktu adalah tentang hal yang sama, tetapi ini kemungkinan besar merupakan hasil dari cache PostgreSQL, jadi abaikan saja. <br><br>  Jika disimpulkan, dibutuhkan sekitar 80 ms untuk kompilasi JIT.  Mengapa JIT tidak gratis?  Sebelum menjalankan permintaan, Anda perlu mengompilasinya, dan ini juga membutuhkan waktu.  Dan tiga urutan besarnya lebih dari perencanaan.  Bukan kesenangan yang mahal, tetapi terbayar karena lamanya eksekusi. <br><br>  Dengan cara ini Anda dapat menggunakan JIT, meskipun itu tidak selalu bermanfaat. <br><br><a name="2"></a><h3>  Partisi </h3><br>  Jika Anda memperhatikan partisi di PostgreSQL, Anda mungkin memperhatikan bahwa partisi itu dibuat untuk pertunjukan.  Situasi sedikit membaik di versi 10, ketika deklarasi deklarasi partisi (bagian) muncul.  Di sisi lain, semuanya tetap sama di dalam dan bekerja kurang lebih sama dengan di versi sebelumnya, yaitu, buruk. <br>  Dalam banyak hal, masalah ini diselesaikan oleh modul pg_pathman, yang memungkinkan bekerja dengan bagian-bagian dan memotongnya pada waktu yang cukup optimal saat run time. <br><br>  Di versi 11, partisi sangat ditingkatkan: <br><br><ul><li>  Pertama, tabel partisi mungkin memiliki kunci utama, yang harus menyertakan kunci partisi.  Sebenarnya, ini adalah kunci semi-primer, atau semi-kunci primer.  Sayangnya, Anda tidak dapat membuat kunci asing di dalamnya.  Saya harap ini akan diperbaiki di masa depan. </li><li>  Juga sekarang dimungkinkan untuk mempartisi tidak hanya oleh rentang, tetapi juga dengan daftar dan hash.  Hash cukup primitif, sisa ekspresi diambil untuk itu. </li><li>  Saat memperbarui, garis bergerak di antara bagian.  Sebelumnya, Anda harus menulis pemicu, tetapi sekarang hal itu dilakukan secara otomatis. </li></ul><br>  Pertanyaan besarnya adalah: berapa banyak bagian yang bisa saya miliki?  Jujur, dengan sejumlah besar bagian (ribuan dan puluhan ribu) fitur tidak berfungsi dengan baik.  Pg_pathman lebih baik. <br><br>  Juga membuat bagian secara default.  Sekali lagi, di pg_pathman Anda dapat membuat bagian secara otomatis, yang lebih nyaman.  Di sini, semua yang tidak bisa didorong di suatu tempat jatuh di bagian.  Jika dalam sistem nyata untuk melakukan ini secara default, maka setelah beberapa waktu Anda mendapatkan kekacauan seperti itu, yang kemudian Anda siksa untuk menyapu. <br><br>  PostgreSQL 11 sekarang dapat mengoptimalkan partisi jika dua tabel digabungkan dengan kunci partisi dan skema partisi cocok.  Ini dikendalikan oleh parameter khusus, yang dimatikan secara default. <br><br>  Anda dapat menghitung agregat untuk setiap bagian secara terpisah, dan kemudian menambahkannya.  Akhirnya, Anda bisa membuat indeks pada tabel partisi induk, dan kemudian indeks lokal di semua tabel yang terhubung dengannya akan dibuat. <br><br>  Di bagian "Apa yang Baru", hal yang luar biasa disebutkan - kemampuan untuk membuang bagian saat melakukan permintaan.  Mari kita periksa cara kerjanya.  Hasilnya adalah tabel seperti itu: <br><br><img src="https://habrastorage.org/webt/pd/yq/og/pdyqogkeovn-af_egj5u8wlszne.png" width="500"><br><br>  Kami membuat tipe dan tabel dua kolom dengan kunci utama, dengan kolom bigserial, menyisipkan data.  Kami membuat tabel kedua, yang akan dipartisi dan akan menjadi salinan yang pertama.  Tambahkan kunci utama ke tabel dipartisi. <br><br><img src="https://habrastorage.org/webt/in/5h/gr/in5hgrummalku8i2gfizbjbt3hm.png" width="500"><br><br>  Tabel akan terdiri dari dua jenis entri: "pengasuh perempuan" dan "pengemudi laki-laki".  Dan akan ada satu pengemudi wanita.  Kami membuat dua bagian, bagi berdasarkan daftar, tambahkan kunci utama dan masukkan semua data dari tabel di mana semua ini dihasilkan.  Hasilnya benar-benar tidak menarik: <br><br><img src="https://habrastorage.org/webt/r5/st/ax/r5staxao_opewadzu9wavch_w6w.png"><br><br>  Perhatikan permintaan itu.  Kami memilih semuanya dari tabel yang tidak dipartisi, terhubung ke yang dipartisi.  Kami mengambil sepotong kecil dan hanya memilih satu jenis, mereka pergi melalui satu.  Kami menunjukkan bahwa kolom oss harus memiliki satu nilai.  Ternyata pilihan driver solid. <br><br>  Pada eksekusi, kami secara khusus menonaktifkan paralelisasi, karena PostgreSQL 11 secara default sangat memparalelkan kueri yang kurang lebih kompleks.  Jika kita melihat rencana pelaksanaan (menjelaskan analisis), maka dapat dilihat bahwa sistem menambahkan data di kedua bagian: di pengasuh dan di driver, meskipun pengasuh tidak ada di sana.  Tidak ada panggilan ke buffer.  Waktu yang dihabiskan, syarat digunakan, meskipun PostgreSQL bisa memikirkan semuanya.  Yaitu, deklarasi penghapusan partisi tidak berfungsi segera.  Mungkin di build berikutnya ini akan diperbaiki.  Dalam hal ini, modul pg_pathman dalam kasus ini berfungsi tanpa masalah. <br><br><a name="3"></a><h3>  Indeks </h3><br><ul><li>  Optimasi penawaran dengan cara yang monoton, mis. B-tree.  Semua orang tahu bahwa ketika Anda memasukkan data yang tumbuh secara monoton, hasilnya tidak terlalu cepat.  Sekarang PostgreSQL dapat me-cache halaman akhir dengan cara khusus dan tidak pergi jauh dari root untuk menyisipkan.  Ini secara signifikan mempercepat pekerjaan. </li><li>  PostgreSQL 10 memungkinkan untuk menggunakan indeks hash karena mulai menggunakan WAL (tulis log depan).  Sebelumnya, kami mendapat nilai, membuka kunci halaman, mengembalikan nilainya.  Untuk nilai selanjutnya, Anda harus memblokir kembali halaman, kembali, membuka kunci, dan sebagainya.  Sekarang hash menjadi lebih cepat.  Ini memungkinkan Anda untuk memblokir halaman sekaligus untuk mengambil catatan dari indeks hash, mengembalikan semua nilai dari sana dan membukanya.  Sekarang ini diimplementasikan untuk HASH, GiST dan GIN.  Di masa depan, ini mungkin akan diterapkan untuk SP-GiST.  Tetapi untuk BRIN dengan logika min / max ini pada prinsipnya tidak dapat dilakukan. </li><li>  Jika Anda terbiasa membuat indeks fungsional, maka pembaruan HOT (Heap Only Tuple) secara efektif dinonaktifkan.  Ketika catatan diperbarui di PostgreSQL, salinan baru benar-benar dibuat, dan ini membutuhkan menempelkan ke semua indeks yang ada di tabel sehingga nilai baru menunjuk ke tuple baru.  Optimalisasi semacam itu telah diimplementasikan untuk waktu yang lama: jika pembaruan tidak mengubah bidang yang tidak termasuk dalam indeks, dan ada ruang kosong di halaman yang sama, maka indeks tidak diperbarui, dan dalam versi tuple lama, penunjuk ke versi baru diletakkan.  Ini memungkinkan Anda untuk sedikit mengurangi keparahan masalah dengan pembaruan.  Namun, pengoptimalan tersebut tidak berfungsi sama sekali jika Anda memiliki indeks fungsional.  Di PostgreSQL 11, itu mulai berfungsi.  Jika Anda membuat indeks fungsional dan memperbarui tupel yang tidak mengubah apa yang bergantung pada indeks fungsional, maka pembaruan HOT akan berfungsi. </li></ul><br><a name="4"></a><h3>  Meliputi Indeks </h3><br>  Fungsionalitas ini diimplementasikan oleh PostgresPro tiga tahun lalu, dan selama ini PostgreSQL mencoba menambahkannya.  Menutupi indeks berarti bahwa Anda dapat menambahkan kolom tambahan ke indeks unik, langsung di tuple indeks. <br><br>  Mengapa  Semua orang menyukai pemindaian hanya indeks untuk pekerjaan cepat mereka.  Untuk ini, indeks “penutup” bersyarat dibangun: <br><br><img src="https://habrastorage.org/webt/ep/s7/vf/eps7vfc5hddmnsu6occowc250kw.png" width="600"><br><br>  Tetapi pada saat yang sama, Anda perlu mempertahankan keunikan.  Oleh karena itu, dua indeks sedang dibangun, sempit dan lebar. <br>  Kerugiannya adalah bahwa ketika Anda menerapkan vakum, masukkan atau perbarui ke sebuah tabel, Anda harus memperbarui kedua indeks.  Jadi memasukkan ke dalam indeks adalah operasi yang lambat.  Dan indeks penutup akan memungkinkan untuk mengelola hanya satu indeks. <br><br>  Benar, ia memiliki beberapa keterbatasan.  Lebih tepatnya, manfaat yang mungkin tidak langsung dipahami.  Kolom c dan d dalam indeks buat pertama tidak harus berupa tipe skalar yang menentukan indeks b-tree.  Artinya, mereka belum tentu memiliki perbandingan yang lebih-kurang.  Itu bisa berupa poin atau poligon.  Satu-satunya hal adalah bahwa tuple harus kurang dari 2,7 Kb, karena tidak ada pemanggangan dalam indeks, tetapi Anda dapat memasukkan apa yang tidak dapat dibandingkan. <br><br>  Namun, di dalam indeks dengan kolom yang dijamin ini, tidak ada perhitungan yang dilakukan saat mencari.  Ini harus dilakukan dengan filter yang berdiri di atas indeks.  Di satu sisi, mengapa tidak menghitungnya di dalam indeks, di sisi lain, ini adalah panggilan fungsi tambahan.  Tapi semuanya tidak seseram kelihatannya. <br><br>  Nah, di samping itu, Anda dapat menambahkan kolom tertutup ini ke kunci utama. <br><br><a name="5"></a><h3>  SP GiST </h3><br>  Hanya sedikit orang yang menggunakan indeks ini karena ini cukup spesifik.  Namun demikian, menjadi mungkin untuk menyimpan di dalamnya tidak cukup apa yang dimasukkan.  Ini mengacu pada lossy - index, kompresi.  Ambil poligon sebagai contoh.  Sebagai gantinya, kotak pembatas dimasukkan ke dalam indeks, yaitu, persegi panjang minimum yang berisi poligon yang diinginkan.  Dalam hal ini, kami mewakili persegi panjang sebagai titik dalam ruang empat dimensi, dan kemudian kami bekerja dengan quad3 klasik, dalam ruang empat dimensi. <br><br>  Juga untuk SP-GiST memperkenalkan operasi "pencarian awalan".  Ini mengembalikan true jika satu baris adalah awalan dari yang lain.  Mereka memperkenalkannya bukan hanya seperti itu, tetapi demi permintaan seperti itu dengan dukungan untuk SP-GiST. <br><br> <code>SELECT * FROM table WHERE c ^@ „abc“</code> <br> <br>  Dalam b-tree ada batas 2,7 Kb per baris, tetapi SP-GiST tidak.  Benar, PostgreSQL memiliki batasan: nilai tunggal tidak boleh melebihi 1 GB. <br><br><a name="6"></a><h3>  Performa </h3><br><ul><li>  <b>Indeks hanya memindai bitmap telah muncul</b> .  Ini berfungsi sama dengan hanya memindai indeks klasik, kecuali bahwa itu tidak dapat menjamin pesanan apa pun.  Oleh karena itu, ini hanya berlaku untuk beberapa agregat seperti hitungan (*), karena bitmap tidak dapat mentransfer bidang dari indeks ke pelaksana.  Dia hanya bisa melaporkan fakta dari catatan yang memenuhi persyaratan. </li><li>  Inovasi berikutnya adalah <b>pembaruan Free Space Map selama penerapan ruang hampa udara</b> .  Sayangnya, tidak ada pengembang sistem yang bekerja dengan PostgreSQL berpikir bahwa perlu untuk menghapus di akhir tabel, jika tidak lubang, ruang yang tidak terisi akan muncul.  Untuk melacak ini, kami menerapkan FSM, yang memungkinkan kami untuk tidak memperbesar tabel, tetapi untuk memasukkan tuple ke dalam rongga.  Sebelumnya, ini dilakukan dengan ruang hampa, tetapi pada akhirnya.  Dan sekarang vakum mampu melakukan ini dalam proses, dan dalam sistem yang sarat muatan, ini membantu menjaga ukuran tabel tetap terkendali. </li><li>  <b>Kemungkinan untuk melewati pemindaian indeks selama eksekusi vakum</b> .  Faktanya adalah bahwa semua indeks PostgreSQL, menurut teori database, disebut sekunder.  Ini berarti bahwa indeks disimpan jauh dari tabel; petunjuk mengarah ke sana dari mereka.  Pemindaian indeks saja memungkinkan Anda untuk tidak melakukan lompatan langsung ini, tetapi mengambil langsung dari indeks.  Tetapi kekosongan, yang menghapus catatan, tidak dapat melihatnya dalam indeks dan memutuskan apakah akan menghapusnya atau tidak, hanya karena tidak ada data seperti itu dalam indeks.  Karena itu, vakum selalu dilakukan dalam dua lintasan.  Pertama, dia menelusuri tabel dan mencari tahu apa yang perlu dia hapus.  Kemudian ia pergi ke indeks yang terlampir pada tabel ini, menghapus catatan yang merujuk pada yang ditemukan, kembali ke tabel dan menghapus apa yang akan terjadi.  Dan tahap menuju ke indeks tidak selalu diperlukan. <br><br>  Jika sejak vakum terakhir tidak ada penghapusan atau pembaruan, maka Anda tidak memiliki catatan mati, Anda tidak perlu menghapusnya.  Dalam hal ini, Anda tidak dapat masuk ke indeks.  Ada seluk-beluk tambahan, b-tree tidak langsung menghapus halamannya, tetapi dalam dua lintasan.  Karena itu, jika Anda menghapus banyak data dalam tabel, maka Anda perlu melakukan vakum.  Tetapi jika Anda ingin membebaskan ruang dalam indeks, maka vakum dua kali. <br><br>  Seseorang akan terkejut, tabel apa ini yang tidak ada hapus atau perbarui?  Bahkan, banyak yang berurusan dengan ini, hanya saja tidak berpikir.  Ini adalah hanya tabel tambahan, di mana, misalnya, log ditambahkan.  Di dalamnya, penghapusan sangat jarang.  Dan ini sangat menghemat durasi vakum / autovacuum, mengurangi beban pada disk, penggunaan cache dan sebagainya. </li><li>  <b>Bersamaan melakukan transaksi kompetitif</b> .  Ini bukan inovasi, tetapi peningkatan.  Sekarang PostgreSQL mendeteksi bahwa ia akan melakukan sekarang, dan menunda komit dari transaksi saat ini, menunggu sisa komit.  Harap dicatat bahwa fitur ini tidak banyak berpengaruh jika Anda memiliki server kecil dengan 2-4 core. </li><li>  <b>postgres_fdw (Pembungkus Data Asing)</b> .  FDW adalah cara untuk menghubungkan sumber data eksternal sehingga terlihat seperti pasca-Kongres nyata.  postgres_fdw memungkinkan Anda untuk menghubungkan tabel dari instance tetangga ke instance Anda, dan itu akan terlihat seperti yang asli.  Sekarang salah satu batasan untuk memperbarui dan menghapus telah dihapus.  PostgreSQL sering dapat menebak bahwa Anda perlu mengirim data mentah.  Cara untuk mengeksekusi permintaan bergabung cukup sederhana: kita menjalankannya di mesin kita, kita menarik tabel dari instance menggunakan FDW, cari tahu kunci primer id yang perlu kita hapus, dan kemudian menerapkan pembaruan dan / atau menghapus, yaitu, data yang kita bolak-balik .  Sekarang mungkin untuk dilakukan.  Tentu saja, jika tabel berada pada mesin yang berbeda, ini tidak mudah, tetapi FDW memungkinkan Anda untuk membuat mesin jarak jauh melakukan operasi, dan kami hanya menunggu. </li><li>  <b>toast_tuple_target</b> .  Ada situasi ketika data sedikit melampaui batas setelah itu perlu bersulang, tetapi pada saat yang sama bersulang dari nilai-nilai tersebut tidak selalu menyenangkan.  Misalkan Anda memiliki batas 90 byte, dan Anda harus memasukkan 100. Anda harus mulai bersulang untuk 10 byte, tambahkan secara terpisah, maka ketika Anda memilih bidang ini Anda harus pergi ke indeks roti, mencari tahu di mana data yang diperlukan, pergi ke meja roti, kumpulkan dan beri. </li></ul><br>  Sekarang dengan bantuan fine-tuning Anda dapat mengubah perilaku ini untuk seluruh database atau tabel terpisah sehingga keluar kecil seperti itu tidak memerlukan penggunaan roti panggang.  Tetapi Anda harus memahami apa yang Anda lakukan, tanpa ini, tidak ada yang akan berhasil. <br><br><a name="7"></a><h3>  WAL </h3><br><ul><li>  WAL (Tulis log depan) adalah log tulis depan.  Ukuran segmen WAL sekarang diatur di initdb.  Syukurlah, tidak saat menyusun. </li><li>  Logikanya juga telah berubah.  Sebelumnya, himpunan segmen WAL diselamatkan dari saat pos pemeriksaan kedua dari belakang, dan sekarang dari yang terakhir.  Ini secara signifikan dapat mengurangi jumlah data yang disimpan.  Tetapi jika Anda memiliki database 1 TB, dan TPS = 1, yaitu, satu permintaan per detik, maka Anda tidak akan melihat perbedaannya. </li></ul><br><a name="8"></a><h3>  Cadangkan dan replikasi </h3><br><ul><li>  <b>Truncate muncul dalam replikasi logis</b> .  Itu adalah operasi DML terakhir yang tidak tercermin dalam replikasi logis.  Sekarang tercermin. </li><li>  <b>Pesan tentang persiapan muncul dalam replikasi logis</b> .  Sekarang Anda dapat menangkap persiapan transaksi, komitmen dua fase dalam replikasi logis.  Ini diimplementasikan untuk pembangunan cluster - heterogen, homogen, sharded dan tidak berbayang, multimaster dan sebagainya. </li><li>  <b>Pengecualian dari pg_basebackup tabel sementara dan tidak masuk log</b> .  Banyak yang mengeluh bahwa pg_basebackup menyertakan tabel yang tercantum.  Dan tidak termasuk mereka, kami mengurangi ukuran cadangan.  Tetapi asalkan Anda menggunakan tabel sementara dan tidak masuk log, jika tidak, opsi ini tidak akan berguna bagi Anda. </li><li>  <b>Kontrol Checksumma dalam replikasi streaming (untuk tabel)</b> .  Ini memungkinkan Anda untuk memahami apa yang terjadi pada replika Anda.  Sejauh ini, fungsi hanya diterapkan untuk tabel. </li><li>  <b>Ada promosi posisi slot replikasi</b> .  Seperti biasa, Anda hanya bisa bergerak maju, mundur hanya jika ada WAL.  Selain itu, Anda perlu memahami dengan baik apa yang Anda lakukan dengannya dan mengapa.  Menurut pendapat saya, ini lebih merupakan opsi pengembangan, tetapi mereka yang menggunakan replikasi logis untuk beberapa aplikasi eksotis dapat menikmatinya. </li></ul><br><a name="9"></a><h3>  Untuk dba </h3><br><ul><li>  <b>Ubah tabel, tambahkan kolom, bukan nol standar X</b> , tulis seluruh tabel.  Ada sedikit biaya untuk ini: nilai default disimpan secara terpisah.  Jika Anda mengambil tuple dan membutuhkan kolom ini, maka PostgreSQL terpaksa mengikuti jalur pengkodean tambahan untuk menarik nilai sementara, gantilah dalam tuple dan berikan kepada Anda.  Namun demikian, seseorang dapat hidup dengannya. </li><li>  <b>Vakum / analisis</b> .  Sebelumnya, Anda hanya bisa menerapkan kekosongan atau analisis ke seluruh database atau tabel tunggal.  Sekarang dimungkinkan untuk melakukan ini ke beberapa tabel, dengan satu perintah. </li></ul><br><a name="10"></a><h3>  Eksekusi paralel </h3><br><ul><li>  <b>Konstruksi paralel indeks b-tree</b> .  Dalam versi 11, menjadi mungkin untuk menanamkan indeks b-tree di beberapa pekerja.  Jika Anda memiliki mesin yang sangat bagus, banyak cakram dan banyak inti, maka Anda dapat membuat indeks secara paralel, ini menjanjikan peningkatan kinerja yang nyata. </li><li>  <b>Hash koneksi paralel menggunakan tabel hash bersama untuk pelaksana</b> .    ,           -.   ,     .   - ,     .     . </li><li>  , <b>      union, create table as, select  create materialized view!</b> </li><li> - <b>   (limit)   </b> .    . </li></ul><br>    : <br><br> <code>alter table usr reset (parallel_workers) <br> create index on usr(lower((so).occ)) — 2  <br> alter table usr set (parallel_workers=2) <br> create index on usr(upper((so).occ)) — 1.8 </code> <br> <br>     parallel worker.        .     16    4  (    )      2 .,    — 1,8 .     ,   ,     .  ,         . <br><br>     : <br><br> <code>explain analyze <br> select u1.* from usr u, usr1 u1 where <br> u.id=u1.id+0</code> <br> <br>     ,      . , user —   ,    .     .    ,      ,   . <br><br>     ,   PostgreSQL 11           . <br><br><img src="https://habrastorage.org/webt/a4/si/tw/a4sitw7cyqsulcovvmv--yueczs.png"><br><br>    1425 ,  1,5 .    1,4 .  2  .  ,   9.6   : 1      —  1 .,   2   1 .    ,    10    tuple.    11    .       :      user,   batch,    x-scan      append   . <br><br>    : <br><br><img src="https://habrastorage.org/webt/7f/rx/2h/7frx2hwdbaxaq4asujz7aembelq.png"><br><br>   .         211 ,   702 .   ,    510     1473.    ,      2  . <br><br>     parallel hash join.       .     — 4.     ,     . <br><br>   parallel index scan    .     batch  .   ?        hash join,         .  user    .        ,  parallel hash,   . <br><br>     1 .  ,       OLAP-,  OLTP  .    OLTP  ,      . <br><br><a name="11"></a><h3>  </h3><br>      . <br><br><ul><li>       .   ,            .      ,    «»   «»,     index scan,     .    (highly skewed data),         ,    .      .    ,    ,    . </li><li>       «»,   . </li></ul><br><a name="12"></a><h3> Window- </h3><br>     SQL:2011,      . <br><br><a name="13"></a><h3>     </h3><br>   ,      ,    . ,   ,    ,  ,    ,    . <br><br>   websearch,     .      ,     .        ,   . <br><br> <code># select websearch_to_tsquery('dog or cat'); <br> ---------------------- <br> 'dor' | 'cat' <br> # select websearch_to_tsquery('dog -cat'); <br> ---------------------- <br> 'dor' &amp; !'cat' <br> # select websearch_to_tsquery('or cat'); <br> ---------------------- <br> 'cat'</code> <br> <br>   — dog or cat —   . Websearch      .     |  ,       .    “or cat”.   ,   .    websearch  “or”  .  ,    -,    . <br><br> Websearch —     .       :        ,   .     ,   . <br><br><a name="14"></a><h3> Json(b)   </h3><br>  10-     ,   11-     .    json  json(b),   tsvector.   ( json(b))  -  .      ,    ,   ,  bull, numeric, string, .     . <br><br> <code># select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '"string"'); <br> ------------------- <br> 'text':1 <br> # select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '["string", "numeric"]'); <br> ------------------- <br> '12':3 'text':1</code> <br> <br>     json(b),        .      ,   ,   ,   . <br><br><a name="15"></a><h3> PL/*  </h3><br>     . <br><br> <code>CREATE PROCEDURE transaction_test1() <br> LANGUAGE plpgsql <br> AS $$ <br> BEGIN <br> FOR i IN 0..9 LOOP <br> INSERT INTO test1 (a) VALUES (i); <br> IF i % 2 = 0 THEN <br> COMMIT; <br> ELSE <br> ROLLBACK; <br> END IF; <br> END LOOP; <br> END <br> $$; <br> CALL transaction_test1();</code> <br> <br>      call,       ,         .        .     .      select, insert   . <br><br>    ,    ,   PostgreSQL    .    Perl, Python, TL  PL/pgSQL.    Perl    sp begin,         . <br><br> PL/pgSQL    :    ,    . <br><br><a name="16"></a><h3> pgbench </h3><br>     pgbench  ICSB bench — ,   ,       .    if,     ,     .  case,       - .   <code>--init-steps</code> ,    ,   . <br><br>         random-seed.   zipfian- .    / —   ,      .   -    ,      ,  - ,  . <br><br> ,  ,    - . <br><br><a name="17"></a><h3>  PSQL </h3><br>  ,    PSQL,        .    exit  quit. <br><br><ul><li>   —    copy,      2 <sup>32</sup> .  copy      :      2 <sup>32</sup> - . ,     2 <sup>31</sup>  2 <sup>32</sup> copy     .    64-  ,      2 <sup>64</sup> . </li><li>  POSIX  :   NaN <sup>0</sup> = 1  1 <sup>NaN</sup> = 1. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414031/">https://habr.com/ru/post/id414031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414019/index.html">Solusi universal untuk UITableViewRowAction dan UIContextualAction</a></li>
<li><a href="../id414023/index.html">Tanyakan Ethan: Seberapa cepat kehidupan dapat muncul di alam semesta?</a></li>
<li><a href="../id414025/index.html">Pengusaha melacak komputer, toilet, dan sekarang emosi juga; Apakah bos Anda mengikuti Anda?</a></li>
<li><a href="../id414027/index.html">Bisakah teman saya dianggap teman sejati?</a></li>
<li><a href="../id414029/index.html">Cahaya misterius di sekitar bintang yang baru terbentuk, dan apa pendapat para astronom tentang itu</a></li>
<li><a href="../id414037/index.html">Sekali di sebuah perusahaan HFT ...</a></li>
<li><a href="../id414039/index.html">Kisah-kisah tentang awan</a></li>
<li><a href="../id414041/index.html">Di musim dingin dan musim panas dalam satu warna? Cari data musiman</a></li>
<li><a href="../id414049/index.html">Permainan utama E3 2018: Fallout 76, Metro Exodus, Doom Eternal, dan lainnya</a></li>
<li><a href="../id414053/index.html">5 kesalahpahaman tentang GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>