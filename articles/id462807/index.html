<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍆 🗄️ 🚷 WinForms: Kesalahan, Holmes ⛳️ 👩🏼‍🎨 🙆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami senang mencari bug di proyek Microsoft. Mengapa Ini sederhana: proyek mereka biasanya mudah diperiksa (pekerjaan dapat dilakukan segera di lingku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WinForms: Kesalahan, Holmes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/462807/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/aeb/a84/71baeba847a8865aef0cc8148effbb8c.png" alt="Gambar 5"></div><br>  Kami senang mencari bug di proyek Microsoft.  Mengapa  Ini sederhana: proyek mereka biasanya mudah diperiksa (pekerjaan dapat dilakukan segera di lingkungan Visual Studio, yang mana PVS-Studio memiliki plug-in yang nyaman) dan mereka mengandung beberapa kesalahan.  Oleh karena itu, algoritma pekerjaan yang biasa adalah sebagai berikut: cari dan unduh proyek terbuka dari MS;  lihat itu;  pilih kesalahan yang menarik;  pastikan jumlahnya sedikit;  menulis artikel tanpa lupa memuji pengembangnya.  Hebat!  Menang-menang-menang: butuh sedikit waktu, manual ini senang melihat materi baru di blog, dan karma dalam urutan yang sempurna.  Tapi kali ini ada yang tidak beres.  Mari kita lihat apa yang menarik ditemukan dalam kode sumber Formulir Windows dan apakah Microsoft harus dipuji saat ini. <br><a name="habracut"></a><br>  <b>Pendahuluan</b> <br><br>  Pada awal Desember 2018, Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengumumkan</a> rilis .NET Core 3 Preview 1. Sedikit lebih awal (kira-kira dari pertengahan Oktober), GitHub mulai bekerja aktif pada publikasi kode sumber untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Windows Forms</a> , platform .NET Core UI untuk membuat aplikasi desktop Windows.  Anda dapat melihat statistik komit di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Sekarang siapa pun dapat mengunduh kode sumber WinForms untuk ditinjau. <br><br>  Saya juga mengunduh sumber untuk mencari kesalahan di sana menggunakan PVS-Studio.  Cek tidak menimbulkan kesulitan.  Diperlukan: Visual Studio 2019, .NET Core 3.0 SDK Preview, PVS-Studio.  Dan sekarang log peringatan penganalisa diterima. <br><br>  Setelah menerima log PVS-Studio, saya biasanya mengurutkannya dalam urutan nomor diagnostik (jendela dengan log pesan PVS-Studio di Visual Studio memiliki berbagai opsi untuk menyortir dan memfilter daftar).  Ini memungkinkan Anda untuk bekerja dengan kelompok kesalahan dari jenis yang sama, yang sangat menyederhanakan analisis kode sumber.  Saya menandai kesalahan menarik dalam daftar dengan tanda bintang, dan hanya setelah itu, setelah menganalisis seluruh log, saya menulis fragmen kode dan membuat deskripsi.  Dan karena biasanya ada beberapa kesalahan, saya mencampurnya, mencoba untuk menempatkan yang paling menarik di awal dan akhir artikel.  Tapi kali ini, kesalahannya ternyata agak banyak (eh, itu tidak mungkin untuk menyimpan intrik untuk waktu yang lama), dan saya akan membawanya sesuai urutan nomor diagnostik. <br><br>  Apa yang ditemukan?  833 peringatan dari tingkat kepercayaan Tinggi dan Menengah (249 dan 584, masing-masing) dikeluarkan untuk 540.000 baris kode (tidak termasuk yang kosong) dalam 1670 file cs.  Dan ya, menurut tradisi, saya tidak memeriksa tes dan tidak mempertimbangkan peringatan tingkat kepercayaan rendah (215 dikeluarkan).  Menurut pengamatan saya sebelumnya, ada terlalu banyak peringatan untuk proyek dari MS.  Tetapi tidak semua peringatan adalah kesalahan. <br><br>  Untuk proyek ini, jumlah positif palsu sekitar 30%.  Dalam sekitar 20% kasus, saya tidak bisa membuat kesimpulan yang pasti tentang apakah ini kesalahan atau tidak, karena saya tidak begitu mengenal kode itu.  Ya, setidaknya 20% dari kesalahan yang saya lewatkan dapat dikaitkan dengan faktor manusia: tergesa-gesa, kelelahan, dll.  Ngomong-ngomong, efek sebaliknya juga mungkin: Saya melihat melalui beberapa jenis pemicu yang sama, yang jumlahnya bisa mencapai 70-80, melalui yang kadang-kadang dapat meningkatkan jumlah kesalahan yang saya anggap nyata. <br><br>  Dalam kasus apa pun, 30% peringatan menunjukkan kesalahan nyata, yang merupakan persentase yang sangat besar, mengingat bahwa alat analisa belum dikonfigurasikan sebelumnya. <br><br>  Jadi, jumlah kesalahan yang bisa saya deteksi adalah sekitar 240, yang berada dalam batas statistik.  Saya ulangi, menurut pendapat saya, untuk proyek dari MS ini bukan hasil yang paling luar biasa (meskipun ini hanya akan 0,44 kesalahan per 1000 baris kode), dan mungkin ada lebih banyak kesalahan nyata dalam kode WinForms.  Saya mengusulkan untuk membicarakan alasan di akhir artikel, tetapi sekarang mari kita lihat kesalahan yang paling menarik. <br><br>  <b>Kesalahan</b> <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3003</a> Penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pola</a> 'if (A) {...} else if (A) {...}' terdeteksi.  Ada kemungkinan kehadiran kesalahan logis.  Periksa baris: 213, 224. ButtonStandardAdapter.cs 213 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PaintWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PaintEventArgs e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> up, CheckState state)</span></span></span><span class="hljs-function"> </span></span>{ up = up &amp;&amp; state == CheckState.Unchecked; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } .... }</code> </pre> <br>  Dalam <i>jika</i> dan <i>jika</i> blok, kondisi yang sama diperiksa.  Sepertinya copy-paste.  Apakah ini sebuah kesalahan?  Jika Anda melihat deklarasi metode <i>IsHighContrastHighlighted</i> , ada keraguan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsHighContrastHighlighted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SystemInformation.HighContrast &amp;&amp; Application.RenderWithVisualStyles &amp;&amp; (Control.Focused || Control.MouseIsOver || (Control.IsDefault &amp;&amp; Control.Enabled)); }</code> </pre> <br>  Metode ini mungkin dapat mengembalikan nilai yang berbeda dalam panggilan yang berurutan.  Dan apa yang dilakukan dalam metode pemanggilan tampak aneh, tentu saja, tetapi ia memiliki hak untuk hidup.  Namun, saya akan menyarankan para penulis untuk melihat potongan kode ini.  Untuk jaga-jaga.  Namun, ini adalah contoh yang baik tentang betapa sulitnya untuk menarik kesimpulan ketika menganalisis kode asing. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3004</a> Pernyataan 'then' setara dengan pernyataan 'else'.  RichTextBox.cs 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SelectionCharOffset { get { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selCharOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... NativeMethods.CHARFORMATA cf = GetCharFormat(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if the effects member contains valid info if ((cf.dwMask &amp; RichTextBoxConstants.CFM_OFFSET) != 0) { selCharOffset = cf.yOffset; // &lt;= } else { // The selection contains characters of different offsets, // so we just return the offset of the first character. selCharOffset = cf.yOffset; // &lt;= } .... } .... }</span></span></code> </pre> <br>  Dan di sini kesalahan copy-paste pasti dibuat.  Terlepas dari kondisinya, variabel <i>selCharOffset akan</i> selalu mendapatkan nilai yang sama. <br><br>  Ada dua kesalahan serupa dalam kode WinForms: <ul><li>  V3004 Pernyataan 'lalu' setara dengan pernyataan 'lain'.  SplitContainer.cs 1700 </li><li>  V3004 Pernyataan 'lalu' setara dengan pernyataan 'lain'.  ToolstripProfessionalRenderer.cs 371 </li></ul><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3008</a> Variabel diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 681, 680. ProfessionalColorTable.cs 681 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSystemColors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Dictionary&lt;KnownColors, Color&gt; rgbTable)</span></span></span><span class="hljs-function"> </span></span>{ .... rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonFace; rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonShadow; .... }</code> </pre> <br>  Metode mengisi kamus <i>rgbTable</i> .  Alat analisis menunjuk ke sepotong kode di mana dua nilai berbeda ditulis secara berurutan pada kunci yang sama.  Dan semuanya akan baik-baik saja, tetapi ada 16 tempat seperti itu dalam metode ini. Ini tidak lagi terlihat seperti satu kesalahan.  Tetapi mengapa melakukan ini, bagi saya itu tetap menjadi misteri.  Saya tidak menemukan tanda-tanda kode autogenerated.  Di editor, ini terlihat seperti ini: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/006/f68/827/006f688275da3701f28abe7918835ce9.png" alt="Gambar 3"></div><br>  Saya akan memberikan sepuluh operasi pertama dengan daftar: <br><br><ol><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 785, 784. ProfessionalColorTable.cs 785 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 787, 786. ProfessionalColorTable.cs 787 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 789, 788. ProfessionalColorTable.cs 789 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 791, 790. ProfessionalColorTable.cs 791 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 797, 796. ProfessionalColorTable.cs 797 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 799, 798. ProfessionalColorTable.cs 799 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 807, 806. ProfessionalColorTable.cs 807 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 815, 814. ProfessionalColorTable.cs 815 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 817, 816. ProfessionalColorTable.cs 817 </li><li>  V3008 Variabel ini diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 823, 822. ProfessionalColorTable.cs 823 </li></ol><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3011</a> Dua kondisi yang berlawanan ditemui.  Kondisi kedua selalu salah.  Periksa baris: 5242, 5240. DataGrid.cs 5242 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHierarchyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkHierarchy &amp;&amp; listManager != null &amp;&amp; myGridTable != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myGridTable == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { // there was nothing to check return; } for (int j = 0; j &lt; myGridTable.GridColumnStyles.Count; j++) { DataGridColumnStyle gridColumn = myGridTable.GridColumnStyles[j]; } checkHierarchy = false; } }</span></span></code> </pre> <br>  <i>Pernyataan pengembalian</i> tidak akan pernah dieksekusi.  Kemungkinan besar, kondisi <i>myGridTable! = Null</i> di eksternal <i>jika</i> blok ditambahkan kemudian selama refactoring.  Dan sekarang memeriksa <i>myGridTable == null tidak</i> ada gunanya.  Untuk meningkatkan kualitas kode, hapus centang ini. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3019</a> Mungkin variabel yang salah dibandingkan dengan nol setelah konversi jenis menggunakan kata kunci 'sebagai'.  Periksa variabel 'kiri', 'cscLeft'.  TypeCodeDomSerializer.cs 611 <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3019</a> Mungkin variabel yang salah dibandingkan dengan nol setelah konversi jenis menggunakan kata kunci 'sebagai'.  Periksa variabel 'benar', 'cscRight'.  TypeCodeDomSerializer.cs 615 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object left, object right)</span></span></span><span class="hljs-function"> </span></span>{ OrderedCodeStatementCollection cscLeft = left as OrderedCodeStatementCollection; OrderedCodeStatementCollection cscRight = right as OrderedCodeStatementCollection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == left) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cscLeft.Order - cscRight.Order; <span class="hljs-comment"><span class="hljs-comment">// &lt;= }</span></span></code> </pre> <br>  Penganalisa segera mengeluarkan dua peringatan untuk metode <i>Bandingkan</i> .  Apa masalahnya?  Ini adalah bahwa nilai-nilai <i>cscLeft</i> dan <i>cscRight</i> tidak diperiksa untuk kesetaraan <i>nol</i> .  Mereka bisa mendapatkan nilai ini setelah melakukan pengecoran yang gagal ke jenis <i>OrderedCodeStatementCollection</i> .  Maka pengecualian akan dilemparkan dalam <i>pernyataan pengembalian</i> terakhir.  Situasi seperti ini dimungkinkan ketika semua memeriksa lulus <i>kiri</i> dan <i>kanan</i> dan tidak mengarah ke jalan keluar awal dari metode. <br><br>  Untuk memperbaiki kodenya, <i>cscLeft</i> / <i>cscRight</i> harus digunakan di <i>mana-mana</i> alih-alih dari <i>kiri</i> / <i>kanan</i> . <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3020</a> 'istirahat' tanpa syarat dalam satu lingkaran.  SelectionService.cs 421 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISelectionService.SetSelectedComponents( ICollection components, SelectionTypes selectionType) { .... <span class="hljs-comment"><span class="hljs-comment">// Handle the click case object requestedPrimary = null; int primaryIndex; if (fPrimary &amp;&amp; 1 == components.Count) { foreach (object o in components) { requestedPrimary = o; if (o == null) { throw new ArgumentNullException(nameof(components)); } break; } } .... }</span></span></code> </pre> <br>  Fragmen ini merujuk, lebih tepatnya, ke kode "dengan bau".  Tidak ada kesalahan di sini.  Tetapi muncul pertanyaan tentang bagaimana siklus <i>pendahuluan</i> diatur.  Mengapa diperlukan di sini - jelas: karena kebutuhan untuk mengekstrak elemen koleksi, dinyatakan sebagai <i>ICollection</i> .  Tetapi mengapa dalam loop, awalnya dirancang untuk iterasi tunggal (prasyarat adalah kehadiran elemen tunggal dalam koleksi <i>komponen</i> ), jaring pengaman tambahan dalam bentuk <i>istirahat</i> diperlukan?  Mungkin, jawabannya dapat dipertimbangkan: "Sudah berkembang secara historis."  Kode terlihat jelek. <br><br>  PVS-Studio: Ekspresi V3022 'ocxState! = Null' selalu benar.  AxHost.cs 2186 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State OcxState { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... ocxState = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ocxState != null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { axState[manualUpdate] = ocxState._GetManualUpdate(); licenseKey = ocxState._GetLicenseKey(); } else { axState[manualUpdate] = false; licenseKey = null; } .... } }</span></span></code> </pre> <br>  Karena kesalahan logis, "kode mati" dibentuk dalam fragmen ini.  Ekspresi di blok <i>lain</i> tidak akan pernah dieksekusi. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3027</a> Variabel 'e' digunakan dalam ekspresi logis sebelum diverifikasi terhadap nol dalam ekspresi logis yang sama.  ImageEditor.cs 99 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... ImageEditor e = ....; Type myClass = GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!myClass.Equals(e.GetType()) &amp;&amp; e != null &amp;&amp; myClass.IsInstanceOfType(e)) { .... } .... }</code> </pre> <br>  Variabel <i>e</i> dalam kondisi ini pertama kali digunakan dan kemudian diperiksa untuk ketimpangan <i>nol</i> .  Hai, <i>NullReferenceException</i> . <br><br>  Kesalahan serupa lainnya: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3027</a> Variabel 'dropDownItem' digunakan dalam ekspresi logis sebelum diverifikasi terhadap nol dalam ekspresi logis yang sama.  ToolStripMenuItemDesigner.cs 1351 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterInSituEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ToolStripItem toolItem)</span></span></span><span class="hljs-function"> </span></span>{ .... ToolStripDropDownItem dropDownItem = toolItem as ToolStripDropDownItem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dropDownItem.Owner is ToolStripDropDownMenu) &amp;&amp; dropDownItem != null &amp;&amp; dropDownItem.Bounds.Width &lt; commitedEditorNode.Bounds.Width) { .... } .... }</code> </pre> <br>  Situasi yang mirip dengan yang sebelumnya, hanya dengan variabel <i>dropDownItem</i> .  Saya pikir kesalahan seperti itu muncul sebagai akibat dari kurangnya perhatian selama refactoring.  Mungkin bagian dari kondisinya <i>! (DropDownItem.Owner adalah ToolStripDropDownMenu)</i> ditambahkan ke kode nanti. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3030</a> Pemeriksaan berulang.  Kondisi 'kolomCount&gt; 0' sudah diverifikasi di baris 3900. ListView.cs 3903 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal ColumnHeader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ColumnHeader ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refreshSubItems)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Add the column to our internal array int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length); if (columnCount &gt; 0) { ColumnHeader[] newHeaders = new ColumnHeader[columnCount + 1]; if (columnCount &gt; 0) { System.Array.Copy(columnHeaders, 0, newHeaders, 0, columnCount); } .... } .... }</span></span></code> </pre> <br>  Kesalahan yang mungkin tampak tidak berbahaya.  Memang, well, pemeriksaan ekstra dilakukan, yang tidak mempengaruhi logika kerja.  Dan kadang-kadang mereka bahkan melakukannya ketika Anda perlu memeriksa kembali status komponen visual, misalnya, dengan mendapatkan jumlah entri dalam daftar.  Hanya dalam kasus ini, mereka memeriksa ulang kolom Variabel <i>lokal</i> .  Ini sangat mencurigakan.  Entah mereka ingin memeriksa variabel lain, atau di salah satu cek mereka menggunakan kondisi yang salah. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3061</a> Parameter 'lprcClipRect' selalu ditulis ulang dalam tubuh metode sebelum digunakan.  WebBrowserSiteBase.cs 281 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext( out UnsafeNativeMethods.IOleInPlaceFrame ppFrame, out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) { ppDoc = null; ppFrame = Host.GetParentContainer(); lprcPosRect.left = Host.Bounds.X; lprcPosRect.top = Host.Bounds.Y; .... lprcClipRect = WebBrowserHelper.GetClipRect(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (lpFrameInfo != null) { lpFrameInfo.cb = Marshal.SizeOf&lt;NativeMethods.tagOIFI&gt;(); lpFrameInfo.fMDIApp = false; .... } return NativeMethods.S_OK; }</span></span></code> </pre> <br>  Kesalahan yang tidak terlihat.  Ya, parameter <i>lprcClipRect</i> benar <i>-</i> benar diinisialisasi dengan nilai baru, tanpa menggunakannya dengan cara apa pun.  Tetapi apa akibatnya ini?  Saya pikir di suatu tempat di kode panggilan, tautan yang melewati parameter ini akan tetap tidak berubah, meskipun itu dimaksudkan secara berbeda.  Memang, lihat bekerja dengan variabel lain dalam metode ini.  Bahkan namanya (awalan "Get") mengisyaratkan bahwa beberapa inisialisasi akan dibuat di dalam metode melalui parameter yang diteruskan.  Begitulah.  Dua parameter pertama ( <i>ppFrame</i> dan <i>ppDoc</i> ) dilewatkan dengan pengubah <i>keluar</i> dan mendapatkan nilai baru.  Tautan <i>lprcPosRect</i> dan <i>lpFrameInfo</i> digunakan untuk mengakses bidang kelas dan menginisialisasi mereka.  Dan hanya <i>lprcClipRect yang</i> keluar dari daftar umum.  Kemungkinan besar, pengubah <i>out</i> atau <i>ref</i> diperlukan untuk parameter ini. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3066</a> Kemungkinan urutan argumen yang salah diteruskan ke metode 'AdjustCellBorderStyle': 'isFirstDisplayedRow' dan 'isFirstDisplayedColumn'.  DataGridViewComboBoxCell.cs 1934 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataGridViewCellMouseEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ .... dgvabsEffective = AdjustCellBorderStyle( DataGridView.AdvancedCellBorderStyle, dgvabsPlaceholder, singleVerticalBorderAdded, singleHorizontalBorderAdded, isFirstDisplayedRow, <span class="hljs-comment"><span class="hljs-comment">// &lt;= isFirstDisplayedColumn); // &lt;= .... }</span></span></code> </pre> <br>  Penganalisa curiga bahwa dua argumen terakhir tercampur aduk.  Mari kita lihat deklarasi metode <i>AdjustCellBorderStyle</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> DataGridViewAdvancedBorderStyle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustCellBorderStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataGridViewAdvancedBorderStyledataGridViewAdvancedBorderStyleInput, DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleVerticalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleHorizontalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedColumn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedRow)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br>  Tampak seperti kesalahan.  Ya, sering beberapa argumen disengaja secara terbalik, misalnya, untuk menukar beberapa variabel.  Tetapi saya tidak berpikir bahwa inilah masalahnya.  Tidak ada dalam pemanggilan atau metode dipanggil mengatakan pola penggunaan seperti itu.  Pertama, variabel tipe <i>bool</i> bingung.  Kedua, nama-nama metode juga umum: tidak ada "Swap" atau "Reverse".  Lagipula, tidak begitu sulit untuk melakukan kesalahan seperti itu.  Orang sering merasakan urutan pasangan baris / kolom berbeda.  Bagi saya, misalnya, hanya "baris / kolom" sudah biasa.  Tetapi bagi penulis metode <i>AdjustCellBorderStyle yang</i> disebut, jelas, urutan yang lebih akrab adalah "kolom / baris". <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3070</a> Variabel tidak diinisialisasi 'LANG_USER_DEFAULT' digunakan ketika menginisialisasi variabel 'LOCALE_USER_DEFAULT'.  NativeMethods.cs 890 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); .... }</code> </pre> <br>  Kesalahan langka.  Urutan inisialisasi bidang kelas dicampur.  Untuk menghitung nilai bidang <i>LOCALE_USER_DEFAULT</i> , gunakan bidang <i>LANG_USER_DEFAULT</i> , yang belum diinisialisasi dan memiliki nilai 0. By the way, variabel <i>LANG_USER_DEFAULT</i> tidak digunakan di tempat lain dalam kode.  Saya tidak terlalu malas dan menulis program konsol kecil yang mensimulasikan situasi.  Alih-alih nilai dari beberapa konstanta yang digunakan dalam kode WinForms, saya menggantikan nilai aktualnya: <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELANGID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> primary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sub)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((((ushort)(sub)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | (ushort)(primary)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAKELCID(lgid, <span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sort)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &amp; lgid) | (((<span class="hljs-number"><span class="hljs-number">0x000f</span></span>) &amp; sort) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.Console.WriteLine(NativeMethods.LOCALE_USER_DEFAULT); } }</code> </pre> <br>  Sebagai hasil dari peluncuran, berikut ini akan ditampilkan pada konsol: 0. Sekarang kita menukar deklarasi bidang <i>LOCALE_USER_DEFAULT</i> dan <i>LANG_USER_DEFAULT</i> .  Hasil program dalam bentuk ini: 1024. Saya pikir tidak ada lagi yang perlu dikomentari di sini. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'ces'.  CodeDomSerializerBase.cs 562 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IDesignerSerializationManager manager, CodeStatement statement)</span></span></span><span class="hljs-function"> </span></span>{ .... CodeExpressionStatement ces = statement as CodeExpressionStatement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ces != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... DeserializeExpression(manager, null, ces.Expression); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } .... }</span></span></code> </pre> <br>  Kode yang harus "jatuh" cukup stabil, karena Anda bisa masuk ke cabang <i>lain</i> tepat ketika referensi <i>ces</i> adalah <i>nol</i> . <br><br>  Contoh serupa lainnya: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'kotak kombo'.  ComboBox.cs 6610 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateOwnerDrawRegions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ComboBox comboBox, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comboBox != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Rectangle topOwnerDrawArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, comboBox.Width, innerBorder.Top); .... }</code> </pre> <br>  Kode paradoks.  Rupanya, mereka mencampuradukkan tes dengan menulis <i>jika (comboBox! = Null)</i> bukannya <i>if (comboBox == null)</i> .  Maka - kami akan menerima <i>NullReferenceException</i> berikutnya. <br><br>  Kami memeriksa dua kesalahan yang cukup jelas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> , di mana Anda dapat secara visual melacak situasi kemungkinan penggunaan referensi nol dalam metode ini.  Tetapi diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> jauh lebih cerdas dan dapat mencari kesalahan serupa untuk rangkaian panggilan metode.  Belum lama ini, kami secara signifikan memperkuat mekanisme aliran data dan analisis antar-prosedur.  Anda dapat membaca tentang ini di artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenis Referensi Nullable dalam C # 8.0 dan Analisis Statis</a> ".  Dan di sini ada kesalahan serupa yang ditemukan di WinForms: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan ada null dereference di dalam metode di 'reader.NameTable'.  Pertimbangkan memeriksa argumen 1: contentReader.  ResXResourceReader.cs 267 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnsureResData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... XmlTextReader contentReader = null; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileContents != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reader != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileName != null || stream != null) { .... contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } SetupNameTable(contentReader); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } finally { .... } .... }</span></span></code> </pre> <br>  Lihat apa yang terjadi dengan <i>contentReader</i> variabel di tubuh metode.  Setelah inisialisasi dengan referensi nol, sebagai hasil dari salah satu pemeriksaan, tautan akan diinisialisasi.  Namun, serangkaian cek tidak berakhir dengan blok <i>lain</i> .  Ini berarti bahwa dalam beberapa kasus yang jarang terjadi (atau karena refactoring di masa depan), tautan masih dapat tetap nol.  Selanjutnya, itu akan diteruskan ke metode <i>SetupNameTable</i> , di mana ia digunakan tanpa verifikasi: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupNameTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlReader reader)</span></span></span><span class="hljs-function"> </span></span>{ reader.NameTable.Add(ResXResourceWriter.TypeStr); reader.NameTable.Add(ResXResourceWriter.NameStr); .... }</code> </pre> <br>  Ini berpotensi kode tidak aman. <br><br>  Dan satu kesalahan lagi, di mana penganalisa harus melalui serangkaian panggilan untuk mengidentifikasi masalah: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'tata letak'.  DockAndAnchorLayout.cs 156 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Rectangle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IArrangedElement element, Rectangle displayRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureOnly)</span></span></span><span class="hljs-function"> </span></span>{ .... AnchorInfo layout = GetAnchorInfo(element); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = layout.Left + displayRect.X; .... }</code> </pre> <br>  Penganalisa mengklaim bahwa adalah mungkin untuk mendapatkan referensi nol dari metode <i>GetAnchorInfo</i> , yang akan menghasilkan pengecualian saat menghitung nilai <i>kiri</i> .  Mari kita telusuri seluruh rantai panggilan dan periksa apakah ini benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnchorInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IArrangedElement element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (AnchorInfo)element.Properties.GetObject(s_layoutInfoProperty); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>=&gt; GetObject(key, out _); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> found)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> keyIndex = SplitKey(key, out <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LocateObjectEntry(keyIndex, out <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index)) { found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-comment"><span class="hljs-comment">// We have found the relevant entry. See if // the bitmask indicates the value is used. if (((1 &lt;&lt; element) &amp; s_objEntries[index].Mask) == 0) { found = false; return null; } found = true; switch (element) { case 0: return s_objEntries[index].Value1; .... default: Debug.Fail("Invalid element obtained from LocateObjectEntry"); return null; } }</span></span></code> </pre> <br>  Memang, dalam beberapa kasus, metode <i>GetObject</i> yang menutup rantai panggilan akan kembali <i>nol</i> , yang tanpa pemeriksaan tambahan akan diteruskan ke metode panggilan.  Mungkin, metode <i>GetAnchorDestination</i> harus menyediakan situasi seperti itu. <br><br>  Dalam kode WinForms ada beberapa kesalahan seperti itu, <b>lebih dari 70</b> .  Mereka semua serupa dan saya tidak akan memberikan deskripsi mereka di artikel. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3091</a> Analisis empiris.  Mungkin salah ketik ada di dalam string literal: "ShowCheckMargin".  Kata 'ShowCheckMargin' mencurigakan.  PropertyNames.cs 136 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNames</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowImageMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowCheckMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; .... }</code> </pre> <br>  Contoh kesalahan yang baik yang tidak mudah dideteksi.  Saat menginisialisasi bidang kelas, mereka menggunakan nilai yang sama, meskipun pembuat kode jelas tidak berpikir begitu (salin-tempel yang harus disalahkan).  Penganalisa membuat kesimpulan ini dengan membandingkan nama-nama variabel dan nilai-nilai string yang ditugaskan.  Saya hanya memberi baris kesalahan, tetapi lihat tampilannya di editor kode: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/196/4de/3131964de8f3f5161678c44086ed2e40.png" alt="Gambar 2"></div><br>  Ini adalah deteksi kesalahan seperti itu yang menunjukkan kekuatan dan perawatan alat analisis statis tanpa batas. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3095 Objek</a> 'currentForm' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 3386, 3404. Application.cs 3386 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunMessageLoopInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reason, ApplicationContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... hwndOwner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef( null, UnsafeNativeMethods.GetWindowLong( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(currentForm, currentForm.Handle), <span class="hljs-comment"><span class="hljs-comment">// &lt;= NativeMethods.GWL_HWNDPARENT)); .... if (currentForm != null &amp;&amp; ....) .... }</span></span></code> </pre> <br>  Klasik  Variabel <i>currentForm</i> digunakan tanpa pemeriksaan.  Tetapi lebih lanjut dalam kode ada pemeriksaan untuk kesetaraan <i>nol</i> .  Dalam hal ini, saya dapat menyarankan Anda untuk lebih berhati-hati ketika bekerja dengan jenis referensi, serta menggunakan analisis statis :). <br><br>  Kesalahan serupa lainnya: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3095 Objek</a> 'backgroundBrush' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 2331, 2334. DataGrid.cs 2331 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color BackgroundColor { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value.Equals(backgroundBrush.Color)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (backgroundBrush != null &amp;&amp; BackgroundBrush != DefaultBackgroundBrush) .... } } }</span></span></code> </pre> <br>  Dalam kode WinForms, saya telah menemukan lebih <b>dari 60</b> kesalahan seperti itu.  Menurut saya, semuanya cukup kritis dan membutuhkan perhatian pengembang.  Tetapi dalam artikel itu tidak begitu menarik untuk membicarakannya, jadi saya akan membatasi diri pada keduanya yang dibahas di atas. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3125 Objek</a> '_propInfo' digunakan dan diverifikasi terhadap null di cabang eksekusi yang berbeda.  Periksa baris: 996, 982. Binding.cs 996 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPropValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object value)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propInfo != null) .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _propInfo.SetValue(_control, value); } .... }</code> </pre> <br>  Untuk melengkapi gambar - juga semacam klasik, bug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3125</a> .  Situasi sebaliknya.  Pada awalnya, referensi yang berpotensi nol digunakan dengan aman, memeriksa <i>nol</i> , tetapi kemudian mereka tidak melakukan ini lagi dalam kode. <br><br>  Dan kesalahan serupa lainnya: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3125 Objek</a> 'pemilik' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 64, 60. FlatButtonAppearance.cs 64 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BorderSize { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != null &amp;&amp; owner.ParentInternal != null) { LayoutTransaction.DoLayoutIf(....); } owner.Invalidate(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } }</span></span></code> </pre> <br>  Kecantikan  Tapi ini dari sudut pandang peneliti luar.  Memang, selain dua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3125 ini</a> , alat analisa menemukan lebih <b>dari 50</b> pola yang sama dalam kode WinForms.  Pengembang harus bekerja. <br><br>  Dan akhirnya - kesalahan yang agak menarik, menurut saya. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3137 Variabel</a> 'hCurrentFont' ditugaskan tetapi tidak digunakan pada akhir fungsi.  DeviceContext2.cs 241 <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { WindowsFont selectedFont; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (disposing) { DeviceContexts.RemoveDeviceContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedFont != null &amp;&amp; selectedFont.Hfont != IntPtr.Zero) { IntPtr hCurrentFont = IntUnsafeNativeMethods.GetCurrentObject( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, hDC), IntNativeMethods.OBJ_FONT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCurrentFont == selectedFont.Hfont) { <span class="hljs-comment"><span class="hljs-comment">// select initial font back in IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(null, hInitialFont)); hCurrentFont = hInitialFont; // &lt;= } selectedFont.Dispose(disposing); selectedFont = null; } } .... }</span></span></code> </pre> <br>  Mari kita lihat apa yang disiagakan oleh penganalisa, dan mengapa fakta bahwa suatu variabel diberi nilai, tetapi tidak digunakan dalam metode di masa depan, dapat mengindikasikan masalah. <br><br>  Kelas parsial dideklarasikan di file <i>DeviceContext2.cs</i> .  Metode <i>DisposeFont</i> digunakan untuk membebaskan sumber daya setelah bekerja dengan grafik: konteks perangkat dan font.  Untuk pemahaman yang lebih baik, saya telah menyediakan seluruh metode <i>DisposeFont</i> .  Perhatikan variabel lokal <i>hCurrentFont</i> .  Masalahnya adalah bahwa mendeklarasikan variabel ini dalam suatu metode menyembunyikan bidang kelas dengan nama yang sama.  Saya menemukan dua metode kelas <i>DeviceContext</i> yang menggunakan <b>bidang yang</b> disebut <i>hCurrentFont</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WindowsFont font)</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = font.Hfont; .... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = hInitialFont; }</code> </pre> <br>  Lihatlah metode <i>ResetFont</i> .  Baris terakhir ada persis apa yang <i>dilakukan</i> metode <i>DisposeFont</i> di blok bersarang <i>jika</i> (penganalisis menunjuk ke tempat ini).  Dan bidang <i>hCurrentFont</i> ini dengan nama yang sama <i>dideklarasikan</i> di bagian lain dari kelas parsial dalam file <i>DeviceContext.cs</i> : <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { .... IntPtr hInitialFont; .... IntPtr hCurrentFont; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Jadi, kesalahan yang jelas telah dibuat.  Pertanyaan lain adalah kekritisannya.  Sekarang, sebagai hasil dari metode <i>DisposeFont</i> yang <i>berfungsi</i> di bagian yang ditandai dengan komentar “pilih kembali font awal”, bidang <i>hCurrentFont</i> tidak akan diberi nilai awal.  Saya pikir hanya penulis kode yang dapat memberikan putusan yang tepat. <br><br>  <b>Kesimpulan</b> <br><br>  Jadi, kali ini saya harus "memarahi" MS sedikit.  Di WinForms ada banyak kesalahan yang membutuhkan perhatian pengembang.  Mungkin ini karena beberapa terburu-buru dengan yang MS sedang mengerjakan .NET Core 3 dan komponen, termasuk WinForms.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurut pendapat saya, kode WinForms masih "lembab", tapi saya harap situasinya akan segera berubah menjadi lebih baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan kedua untuk sejumlah besar kesalahan mungkin karena alat analisa kami menjadi lebih baik untuk mencarinya :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ngomong-ngomong, artikel oleh rekan saya Sergey Vasiliev akan segera diterbitkan di mana dia mencari dan menemukan beberapa masalah dalam kode .NET Core libraries. Saya berharap karyanya juga akan berkontribusi untuk meningkatkan kinerja platform .NET, karena kami selalu mencoba untuk mengomunikasikan hasil analisis proyek mereka kepada pengembang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, bagi mereka yang ingin meningkatkan produk mereka sendiri atau melakukan penelitian untuk menemukan kesalahan dalam proyek orang lain, saya sarankan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengunduh dan mencoba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua kode bersih!</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Sergey Khrenov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinForms: Kesalahan, Holmes</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462807/">https://habr.com/ru/post/id462807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462797/index.html">Dan lagi tentang awan, bukan hanya pro</a></li>
<li><a href="../id462799/index.html">RAVIS dan DAB di awal yang rendah. DRM tersinggung. Masa depan yang aneh dari radio digital Federasi Rusia</a></li>
<li><a href="../id462801/index.html">15 Alat yang Harus Dimiliki untuk Manajer Produk pada 2019</a></li>
<li><a href="../id462803/index.html">Migrasi dari satu sistem ERP ke yang lain</a></li>
<li><a href="../id462805/index.html">Analisis: bagaimana uang sebenarnya dilindungi ketika berdagang di bursa</a></li>
<li><a href="../id462813/index.html">Yekaterinburg, 14 Agustus - mitap Grup Pengguna Atlassian</a></li>
<li><a href="../id462815/index.html">Hari ketiga saya dengan Haiku: seluruh gambar mulai terbentuk</a></li>
<li><a href="../id462817/index.html">Laporan Kotlin / Everywhere - Latihan menampilkan: 31 Juli</a></li>
<li><a href="../id462819/index.html">Kekurangan dalam pendidikan bahasa di CIS: pandangan polyglot</a></li>
<li><a href="../id462821/index.html">Cara mengevaluasi komputer yang belum ada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>