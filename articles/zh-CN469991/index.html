<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♟️ 👩🏽‍🤝‍👨🏾 👐🏿 我们使用RabbitMQ和TypeScript处理来自在线商店的订单 💇 👨‍💻 🎻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 互联网商务的普及与与贸易有关的所有活动的信息化所占的份额都在不断增长。 与此同时，信息处理的复杂性也在增长。 在线商店的客户做出的每笔订单都会生成大量与各种服务的集成。 此类服务可能包括付款处理，交付，会计和会员服务。 每个订单必须付款，记录，组装和交付，还可以进行进一步分析。 由于不是在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们使用RabbitMQ和TypeScript处理来自在线商店的订单</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469991/"><p><img src="https://habrastorage.org/webt/wh/2y/cv/wh2ycv5atat_nuru35jo5pwfo08.jpeg"></p><br><p> 大家好！ 互联网商务的普及与与贸易有关的所有活动的信息化所占的份额都在不断增长。 与此同时，信息处理的复杂性也在增长。 在线商店的客户做出的每笔订单都会生成大量与各种服务的集成。 此类服务可能包括付款处理，交付，会计和会员服务。 每个订单必须付款，记录，组装和交付，还可以进行进一步分析。 由于不是在线商店的用户在下订单时就不想长时间痛苦地等待某事，因此这种情况（而不是简单的情况）变得复杂。 在线商店的响应应该很快，因为每毫秒的延迟都会增加失去客户并随后获利的机会。 在本文中，我想讨论RabbitMQ消息代理，以及如何使用它来使用Node.js和TypeScript组织订单处理。 欢迎来到猫。 </p><a name="habracut"></a><br><h2 id="neobhodimaya-teoriya"> 必要的理论 </h2><br><p> 我想许多人听说过RabbitMQ，因为基于AMQP协议的此消息代理的第一个开源版本已于2007年发布。 需要消息代理将系统的不同组件连接为一个整体，因为需要使用胶水来恢复破损的花瓶。 使用消息代理，可以实现对系统中接收到的事件的异步处理。 在线商店需要的只是异步订单处理。 但是首先，您需要了解RabbitMQ的基本组件。 该代理具有三个主要组件，我们将使用它们来构建处理过程： </p><br><ul><li>  <strong>留言内容</strong> 这是消息代理和我们的处理服务中可以处理的最小信息单元。  RabbitMQ本身以二进制形式存储消息，但是对于我们的系统和本文而言，这并不重要。 我们将以JSON形式接收和处理消息。 还值得一提的是RabbitMQ中的消息具有标头。 它们类似于http请求的标头。 这是一个关联数组，您可以在其中编写必要的信息。 </li><li>  <strong>消息队列</strong> 。 这是RabbitMQ存储消息的队列。 消息队列可以由一个或多个使用者预订。 使用循环算法将兔子队列中的每个消息分发给消费者。 </li><li>  <strong>交换</strong> 顾名思义，这是一个交换点。 队列或其他交换器可以附加到这一点。 交换点不存储消息；它的主要功能是将消息路由到一个或几个队列或相同的交换点。 每个队列或交换器都由路由键绑定。  RabbitMQ中有几种不同类型的交换器，它们会影响交换如何正确路由接收到的消息的方式。 </li></ul><br><p> 为了描述不同类型的交换器是如何工作的，有必要了解什么是路由键。 路由密钥既在队列到交换器的绑定中，又在消息本身中。  <strong>路由密钥</strong>只是一个字符串，分为多个块。 每个块由一个点分隔。 例如，“ notify.sendEmail.sendSms”。 同时，可以使用特殊字符＃和*为消息路由键设置模式。  *-表示在一个点之后任何一个程序段都可以执行，但是在＃之后可以执行任意数量的程序段。 例如，“ notify.sendSms。*”或“ notify。＃”。 现在，您可以继续进行交换点的类型。 </p><br><p> 交换器有四种类型： </p><br><ul><li>  <strong>扇出</strong> 这种交换的路由逻辑很简单；它将进入的消息重定向到与之相连的所有队列或交换器。 </li></ul><br><p><img src="https://habrastorage.org/webt/iw/f5/ib/iwf5ibz1b-6-qqhby_z_kqope9e.png"></p><br><ul><li>  <strong>直达</strong> 此交换根据消息的路由密钥是否与绑定的路由密钥匹配来重定向消息。 </li></ul><br><p><img src="https://habrastorage.org/webt/vu/pm/ia/vupmiavbtemxaxoecqcuklmpvqe.png"></p><br><ul><li>  <strong>话题</strong> 这种类型的交换以及直接路由都取决于路由密钥。 但是模式可以充当路由键。 </li></ul><br><p><img src="https://habrastorage.org/webt/yz/h4/ug/yzh4ug3abx7ywf9ex-bei3k20oe.png"></p><br><ul><li>  <strong>标头</strong> 。 与其他交换不同，此交换使用消息头进行路由。 同时，交换器的队列也使用关联数组进行绑定。 可以使用特殊的“ x-match”键更改交换器路由消息的逻辑，该键在关联绑定数组中设置。 键可以设置为全部或任意两个值。 如果值为all，则消息头必须与匹配绑定数组完全匹配；如果值为any，则该值必须至少与一个键匹配。 </li></ul><br><p><img src="https://habrastorage.org/webt/gq/pd/gm/gqpdgmxxipjwviioorrzouqdj0o.png"></p><br><p> 这些是RabbitMQ的核心组件。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AMQP协议规范中</a>阅读有关这些组件的更多信息。 接下来，我们将以TypeScript为例，设计并实现一个订单处理系统，同时了解每个组件的设置。 </p><br><h2 id="proektirovanie"> 设计方案 </h2><br><p> 为了简化示例，我们假设要成功处理在线订单，我们必须具有以下功能： </p><br><ul><li> 保存收到的订单 </li><li> 通过订单号以及订单状态向客户发送短信 </li><li> 如果客户选择了这种送货方式，请向快递送货服务发送有关我们网上商店的新订单的消息 </li></ul><br><p> 但是，仅仅实现该功能还不够，因为我们的在线商店计划扩展该功能，并在将来为客户提供更多不同的机会（而且这种情况经常发生）。 例如，通过电子邮件通知客户或为订单提供几种交付方式的选择。 因此，我们需要以一种简单的方式来添加功能来设计系统。 </p><br><p> 还值得一提的是，我将使用模板处理延迟的消息，以便在外部服务不可用时能够多次重复逻辑。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关此模板的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息。</a> </p><br><p> 为了更清楚地代表最终目标，我将绘制一个图表。 </p><br><p><img src="https://habrastorage.org/webt/mu/bz/ji/mubzjikeu0b35eac4e_qj0rxdt4.png"></p><br><p> 让我们依次查看订单处理流程在此图中的工作方式。 该方案分为块和不同的颜色。 白框表示我们不会考虑的外部服务。 灰色块表示RabbitMQ元素。 队列和交换器。 绿色反映了需要实现的业务逻辑块。 同样，与我们的逻辑相关的每个块都被编号。 数字按顺序指示流程和子流程。 </p><br><p> 首先，HTTP API消息进入我们的服务。 之后，我们必须为订单分配一个编号，将订单状态保存为数据库中的“新”，并发送有关成功创建订单的响应及其编号。 客户已经收到有关成功创建订单的消息，然后继续自己的生意。 通过发送肯定响应，我们将订单对象发送到后处理交换，交换对象从该对象落入路由键形成的工作程序中。 该工作人员从队列中接收到订单对象后，必须以此为基础（无论订单中是否有电子邮件或客户的电话，以及选择了哪种发送方式），都必须构成订单路由密钥。 形成路由键后，工作人员将消息发送回后处理交换，但是现在订单的路由键已更改，交换器可以在所需的路由上发送它。 根据密钥，可以将订单发送到交易所，后者负责通知，交易所集成或同时执行这两者。 并进一步按照相同的逻辑排队和工作。 </p><br><p>  SMS发送工作者和传递服务将尝试多次处理该消息。 可以在环境变量中传递此类尝试的次数。 但是您不应该无休止地处理消息，因为错误可能在于消息本身或工作人员的逻辑。 因此，在超过允许的尝试次数之后，该消息将从队列中删除，并发送到错误存储，从中可以将其重新发送回所需的处理级别。 </p><br><h2 id="realizaciya"> 实作 </h2><br><p> 为了验证实现，您需要Rabbit本身。 我建议为此使用docker和官方代理映像。 使用以下命令安装并运行容器。 </p><br><pre><code class="bash hljs">docker run -d --name rabbit -p 5672:5672 -e rabbitmq:3.7.15-management-alpine</code> </pre> <br><p> 这是在端口15672上具有Web界面的图像，用于方便调试。 </p><br><p> 我们将使用TypeScript和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">amqplib</a>库（Node.js的RabbitMQ客户端实现）实施我们的计划，因此一开始您需要描述几个接口。 我们描述了订单的界面以及将发送给Rabbit的消息。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    export interface Product { id: string; name: string; price: number; } //    export interface Order { clientName: string; city: string; email?: string; phone?: string; products: Product[]; totalSum: number; deliveryAddress?: string; } //         export interface OrderWithPhone extends Order { phone: string; } //        export interface OrderWithDeliveryAddress extends Order { deliveryAddress: string; } // Types Guard'        export const isOrderWithPhone = (order: Order): order is OrderWithPhone =&gt; Boolean(order.phone); export const isOrderWithDeliveryAddress = (order: Order): order is OrderWithDeliveryAddress =&gt; Boolean(order.deliveryAddress); //    . export interface Message&lt;O extends Order&gt; { errors: string[]; retry: number; order: O; //         export interface FailOrder extends Message&lt;Order&gt; { exchange: string; routingKey: string; }</span></span></code> </pre> <br><p> 现在我们需要描述队列和交换器的配置接口，在此基础上我们将构建Rabbit的处理结构。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Types, ExchangeTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Options } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'amqplib'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   RabbitMQ       export enum Types { QUEUE = 'queue', EXCHANGE = 'exchange', } //      export enum ExchangeTypes { TOPIC = 'topic', } //    export interface Queue { name: string; options: Options.AssertQueue; } //    export interface Exchange { name: string; type: ExchangeTypes; } //    export interface Binding { type: Types; destination: string; source: string; routingKey: string; } //   RabbitMQ export interface PipelineConfig { queues: Queue[]; exchanges: Exchange[]; bindings: Binding[]; }</span></span></code> </pre> <br><p> 描述了系统的主要组件之后，我们描述了使用对象在图上绘制的配置。 </p><br><p>  Queue列 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ <span class="hljs-comment"><span class="hljs-comment">//        routingKey { name: 'generateRoutingKey', options: { durable: true, }, }, //   sms { name: 'sendSms', options: { durable: true, }, }, //      { name: 'delivery', options: { durable: true, }, }, //         sms { name: 'sendSmsHold', options: { durable: true, deadLetterExchange: 'notify', deadLetterRoutingKey: 'sendSms', messageTtl: 60000, }, }, //            { name: 'deliveryHold', options: { durable: true, deadLetterExchange: 'integrates', deadLetterRoutingKey: 'delivery', messageTtl: 60000, }, }, ];</span></span></code> </pre> <br><p> 描述队列时，以下选项用于队列。 </p><br><ul><li>  <strong>耐用的</strong> 。 默认情况下，所有队列消息都存储在内存中。 因此，当代理重新启动时，消息将消失。 为避免这种情况，可以使用此选项。 使用此设置，rabbit会将消息刷新到磁盘。 但是有一个警告。 为了在代理重新启动后保存消息，此设置还不够；必须使用持久性选项将消息发送到队列。 </li><li>  <strong>messageTtl</strong> 。 消息生存期。 以毫秒为单位 </li><li>  <strong>deadLetterExchange</strong> 。 过期时将从队列中发送消息的交换器的名称 </li><li>  <strong>deadLetterRoutingKey</strong> 。 从上一个选项将消息发送到交换器的RoutingKey </li></ul><br><p> 交流交流 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ExchangeTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ExchangeTypes.TOPIC, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ExchangeTypes.TOPIC, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'integrates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ExchangeTypes.TOPIC, }, ];</code> </pre> <br><p> 绑定 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Types } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.EXCHANGE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'#.notify.#'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.EXCHANGE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'integrates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'#.integrates.#'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'generateRoutingKey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'generateRoutingKey'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSms'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'#.sendSms.#'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'delivery'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'integrates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'#.delivery.#'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSmsHold'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSmsHold'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'deliveryHold'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'integrates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'deliveryHold'</span></span>, }, ];</code> </pre> <br><p> 完整配置 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { PipelineConfig } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> exchanges <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./exchanges'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> queues <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./queues'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bindings <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./bindigs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pipelineConfig: PipelineConfig = { exchanges, queues, bindings, };</code> </pre> <br><p> 要连接到Rabbit，请编写一个类。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connect, Connection, Channel } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'amqplib'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RabbitConnect</span></span></span><span class="hljs-class"> </span></span>{ private _uri: string; private _connection: Connection; private _chanel: Channel; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">//    rabbit     this._uri = process.env.RABBIT_URI || 'amqp://localhost'; } protected async connect() { this._connection = await connect(this._uri); this._chanel = await this._connection.createChannel(); } protected async disconnect() { await this._chanel.close(); return this._connection.close(); } protected get chanel() { return this._chanel; } }</span></span></code> </pre> <br><p> 让我们编写Pipeline类，该类在启动时将根据前面所述的配置在Rabbit中创建所有必要的基础结构。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { RabbitConnect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./RabbitConnect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { PipelineConfig } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Types } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pipeline</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RabbitConnect</span></span></span><span class="hljs-class"> </span></span>{ private _pipeline: PipelineConfig; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(pipelineConfig: PipelineConfig) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pipeline = pipelineConfig; } public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> create() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connect(); <span class="hljs-comment"><span class="hljs-comment">//   const createQueues = this._pipeline.queues.map(queue =&gt; this.chanel.assertQueue(queue.name, queue.options), ) as PromiseLike&lt;any&gt;[]; //   const createExchanges = this._pipeline.exchanges.map(exchange =&gt; this.chanel.assertExchange(exchange.name, exchange.type), ) as PromiseLike&lt;any&gt;[]; await Promise.all([...createQueues, ...createExchanges]); //       const createBindings = this._pipeline.bindings.map(binding =&gt; { if (binding.type === Types.QUEUE) { return this.chanel.bindQueue(binding.destination, binding.source, binding.routingKey); } return this.chanel.bindExchange(binding.destination, binding.source, binding.routingKey); }); await Promise.all(createBindings); return this.disconnect(); } catch (error) { console.error(error); throw new Error(error); } } }</span></span></code> </pre> <br><p> 现在，我们将编写一个抽象的工作程序类，该类为所有可以从其继承的工作程序提供通用功能。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { RabbitConnect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./RabbitConnect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Message, Order, FailOrder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ConsumeMessage } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'amqplib'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface WorkerParams { maxRetry?: number; <span class="hljs-comment"><span class="hljs-comment">//     active: string; //    exchange: string; //       holdKey?: string; //      } export abstract class Worker&lt;M extends Order&gt; extends RabbitConnect { private _maxRetry: number; private _active: string; private _holdKey: string | undefined; protected exchange: string; private _currentMessage: Message&lt;M&gt;; private _currentConsumeMessage: ConsumeMessage; constructor({ active, holdKey, exchange, maxRetry }: WorkerParams) { super(); this._maxRetry = maxRetry || 0; this._active = active; this._holdKey = holdKey; this.exchange = exchange; } public async subscribe() { await this.connect(); this.chanel.consume(this._active, this.checkMessage.bind(this)); } //          private async checkMessage(message: ConsumeMessage) { this._currentConsumeMessage = message; const orderMessage: Message&lt;M&gt; = JSON.parse(message.content.toString()); if (orderMessage.retry &gt;= this._maxRetry) { await this.sendToErrorStorage('  '); } this._currentMessage = orderMessage; //           await this.handler(orderMessage.order || orderMessage); } //       protected async sendToErrorStorage(error: string) { const message: FailOrder = { order: this._currentMessage.order, errors: [...this._currentMessage.errors, error], retry: this._currentMessage.retry + 1, exchange: this.exchange, routingKey: this._active }; console.log('   ', message); this.ack(); } //       protected async hold(error: string) { if (!this._holdKey) { return; } const orderMessage = { order: this._currentMessage.order, errors: [...this._currentMessage.errors, error], retry: this._currentMessage.retry + 1, }; const orderData = Buffer.from(JSON.stringify(orderMessage)); return this.chanel.publish(this.exchange, this._holdKey, orderData); } //      protected async ack() { return this.chanel.ack(this._currentConsumeMessage); } protected abstract handler(message: M): void; }</span></span></code> </pre> <br><p> 默认情况下，rabbit要求工作人员确认消息处理成功。 为此，连接通道具有ack方法。 如果工作人员无法处理该消息，则有一个nack方法告诉兔子将消息发送给另一个工作人员。 </p><br><p> 现在，我们可以从图中编写一些简单的工作程序。 </p><br><p> 生成路由密钥的工作人员。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Worker } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Worker'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { isOrderWithPhone, isOrderWithDeliveryAddress, Order, Message, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Keys } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenerateRoutingKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({ <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-string"><span class="hljs-string">'generateRoutingKey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">exchange</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, }); } protected <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(order: Order) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> routingKey: string[] = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isOrderWithPhone(order)) { routingKey.push(Keys.SEND_SMS); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isOrderWithDeliveryAddress(order)) { routingKey.push(Keys.SEND_TO_DELIVERY); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Message&lt;Order&gt; = { <span class="hljs-attr"><span class="hljs-attr">retry</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">errors</span></span>: [], order, }; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.chanel.publish( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.exchange, routingKey.join(<span class="hljs-string"><span class="hljs-string">'.'</span></span>), Buffer.from(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)), ); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ack(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sendToErrorStorage(error); } } }</code> </pre> <br><p> 工人发送短信。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Worker } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Worker'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { OrderWithPhone } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendSms</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderWithPhone</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({ <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSms'</span></span>, <span class="hljs-attr"><span class="hljs-attr">exchange</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">holdKey</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSmsHold'</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetry</span></span>: process.env.MAX_RETRY ? <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(process.env.MAX_RETRY) : <span class="hljs-number"><span class="hljs-number">5</span></span>, }); } protected <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(message: OrderWithPhone) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' sms  : '</span></span>, message.phone); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ack(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hold(error); } } }</code> </pre> <br><p> 工人与送货服务的整合。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Worker } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Worker'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { OrderWithDeliveryAddress } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Delivery</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderWithDeliveryAddress</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({ <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-string"><span class="hljs-string">'delivery'</span></span>, <span class="hljs-attr"><span class="hljs-attr">exchange</span></span>: <span class="hljs-string"><span class="hljs-string">'interates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">holdKey</span></span>: <span class="hljs-string"><span class="hljs-string">'deliveryHold'</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetry</span></span>: process.env.MAX_RETRY ? <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(process.env.MAX_RETRY) : <span class="hljs-number"><span class="hljs-number">5</span></span>, }); } protected <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(message: OrderWithDeliveryAddress) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'      : '</span></span>, message.deliveryAddress); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ack(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hold(error); } } }</code> </pre> <br><p> 应用程序的入口点。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Pipeline } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Pipeline'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { pipelineConfig } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./pipeline'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { GenerateRoutingKey } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./workers/GenerateRoutingKey'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SendSms } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./workers/SendSms'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Delivery } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./workers/Delivery'</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pipeline = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipeline(pipelineConfig); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> generateRoutingKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenerateRoutingKey(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sendSms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SendSms(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delivery = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Delivery(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pipeline.create(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([generateRoutingKey.subscribe(), sendSms.subscribe(), delivery.subscribe()]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); process.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } })();</code> </pre> <br><p> 我不会提供用于将订单写入数据库并生成Internet订单号的代码类示例。 这超出了本文的范围。 要检查代码，可以通过将订单json发送到交换器posrprocessing来使用Rabbit Web界面。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 用于处理在线订单的这种构造方案使得扩展系统变得容易。 对于我们来说，为该方案添加几个队列和工作器以添加必要的功能并不困难。 例如，您可以添加通过电子邮件发送发送通知或发送1C中的记帐订单。 转换后的电路如下所示： </p><br><p><img src="https://habrastorage.org/webt/id/rt/7j/idrt7j5jx9zmzcma6axa3st7-nq.png"></p><br><p> 希望您喜欢这篇文章。 我将对任何评论和批评感到高兴。 所有提交的代码都可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在github</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469991/">https://habr.com/ru/post/zh-CN469991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469979/index.html">来自第二个iOS mitap Redmadrobot的报告记录</a></li>
<li><a href="../zh-CN469981/index.html">聊天机器人里面有什么？</a></li>
<li><a href="../zh-CN469985/index.html">无需优化即可加速Redd合成处理器的程序：更换时钟</a></li>
<li><a href="../zh-CN469987/index.html">全球排名前20位的市场开发公司</a></li>
<li><a href="../zh-CN469989/index.html">C＃正则表达式示例</a></li>
<li><a href="../zh-CN469995/index.html">Python SAX解析器与python DOM解析器。 Parsim FIAS房屋</a></li>
<li><a href="../zh-CN469997/index.html">哪些标题最有可能引起注意或进行HabraHabr分析</a></li>
<li><a href="../zh-CN469999/index.html">服务器之间如何协商：Raft分布式共识算法</a></li>
<li><a href="../zh-CN470001/index.html">Linux技巧和窍门：服务器，开放</a></li>
<li><a href="../zh-CN470005/index.html">通过浏览器进行远程计算机控制</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>