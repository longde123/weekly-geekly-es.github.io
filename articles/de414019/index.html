<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèø üëåüèΩ üîÉ Universelle L√∂sung f√ºr UITableViewRowAction und UIContextualAction ü§≤üèø üòï üòò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele sind auf das Problem gesto√üen, eine sch√∂ne Schaltfl√§chenzuordnung f√ºr eine UITableViewCell zu implementieren, wenn diese nach links verschoben w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Universelle L√∂sung f√ºr UITableViewRowAction und UIContextualAction</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/414019/"><img src="https://habrastorage.org/webt/ij/w5/3b/ijw53blhrl4aftmlr8hv6iymiu8.jpeg"><br><br>  Viele sind auf das Problem gesto√üen, eine sch√∂ne Schaltfl√§chenzuordnung f√ºr eine UITableViewCell zu implementieren, wenn diese nach links verschoben wird.  Einige verwendeten die Standardfunktionalit√§t "out of the box", andere k√ºmmerten sich um ihre eigene Implementierung, w√§hrend andere mit Unicode-Zeichen verwaltet wurden.  In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie die maximale Anpassung von UITableViewRowAction erreichen. <br><a name="habracut"></a><br>  Zun√§chst eine kleine Theorie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UITableViewRowAction</a> ist eine Klasse, mit der der Benutzer bestimmte Aktionen mit dieser Zelle ausf√ºhren kann, wenn er eine Zelle nach links verschiebt (z. B. L√∂schen, √Ñndern usw.).  Jede Instanz dieser Klasse stellt eine auszuf√ºhrende Aktion dar und enth√§lt Text, Stil und einen Klick-Handler.  Mit dem iOS SDK k√∂nnen wir die UITableViewRowAction wie folgt anpassen: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">convenience</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(style: <span class="hljs-type"><span class="hljs-type">UITableViewRowActionStyle</span></span>, title: <span class="hljs-type"><span class="hljs-type">String?</span></span>, handler: @escaping (<span class="hljs-type"><span class="hljs-type">UITableViewRowAction</span></span>, <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Swift</span></span>.<span class="hljs-type"><span class="hljs-type">Void</span></span>)</code> </pre> <br>  Sie k√∂nnen auch backgroundColor festlegen. <br><br><h3>  Bestehende Methoden. </h3><br>  Betrachten Sie die vorhandenen Implementierungsbeispiele oder das, was ich im Internet gefunden habe. <br>  <strong>Methodennummer 1</strong> .  Nutzen Sie die Funktionalit√§t "out of the box".  Dies reicht aus, um normale Schaltfl√§chen mit Text und Hintergrund zu verwenden.  Es sieht zu einfach und langweilig aus: <br><img src="https://habrastorage.org/webt/nw/1a/zu/nw1azubhwsv2ak9tpiaq39jamma.jpeg"><br><br>  <strong>Methode Nummer 2</strong> .  <em>Legen</em> Sie backgroundColor mit <em>UIColor fest (patternImage: UIImage)</em> .  Dies wird Sch√∂nheit erreichen, aber es wird die Vielseitigkeit beeintr√§chtigen, eine Reihe von Einschr√§nkungen und Schwierigkeiten hinzuf√ºgen.  Da die Breite der UITableViewRowAction anhand der Gr√∂√üe des Texts berechnet wird, m√ºssen Sie den <em>Titel</em> als eine Reihe von Leerzeichen mit einer bestimmten Breite angeben.  Wir k√∂nnen diese Methode nicht f√ºr Zellen mit dynamischen H√∂hen verwenden.  Wenn die Zelle an H√∂he zunimmt, sieht sie ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/ni/k3/fm/nik3fmelwkdx6vzqc0f1k_ipxhm.jpeg"><br><br>  <strong>Methode Nummer 3</strong> .  Verwenden Sie Unicode-Zeichen.  Es ist nicht erforderlich, die Gr√∂√üe des Texts mit Leerzeichen zu berechnen, und diese Methode eignet sich f√ºr Zellen mit dynamischer H√∂he.  Es sieht gut aus: <br><br><img src="https://habrastorage.org/webt/jy/f7/j8/jyf7j8qnr-dupmrdtiycimemysa.jpeg"><br><br>  Wenn wir jedoch den Text unter dem Symbol erstellen m√∂chten, passt diese Methode nicht zu uns. <br><br>  <strong>Methodennummer 4</strong> .  Verwenden Sie CoreGraphics, um UI-Komponenten zu rendern.  Die Idee ist, ein Bild mit der gew√ºnschten Anordnung von Elementen (Text und Bild) manuell zu zeichnen.  In diesem Fall m√ºssen Sie die Gr√∂√üen und Koordinaten f√ºr die Position jedes Elements berechnen.  Mit dieser Methode k√∂nnen wir sowohl Text als auch ein Bild erstellen und sie nach Bedarf anordnen.  Diese Methode ist jedoch schwer zu implementieren.  Wir wollen etwas Einfacheres. <br><br>  <strong>Andere Implementierungen</strong> .  Es gibt noch einige fertige L√∂sungen.  Sie verwenden ihre eigene Implementierung der Zelle mit ScrollView und anderer Logik.  Zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SwipeCellKit</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MGSwipeTableCell</a> .  Diese L√∂sungen erm√∂glichen jedoch nicht das Erreichen eines Standard-iOS-Verhaltens, da sie im Gegensatz zur UITableViewRowAction, die im Tabellendelegierten erstellt wird, nur eine Zelle abdecken.  Wenn Sie beispielsweise mit einer dieser L√∂sungen Aktionen f√ºr die Linksverschiebung f√ºr mehrere Zellen √∂ffnen, m√ºssen Sie diese Aktionen in jeder dieser Zellen manuell schlie√üen, was √§u√üerst unpraktisch ist.  Dazu m√ºssen Sie Ihre eigene Logik hinzuf√ºgen, um offene Aktionen beim Wischen zu steuern.  Wir m√∂chten eine einfache L√∂sung erstellen, die keine zus√§tzlichen Kosten erfordert, als ob wir die Standardimplementierung von UITableViewRowAction verwenden. <br><br><h3>  Fangen wir an </h3><br>  Versuchen wir, eine universelle L√∂sung zu erstellen, mit der Sie UITableViewRowAction mit jedem von uns ben√∂tigten Design erstellen k√∂nnen. <br><br>  Erstellen Sie unsere Nachkommenklasse aus UITableViewRowAction und definieren Sie die Methode zur Erstellung der Hauptinstanz: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">RowActionTapHandler</span></span> = (<span class="hljs-type"><span class="hljs-type">RowAction</span></span>, <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RowAction</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewRowAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rowAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with actionHandler: @escaping RowActionTapHandler)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rowAction = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(style: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, title: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { action, indexPath <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> action = action <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">RowAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } actionHandler(action, indexPath) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowAction } }</code> </pre><br>  Da UITableViewRowAction keinen prim√§ren Initialisierer hat, k√∂nnen wir der Einfachheit halber eine statische Methode erstellen, in der wir auf standardm√§√üige Weise eine UITableViewRowAction erstellen und einen actionHandler hineinwerfen, um den Klick zu verarbeiten. <br><br>  Versuchen wir nun, die Schaltfl√§che UITableViewRowAction universell anzupassen.  Die Idee ist, das Aussehen der Schaltfl√§che aus dem fertigen UIView zu erhalten (das in einer regul√§ren xib konfiguriert werden kann).  So k√∂nnen wir eine beliebige Schaltfl√§che erstellen, die auf individuellen Vorlieben basiert (beliebige Schriftart des Textes, Gr√∂√üe und Anordnung der Elemente usw.). <br><br>  Wir haben zwei Dinge, die wir in UITableViewRowAction √§ndern k√∂nnen: <em>backgroundColor</em> und <em>title</em> .  Derzeit besteht die einzige M√∂glichkeit, das Aussehen der Schaltfl√§che UITableViewRowAction zu √§ndern, darin, die Eigenschaft backgroundColor zu √§ndern.  Daher ist es unser Ziel, Folgendes zu transformieren: UIView -&gt; UIImage -&gt; UIColor.  Wir k√∂nnen die Farbe mit dem Bild wie folgt erhalten: <em>UIColor (patternImage: UIImage)</em> .  Und wir k√∂nnen das Bild von UIView erhalten, indem wir es mit dem Standard-CoreGraphics-Framework rendern. <br><br>  Zun√§chst entscheiden wir jedoch, wie die Gr√∂√üe der Schaltfl√§che festgelegt werden soll: "Out of the Box" gibt es diese Funktion nicht, und die Gr√∂√üe in der UITableViewRowAction wird anhand der Gr√∂√üe des Textes des Titelfelds berechnet. <br><br>  Nachdem ich Experimente durchgef√ºhrt hatte (Messung der berechneten und tats√§chlichen Breite der Schaltfl√§che), fand ich ein leeres Unicode-Zeichen mit der kleinsten Breite ungleich Null: <em>U + 200A</em> <br><br>  Wir werden es verwenden und eine Konstante erstellen: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Constants</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> placeholderSymbol = <span class="hljs-string"><span class="hljs-string">"\u{200A}"</span></span> }</code> </pre><br>  Wir werden eine Funktion schreiben, um eine Folge von Leerzeichen zu erhalten, die der Gr√∂√üe entsprechen, die wir ben√∂tigen: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> placeholderSymbolWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> flt_max = <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>.greatestFiniteMagnitude <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maxSize = <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: flt_max, height: flt_max) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attributes = [<span class="hljs-type"><span class="hljs-type">NSFontAttributeName</span></span> : <span class="hljs-type"><span class="hljs-type">UIFont</span></span>.systemFont(ofSize: <span class="hljs-type"><span class="hljs-type">UIFont</span></span>.systemFontSize)] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> boundingRect = <span class="hljs-type"><span class="hljs-type">Constants</span></span>.placeholderSymbol.boundingRect(with: maxSize, options: .usesLineFragmentOrigin, attributes: attributes, context: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> boundingRect.width }() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emptyTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size: CGSize)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usefulWidth = size.width - <span class="hljs-type"><span class="hljs-type">Constants</span></span>.minimalActionWidth usefulWidth = usefulWidth &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : usefulWidth <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countOfSymbols = <span class="hljs-type"><span class="hljs-type">Int</span></span>(floor(usefulWidth * <span class="hljs-type"><span class="hljs-type">Constants</span></span>.shiftFactor / <span class="hljs-type"><span class="hljs-type">RowAction</span></span>.placeholderSymbolWidth)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>(repeating: <span class="hljs-type"><span class="hljs-type">Constants</span></span>.placeholderSymbol, <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: countOfSymbols) }</code> </pre><br>  Die Variable <em>placeholderSymbolWidth ermittelt</em> die Breite unseres Unicode-Zeichens, und die Funktion <em>emptyTitle (f√ºr Gr√∂√üe: CGSize) -&gt; String</em> berechnet die Anzahl der Leerzeichen entsprechend der <em>Gr√∂√üengr√∂√üe</em> und gibt eine Zeichenfolge dieser Zeichen zur√ºck.  Die obige Formel verwendet die <em>ShiftFactor-</em> Konstante.  Dies ist der Abweichungskoeffizient der Breite vom Nennwert.  Tatsache ist, dass mit zunehmender Breite der UITableViewRowAction ein kleiner Fehler zunimmt (d. H. Die tats√§chliche Breite der Schaltfl√§che unterscheidet sich von der berechneten Breite durch die √ºbliche Formel).  Um dies zu vermeiden, verwenden wir diese experimentell abgeleitete Konstante. <br><br>  Au√üerdem hat UITableViewRowAction eine Mindestbreite von 30 (z. B. wenn Sie title = "" festlegen).  Diese Breite ist das Minimum, das zum Einr√ºcken links und rechts vom Titel erforderlich ist. <br>  Aktualisieren Sie unsere Konstanten: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Constants</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> placeholderSymbol = <span class="hljs-string"><span class="hljs-string">"\u{200A}"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> minimalActionWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shiftFactor: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">1.1</span></span> }</code> </pre><br>  Lassen Sie uns nun das Bild aus der UIView holen.  Wir werden die folgende Funktion schreiben: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from view: UIView)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIImage?</span></span> { <span class="hljs-type"><span class="hljs-type">UIGraphicsBeginImageContextWithOptions</span></span>(view.bounds.size, view.isOpaque, <span class="hljs-type"><span class="hljs-type">UIScreen</span></span>.main.scale) <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">UIGraphicsGetCurrentContext</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assertionFailure</span></span>(<span class="hljs-string"><span class="hljs-string">"Something wrong with CoreGraphics image context"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } context.setFillColor(<span class="hljs-type"><span class="hljs-type">UIColor</span></span>.white.cgColor) context.fill(<span class="hljs-type"><span class="hljs-type">CGRect</span></span>(origin: .zero, size: view.bounds.size)) view.layer.render(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: context) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> img = <span class="hljs-type"><span class="hljs-type">UIGraphicsGetImageFromCurrentImageContext</span></span>() <span class="hljs-type"><span class="hljs-type">UIGraphicsEndImageContext</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> img }</code> </pre><br>  Diese Funktion wandelt unsere <em>Ansicht</em> in ein Bild um.  In diesem Fall entspricht die Gr√∂√üe des Bildes der Gr√∂√üe der <em>Ansicht</em> . <br><br>  Der letzte Schritt bleibt, in dem wir die Methode zum Festlegen von UITableViewRowAction mithilfe von UIView implementieren: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupForCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with view: UIView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> img = image(from: view) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = emptyTitle(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: img.size) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.backgroundColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(patternImage: img) }</code> </pre><br>  Hier verwenden wir die zuvor geschriebenen Funktionen, um unsere Schaltfl√§che zu konfigurieren und die <em>Hintergrundfarbe</em> anhand des resultierenden Bildes festzulegen. <br><br>  Das ist alles  Wir haben eine universelle L√∂sung f√ºr UITableViewRowAction und k√∂nnen sie jetzt mithilfe von UIView auf beliebige Weise anpassen. <br><br><img src="https://habrastorage.org/webt/vq/om/jh/vqomjhu5tyowfttayuyddmgqqwu.jpeg"><br><br>  Ab iOS 11 hat Apple eine neue Klasse f√ºr Wischaktionen f√ºr Zellen in der Tabelle hinzugef√ºgt - UIContextualAction.  Sie k√∂nnen damit sofort das Bild angeben, das bei der Aktion auf dem Wisch angezeigt wird (dies fehlt uns in all den Jahren, in denen UITableViewRowAction verwendet wurde).  Er sollte unser Leben leichter machen, aber zus√§tzlich zu einer neuen Gelegenheit schuf er zus√§tzliche Probleme.  Diese Klasse schr√§nkt die Gr√∂√üe des Bildes ein, erlaubt nicht die gleichzeitige Verwendung von Text und Bild, und das Bild muss ein spezielles Format (Vorlagenbild) haben.  Daher habe ich meine L√∂sung f√ºr die Unterst√ºtzung von Wischaktionen in iOS 11 fertiggestellt. Um eine UITableViewRowAction oder UIContextualAction zu erstellen, m√ºssen Sie zun√§chst die RowActionFactory-Factory erstellen und sie mithilfe unserer Ansicht konfigurieren (wie oben in der <em>setupForCell-Methode (mit Ansicht: UIView)).</em> und geben Sie die ben√∂tigte Entit√§t zur√ºck: UITableViewRowAction oder UIContextualAction (unter Verwendung der <em>Methoden rowAction ()</em> bzw. <em>contextualAction (f√ºr indexPath: IndexPath)</em> ).  Das folgende Beispiel zeigt die Verwendung von RowActionFactory: <br><br><pre> <code class="hljs julia"><span class="hljs-meta"><span class="hljs-meta">@available</span></span>(iOS <span class="hljs-number"><span class="hljs-number">11.0</span></span>, *) func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? { var contextualActions: [UIContextualAction] = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> actionType <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rowActionTypes { // actionType -     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rowActionFactory = RowActionFactory { (indexPath) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tableView.setEditing(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rowActionView = &lt;...&gt; //  UIView     rowActionFactory.setupForCell(with: rowActionView) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contextualAction = rowActionFactory.contextualAction(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) { contextualActions.append(contextualAction) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swipeActionsConfiguration = UISwipeActionsConfiguration(actions: contextualActions) swipeActionsConfiguration.performsFirstActionWithFullSwipe = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swipeActionsConfiguration }</code> </pre><br>  Die fertige L√∂sung finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TCSCustomRowActionFactory (github.com)</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414019/">https://habr.com/ru/post/de414019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413997/index.html">Intel 32-Bit-Prozessoren: 3 bis 4 - Nutzloser Friday Longride</a></li>
<li><a href="../de414001/index.html">Wie man in einer sich ver√§ndernden Welt der Entwicklung √ºberlebt</a></li>
<li><a href="../de414003/index.html">Die Z√ºge sind unterschiedlich. Sehr</a></li>
<li><a href="../de414009/index.html">Top 8 der besten Ressourcen f√ºr die Programmierpraxis im Jahr 2018</a></li>
<li><a href="../de414011/index.html">Ich kann Apple werden und du auch</a></li>
<li><a href="../de414023/index.html">Fragen Sie Ethan: Wie schnell h√§tte das Leben im Universum erscheinen k√∂nnen?</a></li>
<li><a href="../de414025/index.html">Arbeitgeber verfolgen Computer, Toilettenfahrten und jetzt auch Emotionen. Folgt Ihnen Ihr Chef?</a></li>
<li><a href="../de414027/index.html">K√∂nnen meine Freunde als wahre Freunde betrachtet werden?</a></li>
<li><a href="../de414029/index.html">Geheimnisvolles Licht um einen neu gebildeten Stern und was Astronomen dar√ºber denken</a></li>
<li><a href="../de414031/index.html">Nach dem Treffen "PostgreSQL 11 New Features"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>