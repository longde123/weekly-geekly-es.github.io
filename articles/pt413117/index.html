<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏿 🏼 👰🏽 Como programar com segurança no bash 👩🏿 👩‍🔧 🆙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por que bater? 
 Existem matrizes e modo de segurança no bash. Quando usado corretamente, o bash é quase consistente com práticas de codificação segur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como programar com segurança no bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1>  Por que bater? </h1><br>  Existem matrizes e modo de segurança no bash.  Quando usado corretamente, o bash é quase consistente com práticas de codificação seguras. <br><br>  É mais difícil cometer um erro no peixe, mas não há modo seguro.  Portanto, a criação de protótipos em peixes e a tradução de peixes para o bash deve ser uma boa idéia, se você souber como fazê-lo corretamente. <br><br><h1>  Prefácio </h1><br>  Este guia acompanha o ShellHarden, mas o autor também recomenda o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ShellCheck</a> para que as regras do ShellHarden não sejam diferentes do ShellCheck. <br><br>  Bash não é um idioma em que a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">maneira mais correta de resolver um problema ao mesmo tempo seja a mais fácil</a> .  Se você fizer o exame de programação segura do bash, a primeira regra do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BashPitfalls</a> seria: sempre use aspas. <br><br><h1>  A principal coisa que você precisa saber sobre programação no bash </h1><br>  <b>Aspas maníacas!</b>  Uma variável não citada deve ser considerada uma bomba armada: ela explode em contato com um espaço.  Sim, ele explode no sentido de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dividir uma string em uma matriz</a> .  Em particular, extensões variáveis ​​como <code>$var</code> e substituições de comandos como <code>$(cmd)</code> são <i>divididas</i> em <i>palavras</i> quando a cadeia interna é expandida em uma matriz devido à divisão em uma variável especial <code>$IFS</code> com um espaço padrão.  Isso geralmente é invisível, porque na maioria das vezes o resultado é uma matriz de 1 elemento, indistinguível da sequência esperada. <br><a name="habracut"></a><br>  Não apenas isso é expandido, mas também curingas ( <code>*?</code> ).  Esse processo ocorre depois que a palavra é dividida; portanto, se houver pelo menos um curinga na palavra, a palavra se transformará em um curinga que se aplica a qualquer caminho de arquivo adequado.  Portanto, esse recurso começa a se aplicar ao sistema de arquivos! <br><br>  A cotação suprime a divisão de palavras e a expansão de padrões para variáveis ​​e substituições de comandos. <br><br>  Extensão variável: <br><br><ul><li>  Bom: <code>"$my_var"</code> </li><li>  Ruim: <code>$my_var</code> </li></ul><br>  Substituição de comando: <br><br><ul><li>  Bom: <code>"$(cmd)"</code> </li><li>  Ruim: <code>$(cmd)</code> </li></ul><br>  Existem exceções com aspas opcionais, mas as aspas nunca serão prejudicadas, e a regra geral é ter cuidado para não citar variáveis ​​não citadas, portanto, não procuraremos exceções de borda para seu benefício.  Parece errado, e a prática errada é generalizada o suficiente para levantar suspeitas: muitos scripts foram escritos com processamento quebrado de nomes de arquivos e espaços neles ... <br><br>  O ShellHarden menciona apenas algumas exceções - essas variáveis ​​têm conteúdo numérico como <code>$?</code>  , <code>$#</code> e <code>${#array[@]}</code> . <br><br><h3>  Preciso usar backticks? </h3><br>  As substituições de comando também podem ter o seguinte formato: <br><br><ul><li>  Correto: <code>"`cmd`"</code> </li><li>  Ruim: <code>`cmd`</code> </li></ul><br>  Embora esse estilo possa ser usado corretamente, parece menos conveniente entre aspas e menos legível quando aninhado.  O consenso aqui é bastante claro: evite-o. <br><br>  A ShellHarden reescreve essas marcas de verificação entre colchetes em dólares. <br><br><h3>  Aparelhos precisam ser usados? </h3><br>  Os colchetes são usados ​​para interpolar cadeias de caracteres, portanto, geralmente são redundantes: <br><br><ul><li>  Ruim: <code>some_command $arg1 $arg2 $arg3</code> </li><li>  Pobre e detalhado: <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li>  Bom, mas detalhado: <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li>  Bom: <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br>  Teoricamente, sempre usar chaves não é um problema, mas de acordo com a experiência do seu autor, existe uma forte correlação negativa entre o uso desnecessário de chaves e o uso correto de aspas - quase todo mundo escolhe a forma “ruim e detalhada” em vez da forma “boa, mas detalhada”! <br><br>  Teorias do seu autor: <br><br><ul><li>  Por causa do medo de fazer algo errado: em vez do perigo real (falta de aspas), os iniciantes podem se preocupar com o fato de a variável <code>$prefix</code> fazer com que a variável <code>"$prefix_postfix"</code> se expanda, mas não funciona dessa maneira. </li><li>  Culto à carga: escrever código na aliança do medo errado que o precedeu. </li><li>  Os colchetes competem entre aspas pelo limite da verbosidade permitida. </li></ul><br>  Portanto, decidiu-se proibir chaves desnecessárias: o ShellHarden substitui essas opções pela forma mais simples. <br><br>  E agora sobre interpolação de strings, onde chaves são realmente úteis: <br><br><ul><li>  Ruim (concatenação): <code>$var1"more string content"$var2</code> </li><li>  Bom (concatenação): <code>"$var1""more string content""$var2"</code> </li><li>  Bom (interpolação): <code>"${var1}more string content${var2}"</code> </li></ul><br>  Concatenação e interpolação no bash são equivalentes mesmo em matrizes (o que é ridículo). <br><br>  Como o ShellHarden não formata estilos, não é necessário alterar o código correto.  Isso é verdade para a opção "boa (interpolação)": do ponto de vista do ShellHarden, essa será a forma canonicamente correta. <br><br>  O ShellHarden agora está adicionando e removendo chaves, conforme necessário: em um mau exemplo, o var1 é fornecido com colchetes, mas eles não são permitidos para o var2, mesmo no caso de “bom (interpolação)”, pois nunca são necessários no final da linha.  O último requisito pode muito bem ser revertido. <br><br><h4>  Pegadinha: argumentos numerados </h4><br>  Diferentemente dos nomes normais de <i>identificadores de</i> variáveis ​​(no regex: <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ), os argumentos numerados exigem colchetes (a interpolação de linha não).  ShellCheck diz: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  O ShellHarden se recusa a corrigi-lo (considera a diferença muito sutil). <br><br>  Como os parênteses são permitidos até 9, o ShellHarden permite todos os argumentos numerados. <br><br><h1>  Usando matrizes </h1><br>  Para poder citar todas as variáveis, você deve usar matrizes reais, não cadeias pseudo-massivas separadas por espaços. <br><br>  A sintaxe é detalhada, mas você precisa lidar com isso.  Esse basismo é apenas um dos motivos para abandonar a compatibilidade do POSIX para a maioria dos scripts de shell. <br><br>  Bom: <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Ruim: <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  É por isso que matrizes são uma função tão básica para um shell: os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">argumentos dos comandos são fundamentalmente matrizes</a> (e os scripts do shell são comandos e argumentos).  Podemos dizer que a concha, que artificialmente impossibilita a passagem de vários argumentos, será cômica e sem valor.  Algumas conchas comuns dessa categoria incluem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dash</a> e Busybox Ash.  Estes são shells mínimos compatíveis com POSIX - mas de que adianta a compatibilidade se o material mais importante <i>não</i> estiver no POSIX? <br><br><h3>  Casos excepcionais em que você realmente vai quebrar uma linha </h3><br>  Exemplo com <code>\v</code> como separador de dados (observe a segunda ocorrência): <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Dessa forma, evitamos a expansão do modelo, e o método funciona mesmo que o separador de dados seja <code>\n</code> .  A segunda ocorrência do separador de dados protege o último elemento, se for um espaço.  Por alguma razão, a opção <code>-d</code> deve ser a primeira, portanto, <code>-rad ''</code> opções em <code>-rad ''</code> tentador, mas não funciona.  Como a leitura retorna um valor diferente de zero nesse caso, ele deve ser protegido contra errexit ( <code>|| true</code> ), se ativado.  Testado no bash 4.0, 4.1, 4.2, 4.3 e 4.4. <br><br>  Alternativa para o bash 4.4: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1>  Onde iniciar um script bash </h1><br>  De algo assim: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br>  Isso inclui: <br><br><ul><li>  Shebang: <br><ul><li>  Problemas de portabilidade: o caminho absoluto para <code>env</code> provavelmente melhor para portabilidade do que o caminho absoluto para o <code>bash</code> .  Você pode ver o exemplo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NixOS</a> .  POSIX requer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">env</a> , mas não bash. </li><li>  Questões de segurança: para nenhum idioma, opções como <code>-euo pipefail</code> não serão aceitas favoravelmente <code>-euo pipefail</code> !  Isso se torna impossível ao usar o redirecionamento <code>env</code> , mas mesmo que seu shebang comece com <code>#!/bin/bash</code> , este não é o lugar para parâmetros que afetam o valor do script, pois eles podem ser substituídos, o que tornará possível a execução incorreta do script.  No entanto, como bônus, opções que não afetam o valor do script, como <code>set -x</code> , se usado, podem ser redefinidas. </li></ul></li><li>  O que precisamos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modo estrito não oficial do Bash</a> , com a verificação do recurso <code>set -u</code> .  Não precisamos de todo o modo estrito do Bash, porque a compatibilidade do shellcheck / shellharden significa citar tudo e tudo que é muito mais rigoroso.  Além disso, a opção <code>set -u</code> <b>não deve ser usada</b> no Bash 4.3 e versões anteriores.  Como essa opção <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">considera matrizes vazias como descartadas</a> nessas versões, as matrizes não podem ser usadas para os fins descritos aqui.  O uso de matrizes é a segunda dica mais importante deste guia (após as aspas) e a única razão pela qual sacrificamos a compatibilidade com o POSIX, de modo que isso não é inaceitável: ou não use <code>set -u</code> , ou use o Bash 4.4 ou outro shell normal como o Zsh.  É mais fácil falar do que fazer, porque existe a possibilidade de alguém ainda executar o seu script na versão antiga do Bash.  Felizmente, tudo o que funciona com <code>set -u</code> funcionará sem ele (para <code>set -e</code> você não pode dizer isso).  É por isso que é importante usar a verificação de versão.  Cuidado com a suposição de que o teste e o desenvolvimento ocorrem em um shell compatível com o Bash 4.4 (para que o aspecto <code>set -u</code> seja testado).  Se isso lhe incomoda, outra opção é recusar a compatibilidade (o script falha quando a verificação da versão falha) ou recusar <code>set -u</code> . </li><li>  <code>shopt -s nullglob</code> força o <code>for f in *.txt</code> a funcionar corretamente se o <code>*.txt</code> não encontrar arquivos.  O comportamento padrão (também conhecido como <i>passglob</i> ) passa o modelo inalterado, o que, no caso de um resultado zero, é perigoso por vários motivos.  Para <i>globstar,</i> isso ativa a pesquisa recursiva.  Substituição é mais fácil de usar do que <code>find</code> .  Então use. </li></ul><br>  Mas não: <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li>  Definir o <i>delimitador de campo interno como</i> uma sequência vazia torna impossível dividir a palavra.  Parece a solução perfeita.  Infelizmente, esse é um substituto incompleto para citar variáveis ​​e substituições de comandos e, como você usará aspas, ele não fornece nada.  O motivo pelo qual as aspas ainda precisam ser usadas é porque, caso contrário, as seqüências vazias se tornam matrizes vazias (como no <code>test $x = ""</code> ) e a expansão indireta do modelo ainda é possível.  Além disso, problemas com essa variável também causarão problemas com comandos como <code>read</code> , que quebram construções como <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> . </li><li>  A extensão do modelo está desativada: não apenas a extensão indireta infame, mas também a extensão direta sem complicações, que, como eu disse, você deve usar.  Então é difícil de aceitar.  E isso também é totalmente opcional para um script compatível com shellcheck / shellharden. </li><li>  Ao contrário do <i>nullglob</i> , o <i>failglob</i> falha com um resultado nulo.  Embora para a maioria dos comandos isso faça sentido, por exemplo, <code>rm -- *.txt</code> (porque para a maioria dos comandos ainda não é esperado que seja executado com resultado zero), obviamente o <i>failglob</i> pode ser usado apenas se você não espera um resultado zero.  Isso significa que geralmente você não colocará modelos de grupo em argumentos de comando, a menos que assuma o mesmo.  Mas o que sempre pode acontecer é usar <i>nullglob</i> e estender o modelo para argumentos nulos em construções que podem levá-los, como um loop ou atribuir valores a uma matriz ( <code>txt_files=(*.txt)</code> ). </li></ul><br><h1>  Como concluir um script bash </h1><br>  O status de saída do script é o status do último comando executado.  Certifique-se de que isso represente sucesso ou fracasso real. <br><br>  O pior é deixar a solução em uma condição não relacionada na forma de uma lista AND no final do script.  Se a condição for falsa, o último comando executado será a própria condição. <br><br>  Para errexit, as condições na forma de uma lista AND nunca são usadas em primeiro lugar.  Se o errexit não for usado, considere manipular erros mesmo para o último comando, para que seu status de saída não seja mascarado se um código adicional for adicionado ao script. <br><br>  Ruim: <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br>  Bom (opção errexit): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Bom (opção de tratamento de erros): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1>  Como usar o errexit </h1><br>  Como <code>set -e</code> . <br><br><h3>  Limpeza programada no nível do programa </h3><br>  Se o errexit estiver funcionando como deveria, use-o para instalar qualquer limpeza necessária na saída. <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3>  Capturado: errexit é ignorado nos argumentos de comando </h3><br>  Aqui está uma "bomba" ramificada muito complicada, cuja compreensão valeu muito para mim.  Meu script de build funcionou bem em diferentes máquinas de desenvolvimento, mas colocou o servidor de build de joelhos: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br>  Correto (substituição de comando na tarefa): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  Aviso: <code>local</code> comandos internos <code>local</code> e de <code>export</code> permanecem comandos, portanto, isso ainda permanece errado: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  ShellCheck avisa apenas sobre comandos especiais como <code>local</code> neste caso. <br><br>  Para usar <code>local</code> , separe a declaração da tarefa: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3>  Capturado: errexit é ignorado dependendo do contexto do chamador </h3><br>  Às vezes, o POSIX é terrível.  O Errexit é ignorado em funções, comandos de grupo e até subcascas se o chamador verificar seu sucesso.  Todos esses exemplos imprimem <code>Unreachable</code> e <code>Great success</code> , por mais estranho que possa parecer. <br><br>  Subshell: <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Equipe do grupo: <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Função: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Por isso, bash com errexit é praticamente inadequado para vinculação: sim, <i>é possível</i> agrupar funções errexit para que funcionem, mas há dúvidas de que o esforço economizado (no tratamento explícito de erros) valha a pena.  Em vez disso, considere dividir em scripts totalmente autônomos. <br><br><h1>  Evitando chamar o shell com aspas incorretas </h1><br>  Ao invocar comandos de outras linguagens de programação, é mais fácil cometer um erro e invocar implicitamente o shell.  Se esse comando do shell for estático, é bom - funciona ou não.  Mas se o seu programa de alguma forma processar as linhas para criar esse comando, você precisará entender - você está <b>gerando um shell script</b> !  Eu raramente quero fazer isso, e é muito cansativo organizar tudo corretamente: <br><br><ul><li>  cite cada argumento; </li><li>  escape dos caracteres correspondentes nos argumentos. </li></ul><br>  Não importa em qual linguagem de programação você faça isso, há pelo menos três maneiras de criar uma equipe corretamente.  Em ordem de preferência: <br><br><h3>  Plano A: faça sem casca </h3><br>  Se este for apenas um comando com argumentos (ou seja, nenhum shell funciona como canalizar ou redirecionar), selecione uma opção de matriz. <br><br><ul><li>  Ruim (python3): <code>subprocess.check_call('rm -rf ' + path)</code> </li><li>  Bom (python3): <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br>  Ruim (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br>  Bom (C / POSIX), menos manipulação de erros: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Plano B: um script de shell estático </h3><br>  Se um shell for necessário, deixe os argumentos serem argumentos.  Você pode pensar que foi complicado escrever um shell script especial em seu próprio arquivo e acessá-lo até que você veja esse truque: <br><br>  Ruim (python3): <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br>  Bom (python3): <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br>  Você pode perceber o script de shell? <br><br>  É isso mesmo, o comando printf é redirecionado.  Preste atenção aos argumentos numerados corretamente citados.  Implementar um script de shell estático é bom. <br><br>  Esses exemplos são executados no Docker porque, caso contrário, não serão tão úteis, mas o Docker também é um ótimo exemplo de um comando que executa outros comandos com base em argumentos.  Ao contrário do Ssh, como veremos mais adiante. <br><br><h3>  Última opção: processamento de linha </h3><br>  Se for uma sequência de caracteres (por exemplo, porque deve funcionar com o <code>ssh</code> ), não poderá ser ignorada.  Você precisará citar cada argumento e escapar dos caracteres necessários para sair dessas aspas.  A maneira mais fácil é mudar para aspas simples, porque elas têm as regras de escape mais simples.  Apenas uma regra: <code>'</code> → <code>'\"</code> . <br><br>  Nome típico de arquivo com aspas simples: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br>  Como usar esse truque para executar com segurança comandos ssh?  Isso é impossível!  Bem, aqui está a solução "geralmente certa": <br><br><ul><li>  A solução "frequentemente correta" (python3): <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br>  Nós mesmos devemos combinar todos os argumentos em uma string para que o Ssh não faça errado: se você tentar passar vários argumentos do ssh, ele começará a combinar traiçoeiramente os argumentos sem aspas. <br><br>  A razão pela qual isso geralmente não é possível é porque a decisão correta depende das preferências do usuário do outro lado, a saber, o shell remoto, que pode ser qualquer coisa.  Basicamente, poderia até ser sua mãe.  É “geralmente correto” supor que o shell remoto seja bash ou outro shell compatível com POSIX, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">peixe é incompatível nesse estágio</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413117/">https://habr.com/ru/post/pt413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413105/index.html">Notas do provedor de IoT. Ativação e segurança no LoraWAN</a></li>
<li><a href="../pt413107/index.html">Tradução do wiki do projeto Svelto.ECS. Estrutura do ECS para Unity3D</a></li>
<li><a href="../pt413109/index.html">Como criar uma plataforma de integração de produtos SaaS: experiência de checkout na nuvem de pôsteres</a></li>
<li><a href="../pt413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../pt413113/index.html">Classe JavaScript Suporte à serialização de JavaScript</a></li>
<li><a href="../pt413119/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 317 (28 de maio a 3 de junho de 2018)</a></li>
<li><a href="../pt413121/index.html">Tour fotográfico de Moscou coworking #tceh</a></li>
<li><a href="../pt413123/index.html">JOIN nos bancos de dados NoSQL</a></li>
<li><a href="../pt413125/index.html">A terapia gênica oferece aos pacientes pequenos com atrofia muscular a chance de sobreviver</a></li>
<li><a href="../pt413127/index.html">Algumas palavras sobre o desempenho real do hypervisor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>