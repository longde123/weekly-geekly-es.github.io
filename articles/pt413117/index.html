<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèø üèº üë∞üèΩ Como programar com seguran√ßa no bash üë©üèø üë©‚Äçüîß üÜô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por que bater? 
 Existem matrizes e modo de seguran√ßa no bash. Quando usado corretamente, o bash √© quase consistente com pr√°ticas de codifica√ß√£o segur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como programar com seguran√ßa no bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1>  Por que bater? </h1><br>  Existem matrizes e modo de seguran√ßa no bash.  Quando usado corretamente, o bash √© quase consistente com pr√°ticas de codifica√ß√£o seguras. <br><br>  √â mais dif√≠cil cometer um erro no peixe, mas n√£o h√° modo seguro.  Portanto, a cria√ß√£o de prot√≥tipos em peixes e a tradu√ß√£o de peixes para o bash deve ser uma boa id√©ia, se voc√™ souber como faz√™-lo corretamente. <br><br><h1>  Pref√°cio </h1><br>  Este guia acompanha o ShellHarden, mas o autor tamb√©m recomenda o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ShellCheck</a> para que as regras do ShellHarden n√£o sejam diferentes do ShellCheck. <br><br>  Bash n√£o √© um idioma em que a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">maneira mais correta de resolver um problema ao mesmo tempo seja a mais f√°cil</a> .  Se voc√™ fizer o exame de programa√ß√£o segura do bash, a primeira regra do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BashPitfalls</a> seria: sempre use aspas. <br><br><h1>  A principal coisa que voc√™ precisa saber sobre programa√ß√£o no bash </h1><br>  <b>Aspas man√≠acas!</b>  Uma vari√°vel n√£o citada deve ser considerada uma bomba armada: ela explode em contato com um espa√ßo.  Sim, ele explode no sentido de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dividir uma string em uma matriz</a> .  Em particular, extens√µes vari√°veis ‚Äã‚Äãcomo <code>$var</code> e substitui√ß√µes de comandos como <code>$(cmd)</code> s√£o <i>divididas</i> em <i>palavras</i> quando a cadeia interna √© expandida em uma matriz devido √† divis√£o em uma vari√°vel especial <code>$IFS</code> com um espa√ßo padr√£o.  Isso geralmente √© invis√≠vel, porque na maioria das vezes o resultado √© uma matriz de 1 elemento, indistingu√≠vel da sequ√™ncia esperada. <br><a name="habracut"></a><br>  N√£o apenas isso √© expandido, mas tamb√©m curingas ( <code>*?</code> ).  Esse processo ocorre depois que a palavra √© dividida; portanto, se houver pelo menos um curinga na palavra, a palavra se transformar√° em um curinga que se aplica a qualquer caminho de arquivo adequado.  Portanto, esse recurso come√ßa a se aplicar ao sistema de arquivos! <br><br>  A cota√ß√£o suprime a divis√£o de palavras e a expans√£o de padr√µes para vari√°veis ‚Äã‚Äãe substitui√ß√µes de comandos. <br><br>  Extens√£o vari√°vel: <br><br><ul><li>  Bom: <code>"$my_var"</code> </li><li>  Ruim: <code>$my_var</code> </li></ul><br>  Substitui√ß√£o de comando: <br><br><ul><li>  Bom: <code>"$(cmd)"</code> </li><li>  Ruim: <code>$(cmd)</code> </li></ul><br>  Existem exce√ß√µes com aspas opcionais, mas as aspas nunca ser√£o prejudicadas, e a regra geral √© ter cuidado para n√£o citar vari√°veis ‚Äã‚Äãn√£o citadas, portanto, n√£o procuraremos exce√ß√µes de borda para seu benef√≠cio.  Parece errado, e a pr√°tica errada √© generalizada o suficiente para levantar suspeitas: muitos scripts foram escritos com processamento quebrado de nomes de arquivos e espa√ßos neles ... <br><br>  O ShellHarden menciona apenas algumas exce√ß√µes - essas vari√°veis ‚Äã‚Äãt√™m conte√∫do num√©rico como <code>$?</code>  , <code>$#</code> e <code>${#array[@]}</code> . <br><br><h3>  Preciso usar backticks? </h3><br>  As substitui√ß√µes de comando tamb√©m podem ter o seguinte formato: <br><br><ul><li>  Correto: <code>"`cmd`"</code> </li><li>  Ruim: <code>`cmd`</code> </li></ul><br>  Embora esse estilo possa ser usado corretamente, parece menos conveniente entre aspas e menos leg√≠vel quando aninhado.  O consenso aqui √© bastante claro: evite-o. <br><br>  A ShellHarden reescreve essas marcas de verifica√ß√£o entre colchetes em d√≥lares. <br><br><h3>  Aparelhos precisam ser usados? </h3><br>  Os colchetes s√£o usados ‚Äã‚Äãpara interpolar cadeias de caracteres, portanto, geralmente s√£o redundantes: <br><br><ul><li>  Ruim: <code>some_command $arg1 $arg2 $arg3</code> </li><li>  Pobre e detalhado: <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li>  Bom, mas detalhado: <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li>  Bom: <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br>  Teoricamente, sempre usar chaves n√£o √© um problema, mas de acordo com a experi√™ncia do seu autor, existe uma forte correla√ß√£o negativa entre o uso desnecess√°rio de chaves e o uso correto de aspas - quase todo mundo escolhe a forma ‚Äúruim e detalhada‚Äù em vez da forma ‚Äúboa, mas detalhada‚Äù! <br><br>  Teorias do seu autor: <br><br><ul><li>  Por causa do medo de fazer algo errado: em vez do perigo real (falta de aspas), os iniciantes podem se preocupar com o fato de a vari√°vel <code>$prefix</code> fazer com que a vari√°vel <code>"$prefix_postfix"</code> se expanda, mas n√£o funciona dessa maneira. </li><li>  Culto √† carga: escrever c√≥digo na alian√ßa do medo errado que o precedeu. </li><li>  Os colchetes competem entre aspas pelo limite da verbosidade permitida. </li></ul><br>  Portanto, decidiu-se proibir chaves desnecess√°rias: o ShellHarden substitui essas op√ß√µes pela forma mais simples. <br><br>  E agora sobre interpola√ß√£o de strings, onde chaves s√£o realmente √∫teis: <br><br><ul><li>  Ruim (concatena√ß√£o): <code>$var1"more string content"$var2</code> </li><li>  Bom (concatena√ß√£o): <code>"$var1""more string content""$var2"</code> </li><li>  Bom (interpola√ß√£o): <code>"${var1}more string content${var2}"</code> </li></ul><br>  Concatena√ß√£o e interpola√ß√£o no bash s√£o equivalentes mesmo em matrizes (o que √© rid√≠culo). <br><br>  Como o ShellHarden n√£o formata estilos, n√£o √© necess√°rio alterar o c√≥digo correto.  Isso √© verdade para a op√ß√£o "boa (interpola√ß√£o)": do ponto de vista do ShellHarden, essa ser√° a forma canonicamente correta. <br><br>  O ShellHarden agora est√° adicionando e removendo chaves, conforme necess√°rio: em um mau exemplo, o var1 √© fornecido com colchetes, mas eles n√£o s√£o permitidos para o var2, mesmo no caso de ‚Äúbom (interpola√ß√£o)‚Äù, pois nunca s√£o necess√°rios no final da linha.  O √∫ltimo requisito pode muito bem ser revertido. <br><br><h4>  Pegadinha: argumentos numerados </h4><br>  Diferentemente dos nomes normais de <i>identificadores de</i> vari√°veis ‚Äã‚Äã(no regex: <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ), os argumentos numerados exigem colchetes (a interpola√ß√£o de linha n√£o).  ShellCheck diz: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  O ShellHarden se recusa a corrigi-lo (considera a diferen√ßa muito sutil). <br><br>  Como os par√™nteses s√£o permitidos at√© 9, o ShellHarden permite todos os argumentos numerados. <br><br><h1>  Usando matrizes </h1><br>  Para poder citar todas as vari√°veis, voc√™ deve usar matrizes reais, n√£o cadeias pseudo-massivas separadas por espa√ßos. <br><br>  A sintaxe √© detalhada, mas voc√™ precisa lidar com isso.  Esse basismo √© apenas um dos motivos para abandonar a compatibilidade do POSIX para a maioria dos scripts de shell. <br><br>  Bom: <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Ruim: <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  √â por isso que matrizes s√£o uma fun√ß√£o t√£o b√°sica para um shell: os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">argumentos dos comandos s√£o fundamentalmente matrizes</a> (e os scripts do shell s√£o comandos e argumentos).  Podemos dizer que a concha, que artificialmente impossibilita a passagem de v√°rios argumentos, ser√° c√¥mica e sem valor.  Algumas conchas comuns dessa categoria incluem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dash</a> e Busybox Ash.  Estes s√£o shells m√≠nimos compat√≠veis com POSIX - mas de que adianta a compatibilidade se o material mais importante <i>n√£o</i> estiver no POSIX? <br><br><h3>  Casos excepcionais em que voc√™ realmente vai quebrar uma linha </h3><br>  Exemplo com <code>\v</code> como separador de dados (observe a segunda ocorr√™ncia): <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Dessa forma, evitamos a expans√£o do modelo, e o m√©todo funciona mesmo que o separador de dados seja <code>\n</code> .  A segunda ocorr√™ncia do separador de dados protege o √∫ltimo elemento, se for um espa√ßo.  Por alguma raz√£o, a op√ß√£o <code>-d</code> deve ser a primeira, portanto, <code>-rad ''</code> op√ß√µes em <code>-rad ''</code> tentador, mas n√£o funciona.  Como a leitura retorna um valor diferente de zero nesse caso, ele deve ser protegido contra errexit ( <code>|| true</code> ), se ativado.  Testado no bash 4.0, 4.1, 4.2, 4.3 e 4.4. <br><br>  Alternativa para o bash 4.4: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1>  Onde iniciar um script bash </h1><br>  De algo assim: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br>  Isso inclui: <br><br><ul><li>  Shebang: <br><ul><li>  Problemas de portabilidade: o caminho absoluto para <code>env</code> provavelmente melhor para portabilidade do que o caminho absoluto para o <code>bash</code> .  Voc√™ pode ver o exemplo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NixOS</a> .  POSIX requer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">env</a> , mas n√£o bash. </li><li>  Quest√µes de seguran√ßa: para nenhum idioma, op√ß√µes como <code>-euo pipefail</code> n√£o ser√£o aceitas favoravelmente <code>-euo pipefail</code> !  Isso se torna imposs√≠vel ao usar o redirecionamento <code>env</code> , mas mesmo que seu shebang comece com <code>#!/bin/bash</code> , este n√£o √© o lugar para par√¢metros que afetam o valor do script, pois eles podem ser substitu√≠dos, o que tornar√° poss√≠vel a execu√ß√£o incorreta do script.  No entanto, como b√¥nus, op√ß√µes que n√£o afetam o valor do script, como <code>set -x</code> , se usado, podem ser redefinidas. </li></ul></li><li>  O que precisamos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modo estrito n√£o oficial do Bash</a> , com a verifica√ß√£o do recurso <code>set -u</code> .  N√£o precisamos de todo o modo estrito do Bash, porque a compatibilidade do shellcheck / shellharden significa citar tudo e tudo que √© muito mais rigoroso.  Al√©m disso, a op√ß√£o <code>set -u</code> <b>n√£o deve ser usada</b> no Bash 4.3 e vers√µes anteriores.  Como essa op√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">considera matrizes vazias como descartadas</a> nessas vers√µes, as matrizes n√£o podem ser usadas para os fins descritos aqui.  O uso de matrizes √© a segunda dica mais importante deste guia (ap√≥s as aspas) e a √∫nica raz√£o pela qual sacrificamos a compatibilidade com o POSIX, de modo que isso n√£o √© inaceit√°vel: ou n√£o use <code>set -u</code> , ou use o Bash 4.4 ou outro shell normal como o Zsh.  √â mais f√°cil falar do que fazer, porque existe a possibilidade de algu√©m ainda executar o seu script na vers√£o antiga do Bash.  Felizmente, tudo o que funciona com <code>set -u</code> funcionar√° sem ele (para <code>set -e</code> voc√™ n√£o pode dizer isso).  √â por isso que √© importante usar a verifica√ß√£o de vers√£o.  Cuidado com a suposi√ß√£o de que o teste e o desenvolvimento ocorrem em um shell compat√≠vel com o Bash 4.4 (para que o aspecto <code>set -u</code> seja testado).  Se isso lhe incomoda, outra op√ß√£o √© recusar a compatibilidade (o script falha quando a verifica√ß√£o da vers√£o falha) ou recusar <code>set -u</code> . </li><li>  <code>shopt -s nullglob</code> for√ßa o <code>for f in *.txt</code> a funcionar corretamente se o <code>*.txt</code> n√£o encontrar arquivos.  O comportamento padr√£o (tamb√©m conhecido como <i>passglob</i> ) passa o modelo inalterado, o que, no caso de um resultado zero, √© perigoso por v√°rios motivos.  Para <i>globstar,</i> isso ativa a pesquisa recursiva.  Substitui√ß√£o √© mais f√°cil de usar do que <code>find</code> .  Ent√£o use. </li></ul><br>  Mas n√£o: <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li>  Definir o <i>delimitador de campo interno como</i> uma sequ√™ncia vazia torna imposs√≠vel dividir a palavra.  Parece a solu√ß√£o perfeita.  Infelizmente, esse √© um substituto incompleto para citar vari√°veis ‚Äã‚Äãe substitui√ß√µes de comandos e, como voc√™ usar√° aspas, ele n√£o fornece nada.  O motivo pelo qual as aspas ainda precisam ser usadas √© porque, caso contr√°rio, as seq√º√™ncias vazias se tornam matrizes vazias (como no <code>test $x = ""</code> ) e a expans√£o indireta do modelo ainda √© poss√≠vel.  Al√©m disso, problemas com essa vari√°vel tamb√©m causar√£o problemas com comandos como <code>read</code> , que quebram constru√ß√µes como <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> . </li><li>  A extens√£o do modelo est√° desativada: n√£o apenas a extens√£o indireta infame, mas tamb√©m a extens√£o direta sem complica√ß√µes, que, como eu disse, voc√™ deve usar.  Ent√£o √© dif√≠cil de aceitar.  E isso tamb√©m √© totalmente opcional para um script compat√≠vel com shellcheck / shellharden. </li><li>  Ao contr√°rio do <i>nullglob</i> , o <i>failglob</i> falha com um resultado nulo.  Embora para a maioria dos comandos isso fa√ßa sentido, por exemplo, <code>rm -- *.txt</code> (porque para a maioria dos comandos ainda n√£o √© esperado que seja executado com resultado zero), obviamente o <i>failglob</i> pode ser usado apenas se voc√™ n√£o espera um resultado zero.  Isso significa que geralmente voc√™ n√£o colocar√° modelos de grupo em argumentos de comando, a menos que assuma o mesmo.  Mas o que sempre pode acontecer √© usar <i>nullglob</i> e estender o modelo para argumentos nulos em constru√ß√µes que podem lev√°-los, como um loop ou atribuir valores a uma matriz ( <code>txt_files=(*.txt)</code> ). </li></ul><br><h1>  Como concluir um script bash </h1><br>  O status de sa√≠da do script √© o status do √∫ltimo comando executado.  Certifique-se de que isso represente sucesso ou fracasso real. <br><br>  O pior √© deixar a solu√ß√£o em uma condi√ß√£o n√£o relacionada na forma de uma lista AND no final do script.  Se a condi√ß√£o for falsa, o √∫ltimo comando executado ser√° a pr√≥pria condi√ß√£o. <br><br>  Para errexit, as condi√ß√µes na forma de uma lista AND nunca s√£o usadas em primeiro lugar.  Se o errexit n√£o for usado, considere manipular erros mesmo para o √∫ltimo comando, para que seu status de sa√≠da n√£o seja mascarado se um c√≥digo adicional for adicionado ao script. <br><br>  Ruim: <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br>  Bom (op√ß√£o errexit): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Bom (op√ß√£o de tratamento de erros): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1>  Como usar o errexit </h1><br>  Como <code>set -e</code> . <br><br><h3>  Limpeza programada no n√≠vel do programa </h3><br>  Se o errexit estiver funcionando como deveria, use-o para instalar qualquer limpeza necess√°ria na sa√≠da. <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3>  Capturado: errexit √© ignorado nos argumentos de comando </h3><br>  Aqui est√° uma "bomba" ramificada muito complicada, cuja compreens√£o valeu muito para mim.  Meu script de build funcionou bem em diferentes m√°quinas de desenvolvimento, mas colocou o servidor de build de joelhos: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br>  Correto (substitui√ß√£o de comando na tarefa): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  Aviso: <code>local</code> comandos internos <code>local</code> e de <code>export</code> permanecem comandos, portanto, isso ainda permanece errado: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  ShellCheck avisa apenas sobre comandos especiais como <code>local</code> neste caso. <br><br>  Para usar <code>local</code> , separe a declara√ß√£o da tarefa: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3>  Capturado: errexit √© ignorado dependendo do contexto do chamador </h3><br>  √Äs vezes, o POSIX √© terr√≠vel.  O Errexit √© ignorado em fun√ß√µes, comandos de grupo e at√© subcascas se o chamador verificar seu sucesso.  Todos esses exemplos imprimem <code>Unreachable</code> e <code>Great success</code> , por mais estranho que possa parecer. <br><br>  Subshell: <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Equipe do grupo: <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Fun√ß√£o: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Por isso, bash com errexit √© praticamente inadequado para vincula√ß√£o: sim, <i>√© poss√≠vel</i> agrupar fun√ß√µes errexit para que funcionem, mas h√° d√∫vidas de que o esfor√ßo economizado (no tratamento expl√≠cito de erros) valha a pena.  Em vez disso, considere dividir em scripts totalmente aut√¥nomos. <br><br><h1>  Evitando chamar o shell com aspas incorretas </h1><br>  Ao invocar comandos de outras linguagens de programa√ß√£o, √© mais f√°cil cometer um erro e invocar implicitamente o shell.  Se esse comando do shell for est√°tico, √© bom - funciona ou n√£o.  Mas se o seu programa de alguma forma processar as linhas para criar esse comando, voc√™ precisar√° entender - voc√™ est√° <b>gerando um shell script</b> !  Eu raramente quero fazer isso, e √© muito cansativo organizar tudo corretamente: <br><br><ul><li>  cite cada argumento; </li><li>  escape dos caracteres correspondentes nos argumentos. </li></ul><br>  N√£o importa em qual linguagem de programa√ß√£o voc√™ fa√ßa isso, h√° pelo menos tr√™s maneiras de criar uma equipe corretamente.  Em ordem de prefer√™ncia: <br><br><h3>  Plano A: fa√ßa sem casca </h3><br>  Se este for apenas um comando com argumentos (ou seja, nenhum shell funciona como canalizar ou redirecionar), selecione uma op√ß√£o de matriz. <br><br><ul><li>  Ruim (python3): <code>subprocess.check_call('rm -rf ' + path)</code> </li><li>  Bom (python3): <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br>  Ruim (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br>  Bom (C / POSIX), menos manipula√ß√£o de erros: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Plano B: um script de shell est√°tico </h3><br>  Se um shell for necess√°rio, deixe os argumentos serem argumentos.  Voc√™ pode pensar que foi complicado escrever um shell script especial em seu pr√≥prio arquivo e acess√°-lo at√© que voc√™ veja esse truque: <br><br>  Ruim (python3): <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br>  Bom (python3): <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br>  Voc√™ pode perceber o script de shell? <br><br>  √â isso mesmo, o comando printf √© redirecionado.  Preste aten√ß√£o aos argumentos numerados corretamente citados.  Implementar um script de shell est√°tico √© bom. <br><br>  Esses exemplos s√£o executados no Docker porque, caso contr√°rio, n√£o ser√£o t√£o √∫teis, mas o Docker tamb√©m √© um √≥timo exemplo de um comando que executa outros comandos com base em argumentos.  Ao contr√°rio do Ssh, como veremos mais adiante. <br><br><h3>  √öltima op√ß√£o: processamento de linha </h3><br>  Se for uma sequ√™ncia de caracteres (por exemplo, porque deve funcionar com o <code>ssh</code> ), n√£o poder√° ser ignorada.  Voc√™ precisar√° citar cada argumento e escapar dos caracteres necess√°rios para sair dessas aspas.  A maneira mais f√°cil √© mudar para aspas simples, porque elas t√™m as regras de escape mais simples.  Apenas uma regra: <code>'</code> ‚Üí <code>'\"</code> . <br><br>  Nome t√≠pico de arquivo com aspas simples: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br>  Como usar esse truque para executar com seguran√ßa comandos ssh?  Isso √© imposs√≠vel!  Bem, aqui est√° a solu√ß√£o "geralmente certa": <br><br><ul><li>  A solu√ß√£o "frequentemente correta" (python3): <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br>  N√≥s mesmos devemos combinar todos os argumentos em uma string para que o Ssh n√£o fa√ßa errado: se voc√™ tentar passar v√°rios argumentos do ssh, ele come√ßar√° a combinar trai√ßoeiramente os argumentos sem aspas. <br><br>  A raz√£o pela qual isso geralmente n√£o √© poss√≠vel √© porque a decis√£o correta depende das prefer√™ncias do usu√°rio do outro lado, a saber, o shell remoto, que pode ser qualquer coisa.  Basicamente, poderia at√© ser sua m√£e.  √â ‚Äúgeralmente correto‚Äù supor que o shell remoto seja bash ou outro shell compat√≠vel com POSIX, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">peixe √© incompat√≠vel nesse est√°gio</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413117/">https://habr.com/ru/post/pt413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413105/index.html">Notas do provedor de IoT. Ativa√ß√£o e seguran√ßa no LoraWAN</a></li>
<li><a href="../pt413107/index.html">Tradu√ß√£o do wiki do projeto Svelto.ECS. Estrutura do ECS para Unity3D</a></li>
<li><a href="../pt413109/index.html">Como criar uma plataforma de integra√ß√£o de produtos SaaS: experi√™ncia de checkout na nuvem de p√¥steres</a></li>
<li><a href="../pt413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../pt413113/index.html">Classe JavaScript Suporte √† serializa√ß√£o de JavaScript</a></li>
<li><a href="../pt413119/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 317 (28 de maio a 3 de junho de 2018)</a></li>
<li><a href="../pt413121/index.html">Tour fotogr√°fico de Moscou coworking #tceh</a></li>
<li><a href="../pt413123/index.html">JOIN nos bancos de dados NoSQL</a></li>
<li><a href="../pt413125/index.html">A terapia g√™nica oferece aos pacientes pequenos com atrofia muscular a chance de sobreviver</a></li>
<li><a href="../pt413127/index.html">Algumas palavras sobre o desempenho real do hypervisor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>