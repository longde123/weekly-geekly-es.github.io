<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🚒 👩‍👧‍👦 ☝🏽 Componentes isolados Zen na arquitetura Android 👩🏾‍🤝‍👨🏼 📂 🏞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alguns anos atrás, no Badoo, começamos a usar a abordagem MVI para o desenvolvimento do Android. O objetivo era simplificar uma base de código complex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Componentes isolados Zen na arquitetura Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/463781/"><img src="https://habrastorage.org/webt/0f/iz/h0/0fizh0eukxdsz6kb0zxcjiw5878.jpeg"><br><br>  Alguns anos atrás, no Badoo, começamos a usar a abordagem MVI para o desenvolvimento do Android.  O objetivo era simplificar uma base de código complexa e evitar o problema de estados incorretos: em cenários simples, é fácil, mas quanto mais complexo o sistema, mais difícil é mantê-lo na forma correta e mais fácil é perder um bug. <br><br>  No Badoo, todos os aplicativos são assíncronos - não apenas devido à ampla funcionalidade disponível ao usuário por meio da interface do usuário, mas também pela possibilidade de envio de dados unidirecionais pelo servidor.  Usando a abordagem antiga em nosso módulo de bate-papo, encontramos vários bugs estranhos, difíceis de reproduzir, que precisávamos gastar muito tempo para eliminar. <br><br>  Nosso colega Zsolt Kocsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Medium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Twitter</a> ) do escritório de Londres contou como o uso do MVI criamos componentes independentes que são fáceis de reutilizar, que vantagens obtemos e que desvantagens encontramos ao usar essa abordagem. <a name="habracut"></a><br><br>  Este é o terceiro artigo de uma série de artigos sobre a arquitetura do Badoo Android.  Links para os dois primeiros: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura moderna de MVI baseada em Kotlin</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Construindo um sistema de componentes reativos com o Kotlin</a> . <br></li></ol><br><h2>  Não fique com componentes mal conectados. </h2><br>  Conectividade fraca é considerada melhor que forte.  Se você confiar apenas em interfaces e não em implementações específicas, será mais fácil substituir componentes, será mais fácil alternar para outras implementações sem reescrever a maior parte do código, o que simplifica a inclusão de testes de unidade. <br><br>  Geralmente terminamos aqui e dizemos que fizemos todo o possível em termos de conectividade. <br><br>  No entanto, essa abordagem não é ótima.  Suponha que você tenha uma classe A que precise usar os recursos de três outras classes: B, C e D. Mesmo que você as refira através de interfaces, a classe A fica mais difícil com cada uma dessas classes: <br><br><ul><li>  ele conhece todos os métodos em todas as interfaces, seus nomes e tipos de retorno, mesmo que ele não os use; <br></li><li>  ao testar A, você precisa configurar mais zombarias ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">objeto simulado</a> ); <br></li><li>  é mais difícil usar A repetidamente em outros contextos em que não temos ou não queremos ter B, C e D. <br></li></ul><br>  Obviamente, é precisamente a classe A que deve determinar o conjunto mínimo de interfaces necessárias (princípio de segregação de interface do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SOLID</a> ).  No entanto, na prática, todos tivemos que lidar com situações em que, por uma questão de conveniência, foi adotada uma abordagem diferente: pegamos uma classe existente que implementa alguma funcionalidade, extraímos todos os seus métodos públicos para a interface e depois usamos essa interface onde a classe mencionada era necessária.  Ou seja, a interface foi usada não com base no que esse componente é necessário, mas com base no que outro componente pode oferecer. <br><br>  Com essa abordagem, a situação piora com o tempo.  Sempre que adicionamos novas funcionalidades, nossas classes são vinculadas a uma rede de novas interfaces que eles precisam conhecer.  As aulas estão crescendo em tamanho e os testes estão se tornando cada vez mais difíceis. <br><br>  Como resultado, quando você precisar usá-los em um contexto diferente, será quase impossível movê-los sem todo esse emaranhado com o qual eles estão conectados, mesmo através de interfaces.  Você pode fazer uma analogia: você quer usar uma banana, e ela está nas mãos de um macaco que fica pendurado em uma árvore; portanto, na carga da banana, você terá um pedaço inteiro da selva.  Em resumo, o processo de transferência leva muito tempo e logo você começa a se perguntar por que, na prática, é tão difícil reutilizar o código. <br><br><h2>  Componentes da caixa preta </h2><br>  Se queremos que o componente seja fácil e reutilizável, para isso não precisamos saber sobre duas coisas: <br><br><ul><li>  sobre onde mais ele é usado; <br></li><li>  sobre outros componentes que não estão relacionados à sua implementação interna. <br></li></ul><br>  A razão é clara: se você não conhece o mundo exterior, não estará conectado a ele. <br><br>  O que realmente queremos do componente: <br><br><ul><li>  definir seus próprios dados de entrada (entrada) e saída (saída); <br></li><li>  Não pense de onde esses dados vêm ou para onde vão; <br></li><li>  deve ser auto-suficiente para que não precisemos conhecer a estrutura interna do componente para seu uso. <br></li></ul><br>  Você pode considerar o componente como uma caixa preta ou um circuito integrado.  Ela tem contatos de entrada e saída.  Você os solda - e o microcircuito se torna parte de um sistema que não conhece nada. <br><br><img src="https://habrastorage.org/webt/ol/fy/04/olfy04qy7hmdfupiqifwqfx9jwa.jpeg"><br><br>  Até agora, supunha-se que estamos falando de fluxos de dados bidirecionais: se a classe A precisar de algo, extrai um método pela interface B e recebe o resultado na forma do valor retornado pela função. <br><br><img src="https://habrastorage.org/webt/yb/1s/4k/yb1s4ksgh4k3adpupkm9bkiiem0.png"><br><br>  Mas então A sabe sobre B, e queremos evitar isso. <br><br>  Obviamente, esse esquema faz sentido para os recursos de implementação de baixo nível.  Mas se precisarmos de um componente reutilizável que funcione como uma caixa preta independente, precisamos garantir que ele não saiba nada sobre interfaces externas, nomes de métodos ou valores de retorno. <br><br><h2>  Passamos à unidirecionalidade </h2><br>  Mas sem nomes e métodos de interface, não podemos chamar nada!  Tudo o que resta é usar um fluxo de dados unidirecional, no qual simplesmente obtemos entrada e geramos saída: <br><br><img src="https://habrastorage.org/webt/3p/zy/_m/3pzy_micni9yxdstnff6m3ilfxw.png"><br><br>  A princípio, isso pode parecer uma limitação, mas essa solução tem muitas vantagens, que serão discutidas abaixo. <br><br>  Desde o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo</a> , sabemos que os recursos (Recurso) definem seus próprios dados de entrada (Desejo) e seus próprios dados de saída (Estado).  Portanto, não importa para eles de onde vem o Desejo ou para onde vai o Estado. <br><br><img src="https://habrastorage.org/webt/aw/wn/c0/awwnc0nkjkhiedmyxd00ovtdhrw.png"><br><br>  É disso que precisamos!  Os recursos podem ser usados ​​onde quer que você possa dar entrada e, com a saída, você pode fazer o que quiser.  E como os recursos não se comunicam diretamente com outros componentes, são módulos independentes e não relacionados. <br><br>  Agora pegue o View e projete-o para que ele também seja um módulo independente. <br><br>  Primeiro, o View deve ser o mais simples possível, para que ele possa lidar apenas com suas tarefas internas. <br><br>  Que tipo de tarefas?  Existem dois deles: <br><br><ul><li>  renderizando ViewModel (entrada); <br></li><li>  acionando ViewEvents dependendo das ações do usuário (saída). <br></li></ul><br>  Por que usar o ViewModel?  Por que não desenhar diretamente o estado do recurso? <br><br><ul><li>  (Não) exibir um recurso na tela não faz parte da implementação.  O View deve ser capaz de renderizar-se se os dados vierem de várias fontes. <br></li><li>  Não há necessidade de refletir a complexidade do estado na Visualização.  O ViewModel deve conter apenas as informações prontas para exibição necessárias para mantê-las simples. <br></li></ul><br>  Além disso, o View não deve se interessar pelo seguinte: <br><br><ul><li>  de onde vêm todos esses ViewModels; <br></li><li>  o que acontece quando o ViewEvent é acionado; <br></li><li>  qualquer lógica de negócios; <br></li><li>  rastreamento analítico; <br></li><li>  diário <br></li><li>  outras tarefas. <br></li></ul><br>  Todas essas são tarefas externas e o View não deve estar conectado a elas.  Vamos parar e resumir a simplicidade da exibição: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooView</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bgColor: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ButtonClicked : Event() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextFocusChanged</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasFocus: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : Event() } }</code> </pre> <br>  Uma implementação do Android deve: <br><br><ol><li>  Encontre visualizações do Android por seu ID. <br></li><li>  Implemente o método de aceitação da interface do consumidor, definindo o valor no ViewModel. <br></li><li>  Defina ouvintes (ClickListeners) para interagir com a interface do usuário para gerar eventos específicos. <br></li></ol><br>  Um exemplo: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooViewImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events: PublishRelay&lt;Event&gt; = PublishRelay.create&lt;Event&gt;() ) : LinearLayout(context, attrs, defStyle), FooView, <span class="hljs-comment"><span class="hljs-comment">// delegate implementing ObservableSource to our Relay ObservableSource&lt;Event&gt; by events { // 1. find the views private val title: TextView by lazy { findViewById&lt;TextView&gt;(R.id.title)} private val panel: ViewGroup by lazy { findViewById&lt;ViewGroup&gt;(R.id.panel)} private val button: Button by lazy { findViewById&lt;Button&gt;(R.id.button)} private val editText: EditText by lazy { findViewById&lt;EditText&gt;(R.id.editText)} // 2. set listeners to trigger Events override fun onFinishInflate() { super.onFinishInflate() button.setOnClickListener { events.accept(Event.ButtonClicked) } editText.setOnFocusChangeListener { _, hasFocus -&gt; events.accept(Event.TextFocusChanged(hasFocus)) } } // 3. render the ViewModel override fun accept(vm: ViewModel) { title.text = vm.title panel.setBackgroundColor(ContextCompat.getColor(context, vm.bgColor)) } }</span></span></code> </pre><br>  Se não estiver limitado a Feature e View, eis a aparência de qualquer outro componente com esta abordagem: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericBlackBoxComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Input</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Output</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Agora tudo está claro com o padrão! <br><br><img src="https://habrastorage.org/webt/pt/pi/pb/ptpipbdlny1tekgwhhgnwu3pg2q.png"><br><br><h2>  Unir, unir, unir! </h2><br>  Mas e se tivermos componentes diferentes e cada um deles tiver sua própria entrada e saída?  Vamos conectá-los! <br><br>  Felizmente, isso pode ser feito facilmente usando o Binder, o que também ajuda a criar o escopo correto, como sabemos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segundo artigo</a> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// will automatically dispose of the created rx subscriptions when the lifecycle ends: val binder = Binder(lifecycle) // connect some observable sources to some consumers with element transformation: binder.bind(outputA to inputB using transformer1) binder.bind(outputB to inputA using transformer2)</span></span></code> </pre><br><h2>  A primeira vantagem: fácil de expandir sem modificações </h2><br>  O uso de componentes não relacionados na forma de caixas pretas que são conectadas apenas temporariamente permite adicionar novas funcionalidades sem modificar os componentes existentes. <br><br>  Veja um exemplo simples: <br><br><img src="https://habrastorage.org/webt/qz/py/4j/qzpy4jxjtbnceillcf05-jay_ym.png"><br><br>  Aqui, os recursos (F) e o View (V) são simplesmente conectados um ao outro. <br><br>  As ligações correspondentes serão: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer)</code> </pre> <br><br>  Suponha que desejemos adicionar o rastreamento de alguns eventos da interface do usuário a este sistema. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AnalyticsTracker : Consumer&lt;AnalyticsTracker.Event&gt; { <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ProfileImageClicked: Event() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> EditButtonClicked : Event() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsTracker</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// TODO Implement actual tracking } }</span></span></code> </pre><br>  A boa notícia é que podemos fazer isso simplesmente reutilizando o canal de visualização de saída existente: <br><br><img src="https://habrastorage.org/webt/en/sz/ld/enszldmuacqrd0e7wmumdm_duoi.png"><br><br>  No código, fica assim: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer) <span class="hljs-comment"><span class="hljs-comment">// +1 line, nothing else changed: bind(view to analyticsTracker using uiEventToAnalyticsEventTransformer)</span></span></code> </pre><br>  Novas funcionalidades podem ser adicionadas com apenas uma linha de ligação adicional.  Agora, não podemos apenas não alterar uma única linha de código View, mas nem sabemos que a saída é usada para resolver um novo problema. <br><br>  Obviamente, agora é mais fácil evitar preocupações adicionais e componentes desnecessariamente complicados.  Eles permanecem simples.  Você pode adicionar funcionalidade ao sistema simplesmente conectando componentes aos já existentes. <br><br><h2>  Segunda vantagem: fácil de usar repetidamente </h2><br>  Usando o exemplo de Feature e View, pode-se ver claramente que podemos adicionar uma nova fonte de entrada ou consumidor de dados de saída com apenas uma linha com ligação.  Isso facilita muito a reutilização de componentes em diferentes partes do aplicativo. <br><br>  No entanto, essa abordagem não se limita às classes.  Essa maneira de usar interfaces nos permite descrever componentes reativos independentes de qualquer tamanho. <br><br>  Ao nos limitarmos a determinados dados de entrada e saída, nos livramos da necessidade de saber como tudo funciona sob o capô e, portanto, evitamos facilmente vincular acidentalmente os componentes internos dos componentes com outras partes do sistema.  E sem encadernação, você pode facilmente e simplesmente usar componentes repetidamente. <br><br>  Voltaremos a isso em um dos artigos a seguir e consideraremos exemplos do uso dessa técnica para conectar componentes de nível superior. <br><br><h2>  Primeira pergunta: onde colocar as ligações? </h2><br><ol><li>  Escolha o nível de abstração.  Dependendo da arquitetura, isso pode ser uma Atividade, um fragmento ou algum ViewController.  Espero que você ainda tenha algum nível de abstração nas partes em que não há interface do usuário.  Por exemplo, em alguns dos escopos da árvore de contexto de DI. <br></li><li>  Crie uma classe separada para a ligação no mesmo nível que esta parte da interface do usuário.  Se for FooActivity, FooFragment ou FooViewController, você poderá colocar FooBindings ao lado dele. <br></li><li>  Certifique-se de incorporar FooBindings nas mesmas instâncias de componente usadas na atividade, fragmento etc. <br></li><li>  Para formar o escopo das ligações, use o Ciclo de Vida da Atividade ou Fragmento.  Se esse loop não estiver vinculado ao Android, você poderá criar gatilhos manualmente, por exemplo, ao criar ou destruir um escopo de DI.  Outros exemplos de escopo são descritos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segundo artigo</a> . <br></li></ol><br><h3>  Segunda pergunta: testing </h3><br>  Como nosso componente não sabe nada sobre os outros, geralmente não precisamos de stubs.  Os testes são simplificados para verificar a resposta correta do componente aos dados de entrada e produzir os resultados esperados. <br><br>  No caso do Feature, isso significa: <br><br><ul><li>  a capacidade de testar se determinados dados de entrada geram o estado esperado (saída). <br></li></ul><br>  E no caso do View: <br><br><ul><li>  podemos testar se um determinado ViewModel (entrada) leva ao estado esperado da interface do usuário; <br></li><li>  podemos testar se a simulação de interação com a interface do usuário leva à inicialização no ViewEvent (saída) esperado. <br></li></ul><br>  Obviamente, as interações entre componentes não desaparecem magicamente.  Acabamos de extrair essas tarefas dos próprios componentes.  Eles ainda precisam ser testados.  Mas onde? <br><br>  No nosso caso, o Binders é responsável por conectar os componentes: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// this is wherever you put your bindings, depending on your architecture class BindingEnvironment( private val component1: Component1, private val component2: Component2 ) { fun createBindings(lifecycle: Lifecycle) { val binder = Binder(lifecycle) binder.bind(component1 to component2 using Transformer()) } }</span></span></code> </pre><br>  Nossos testes devem confirmar o seguinte: <br><br>  1. Transformadores (mapeadores). <br><br>  Algumas conexões possuem mapeadores e você precisa garantir que eles convertam corretamente os elementos.  Na maioria dos casos, um teste de unidade muito simples é suficiente para isso, pois os mapeadores geralmente também são muito simples: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCase1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> transformer = Transformer() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testInput = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actualOutput = transformer.invoke(testInput) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedOutput = TODO() assertEquals(expectedOutput, actualOutput) }</code> </pre><br>  2. Comunicação. <br><br>  Você precisa garantir que as conexões estejam configuradas corretamente.  Qual é o objetivo do trabalho de componentes e mapeadores individuais, se por algum motivo a conexão entre eles não tiver sido estabelecida?  Tudo isso pode ser testado configurando o ambiente de ligação com stubs, fontes de inicialização e verificando se os resultados esperados são recebidos no lado do cliente: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BindingEnvironmentTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component1: ObservableSource&lt;Component1.Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component2: Consumer&lt;Component2.Input&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindings: BindingEnvironment <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component1 = PublishRelay.create() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component2 = mock() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings = BindingEnvironment(component1, component2) } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testBindings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> simulatedOutputOnLeftSide = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedInputOnRightSide = TODO() component1.accept(simulatedOutputOnLeftSide) verify(component2).accept(expectedInputOnRightSide) } }</code> </pre><br>  E, embora para testar você precise escrever sobre a mesma quantidade de código que em outras abordagens, no entanto, componentes autossuficientes facilitam o teste de partes individuais, pois as tarefas são claramente separadas. <br><br><h2>  Alimento para o pensamento </h2><br>  Embora a descrição do nosso sistema na forma de um gráfico de caixas pretas seja boa para o entendimento geral, isso só funciona desde que o tamanho do sistema seja relativamente pequeno. <br><br>  Cinco a oito linhas de ligação são aceitáveis.  Mas, tendo conectado mais, será bastante difícil entender o que está acontecendo: <br><br><img src="https://habrastorage.org/webt/x6/88/du/x688duddke2ejaf65ywgz60u4ic.png"><br><br><img src="https://habrastorage.org/webt/93/lm/wl/93lmwld0ldslgadh1kre2n2uvou.png"><br><br>  Fomos confrontados com o fato de que, com um aumento no número de links (havia ainda mais do que no fragmento de código apresentado), a situação se tornou ainda mais complicada.  O motivo não estava apenas no número de linhas - algum tipo de ligação poderia ser agrupado e extraído para diferentes métodos - mas também porque se tornou cada vez mais difícil manter tudo à vista.  E este é sempre um mau sinal.  Se dezenas de componentes diferentes estão localizados no mesmo nível, é impossível imaginar todas as interações possíveis. <br><br>  O motivo é o uso de componentes - caixas pretas ou algo mais? <br><br>  Obviamente, se o escopo que você está descrevendo for inicialmente complexo, nenhuma abordagem o salvará do problema mencionado até você dividir o sistema em partes menores.  Vai ser complicado, mesmo sem uma lista enorme de ligações, simplesmente não será tão óbvio.  Além disso, é muito melhor se a complexidade for expressa explicitamente e não oculta.  É melhor ver uma lista crescente de junções de linha única que lembram quantos componentes individuais você tem que desconhecem sobre esses links ocultos nas classes em diferentes chamadas de método. <br><br>  Como os componentes são simples (são caixas pretas e processos adicionais não fluem para eles), é mais fácil separá-los, o que significa que este é um passo na direção certa.  Mudamos a dificuldade para um lugar - para a lista de ligações, um olhar que permite avaliar a situação geral e começar a pensar em como sair dessa bagunça. <br><br>  Encontrar uma solução nos levou muito tempo e ainda está em andamento.  Planejamos falar sobre como lidar com esse problema nos seguintes artigos.  Fique em contato! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463781/">https://habr.com/ru/post/pt463781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463769/index.html">Mitap Netologii “Carreira em ciência de dados: do iniciante ao médio”</a></li>
<li><a href="../pt463771/index.html">[Peter] Encontrando JUG.ru com Sebastian Dashner - Torne mais alegre a realização de testes corporativos</a></li>
<li><a href="../pt463773/index.html">Como é organizada a proteção das crianças contra as informações - e a história encantadora sobre de onde elas vieram (18+)</a></li>
<li><a href="../pt463775/index.html">Quem usa o protocolo de autenticação SAML 2.0</a></li>
<li><a href="../pt463777/index.html">Monitoramento de disponibilidade do host do Powershell</a></li>
<li><a href="../pt463785/index.html">Visão geral dos emuladores de terminal</a></li>
<li><a href="../pt463787/index.html">Grande surpresa velha da HP</a></li>
<li><a href="../pt463789/index.html">O poder dos genéricos em Swift. Parte 2</a></li>
<li><a href="../pt463791/index.html">Punho de ferro: cinemática do desembarque de pássaros, dependendo da geometria e textura da superfície</a></li>
<li><a href="../pt463795/index.html">Tons de significado em inglês: como usar os verbos Aconselhar, Recomendar, Sugerir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>