<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🌾 🍓 👨‍👨‍👧‍👧 Envoi d'événements de ViewModel vers Activity / Fragment dans MVVM 🙍🏿 👨🏼‍⚕️ 🤚🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous allons parler de la façon d'échanger des événements entre les activités / fragments et ViewModel dans MVVM. Pour obtenir des données...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Envoi d'événements de ViewModel vers Activity / Fragment dans MVVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/homecredit/blog/477314/">  Aujourd'hui, nous allons parler de la façon d'échanger des événements entre les activités / fragments et ViewModel dans MVVM.  Pour obtenir des données du ViewModel, il est recommandé dans Activity / Fragment de s'abonner aux données LiveData situées dans le ViewModel.  Mais que faire pour envoyer des événements uniques (et pas seulement), comme afficher une notification ou, par exemple, ouvrir un autre fragment? <br><br><img src="https://habrastorage.org/webt/td/ey/cp/tdeycpvhsyngrmfgzco-mpmjzta.jpeg"><br><a name="habracut"></a><br>  Alors bonjour à tous! <br><br>  Je m'appelle Alexei, je suis développeur Android chez Home Credit Bank. <br><br>  Dans cet article, je vais partager notre façon d'envoyer et de recevoir des événements de ViewModels vers des vues (activités / fragments). <br><br>  <i>Dans notre application <a href="https://play.google.com/store/apps/details%3Fid%3Dru.homecredit.marketplace">«Biens à tempérament de Home Credit Bank»,</a> nous utilisons des fragments, nous en parlerons donc, mais tout est également pertinent pour l'activité.</i> <br><br><h3>  Que voulons-nous? </h3><br>  Nous avons un fragment, qui comprend plusieurs ViewModel, les données sont liées par <code>DataBinding</code> .  Tous les événements utilisateur reçoivent ViewModel.  Si l'événement est de navigation: vous devez ouvrir un autre fragment / activité, afficher <code>AlertDialog</code> , <code>Snackbar</code> , une demande système pour les autorisations, etc., alors un tel événement doit être exécuté dans le fragment. <br><cut></cut><br><h3>  Et quel est en fait le problème? </h3><br>  Les cycles de vie des vues et des modèles de vue ne sont pas liés.  Il est impossible de se lier aux écouteurs, car ViewModel ne devrait rien savoir des fragments, et ne devrait pas non plus contenir de lien vers des fragments, sinon, comme vous le savez, la mémoire commencera à « <a href="https://developer.android.com/topic/performance/memory">se réjouir</a> ». <br><br>  L'approche standard pour l'interaction entre Fragments et ViewModels consiste à s'abonner à <code>LiveData</code> , situé dans ViewModel.  <code>LiveData</code> impossible de transmettre des événements directement via <code>LiveData</code> , car cette approche ne tient pas compte du fait que l'événement est déjà terminé ou non. <br><br><h3>  Quelles solutions existent: </h3><br>  1. Utilisez <a href=""><code>SingleLiveEvent</code></a> <br>  <b>Avantages: l'</b> événement est exécuté une fois. <br>  <b>Inconvénients:</b> un événement - un événement <code>SingleLiveEvent</code> .  Avec un grand nombre d'événements, N objets d'événement apparaissent dans le ViewModel, chacun devant être abonné dans le fragment. <br><br>  2. Un bon <a href="https://android.jlelse.eu/sending-events-from-viewmodel-to-activities-fragments-the-right-way-26bb68502b24">exemple</a> . <br>  <b>Avantages:</b> un événement est également exécuté une fois, vous pouvez transférer des données de viewModel vers un fragment. <br>  <b>Inconvénients: les</b> données de l'événement sont obligatoires, mais si vous devez exécuter un événement sans données <code>(val content: T)</code> , vous devrez créer une autre classe.  Il ne résout pas le problème de l'exécution d'un type d'événement une fois (l'événement lui-même est exécuté une fois, mais ce type d'événement sera exécuté autant de fois que nous l'exécutons à partir du ViewModel).  Par exemple, les N-requêtes sont asynchrones, mais il n'y a pas de réseau.  Chaque demande renverra une erreur réseau et récupérera un fragment de N événements concernant une erreur réseau, N alertes s'ouvriront dans le fragment.  L'utilisateur n'approuvera pas une telle décision :).  Nous devons lui montrer une fois un message avec cette erreur.  En d'autres termes, ce type d'événement doit être exécuté une fois. <br><br><h3>  Solution </h3><br>  Nous prenons l'idée de <code>SingleLiveEvent</code> pour enregistrer les informations de gestion des événements comme base. <br><br><h4>  Définissez les types d'événements possibles </h4><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class"> </span></span>{ EXECUTE_WITHOUT_LIMITS, <span class="hljs-comment"><span class="hljs-comment">//    –   ,             EXECUTE_ONCE, //      WAIT_OBSERVER_IF_NEEDED,//    ,     -       WAIT_OBSERVER_IF_NEEDED_AND_EXECUTE_ONCE //    ,     -           }</span></span></code> </pre> <br><h4>  Créer une classe de base d'événements - <code>NavigationEvent</code> </h4><br>  <code>isHandled</code> indique si l'événement a été reçu (nous pensons qu'il a été exécuté si Observer a été reçu dans le fragment). <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NavigationEvent</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isHandled: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type: Events.Type)</code> </pre> <br><h4>  Créer une classe d' <code>Emitter</code> - <code>Emitter</code> </h4><br>  La classe d'émetteur d'événements hérite de <code>LiveData</code> &lt; <code>NavigationEvent</code> &gt;.  Cette classe sera utilisée dans le ViewModel pour distribuer des événements. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Emitter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MutableLiveData</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NavigationEvent</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> waitingEvents: ArrayList&lt;NavigationEvent&gt; = ArrayList() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInactive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { isActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> postingEvents = ArrayList&lt;NavigationEvent&gt;() waitingEvents .forEach { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasObservers()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = it postingEvents.add(it) } }.also { waitingEvents.removeAll(postingEvents) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">NavigationEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">, type: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Type</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { event.type = type <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (type) { Type.EXECUTE_WITHOUT_LIMITS, Type.EXECUTE_ONCE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasObservers()) event <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> Type.WAIT_OBSERVER_IF_NEEDED, Type.WAIT_OBSERVER_IF_NEEDED_AND_EXECUTE_ONCE -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasObservers() &amp;&amp; isActive) event <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { waitingEvents.add(event) <span class="hljs-literal"><span class="hljs-literal">null</span></span> } } } } <span class="hljs-comment"><span class="hljs-comment">/** Clear All Waiting Events */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearWaitingEvents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = waitingEvents.clear() }</code> </pre> <br>  <code>isActive</code> - nous devons comprendre si au moins un <code>Observer</code> est abonné à <code>Emitter</code> .  Et dans le cas où l'abonné est apparu et que les événements qui l'attendent se sont accumulés, nous envoyons ces événements.  Une clarification importante: l'envoi d'événements n'est pas nécessaire via <code>this.postValue(event)</code> , mais via le setter <code>this.value = event</code> .  Sinon, l'abonné ne recevra que le dernier événement de la liste. <br><br>  La méthode d'envoi d'un nouvel événement, <code>newEvent(event, type)</code> , accepte deux paramètres - en fait, l'événement lui-même et le type de cet événement. <br><br>  Afin de ne pas mémoriser tous les types d'événements (noms longs), nous allons créer des méthodes publiques distinctes qui n'accepteront que l'événement lui-même: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Emitter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MutableLiveData</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NavigationEvent</span></span></span><span class="hljs-class">&gt;</span></span>() { … <span class="hljs-comment"><span class="hljs-comment">/** Default: Emit Event for Execution */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emitAndExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">NavigationEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = newEvent(event, Type.EXECUTE_WITHOUT_LIMITS) <span class="hljs-comment"><span class="hljs-comment">/** Emit Event for Execution Once */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emitAndExecuteOnce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">NavigationEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = newEvent(event, Type.EXECUTE_ONCE) <span class="hljs-comment"><span class="hljs-comment">/** Wait Observer Available and Emit Event for Execution */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitAndExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">NavigationEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = newEvent(event, Type.WAIT_OBSERVER_IF_NEEDED) <span class="hljs-comment"><span class="hljs-comment">/** Wait Observer Available and Emit Event for Execution Once */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitAndExecuteOnce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">NavigationEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = newEvent(event, Type.WAIT_OBSERVER_IF_NEEDED_AND_EXECUTE_ONCE) }</code> </pre> <br>  Formellement, vous pouvez déjà vous abonner à <code>Emitter</code> dans le ViewModel et recevoir des événements sans égard à leur gestion (que l'événement ait déjà été traité ou non). <br><br><h4>  Créer une classe Observateur d'événements - <code>EventObserver</code> </h4><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventObserver</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> handlerBlock: (NavigationEvent) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) : Observer&lt;NavigationEvent&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> executedEvents: HashSet&lt;String&gt; = hashSetOf() <span class="hljs-comment"><span class="hljs-comment">/** Clear All Executed Events */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearExecutedEvents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = executedEvents.clear() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(it: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">NavigationEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it?.type) { Type.EXECUTE_WITHOUT_LIMITS, Type.WAIT_OBSERVER_IF_NEEDED -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!it.isHandled) { it.isHandled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> it.apply(handlerBlock) } } Type.EXECUTE_ONCE, Type.WAIT_OBSERVER_IF_NEEDED_AND_EXECUTE_ONCE -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.javaClass.simpleName !<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> executedEvents) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!it.isHandled) { it.isHandled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> executedEvents.add(it.javaClass.simpleName) it.apply(handlerBlock) } } } } } }</code> </pre> <br>  Cet observateur accepte une fonction d'ordre supérieur comme entrée - le traitement des événements sera écrit dans un fragment (exemple ci-dessous). <br><br>  La méthode <code>clearExecutedEvents()</code> pour nettoyer les événements exécutés (ceux qui auraient dû être exécutés une fois).  Obligatoire lors de la mise à jour de l'écran, par exemple, dans <code>swipeToRefresh()</code> . <br><br>  Eh bien, en fait, la principale méthode <code>onChange()</code> , qui se produit lorsque de nouvelles données d'émetteur sont reçues, auxquelles cet observateur souscrit. <br><br>  Dans le cas où l'événement a un type d'exécution d'un nombre illimité de fois, nous vérifions si l'événement a été exécuté et le traitons.  Nous exécutons l'événement et indiquons qu'il est reçu et traité. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!it.isHandled) { it.isHandled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> it.apply(handlerBlock) }</code> </pre> <br>  Si l'événement est du type qui doit être exécuté une fois, vérifiez si la classe de cet événement se trouve dans la table de hachage.  Sinon, exécutez l'événement et ajoutez la classe de cet événement à la table de hachage. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.javaClass.simpleName !<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> executedEvents) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!it.isHandled) { it.isHandled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> executedEvents.add(it.javaClass.simpleName) it.apply(handlerBlock) } }</code> </pre> <br><h3>  Mais comment transférer des données à l'intérieur d'événements? </h3><br>  Pour ce faire, l'interface <code>MyFragmentNavigation</code> est <code>MyFragmentNavigation</code> , qui consistera en classes héritées de <code>NavigationEvent()</code> .  Différentes classes sont créées ci-dessous avec et sans paramètres passés. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFragmentNavigation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShowCategoryList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NavigationEvent</span></span></span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenProduct</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productId: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productName: String) : NavigationEvent() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayVideo</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url: String) : NavigationEvent() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShowNetworkError</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NavigationEvent</span></span></span></span>() }</code> </pre> <br><h3>  Comment ça marche dans la pratique </h3><br>  Envoi d'événements à partir de ViewModel: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> emitter = Events.Enitter() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doOnShowCategoryListButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = emitter.emitAndExecute(MyNavigation.ShowCategoryList()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doOnPlayClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = emitter.waitAndExecuteOnce(MyNavigation.PlayVideo(url = <span class="hljs-string"><span class="hljs-string">"https://site.com/abc"</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doOnProductClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = emitter.emitAndExecute(MyNavigation.OpenProduct( productId = <span class="hljs-string"><span class="hljs-string">"123"</span></span>, productTitle = <span class="hljs-string"><span class="hljs-string">" Samsung"</span></span>) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doOnNetworkError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = emitter.emitAndExecuteOnce(MyNavigation.ShowNetworkError()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doOnSwipeRefresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ emitter.clearWaitingEvents() ..<span class="hljs-comment"><span class="hljs-comment">//loadData() } }</span></span></code> </pre> <br>  Réception d'événements dans un fragment: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigationEventsObserver = Events.EventObserver { event -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (event) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MyFragmentNavigation.ShowCategoryList -&gt; ShowCategoryList() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MyFragmentNavigation.PlayVideo -&gt; videoPlayerView.loadUrl(event.url) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MyFragmentNavigation.OpenProduct -&gt; openProduct(id = event.productId, name = event.otherInfo) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MyFragmentNavigation.ShowNetworkError -&gt; showNetworkErrorAlert() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">// Observer   ViewModels     myViewModel.emitter.observe(viewLifecycleOwner, navigationEventsObserver) myViewModelSecond.emitter.observe(viewLifecycleOwner, navigationEventsObserver) myViewModelThird.emitter.observe(viewLifecycleOwner, navigationEventsObserver) } private fun ShowCategoryList(){ ... } private fun openProduct(id: String, name: String){ ... } private fun showNetworkErrorAlert(){ ... } }</span></span></code> </pre> <br>  En substance, nous avons obtenu un analogue de Rx- <code>BehaviorSubjec</code> ta et <code>EventBus</code> -a, uniquement basé sur <code>LiveData</code> , dans lequel <code>Emitter</code> peut collecter des événements avant l'apparition d'un artiste-Observer, et dans lequel Observer peut surveiller les types d'événements et, si nécessaire, les appeler une seule fois. <br><br>  Bienvenue dans les commentaires avec des suggestions. <br><br>  <a href="https://github.com/klukwist/EventEmitter">Lien vers la source</a> . <br>  <a href="https://market.homecredit.ru/">Plan de versement de Home Credit Bank</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477314/">https://habr.com/ru/post/fr477314/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477304/index.html">CDN dynamique pour le streaming WebRTC à faible latence</a></li>
<li><a href="../fr477306/index.html">De la production au salaire à la production à la commande. La séquence des étapes et un exemple de mise en œuvre pratique</a></li>
<li><a href="../fr477308/index.html">Clone Numpy</a></li>
<li><a href="../fr477310/index.html">CDN dynamique pour le streaming WebRTC à faible latence</a></li>
<li><a href="../fr477312/index.html">Développement de jeux sur les réseaux sociaux</a></li>
<li><a href="../fr477318/index.html">PHP Digest n ° 168 (5-25 novembre 2019)</a></li>
<li><a href="../fr477320/index.html">Front environnemental: comment l'Internet des objets contribuera à protéger l'environnement</a></li>
<li><a href="../fr477324/index.html">Pourquoi choisir l'analyseur statique PVS-Studio à intégrer dans votre processus de développement</a></li>
<li><a href="../fr477326/index.html">Simplicité Hickey</a></li>
<li><a href="../fr477328/index.html">Raisons pour introduire l'analyseur de code statique PVS-Studio dans le processus de développement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>