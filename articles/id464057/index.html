<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¶ ğŸš® ğŸ‘¨ğŸ»â€ğŸ”¬ Hilbert, Lebesgue ... and the Void ğŸ˜‰ ğŸ˜¸ ğŸ‘†ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di bawah potongan, pertanyaan tentang bagaimana algoritma pengindeksan multidimensi yang baik harus diselidiki diselidiki. Anehnya, tidak ada begitu b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hilbert, Lebesgue ... and the Void</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464057/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/fh/qp/fzfhqp64ark_qr2begezr_lvmha.jpeg" width="80%"></div><br>  Di bawah potongan, pertanyaan tentang bagaimana algoritma pengindeksan multidimensi yang baik harus diselidiki diselidiki.  Anehnya, tidak ada begitu banyak pilihan. <br><a name="habracut"></a><br><h4>  Indeks Satu Dimensi, Pohon-B </h4><br>  Ukuran keberhasilan algoritma pencarian akan dianggap 2 fakta - <br><br><ol><li>  penetapan fakta ada atau tidak adanya hasil terjadi untuk jumlah logaritmik (sehubungan dengan ukuran indeks) pembacaan halaman disk </li><li>  biaya mengeluarkan hasil sebanding dengan volumenya </li></ol><br>  Dalam hal ini, pohon-B cukup berhasil dan alasannya dapat dianggap sebagai penggunaan pohon seimbang.  Kesederhanaan algoritme ini disebabkan oleh satu dimensi ruang utama - jika perlu, bagi halaman, cukup untuk membagi dua elemen elemen halaman ini.  Secara umum dibagi dengan jumlah elemen, meskipun ini tidak perlu. <br><br>  Karena  halaman-halaman pohon disimpan pada disk, dapat dikatakan bahwa B-tree memiliki kemampuan untuk secara efisien mengkonversi ruang kunci satu dimensi ke ruang disk satu dimensi. <br><br>  Saat mengisi pohon dengan â€œpenyisipan kananâ€ yang kurang lebih, dan ini merupakan kasus yang cukup umum, halaman dihasilkan dalam urutan pertumbuhan kunci, dari waktu ke waktu bergantian dengan halaman yang lebih tinggi.  Ada kemungkinan besar bahwa mereka akan berada di disk juga.  Dengan demikian, tanpa upaya apa pun, lokalitas data tinggi tercapai - data yang dekat nilainya akan berada di suatu tempat di dekatnya dan di disk. <br><br>  Tentu saja, ketika memasukkan nilai-nilai dalam urutan acak, kunci dan halaman dihasilkan secara acak, sebagai akibat dari apa yang disebut  indeks fragmentasi.  Ada juga alat anti-fragmentasi yang mengembalikan lokalitas data. <br><br>  Tampaknya di zaman kita disk RAID dan SSD urutan membaca dari disk tidak masalah.  Tetapi, lebih tepatnya, itu tidak memiliki arti yang sama seperti sebelumnya.  Tidak ada penerusan fisik kepala di SSD, sehingga kecepatan baca acaknya tidak turun ratusan kali dibandingkan dengan pembacaan solid, seperti HDD.  Dan hanya sekali setiap 10 atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih</a> . <br><br>  Ingatlah bahwa B-tree muncul pada tahun 1970 di era pita magnetik dan drum.  Ketika perbedaan dalam kecepatan akses acak untuk tape dan drum yang disebutkan itu jauh lebih dramatis daripada dibandingkan dengan HDD dan SSD. <br><br>  Selain itu, 10 kali juga masalah.  Dan 10 kali ini tidak hanya mencakup fitur fisik SSD, tetapi juga titik mendasar - prediktabilitas perilaku pembaca.  Jika pembaca sangat mungkin meminta blok berikutnya untuk blok ini, masuk akal untuk mengunduhnya secara proaktif, dengan asumsi.  Dan jika perilakunya kacau, semua upaya prediksi tidak ada artinya dan bahkan berbahaya. <br><br><h4>  Pengindeksan multidimensi </h4><br>  Selanjutnya kita akan berurusan dengan indeks titik dua dimensi (X, Y), hanya karena nyaman dan intuitif untuk bekerja dengan mereka.  Tetapi masalahnya pada dasarnya sama. <br><br>  Opsi sederhana, "tidak canggih" dengan indeks terpisah untuk X dan Y tidak lulus sesuai dengan kriteria kesuksesan kami.  Itu tidak memberikan biaya logaritmik untuk mendapatkan poin pertama.  Bahkan, untuk menjawab pertanyaan, adakah yang ada dalam batas yang diinginkan, kita harus <br><br><ul><li>  lakukan pencarian di indeks X dan dapatkan semua pengidentifikasi dari X-interval </li><li>  mirip untuk Y </li><li>  memotong dua set pengidentifikasi ini </li></ul><br>  Sudah item pertama tergantung pada ukuran sejauh dan tidak menjamin logaritma. <br><br>  Untuk menjadi "sukses," indeks multidimensi harus disusun sebagai pohon yang kurang lebih seimbang.  Pernyataan ini mungkin tampak kontroversial.  Tetapi persyaratan pencarian logaritma menentukan bagi kita hanya perangkat semacam itu.  Mengapa tidak dua pohon atau lebih?  Sudah dianggap sebagai opsi "tidak canggih" dan tidak cocok dengan dua pohon.  Mungkin ada yang cocok.  Tapi dua pohon - ini dua kali lebih banyak (termasuk simultan) kunci, dua kali lebih banyak biaya, peluang yang jauh lebih besar untuk menangkap jalan buntu.  Jika Anda dapat bertahan dengan satu pohon, Anda harus menggunakannya. <br><br>  Mengingat semua ini, keinginan untuk mengambil sebagai dasar pengalaman B-tree yang sangat sukses dan "menggeneralisasi" untuk bekerja dengan data dua dimensi cukup wajar. <br><br>  Jadi pohon-R muncul. <br><br><h4>  R-tree </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">R-tree</a> diatur sebagai berikut: <br>  Awalnya, kami memiliki halaman kosong, cukup tambahkan data (poin) ke dalamnya. <br>  Tapi di sini halamannya penuh dan harus dibagi. <br>  Di B-tree, elemen halaman diurutkan secara alami, jadi pertanyaannya adalah berapa banyak yang harus dipotong.  Tidak ada tatanan alami di R-tree.  Ada dua opsi: <br><br><ul><li>  Bawa pesanan, mis.  memperkenalkan fungsi yang, berdasarkan X&amp;Y, akan memberikan nilai sesuai dengan elemen halaman mana yang akan dipesan dan dibagi sesuai dengan itu.  Dalam hal ini, seluruh indeks berdegenerasi menjadi B-tree reguler yang dibangun dari nilai-nilai fungsi yang ditentukan.  Selain plus yang jelas, ada pertanyaan besar - baik, baik, kami diindeks, tapi bagaimana cara melihatnya?  Lebih lanjut tentang itu nanti, pertimbangkan opsi kedua. </li><li>  Bagilah halaman dengan kriteria spasial.  Untuk melakukan ini, setiap halaman harus ditetapkan sejauh elemen yang terletak di / di bawahnya.  Yaitu  halaman root memiliki luas seluruh lapisan.  Saat memisahkan, dua (atau lebih) halaman dihasilkan yang luasannya termasuk dalam luas halaman induk (untuk pencarian). </li></ul><br>  Ada banyak ketidakpastian.  Bagaimana tepatnya membagi halaman?  Horisontal atau vertikal?  Lanjutkan dari setengah area atau setengah dari elemen?  Tetapi bagaimana jika titik membentuk dua kelompok, tetapi Anda hanya dapat memisahkannya dengan garis diagonal?  Dan jika ada tiga kelompok? <br><br><hr><br>  Kehadiran pertanyaan semacam itu menunjukkan bahwa R-tree bukan sebuah algoritma.  Ini adalah seperangkat heuristik, setidaknya untuk memisahkan halaman selama penyisipan, untuk menggabungkan halaman selama penghapusan / modifikasi, untuk preprocessing untuk penyisipan massal. <br><br>  Heuristik melibatkan spesialisasi pohon tertentu pada tipe data tertentu.  Yaitu  pada dataset dari jenis tertentu, dia kurang melakukan kesalahan.  â€œHeuristik tidak bisa sepenuhnya keliru, karena  dalam hal ini, itu akan menjadi sebuah algoritma â€Â©. <br><br>  Apa artinya kesalahan heuristik dalam konteks ini?  Sebagai contoh, bahwa halaman akan terpecah / digabung tidak berhasil dan halaman akan mulai tumpang tindih sebagian.  Jika tiba-tiba tingkat pencarian jatuh pada area tumpang tindih halaman, biaya pencarian sudah tidak cukup logaritmik.  Seiring waktu, saat Anda memasukkan / menghapus, jumlah kesalahan menumpuk dan kinerja pohon mulai menurun. <br><br><img src="https://habrastorage.org/webt/uf/ls/nc/uflsncc4sbgqqokdgf9ofvlyole.png"><br>  <i>Gambar 1 Berikut adalah contoh pohon R *, yang dibangun secara alami.</i> <br><br><img src="https://habrastorage.org/webt/vw/f0/ic/vwf0icm5lrfl7yapbxzwm0rkipg.png"><br>  <i>Gambar 2 Dan di sini dataset yang sama adalah pra-diproses dan pohon dibangun dengan penyisipan massal</i> <br><br>  Kita dapat mengatakan bahwa B-tree juga mengalami degradasi seiring waktu, tetapi ini adalah degradasi yang sedikit berbeda.  Kinerja B-tree turun karena fakta bahwa halamannya tidak berturut-turut.  Ini mudah diobati dengan "meluruskan" pohon - defragmentasi.  Dalam kasus R-tree, tidak mudah untuk menghilangkannya, struktur pohon itu sendiri adalah "kurva" untuk memperbaiki situasi; <br><br>  Generalisasi dari R-tree ke ruang multidimensi tidak jelas.  Misalnya, saat memisahkan halaman, kami meminimalkan batas halaman anak.  Apa yang harus dikurangi dalam kasus tiga dimensi?  Volume atau luas permukaan?  Dan dalam kasus delapan dimensi?  Akal sehat tidak lagi menjadi penasihat. <br><br>  Ruang yang diindeks mungkin non-isotropik.  Mengapa tidak mengindeks bukan hanya poin, tetapi posisi mereka tepat waktu, mis.  (X, Y, t).  Dalam hal ini, misalnya, heuristik berdasarkan perimeter tidak ada artinya sejak itu  menumpuk panjang pada interval waktu. <br><br>  Kesan umum dari R-tree adalah sesuatu seperti krustasea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">insang</a> .  Mereka memiliki ceruk ekologis sendiri di mana sulit untuk bersaing dengan mereka.  Tetapi dalam kasus umum, mereka tidak memiliki peluang untuk bersaing dengan hewan yang lebih maju. <br><br><h4>  Pohon quad </h4><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">quadtree,</a> setiap halaman non-daun memiliki empat keturunan, yang membagi ruang menjadi kuadran. <br><br><img src="https://habrastorage.org/webt/wi/bp/ka/wibpkauhekq5ar01kbafsupfu9c.png" width="500"><br>  <i>Gambar 3 Contoh pohon quad dibangun</i> <br><br>  Ini bukan desain basis data yang baik. <br><br><ul><li>  Setiap halaman mempersempit ruang pencarian untuk setiap koordinat hanya dua kali.  Ya, ini memberikan kompleksitas logaritma pencarian, tetapi ini adalah logaritma basis 2, bukan jumlah elemen pada halaman, (bahkan 100) seperti dalam B-tree. </li><li>  Setiap halaman kecil, tetapi di belakangnya Anda masih harus pergi ke disk. </li><li>  Kedalaman pohon quad harus dibatasi, jika tidak, ketidakseimbangannya mempengaruhi kinerja.  Akibatnya, pada data yang sangat berkerumun (misalnya, rumah di peta - ada banyak kota di kota, sedikit di bidang) sejumlah besar data dapat terakumulasi di halaman daun.  Indeks dari indeks yang tepat menjadi kuning dan membutuhkan pasca pemrosesan. <br><br>  Ukuran kisi yang dipilih dengan buruk (kedalaman pohon) dapat membunuh kinerja.  Namun demikian, saya ingin agar kinerja algoritma tidak bergantung secara kritis pada faktor manusia. <br></li><li>  Biaya ruang untuk menyimpan satu titik cukup besar. </li></ul><br><h4>  Penomoran ruang </h4><br>  Masih mempertimbangkan versi yang sebelumnya ditangguhkan dengan fungsi yang, berdasarkan kunci multidimensi, menghitung nilai untuk menulis dalam B-tree reguler. <br><br>  Konstruksi indeks semacam itu jelas, dan indeks itu sendiri memiliki semua keunggulan B-tree.  Satu-satunya pertanyaan adalah apakah indeks ini dapat digunakan untuk pencarian yang efektif. <br><br>  Ada sejumlah besar fungsi seperti itu, dapat diasumsikan bahwa di antara mereka ada sejumlah kecil "baik", sejumlah besar "buruk" dan sejumlah besar "hanya mengerikan". <br><br>  Menemukan fungsi yang mengerikan tidak sulit - kami membuat serial kunci menjadi string, pertimbangkan MD5 darinya dan dapatkan nilai yang sama sekali tidak berguna untuk keperluan kami. <br><br>  Dan bagaimana cara mendekati yang baik?  Sudah dikatakan bahwa indeks yang berguna menyediakan "lokalitas" data - titik yang dekat dalam ruang dan sering dekat satu sama lain ketika disimpan ke disk.  Seperti yang diterapkan pada fungsi yang diinginkan, ini berarti bahwa untuk titik dekat spasi ia memberikan nilai dekat. <br><br>  Setelah di indeks, nilai yang dihitung akan muncul pada halaman "fisik" dalam urutan nilainya.  Dari sudut pandang "pengertian fisik", tingkat pencarian harus memengaruhi halaman indeks fisik sesedikit mungkin.  Apa yang umumnya jelas.  Dari sudut pandang ini, kurva penomoran yang "menarik" data adalah "buruk".  Dan orang-orang yang "bingung dalam bola" - lebih dekat dengan "baik". <br><br><h4>  Penomoran naif </h4><br>  Upaya untuk memeras segmen ke dalam kotak (hypercube) sambil tetap dalam logika ruang satu dimensi yaitu  potong-potong dan isi kotak dengan potongan-potongan ini.  Itu bisa saja <br><br><img src="https://habrastorage.org/webt/m6/1z/fp/m61zfp6xf6wfzjkl2617fu1m6-m.png"><br>  <i>Pemindaian 4 baris</i> <br><br><img src="https://habrastorage.org/webt/b9/9p/hc/b99phcgowrxhdvtinm--p4anow0.png"><br>  <i>5 interlaced</i> <br><br><img src="https://habrastorage.org/webt/ym/vh/e-/ymvhe-a64v_evksgfmdyxheuvuw.png"><br>  <i>Gbr.6 spiral</i> <br><br>  atau ... Anda dapat memunculkan banyak opsi, semuanya memiliki dua kelemahan <br><br><ol><li>  ambiguitas, misalnya: mengapa spiral melengkung searah jarum jam dan tidak menentangnya, atau mengapa pemindaian horizontal pertama sepanjang X dan kemudian sepanjang Y <br></li><li>  keberadaan potongan lurus panjang yang membuat penggunaan metode seperti itu tidak efektif untuk pengindeksan multidimensi (perimeter halaman besar) </li></ol><br><h4>  Fitur akses langsung </h4><br>  Jika klaim utama untuk metode "naif" adalah bahwa mereka menghasilkan halaman yang sangat panjang, mari kita buat halaman "benar" sendiri. <br><br>  Idenya sederhana - biarkan ada pembagian ruang eksternal ke dalam blok, tetapkan pengidentifikasi untuk setiap blok dan ini akan menjadi kunci indeks spasial. <br><br><ul><li>  biarkan koordinat X&amp;Y menjadi 16-bit (untuk kejelasan) </li><li>  kita akan menutup ruang dengan blok persegi ukuran 1024X1024 </li><li>  kasar koordinat, bergeser 10 bit ke kanan </li><li>  dan dapatkan ID halaman, rekatkan bit dari X&amp;Y.  Sekarang di pengidentifikasi 6 digit bawah adalah yang tertua dari X, 6 digit berikutnya adalah yang tertua dari Y <br></li></ul><br>  Sangat mudah untuk melihat bahwa blok-blok membentuk pemindaian garis, oleh karena itu, untuk menemukan data untuk tingkat pencarian, Anda harus melakukan pencarian / baca dalam indeks untuk setiap baris blok yang menjadi batas ini.  Secara umum, metode ini bekerja dengan baik, meskipun memiliki beberapa kelemahan. <br><br><ul><li>  saat membuat indeks, Anda harus memilih ukuran blok optimal, yang sama sekali tidak terlihat </li><li>  jika blok secara signifikan lebih besar dari kueri tipikal, pencarian akan menjadi tidak efisien sejak itu  harus membaca dan memfilter (postprocessing) terlalu banyak <br></li><li>  jika blok secara signifikan lebih kecil dari kueri tipikal, pencarian akan menjadi tidak efisien sejak itu  harus melakukan banyak pertanyaan baris demi baris <br></li><li>  jika blok memiliki terlalu banyak atau terlalu sedikit data rata-rata, pencarian akan menjadi tidak efektif <br></li><li>  jika data dikelompokkan (mis: di rumah di peta), pencarian tidak akan efektif di mana-mana </li><li>  jika dataset telah tumbuh, mungkin ternyata ukuran blok tidak lagi optimal. <br></li></ul><br>  Sebagian, masalah ini diselesaikan dengan membangun blok multi-level.  Untuk contoh yang sama: <br><br><ul><li>  masih ingin blok 1024X1024 </li><li>  tapi sekarang kita masih akan memiliki blok tingkat atas ukuran 8X8 blok yang lebih rendah </li><li>  kuncinya diatur sebagai berikut (dari rendah ke tinggi): <br>  3 digit - digit 10 ... 12 koordinat X <br>  3 digit - digit 10 ... koordinat 12 Y <br>  3 digit - digit 13 ... 15 X koordinat <br>  3 digit - digit 13 ... 15 Y koordinat </li></ul><br><img src="https://habrastorage.org/webt/az/y5/h6/azy5h6jt0wtephbmp96lcsbs_rm.png"><br>  <i>7 Blok tingkat rendah membentuk blok tingkat tinggi</i> <br><br>  Sekarang untuk luasan besar Anda tidak perlu membaca sejumlah besar blok kecil, ini dilakukan dengan mengorbankan blok tingkat tinggi. <br><br>  Menariknya, adalah mungkin untuk tidak memperkeras koordinat, tetapi dengan cara yang sama untuk menekan mereka ke dalam kunci.  Dalam hal ini, post-filtering akan lebih murah karena  akan terjadi saat membaca indeks. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Indeks GRID</a> spasial diatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam MS SQL</a> dengan cara yang sama, hingga 4 level blok diizinkan di dalamnya. <br><br><img src="https://habrastorage.org/webt/dn/kx/r_/dnkxr_kdijxhpjpggh3sgvoh2lm.png"><br>  <i>Gbr.8 Indeks GRID</i> <br><br>  Cara lain yang menarik dari pengindeksan langsung adalah dengan menggunakan pohon quad untuk partisi ruang eksternal. <br><br>  Pohon quad berguna karena dapat beradaptasi dengan kepadatan objek sejak itu  ketika node meluap, ia terbelah.  Akibatnya, di mana kepadatan objek tinggi, blok akan menjadi kecil dan sebaliknya.  Ini mengurangi jumlah panggilan indeks kosong. <br><br>  Benar, pohon quad adalah konstruksi yang tidak nyaman untuk membangun kembali dengan cepat, menguntungkan untuk melakukan ini dari waktu ke waktu. <br><br>  Dari hal yang menyenangkan, ketika membangun kembali pohon quad, tidak perlu membangun kembali indeks jika blok diidentifikasi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode Morton</a> dan objek dikodekan menggunakannya.  Begini caranya: jika koordinat titik dikodekan dengan kode Morton, pengenal halaman adalah awalan dalam kode itu.  Saat mencari data halaman, semua kunci yang berada dalam kisaran dari [awalan] 00 ... 00B hingga [awalan] 11 ... 11B dipilih, jika halaman dipecah, itu berarti hanya awalan dari keturunannya yang telah diperpanjang. <br><br><h4>  Fitur mirip diri </h4><br>  Hal pertama yang terlintas dalam pikiran ketika menyebutkan fungsi yang mirip dengan diri sendiri adalah "kurva sapuan".  "Kurva yang terlihat adalah pemetaan berkelanjutan, domain yang merupakan segmen unit [0, 1], dan domain adalah ruang Euclidean (lebih ketat, topologis)."  Contohnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kurva Peano.</a> <br><br><img src="https://habrastorage.org/webt/if/1t/yo/if1tyoie_5uobqmnznsudpfnoau.png"><br>  <i>Gambar. 9 iterasi pertama dari kurva Peano</i> <br><br>  Di sudut kiri bawah adalah awal dari area definisi (dan nilai nol fungsi), di sudut kanan atas ujung (dan 1), setiap kali kita memindahkan 1 langkah, tambahkan 1 / (N * N) ke nilai (asalkan N - derajat 3, tentu saja).  Hasilnya, di sudut kanan atas nilainya mencapai 1. Jika kita menambahkan satu di setiap langkah, fungsi seperti itu hanya memberi nomor kisi kuadrat secara berurutan, yang merupakan apa yang kita inginkan. <br><br>  Semua kurva sweeping hampir sama.  Dalam hal ini, simpleks adalah bujur sangkar 3x3. Pada setiap iterasi, setiap titik simpleks berubah menjadi simpleks yang sama, untuk memastikan kontinuitas, Anda harus menggunakan pemetaan (membalik). <br><br>  <b>Kesamaan diri</b> adalah kualitas yang sangat penting bagi kami.  Ini memberi harapan untuk nilai logaritma pencarian.  Misalnya, untuk simpleks 3x3, semua angka yang dihasilkan dalam masing-masing dari 9 kotak dasar dengan iterasi detail berikutnya akan berada dalam kisaran yang sama.  Hanya karena jumlahnya adalah jalur yang dilalui sejak awal.  Yaitu  jika Anda membagi luasnya menjadi 9 bagian, konten masing-masing dapat diperoleh dengan satu indeks lintasan.  Dan seterusnya secara rekursif, masing-masing dari 9 sub-kotak dari masing-masing kotak dapat diperoleh dengan satu permintaan pada indeks (meskipun dalam kisaran yang lebih kecil).  Jadi jangkauan pencarian dapat dipecah menjadi sejumlah kecil kuadrat persegi, dibaca secara keseluruhan atau dengan pemfilteran (sekitar batas).  Gambar 9 menunjukkan tingkat pencarian dalam warna hijau, dipecah oleh garis merah menjadi subquery. <br><br>  Namun, kemiripan diri tidak secara otomatis membuat kurva penomoran cocok untuk keperluan pengindeksan. <br><br><ul><li>  kurva harus mengisi kisi kuadrat.  Kami mengindeks nilai dalam node kisi kuadrat dan setiap kali kami tidak ingin mencari node yang sesuai pada kisi, misalnya, segitiga.  Setidaknya untuk menghindari masalah pembulatan.  Di sini, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti (Gambar 10)</a> <br><br><img src="https://habrastorage.org/webt/86/7s/w1/867sw16ik5sqwl5syykidgylzuw.png"><br>  <i>Gambar 10 danau ternary Kokha</i> <br><br>  kurva tidak cocok untuk kita.  Meskipun, itu sempurna "menjembatani" permukaan. <br></li><li>  kurva harus mengisi ruang tanpa celah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dimensi fraktal</a> D = 2).  Ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dia</a> (Gbr. 11): <br><img src="https://habrastorage.org/webt/kt/pi/ag/ktpiaglmp2_ylugv2cosyoyefsy.gif"><br>  <i>11 kurva fraktal anonim</i> <br><br>  juga tidak cocok. <br></li><li>    (,     )    .   ,          ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> <br><br><img src="https://habrastorage.org/webt/83/p3/ck/83p3ckw6mejy8prdspy7wklo87m.png"><br> <i>.12  </i> <br><br> ,     ( ), â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> â€ <br><br><img src="https://habrastorage.org/webt/ja/64/2v/ja642v4mwxfgneoknpnejnwwymc.png"><br> <i>. 13  ,       85Â°</i> </li><li>       ,     (   ).         . :       ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ) <br><br><img src="https://habrastorage.org/webt/my/na/py/mynapy6g0pimgnlttggkw6tkjym.png"><br> <i>. 14 â€œA Plane Filling Curve for the Year 2017â€</i> <br><br>         ,    (  )       . <br>      , ,   ,        . </li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isotropi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah karakteristik penting lainnya. Dapat dipahami bahwa fungsi penomoran harus mudah digeneralisasikan ke dimensi yang lebih tinggi. Dan ada baiknya jika untuk kubus N-dimensi semua proyeksi N-nya pada dimensi (N-1) adalah sama. Ini mengikuti dari fakta bahwa kami menggunakan ruang isotropik dan akan aneh jika sumbu yang berbeda digunakan dalam fungsi yang berbeda. </font></font><br><br><img src="https://habrastorage.org/webt/zp/e8/th/zpe8thfxsdipyiwe5iwwpwo2jfk.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. 15 Simpleks tiga dimensi dari kurva Peano 3x3x3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isotropi bukan persyaratan yang ketat, tetapi merupakan indikator penting dari kualitas kurva penomoran. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengenai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kontinuitas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di atas, kami melihat contoh fungsi penomoran berkelanjutan yang tidak sesuai untuk tujuan kami. </font><font style="vertical-align: inherit;">Di sisi lain, fungsi pemindaian garis yang cukup terputus dengan blok sangat bagus untuk ini (dengan beberapa batasan). </font><font style="vertical-align: inherit;">Tidak hanya itu, jika kami membuat indeks blok berdasarkan pemindaian interlaced berkelanjutan, ini tidak akan mengubah apa pun dalam hal kinerja. </font><font style="vertical-align: inherit;">Karena jika blok dibaca secara keseluruhan, tidak ada perbedaan dalam urutan apa objek akan diterima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk kurva mirip diri ini juga benar.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mari kita sebut ukuran halaman, luasnya semua objek pada halaman disk </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ukuran karakteristik akan menjadi area halaman rata-rata </font></font></li><li>    (   )          ,         .      ,    .   â€”         .      . </li><li>    â€”   ,        ..            . <br></li><li>        ,       .   ,      ,          .  ,     ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> â€”  ()     3...10%      () Z-. <br><br>   â€”   ,         . </li></ul><br><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari apa yang telah dikatakan, dapat disimpulkan bahwa untuk keperluan pengindeksan multidimensi, hanya simpleks kuadrat (hiperkubik) yang diterapkan secara berulang sebanyak yang diperlukan (untuk detail kisi yang cukup). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, ada cara serupa lainnya untuk menjembatani kisi persegi, namun, tidak ada cara yang murah secara komputasi untuk melakukan transformasi semacam itu, termasuk sebaliknya. Mungkin trik numerik seperti itu ada, tetapi mereka tidak diketahui oleh penulis. Selain itu, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simpleks kuadrat memungkinkan untuk secara efektif membagi tingkat pencarian menjadi subquery dengan memotong sepanjang salah satu koordinat</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan batas yang terputus antara simpleks, ini tidak mungkin</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa simpleks persegi dan bukan persegi panjang? Untuk alasan isotropi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap memilih ukuran dan penomoran yang sesuai di dalam simpleks (bypass). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memilih </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukuran simpleks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Anda perlu mencari tahu apa pengaruhnya. Jumlah subqueries yang dihasilkan yang harus dibuat selama pencarian. Misalnya, simpleks 3X3 dari kurva Peano dipotong menjadi 3 subquery dengan interval angka kontinu, pertama dalam X, dan kemudian masing-masing dari mereka menjadi 3 bagian dalam Y. Akibatnya, kita kembali ke tahap rekursi berikutnya. Jika kita memiliki simpleks 5X5 (interlaced) yang serupa, itu harus dipotong menjadi 5 bagian. Atau menjadi bagian yang tidak sama (mis: 2 + 3), yang aneh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini mengingatkan salah satu pohon pencarian dalam beberapa cara - Anda tentu saja dapat menggunakan pohon 5-desimal dan 7-desimal, tetapi dalam praktiknya hanya pohon biner yang digunakan. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pohon Tritunggal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki ceruk sempit sendiri untuk pencarian dengan awalan. Dan ini bukan apa yang secara intuitif dipahami sebagai pohon ternary. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dijelaskan oleh efisiensi. Dalam simpul ternary, untuk memilih keturunan, seseorang harus membuat 2 perbandingan. Di pohon biner, ini sesuai dengan pilihan di antara 4 opsi. Bahkan kedalaman pohon yang lebih pendek tidak menghalangi hilangnya produktivitas dari peningkatan jumlah perbandingan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, jika 3X3 lebih efektif daripada 2X2 hanya karena 3&gt; 2, 4X4 akan lebih efektif daripada 3X3, dan 8X8 lebih efektif daripada 5X5. Anda selalu dapat menemukan kekuatan yang tepat dari dua, yang dibentuk oleh beberapa iterasi 2X2 ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan apa yang dipengaruhi oleh </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplex bypass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? Pertama-tama, jumlah subquery yang dihasilkan oleh pencarian.</font></font> Karena<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu baik jika simpleks memungkinkan Anda untuk memotong-motong diri Anda dengan interval angka terus menerus. Di sini Peano 3X3 memungkinkan, jadi satu iterasi memotongnya menjadi 3 bagian. Dan jika Anda mengambil simpleks 8x8 dengan ksatria catur (Gbr. 16), satu-satunya pilihan adalah segera memiliki 64 elemen. </font></font><br><br><img src="https://habrastorage.org/webt/l7/cf/dc/l7cfdcocdq3oe-xal_wbvc34t74.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. 16 Salah satu opsi untuk menghindari simpleks 8x8</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jadi, karena kami menemukan bahwa simpleks optimal adalah 2x2, kita harus mempertimbangkan opsi apa yang ada untuknya. </font></font><br><br><img src="https://habrastorage.org/webt/ev/q3/b2/evq3b277yrimcisco3m9iqcksgk.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. 17 Pilihan untuk menghindari simpleks 2x2</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada tiga, hingga simetri, yang disebut â€œZâ€, â€œomegaâ€ dan â€œalphaâ€. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera menangkap mata bahwa "alpha" melintasi dirinya sendiri, dan karena itu tidak cocok untuk pemisahan biner. Itu harus segera dipotong menjadi 4 bagian. Atau 256 dalam kasus 8 dimensi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemampuan untuk menggunakan algoritme tunggal untuk ruang dimensi yang berbeda (yang kita kehilangan dalam kasus kurva seperti "alpha") terlihat sangat menarik. </font><font style="vertical-align: inherit;">Karenanya, di masa depan kami hanya akan mempertimbangkan dua opsi pertama. </font></font><br><br><img src="https://habrastorage.org/webt/ij/pk/p2/ijpkp2sneivmayqaie38y91mylc.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. </font><font style="vertical-align: inherit;">18 Z-kurva dari </font></font></i> <br><br><img src="https://habrastorage.org/webt/bo/ar/oq/boaroq7scpwqyvargccwvv6i7li.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. </font><font style="vertical-align: inherit;">19 "omega" - kurva Hilbert.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah kurva ini memiliki hubungan dekat, mereka </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diproses dengan satu algoritma. </font><font style="vertical-align: inherit;">Spesifisitas utama kurva terlokalisasi dalam pemisahan subquery.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pertama kita menemukan tingkat awal, ini adalah persegi panjang minimum yang mencakup tingkat pencarian dan berisi satu interval berkesinambungan dari nilai-nilai kunci. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ditemukan sebagai berikut -</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menghitung nilai kunci untuk titik kiri bawah dan kanan atas dari tingkat pencarian (KMin, KMax) </font></font><br></li><li>     (    )  KMin, KMax <br></li><li>     ,  SMin,   ,  SMax <br></li><li>           .    , ,           SMin,    .      . </li><li>       ,   ,      ( ). <br></li><li>  Z-         .     z- â€”           ,    â€”  ( ). ,         ,      . </li></ul></li><li>       </li><li>      <ul><li>    </li><li>       ,  ,  .   ,           </li><li>        ,        .      â€” â€œ â€ &gt;=   â€œ â€   () ,   â€œ â€ <br><br><ul><li>  â€œ â€ &gt;    ,   ,   <br></li><li>       ,         ,   <br></li><li>  â€œ â€ &gt;    ,         ,        ,   </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pisahkan huruf "kunci terakhir" == nilai maksimum dari subquery saat ini, diproses secara terpisah dengan melintasi maju </font></font><br></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pisahkan subquery saat ini </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tambahkan 0 dan 1 ke awalannya - kami mendapatkan dua awalan baru </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> isi sisa kunci 0 atau 1 - kami mendapatkan nilai minimum dan maksimum dari subqueries baru </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mendorong mereka ke tumpukan, pertama yang ditambah 1, lalu 0. Ini untuk pembacaan indeks searah. </font></font></li></ul></li></ul><br></li></ul> Pada kurva Z, kerjanya seperti ini: <br><br><img src="https://habrastorage.org/files/8a1/104/6c5/8a11046c5b1749cc8a5dbd0ef1634eba.png"><br>  <i>Gbr.</i>  <i>20 - pemisahan sub-permintaan jika Z-curve</i> <br><br><img src="https://habrastorage.org/webt/zh/kv/n5/zhkvn5nfyem8jdgvdhbromo9oyq.png"><br>  <i>Gbr.</i>  <i>21 Hilbert curve, kasus ketika tingkat awal adalah maksimum</i> <br><br>  Tahap pertama ditunjukkan di sini - memotong lapisan berlebih dari batas maksimum. <br><br><img src="https://habrastorage.org/webt/mq/2z/xe/mq2zxetkzhkkpxenqzoxxifkmp8.png"><br>  <i>Gbr.</i>  <i>22 Hilbert Curve, area permintaan pencarian</i> <br><br>  Dan di sini adalah perincian ke dalam sub-kueri, poin yang ditemukan, dan mengindeks panggilan di area permintaan pencarian.  Ini masih permintaan yang sangat gagal dari sudut pandang kurva Hilbert.  Biasanya semuanya kurang berdarah. <br><br>  Namun, statistik kueri mengatakan bahwa (secara kasar) pada data yang sama, indeks dua dimensi berdasarkan kurva Hilbert membaca rata-rata halaman disk 5% lebih sedikit, tetapi berfungsi setengah lebih lambat.  Perlambatan juga disebabkan oleh kenyataan bahwa perhitungan itu sendiri (langsung dan mundur) dari kurva ini jauh lebih sulit - 2000 jam prosesor untuk Hilbert dibandingkan dengan 50 untuk kurva-Z. <br><br>  Dengan berhenti mendukung kurva Hilbert, algoritme dapat disederhanakan, sekilas, perlambatan seperti itu tidak dapat dibenarkan.  Di sisi lain, ini hanya kasus dua dimensi, misalnya, dalam ruang 8 dimensi atau lebih, statistik dapat bersinar dengan warna yang sama sekali baru.  Masalah ini masih menunggu klarifikasi. <br><br>  <b>PS</b> : Kurva Z kadang-kadang disebut kurva bit-interleaving karena algoritma untuk menghitung nilai - digit dari masing-masing koordinat jatuh ke dalam nilai kunci melalui satu, yang sangat teknologi.  Tapi Anda bisa, setelah semua, interleave buangan tidak secara individual, tetapi dalam paket 2,3 ... 8 ... potongan.  Sekarang, jika kita mengambil 8 bit, maka pada kunci 32-bit kita mendapatkan analog dari indeks GRID 4-tingkat dari MS SQL.  Dan dalam kasus yang ekstrim - masing-masing satu pak 32 bit - suatu algoritma pemindaian horizontal. <br><br>  Indeks seperti itu (bukan huruf kecil, tentu saja) bisa sangat efektif, bahkan lebih efisien daripada kurva-Z pada beberapa set data.  Sayangnya, karena kehilangan keumuman. <br><br>  <b>PPS</b> : Indeks yang dijelaskan sangat mirip dengan bekerja dengan pohon quad.  Batas maksimum adalah halaman root dari pohon quad, ia memiliki 4 keturunan ... Dan karena itu, algoritme dapat dikaitkan dengan "metode akses langsung". <br><br>  Perbedaan masih mendasar. <br><br>  Pohon quad tidak disimpan di mana pun, itu virtual, tertanam dalam sifat nomor.  Tidak ada batasan pada kedalaman pohon, kami memperoleh informasi tentang populasi keturunan dari populasi pohon utama.  Selain itu, pohon utama dibaca sekali, kita beralih dari nilai terkecil ke nilai tertua.  Ini lucu, tetapi struktur fisik B-tree memungkinkan untuk menghindari pertanyaan kosong dan membatasi kedalaman rekursi. <br><br>  Satu hal lagi - pada setiap iterasi hanya dua keturunan yang muncul - dari mereka 4 subquery dapat dihasilkan, dan tidak dapat dihasilkan jika tidak ada data di bawahnya.  Dalam kasus 3 dimensi, kita akan berbicara tentang 8 keturunan, dalam kasus 8 dimensi - sekitar 256. <br><br>  <b>PPPS</b> : di awal artikel ini, kita berbicara tentang dikotomi ketika mencari dalam indeks multidimensi - untuk mendapatkan nilai logaritmik, perlu untuk membagi beberapa sumber daya yang terbatas pada setiap iterasi - baik ruang nilai kunci atau ruang pencarian.  Dalam algoritma yang disajikan, dikotomi ini runtuh - kami secara bersamaan berbagi kunci dan ruang. <br><br>  "Saya tinggal di kedua pekarangan, dan pohon-pohon saya selalu lebih tinggi." <br><br>  <b>PPPPS</b> : Begitu mereka memanggil kurva-Z, di sini Anda memiliki urutan-Z dan interleaving-bit dan kode / kurva Morton.  Itu juga dikenal sebagai kurva Lebesgue, sehingga untuk menjaga keseimbangan, penulis berhak artikel, termasuk untuk menghormati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Henry Leon Lebesgue</a> . <br><br>  <b>PPPPPS</b> : Dalam ilustrasi judul, pemandangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gletser Fedchenko</a> cukup indah, dan ada kekosongan yang cukup.  Bahkan, penulis terkesan dengan bagaimana berbagai ide dan metode mengalir dengan lancar satu sama lain, secara bertahap bergabung menjadi satu algoritma.  Sama seperti banyak sumber air kecil yang membentuk daerah tangkapan air membentuk limpasan tunggal. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464057/">https://habr.com/ru/post/id464057/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464041/index.html">Mengapa pilot pesawat tempur terbaik sering mendapat masalah besar</a></li>
<li><a href="../id464043/index.html">Sejarah Konverter Ethernet-CAN</a></li>
<li><a href="../id464045/index.html">How I Almost Real-Time Race Trails pada tahun 1997</a></li>
<li><a href="../id464053/index.html">Nota: Pemilihan trek dan algoritma rotasi</a></li>
<li><a href="../id464055/index.html">Kami mempelajari data yang dikumpulkan oleh Xiaomi Mi Band untuk tahun ini</a></li>
<li><a href="../id464063/index.html">Memotong kabel pada tahun 2019</a></li>
<li><a href="../id464071/index.html">Revolusi atau rasa sakit? Laporan Reaksi Kait Yandex</a></li>
<li><a href="../id464075/index.html">Pengantar C. Pesan dari abad terakhir</a></li>
<li><a href="../id464077/index.html">Tidak, Anda tidak perlu delta 50 km / s. Anda Membutuhkan Teknologi Aditif (Bagian 1)</a></li>
<li><a href="../id464079/index.html">Cara membuat pesawat ruang angkasa lepas landas dan mendarat tanpa teknologi keajaiban</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>