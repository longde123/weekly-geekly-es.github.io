<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ë üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ üì© Trabaja con IPv6 en PHP üöÜ ‚ÜïÔ∏è üßù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente recibimos el estado de LIR y el bloque / 29 IPv6. Y luego era necesario hacer un seguimiento de las subredes designadas. Y dado que nues...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabaja con IPv6 en PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/484586/">  Recientemente recibimos el estado de LIR y el bloque / 29 IPv6.  Y luego era necesario hacer un seguimiento de las subredes designadas.  Y dado que nuestra facturaci√≥n se escribi√≥ en PHP, tuve que inspirarme un poco por el problema y darme cuenta de que este lenguaje no es el m√°s amigable en t√©rminos de trabajo con IPv6.  Under the cut: nuestra soluci√≥n a los problemas de trabajar con direcciones y rangos.  Quiz√°s no sea el m√°s elegante, pero realiza las tareas. <br><br><img src="https://habrastorage.org/webt/bk/on/p9/bkonp9-y-sxfdqvirte2ehjunr0.jpeg"><a name="habracut"></a><br><br><h3>  Poco de teor√≠a </h3><br><blockquote>  <b>Descargo de responsabilidad.</b>  Si est√° familiarizado con lo que es IPv6 y con qu√© se come, esta parte puede ser aburrida para usted.  Puede que no sea. </blockquote><br>  Las personas que primero ven la anotaci√≥n IPv6 pueden desanimarse.  Despu√©s del elegante <i>64.233.177.101, de</i> repente nos encontramos con <i>2607: f8b0: 4002: c08 :: 8b</i> y podemos confundirnos.  Tanto eso como otro, solo una representaci√≥n legible por humanos de 32 y 128 bits respectivamente.  Cualquier paquete IP contiene un encabezado con una asignaci√≥n estrictamente estandarizada de cada bit.  Sin profundizar a√∫n m√°s en la estructura de los encabezados, necesitamos sacar una cosa de aqu√≠: para operaciones con direcciones IP y rangos, generalmente es conveniente usar operaciones binarias de matem√°tica y bit a bit.  Tambi√©n es m√°s conveniente almacenarlos en la base de datos como <i>BINARY (4)</i> para IPv4 y <i>BINARY (16)</i> para IPv6. <br><br>  Otro aspecto importante que debe abordarse son las m√°scaras de red y la notaci√≥n CIDR.  CIDR es un acr√≥nimo de enrutamiento entre dominios sin clase.  Este concepto reemplaz√≥ a la clase uno para determinar qu√© parte de la direcci√≥n IP es el prefijo de red y qu√© parte es la direcci√≥n de interfaz de red dentro de esta red.  En la pr√°ctica, los primeros n bits correspondientes al prefijo se establecer√°n en 1, el resto en 0. <br><br>  En forma legible para humanos, esto se escribe como <i>ip.add.re.ss. / cidr</i> .  Por ejemplo, <i>64.233.177.0/24</i> significa que los primeros 24 bits se refieren al prefijo.  Los √∫ltimos 8 bits, son el √∫ltimo n√∫mero en una entrada legible para humanos, se refieren a la direcci√≥n dentro de la subred.  Un par de ejercicios m√°s.  <i>64.233.177.101/32</i> y <i>2607: f8b0: 4002: c08 :: 8b / 128</i> - una direcci√≥n espec√≠fica.  <i>2607: f8b0: 4002: c08 :: / 64</i> - los primeros 64 bits (los primeros 4 grupos) - el prefijo, los 64 bits restantes - la parte local.  Por cierto, si alguien est√° avergonzado por el "::" en la entrada, un doble punto reemplaza un n√∫mero arbitrario de secciones que contienen 0. Puede ocurrir en la anotaci√≥n solo 1 vez.  En otras palabras, <i>2607: f8b0: 4002: c08 :: 8b = 2607: f8b0: 4002: c08: 0: 0: 0: 8b</i> . <br><br>  ¬øQu√© necesitamos aprender de todo esto?  En primer lugar, la primera y la √∫ltima direcci√≥n de subred se pueden obtener utilizando AND y OR binarios, conociendo la m√°scara en forma binaria.  En segundo lugar, la siguiente subred de tama√±o (es decir, con CIDR) <b>n</b> puede calcularse sumando 1 a la en√©sima posici√≥n en representaci√≥n binaria.  Por vista binaria, me refiero al resultado del uso de las funciones <i>pack ()</i> e <i>inet_pton ()</i> y el uso posterior de <a href="https://www.php.net/manual/ru/language.operators.bitwise.php">operadores bit a bit</a> , por binario, una representaci√≥n en el sistema binario, que se puede obtener, por ejemplo, usando <i>base_convert ()</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Antecedentes historicos</b> <div class="spoiler_text"> <s>Segregaci√≥n</s> sin clase <s>de</s> direccionamiento precedido sin clase.  En esos a√±os distantes, nadie esperaba que hubiera tantas subredes; se distribu√≠an a la derecha y a la izquierda en grandes bloques: clase A: los primeros 8 bits (es decir, el primer n√∫mero) ten√≠an el prefijo, con el bit inicial 0;  clase B: los primeros 16 (primeros dos n√∫meros), los bits iniciales de 10;  clase C: los primeros 24 bits, los bits iniciales de 110. Estos mismos bits <i>iniciales</i> establecen los rangos en los que se emiti√≥ la direcci√≥n de una clase: <i>0.0.0.0 - 127.255.255.255</i> para la clase A, <i>128.0.0.0 - 191.255.255.255</i> - clase B, 192.0 .0.0 - 223.255.255.255 - clase C. A medida que Internet se extendi√≥ por todo el planeta, los reguladores se dieron cuenta de que hab√≠an fallado, y a principios de los a√±os 90 desarrollaron un concepto sin clases, que les permiti√≥ no apegarse a los bits principales.  Un poco m√°s de detalles se pueden encontrar, por ejemplo, en el <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">gran y omnisciente</a> . </div></div><br><br><h3>  Pasemos a practicar </h3><br>  En la pr√°ctica, implementamos las tres tareas m√°s probables, como me pareci√≥ a m√≠: <br><br><ol><li>  obtener la primera y la √∫ltima direcci√≥n del rango; </li><li>  obtener el siguiente rango de un tama√±o dado (CIDR); </li><li>  comprobando que la direcci√≥n pertenece a un rango. </li></ol><br>  La implementaci√≥n ser√° para IPv6, pero si es necesario, la l√≥gica se puede adaptar f√°cilmente.  Obtuve algunas ideas de <a href="https://intsystem.org/coding/kak-rabotat-s-ipv6-v-php/">aqu√≠</a> , pero las implement√© de manera un poco diferente.  Adem√°s, en los ejemplos no hay verificaci√≥n de errores de entrada.  Entonces vamos. <br><br>  Como ya mencion√©, la primera y la √∫ltima direcci√≥n de un rango se pueden determinar utilizando operaciones bit a bit, conociendo el comienzo del rango y la m√°scara de subred binaria.  En consecuencia, lo primero que debemos hacer es convertir CIDR en una m√°scara binaria.  Para hacer esto, recopile su representaci√≥n hexadecimal y empaqu√©tela en binario. <br><br><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cidrToMask</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($cidr)</span></span></span><span class="hljs-function"> </span></span>{ $mask = str_repeat(<span class="hljs-string"><span class="hljs-string">'f'</span></span>, ceil($cidr / <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask .= dechex(<span class="hljs-number"><span class="hljs-number">4</span></span> * ($cidr % <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask = str_pad($mask, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $mask); }</code> </pre> <br>  Call <i>pack ('H *', $ mask)</i> empaqueta la representaci√≥n hexadecimal de la misma manera que <i>inet_pton ()</i> .  La √∫nica diferencia es que cuando llama a <i>pack (),</i> todos los 0 deben estar en su lugar, y no debe haber dos puntos en la entrada, en contraste con la entrada legible por humanos. <br><br>  El siguiente paso es calcular el comienzo y el final del rango.  Y aqu√≠ hay matices.  Las operaciones bit a bit est√°n limitadas por la capacidad del procesador.  En consecuencia, en mi CubieTruck de 32 bits, que a veces uso para cualquier prueba de mimo, los 128 bits de la direcci√≥n no se pueden procesar en una sola operaci√≥n.  Sin embargo, nada nos impide dividirlo en grupos de 32 bits (por si acaso, qui√©n sabe qu√© procesadores ejecutaremos). <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRangeBoundary</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $cidr, $which, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ $mask = cidrToMask($cidr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ip = inet_pton($ip); } $ipParts = str_split($ip, <span class="hljs-number"><span class="hljs-number">4</span></span>); $maskParts = str_split($mask, <span class="hljs-number"><span class="hljs-number">4</span></span>); $rangeParts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; count($ipParts); $i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($which == <span class="hljs-string"><span class="hljs-string">'start'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  &amp;       . */</span></span> $rangeParts[$i] = $ipParts[$i] &amp; $maskParts[$i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*  |    (~)           1. */</span></span> $rangeParts[$i] = $ipParts[$i] | ~$maskParts[$i]; } } $rangeBoundary = implode($rangeParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rangeBoundary; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($rangeBoundary); } }</code> </pre> <br>  Para uso futuro, proporcionaremos la capacidad de transmitir IP y obtener el resultado tanto en formato binario como legible para humanos.  El par√°metro <i>$ which</i> establece aqu√≠ si queremos obtener el principio o el final del rango (los valores son <i>'inicio'</i> o <i>'final',</i> respectivamente). <br><br>  La siguiente tarea (adem√°s de la m√°s pr√°ctica para nuestra empresa) es calcular el siguiente rango.  Para esta tarea, no se me ocurri√≥ nada mejor, excepto c√≥mo descomponer la direcci√≥n en una cadena binaria y agregar 1 en la posici√≥n deseada, luego colapsar todo de nuevo.  Para evitar que aparezcan artefactos en cualquier lugar, decid√≠ dividir la direcci√≥n por bytes durante la descomposici√≥n y el ensamblaje. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextBlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ipStart, $cidr, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ipStart = inet_pton($ipStart); } $ipParts = str_split($ipStart, <span class="hljs-number"><span class="hljs-number">1</span></span>); $ipBin = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $ipPart) { $ipBin .= str_pad(base_convert(unpack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $ipPart)[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT); } <span class="hljs-comment"><span class="hljs-comment">/*  1       "" :) */</span></span> $i = $cidr - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($ipBin[$i] == <span class="hljs-string"><span class="hljs-string">'0'</span></span>) { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'0'</span></span>; } $i--; } $ipBinParts = str_split($ipBin, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipBinParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $ipBinPart) { $ipParts[$key] = pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, str_pad(base_convert($ipBinPart, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT)); } $nextIp = implode($ipParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $nextIp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($nextIp); } }</code> </pre> <br>  En la salida, obtenemos el prefijo del siguiente rango de tama√±o especificado en <i>$ cidr</i> .  Con esta funci√≥n, asignamos bloques de direcciones a nuestros clientes. <br><br>  Finalmente, verifique si la direcci√≥n pertenece al rango.  Por ejemplo, asignamos un bloque / 48 para la distribuci√≥n de bloques / 64 a los clientes, y debemos asegurarnos de que durante la cita no vayamos m√°s all√° del bloque asignado (en la pr√°ctica esto suceder√° pronto, pero todav√≠a hay una posibilidad).  Todo es simple aqu√≠.  Obtenemos el comienzo y el final del rango en forma binaria y verificamos si la direcci√≥n est√° dentro. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ipInRange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $rangeStart, $cidr)</span></span></span><span class="hljs-function"> </span></span>{ $start = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'start'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $end = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'end'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $ipBin = inet_pton($ip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($ipBin &gt;= $start &amp;&amp; $ipBin &lt;= $end); }</code> </pre> <br>  Espero que haya sido √∫til.  ¬øQu√© otras funciones de direccionamiento pueden resultarle √∫tiles?  Cualquier adici√≥n, comentario y revisi√≥n de c√≥digo son bienvenidos en los comentarios. <br><br>  Si ya es nuestro cliente o est√° pensando en convertirse en uno, con ocasi√≥n del lanzamiento de este art√≠culo, le sugerimos que reciba el bloque / 64 de forma gratuita para todos los servicios vps o un servidor dedicado en el centro de datos Equinix Tier IV, Pa√≠ses Bajos, previa solicitud al departamento de ventas, proporcionando un enlace a Este art√≠culo en el boleto.  La oferta es v√°lida hasta marzo de 2020. <br><br><h3>  Un poco de publicidad :) </h3><br>  Gracias por quedarte con nosotros.  ¬øTe gustan nuestros art√≠culos?  ¬øQuieres ver m√°s materiales interesantes?  Ap√≥yenos haciendo un pedido o recomendando a sus amigos <a href="https://ua-hosting.company/cloudvps/nl">VPS basado en la nube para desarrolladores desde $ 4.99</a> , un <b>an√°logo √∫nico de servidores de nivel b√°sico que inventamos para usted:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">toda la verdad sobre VPS (KVM) E5-2697 v3 (6 n√∫cleos) 10GB DDR4 480GB SSD 1Gbps desde $ 19 o c√≥mo dividir el servidor?</a>  (las opciones est√°n disponibles con RAID1 y RAID10, hasta 24 n√∫cleos y hasta 40GB DDR4). <br><br>  <b>Dell R730xd 2 veces m√°s barato en el centro de datos Equinix Tier IV en Amsterdam?</b>  ¬°Solo tenemos <b><a href="https://ua-hosting.company/serversnl">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV desde $ 199</a> en los Pa√≠ses Bajos!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - ¬°desde $ 99!</b></b>  Lea sobre <a href="https://habr.com/company/ua-hosting/blog/329618/">C√≥mo construir un edificio de infraestructura.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">clase utilizando servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</a> </div></div><p>Source: <a href="https://habr.com/ru/post/484586/">https://habr.com/ru/post/484586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484574/index.html">No hay garrapatas! Vector de plantas contra la enfermedad de Lyme</a></li>
<li><a href="../484578/index.html">Objetivos del nivel de servicio: experiencia de Google (traducci√≥n del cap√≠tulo del libro de Google SRE)</a></li>
<li><a href="../484580/index.html">Lo que necesita saber sobre simuladores para memoria</a></li>
<li><a href="../484582/index.html">ASP.NET MVC: Entity Framework, MySQL y el uso de Dependency Resolver para seleccionar un repositorio</a></li>
<li><a href="../484584/index.html">¬øPor qu√© necesitamos un gerente en un proyecto de TI y qu√© suceder√° cuando no lo sea?</a></li>
<li><a href="../484588/index.html">Modelo automatizado de gesti√≥n de programas</a></li>
<li><a href="../484590/index.html">Para que los chicos no se avergonzaran de mostrar</a></li>
<li><a href="../484592/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 398 (13-19 de enero de 2020)</a></li>
<li><a href="../484596/index.html">Blazor Client Side Online Store: Parte 1 - Autorizaci√≥n oidc (oauth2) + Identity Server4</a></li>
<li><a href="../484600/index.html">Microsoft Ignite The Tour Praga Conferencia t√©cnica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>