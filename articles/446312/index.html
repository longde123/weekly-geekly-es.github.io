<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍⚖️ 🤞🏾 🙎🏿 Interrupciones externas en el sistema x86. Parte 1. Evolución del controlador de interrupción 👨🏼‍⚕️ 👩🏿‍🏫 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo trata sobre el proceso de entrega de interrupciones desde dispositivos externos en el sistema x86. Intenta responder preguntas como: 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interrupciones externas en el sistema x86. Parte 1. Evolución del controlador de interrupción</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446312/">  Este artículo trata sobre el proceso de entrega de interrupciones desde dispositivos externos en el sistema x86.  Intenta responder preguntas como: <br><br><ul><li>  ¿Qué es pic y para qué sirve? </li><li>  ¿Qué es APIC y para qué sirve?  ¿Cuál es el propósito de LAPIC y I / O APIC? </li><li>  ¿Cuáles son las diferencias entre APIC, xAPIC y x2APIC? </li><li>  ¿Qué es el MSI?  ¿Cuáles son las diferencias entre MSI y MSI-X? </li><li>  ¿Cuál es el papel de las tablas $ PIR, MPtable y ACPI? </li></ul><br>  Si desea conocer la respuesta a una de estas preguntas, o si simplemente desea saber sobre la evolución del controlador de interrupción, por favor, bienvenido. <br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  Para aquellos que no saben qué es una interrupción, aquí hay una cita de Wikipedia: <br><blockquote>  En la programación del sistema, una interrupción es una señal al procesador emitida por hardware o software que indica un evento que requiere atención inmediata.  Una interrupción alerta al procesador sobre una condición de alta prioridad que requiere la interrupción del código actual que el procesador está ejecutando.  El procesador responde suspendiendo sus actividades actuales, guardando su estado y ejecutando una función llamada controlador de interrupción (o una rutina de servicio de interrupción, ISR) para tratar el evento.  Esta interrupción es temporal y, una vez que finaliza el controlador de interrupciones, el procesador reanuda las actividades normales. <br><br>  Hay dos tipos de interrupciones: interrupciones de hardware e interrupciones de software (softirqs): <br><br><ul><li> Los dispositivos utilizan las interrupciones de hardware para comunicar que requieren atención del sistema operativo.  Internamente, las interrupciones de hardware se implementan utilizando señales de alerta electrónicas que se envían al procesador desde un dispositivo externo, que es parte de la computadora, como un controlador de disco o un periférico externo.  Por ejemplo, al presionar una tecla en el teclado o al mover el mouse se activan interrupciones de hardware que hacen que el procesador lea la pulsación de tecla o la posición del mouse.  El acto de iniciar una interrupción de hardware se denomina solicitud de interrupción (IRQ). </li><li>  Una interrupción de software es causada por una condición excepcional en el procesador o por una instrucción especial en el conjunto de instrucciones que causa una interrupción cuando se ejecuta.  El primero a menudo se llama trampa o excepción y se usa para errores o eventos que ocurren durante la ejecución del programa que son lo suficientemente excepcionales como para que no puedan manejarse dentro del programa mismo.  Por ejemplo, se generará una excepción de división por cero si se ordena a la unidad lógica aritmética del procesador que divida un número por cero, ya que esta instrucción es un error e imposible. </li></ul></blockquote><br>  Este artículo trata sobre hardware / interrupciones externas IRQ. <br><br>  ¿Cuál es el propósito de las interrupciones?  Por ejemplo, queremos realizar una acción con un paquete entrante de la tarjeta de red tan pronto como llegue el paquete.  Si no desea preguntar continuamente a la tarjeta de red "¿Ha llegado mi paquete?"  y perder el tiempo de su procesador, puede utilizar IRQ de interrupción de hardware externo.  La línea de interrupción de un dispositivo debe conectarse a la línea INTR de la CPU, y después de recibir cada paquete, la tarjeta de red emitirá una señal a través de esta línea.  La CPU detectará esta señal y sabrá que la tarjeta de red tiene información para ella.  Solo después de eso, la CPU leerá el paquete entrante. <br><br>  Pero, ¿qué debemos hacer si hay muchos dispositivos externos?  Sería muy improductivo hacer un montón de pines INTR en la CPU para todos ellos. <br><br><img src="https://habrastorage.org/webt/vg/3q/3v/vg3q3v7kx8vjttp43xo99o8pccs.png"><br><br>  Para resolver este problema, se inventó un chip especial: un controlador de interrupción. <br><br><h3>  Pic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">osdev</a> ) <br><br>  El primer chip controlador de interrupción fue el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PIC Intel 8259</a> .  Tenía 8 líneas de entrada (IRQ0-7) y 1 línea de salida (que conecta el controlador de interrupción con la línea INTR de la CPU).  Cuando hay una interrupción de uno de los dispositivos en sus líneas de entrada, el 8259 emitirá una señal sobre la línea INTR.  Después de eso, la CPU sabrá que algún dispositivo requiere su atención inmediata, y el procesador le preguntará al PIC cuál de las 8 líneas de entrada (IRQx) fue la fuente de esta interrupción.  Hay algo de sobrecarga en este sondeo, pero ahora tenemos 8 líneas de interrupción en lugar de 1. <br><br><img src="https://habrastorage.org/webt/le/yf/6e/leyf6enogyzp6flpijo2d0x1w9g.png"><br><br>  Pronto 8 líneas no fueron suficientes.  Para aumentar el número total de líneas de interrupción, se conectaron dos controladores 8259 (maestro y esclavo) en cascada (Dual PIC). <br><br>  Las IRQ de 0 a 7 se procesan con el primer Intel 8259 PIC (maestro), y las IRQ de 8 a 15 se procesan con el segundo Intel 8259 PIC (maestro).  Solo el maestro está conectado a la CPU y puede señalar las interrupciones entrantes.  Si hay una interrupción en las líneas 8-15, el segundo PIC (esclavo) se lo indicará al maestro en la línea IRQ2, y después de eso, el maestro señalará a la CPU.  Esta interrupción en cascada elimina 1 de las 16 líneas, pero hace un total de 15 interrupciones para todos los dispositivos externos. <br><br><img src="https://habrastorage.org/webt/xj/yn/dh/xjyndhabujjwz0alrbx831zfzt8.png"><br><br>  Este esquema fue adoptado por la comunidad, y ahora cuando alguien habla de PIC (Controlador de interrupción de programa) se refieren a este sistema Dual PIC.  Después de algún tiempo, los controladores 8259 se mejoraron y obtuvieron un nuevo nombre: 8259A.  Con estos controladores, el sistema DUAL PIC se incluyó en el conjunto de chips.  En un momento en que el bus principal para la conexión del dispositivo externo era el ISA, este sistema era suficiente.  Solo era necesario que diferentes dispositivos no se conectaran a la misma línea IRQ, ya que las interrupciones ISA no son compartibles. <br><br>  El mapeo de interrupción del dispositivo era bastante estándar: <br><br>  Ejemplo (desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> ): <br>  IRQ 0 - temporizador del sistema <br>  IRQ 1 - controlador de teclado <br>  IRQ 2 - cascada (interrupción del controlador esclavo) <br>  IRQ 3 - puerto serie COM2 <br>  IRQ 4 - puerto serie COM1 <br>  IRQ 5 - puerto paralelo 2 y 3 o tarjeta de sonido <br>  IRQ 6 - controlador de disquete <br>  IRQ 7 - puerto paralelo 1 <br>  IRQ 8 - Temporizador RTC <br>  IRQ 9 - ACPI <br>  IRQ 10 - abierto / SCSI / NIC <br>  IRQ 11 - abierto / SCSI / NIC <br>  IRQ 12 - controlador de mouse <br>  IRQ 13 - coprocesador matemático <br>  IRQ 14 - ATA canal 1 <br>  IRQ 15 - ATA canal 2 <br><br>  La configuración y el trabajo con chips 8259 se realiza con puertos de E / S: <br><div class="scrollable-table"><table><tbody><tr><th>  Chip </th><th>  Registrarse </th><th>  Puerto de E / S </th></tr><tr><td>  Foto maestra </td><td>  Comando </td><td>  0x0020 </td></tr><tr><td>  Foto maestra </td><td>  Datos </td><td>  0x0021 </td></tr><tr><td>  Foto esclavo </td><td>  Comando </td><td>  0x00A0 </td></tr><tr><td>  Foto esclavo </td><td>  Datos </td><td>  0x00A1 </td></tr></tbody></table></div><br>  La documentación completa del 8259A se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  El bus PCI luego reemplazó al bus ISA.  Desafortunadamente, el número de dispositivos comenzó a exceder el número 15. Además, en lugar del bus ISA estático, los dispositivos en el bus PCI se pueden agregar al sistema dinámicamente, lo que podría generar aún más problemas.  Pero afortunadamente, las interrupciones en el bus PCI se pueden compartir, por lo que es posible conectar muchos dispositivos a una línea de interrupción IRQ.  Al final, para resolver el problema de la falta de líneas de interrupción, se decidió agrupar las interrupciones de todos los dispositivos PCI a las líneas PIRQ (solicitud de interrupción programable). <br><br>  Por ejemplo, supongamos que tenemos 4 líneas de interrupción libres en el controlador PIC y 20 dispositivos PCI.  Podemos combinar interrupciones de 5 dispositivos en una línea PIRQx y conectar estas líneas PIRQx al controlador PIC.  En este caso, si hay una interrupción en una de las líneas PIRQx, el procesador tendrá que preguntar a todos los dispositivos conectados a esta línea sobre la interrupción para saber quién es el responsable, pero al final resuelve el problema.  El dispositivo que conecta las líneas de interrupción PCI a las líneas PIRQ a menudo se denomina enrutador PIR. <br><br>  Con este método es necesario asegurarse de que las líneas PIRQx no se conectan a líneas con interrupciones ISA (ya que esto producirá conflictos) y que las líneas PIRQx están equilibradas (cuantos más dispositivos conectemos a una línea, más dispositivos necesitará la CPU para sondear cuando necesita verificar qué dispositivo es responsable de la interrupción). <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>Nota</b> : en la imagen, el mapeo del dispositivo PCI -&gt; PIR se ilustra de forma abstracta, ya que en el caso real es un poco más complicado.  En el mundo real, cada dispositivo PCI tiene 4 líneas de interrupción (INTA, INTB, INTC, INTD) y hasta 8 funciones, donde cada función puede tener solo una de estas interrupciones INTx.  La configuración del conjunto de chips determina qué línea INTx será utilizada por cada función. <br><br>  Por su naturaleza, las funciones son bloques lógicos separados.  Por ejemplo, un dispositivo PCI puede tener una función de controlador Smbus, una función de controlador SATA y una función de puente LPC.  Desde el punto de vista de un sistema operativo (SO), cada función es como un dispositivo separado con su propio espacio de configuración (configuración PCI). <br><br>  La información sobre el enrutamiento de interrupción del controlador PIC es enviada al SO por el BIOS, con la ayuda de la tabla $ PIR y a través de los registros 3Ch (INT_LN Interrupt Line (R / W)) y 3Dh (INT_PN Interrupt Pin (RO)) de El espacio de configuración PCI para cada función. <br><br>  Recientemente se encontró una especificación para la tabla $ PIR <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web de Microsoft</a> , pero actualmente no está disponible.  Es posible comprender el contenido de la tabla a partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificación PCI BIOS</a> [4.2.2.  Obtener opciones de enrutamiento de interrupción PCI] o desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> (el último enlace está en ruso, pero puede intentar buscar en Google "Especificación de tabla de enrutamiento PCI IRQ") <br><br><h3>  Apic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">osdev</a> ) <br><br>  El último método funcionó hasta que llegaron los sistemas multiprocesador.  Por naturaleza, el PIC solo puede enviar interrupciones a una CPU, y en un sistema multiprocesador se desea cargar las CPU de forma equilibrada.  La solución a este problema fue la nueva interfaz APIC (Advanced PIC). <br><br>  Se agregó un controlador especial llamado LAPIC (APIC local) para cada procesador, así como el controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">APIC de E / S</a> para enrutar interrupciones desde dispositivos externos.  Todos estos controladores se combinan en un bus común con el nombre APIC (tenga en cuenta que los sistemas modernos usan un bus de sistema estándar en lugar de un bus APIC separado para esta tarea). <br><br>  Cuando llega una interrupción externa a la entrada I / O APIC, el controlador enviará un mensaje de interrupción al LAPIC de una de las CPU del sistema.  De esta forma, el controlador I / O APIC ayuda a equilibrar la carga de interrupción entre procesadores. <br><br>  El primer chip APIC fue el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">82489DX</a> , que era un chip separado que tenía un LAPIC conectado y un APIC de E / S dentro de sí mismo.  Para un sistema de procesador dual se necesitaban tres chips de este tipo: dos para LAPIC y uno para I / O APIC.  La funcionalidad LAPIC posterior se incluyó directamente en los procesadores, y la parte I / O APIC se separó al chip 82093AA. <br><br>  El I / O APIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">82093AA</a> tenía 24 entradas, y la arquitectura APIC podía soportar hasta 16 CPU.  Las interrupciones 0-15 se dejaron para las antiguas interrupciones ISA por compatibilidad con sistemas más antiguos, y las interrupciones 16-23 estaban destinadas a todos los dispositivos PCI.  Con esta delimitación, todos los conflictos entre las interrupciones ISA y PCI podrían evitarse fácilmente.  Con el mayor número de líneas de interrupción libre, también fue posible aumentar el número de líneas PIRQx. <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  La programación I / O APIC y LAPIC se realiza con la ayuda de MMIO.  Los registros LAPIC generalmente se colocan en la dirección 0xFEE00000 y los registros APIC de E / S en la dirección 0xFE0000, aunque es posible volver a configurarlos. <br><br>  Como en el caso de PIC, chips separados al principio se convirtieron en parte del conjunto de chips más tarde. <br><br>  La arquitectura APIC se modernizó más tarde, y su nueva variante se denominó xAPIC (x - extendida).  Con total compatibilidad con versiones anteriores, el número total de CPU posibles en el sistema se incrementó a 256. <br><br>  El siguiente paso en el desarrollo de la arquitectura se denominó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">x2APIC</a> .  El número de CPU posibles en el sistema se incrementó a 2 ^ 32.  Estos controladores pueden funcionar en un modo de compatibilidad con versiones anteriores con xAPIC, o pueden funcionar en el nuevo modo x2APIC.  En este nuevo modo, la programación del controlador no se realiza a través de MMIO, sino a través de registros MSR (que son mucho más rápidos).  Según <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este enlace</a> , el soporte de IOMMU es necesario para este modo. <br><br>  Vale la pena señalar que es posible tener varios controladores APIC de E / S en el sistema.  Por ejemplo, una para 24 interrupciones en un puente sur y la otra para 32 interrupciones en un puente norte.  En el contexto de E / S APIC, las interrupciones generalmente se denominan GSI (Interrupción del sistema global).  Entonces, el sistema mencionado tiene GSI 0-55. <br><br>  ¿Cómo podemos determinar si una CPU tiene un LAPIC interno y qué arquitectura APIC admite?  Es posible responder a estas preguntas inspeccionando las banderas de bits de CPUID. <br>  Para ayudar al sistema operativo a descubrir LAPIC y I / O APIC, el BIOS debe presentar información sobre ellos a través de una tabla MPtable (método antiguo) o una tabla ACPI (una tabla MADT en este caso).  Además de la información común, tanto la MPtable como la ACPI (en este caso, una tabla DSDT) deben contener información sobre el enrutamiento de interrupción.  Esto significa información sobre qué dispositivo usa qué línea de interrupción (similar a la tabla $ PIR). <br><br>  Puede leer sobre MPtable en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20121002210153/">especificación</a> oficial.  Anteriormente, la especificación estaba en el sitio web de Intel, pero actualmente solo es posible encontrarla en una versión de archivo.  La especificación ACPI se puede encontrar en el sitio web de UEFI (la versión actual es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2</a> ).  Vale la pena notar que con ACPI es posible declarar el enrutamiento de interrupción para sistemas sin APIC (en lugar de proporcionar una tabla $ PIR separada). <br><br><h3>  Msi </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki</a> ) <br><br>  La última variante de APIC fue buena, pero no sin inconvenientes.  Todas las líneas de interrupción de los dispositivos complicaron mucho el sistema y, por lo tanto, aumentaron la probabilidad de error.  El bus PCI express vino a reemplazar al bus PCI, lo que simplificó completamente todos los sistemas de interrupción.  No tiene líneas de interrupción en absoluto.  Para la compatibilidad con versiones anteriores, las señales de interrupción (INTx #) se emulan con un tipo separado de mensajes.  Con las líneas de interrupción PCI, su conexión se realizó con cables físicos.  Con las líneas de interrupción PCI express, una conexión es lógica y se realiza mediante puentes PCI express.  Pero este soporte de interrupciones INTx heredadas solo existe para la compatibilidad con el bus PCI.  PCI express presenta un método completamente nuevo de entrega de interrupciones: MSI (interrupciones señalizadas por mensaje).  En este método, un dispositivo señala la interrupción simplemente escribiendo en un lugar especial en la región MMIO de las CPU LAPIC. <br><br><img src="https://habrastorage.org/webt/8z/qw/7h/8zqw7him-vupzm_wi5glkqtr1ja.png"><br><br>  Anteriormente, un solo dispositivo PCI (esto significa todas sus funciones) podía tener solo 4 interrupciones, pero ahora era posible abordar hasta 32 interrupciones. <br><br>  En el caso de MSI, no se comparten líneas de interrupción: cada interrupción corresponde naturalmente a su dispositivo. <br><br>  Las interrupciones de MSI también resuelven un problema más.  Por ejemplo, imaginemos una situación en la que un dispositivo realiza una transacción de escritura de memoria y quiere indicar que se ha completado a través de la interrupción.  Pero una transacción de escritura puede retrasarse en el bus en el proceso de su transmisión (y el dispositivo no podía saberlo).  En este caso, la señal sobre la interrupción llegará primero a la CPU, por lo que el procesador leerá datos aún no válidos.  Si se usa MSI, la información sobre MSI se transmite de la misma manera que los mensajes de datos, por lo que no puede llegar antes. <br><br>  Vale la pena notar que las interrupciones de MSI no pueden funcionar sin LAPIC, pero MSI puede reemplazar I / O APIC (una simplificación de diseño más). <br><br>  Después de algún tiempo, el método MSI se extendió a MSI-X.  Ahora cada dispositivo puede tener hasta 2048 interrupciones.  Ahora también es posible especificar qué CPU debe procesar qué interrupción.  Puede ser muy útil para dispositivos de alta carga, como las tarjetas de red, por ejemplo. <br><br>  No hay necesidad de una tabla de BIOS separada para el soporte de MSI.  Pero el dispositivo debe indicar su soporte MSI a través de una de las capacidades en su espacio de configuración PCI.  Además, un controlador de dispositivo debe incluir todo el soporte necesario para trabajar con el MSI. <br><br><h3>  Conclusión </h3><br>  En este artículo, hemos estudiado información sobre la evolución del controlador de interrupciones y tenemos un conocimiento teórico común sobre la entrega de interrupciones desde dispositivos externos en el sistema x86. <br><br>  En la siguiente parte, iremos a practicar y veremos cómo involucrar a cada uno de los controladores de interrupción mencionados en Linux. <br><br>  En la tercera parte, analizaremos el código de arranque de núcleo y veremos qué configuraciones se necesitan en el conjunto de chips para un enrutamiento de interrupción correcto. <br><br><h4>  Enlaces: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Controladores de interrupción (cosas en el medio)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué hacen las diferentes interrupciones en PCIe?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reducción de la latencia de interrupción mediante el uso de interrupciones señalizadas por mensaje</a> </li></ul><br><h4>  Segmentos reconocidos </h4><br>  Un agradecimiento especial a Jacob Garber de la comunidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">coreboot</a> por ayudarme con la traducción de este artículo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446312/">https://habr.com/ru/post/446312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446300/index.html">Cómo coordinar el vuelo de la sonda hacia la estratosfera (lo que encontraremos en la práctica en el lanzamiento)</a></li>
<li><a href="../446302/index.html">9 citas de Habraseminar 2019 para bloggers, emprendedores y RRHH</a></li>
<li><a href="../446304/index.html">Funciones físicas no razonables: protección de la electrónica contra copia ilegal</a></li>
<li><a href="../446306/index.html">¿Guerras nucleares del pasado lejano?</a></li>
<li><a href="../446308/index.html">¿El reclutamiento de referencias está vivo en TI?</a></li>
<li><a href="../446316/index.html">¡Solo espacio! Una enorme pieza de titanio en 6.5 días.</a></li>
<li><a href="../446320/index.html">Cómo el escáner 3D permitió abandonar el conjunto de control a gran escala del puente</a></li>
<li><a href="../446322/index.html">Criptografía en Java. Keytool Utility</a></li>
<li><a href="../446324/index.html">Navegación en DataGrip con Yandex.Navigator</a></li>
<li><a href="../446326/index.html">Resolviendo problemas de tráfico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>