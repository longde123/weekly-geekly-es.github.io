<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚓️ 👨🏾‍🤝‍👨🏻 🚋 Analyse de sentiment de texte sur Node.js 👧🏼 🆑 👍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous. Le sujet est assez intéressant et peut sembler assez difficile à mettre en œuvre. Mais je suis une personne pratique et je veux touche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse de sentiment de texte sur Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486036/"><p><img src="https://habrastorage.org/webt/ib/_g/vg/ib_gvg4f3vdu0wiwjyhrjctmd8g.jpeg"></p><br><p>  Bonjour à tous.  Le sujet est assez intéressant et peut sembler assez difficile à mettre en œuvre.  Mais je suis une personne pratique et je veux toucher la belle surtout sans forcer.  Aujourd'hui, nous allons faire un "microservice" pour l'analyse de la sentimentalité / tonalité du texte.  Et le cas, quelques choses plus intéressantes qui vous aideront à préparer votre appel textuel à Skynet. </p><a name="habracut"></a><br><h3 id="intro">  Intro </h3><br><p>  Pourquoi?  C'est une très bonne question.  Mais avant d'y répondre, soyons un peu plus intelligents et découvrons quelle est l'analyse de la tonalité du texte et quelle est la tonalité? </p><br><blockquote> L'analyse de la tonalité du texte (analyse des sentiments, analyse des sentiments en anglais, exploration des opinions en anglais) est une classe de méthodes d'analyse de contenu en linguistique informatique, conçue pour identifier automatiquement dans les textes le vocabulaire émotionnellement coloré et l'évaluation émotionnelle des auteurs (opinions) en relation avec les objets, la parole qui va dans le texte. <br><br>  La tonalité est l'attitude émotionnelle de l'auteur d'une déclaration à un objet (un objet du monde réel, un événement, un processus ou leurs propriétés / attributs), exprimée dans le texte.  La composante émotionnelle, exprimée au niveau du lexème ou fragment communicatif, est appelée tonalité lexicale (ou sentiment lexical).  La tonalité de l'ensemble du texte dans son ensemble peut être définie comme une fonction (dans le cas le plus simple, la somme) de la tonalité lexicale de ses unités (phrases) et des règles de combinaison. </blockquote><p>  par wikipedia </p><br><h3 id="zachem">  Pourquoi? </h3><br><p>  J'ai souvent plus de questions que de réponses en lisant Wikipédia.  Simplifions - la clé du texte nous parle de "l'humeur du texte".  Par exemple, «Viens ici, ta mère ...» signale que l'auditeur a des problèmes.  «Chérie, je suis à la maison» - un peu mieux, mais selon la situation. </p><br><p><img src="https://habrastorage.org/webt/5s/xz/dl/5sxzdlj-cbh9r3axka1xf0lmcwq.gif"></p><br><p>  Vous pouvez utiliser cette analyse pour rechercher des nouvelles positives, filtrer les commentaires négatifs, créer des évaluations de produits par avis, etc.  Je pense que l'idée générale est claire. </p><br><h3 id="ustanavlivaem-neobhodimoe">  Installez le nécessaire </h3><br><p>  Puisque nous allons utiliser Node.js, nous aurons besoin d'Express.  Vous pouvez utiliser n'importe quoi, Express ala bas niveau et non critique pour la tâche. </p><br><pre><code class="bash hljs">npm install -g express-generator</code> </pre> <br><p>  <a href="https://expressjs.com/en/starter/generator.html" rel="nofollow">express-generator</a> est une sorte d'application <a href="https://reactjs.org/docs/create-a-new-react-app.html" rel="nofollow">create-react-</a> framework pour Express. </p><br><p>  Nous générons l'application dans le dossier <code>node_nlp</code> : </p><br><pre> <code class="bash hljs">express node_nlp --no-view</code> </pre> <br><p>  vous pouvez simplifier les deux dernières commandes en utilisant npx: </p><br><pre> <code class="bash hljs">npx express-generator node_nlp --no-view</code> </pre> <br><p>  Pour démarrer l'application, allez dans le dossier, téléchargez les dépendances et lance: </p><br><pre> <code class="plaintext hljs">cd node_nlp npm install npm start</code> </pre> <br><p>  Afin de ne pas perdre de temps à redémarrer manuellement le serveur pour chaque changement, <code>nodemon</code> et configurons <code>nodemon</code> : </p><br><pre> <code class="bash hljs">npm install --save nodemon</code> </pre> <br><p>  Modifications mineures dans package.json: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"dev"</span></span>: <span class="hljs-string"><span class="hljs-string">"nodemon ./bin/www"</span></span></code> </pre> <br><p>  Et pour le développement, nous utilisons: </p><br><pre> <code class="bash hljs">npm run dev</code> </pre> <br><p>  Mettons tout de suite une multitude de paquets, je vais vous expliquer pourquoi ils sont nécessaires en cours de route.  C’est juste un didacticiel différent pour s’efforcer d’être une configuration de projet et j’ai déjà oublié ce que j’écris avec toutes ces <code>npm install</code> . </p><br><pre> <code class="bash hljs">npm install --save natural apos-to-lex-form spelling-corrector stopword</code> </pre> <br><p><img src="https://habrastorage.org/webt/yd/q5/6y/ydq56yhahqjyit4dpuqgntr0s2i.png"></p><br><h3 id="routing">  Acheminement </h3><br><p>  En fait, nous n'aurons qu'un seul point de terminaison, dans le dossier <code>./routers</code> , il y a un fichier <code>index.js</code> que nous allons <code>index.js</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> natural = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'natural'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = express.Router(); router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = req.body; }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router;</code> </pre> <br><p>  Un point de terminaison <code>POST</code> simple qui prend un <code>body</code> avec un champ de <code>text</code> . </p><br><h3 id="processing">  Traitement </h3><br><p>  Si vous, comme moi, êtes en quelque sorte entré en contact avec la création <del>  skynet </del>  , traité les données, vous savez probablement que le processus de préparation est aussi important que le processus de traitement des données.  Nous devons minimiser les différents bruits et les erreurs possibles, afin que vous n'iriez pas vers le haut-parleur, "eh bien, viens ici ta mère ...". </p><br><h3 id="izbavlyaemsya-ot-sokrascheniy">  Débarrassez-vous des coupures </h3><br><p><img src="https://habrastorage.org/webt/p6/bf/b4/p6bfb4bi1gveyau9ek44ed7hxhc.gif"></p><br><p>  Étant donné que le microservice sera engagé dans l'analyse de la tonalité de la langue anglaise, nous devons examiner comment transformer des abréviations telles que je suis, vous êtes en je suis, vous êtes. <br>  Pour cela, nous utiliserons <a href="https://www.npmjs.com/package/apos-to-lex-form" rel="nofollow">apos-to-lex-form</a> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> natural = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'natural'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aposToLexForm = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'apos-to-lex-form'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = express.Router(); router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = req.body; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lexedText = aposToLexForm(text); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router;</code> </pre> <br><h3 id="konvertiruem-tekst-v-lowercase-nizhniy-registr">  Convertir le texte en minuscules (minuscules) </h3><br><p>  Pour que les mots ALLER ICI et venir ici soient perçus de la même manière, vous devez vous assurer que tout le texte est dans un seul registre. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> casedReview = lexedText.toLowerCase();</code> </pre> <br><h3 id="udalyaem-lishnie-simvoly">  Supprimer des caractères supplémentaires </h3><br><p>  Pour la prochaine amélioration de la précision de notre analyse, vous devez supprimer les caractères supplémentaires, il m'est difficile de dire quelle tonalité @ # $% ^ # ces caractères sont.  Par conséquent, nous supprimons tous les inutiles et ne laissons que des lettres. <br>  Nous utilisons la fonction JavaScript standard - <code>replace()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alphaOnlyReview = casedReview.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[^a-zA-Z\s]+/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><h3 id="tokenizaciya">  Tokenisation </h3><br><p>  La tokenisation est le processus de décomposition du texte en composants individuels.  Par exemple, le mot est le jeton de phrase et la phrase, à son tour, est le jeton de paragraphe. </p><br><p>  Ici, notre cheval principal <a href="https://www.npmjs.com/package/natural" rel="nofollow">Natural se</a> précipite dans la scène. <br>  Dans ce package, nous sommes fournis avec l' <code>WordTokenizer</code> WordTokenizer: </p><br><pre> <code class="javascript hljs">... const { WordTokenizer } = natural; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordTokenizer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizedReview = tokenizer.tokenize(alphaOnlyReview); ...</code> </pre> <br><h3 id="ispravlyaem-oshibki">  Corrections de bugs </h3><br><p>  Comme le texte peut provenir de n'importe où, il y a un risque d'erreurs.  Nous devons essayer de les réparer.  Le <a href="https://www.npmjs.com/package/spelling-corrector" rel="nofollow">correcteur orthographique</a> nous y aidera. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> natural = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'natural'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aposToLexForm = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'apos-to-lex-form'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SpellCorrector = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'spelling-corrector'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = express.Router(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spellCorrector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpellCorrector(); spellCorrector.loadDictionary(); router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = req.body; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lexedText = aposToLexForm(text); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> casedReview = lexedText.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alphaOnlyReview = casedReview.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[^a-zA-Z\s]+/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { WordTokenizer } = natural; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordTokenizer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizedReview = tokenizer.tokenize(alphaOnlyReview); tokenizedReview.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word, index</span></span></span><span class="hljs-function">) =&gt;</span></span> { tokenizedReview[index] = spellCorrector.correct(word); }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router;</code> </pre> <br><h3 id="udalyaem-stop-slova">  Supprimer les mots vides </h3><br><p><img src="https://habrastorage.org/webt/lp/5r/_u/lp5r_uo_fh_dra2is3ct56ufrzq.gif"></p><br><p>  Arrêtez les mots, ce sont des mots parasites.  Eh bien, pour ainsi dire, euh, ouu, hé, pas comme des parasites, mais juste des mots superflus qui ne font absolument aucun temps pour notre tonique.  Avec la suppression de ces mots, le paquet de <a href="https://www.npmjs.com/package/stopword" rel="nofollow">mots vides</a> nous aidera. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SW = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stopword'</span></span>); ... const filteredReview = SW.removeStopwords(tokenizedReview);</code> </pre> <br><h3 id="stemming-stemming">  Stemming </h3><br><p>  La racine est le processus de normalisation des mots.  Par exemple, «donner», «donner» et «donner» sous la forme simple «donner». <br>  Nous ne considérerons pas cela comme une étape distincte, car le <code>SentimentAnalyzer</code> qui nous fournit le package <code>Natural</code> peut le faire pour nous. </p><br><h3 id="tonalnyy-analiz-teksta-s-pomoschyu-natural">  Analyse du texte de tonalité avec Natural </h3><br><p>  C’est tout!  Nous y sommes arrivés.  Skynet va maintenant accepter la nôtre et tout comprendre.  Il est temps d'alimenter le texte dans <code>SentimentAnalyzer</code> et de comprendre si nous semblons positifs dans une société aussi tolérante ou non. </p><br><p>  L'analyse de tonalité fonctionne de manière assez complexe.  Le paquet naturel a son propre dictionnaire de mots avec la "polarité" des mots.  Par exemple, le mot «bon» a une polarité de 3 et le mot «mauvais» est -3.  En fait, tous ces «points» sont résumés et normalisés en fonction de la taille de la proposition.  Par conséquent, en fait, nous avons tant fait pour éliminer notre texte de tout ce qui était superflu, afin que rien ne nous empêche d'obtenir une évaluation adéquate. <br>  Le texte est positif si la note est positive, négatif s'il est négatif et neutre si nous obtenons 0. </p><br><p>  <code>SentimentAnalyzer</code> <a href="https://www.npmjs.com/package/natural" rel="nofollow">accepte 3 paramètres</a> : </p><br><ul><li>  Langue du texte </li><li>  Diffuser ou ne pas diffuser </li><li>  Dictionnaire (AFINN, Senticon, Pattern), il est intégré </li></ul><br><p>  Tout le code final avec analyse du ton du texte à la fin: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> natural = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'natural'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aposToLexForm = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'apos-to-lex-form'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SpellCorrector = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'spelling-corrector'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SW = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stopword'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = express.Router(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spellCorrector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpellCorrector(); spellCorrector.loadDictionary(); router.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { text } = req.body; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lexedText = aposToLexForm(text); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> casedReview = lexedText.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alphaOnlyReview = casedReview.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[^a-zA-Z\s]+/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { WordTokenizer } = natural; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordTokenizer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenizedReview = tokenizer.tokenize(alphaOnlyReview); tokenizedReview.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word, index</span></span></span><span class="hljs-function">) =&gt;</span></span> { tokenizedReview[index] = spellCorrector.correct(word); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filteredReview = SW.removeStopwords(tokenizedReview); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { SentimentAnalyzer, PorterStemmer } = natural; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> analyzer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SentimentAnalyzer(<span class="hljs-string"><span class="hljs-string">'English'</span></span>, PorterStemmer, <span class="hljs-string"><span class="hljs-string">'afinn'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> analysis = analyzer.getSentiment(filteredReview); res.status(<span class="hljs-number"><span class="hljs-number">200</span></span>).json({ analysis }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router;</code> </pre> <br><p>  Nous avons ajouté de nouvelles lignes.  Destruction <code>natural</code> , pour obtenir les outils dont nous avons besoin, nous avons créé une variable pour l'analyseur et affecté le résultat à l' <code>analysis</code> variables. <br>  Les paramètres du <code>SentimentAnalyzer</code> sont relativement évidents.  La langue est l'anglais comme texte que nous traitons en anglais.  Tamponner les mots que j'ai mentionnés ci-dessus et le dictionnaire qui nous est fourni par le package <code>Natrual</code> . </p><br><p>  Je voudrais faire une interface utilisateur pour ce cas, mais vous pouvez le tester dans quelques DevTools: </p><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify({<span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'hey'</span></span>}) }) <span class="hljs-comment"><span class="hljs-comment">// {"analysis":0} fetch('/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({text: 'hey f*** you'}) }) // {"analysis":-2} fetch('/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({text: 'hey love you'}) }) // {"analysis":1}</span></span></code> </pre> <br><p>  Comme nous le voyons, cela fonctionne :) </p><br><p>  <a href="https://github.com/DmitryOlkhovoi/sentiment-analysis-nodejs" rel="nofollow">Github repo</a> </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Dans cet article, nous avons créé un "microservice" qui analyse la tonalité du texte.  Amenez-le à n'importe quelle épreuve de force et analysez ce que disent vos adversaires.  Nous avons également abordé le sujet de la préparation des données et installé une tonne de dépendances.  Merci de votre attention! </p><br><p>  Lisez la même chose </p><br><ul><li>  <a href="https://habr.com/ru/post/485768/">Tendances Web 2020 à essayer</a> </li><li>  <a href="https://habr.com/ru/post/485562/">Surfer sur Internet avec une manette de jeu (Javascript)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr486036/">https://habr.com/ru/post/fr486036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486024/index.html">Graphismes vraiment simples en R pour la science et le journalisme</a></li>
<li><a href="../fr486028/index.html">Réseaux de neurones dans la production de prothèses dentaires</a></li>
<li><a href="../fr486030/index.html">TL-SREET 55 5K LED Light Street Review</a></li>
<li><a href="../fr486032/index.html">Comment devenir concepteur de dialogues</a></li>
<li><a href="../fr486034/index.html">Accès rapide à la gestion des produits via Open source</a></li>
<li><a href="../fr486042/index.html">Messagers et législation télécom</a></li>
<li><a href="../fr486046/index.html">Noyau Linux inclus WireGuard VPN</a></li>
<li><a href="../fr486048/index.html">Qu'est-ce que «cela» et que mange-t-il</a></li>
<li><a href="../fr486050/index.html">Bibliothèque JavaScript Webix vue par un débutant. Partie 3. Modules, diagrammes, tables arborescentes</a></li>
<li><a href="../fr486052/index.html">Scorched Earth est la mère de tous les jeux. Entretien avec le créateur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>