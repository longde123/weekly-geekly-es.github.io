<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèø üôå üçπ Implementierung der Sofort-Suche in Android mit RxJava üÉè üåó üò®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich arbeite an einer neuen Anwendung, die wie √ºblich mit dem Backend-Dienst kommuniziert, um Daten √ºber die API zu empfangen. In diesem Beispiel werde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung der Sofort-Suche in Android mit RxJava</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430394/"><p><img src="https://habrastorage.org/getpro/habr/post_images/055/9a9/4b7/0559a94b7ce49b504f8daf58be3f1a06.jpg" alt="Implementierung der Sofort-Suche in Android mit RxJava"></p><br><p>  Ich arbeite an einer neuen Anwendung, die wie √ºblich mit dem Backend-Dienst kommuniziert, um Daten √ºber die API zu empfangen.  In diesem Beispiel werde ich eine Suchfunktion entwickeln, deren eine Funktion die sofortige Suche direkt bei der Texteingabe ist. </p><a name="habracut"></a><br><h2 id="mgnovennyy-poisk">  Sofortige Suche </h2><br><p> Nichts kompliziertes, denkst du?  Sie m√ºssen nur die <code>onTextChange</code> auf der Seite platzieren (h√∂chstwahrscheinlich in der Symbolleiste), den Ereignishandler <code>onTextChange</code> verbinden und die Suche durchf√ºhren.  Also hier ist was ich getan habe: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateOptionsMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(menu: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Menu</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { menuInflater.inflate(R.menu.menu_main, menu) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> searchView = menu?.findItem(R.id.action_search)?.actionView <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SearchView <span class="hljs-comment"><span class="hljs-comment">// Set up the query listener that executes the search searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener { override fun onQueryTextSubmit(query: String?): Boolean { Log.d(TAG, "onQueryTextSubmit: $query") return false } override fun onQueryTextChange(newText: String?): Boolean { Log.d(TAG, "onQueryTextChange: $newText") return false } }) return super.onCreateOptionsMenu(menu) }</span></span></code> </pre> <br><p>  Aber hier ist das Problem.  Da ich w√§hrend der Eingabe eine Suche implementieren muss, <code>onQueryTextChange()</code> ich mich bei jedem <code>onQueryTextChange()</code> eines <code>onQueryTextChange()</code> an die API, um die ersten Ergebnisse zu erhalten.  Die Protokolle lauten wie folgt: </p><br><pre> <code class="xml hljs">D/MainActivity: onQueryTextChange: T D/MainActivity: onQueryTextChange: TE D/MainActivity: onQueryTextChange: TES D/MainActivity: onQueryTextChange: TEST D/MainActivity: onQueryTextSubmit: TEST</code> </pre> <br><p>  Trotz der Tatsache, dass ich nur meine Anfrage drucke, gibt es f√ºnf API-Aufrufe, von denen jeder eine Suche durchf√ºhrt.  In der Cloud m√ºssen Sie beispielsweise f√ºr jeden Aufruf der API bezahlen.  Wenn ich meine Anfrage eingebe, brauche ich daher eine kleine Verz√∂gerung, bevor ich sie sende, damit am Ende nur ein API-Aufruf erfolgt. </p><br><p>  Angenommen, ich m√∂chte etwas anderes finden.  Ich l√∂sche TEST und gebe andere Zeichen ein: </p><br><pre> <code class="xml hljs">D/MainActivity: onQueryTextChange: TES D/MainActivity: onQueryTextChange: TE D/MainActivity: onQueryTextChange: T D/MainActivity: onQueryTextChange: D/MainActivity: onQueryTextChange: S D/MainActivity: onQueryTextChange: SO D/MainActivity: onQueryTextChange: SOM D/MainActivity: onQueryTextChange: SOME D/MainActivity: onQueryTextChange: SOMET D/MainActivity: onQueryTextChange: SOMETH D/MainActivity: onQueryTextChange: SOMETHI D/MainActivity: onQueryTextChange: SOMETHIN D/MainActivity: onQueryTextChange: SOMETHING D/MainActivity: onQueryTextChange: SOMETHING D/MainActivity: onQueryTextChange: SOMETHING E D/MainActivity: onQueryTextChange: SOMETHING EL D/MainActivity: onQueryTextChange: SOMETHING ELS D/MainActivity: onQueryTextChange: SOMETHING ELSE D/MainActivity: onQueryTextChange: SOMETHING ELSE D/MainActivity: onQueryTextSubmit: SOMETHING ELSE</code> </pre> <br><p>  Es gibt 20 API-Aufrufe!  Eine kleine Verz√∂gerung verringert die Anzahl dieser Anrufe.  Ich m√∂chte auch Duplikate entfernen, damit der zugeschnittene Text nicht zu wiederholten Anfragen f√ºhrt.  Ich m√∂chte wahrscheinlich auch einige Elemente herausfiltern.  Ben√∂tigen Sie beispielsweise die F√§higkeit, ohne die eingegebenen Zeichen zu suchen oder nach einem Zeichen zu suchen? </p><br><h2 id="reaktivnoe-programmirovanie">  Reaktive Programmierung </h2><br><p>  Es gibt verschiedene M√∂glichkeiten, was als n√§chstes zu tun ist, aber im Moment m√∂chte ich mich auf eine Technik konzentrieren, die allgemein als reaktive Programmierung und die RxJava-Bibliothek bekannt ist.  Als ich zum ersten Mal auf reaktive Programmierung stie√ü, sah ich die folgende Beschreibung: </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReactiveX</a> ist eine API, die mit asynchronen Strukturen arbeitet und Datenstr√∂me oder Ereignisse mithilfe von Kombinationen aus Observer- und Iterator-Mustern sowie funktionalen Programmierfunktionen bearbeitet. </blockquote><p>  Diese Definition erkl√§rt die Natur und die St√§rken von ReactiveX nicht vollst√§ndig.  Und wenn es erkl√§rt, dann nur f√ºr diejenigen, die bereits mit den Prinzipien dieses Rahmens vertraut sind.  Ich habe auch solche Diagramme gesehen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7e6/97b/6af/7e697b6af3434e70fd3e72ef3fcf5764.jpg" alt="Verz√∂gerungsoperatortabelle"></p><br><p>  Das Diagramm erkl√§rt die Rolle des Bedieners, versteht jedoch das Wesentliche nicht vollst√§ndig.  Lassen Sie uns also sehen, ob ich dieses Diagramm anhand eines einfachen Beispiels klarer erkl√§ren kann. </p><br><p>  Lassen Sie uns zuerst unser Projekt vorbereiten.  Sie ben√∂tigen eine neue Bibliothek in der Datei <code>build.gradle</code> Ihrer Anwendung: </p><br><pre> <code class="plaintext hljs">implementation "io.reactivex.rxjava2:rxjava:2.1.14"</code> </pre> <br><p>  Denken Sie daran, die Projektabh√§ngigkeiten zu synchronisieren, um die Bibliothek zu laden. </p><br><p>  Schauen wir uns nun eine neue L√∂sung an.  Mit der alten Methode habe ich auf die API zugegriffen, als ich jedes neue Zeichen eingegeben habe.  Mit der neuen Methode werde ich ein <code>Observable</code> erstellen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateOptionsMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(menu: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Menu</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { menuInflater.inflate(R.menu.menu_main, menu) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> searchView = menu?.findItem(R.id.action_search)?.actionView <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SearchView <span class="hljs-comment"><span class="hljs-comment">// Set up the query listener that executes the search Observable.create(ObservableOnSubscribe&lt;String&gt; { subscriber -&gt; searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener { override fun onQueryTextChange(newText: String?): Boolean { subscriber.onNext(newText!!) return false } override fun onQueryTextSubmit(query: String?): Boolean { subscriber.onNext(query!!) return false } }) }) .subscribe { text -&gt; Log.d(TAG, "subscriber: $text") } return super.onCreateOptionsMenu(menu) }</span></span></code> </pre> <br><p>  Dieser Code macht genau das Gleiche wie der alte Code.  Die Protokolle lauten wie folgt: </p><br><pre> <code class="xml hljs">D/MainActivity: subscriber: T D/MainActivity: subscriber: TE D/MainActivity: subscriber: TES D/MainActivity: subscriber: TEST D/MainActivity: subscriber: TEST</code> </pre> <br><p>  Der Hauptunterschied zwischen der Verwendung der neuen Technik ist jedoch das Vorhandensein eines reaktiven Stroms - beobachtbar.  Der Texthandler (oder in diesem Fall der Anforderungshandler) sendet die Elemente mit der Methode <code>onNext()</code> an den Stream.  Und <code>Observable</code> hat Abonnenten, die diese Elemente verarbeiten. </p><br><p>  Wir k√∂nnen vor dem Abonnieren eine Methodenkette erstellen, um die Liste der zu verarbeitenden Zeichenfolgen zu reduzieren.  Zun√§chst wird der gesendete Text immer in Kleinbuchstaben geschrieben und am Anfang und Ende der Zeile stehen keine Leerzeichen: </p><br><pre> <code class="kotlin hljs">Observable.create(ObservableOnSubscribe&lt;String&gt; { ... }) .map { text -&gt; text.toLowerCase().trim() } .subscribe { text -&gt; Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"subscriber: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$text</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  Ich schneide Methoden, um den wichtigsten Teil zu zeigen.  Jetzt sind die gleichen Protokolle wie folgt: </p><br><pre> <code class="xml hljs">D/MainActivity: subscriber: t D/MainActivity: subscriber: te D/MainActivity: subscriber: tes D/MainActivity: subscriber: test D/MainActivity: subscriber: test</code> </pre> <br><p>  Wenden wir nun eine Verz√∂gerung von 250 ms an und erwarten mehr Inhalt: </p><br><pre> <code class="kotlin hljs">Observable.create(ObservableOnSubscribe&lt;String&gt; { ... }) .map { text -&gt; text.toLowerCase().trim() } .debounce(<span class="hljs-number"><span class="hljs-number">250</span></span>, TimeUnit.MILLISECONDS) .subscribe { text -&gt; Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"subscriber: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$text</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  L√∂schen Sie abschlie√üend den doppelten Stream, sodass nur die erste eindeutige Anforderung verarbeitet wird.  Nachfolgende identische Anforderungen werden ignoriert: </p><br><pre> <code class="kotlin hljs">Observable.create(ObservableOnSubscribe&lt;String&gt; { ... }) .map { text -&gt; text.toLowerCase().trim() } .debounce(<span class="hljs-number"><span class="hljs-number">100</span></span>, TimeUnit.MILLISECONDS) .distinct() .subscribe { text -&gt; Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"subscriber: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$text</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><blockquote>  <strong>Hinweis</strong>  <strong>perev.</strong>  In diesem Fall ist es sinnvoller, den Operator <code>distinctUntilChanged()</code> , da sonst bei wiederholter Suche nach einer Zeichenfolge die Abfrage einfach ignoriert wird.  Und wenn Sie eine solche Suche implementieren, ist es sinnvoll, nur auf die letzte erfolgreiche Anforderung zu achten und die neue zu ignorieren, wenn sie mit der vorherigen identisch ist. </blockquote><p>  Am Ende filtern wir leere Abfragen heraus: </p><br><pre> <code class="kotlin hljs">Observable.create(ObservableOnSubscribe&lt;String&gt; { ... }) .map { text -&gt; text.toLowerCase().trim() } .debounce(<span class="hljs-number"><span class="hljs-number">100</span></span>, TimeUnit.MILLISECONDS) .distinct() .filter { text -&gt; text.isNotBlank() } .subscribe { text -&gt; Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"subscriber: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$text</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  An diesem Punkt werden Sie feststellen, dass nur eine (oder m√∂glicherweise zwei) Nachricht in den Protokollen angezeigt wird, was auf weniger API-Aufrufe hinweist.  In diesem Fall funktioniert die Anwendung weiterhin ordnungsgem√§√ü.  Dar√ºber hinaus f√ºhren F√§lle, in denen Sie etwas eingeben, dann aber l√∂schen und erneut eingeben, zu weniger Aufrufen der API. </p><br><p>  Abh√§ngig von Ihren Zielen k√∂nnen Sie dieser Pipeline viele weitere verschiedene Operatoren hinzuf√ºgen.  Ich glaube, dass sie sehr n√ºtzlich f√ºr die Arbeit mit Eingabefeldern sind, die mit der API interagieren.  Der vollst√§ndige Code lautet wie folgt: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Set up the query listener that executes the search Observable.create(ObservableOnSubscribe&lt;String&gt; { subscriber -&gt; searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener { override fun onQueryTextChange(newText: String?): Boolean { subscriber.onNext(newText!!) return false } override fun onQueryTextSubmit(query: String?): Boolean { subscriber.onNext(query!!) return false } }) }) .map { text -&gt; text.toLowerCase().trim() } .debounce(250, TimeUnit.MILLISECONDS) .distinct() .filter { text -&gt; text.isNotBlank() } .subscribe { text -&gt; Log.d(TAG, "subscriber: $text") }</span></span></code> </pre> <br><p>  Jetzt kann ich die Protokollnachricht durch einen Aufruf des ViewModel ersetzen, um einen API-Aufruf zu initiieren.  Dies ist jedoch ein Thema f√ºr einen anderen Artikel. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Mit dieser einfachen Technik zum Umschlie√üen von Textelementen in <code>Observable</code> und mit RxJava k√∂nnen Sie die Anzahl der API-Aufrufe reduzieren, die zum Ausf√ºhren von Serveroperationen erforderlich sind, und die Reaktionsf√§higkeit Ihrer Anwendung verbessern.  In diesem Artikel haben wir nur einen kleinen Teil der gesamten Welt von RxJava behandelt. Daher hinterlasse ich Ihnen Links f√ºr weitere Informationen zu diesem Thema: </p><br><ul><li>  Dan Lew <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grokking RxJava</a> (dies ist die Seite, die mir geholfen hat, mich in die richtige Richtung zu bewegen). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReactiveX-Site</a> (Ich beziehe mich beim Erstellen einer Pipeline h√§ufig auf diese Site). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430394/">https://habr.com/ru/post/de430394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430382/index.html">JavaScript-Handbuch Teil 4: Funktionen</a></li>
<li><a href="../de430384/index.html">Erstellen von Karten aus Rauschfunktionen</a></li>
<li><a href="../de430386/index.html">Festk√∂rperspeicherkraftwerk in Indien gebaut werden</a></li>
<li><a href="../de430388/index.html">Web Summit Unconference</a></li>
<li><a href="../de430392/index.html">Wie ich APIs mit meinem PieceofScript-Fahrrad entwickle und teste</a></li>
<li><a href="../de430396/index.html">Kettenreplikation: Aufbau eines effektiven KV-Repositorys (Teil 1/2)</a></li>
<li><a href="../de430398/index.html">Wie Sie verstehen, dass Sie nicht willkommen sind oder Methoden diskutieren, um Mitarbeiter aus dem Unternehmen zu verdr√§ngen</a></li>
<li><a href="../de430400/index.html">Erfahrung mit einem Tastatur-Maus-Hybrid in der Programmierung</a></li>
<li><a href="../de430402/index.html">Was sagt developer.android.com √ºber RecyclerView?</a></li>
<li><a href="../de430404/index.html">Wir sammeln Daten zum Kundenverhalten auf der Website</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>