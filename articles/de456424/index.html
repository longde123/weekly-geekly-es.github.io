<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶ üå≠ üõ†Ô∏è Utreexo: viel UTXO Bitcoin komprimieren üë©üèæ‚Äçüíº üåó ü§º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 


 Im Bitcoin-Netzwerk sind sich alle Knoten einig √ºber die vielen UTXOs: Wie viele M√ºnzen stehen f√ºr wen und unter welchen Bedingungen z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utreexo: viel UTXO Bitcoin komprimieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456424/"><p><img src="https://habrastorage.org/webt/5_/dt/be/5_dtbegl1errsyauglpuftz1xus.png"></p><br><p>  Hallo Habr! </p><br><p>  Im Bitcoin-Netzwerk sind sich alle Knoten einig √ºber die vielen UTXOs: Wie viele M√ºnzen stehen f√ºr wen und unter welchen Bedingungen zur Verf√ºgung?  Der Satz von UTXOs ist der Mindestdatensatz, der f√ºr einen Validierungsknoten erforderlich ist, ohne den der Knoten die G√ºltigkeit eingehender Transaktionen und der sie enthaltenden Bl√∂cke nicht √ºberpr√ºfen kann. </p><br><p>  In dieser Hinsicht wird in jeder Hinsicht versucht, die gespeicherte Darstellung dieses Satzes zu reduzieren und ohne Verlust von Sicherheitsgarantien zu komprimieren.  Je kleiner das gespeicherte Datenvolumen ist, desto geringer sind die Anforderungen an den Speicherplatz des Validierungsknotens, wodurch das Starten des Validatorknotens kosteng√ºnstig wird. Dadurch k√∂nnen Sie das Netzwerk erweitern und dadurch die Netzwerkstabilit√§t erh√∂hen. </p><br><p>  In diesem Hinweis werden wir den Rust-Prototyp eines aktuellen Vorschlags des Co-Autors von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightning Network Paper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Utreexo, behandeln: einen dynamischen Hash-basierten Akkumulator, der f√ºr das Bitcoin UTXO-Set optimiert</a> wurde und den Speicherplatzbedarf f√ºr Validatorknoten reduziert. </p><a name="habracut"></a><br><h2 id="v-chyom-problema">  Was ist das Problem? </h2><br><p>  Eines der ewigen Probleme von Bitcoin war seine Skalierbarkeit.  Die Idee, eine Bank zu besitzen, erfordert, dass die Netzwerkteilnehmer alle verf√ºgbaren Mittel zur Verwendung im Auge behalten.  In Bitcoin werden verf√ºgbare Mittel als eine Reihe nicht ausgegebener Ausgaben ausgedr√ºckt - UTXO-Menge.  Obwohl dies keine sehr intuitive Ansicht ist, ist sie im Hinblick auf die Implementierungsleistung vorteilhaft im Vergleich zu einer Ansicht, in der jede Brieftasche ein ‚ÄûGuthaben‚Äú als separaten Eintrag hat und au√üerdem Datenschutz bietet (z. B. bietet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoinJoin</a> Arbeit). </p><br><p>  Es ist wichtig, zwischen einem Transaktionsverlauf (einer sogenannten Blockchain) und dem aktuellen Status des Systems zu unterscheiden.  Die Transaktionshistorie von Bitcoin belegt derzeit etwa 200 GB Festplattenspeicher und w√§chst weiter.  Der Status des Systems ist jedoch viel kleiner, etwa 4 GB, und ber√ºcksichtigt nur die Tatsache, dass derzeit jemand M√ºnzen besitzt.  Das Volumen dieser Daten nimmt ebenfalls mit der Zeit zu, jedoch mit einer viel geringeren Rate und nimmt manchmal sogar tendenziell ab (siehe KDPV). </p><br><p>  Light Clients (SPVs) tauschen Sicherheitsgarantien f√ºr die F√§higkeit aus, keinen Mindeststatus (UTXO-Set) au√üer privaten Schl√ºsseln zu speichern. </p><br><h2 id="utxo-i-utxo-set">  UTXO und UTXO-Set </h2><br><p>  UTXO (Unspent Transaction Output) - Nicht ausgegebene Transaktionsausgabe, der Endpunkt der Reise jedes in Transaktionen √ºbertragenen Satoshi.  Nicht ausgegebene Ausgaben werden zu Eingaben f√ºr neue Transaktionen und werden gleichzeitig ausgegeben und aus dem UTXO-Set entfernt. </p><br><p>  Neue UTXOs werden immer durch Transaktionen erstellt: </p><br><ul><li>  Coinbase-Transaktionen ohne Eingaben: Erstellen Sie neue UTXOs w√§hrend der Ausgabe von M√ºnzen durch Bergleute </li><li>  Konventionelle Transaktionen: Erstellen Sie neue UTXOs, w√§hrend Sie einige vorhandene UTXOs ausgeben </li></ul><br><p>  Der Prozess der Arbeit mit UTXO: <br><img src="https://habrastorage.org/webt/rw/ey/fh/rweyfhzcoy-cgcigbrlfv0qbypi.gif"></p><br><p>  Brieftaschen ber√ºcksichtigen die Anzahl der f√ºr Ausgaben verf√ºgbaren M√ºnzen (Saldo) basierend auf der Menge an UTXO, die f√ºr diese Brieftasche f√ºr Ausgaben verf√ºgbar ist. </p><br><p>  Jeder Validierungsknoten muss die Erfassung <strong>aller</strong> UTXOs w√§hrend der √úberpr√ºfung <strong>jeder</strong> Transaktion <strong>jedes</strong> Blocks verfolgen, um doppelte Ausgabenversuche zu verhindern. </p><br><p>  Der Knoten muss logisch sein: </p><br><ul><li>  Erg√§nzungen zum UTXO-Set </li><li>  UTXO-Set-L√∂schungen </li><li>  √úberpr√ºft, ob ein einzelnes UTXO im Set vorhanden ist </li></ul><br><p>  Es gibt M√∂glichkeiten, die Anforderungen an gespeicherte Informationen √ºber das Set zu reduzieren und gleichzeitig die M√∂glichkeit beizubehalten, Elemente hinzuzuf√ºgen und zu entfernen sowie die Existenz eines Elements im Set mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kryptografischer Batterien zu</a> √ºberpr√ºfen und nachzuweisen. </p><br><h2 id="akkumulyatory-dlya-utxo">  Batterien f√ºr UTXO </h2><br><p>  Die Idee, Batterien zum Speichern vieler UTXOs zu verwenden, wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">er√∂rtert</a> . </p><br><p>  UTXO-set wird im laufenden Betrieb erstellt, w√§hrend das anf√§ngliche Laden der Blockkette (IBD, anf√§nglicher Blockdownload) vollst√§ndig und konstant gespeichert wird, w√§hrend sich sein Inhalt nach der Verarbeitung von Transaktionen aus jedem neuen und korrekten Netzwerkblock √§ndert.  F√ºr diesen Vorgang m√ºssen ca. 200 GB Datenbl√∂cke heruntergeladen und Hunderte Millionen digitaler Signaturen √ºberpr√ºft werden.  Nach Abschluss des IBD-Prozesses nimmt das UTXO-Set im trockenen R√ºckstand ca. 4 GB ein. </p><br><p>  Bei der Verwendung von Batterien besteht die Konsensregel in Bezug auf Fonds jedoch darin, kryptografische Beweise zu √ºberpr√ºfen und zu generieren, und die Last der Verfolgung verf√ºgbarer Fonds liegt auf den Schultern des Eigent√ºmers dieser Fonds, was den Nachweis ihrer Anwesenheit und ihres Eigentums erbringt. </p><br><p>  Die Batterie kann als kompakte Darstellung des Sets bezeichnet werden.  Die Gr√∂√üe der gespeicherten Ansicht muss in diesem Fall entweder konstant sein <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.66ex" viewBox="0 -832 2043 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-31" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-29" x="1653" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (1) </script>  oder beispielsweise sublinear relativ zur Potenz der Menge und Gr√∂√üe des Elements selbst erh√∂hen <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.724ex" height="2.66ex" viewBox="0 -832 4186.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6C" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6F" x="1451" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-67" x="1937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-28" x="2417" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6E" x="2807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-29" x="3407" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-29" x="3797" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2"> O (log (n)) </script>  Dabei ist n die Potenz der gespeicherten Menge. </p><br><p>  In diesem Fall sollte der Akkumulator die Erstellung von Nachweisen f√ºr die Aufnahme eines Elements in die Menge (Einschlussnachweis) erm√∂glichen und es ihm erm√∂glichen, diesen Nachweis effektiv zu √ºberpr√ºfen. </p><br><p>  Eine Batterie wird als <strong>dynamisch bezeichnet,</strong> wenn Sie damit Elemente hinzuf√ºgen und Elemente aus dem Set entfernen k√∂nnen. </p><br><p>  Ein Beispiel f√ºr eine solche Batterie ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Boneh, Bunz, Fisch im Dezember 2018 vorgeschlagene RSA-Batterie</a> .  Eine solche Batterie hat eine konstante Gr√∂√üe der gespeicherten Ansicht, erfordert jedoch ein <em>gemeinsames Geheimnis</em> (vertrauensw√ºrdiges Setup).  Diese Anforderung negiert die Anwendbarkeit eines solchen Akkumulators f√ºr vertrauensw√ºrdige Netzwerke wie Bitcoin, da Datenlecks w√§hrend der Generierung eines Geheimnisses es Angreifern erm√∂glichen k√∂nnen, gef√§lschte Beweise f√ºr die Existenz von UTXO zu erstellen, indem sie Knoten mit einem UTXO-Satz f√§lschen, der auf einem solchen Akkumulator basiert. </p><br><h3 id="utreexo">  Utreexo </h3><br><p>  Mit dem von Utreexo vorgeschlagenen Thaddeus Dryja-Design k√∂nnen Sie eine <strong>dynamische</strong> Batterie <strong>ohne</strong> vertrauensw√ºrdige Einrichtung erstellen. </p><br><p>  Utreexo ist ein Wald idealer bin√§rer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkle-B√§ume</a> und eine Weiterentwicklung der Ideen, die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effiziente asynchrone Akkumulatoren f√ºr verteilte pki vorgestellt werden</a> , und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bietet</a> die M√∂glichkeit, Elemente aus der Menge zu entfernen. </p><br><h4 id="logicheskaya-struktura-akkumulyatora">  Die logische Struktur der Batterie </h4><br><p>  Batteriezellen sind in einem Wald perfekter Bin√§rb√§ume angeordnet.  B√§ume sind nach H√∂he geordnet.  Diese Pr√§sentation wurde als die visuellste ausgew√§hlt und erm√∂glicht es Ihnen, das Zusammenf√ºhren von B√§umen w√§hrend des Betriebs mit der Batterie zu visualisieren. </p><br><p>  Der Autor stellt fest, dass, da alle B√§ume im Wald perfekt sind, ihre H√∂he durch die Zweierpotenz ausgedr√ºckt wird, genau wie jede nat√ºrliche Zahl als Summe der Zweierpotenzen dargestellt werden kann.  Dementsprechend kann jeder Satz von Bl√§ttern in Form von Bin√§rb√§umen gruppiert werden, und in allen F√§llen erfordert das Hinzuf√ºgen eines neuen Elements nur Kenntnisse <em>√ºber die Wurzelknoten der gespeicherten B√§ume</em> . </p><br><p>  Die gespeicherte Ansicht der Utreexo-Batterie ist also eine Liste von Wurzelknoten (Merkle-Wurzel) <em>und nicht der gesamte Wald von B√§umen</em> . </p><br><p> Stellen Sie sich die Liste der Stammelemente als <code>Vec&lt;Option&lt;Hash&gt;&gt;</code> .  Der optionale <code>Option&lt;Hash&gt;</code> weist darauf hin, dass das Stammelement m√∂glicherweise fehlt. Dies bedeutet, dass der Baum keinen Baum mit einer angemessenen H√∂he hat. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// SHA-256  #[derive(Copy, Clone, Hash, Eq, PartialEq)] pub struct Hash(pub [u8; 32]); #[derive(Debug, Clone)] pub struct Utreexo { pub roots: Vec&lt;Option&lt;Hash&gt;&gt;, } impl Utreexo { pub fn new(capacity: usize) -&gt; Self { Utreexo { roots: vec![None; capacity], } } }</span></span></code> </pre> <br><h4 id="dobavlenie-elementov">  Elemente hinzuf√ºgen </h4><br><p>  Zun√§chst beschreiben wir die Funktion <code>parent()</code> , die den √ºbergeordneten Knoten f√ºr zwei bestimmte Elemente erkennt. </p><br><div class="spoiler">  <b class="spoiler_title">Parent () -Funktion</b> <div class="spoiler_text"><p>  Da wir Merkle-B√§ume verwenden, ist das √ºbergeordnete Element jedes der beiden Knoten ein Knoten, der den Verkettungs-Hash der Hashes der untergeordneten Knoten speichert: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span></span>(bytes: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sha = Sha256::new(); sha.input(bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = sha.result(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res_bytes = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]; res_bytes.copy_from_slice(res.as_slice()); Hash(res_bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>(left: &amp;Hash, right: &amp;Hash) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> concat = left .<span class="hljs-number"><span class="hljs-number">0</span></span> .into_iter() .chain(right.<span class="hljs-number"><span class="hljs-number">0</span></span>.into_iter()) .map(|b| *b) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;&gt;(); hash(&amp;concat[..]) }</code> </pre> <br><p>  Der Autor stellt fest, dass zur Verhinderung der von Charles Bouillaguet, Pierre-Alain Fouque, Adi Shamir und Sebastien Zimmer in <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweite Preimage-Angriffe auf Dithering-Hash-Funktionen</a> Zus√§tzlich zu zwei Hashes sollten Sie der Verkettung die H√∂he innerhalb des Baums hinzuf√ºgen. </p></div></div><br><p>  Wenn Sie der Batterie Elemente hinzuf√ºgen, m√ºssen Sie nachverfolgen, welche Stammelemente ge√§ndert werden.  Wenn Sie dem Pfad zum √Ñndern der Stammelemente f√ºr jedes hinzugef√ºgte Element folgen, k√∂nnen Sie sp√§ter einen Beweis f√ºr das Vorhandensein dieser Elemente erstellen. </p><br><div class="spoiler">  <b class="spoiler_title">Verfolgen Sie √Ñnderungen w√§hrend des Uploads</b> <div class="spoiler_text"><p>  Um die vorgenommenen √Ñnderungen zu verfolgen, deklarieren wir die <code>Update</code> Struktur, in der Daten zu √Ñnderungen an Knoten gespeichert werden. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> utreexo: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Utreexo, <span class="hljs-comment"><span class="hljs-comment">// ProofStep  ""     pub updated: HashMap&lt;Hash, ProofStep&gt;, }</span></span></code> </pre> </div></div><br><p>  Um der Batterie ein Element hinzuzuf√ºgen, ben√∂tigen Sie: </p><br><ul><li>  Erstellen Sie ein Array von K√∂rben mit <code>new_roots</code> und platzieren Sie die vorhandenen <code>new_roots</code> dort, eines f√ºr jeden Korb: </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> new_roots = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::&lt;Hash&gt;::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hash) = root { vec.push(*hash); } new_roots.push(vec); }</code> </pre> </div></div><br><ul><li>  F√ºgen Sie die hinzugef√ºgten Elemente ( <code>insertions</code> ) zum ersten Warenkorb hinzu <code>new_roots[0]</code> : </li></ul><br><p><img src="https://habrastorage.org/webt/8f/ne/jg/8fnejgnqbngrgygwreduomorpni.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs">new_roots[<span class="hljs-number"><span class="hljs-number">0</span></span>].extend_from_slice(insertions);</code> </pre> </div></div><br><ul><li>  F√ºhren Sie das "Zusammenf√ºhren" von Artikeln durch, die dem ersten Warenkorb hinzugef√ºgt wurden, mit dem Rest: <br><ul><li>  F√ºr alle K√∂rbe mit mehr als einem Artikel: <br><ol><li>  Wir nehmen zwei Elemente vom Ende des Warenkorbs, berechnen ihre √ºbergeordneten Elemente und l√∂schen beide Elemente </li><li>  F√ºgen Sie das berechnete √ºbergeordnete Element zum n√§chsten Warenkorb hinzu. </li></ol></li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/df/dl/fm/dfdlfm0iw0tvwxtlomxmrml1ijc.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> new_roots[i].len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         let a = new_roots[i][new_roots[i].len() - 2]; let b = new_roots[i][new_roots[i].len() - 1]; new_roots[i].pop(); new_roots[i].pop(); let hash = self.parent(&amp;a, &amp;b); //      if new_roots.len() &lt;= i + 1 { new_roots.push(vec![]); } //      new_roots[i + 1].push(hash); //    ; //        updated.insert(a, ProofStep { hash: b, is_left: false }); updated.insert(b, ProofStep {hash: a, is_left: true }); } }</span></span></code> </pre> </div></div><br><ul><li>  Verschieben Sie Wurzelelemente aus K√∂rben in das resultierende Batteriearray </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, bucket) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_roots.into_iter().enumerate() { <span class="hljs-comment"><span class="hljs-comment">//     if self.roots.len() &lt;= i { self.roots.push(None); } if bucket.is_empty() { self.roots[i] = None; } else { self.roots[i] = Some(bucket[0]); } }</span></span></code> </pre> </div></div><br><h4 id="sozdanie-dokazatelstva-dlya-dobavlennyh-elementov">  Erstellen von Beweisen f√ºr hinzugef√ºgte Elemente </h4><br><p>  Der Nachweis der Aufnahme des Elements in die Batterie ( <code>Proof</code> ) dient als Pfad von Merkle (Merkle Path), der aus einer Kette von <code>ProofStep</code> .  Wenn der Weg nirgendwohin f√ºhrt, ist der Beweis falsch. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///         . #[derive(Debug, Copy, Clone)] pub struct ProofStep { pub hash: Hash, pub is_left: bool, } ///   .       . #[derive(Debug, Clone)] pub struct Proof { pub steps: Vec&lt;ProofStep&gt;, pub leaf: Hash, }</span></span></code> </pre> <br><p>  Mithilfe der Informationen, die Sie zuvor beim Hinzuf√ºgen des Elements erhalten haben (Struktur <code>Update</code> ), k√∂nnen Sie den Nachweis erbringen, dass das Element zur Batterie hinzugef√ºgt wurde.  Dazu gehen wir die Tabelle der vorgenommenen √Ñnderungen durch und f√ºgen jeden Schritt dem Pfad von Merkle hinzu, der anschlie√üend als Beweis dienen wird: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Update&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prove</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, leaf: &amp;Hash) -&gt; Proof { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> proof = Proof { steps: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], leaf: *leaf, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> item = *leaf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updated.get(&amp;item) { proof.steps.push(*s); item = parent(&amp;item, &amp;s); } proof } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Beweisprozess</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8i/2h/gy/8i2hgyqkn8syqa0wdsybg3o9asm.gif"></p></div></div><br><h4 id="proverka-dokazatelstva-dlya-elementa">  Beweis f√ºr einen Gegenstand </h4><br><p>  Das √úberpr√ºfen des Beweises f√ºr die Aufnahme eines Elements (Einschlussbeweis) reduziert sich darauf, dem Pfad von Merkle zu folgen, bis es zum vorhandenen Wurzelelement f√ºhrt: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = proof.steps.len(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expected) = expected { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> current_parent = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> proof.steps.iter() { current_parent = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.is_left { parent(&amp;s.hash, &amp;current_parent) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent(&amp;current_parent, &amp;s.hash) }; } current_parent == expected } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><p>  Klar: </p><br><div class="spoiler">  <b class="spoiler_title">Beweis√ºberpr√ºfungsprozess f√ºr A.</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sx/49/dz/sx49dzfpgnzqv-x6-hl1fxgey1a.gif"></p></div></div><br><h4 id="udalenie-elementov">  Elemente l√∂schen </h4><br><p>  Um ein Element aus der Batterie zu entfernen, m√ºssen Sie einen g√ºltigen Nachweis erbringen, dass das Element vorhanden ist.  Mit den Daten aus dem Proof k√∂nnen wir die neuen Wurzelelemente der Batterie berechnen, f√ºr die dieser Proof nicht mehr g√ºltig ist. </p><br><p>  Der Algorithmus ist wie folgt: </p><br><ol><li>  Wie bei der Hinzuf√ºgung organisieren wir eine Reihe leerer K√∂rbe, die Merkle-B√§umen entsprechen und deren H√∂he zwei des Korbindex entspricht </li><li>  Legen Sie Gegenst√§nde von den Stufen des Merkle-Pfades in die K√∂rbe.  Der Warenkorbindex entspricht der aktuellen Schrittnummer </li><li>  Wir entfernen das Wurzelelement, zu dem der Pfad vom Beweis f√ºhrt. </li><li>  Wie bei der Addition berechnen wir die neuen Wurzelelemente, kombinieren die Elemente aus den K√∂rben paarweise und verschieben das Ergebnis der Vereinigung in den n√§chsten Korb </li></ol><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof, new_roots: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Hash&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() &lt; proof.steps.len() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.get(proof.steps.len()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> height = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> hash = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt; new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (index, ok) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.find_root(&amp;hash, &amp;new_roots[height]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { <span class="hljs-comment"><span class="hljs-comment">// Remove hash from new_roots new_roots[height].remove(index); loop { if height &gt;= proof.steps.len() { if !self.roots[height] .and_then(|h| Some(h == hash)) .unwrap_or(false) { return Err(()); } return Ok(()); } s = proof.steps[height]; hash = self.parent(&amp;hash, &amp;s); height += 1; } } } if height &gt;= proof.steps.len() { return Err(()); } while height &gt; new_roots.len() { new_roots.push(vec![]); } s = proof.steps[height]; new_roots[height].push(s.hash); hash = self.parent(&amp;hash, &amp;s); height += 1; } }</span></span></code> </pre> </div></div><br><p>  Der Vorgang zum Entfernen von Element "A": <br><img src="https://habrastorage.org/webt/pi/uf/rb/piufrb9ivxabdm_45vbmohgm5os.gif"></p><br><h2 id="integraciya-v-suschestvuyuschuyu-set">  Integration in ein bestehendes Netzwerk </h2><br><p>  Mit der vorgeschlagenen Batterie k√∂nnen Knoten die Verwendung der Datenbank zum Speichern aller UTXO verweigern, w√§hrend die M√∂glichkeit erhalten bleibt, den UTXO-Satz zu √§ndern.  Es besteht jedoch das Problem, mit Beweisen zu arbeiten. </p><br><p>  Wir werden einen Validator-Knoten nennen, der den UTXO-Batteriekompakt (Compact-State-Knoten) verwendet, und einen Validator ohne Batterie - <em>voll</em> (Vollknoten).  Die Existenz von zwei Knotenklassen f√ºhrt zu dem Problem, sie in ein einziges Netzwerk zu integrieren, da kompakte Knoten den Nachweis der Existenz von UTXO erfordern, das f√ºr Transaktionen verwendet wird, vollst√§ndige Knoten jedoch nicht.  Wenn nicht alle Knoten des Netzwerks gleichzeitig und auf koordinierte Weise zu Utreexo wechseln, bleiben die kompakten Knoten zur√ºck und k√∂nnen nicht im Bitcoin-Netzwerk arbeiten. </p><br><p>  Um das Problem der Integration kompakter Knoten in das Netzwerk zu l√∂sen, wird vorgeschlagen, eine zus√§tzliche Klasse von Knoten einzuf√ºhren - <em>Br√ºcken</em> .  Ein Br√ºckenknoten ist ein vollst√§ndiger Knoten, der unter anderem die Utreexo-Batterie und Einschlussnachweise f√ºr <strong>alle</strong> UTXOs aus dem UTXO-Set speichert.  Bridges berechnen neue Hashes und aktualisieren die Batterie und Beweise, wenn neue Bl√∂cke mit Transaktionen eintreffen.  Die Unterst√ºtzung und Aktualisierung der Batterie und der Nachweise bedeutet f√ºr solche Knoten keine zus√§tzliche Rechenlast.  Bridges opfern Speicherplatz: Ordnung in Ordnung halten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="1.937ex" viewBox="0 -728.2 1101 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> 2n </script>  Hashes im Vergleich zu <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.141ex" height="2.66ex" viewBox="0 -832 2644 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-67" x="784" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-28" x="1264" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6E" x="1654" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-29" x="2254" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-4"> log (n) </script>  Hashes f√ºr kompakte Knoten, wobei n die Potenz der Menge UTXO ist. </p><br><h3 id="arhitektura-seti">  Netzwerkarchitektur </h3><br><p><img src="https://habrastorage.org/webt/fj/at/9t/fjat9tzhyxy_ncflmmzgt8ere_4.gif"></p><br><p>  Bridges erm√∂glichen das schrittweise Hinzuf√ºgen kompakter Knoten zum Netzwerk, ohne die Software vorhandener Knoten zu √§ndern.  Vollst√§ndige Knoten arbeiten wie zuvor und verteilen Transaktionen und Bl√∂cke untereinander.  Bridge-Knoten sind vollst√§ndige Knoten, die zus√§tzlich Utreexo-Batteriedaten und eine Reihe von Einschlussnachweisen f√ºr <strong>alle</strong> UTXOs speichern.  Der Br√ºckenknoten k√ºndigt sich nicht als solcher an und gibt vor, ein vollst√§ndiger Knoten f√ºr alle vollst√§ndigen Knoten und ein kompakter Knoten f√ºr alle kompakten Knoten zu sein.  Obwohl Bridges beide Netzwerke miteinander verbinden, m√ºssen sie in der Realit√§t nur in eine Richtung verbunden werden: von vorhandenen vollst√§ndigen Knoten zu kompakten Knoten.  Dies ist m√∂glich, da das Transaktionsformat nicht ge√§ndert werden muss und der Nachweis f√ºr UTXO f√ºr kompakte Knoten verworfen werden kann, sodass jeder kompakte Knoten Transaktionen auf die gleiche Weise an alle Netzwerkteilnehmer senden kann, ohne dass Br√ºckenknoten beteiligt sind. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Wir haben die Utreexo-Batterie √ºberpr√ºft und ihren Prototyp in Rust implementiert.  Wir haben die Netzwerkarchitektur untersucht, die die Knoten basierend auf der Batterie integriert.  Der Vorteil von Compact Catch ist die Gr√∂√üe der gespeicherten Daten, die logarithmisch von der Leistung vieler UTXOs abh√§ngt, wodurch der Speicherplatzbedarf und die Speicherleistung f√ºr solche Knoten erheblich reduziert werden.  Der Nachteil ist zus√§tzlicher Knotenverkehr f√ºr die Beweis√ºbertragung, aber Beweisaggregationstechniken (wenn ein Beweis das Vorhandensein mehrerer Elemente beweist) und Caching k√∂nnen dazu beitragen, den Verkehr innerhalb akzeptabler Grenzen zu halten. </p><br><p>  <strong>Referenzen</strong> : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Utreexo Rust Prototyp GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Utreexo: Ein dynamischer Hash-basierter Akkumulator, der f√ºr das Bitcoin UTXO-Set optimiert wurde</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animierte Grafik aus einem Artikel</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456424/">https://habr.com/ru/post/de456424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456412/index.html">Umstrittene Innovation von Yandex - Melden Sie sich per Brief in Ihrem Konto an</a></li>
<li><a href="../de456414/index.html">Schutz vor Feuer in Rechenzentren oder wie Daten gespeichert werden</a></li>
<li><a href="../de456416/index.html">Agil f√ºr alle B√ºcher</a></li>
<li><a href="../de456418/index.html">Eine kurze Geschichte des Betrugs von Videospielen</a></li>
<li><a href="../de456422/index.html">Ank√ºndigung einer neuen Version von Styled Components v5: Animal Grin</a></li>
<li><a href="../de456426/index.html">BASS - ein Framework f√ºr die automatische Synthese von Antivirensignaturen</a></li>
<li><a href="../de456428/index.html">Implementierung eines BI-Ansatzes zur Datenanalyse: praktische Empfehlungen</a></li>
<li><a href="../de456430/index.html">Das ewige Problem der technischen Verschuldung</a></li>
<li><a href="../de456432/index.html">Sicherheitswoche 25: Evernote-Sicherheitsl√ºcke und Hunderte von gehackten Online-Shops</a></li>
<li><a href="../de456434/index.html">Berufe der Zukunft: ‚ÄûMit wem werden Sie auf dem Mars arbeiten?‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>