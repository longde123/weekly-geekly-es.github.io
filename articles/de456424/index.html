<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦 🌭 🛠️ Utreexo: viel UTXO Bitcoin komprimieren 👩🏾‍💼 🌗 🤼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 


 Im Bitcoin-Netzwerk sind sich alle Knoten einig über die vielen UTXOs: Wie viele Münzen stehen für wen und unter welchen Bedingungen z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utreexo: viel UTXO Bitcoin komprimieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456424/"><p><img src="https://habrastorage.org/webt/5_/dt/be/5_dtbegl1errsyauglpuftz1xus.png"></p><br><p>  Hallo Habr! </p><br><p>  Im Bitcoin-Netzwerk sind sich alle Knoten einig über die vielen UTXOs: Wie viele Münzen stehen für wen und unter welchen Bedingungen zur Verfügung?  Der Satz von UTXOs ist der Mindestdatensatz, der für einen Validierungsknoten erforderlich ist, ohne den der Knoten die Gültigkeit eingehender Transaktionen und der sie enthaltenden Blöcke nicht überprüfen kann. </p><br><p>  In dieser Hinsicht wird in jeder Hinsicht versucht, die gespeicherte Darstellung dieses Satzes zu reduzieren und ohne Verlust von Sicherheitsgarantien zu komprimieren.  Je kleiner das gespeicherte Datenvolumen ist, desto geringer sind die Anforderungen an den Speicherplatz des Validierungsknotens, wodurch das Starten des Validatorknotens kostengünstig wird. Dadurch können Sie das Netzwerk erweitern und dadurch die Netzwerkstabilität erhöhen. </p><br><p>  In diesem Hinweis werden wir den Rust-Prototyp eines aktuellen Vorschlags des Co-Autors von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightning Network Paper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Utreexo, behandeln: einen dynamischen Hash-basierten Akkumulator, der für das Bitcoin UTXO-Set optimiert</a> wurde und den Speicherplatzbedarf für Validatorknoten reduziert. </p><a name="habracut"></a><br><h2 id="v-chyom-problema">  Was ist das Problem? </h2><br><p>  Eines der ewigen Probleme von Bitcoin war seine Skalierbarkeit.  Die Idee, eine Bank zu besitzen, erfordert, dass die Netzwerkteilnehmer alle verfügbaren Mittel zur Verwendung im Auge behalten.  In Bitcoin werden verfügbare Mittel als eine Reihe nicht ausgegebener Ausgaben ausgedrückt - UTXO-Menge.  Obwohl dies keine sehr intuitive Ansicht ist, ist sie im Hinblick auf die Implementierungsleistung vorteilhaft im Vergleich zu einer Ansicht, in der jede Brieftasche ein „Guthaben“ als separaten Eintrag hat und außerdem Datenschutz bietet (z. B. bietet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoinJoin</a> Arbeit). </p><br><p>  Es ist wichtig, zwischen einem Transaktionsverlauf (einer sogenannten Blockchain) und dem aktuellen Status des Systems zu unterscheiden.  Die Transaktionshistorie von Bitcoin belegt derzeit etwa 200 GB Festplattenspeicher und wächst weiter.  Der Status des Systems ist jedoch viel kleiner, etwa 4 GB, und berücksichtigt nur die Tatsache, dass derzeit jemand Münzen besitzt.  Das Volumen dieser Daten nimmt ebenfalls mit der Zeit zu, jedoch mit einer viel geringeren Rate und nimmt manchmal sogar tendenziell ab (siehe KDPV). </p><br><p>  Light Clients (SPVs) tauschen Sicherheitsgarantien für die Fähigkeit aus, keinen Mindeststatus (UTXO-Set) außer privaten Schlüsseln zu speichern. </p><br><h2 id="utxo-i-utxo-set">  UTXO und UTXO-Set </h2><br><p>  UTXO (Unspent Transaction Output) - Nicht ausgegebene Transaktionsausgabe, der Endpunkt der Reise jedes in Transaktionen übertragenen Satoshi.  Nicht ausgegebene Ausgaben werden zu Eingaben für neue Transaktionen und werden gleichzeitig ausgegeben und aus dem UTXO-Set entfernt. </p><br><p>  Neue UTXOs werden immer durch Transaktionen erstellt: </p><br><ul><li>  Coinbase-Transaktionen ohne Eingaben: Erstellen Sie neue UTXOs während der Ausgabe von Münzen durch Bergleute </li><li>  Konventionelle Transaktionen: Erstellen Sie neue UTXOs, während Sie einige vorhandene UTXOs ausgeben </li></ul><br><p>  Der Prozess der Arbeit mit UTXO: <br><img src="https://habrastorage.org/webt/rw/ey/fh/rweyfhzcoy-cgcigbrlfv0qbypi.gif"></p><br><p>  Brieftaschen berücksichtigen die Anzahl der für Ausgaben verfügbaren Münzen (Saldo) basierend auf der Menge an UTXO, die für diese Brieftasche für Ausgaben verfügbar ist. </p><br><p>  Jeder Validierungsknoten muss die Erfassung <strong>aller</strong> UTXOs während der Überprüfung <strong>jeder</strong> Transaktion <strong>jedes</strong> Blocks verfolgen, um doppelte Ausgabenversuche zu verhindern. </p><br><p>  Der Knoten muss logisch sein: </p><br><ul><li>  Ergänzungen zum UTXO-Set </li><li>  UTXO-Set-Löschungen </li><li>  Überprüft, ob ein einzelnes UTXO im Set vorhanden ist </li></ul><br><p>  Es gibt Möglichkeiten, die Anforderungen an gespeicherte Informationen über das Set zu reduzieren und gleichzeitig die Möglichkeit beizubehalten, Elemente hinzuzufügen und zu entfernen sowie die Existenz eines Elements im Set mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kryptografischer Batterien zu</a> überprüfen und nachzuweisen. </p><br><h2 id="akkumulyatory-dlya-utxo">  Batterien für UTXO </h2><br><p>  Die Idee, Batterien zum Speichern vieler UTXOs zu verwenden, wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erörtert</a> . </p><br><p>  UTXO-set wird im laufenden Betrieb erstellt, während das anfängliche Laden der Blockkette (IBD, anfänglicher Blockdownload) vollständig und konstant gespeichert wird, während sich sein Inhalt nach der Verarbeitung von Transaktionen aus jedem neuen und korrekten Netzwerkblock ändert.  Für diesen Vorgang müssen ca. 200 GB Datenblöcke heruntergeladen und Hunderte Millionen digitaler Signaturen überprüft werden.  Nach Abschluss des IBD-Prozesses nimmt das UTXO-Set im trockenen Rückstand ca. 4 GB ein. </p><br><p>  Bei der Verwendung von Batterien besteht die Konsensregel in Bezug auf Fonds jedoch darin, kryptografische Beweise zu überprüfen und zu generieren, und die Last der Verfolgung verfügbarer Fonds liegt auf den Schultern des Eigentümers dieser Fonds, was den Nachweis ihrer Anwesenheit und ihres Eigentums erbringt. </p><br><p>  Die Batterie kann als kompakte Darstellung des Sets bezeichnet werden.  Die Größe der gespeicherten Ansicht muss in diesem Fall entweder konstant sein <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.66ex" viewBox="0 -832 2043 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-31" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-29" x="1653" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (1) </script>  oder beispielsweise sublinear relativ zur Potenz der Menge und Größe des Elements selbst erhöhen <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.724ex" height="2.66ex" viewBox="0 -832 4186.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6C" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6F" x="1451" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-67" x="1937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-28" x="2417" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6E" x="2807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-29" x="3407" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-29" x="3797" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2"> O (log (n)) </script>  Dabei ist n die Potenz der gespeicherten Menge. </p><br><p>  In diesem Fall sollte der Akkumulator die Erstellung von Nachweisen für die Aufnahme eines Elements in die Menge (Einschlussnachweis) ermöglichen und es ihm ermöglichen, diesen Nachweis effektiv zu überprüfen. </p><br><p>  Eine Batterie wird als <strong>dynamisch bezeichnet,</strong> wenn Sie damit Elemente hinzufügen und Elemente aus dem Set entfernen können. </p><br><p>  Ein Beispiel für eine solche Batterie ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Boneh, Bunz, Fisch im Dezember 2018 vorgeschlagene RSA-Batterie</a> .  Eine solche Batterie hat eine konstante Größe der gespeicherten Ansicht, erfordert jedoch ein <em>gemeinsames Geheimnis</em> (vertrauenswürdiges Setup).  Diese Anforderung negiert die Anwendbarkeit eines solchen Akkumulators für vertrauenswürdige Netzwerke wie Bitcoin, da Datenlecks während der Generierung eines Geheimnisses es Angreifern ermöglichen können, gefälschte Beweise für die Existenz von UTXO zu erstellen, indem sie Knoten mit einem UTXO-Satz fälschen, der auf einem solchen Akkumulator basiert. </p><br><h3 id="utreexo">  Utreexo </h3><br><p>  Mit dem von Utreexo vorgeschlagenen Thaddeus Dryja-Design können Sie eine <strong>dynamische</strong> Batterie <strong>ohne</strong> vertrauenswürdige Einrichtung erstellen. </p><br><p>  Utreexo ist ein Wald idealer binärer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkle-Bäume</a> und eine Weiterentwicklung der Ideen, die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effiziente asynchrone Akkumulatoren für verteilte pki vorgestellt werden</a> , und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bietet</a> die Möglichkeit, Elemente aus der Menge zu entfernen. </p><br><h4 id="logicheskaya-struktura-akkumulyatora">  Die logische Struktur der Batterie </h4><br><p>  Batteriezellen sind in einem Wald perfekter Binärbäume angeordnet.  Bäume sind nach Höhe geordnet.  Diese Präsentation wurde als die visuellste ausgewählt und ermöglicht es Ihnen, das Zusammenführen von Bäumen während des Betriebs mit der Batterie zu visualisieren. </p><br><p>  Der Autor stellt fest, dass, da alle Bäume im Wald perfekt sind, ihre Höhe durch die Zweierpotenz ausgedrückt wird, genau wie jede natürliche Zahl als Summe der Zweierpotenzen dargestellt werden kann.  Dementsprechend kann jeder Satz von Blättern in Form von Binärbäumen gruppiert werden, und in allen Fällen erfordert das Hinzufügen eines neuen Elements nur Kenntnisse <em>über die Wurzelknoten der gespeicherten Bäume</em> . </p><br><p>  Die gespeicherte Ansicht der Utreexo-Batterie ist also eine Liste von Wurzelknoten (Merkle-Wurzel) <em>und nicht der gesamte Wald von Bäumen</em> . </p><br><p> Stellen Sie sich die Liste der Stammelemente als <code>Vec&lt;Option&lt;Hash&gt;&gt;</code> .  Der optionale <code>Option&lt;Hash&gt;</code> weist darauf hin, dass das Stammelement möglicherweise fehlt. Dies bedeutet, dass der Baum keinen Baum mit einer angemessenen Höhe hat. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// SHA-256  #[derive(Copy, Clone, Hash, Eq, PartialEq)] pub struct Hash(pub [u8; 32]); #[derive(Debug, Clone)] pub struct Utreexo { pub roots: Vec&lt;Option&lt;Hash&gt;&gt;, } impl Utreexo { pub fn new(capacity: usize) -&gt; Self { Utreexo { roots: vec![None; capacity], } } }</span></span></code> </pre> <br><h4 id="dobavlenie-elementov">  Elemente hinzufügen </h4><br><p>  Zunächst beschreiben wir die Funktion <code>parent()</code> , die den übergeordneten Knoten für zwei bestimmte Elemente erkennt. </p><br><div class="spoiler">  <b class="spoiler_title">Parent () -Funktion</b> <div class="spoiler_text"><p>  Da wir Merkle-Bäume verwenden, ist das übergeordnete Element jedes der beiden Knoten ein Knoten, der den Verkettungs-Hash der Hashes der untergeordneten Knoten speichert: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span></span>(bytes: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sha = Sha256::new(); sha.input(bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = sha.result(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res_bytes = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]; res_bytes.copy_from_slice(res.as_slice()); Hash(res_bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>(left: &amp;Hash, right: &amp;Hash) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> concat = left .<span class="hljs-number"><span class="hljs-number">0</span></span> .into_iter() .chain(right.<span class="hljs-number"><span class="hljs-number">0</span></span>.into_iter()) .map(|b| *b) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;&gt;(); hash(&amp;concat[..]) }</code> </pre> <br><p>  Der Autor stellt fest, dass zur Verhinderung der von Charles Bouillaguet, Pierre-Alain Fouque, Adi Shamir und Sebastien Zimmer in <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweite Preimage-Angriffe auf Dithering-Hash-Funktionen</a> Zusätzlich zu zwei Hashes sollten Sie der Verkettung die Höhe innerhalb des Baums hinzufügen. </p></div></div><br><p>  Wenn Sie der Batterie Elemente hinzufügen, müssen Sie nachverfolgen, welche Stammelemente geändert werden.  Wenn Sie dem Pfad zum Ändern der Stammelemente für jedes hinzugefügte Element folgen, können Sie später einen Beweis für das Vorhandensein dieser Elemente erstellen. </p><br><div class="spoiler">  <b class="spoiler_title">Verfolgen Sie Änderungen während des Uploads</b> <div class="spoiler_text"><p>  Um die vorgenommenen Änderungen zu verfolgen, deklarieren wir die <code>Update</code> Struktur, in der Daten zu Änderungen an Knoten gespeichert werden. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> utreexo: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Utreexo, <span class="hljs-comment"><span class="hljs-comment">// ProofStep  ""     pub updated: HashMap&lt;Hash, ProofStep&gt;, }</span></span></code> </pre> </div></div><br><p>  Um der Batterie ein Element hinzuzufügen, benötigen Sie: </p><br><ul><li>  Erstellen Sie ein Array von Körben mit <code>new_roots</code> und platzieren Sie die vorhandenen <code>new_roots</code> dort, eines für jeden Korb: </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> new_roots = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::&lt;Hash&gt;::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hash) = root { vec.push(*hash); } new_roots.push(vec); }</code> </pre> </div></div><br><ul><li>  Fügen Sie die hinzugefügten Elemente ( <code>insertions</code> ) zum ersten Warenkorb hinzu <code>new_roots[0]</code> : </li></ul><br><p><img src="https://habrastorage.org/webt/8f/ne/jg/8fnejgnqbngrgygwreduomorpni.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs">new_roots[<span class="hljs-number"><span class="hljs-number">0</span></span>].extend_from_slice(insertions);</code> </pre> </div></div><br><ul><li>  Führen Sie das "Zusammenführen" von Artikeln durch, die dem ersten Warenkorb hinzugefügt wurden, mit dem Rest: <br><ul><li>  Für alle Körbe mit mehr als einem Artikel: <br><ol><li>  Wir nehmen zwei Elemente vom Ende des Warenkorbs, berechnen ihre übergeordneten Elemente und löschen beide Elemente </li><li>  Fügen Sie das berechnete übergeordnete Element zum nächsten Warenkorb hinzu. </li></ol></li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/df/dl/fm/dfdlfm0iw0tvwxtlomxmrml1ijc.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> new_roots[i].len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         let a = new_roots[i][new_roots[i].len() - 2]; let b = new_roots[i][new_roots[i].len() - 1]; new_roots[i].pop(); new_roots[i].pop(); let hash = self.parent(&amp;a, &amp;b); //      if new_roots.len() &lt;= i + 1 { new_roots.push(vec![]); } //      new_roots[i + 1].push(hash); //    ; //        updated.insert(a, ProofStep { hash: b, is_left: false }); updated.insert(b, ProofStep {hash: a, is_left: true }); } }</span></span></code> </pre> </div></div><br><ul><li>  Verschieben Sie Wurzelelemente aus Körben in das resultierende Batteriearray </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, bucket) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_roots.into_iter().enumerate() { <span class="hljs-comment"><span class="hljs-comment">//     if self.roots.len() &lt;= i { self.roots.push(None); } if bucket.is_empty() { self.roots[i] = None; } else { self.roots[i] = Some(bucket[0]); } }</span></span></code> </pre> </div></div><br><h4 id="sozdanie-dokazatelstva-dlya-dobavlennyh-elementov">  Erstellen von Beweisen für hinzugefügte Elemente </h4><br><p>  Der Nachweis der Aufnahme des Elements in die Batterie ( <code>Proof</code> ) dient als Pfad von Merkle (Merkle Path), der aus einer Kette von <code>ProofStep</code> .  Wenn der Weg nirgendwohin führt, ist der Beweis falsch. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///         . #[derive(Debug, Copy, Clone)] pub struct ProofStep { pub hash: Hash, pub is_left: bool, } ///   .       . #[derive(Debug, Clone)] pub struct Proof { pub steps: Vec&lt;ProofStep&gt;, pub leaf: Hash, }</span></span></code> </pre> <br><p>  Mithilfe der Informationen, die Sie zuvor beim Hinzufügen des Elements erhalten haben (Struktur <code>Update</code> ), können Sie den Nachweis erbringen, dass das Element zur Batterie hinzugefügt wurde.  Dazu gehen wir die Tabelle der vorgenommenen Änderungen durch und fügen jeden Schritt dem Pfad von Merkle hinzu, der anschließend als Beweis dienen wird: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Update&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prove</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, leaf: &amp;Hash) -&gt; Proof { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> proof = Proof { steps: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], leaf: *leaf, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> item = *leaf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updated.get(&amp;item) { proof.steps.push(*s); item = parent(&amp;item, &amp;s); } proof } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Beweisprozess</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8i/2h/gy/8i2hgyqkn8syqa0wdsybg3o9asm.gif"></p></div></div><br><h4 id="proverka-dokazatelstva-dlya-elementa">  Beweis für einen Gegenstand </h4><br><p>  Das Überprüfen des Beweises für die Aufnahme eines Elements (Einschlussbeweis) reduziert sich darauf, dem Pfad von Merkle zu folgen, bis es zum vorhandenen Wurzelelement führt: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = proof.steps.len(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expected) = expected { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> current_parent = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> proof.steps.iter() { current_parent = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.is_left { parent(&amp;s.hash, &amp;current_parent) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent(&amp;current_parent, &amp;s.hash) }; } current_parent == expected } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><p>  Klar: </p><br><div class="spoiler">  <b class="spoiler_title">Beweisüberprüfungsprozess für A.</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sx/49/dz/sx49dzfpgnzqv-x6-hl1fxgey1a.gif"></p></div></div><br><h4 id="udalenie-elementov">  Elemente löschen </h4><br><p>  Um ein Element aus der Batterie zu entfernen, müssen Sie einen gültigen Nachweis erbringen, dass das Element vorhanden ist.  Mit den Daten aus dem Proof können wir die neuen Wurzelelemente der Batterie berechnen, für die dieser Proof nicht mehr gültig ist. </p><br><p>  Der Algorithmus ist wie folgt: </p><br><ol><li>  Wie bei der Hinzufügung organisieren wir eine Reihe leerer Körbe, die Merkle-Bäumen entsprechen und deren Höhe zwei des Korbindex entspricht </li><li>  Legen Sie Gegenstände von den Stufen des Merkle-Pfades in die Körbe.  Der Warenkorbindex entspricht der aktuellen Schrittnummer </li><li>  Wir entfernen das Wurzelelement, zu dem der Pfad vom Beweis führt. </li><li>  Wie bei der Addition berechnen wir die neuen Wurzelelemente, kombinieren die Elemente aus den Körben paarweise und verschieben das Ergebnis der Vereinigung in den nächsten Korb </li></ol><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof, new_roots: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Hash&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() &lt; proof.steps.len() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.get(proof.steps.len()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> height = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> hash = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt; new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (index, ok) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.find_root(&amp;hash, &amp;new_roots[height]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { <span class="hljs-comment"><span class="hljs-comment">// Remove hash from new_roots new_roots[height].remove(index); loop { if height &gt;= proof.steps.len() { if !self.roots[height] .and_then(|h| Some(h == hash)) .unwrap_or(false) { return Err(()); } return Ok(()); } s = proof.steps[height]; hash = self.parent(&amp;hash, &amp;s); height += 1; } } } if height &gt;= proof.steps.len() { return Err(()); } while height &gt; new_roots.len() { new_roots.push(vec![]); } s = proof.steps[height]; new_roots[height].push(s.hash); hash = self.parent(&amp;hash, &amp;s); height += 1; } }</span></span></code> </pre> </div></div><br><p>  Der Vorgang zum Entfernen von Element "A": <br><img src="https://habrastorage.org/webt/pi/uf/rb/piufrb9ivxabdm_45vbmohgm5os.gif"></p><br><h2 id="integraciya-v-suschestvuyuschuyu-set">  Integration in ein bestehendes Netzwerk </h2><br><p>  Mit der vorgeschlagenen Batterie können Knoten die Verwendung der Datenbank zum Speichern aller UTXO verweigern, während die Möglichkeit erhalten bleibt, den UTXO-Satz zu ändern.  Es besteht jedoch das Problem, mit Beweisen zu arbeiten. </p><br><p>  Wir werden einen Validator-Knoten nennen, der den UTXO-Batteriekompakt (Compact-State-Knoten) verwendet, und einen Validator ohne Batterie - <em>voll</em> (Vollknoten).  Die Existenz von zwei Knotenklassen führt zu dem Problem, sie in ein einziges Netzwerk zu integrieren, da kompakte Knoten den Nachweis der Existenz von UTXO erfordern, das für Transaktionen verwendet wird, vollständige Knoten jedoch nicht.  Wenn nicht alle Knoten des Netzwerks gleichzeitig und auf koordinierte Weise zu Utreexo wechseln, bleiben die kompakten Knoten zurück und können nicht im Bitcoin-Netzwerk arbeiten. </p><br><p>  Um das Problem der Integration kompakter Knoten in das Netzwerk zu lösen, wird vorgeschlagen, eine zusätzliche Klasse von Knoten einzuführen - <em>Brücken</em> .  Ein Brückenknoten ist ein vollständiger Knoten, der unter anderem die Utreexo-Batterie und Einschlussnachweise für <strong>alle</strong> UTXOs aus dem UTXO-Set speichert.  Bridges berechnen neue Hashes und aktualisieren die Batterie und Beweise, wenn neue Blöcke mit Transaktionen eintreffen.  Die Unterstützung und Aktualisierung der Batterie und der Nachweise bedeutet für solche Knoten keine zusätzliche Rechenlast.  Bridges opfern Speicherplatz: Ordnung in Ordnung halten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="1.937ex" viewBox="0 -728.2 1101 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> 2n </script>  Hashes im Vergleich zu <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.141ex" height="2.66ex" viewBox="0 -832 2644 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-67" x="784" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-28" x="1264" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMATHI-6E" x="1654" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgR5Gd4stZtfHa0MmyUlII4arsEDA#MJMAIN-29" x="2254" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-4"> log (n) </script>  Hashes für kompakte Knoten, wobei n die Potenz der Menge UTXO ist. </p><br><h3 id="arhitektura-seti">  Netzwerkarchitektur </h3><br><p><img src="https://habrastorage.org/webt/fj/at/9t/fjat9tzhyxy_ncflmmzgt8ere_4.gif"></p><br><p>  Bridges ermöglichen das schrittweise Hinzufügen kompakter Knoten zum Netzwerk, ohne die Software vorhandener Knoten zu ändern.  Vollständige Knoten arbeiten wie zuvor und verteilen Transaktionen und Blöcke untereinander.  Bridge-Knoten sind vollständige Knoten, die zusätzlich Utreexo-Batteriedaten und eine Reihe von Einschlussnachweisen für <strong>alle</strong> UTXOs speichern.  Der Brückenknoten kündigt sich nicht als solcher an und gibt vor, ein vollständiger Knoten für alle vollständigen Knoten und ein kompakter Knoten für alle kompakten Knoten zu sein.  Obwohl Bridges beide Netzwerke miteinander verbinden, müssen sie in der Realität nur in eine Richtung verbunden werden: von vorhandenen vollständigen Knoten zu kompakten Knoten.  Dies ist möglich, da das Transaktionsformat nicht geändert werden muss und der Nachweis für UTXO für kompakte Knoten verworfen werden kann, sodass jeder kompakte Knoten Transaktionen auf die gleiche Weise an alle Netzwerkteilnehmer senden kann, ohne dass Brückenknoten beteiligt sind. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Wir haben die Utreexo-Batterie überprüft und ihren Prototyp in Rust implementiert.  Wir haben die Netzwerkarchitektur untersucht, die die Knoten basierend auf der Batterie integriert.  Der Vorteil von Compact Catch ist die Größe der gespeicherten Daten, die logarithmisch von der Leistung vieler UTXOs abhängt, wodurch der Speicherplatzbedarf und die Speicherleistung für solche Knoten erheblich reduziert werden.  Der Nachteil ist zusätzlicher Knotenverkehr für die Beweisübertragung, aber Beweisaggregationstechniken (wenn ein Beweis das Vorhandensein mehrerer Elemente beweist) und Caching können dazu beitragen, den Verkehr innerhalb akzeptabler Grenzen zu halten. </p><br><p>  <strong>Referenzen</strong> : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Utreexo Rust Prototyp GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Utreexo: Ein dynamischer Hash-basierter Akkumulator, der für das Bitcoin UTXO-Set optimiert wurde</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animierte Grafik aus einem Artikel</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456424/">https://habr.com/ru/post/de456424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456412/index.html">Umstrittene Innovation von Yandex - Melden Sie sich per Brief in Ihrem Konto an</a></li>
<li><a href="../de456414/index.html">Schutz vor Feuer in Rechenzentren oder wie Daten gespeichert werden</a></li>
<li><a href="../de456416/index.html">Agil für alle Bücher</a></li>
<li><a href="../de456418/index.html">Eine kurze Geschichte des Betrugs von Videospielen</a></li>
<li><a href="../de456422/index.html">Ankündigung einer neuen Version von Styled Components v5: Animal Grin</a></li>
<li><a href="../de456426/index.html">BASS - ein Framework für die automatische Synthese von Antivirensignaturen</a></li>
<li><a href="../de456428/index.html">Implementierung eines BI-Ansatzes zur Datenanalyse: praktische Empfehlungen</a></li>
<li><a href="../de456430/index.html">Das ewige Problem der technischen Verschuldung</a></li>
<li><a href="../de456432/index.html">Sicherheitswoche 25: Evernote-Sicherheitslücke und Hunderte von gehackten Online-Shops</a></li>
<li><a href="../de456434/index.html">Berufe der Zukunft: „Mit wem werden Sie auf dem Mars arbeiten?“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>