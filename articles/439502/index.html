<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÅÔ∏è üßòüèæ üññüèº Comportamiento indefinido y verdad no definida üóº üë®üèæ‚Äç‚öñÔ∏è ü§úüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El t√©rmino "comportamiento indefinido" en el lenguaje C y C ++ designa una situaci√≥n en la que literalmente "lo que simplemente no sucede". Hist√≥ricam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comportamiento indefinido y verdad no definida</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/439502/">  El t√©rmino <b>"comportamiento indefinido"</b> en el lenguaje C y C ++ designa una situaci√≥n en la que literalmente "lo que simplemente no sucede".  Hist√≥ricamente, los casos en que los compiladores anteriores para C (y las arquitecturas en √©l) se comportaron de manera incompatible se atribuyeron al comportamiento indefinido, y el comit√© para desarrollar el est√°ndar, en su sabidur√≠a ilimitada, decidi√≥ no decidir nada al respecto (es decir, no dar preferencia alguna de las implementaciones de la competencia).  El comportamiento indefinido tambi√©n se denomin√≥ situaciones posibles en las que el est√°ndar, generalmente tan exhaustivo, no prescrib√≠a ning√∫n comportamiento espec√≠fico.  Este t√©rmino tiene un tercer significado, que en nuestro tiempo se est√° volviendo cada vez m√°s relevante: comportamiento indefinido: esta es la oportunidad de optimizaci√≥n.  Y los desarrolladores en C y C ++ <i>adoran las</i> optimizaciones;  insistentemente requieren que los compiladores hagan todo lo posible para acelerar el c√≥digo. <br><br>  <i>Este art√≠culo se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>public√≥</i></a> por primera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>vez</i></a> en el sitio web de Cryptography Services.</i>  <i>La traducci√≥n se publica con el permiso del autor Thomas Pornin.</i> <br><a name="habracut"></a><br>  Aqu√≠ hay un ejemplo cl√°sico: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i ++) { dst[i] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)src[i]; } }</code> </pre> <br>  Compilaremos este c√≥digo GCC en una plataforma x86 de 64 bits para Linux (trabajo en la √∫ltima versi√≥n de Ubuntu 18.04, versi√≥n GCC - 7.3.0).  <i>Activamos</i> la optimizaci√≥n completa y luego miramos la lista de ensambladores, para la cual usamos las teclas <i>"-W -Wall -O9 -S</i> " (el argumento " <i>-O9</i> " establece el nivel m√°ximo de optimizaci√≥n de GCC, que en la pr√°ctica es equivalente a " <i>-O3</i> ", aunque en algunas bifurcaciones) CCG definido y niveles superiores).  Obtenemos el siguiente resultado: <br><br><pre> <code class="cpp hljs"> .file <span class="hljs-string"><span class="hljs-string">"zap.c"</span></span> .text .p2align <span class="hljs-number"><span class="hljs-number">4</span></span>,,<span class="hljs-number"><span class="hljs-number">15</span></span> .globl foo .type foo, @function foo: .LFB0: .<span class="hljs-function"><span class="hljs-function">cfi_startproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movupd</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm0 movupd 16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm1 cvttpd2dq %xmm0, %xmm0 cvttpd2dq %xmm1, %xmm1 punpcklqdq %xmm1, %xmm0 movups %xmm0, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function"> ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ubuntu </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7.3</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-27u</span></span></span></span><span class="hljs-function"><span class="hljs-params">buntu1~</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">18.04</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 7.3.0" .section .note.GNU-</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">stack</span></span></span><span class="hljs-function">,"",@progbits</span></span></code> </pre> <br>  Cada una de las dos <i>primeras</i> instrucciones <i>movupd</i> mueve dos valores <i>dobles</i> al registro SSE2 de 128 bits (el <i>doble</i> tiene un tama√±o de 64 bits, por lo que el registro SSE2 puede almacenar dos valores <i>dobles</i> ).  En otras palabras, cuatro valores iniciales se leen primero, y solo luego se <i>convierten</i> a <i>int</i> (operaci√≥n <i>cvttpd2dq</i> ).  La operaci√≥n <i>punpcklqdq</i> mueve los cuatro enteros de 32 bits recibidos en un registro SSE2 <i>(% xmm0</i> ), cuyo contenido se escribe en RAM ( <i>movups</i> ).  Y ahora lo principal: nuestro programa C requiere formalmente que el acceso a la memoria ocurra en el siguiente orden: <br><br><ul><li>  Lea el primer valor <i>doble</i> de <i>src [0]</i> . </li><li>  Escriba el primer valor de tipo <i>int</i> en <i>dst [0]</i> . </li><li>  Lea el segundo valor <i>doble</i> de <i>src [1]</i> . </li><li>  Escriba el segundo valor de tipo <i>int</i> a <i>dst [1]</i> . </li><li>  Lea el tercer valor <i>doble</i> de <i>src [2]</i> . </li><li>  Escriba el tercer valor de tipo <i>int</i> a <i>dst [2]</i> . </li><li>  Lea el cuarto valor <i>doble</i> de <i>src [3]</i> . </li><li>  Escriba el cuarto valor de tipo <i>int</i> a <i>dst [3]</i> . </li></ul><br>  Sin embargo, todos estos requisitos tienen sentido solo en el contexto de una m√°quina abstracta, que define el est√°ndar C;  El procedimiento en una m√°quina real puede variar.  El compilador es libre de reorganizar o modificar operaciones, siempre que su resultado no contradiga la sem√°ntica de la m√°quina abstracta (la llamada regla <i>as-if</i> es "como si").  En nuestro ejemplo, el orden de acci√≥n es simplemente diferente: <br><br><ul><li>  Lea el primer valor <i>doble</i> de <i>src [0]</i> . </li><li>  Lea el segundo valor <i>doble</i> de <i>src [1]</i> . </li><li>  Lea el tercer valor <i>doble</i> de <i>src [2]</i> . </li><li>  Lea el cuarto valor <i>doble</i> de <i>src [3]</i> . </li><li>  Escriba el primer valor de tipo <i>int</i> en <i>dst [0]</i> . </li><li>  Escriba el segundo valor de tipo <i>int</i> a <i>dst [1]</i> . </li><li>  Escriba el tercer valor de tipo <i>int</i> a <i>dst [2]</i> . </li><li>  Escriba el cuarto valor de tipo <i>int</i> a <i>dst [3]</i> . </li></ul><br>  Este es el lenguaje C: todos los contenidos de la memoria son, en √∫ltima instancia, bytes (es decir, ranuras con valores de tipo <i>unsigned char</i> , pero en la pr√°ctica, grupos de ocho bits), y se permiten cualquier operaci√≥n de puntero arbitrario.  En particular, los punteros <i>src</i> y <i>dst</i> se pueden usar para acceder a porciones de memoria superpuestas cuando se llama (esta situaci√≥n se llama "aliasing").  Por lo tanto, el orden de lectura y escritura puede ser importante si los bytes se escriben y luego se leen nuevamente.  Para que el comportamiento real del programa se corresponda con el resumen definido por el est√°ndar C, el compilador tendr√≠a que alternar entre las operaciones de lectura y escritura, proporcionando un ciclo completo de accesos a la memoria en cada iteraci√≥n.  El c√≥digo resultante ser√≠a m√°s grande y funcionar√≠a mucho m√°s lento.  Para los desarrolladores de C, esto ser√≠a una pena. <br><br>  Aqu√≠, afortunadamente, el <i>comportamiento indefinido</i> viene al rescate.  El est√°ndar C establece que no se puede acceder a los valores a trav√©s de punteros cuyo tipo no corresponde a los tipos actuales de estos valores.  En pocas palabras, si el valor se escribe en <i>dst [0]</i> , donde <i>dst es</i> un puntero <i>int</i> , entonces los bytes correspondientes no se pueden leer a trav√©s de <i>src [1]</i> , donde <i>src</i> es un puntero <i>doble</i> , ya que en este caso intentar√≠amos acceder valor, que ahora es de tipo <i>int</i> , utilizando un puntero de un tipo incompatible.  En este caso, se producir√≠a un comportamiento indefinido.  Esto se indica en el p√°rrafo 7 de la secci√≥n 6.5 de la norma ISO 9899: 1999 (‚ÄúC99‚Äù) (en la nueva edici√≥n 9899: 2018 o ‚ÄúC17‚Äù, la redacci√≥n no ha cambiado).  Este requisito se llama la estricta regla de alias.  Como resultado, el compilador de C puede actuar bajo el supuesto de que no se producen operaciones de acceso a la memoria que conducen a un comportamiento indefinido debido a la violaci√≥n de la estricta regla de alias.  Por lo tanto, el compilador puede reorganizar las operaciones de lectura y escritura en cualquier orden, ya que no deben acceder a porciones superpuestas de memoria.  De esto se trata la optimizaci√≥n del c√≥digo. <br><br>  El significado del comportamiento indefinido, en resumen, es el siguiente: el compilador puede asumir que no habr√° un comportamiento indefinido y generar c√≥digo basado en esta suposici√≥n.  En el caso de la estricta regla de alias, siempre que tenga lugar el alias, el comportamiento indefinido permite optimizaciones importantes que de otro modo ser√≠an dif√≠ciles de implementar.  En t√©rminos generales, cada instrucci√≥n en los procedimientos de generaci√≥n de c√≥digo utilizada por el compilador tiene dependencias que restringen el algoritmo de planificaci√≥n de la operaci√≥n: una instrucci√≥n no se puede ejecutar antes de las instrucciones de las que depende, o despu√©s de las instrucciones que dependen de √©l.  En nuestro ejemplo, el comportamiento indefinido elimina las dependencias entre las operaciones de escritura en <i>dst []</i> y las operaciones de lectura "posteriores" de <i>src []</i> : dicha dependencia solo puede existir en los casos en que se produce un comportamiento indefinido al acceder a la memoria.  Del mismo modo, el concepto de comportamiento indefinido permite al compilador simplemente eliminar el c√≥digo que no se puede ejecutar sin entrar en un estado de comportamiento indefinido. <br><br>  Todo esto, por supuesto, es bueno, pero el compilador a veces percibe tal comportamiento como una traici√≥n traidora.  A menudo puede escuchar la frase: "El compilador utiliza el concepto de comportamiento indefinido como una excusa para romper mi c√≥digo".  Supongamos que alguien escribe un programa que suma enteros y desborda temores; recuerde el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">caso de Bitcoin</a> .  Puede pensar as√≠: para representar enteros, el procesador usa c√≥digo adicional, lo que significa que si se produce un desbordamiento, suceder√° porque el resultado se truncar√° al tama√±o del tipo, es decir.  32 bit  Esto significa que el resultado del desbordamiento se puede predecir y verificar con una prueba. <br><br>  Nuestro desarrollador condicional escribir√° esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int add(int x, int y, int *z) { int r = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; r &lt; x) { return 0; } if (x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; r &gt; x) { return 0; } *z = r; return 1; } int main(int argc, char *argv[]) { int x, y, z; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); if (add(x, y, &amp;z)) { printf("%d\n", z); } else { printf("overflow!\n"); } return 0; }</span></span></span></span></code> </pre><br>  Ahora intentemos compilar este c√≥digo usando GCC: <br><br><pre> <code class="cpp hljs">$ gcc -W -Wall -O9 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> overflow!</code> </pre><br>  Ok, parece funcionar.  Ahora intente con otro compilador, por ejemplo, Clang (tengo la versi√≥n 6.0.0): <br><br><pre> <code class="cpp hljs">$ clang -W -Wall -O3 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> <span class="hljs-number"><span class="hljs-number">-794967296</span></span></code> </pre><br>  Que? <br><br>  Resulta que cuando una operaci√≥n con tipos enteros con signo conduce a un resultado que no puede ser representado por el tipo de destino, ingresamos al territorio de comportamiento indefinido.  Pero el compilador puede suponer que no sucede.  En particular, al optimizar la expresi√≥n <i>x&gt; 0 &amp;&amp; y&gt; 0 &amp;&amp; r &lt;x</i> , el compilador concluye que dado que los valores de <i>x</i> e <i>y son</i> estrictamente positivos, la tercera verificaci√≥n no puede ser verdadera (la suma de dos valores no puede ser menor que ninguno de ellos), y puedes omitir toda esta operaci√≥n.  En otras palabras, dado que el desbordamiento es un comportamiento indefinido, "no puede suceder" desde el punto de vista del compilador, y todas las instrucciones que dependen de este estado se pueden eliminar.  El mecanismo para detectar comportamientos indefinidos simplemente ha desaparecido. <br><br>  El est√°ndar nunca prescribi√≥ la suposici√≥n de que la "sem√°ntica con signo" (que en realidad se usa en las operaciones del procesador) se usa en los c√°lculos con tipos con signo;  esto sucedi√≥ m√°s bien por tradici√≥n, incluso en aquellos d√≠as en que los compiladores no eran lo suficientemente inteligentes como para optimizar el c√≥digo, centr√°ndose en una gama de valores.  Puede forzar a Clang y GCC a aplicar sem√°ntica de <i>ajuste a</i> tipos firmados utilizando el <i>indicador</i> especial <i>-fwrapv</i> (en Microsoft Visual C, puede usar <i>-d2UndefIntOverflow-,</i> como se describe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ).  Sin embargo, este enfoque no es confiable, la bandera puede desaparecer cuando el c√≥digo se transfiere a otro proyecto o a otra arquitectura. <br><br>  Pocas personas saben que los desbordamientos de tipo de personaje implican un comportamiento indefinido.  Esto se afirma en el p√°rrafo 5 de la secci√≥n 6.5 de las normas C99 y C17: <br><br>  <i>Si se produce una excepci√≥n al evaluar una expresi√≥n (es decir, si el resultado no est√° matem√°ticamente definido o est√° fuera del rango de valores v√°lidos de un tipo dado), el comportamiento es indefinido.</i> <br><br>  Sin embargo, para los tipos sin signo, la sem√°ntica modular est√° garantizada.  El p√°rrafo 9 de la secci√≥n 6.2.5 dice lo siguiente: <br><br>  <i>El desbordamiento nunca ocurre en los c√°lculos con operandos sin signo, ya que un resultado que no puede ser representado por el tipo entero sin signo resultante es un m√≥dulo truncado, un n√∫mero que es uno m√°s que el valor m√°ximo representado por el tipo resultante.</i> <br><br>  Otro ejemplo de comportamiento indefinido en operaciones con tipos con signo es la operaci√≥n de divisi√≥n.  Como todos saben, el resultado de la divisi√≥n por cero no est√° matem√°ticamente determinado, por lo tanto, de acuerdo con el est√°ndar, esta operaci√≥n implica un comportamiento indefinido.  Si el divisor es cero en la operaci√≥n <i>idiv</i> en el procesador x86, se <i>genera</i> una excepci√≥n de procesador.  Al igual que las solicitudes de interrupci√≥n, el sistema operativo maneja las excepciones del procesador.  En sistemas similares a Unix, como Linux, la excepci√≥n del procesador activada por la operaci√≥n <i>idiv</i> se traduce en una se√±al <i>SIGFPE</i> , que se env√≠a al proceso, y termina con el controlador predeterminado (no se sorprenda de que "FPE" significa "excepci√≥n de punto flotante" (excepci√≥n en operaciones de punto flotante), mientras que <i>idiv</i> trabaja con enteros).  Pero hay otra situaci√≥n que conduce a un comportamiento indefinido.  Considere el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", x / y); return 0; }  : $ gcc -W -Wall -O testdiv.c $ ./a.out 42 17 2 $ ./a.out -2147483648 -1 zsh: floating point exception (core dumped) ./a.out -2147483648 -1</span></span></span></span></code> </pre> <br>  Y la verdad es: en esta m√°quina (la misma x86 para Linux), el tipo <i>int</i> representa un rango de valores desde -2,147,483,648 hasta +2,147,483,647. Si divide -2,147,483,648 por -1, deber√≠a obtener +2,147,483,648 Pero este n√∫mero no est√° en el rango de valores <i>int</i> .  Por lo tanto, el comportamiento no est√° definido.  Cualquier cosa puede pasar.  En este caso, el proceso se termina por la fuerza.  En otro sistema, especialmente con un procesador peque√±o que no tiene una operaci√≥n de divisi√≥n, el resultado puede variar.  En tales arquitecturas, la divisi√≥n se realiza mediante programaci√≥n, con la ayuda del procedimiento generalmente proporcionado por el compilador, y ahora puede hacer lo que quiera con un comportamiento indefinido, porque eso es exactamente lo que es. <br><br>  Observo que <i>SIGFPE</i> se puede obtener en las mismas condiciones y con la ayuda del operador de m√≥dulo ( <i>%</i> ).  Y de hecho: debajo de ella se encuentra la misma operaci√≥n <i>idiv</i> , que calcula tanto el cociente como el resto, por lo que se activa la misma excepci√≥n del procesador.  Curiosamente, el est√°ndar C99 dice que la expresi√≥n <i>INT_MIN% -1</i> no puede conducir a un comportamiento indefinido, ya que el resultado est√° matem√°ticamente definido (cero) y claramente ingresa el rango de valores del tipo objetivo.  En la versi√≥n C17, se modific√≥ el texto del p√°rrafo 6 de la secci√≥n 6.5.5, y ahora tambi√©n se tiene en cuenta este caso, lo que acerca el est√°ndar a la situaci√≥n real en las plataformas de hardware comunes. <br><br>  Hay muchas situaciones no obvias que tambi√©n conducen a un comportamiento indefinido.  Echa un vistazo a este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned short mul(unsigned short x, unsigned short y) { return x * y; } int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", mul(x, y)); return 0; }</span></span></span></span></code> </pre> <br>  ¬øCrees que un programa, siguiendo el est√°ndar C, deber√≠a imprimirse si pasamos los factores 45,000 y 50,000 a la funci√≥n? <br><br><ul><li>  18,048 </li><li>  2,250,000,000 </li><li>  Dios salve a la reina! </li></ul><br>  La respuesta correcta ... s√≠, todo lo anterior!  Es posible que haya argumentado as√≠: dado que un <i>corto sin signo</i> es un tipo sin signo, deber√≠a admitir la sem√°ntica de envoltura m√≥dulo 65 536, porque en un procesador x86 el tama√±o de este tipo, por regla general, es exactamente 16 bits (el est√°ndar tambi√©n permite un tama√±o m√°s grande, pero en la pr√°ctica, este sigue siendo un tipo de 16 bits).  Como matem√°ticamente el producto es 2,250,000,000, se truncar√° el m√≥dulo 65,536, lo que da una respuesta de 18,048. Sin embargo, al pensar de esta manera, nos olvidamos de la extensi√≥n de los tipos enteros.  De acuerdo con el est√°ndar C (secci√≥n 6.3.1.1, p√°rrafo 2), si los operandos son de un tipo cuyo tama√±o es estrictamente m√°s peque√±o que el tama√±o de <i>int</i> , y los valores de este tipo pueden ser representados por el tipo <i>int</i> sin p√©rdida de bits (y solo tenemos este caso: en mi x86 bajo Linux tiene un tama√±o <i>int</i> de 32 bits, y puede almacenar expl√≠citamente valores de 0 a 65.535), luego ambos operandos se convierten en <i>int</i> y la operaci√≥n ya se realiza en los valores convertidos.  A saber: el producto se calcula como un valor de tipo <i>int,</i> y es solo cuando regresa de la funci√≥n que se devuelve a <i>corto sin signo</i> (es decir, es en este momento cuando se produce el m√≥dulo de truncamiento 65 536).  El problema es que matem√°ticamente el resultado antes de la transformaci√≥n inversa es 2.250 millones, y este valor excede el rango de <i>int</i> , que es un tipo con signo.  Como resultado, obtenemos un comportamiento indefinido.  Despu√©s de eso, puede pasar cualquier cosa, incluidos episodios repentinos de patriotismo ingl√©s. <br><br>  Sin embargo, en la pr√°ctica, con los compiladores ordinarios, el resultado es 18.048, ya que todav√≠a no hay una optimizaci√≥n que pueda aprovechar el comportamiento indefinido en este programa en particular (uno podr√≠a imaginar escenarios m√°s artificiales en los que realmente causar√≠a problemas). <br><br>  Finalmente, otro ejemplo, ahora en C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;array&gt; int main(int argc, char *argv[]) { std::array&lt;char, 16&gt; tmp; int i; if (argc &lt; 2) { return EXIT_FAILURE; } memset(tmp.data(), 0, 16); if (strlen(argv[1]) &lt; 16) { strcpy(tmp.data(), argv[1]); } for (i = 0; i &lt; 17; i ++) { printf(" %02x", tmp[i]); } printf("\n"); }</span></span></span></span></code> </pre> <br>  ¬°Este no es el t√≠pico "malo, horrible, <i>rayado ()</i> !"  De hecho, aqu√≠ la funci√≥n <i>strcpy ()</i> se ejecuta solo si el tama√±o de la cadena de origen, incluido el terminal cero, es lo suficientemente peque√±o.  Adem√°s, los elementos de la matriz se inicializan expl√≠citamente a cero, por lo que todos los bytes de la matriz tienen un valor dado, independientemente de si se pasa una cadena grande o peque√±a a la funci√≥n.  Al mismo tiempo, el bucle al final es incorrecto: lee un byte m√°s de lo que deber√≠a. <br><br>  Ejecuta el c√≥digo: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O9 testvec.c $ ./a.out foo <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ff ffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> ffffff99 <span class="hljs-number"><span class="hljs-number">07</span></span> ffffffba ff ffffea ffffffd0 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ffffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff97 <span class="hljs-number"><span class="hljs-number">7b</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">1b</span></span> ffffffa1 <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffffd8 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> (...) <span class="hljs-number"><span class="hljs-number">62</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> zsh: <span class="hljs-function"><span class="hljs-function">segmentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(core dumped)</span></span></span><span class="hljs-function"> ./a.out foo ++?</span></span></code> </pre> <br>  Puede objetar ingenuamente: bueno, lee un byte adicional m√°s all√° de los l√≠mites de la matriz;  pero esto no da tanto miedo, porque en la pila este byte todav√≠a est√° all√≠, se asigna a la memoria, por lo que el √∫nico problema aqu√≠ es el decimos√©ptimo elemento adicional con un valor desconocido.  El ciclo seguir√° imprimiendo exactamente 17 enteros (en formato hexadecimal) y finalizar√° sin ninguna queja. <br><br>  Pero el compilador tiene su propia opini√≥n sobre este asunto.  Es muy consciente de que la decimos√©ptima lectura provoca un comportamiento indefinido.  Seg√∫n su l√≥gica, cualquier instrucci√≥n posterior est√° en el limbo: no es necesario que despu√©s de un comportamiento indefinido algo deba existir (formalmente, incluso las instrucciones anteriores pueden estar bajo ataque, ya que el comportamiento indefinido tambi√©n funciona en la direcci√≥n opuesta).  En nuestro caso, el compilador simplemente ignorar√° la verificaci√≥n de condici√≥n en el bucle, y girar√° para siempre, o m√°s bien, hasta que comience a leer fuera de la memoria asignada para la pila, despu√©s de lo cual la se√±al <i>SIGSEGV</i> funcionar√°. <br><br>  Es divertido, pero si GCC se inicia con configuraciones menos agresivas para optimizaciones, dar√° una advertencia: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O1 testvec.c testvec.c: In function <span class="hljs-string"><span class="hljs-string">'int main(int, char**)'</span></span>: testvec.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>: warning: iteration <span class="hljs-number"><span class="hljs-number">16</span></span> invokes undefined behavior [-Waggressive-loop-optimizations] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" %02x"</span></span>, tmp[i]); ~~~~~~^~~~~~~~~~~~~~~~~ testvec.c:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>: note: <span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> loop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">17</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i ++)</span></span></span><span class="hljs-function"> </span></span>{ ~~^~~~</code> </pre> <br>  En <i>-O9,</i> esta advertencia desaparece de alguna manera.  Quiz√°s el hecho es que a altos niveles de optimizaci√≥n, el compilador aplica de manera m√°s agresiva el despliegue del bucle.  Es posible (pero impreciso) que este sea un error de CCG (en el sentido de una p√©rdida de advertencia; por lo tanto, las acciones de CCG en cualquier caso no contradicen el est√°ndar, ya que no requiere la emisi√≥n de "diagn√≥sticos" en tal situaci√≥n). <br><br>  Conclusi√≥n: si est√° escribiendo c√≥digo en C o C ++, tenga mucho cuidado y evite situaciones que conduzcan a un comportamiento indefinido, incluso cuando parezca "est√° bien". <br><br>  Los tipos enteros sin signo son una buena ayuda en los c√°lculos aritm√©ticos, ya que tienen sem√°ntica modular garantizada (pero a√∫n puede obtener problemas relacionados con la extensi√≥n de los tipos enteros).  Otra opci√≥n, por alguna raz√≥n impopular, es no escribir en C y C ++.  Por varias razones, esta soluci√≥n no siempre es adecuada.  Pero si puede elegir en qu√© idioma escribir el programa, es decir,  Cuando reci√©n est√° comenzando un nuevo proyecto en una plataforma que admite Go, Rust, Java u otros lenguajes, puede ser m√°s rentable negarse a usar C como el "lenguaje predeterminado".  La elecci√≥n de herramientas, incluido un lenguaje de programaci√≥n, siempre es un compromiso.  Las trampas de C, especialmente el comportamiento indefinido en operaciones con tipos firmados, conducen a costos adicionales para un mayor mantenimiento del c√≥digo, que a menudo se subestiman. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439502/">https://habr.com/ru/post/439502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439490/index.html">Tipos de referencia .NET vs Tipos de valor. Parte 2</a></li>
<li><a href="../439492/index.html">10 consejos para ser un buen l√≠der tecnol√≥gico</a></li>
<li><a href="../439496/index.html">C√≥mo se realiza la facturaci√≥n all√≠: cuando el cliente y el desarrollador hablan diferentes idiomas</a></li>
<li><a href="../439498/index.html">¬øEn qu√© hardware analizar un enorme eje de informaci√≥n?</a></li>
<li><a href="../439500/index.html">¬øPor qu√© los captchas se han vuelto tan complicados?</a></li>
<li><a href="../439504/index.html">¬øSu equipo necesita un ingeniero de datos?</a></li>
<li><a href="../439506/index.html">9 alternativas a un mal equipo (patr√≥n de dise√±o)</a></li>
<li><a href="../439508/index.html">Mitap sobre desarrollo de c√≥digo abierto en Mosc√∫</a></li>
<li><a href="../439510/index.html">Sistema de control distribuido altamente cargado de una central nuclear moderna</a></li>
<li><a href="../439512/index.html">¬øLa edad de los dinosaurios o el reaseguro legalmente verificado?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>