<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÄ üêÑ üë∏ Desenvolvimento de software para controle de motor DSP TMS320F28 üåÆ üë©üèª‚Äçüé® üéÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No meu primeiro artigo, falei sobre essa fam√≠lia de controladores; mais de uma d√∫zia de pessoas me escreveram na MP com perguntas sobre o assunto, emb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvimento de software para controle de motor DSP TMS320F28</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410161/">  No meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo,</a> falei sobre essa fam√≠lia de controladores; mais de uma d√∫zia de pessoas me escreveram na MP com perguntas sobre o assunto, embora esse n√£o fosse o t√≥pico do artigo.  As pessoas categoricamente n√£o quiseram ir ao Google, falando sobre a falta de informa√ß√£o.  Fiquei um pouco surpreso e decidi verificar - na verdade, em russo, praticamente n√£o h√° nada na fam√≠lia C2000 (no contexto do AVR, STM) e, o mais importante, n√£o h√° guias de in√≠cio claros.  As informa√ß√µes podem ser encontradas em ingl√™s, mas, novamente, n√£o s√£o suficientes.  Para mim, isso √© um tanto surpreendente, j√° que essa fam√≠lia n√£o tem alguns anos.  Portanto, foi decidido o melhor de sua capacidade de influenciar a situa√ß√£o. <br><br>  Quem precisa desses controladores em princ√≠pio ... Deseja montar um inversor de solda?  Fonte de alimenta√ß√£o ininterrupta?  Alisador de banho de galvanoplastia?  Frequ√™ncia?  Um inversor para energia alternativa?  M√°quina CNC?  Se pelo menos um ponto √© sobre voc√™, o artigo √© dedicado a voc√™! <br><br>  Outros leitores tamb√©m estar√£o interessados ‚Äã‚Äãem aprender sobre o controlador "novo e velho", por que ele √© necess√°rio e como trabalhar com ele.  Essa fam√≠lia √© muito simples (muito mais simples que STM, LPC e outro Cortex), as pedras s√£o f√°ceis de comprar (tamb√©m existem Ali), permitem implementar solu√ß√µes industriais altamente confi√°veis, pois voc√™ pode construir praticamente qualquer sistema de controle industrial. <br><br>  Voc√™ j√° decidiu que esse controlador √© o seu sonho e est√° pronto para correr para a batalha?  Em seguida, compramos por US $ 17 a seguinte depura√ß√£o do F28027-LaunchPad: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/cd/cv/edcdcvjwp5ewu_jl0jbnwwzsfyc.png"></div><br>  Voc√™ comprou?  Agora voc√™ pode entrar em batalha.  Se surgiu a quest√£o de onde comprar "melhor" e "mais barato", ent√£o vamos √† loja oficial.  Vamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e vemos o pre√ßo de US $ 17.  Por esse valor, voc√™ receber√° uma taxa de depura√ß√£o original e a entrega do correio na porta.  Encomendei uma vez na China para entrega, resultou em US $ 16 e est√° com desconto e cupom, al√©m de uma viagem "b√¥nus" aos correios.  Portanto, eu recomendo que √© o oficial.  Vamos l√°! <br><a name="habracut"></a><br><h2>  Vis√£o geral da s√©rie C2000 </h2><br>  Voc√™ pode ler o m√°ximo de detalhes sobre tudo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site oficial</a> , √© claro, em ingl√™s.  Vou falar brevemente sobre isso e expressar meus pensamentos sobre o aplicativo.  Por favor, note que esta √© apenas minha especula√ß√£o e eles n√£o reivindicam a verdade. <br><br>  Primeiro, algumas palavras sobre o C2000 em geral.  Caracter√≠sticas distintivas da fam√≠lia, associadas ao seu principal objetivo de controle motor, s√£o a presen√ßa de HRPWM (PWM de alta precis√£o) e CLA (coprocessador).  O √∫ltimo est√° realmente ausente no Piccolo TMS320F2802x mais novo, mas n√£o √© necess√°rio por l√°, o principal √© o HRPWM em vigor.  O que √© ... O pr√≥prio HRPWM √© um PWM regular, √© muito preciso e o tempo de grava√ß√£o e configura√ß√£o para um novo ciclo de trabalho √© significativamente mais r√°pido.  Isso possibilita obter, por exemplo, um seno perfeitamente modelado em um inversor DC / CA ou controlar motores de passo em uma m√°quina CNC com precis√£o muito alta. <br><br>  O CLA √© essencialmente um n√∫cleo completo, mas n√£o tem acesso a perif√©ricos, apenas ao n√∫cleo principal e √† mem√≥ria.  Serve para descarregar o n√∫cleo principal da computa√ß√£o.  Esse coprocessador digere de maneira f√°cil e natural os dados flutuantes, o que √© importante ao implementar v√°rios algoritmos, filtros e muito mais. <br><br><img src="https://habrastorage.org/webt/5o/ui/lh/5ouilh691kdhoflkcrtcs4tmwqy.png"><br><br>  Vou falar sobre duas fam√≠lias principais que voc√™ provavelmente encontrar√°: <br><br><ul><li>  <b>Piccolo.</b>  Os controladores mais jovens, mas tamb√©m os mais baratos.  Meu TMS320F28027 √© desta fam√≠lia.  Se voc√™ decidir desenvolver eletr√¥nicos de pot√™ncia para fins comerciais, essas ser√£o suas principais pedras - elas s√£o bastante baratas, pag√°veis ‚Äã‚Äã(LQFP, QFN, TSSOP) e permitem implementar quase tudo.  Por exemplo, seu desempenho √© suficiente para um PFC bif√°sico, um inversor para pain√©is solares, um conversor de frequ√™ncia de at√© 10 kW com controle vetorial, etc.  Como voc√™ pode ver, este √© um segmento de produtos que √© comprado por pessoas comuns e empresas, o que significa que √© muito procurado.  As principais limita√ß√µes s√£o a frequ√™ncia de 60 MHz, um n√∫mero limitado de canais PWM. </li><li>  <b>Delfino.</b>  Ideologicamente, estes s√£o todos iguais Piccolo, apenas inflados com meldonium.  O que √© isso expresso - a frequ√™ncia √© de 200 MHz, nas pedras antigas j√° existem 2 n√∫cleos completos + 2 coprocessadores, gabinetes grandes e, portanto, muitas pernas, muitos canais PWM, muitos ADCs e, em geral, muito.  Ou seja, em pedras mais antigas, temos 4 n√∫cleos com uma frequ√™ncia de 200 MHz, um desempenho de 800 MIPS, o que √© bastante impressionante.  Esse poder pode ser usado de diferentes maneiras, mas a aplica√ß√£o principal s√£o sistemas algoritmicamente complexos, por exemplo, o retificador de Vienne ou qualquer outra coisa.  Tamb√©m em um desses controladores, voc√™ pode implementar todo o sistema de controle de uma m√°quina CNC, por exemplo, fresagem ou corte a chama de metal. </li></ul><br><h2>  Finaliza√ß√£o da placa de depura√ß√£o </h2><br>  Quando voc√™ recebe uma caixa com uma placa de depura√ß√£o, encontrar√° o quartzo e os capacitores ausentes.  Eles n√£o s√£o necess√°rios, mas √© aconselh√°vel usar drogas.  Eu n√£o tenho mais quartzo no HC-49, ent√£o tive que pedir emprestado a um amigo.  Ele escolhe AVR e STM, ent√£o encontrou apenas 8 MHz.  Soldado.  Adicionei 22 capacitores pF da mem√≥ria antiga, como fiz em mega na escola. <br><br>  Esta solu√ß√£o n√£o √© a melhor e est√° conectada √† configura√ß√£o do PLL.  O multiplicador m√°ximo para PLL √© x12 (mais pode ser, mas n√£o √© recomendado, e funciona de maneira torta).  A frequ√™ncia m√°xima √© de 60 MHz.  O valor m√°ximo do divisor na sa√≠da PLL √© 3. A frequ√™ncia do quartzo √© 8 MHz.  N√£o posso multiplicar por 8 por um n√∫mero inteiro e obter 60. Estamos procurando o valor total mais pr√≥ximo, neste caso 240. Ou seja, multiplique 8 por 30 e, em seguida, dividindo por 4, obtenho os cobi√ßados 60 MHz, mas o problema √© que o multiplicador x30 PLL √© inaceit√°vel , divider / 4 tamb√©m est√° indispon√≠vel.  Existem 2 sa√≠das: <br><br><ul><li>  <b>Ruim:</b> multiplique a frequ√™ncia de 8 MHz por 7 e divida por 1 e obtenha 56 MHz.  Voc√™ pode multiplicar por 8 e obter 64 MHz, funcionar√° de forma est√°vel, mas em ambos os casos a frequ√™ncia n√£o √© m√°xima de 60 MHz.  N√£o √© suficiente perfeccionismo, infelizmente.  Eu tenho apenas essa op√ß√£o, soldado 8 MHz e fez uma frequ√™ncia de 56 MHz. </li><li>  <b>Bom:</b> compre o quartzo a 10 ou 20 MHz (melhor que 10) e multiplique por 6, bem, divida por 1, obtemos os estimados 60 MHz.  Eu moro fora da cidade e, honestamente, era muito pregui√ßoso ir a uma loja local, na qual n√£o √© fato que haja quartzo de 10 MHz.  Obviamente, o circuito RC interno e o quartzo de 8 MHz ser√£o usados ‚Äã‚Äãpara treinamento, mas em seus projetos futuros, coloque o quartzo de 10 MHz, n√£o os gigantescos mutantes no pacote HC-49. </li></ul><br><h2>  Arquitetura e recursos perif√©ricos </h2><br>  Tudo o que acontecer√° a seguir se aplica ao controlador TMS320F28027.  Para come√ßar, vejamos a estrutura retirada da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha de dados</a> : <br><br> <a href=""><img src="https://habrastorage.org/webt/sr/da/hb/srdahbswvkrs9zjzbnvevwgqvho.png"></a> <br><br>  A primeira coisa que voc√™ deve prestar aten√ß√£o √© que a RAM √© dividida em 3 setores: M0, M1 e SARAM.  Os volumes desses setores de mem√≥ria no nosso caso s√£o 1k, 1k e 4k.  Vale ressaltar que, neste caso, a palavra n√£o √© de 8 bits, mas de 16 bits, ou seja, de uma forma mais familiar, √© de 2 kB + 2 kB + 8 kB.  A peculiaridade deste m√≥dulo √© que os setores M0 e M1 s√£o mais r√°pidos que os 8 kB restantes de RAM.  Formalmente, voc√™ pode levar isso como um cache.  Os setores M0 e M1 geralmente armazenam os dados usados ‚Äã‚Äãcom mais freq√º√™ncia, bem como os dados mais cr√≠ticos para o desempenho da mem√≥ria.  Por padr√£o, podemos usar o vinculador para especificar o que e onde est√° armazenado, mas n√£o abordarei este t√≥pico neste artigo, aqui √© necess√°rio pelo menos um artigo separado. <br><br>  A segunda caracter√≠stica importante √© que todos os perif√©ricos t√™m clock do barramento do sistema, ou seja, a partir de 60 MHz (no meu caso, 56 MHz).  Como exemplo, darei os microcontroladores STM32, onde a frequ√™ncia do n√∫cleo √©, por exemplo, 180 MHz para F4, mas os perif√©ricos s√£o sincronizados atrav√©s de uma s√©rie de divisores.  Eu chamo essa abordagem de "megahertz falso" para mim, embora isso seja muito exagerado.  Portanto, 60 MHz para TMS320F28 e 180 MHz para stm32 n√£o s√£o t√£o diferentes e, se voc√™ se lembrar da presen√ßa de CLA, 60 + 60 MHz s√£o pelo menos compar√°veis.  √â claro que essa compara√ß√£o n√£o est√° correta, mas deixa claro que n√£o apenas os megahertz est√£o cansados. <br><br>  Tamb√©m √© um ponto interessante - preste aten√ß√£o √† estrutura geral: HRPWM, ADCs, comparadores com um DAC interno, m√≥dulo de processamento de codificador (eCAP) ... Um conversor de frequ√™ncia pronto com controle vetorial em sua forma pura!  Essa √© toda a ess√™ncia dessa fam√≠lia - minimalismo.  Por um lado, a periferia √© bastante ruim em compara√ß√£o com o Cortex, mas, por outro lado, √© suficiente implementar um conversor de frequ√™ncia, dc / dc, dc / ac e um driver de motor de passo.  Devido a isso, trabalhar com os controladores TMS320F28 √© muito simples, compreens√≠vel e n√£o sobrecarregado com a√ß√µes desnecess√°rias.  Mas se de repente voc√™ precisar de 3 UARTs, e para eles um par de i2c e mais 3 SPIs, esses controladores definitivamente n√£o s√£o para voc√™ - eles t√™m tarefas diferentes. <br><br><h2>  Ambiente de Desenvolvimento </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/vc/iv/5vvcivdcbwzulr9uocxmccv-ba0.png"></div><br>  Voc√™ j√° viu o logotipo inicial?  Lembre-se dela.  Se voc√™ decidir come√ßar a usar artigos no desenvolvimento dos her√≥is do artigo, esse software ser√° todo seu e, como voc√™ v√™, o <b>software</b> ser√° <b>chamado controlSUITE</b> . <br><br>  Esta aplica√ß√£o √© uma cole√ß√£o e biblioteca de tudo o que voc√™ precisa para desenvolver software para a fam√≠lia de controladores C2000.  Instalar este aplicativo √© a primeira coisa a fazer e ver sua composi√ß√£o; ele cont√©m: <br><br><ul><li>  Descri√ß√£o de todos os controladores e placas de depura√ß√£o existentes com base neles.  Fontes de circuitos, placas de circuito impresso, listas t√©cnicas, principalmente no Altium Designer </li><li>  Exemplos de circuitos e design de placas de circuito impresso </li><li>  Bibliotecas principais para desenvolvimento de firmware </li><li>  Bibliotecas de matem√°tica e DSP, inclusive para uso com CLA </li><li>  Um exemplo de projetos de software para cada tipo de perif√©rico </li><li>  Um grande n√∫mero de apnouts para a implementa√ß√£o da maioria dos algoritmos para controle de motores, conversores dc / dc, controladores MPPT e outros sistemas </li><li>  Um conjunto de programas que permitem criar um sistema de gerenciamento de mecanismo sem programa√ß√£o, simplesmente usando um ambiente gr√°fico </li><li>  O pr√≥prio IDE, que ser√° desenvolvido </li></ul><br>  Tudo o que descrevi acima √© muito breve e modesto.  Voc√™ levar√° algumas semanas para ver e rolar pelo menos na diagonal.  Obviamente, voc√™ n√£o precisar√° da maior parte dessa quantidade de dados no in√≠cio, mas precisar√° se lembrar para onde ir se algo for incompreens√≠vel para voc√™ e estranho. <br><br>  Agora, com o que trabalharemos hoje √© o IDE, cuja parte gr√°fica se baseia na conhecida Eclipse.  O compilador n√£o √© o GCC, mas o pr√≥prio Texas, que na minha opini√£o subjetiva √© definitivamente melhor que o primeiro.  Embora haja suspeitas de que isso seja completamente dopado do mesmo modo gcc.  O ambiente de desenvolvimento √© chamado <b>Code Composer Studio</b> , a vers√£o atual 7.4. <br><br><h2>  Cria√ß√£o de projeto </h2><br>  No come√ßo, eu queria implementar uma tarefa id√™ntica ao primeiro artigo, ou seja, desenhar um seno.  Em princ√≠pio, na estrutura de um artigo, isso poderia ter sido feito deixando para tr√°s um quadro de um volume muito grande de pequenas coisas, mas como voc√™ sabe, a ess√™ncia est√° precisamente nas pequenas coisas.  Existem v√°rios artigos sobre o TMS na Internet, mas todos s√£o muito superficiais e se resumem ao tipo de "copiar isso e tudo funciona", ou seja, o processo e a ideologia em si n√£o s√£o considerados.  Portanto, na estrutura deste artigo, criaremos um projeto, limparemos os componentes desnecess√°rios, configuramos o firmware na mem√≥ria flash do controlador e aprenderemos a trabalhar com o GPIO, e eles s√£o muito interessantes aqui. <br><br>  Fa√ßa o download do CCS7 no site do fabricante, instale e comece a criar o projeto da maneira usual: <i>Arquivo ‚Üí Novo ‚Üí Projeto CCS ...</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wb/v0/jy/wbv0jyccatp8jysn2nckh7qaooc.png"></div><br>  Vemos essa janela e nela precisamos selecionar o controlador que nos interessa, no meu caso √© TMS320F28027, indicar o nome do projeto e prescrever o caminho em que ele ser√° armazenado.  Primeiro, voc√™ precisa criar uma pasta onde o projeto ser√° armazenado.  O nome do projeto e o nome da pasta podem n√£o corresponder.  Clique no bot√£o <i>Concluir</i> e nosso projeto √© criado. <br><br>  Agora voc√™ precisa preencher o nosso projeto com conte√∫do e conect√°-lo.  Antes disso, para melhorar a estrutura do projeto, crie este conjunto de pastas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/cg/er/eecgerskm0jeso2ocebvaheeyrc.png"></div><br><ul><li>  <i>inc</i> - uma pasta que cont√©m todos os arquivos de cabe√ßalho </li><li>  <i>system_inc</i> - esta se√ß√£o armazenar√° os arquivos de cabe√ßalho das bibliotecas padr√£o, os arquivos que n√≥s mesmos criaremos, por exemplo, main.c, est√£o na pasta inc.  Isso n√£o quebrar√° algo sem pensar ou remover√° desnecessariamente </li><li>  <i>src</i> - pasta com todas as fontes </li><li>  <i>system_src</i> - pasta com arquivos de origem para bibliotecas padr√£o </li></ul><br>  Observe que essa estrutura n√£o √© algum tipo de dogma, mas √© apenas minha ideia de pedido.  Embora eu o recomende a pessoas com experi√™ncia m√≠nima, com o tempo voc√™ mudar√° para se adequar √† sua vis√£o de mundo, mas, por enquanto, isso minimizar√° o n√∫mero de batentes. <br><br>  Agora crie o arquivo main.h na pasta inc e conecte-o ao main.c.  Atrav√©s dele, conectar√° as bibliotecas de base.  E antes de come√ßar a transferir bibliotecas e outros arquivos, vamos escrever o caminho para as pastas onde nossos futuros arquivos de cabe√ßalho ser√£o armazenados nas configura√ß√µes do projeto.  Para fazer isso, clique com o bot√£o direito do mouse no projeto (Teste) na √°rvore do projeto e clique em <i>Propriedades</i> na parte inferior ou pressione <i>Alt + Enter</i> .  Na janela que se abre, v√° para <i>Compilar ‚Üí Compilador C2000 ‚Üí Incluir op√ß√µes</i> e aqui precisamos de dois caminhos existentes - registre o caminho para as pastas inc e system_inc.  Clique em <i>Adicionar</i> , <i>Espa√ßo de trabalho</i> e, em seguida, na pasta inc desejada, fa√ßa o mesmo e se apegue √† segunda pasta.  Assim, prescrevemos caminhos relativos; ao transferir um projeto, voc√™ n√£o precisar√° reconfigurar nada.  Como resultado, obtemos uma imagem e <i>clicamos</i> em <i>Ok</i> : <br><br><img src="https://habrastorage.org/webt/2x/nd/ql/2xndqlhcm5szyalytbw6oeseyka.png"><br><br>  Agora temos um projeto vazio com os caminhos prescritos e outras configura√ß√µes, resta apenas preench√™-lo com bibliotecas.  A √∫nica coisa a fazer √© verificar se tudo est√° conectado.  Em teoria, voc√™ deve obter um c√≥digo e uma imagem e compilar o projeto.  Para fazer isso, pressione <i>CTRL + B</i> ou v√° para <i>Projeto ‚Üí Compilar tudo</i> na parte superior.  O projeto deve compilar sem erros e ter a seguinte apar√™ncia (a imagem √© clic√°vel): <br><br> <a href=""><img src="https://habrastorage.org/webt/0b/hv/ur/0bhvurabfuhr1-6lqjgzn4svzp0.png"></a> <br><br>  Agora vamos falar um pouco sobre o vinculador.  Inicialmente, ao criar um projeto, o IDE gera o arquivo <i>28027_RAM_lnk.cmd</i> , coloca nosso programa na RAM durante a depura√ß√£o e o firmware.  Isso √© conveniente quando estamos depurando, porque  Os recursos de mem√≥ria flash n√£o s√£o desperdi√ßados e a entrada de depura√ß√£o na RAM √© significativamente mais r√°pida.  Mas e se quisermos costurar em flash?  Para fazer isso, existe outro arquivo de link que colocar√° nosso programa em flash.  Vou mostrar esta op√ß√£o. <br><br>  Antes de tudo, exclua o arquivo <i>28027_RAM_lnk.cmd</i> .  Como eu disse - <b>controlSUITE √© o</b> nosso tudo.  N√≥s abrimos.  Agora v√° em <i>ingl√™s ‚Üí Dispositivo ‚Üí Piccolo F2802x ‚Üí Bibliotecas de suporte ‚Üí Arquivos de cabe√ßalho para F28027x</i> .  √Ä direita, vemos pastas - estas s√£o as bibliotecas padr√£o e tudo o que √© necess√°rio, incluindo vinculadores.  Agora vamos para a pasta <i>f2802x_common ‚Üí cmd</i> e aqui vemos um conjunto de vinculadores para todas as pedras na linha.  N√£o √© dif√≠cil adivinhar os arquivos _RAM para fazer upload de c√≥digo na RAM e sem essa tag para fazer o upload via flash.  Pegamos o arquivo <i>F28027.cmd</i> e o <i>copiamos</i> para o nosso projeto, em vez do antigo vinculador remoto. <br><br>  Agora √© hora de migrar as pr√≥prias bibliotecas.  Vamos para a pasta <i>f2802x_common ‚Üí source</i> e vemos <i>v√°rios</i> arquivos.  Existem dois tipos de bibliotecas: registradores padr√£o (semelhantes ao CMSIS) e algum tipo de SPL.  Nesse caso, estamos interessados ‚Äã‚Äãapenas na primeira visualiza√ß√£o, ou seja, arquivos com o prefixo <i>f2802x_</i> .  Claro, voc√™ pode arrastar todos eles para o nosso projeto, mas por que entupi-lo se n√£o usarmos tudo?  Se voc√™ precisar de algo, no futuro, basta adicion√°-lo.  Por enquanto, nos restringimos aos seguintes conjuntos de arquivos: <br><br><ul><li>  <i>f2802x_codestartbranch.asm</i> </li><li>  <i>f2802x_defaultisr.c</i> </li><li>  <i>f2802x_piectrl.c</i> </li><li>  <i>f2802x_pievect.c</i> </li><li>  <i>f2802x_sysctrl.c</i> </li></ul><br>  Copiamos o arquivo de dados e colamos em nossa pasta <i>system_src</i> .  Agora vamos para a pasta <i>f2802x_headers ‚Üí source</i> e <i>pegamos</i> o arquivo <i>F2802x_GlobalVariableDefs.c</i> de l√° e <i>copiamos</i> novamente para a pasta <i>system_src</i> .  Em seguida, v√° para a pasta <i>f2802x_headers ‚Üí cmd</i> e copie o arquivo <i>F2802x_Headers_nonBIOS.cmd</i> de l√° para a mesma pasta.  Isso completa o preenchimento da pasta <i>system_src</i> e prossegue para os cabe√ßalhos. <br><br>  N√≥s vamos para a pasta <i>f2802x_headers ‚Üí inclu√≠mos</i> e <i>copiamos</i> todos os arquivos de l√° para a pasta <i>system_inc</i> .  Agora vamos para a pasta <i>f2802x_common ‚Üí source</i> e <i>copiamos</i> os arquivos de l√°: <br><br><ul><li>  <i>f2802x_examples.h</i> </li><li>  <i>f2802x_globalprototypes.h</i> </li><li>  <i>f2802x_i2c_defines.h</i> </li><li>  <i>f2802x_epwm_defines</i> </li><li>  <i>f2802x_swprioritizedisrlevels.h</i> </li><li>  <i>f2802x_defaultisr.h</i> </li></ul><br>  Devemos obter esta imagem na √°rvore do projeto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/tu/h-/jwtuh-pssz-pn5_ynxlxugmijtw.png"></div><br>  Agora voc√™ precisa conectar as bibliotecas b√°sicas, o arquivo <i>main.h</i> assume o seguinte formato: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_Device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_examples.h"</span></span></span></span></code> </pre> <br>  Estamos tentando compilar.  Se o projeto foi compilado sem erros e avisos, tudo est√° conectado corretamente.  Se isso n√£o aconteceu, verifique duas vezes todas as 10 vezes e, se n√£o der certo, escreva para o PM - eu ajudarei, como Owl disse: <i>"Baz-woz-mEz-bottom, ou seja, por nada</i> . <i>"</i> <br><br><h2>  Inicializa√ß√£o do controlador e sistema de rel√≥gio </h2><br>  Nesta se√ß√£o, escreveremos uma fun√ß√£o que inicializa o timer do watchdog e os vetores de interrup√ß√£o e define os sinalizadores de interrup√ß√£o para zero.  Tamb√©m configuramos o sistema de rel√≥gio, como resultado do quartzo externo e n√£o da cadeia RC interna se tornar a fonte do rel√≥gio, configurar o PLL e ativar o rel√≥gio para todos os perif√©ricos. <br><br>  Para a precis√£o do c√≥digo, proponho colocar todas as inicializa√ß√µes b√°sicas em um arquivo separado, cuja interface ser√° a fun√ß√£o <i>void InitStartSystem (void)</i> .  Para fazer isso, crie os arquivos <i>systemInitStart.he</i> <i>systemInitStart.c</i> .  Escreverei imediatamente uma fun√ß√£o e simplesmente analisamos seu conte√∫do: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLCR, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); }</code> </pre><br>  Todas as fun√ß√µes chamadas em <i>InitStartSystem ()</i> s√£o padr√£o.  Aconselho que voc√™ veja em detalhes como eles s√£o implementados; para isso, voc√™ pode pressionar CTRL e clicar na fun√ß√£o de seu interesse.  Voc√™ j√° olhou?  Agora repasse brevemente ... <br><br><ul><li>  <i>DisableDog ()</i> - a fun√ß√£o desativa o "c√£o".  Esta √© uma etapa obrigat√≥ria ao configurar a parte principal de perif√©ricos cr√≠ticos, por exemplo, um sistema de rel√≥gio.  No c√≥digo da biblioteca, voc√™ costuma ver isso, ele ser√° duplicado e duplicado </li><li>  <i>XtalOscSel ()</i> - esta fun√ß√£o implementa a mudan√ßa de uma fonte de rel√≥gio interna para um quartzo externo.  <b>Um ponto importante!</b>  H√° um erro na biblioteca padr√£o com esta fun√ß√£o - ela n√£o √© declarada.  Vamos para o arquivo <i>f2802x_globalprototypes.he</i> entre todos os outros, adicionamos a linha <i>extern void XtalOscSel (void)</i> <br><br><img src="https://habrastorage.org/webt/3l/vv/yv/3lvvyvwdfpwbqpek6bphfkheapu.png"><br><br>  <b>O segundo ponto importante!</b>  V√° para a fun√ß√£o XtalOscSel e exclua a fun√ß√£o de atraso. <br><br><img src="https://habrastorage.org/webt/ve/iq/iw/veiqiwa2locaclbj2-xfbpiakpe.png"><br><br>  <b>O terceiro ponto importante!</b>  Vamos ao arquivo <i>f28027x_exmaples.h</i> e comentamos a fun√ß√£o de implementa√ß√£o de atraso. <br><br><img src="https://habrastorage.org/webt/t7/jk/jp/t7jkjpu3nbgcqlqt5aolaniwqxg.png"><br></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> - a fun√ß√£o configura o PLL.  Dois valores s√£o transferidos para ele: multiplicador e divisor.  Seu valor √© especificado no arquivo de cabe√ßalho.  <b>Um ponto importante!</b>  Abrimos essa fun√ß√£o na biblioteca e voc√™ precisa comentar o atraso na parte inferior <br><br><img src="https://habrastorage.org/webt/mg/up/gi/mgupgi_vhx8hvcvg3tgaqsxaxas.png"></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> - a fun√ß√£o configura o PLL.  Dois valores s√£o transferidos para ele: multiplicador e divisor.  Seu valor √© especificado no arquivo de cabe√ßalho.  <b>Um ponto importante!</b>  Abrimos essa fun√ß√£o na biblioteca e voc√™ precisa comentar o atraso na parte inferior </li><li>  <i>InitPeripheralClocks ()</i> - essa fun√ß√£o simplesmente habilita o rel√≥gio para toda a periferia.  Sim para todos.  O C2000 n√£o √© uma solu√ß√£o para gl√¢ndulas alimentadas por bateria, <br>  esta solu√ß√£o de unidades-dezenas-centenas de quilowatts e pat√©tico 2-3 mA n√£o desempenhar√° um papel aqui.  Bem, voc√™ n√£o precisa se lembrar toda vez que liga o rel√≥gio para algum tipo de SPI ou n√£o </li><li>  <i>InitPieCtrl ()</i> - a fun√ß√£o desativa todas as interrup√ß√µes e redefine os sinalizadores de interrup√ß√£o </li><li>  <i>InitPieVectTable ()</i> - a fun√ß√£o preenche a tabela com vetores de interrup√ß√£o </li></ul><br>  Na verdade, aqui est√° tudo inicializa√ß√£o.  Eu acho que muitos notaram os "pontos importantes" associados √† fun√ß√£o <i>Delay</i> .  Por que cortamos na videira?  Sim, tudo √© simples - √© uma muleta. <br><br>  Os engenheiros de TI adicionaram esses atrasos completamente desnecess√°rios a algumas das fun√ß√µes, adicionadas em atualiza√ß√µes recentes.  Por que - um mist√©rio n√£o s√≥ para mim.  Registros e outras entradas cr√≠ticas j√° est√£o protegidos, portanto n√£o tornar√° nosso controlador est√∫pido.  A prop√≥sito, ao inicializar em eletr√¥nica de pot√™ncia, √© imposs√≠vel "embotar", caso contr√°rio, ser√£o mariquinhas.  Portanto, esque√ßa as fun√ß√µes de <i>atraso</i> e outros males para sempre, apenas temporizadores!  Atrasos s√£o permitidos apenas para alguns fins educacionais, por exemplo, piscando rapidamente com um LED. <br><br>  Para verificar se o c√≥digo est√° funcionando, chamamos a fun√ß√£o de inicializa√ß√£o em main, compile, flash e <b>hook</b> no oscilosc√≥pio <b>GPIO18</b> .  Este pino √© semelhante ao MCO do STM32, o que significa que emite a frequ√™ncia do sistema.  Um oscilosc√≥pio deve ver um sinal com uma frequ√™ncia de 56 MHz.  Se o oscilosc√≥pio for bom, voc√™ ver√° o meandro, se o chin√™s (at√© bom), provavelmente ser√° algo mais pr√≥ximo do seno.  A configura√ß√£o do GPIO18 na frequ√™ncia do sistema de sa√≠da pode ser vista na fun√ß√£o <i>InitPeripheralClocks ()</i> .  Primeiro, voc√™ precisa ‚Äúconectar‚Äù o gpio √† sa√≠da de frequ√™ncia e depois definir o divisor para 1: <br><br><pre> <code class="cpp hljs"> GpioCtrlRegs.GPAMUX2.bit.GPIO18 = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GPIO18 = XCLKOUT SysCtrlRegs.XCLK.bit.XCLKOUTDIV=2; // Set XCLKOUT = SYSCLKOUT/1</span></span></code> </pre><br><h2>  Configura√ß√£o GPIO </h2><br>  Para trabalhar com essa fam√≠lia, precisamos apenas de um manual de refer√™ncia, que os desenvolvedores de TI dividiram em v√°rios arquivos, cada um dos quais descreve uma certa periferia, o que √© muito conveniente.  Fa√ßa o download da folha de dados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e v√° para a se√ß√£o <i>Suporte</i> da <i>documenta√ß√£o</i> na p√°gina 126. Aqui vemos um conjunto de links para a documenta√ß√£o com sua breve descri√ß√£o: errata, um guia para iniciar o gerenciamento do mecanismo e guias em cada periferia.  Estamos interessados ‚Äã‚Äãem um documento chamado <b>Guia de Refer√™ncia de Controle e Interrup√ß√µes do Sistema TMS320F2802x / TMS320F2802xx</b> , que cont√©m a descri√ß√£o do GPIO e outras configura√ß√µes b√°sicas do sistema que nos interessam.  Observamos o diagrama de blocos do GPIO: <br><br> <a href=""><img src="https://habrastorage.org/webt/vp/uu/29/vpuu29qhryyngpm2thgtvtquoeo.png"></a> <br><br>  Vemos uma imagem bastante familiar das portas de entrada / sa√≠da do dispositivo.  Aqui e a capacidade de ativar o suspender interno e o uso de um sinal com o GPIO para interrup√ß√µes e outras comodidades.  A principal caracter√≠stica desse perif√©rico no C2000 √© a possibilidade de suprimir interfer√™ncias de hardware, por exemplo, o barulho de contatos mec√¢nicos de um bot√£o.  Vejamos um diagrama interessante: <br><br><img src="https://habrastorage.org/webt/gu/zj/ym/guzjymm5gq08m1gar1284zobjx8.png"><br><br>  Ele mostra o princ√≠pio de ler o status das entradas.  Na maioria dos controladores, o estado de entrada √© lido com a frequ√™ncia de clock dessa periferia, ou seja, por padr√£o com uma frequ√™ncia de 56 MHz no nosso caso, e para o mesmo stm nas fam√≠lias mais antigas, essas frequ√™ncias s√£o ainda mais altas.  Acho que todo mundo entende que, com essa frequ√™ncia, o controlador tem tempo para "ver" qualquer interfer√™ncia e ru√≠do.  √Äs vezes, essa frequ√™ncia √© necess√°ria e, √†s vezes, n√£o, por exemplo, se precisarmos pressionar um bot√£o.  Por que a entrevistar√≠amos a cada 18 anos?  Portanto, percebemos a possibilidade de reduzir a frequ√™ncia de clock de uma porta espec√≠fica usando o registro <i>CTRL</i> e os bits <i>QUALPRDx</i> , onde X assume um valor de 0 a 3: QUALPRD0 √© respons√°vel por GPIO0 ... 7, QUALPRD1 √© respons√°vel por GPIO8 ... 15 e assim por diante.  De fato, este √© um divisor de frequ√™ncia comum com um coeficiente de 1 a 510. <br><br><img src="https://habrastorage.org/webt/a5/ro/9e/a5ro9eq9hvvmomonnkm8ggkxzcq.png"><br><br>  Geralmente n√£o faz sentido interrogar um bot√£o, portanto ajustaremos o divisor para 510, ou seja, ao m√°ximo.  N√≥s olhamos novamente para o diagrama e vemos que o sinal √© considerado est√°vel somente quando seu n√≠vel n√£o foi alterado por 6 tiques.  O n√∫mero de medidas necess√°rias para a fixa√ß√£o pode ser 1, 3 ou 6. <b>Quanto maior o divisor e mais ciclos fixamos, mais est√°vel √© a prote√ß√£o contra conversas.</b>  Quando h√° uma conversa de contatos, no in√≠cio ser√£o transi√ß√µes ca√≥ticas de 0 para 1 e vice-versa, quando a conversa passa e o sinal para e n√£o muda por 6 rel√≥gios, isso significa que o bot√£o √© pressionado.  Tudo engenhoso √© simples. <br><br>  Agora, vamos olhar para os principais registros, n√£o tocaremos em interrup√ß√µes - apenas nas configura√ß√µes das pr√≥prias portas.  Primeiro, voc√™ precisa dizer que os registros s√£o divididos em 2 tipos: <b>registros de</b> <b>configura√ß√£o</b> e <b>registros de dados</b> .  Os primeiros s√£o respons√°veis ‚Äã‚Äãpela configura√ß√£o das propriedades, por exemplo, essa entrada ou sa√≠da.  O segundo grupo √© respons√°vel por escrever e ler o status da porta. <br><br>  <u>Registros de instala√ß√£o:</u> <br><br><ul><li>  <i>GPxCTRL</i> - registre-se para escrever o divisor de rel√≥gio.  Em vez de "x", substitu√≠mos a letra "A" - se tivermos GPIO0 ... 31, "B" - se usarmos GPIO32 ... 63 e assim por diante </li><li>  <i>GPAQSELx</i> - registre para definir o n√∫mero de ticks para fixar o valor na entrada </li><li>  <i>GPAMUX1</i> √© um registro para a sele√ß√£o de perif√©ricos conectados, por exemplo, indica que GPIO ou UART, ou talvez PWM, est√£o no p√©. </li><li>  <i>GPADIR</i> - Registro de sele√ß√£o de dire√ß√£o GPIO: entrada ou sa√≠da.  Por padr√£o, todas as portas est√£o configuradas para entrada. </li><li>  <i>GPAPUD</i> √© o registro respons√°vel por conectar o suspensor interno ao VCC. <br>  Vale a pena notar que, para algumas portas, por padr√£o, o pull-up est√° desativado e, para uma parte, est√° ativado. <br>  Isso √© importante lembrar! </li></ul><br>  <u>Registradores de dados:</u> <br><br><ul><li>  <i>GPADAT</i> - registro de status de sa√≠da.  Se a sa√≠da estiver configurada para entrada, ent√£o lemos o status da entrada.  Se estiver configurado para uma sa√≠da, podemos escrever o valor que essa sa√≠da deve receber, ou seja, 0 ou 1 </li><li>  <i>GPASET</i> - registrador configurando a sa√≠da para "1".  Para definir como "1", voc√™ deve escrever "1", ao escrever "0" o comando √© ignorado </li><li>  <i>GPACLEAR</i> - registrador configurando a sa√≠da para "0".  Para definir como "0", voc√™ deve escrever "1", ao escrever "0" o comando √© ignorado </li><li>  <i>GPATOGGLE</i> √© um registro que inverte o valor atual do estado de sa√≠da.  Para inverter o valor, escreva ‚Äú1‚Äù; ao escrever ‚Äú0‚Äù, o comando √© ignorado </li></ul><br>  Aqui est√° um conjunto t√£o simples de registros.  Mesmo com a descri√ß√£o acima, voc√™ j√° pode entender o que precisa ser feito para configurar a porta, mas os engenheiros ou escritores t√©cnicos prudentes da TI fizeram outra instru√ß√£o passo a passo: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Eu direi imediatamente que as etapas 6 e 7 n√£o s√£o necess√°rias para n√≥s, porque  nem o c√£o nem a interrup√ß√£o s√£o usados ‚Äã‚Äãneste artigo.  Descreverei brevemente as etapas restantes para as pessoas que estudaram alem√£o na escola: <br><br><ul><li>  <i>Etapa 1</i> - determine a funcionalidade de sa√≠da: que ser√° uma entrada ou sa√≠da, <br>  gpio ou sa√≠da para outros perif√©ricos e outras coisas </li><li>  <i>Etapa 2</i> - ativar ou desativar o pull-up interno </li><li>  <i>Etapa 3</i> - configurar a prote√ß√£o de rel√≥gio e rejei√ß√£o para uma porta espec√≠fica </li><li>  <i>Etapa 4</i> - selecione a fun√ß√£o desejada: gpio ou perif√©ricos </li><li>  <i>Etapa 5</i> - defina a dire√ß√£o da sa√≠da: entrada ou sa√≠da </li></ul><br>  Essa √© toda a configura√ß√£o, como voc√™ v√™, √© elementar e logicamente clara.  Quero notar imediatamente que n√£o √© necess√°rio, nesta ordem, fazer configura√ß√µes, por exemplo, voc√™ pode definir a dire√ß√£o (entrada ou sa√≠da) no primeiro passo.  Isso n√£o importa. <br><br>  <b>Super importante!</b> <br><br>  Ao trabalhar com registros na fam√≠lia C2000, √© necess√°rio levar em considera√ß√£o o momento em que eles est√£o protegidos.  Tudo descrito abaixo se aplica principalmente aos registros do grupo de configura√ß√£o.  Se voc√™ analisou cuidadosamente as fun√ß√µes padr√£o, provavelmente viu comandos estranhos l√°: <b>EALLOW;</b>  e <b>EDIS;</b>  .  Comando <i>EALLOW</i> - remove a prote√ß√£o e fornece acesso ao trabalho com os registros do sistema.  Comando <i>EDIS</i> - ativa a prote√ß√£o traseira e fornece acesso ao trabalho com registros do sistema.  Ou seja, qualquer trabalho com registros do sistema SEMPRE deve ser assim: <br><br><pre> <code class="cpp hljs">EALLOW; <span class="hljs-comment"><span class="hljs-comment">//    ,   ,  EDIS;</span></span></code> </pre><br>  Essa opera√ß√£o n√£o √© necess√°ria se trabalharmos com registradores de dados, por exemplo, se <i>definirmos</i> nossa sa√≠da como "1" usando o registrador <i>GPxSET</i> , n√£o precisaremos remover a prote√ß√£o e, consequentemente, ativ√°-lo novamente.  A documenta√ß√£o em toda parte diz o que precisa ser protegido e o que n√£o √©, por exemplo, assim: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Com base em tudo isso, vamos configurar o GPIO0 ... 3 com LEDs para sa√≠da.  Sugiro colocar todas as configura√ß√µes do GPIO na fun√ß√£o <i>InitLEDgpio</i> e escrever: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; }</code> </pre><br>  Por padr√£o, nossos GPIOs j√° est√£o configurados como GPIOs, como  todos os valores do registro s√£o limpos, o que significa que ‚Äú0‚Äù j√° est√° gravado no registro GPAMUX1.  Para GPIO0 ... 11, o pull-up √© desativado por padr√£o, para que possamos tomar e determinar a dire√ß√£o do trabalho at√© a sa√≠da usando GPADIR.  Se voc√™ se lembrar, os LEDs s√£o conectados ao controlador por c√°todos, o que significa que imediatamente ap√≥s a inicializa√ß√£o eles acender√£o.  Vamos definir essas conclus√µes diretamente na fun√ß√£o de inicializa√ß√£o como "1": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Como voc√™ pode ver, n√£o uso o registro <i>GPADAT</i> para escrever, mas uso <i>SET, CLEAR, TOGGLE</i> .  Observe tamb√©m que eu fiz essa entrada fora da zona protegida, ou seja, ap√≥s o comando <i>EDIS</i> .  Agora, na mesma fun√ß√£o, configure o GPIO12 para trabalhar com o bot√£o e adicione nossa fun√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPAPUD.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPACTRL.bit.QUALPRD1 = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; GpioCtrlRegs.GPAQSEL1.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">2</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Antes de tudo, desative o aperto interno escrevendo "1" no registro <i>GPAPUD</i> , porque  √© ativado pelo GPIO12 por padr√£o.  Como escrevi anteriormente, todas as portas ap√≥s a inicializa√ß√£o s√£o configuradas para entrada, como  zeros s√£o escritos no registro <i>GPADIR</i> , n√£o o configuramos aqui. <br><br>  Resta configurar a prote√ß√£o contra rejei√ß√£o, para isso dividimos os divisores <i>0xFF</i> , que corresponde ao valor / 510.  No registro <i>GPAQSEL1</i> , escrevemos o valor ‚Äú10‚Äù ou 2, que define o valor para uma amostra de 6 medidas.  Feito!  Para ler o valor de uma entrada espec√≠fica, voc√™ s√≥ precisa ler o valor do registro <i>GPADAT</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GpioDataRegs.GPADAT.bit.GPIO12) { <span class="hljs-comment"><span class="hljs-comment">//      +3.3 (. 1)  ,     }</span></span></code> </pre><br>  √â assim que interrogamos as conclus√µes necess√°rias.  Agora vamos chamar a fun√ß√£o de configura√ß√£o gpio em nossa fun√ß√£o principal e obter sua forma final: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLMUL, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); <span class="hljs-comment"><span class="hljs-comment">/*********************************/</span></span> InitLEDgpio(); }</code> </pre><br>  Agora chamamos a fun√ß√£o <i>InitStartSystem</i> no corpo principal do programa em main e isso completa a configura√ß√£o.  N√≥s obtemos o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { } }</span></span></code> </pre><br>  √â hora de escrever nosso primeiro programa de teste e testar tudo isso.  O algoritmo √© este: o LED que fica no GPIO3 pisca e, quando voc√™ pressiona o bot√£o no GPIO12, simplesmente acendemos o LED GPIO0.  Assim, verificaremos o funcionamento das portas para entrada e sa√≠da.  Escrevemos o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (GpioDataRegs.GPADAT.bit.GPIO12) { GpioDataRegs.GPACLEAR.bit.GPIO0 = 1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { GpioDataRegs.GPASET.bit.GPIO0 = 1; } GpioDataRegs.GPATOGGLE.bit.GPIO3 = 1; delay(100000); } }</span></span></code> </pre><br>  N√≥s compilamos, vamos ao depurador, inici√°-lo e ver como um LED pisca constantemente e, quando voc√™ pressiona o bot√£o, outro acende.  No final da se√ß√£o, anexarei um projeto com esse c√≥digo; se algo n√£o der certo, analise-o.  Especialmente para quem √© exigente em textos ou n√£o entendeu todos os pontos, sugiro que assista a este v√≠deo sobre como trabalhar com o GPIO, tudo est√° acontecendo l√°, como na se√ß√£o "GPIO".  Eu aviso que o v√≠deo por uma hora, sombrio, longo, mas o mais detalhado poss√≠vel e tudo √© vis√≠vel: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jlyVy73pa98" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Arquivos do artigo </h2><br><ul><li>  Arquivo com o projeto para o CCS7 fa√ßa o download <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> </li><li>  Voc√™ pode ver o c√≥digo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> </li></ul><br><h2>  Sum√°rio </h2><br>  Nesta fase, estou terminando o artigo de hoje.  Eu acho que voc√™ entendeu que, se eu decidisse imediatamente mostrar a implementa√ß√£o do inversor DC / CA, o artigo teria sido v√°rias vezes maior ou muitos detalhes importantes simplesmente permaneceriam nos bastidores, o que, na minha opini√£o, √© inaceit√°vel. <br><br>  Espero que meu artigo ajude todos a iniciar o desenvolvimento dessa fam√≠lia de controladores e a desenvolver no campo da eletr√¥nica de pot√™ncia e das m√°quinas-ferramentas.  No futuro, provavelmente escreverei algo mais sobre esse t√≥pico, por exemplo, gostaria de considerar trabalhar com o PWM ou implementar algum tipo de algoritmo.  O principal √© ter tempo. <br><br>  Se voc√™ tiver alguma d√∫vida ou se algo n√£o der certo para voc√™, escreva-me em mensagens privadas. Tentarei responder √†s suas perguntas e fornecer toda a assist√™ncia poss√≠vel no estudo.  Desejo-lhe sucesso nos treinamentos! <br><br>  <b>UPD</b>  Obrigado pela dica da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">BelerafonL</a> no livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Sistemas de controle digital embarcados de alto desempenho"</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt410161/">https://habr.com/ru/post/pt410161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt410149/index.html">Como negociar no Skype e telefone em ingl√™s: instru√ß√µes e frases √∫teis</a></li>
<li><a href="../pt410153/index.html">A Idade M√©dia Sacanagem</a></li>
<li><a href="../pt410155/index.html">Bandagem que d√° vida n√£o remov√≠vel</a></li>
<li><a href="../pt410157/index.html">Intel mostrou √≥culos inteligentes nos quais a imagem √© transmitida para a retina</a></li>
<li><a href="../pt410159/index.html">Como um smartphone pode escutar, espiar e rastrear</a></li>
<li><a href="../pt410163/index.html">[CASE] Impress√£o 3D na ind√∫stria leve, no exemplo do FullPower</a></li>
<li><a href="../pt410167/index.html">Como a sujeira pode salvar a humanidade de um apocalipse infeccioso</a></li>
<li><a href="../pt410169/index.html">[CASE] Como fizemos o layout do pr√©dio da Novo Nordisk</a></li>
<li><a href="../pt410171/index.html">Os rob√¥s de DNA viral foram programados para bloquear vasos sangu√≠neos humanos e matar tumores cancer√≠genos.</a></li>
<li><a href="../pt410173/index.html">Yandex tendencioso compila suas principais not√≠cias, disse que a den√∫ncia enviada √† FAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>