<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïπÔ∏è ‚¨áÔ∏è ü§úüèº Node.js und Server-Rendering in Airbnb ‚ò¢Ô∏è üêΩ ‚úçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, widmet sich der Geschichte, wie Airbnb die Serverteile von Webanwendungen optimiert, um de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js und Server-Rendering in Airbnb</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418009/">  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, widmet sich der Geschichte, wie Airbnb die Serverteile von Webanwendungen optimiert, um den zunehmenden Einsatz von Server-Rendering-Technologien zu ber√ºcksichtigen.  Im Laufe mehrerer Jahre hat das Unternehmen sein gesamtes Front-End schrittweise auf eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einheitliche</a> Architektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgestellt</a> , nach der Webseiten hierarchische Strukturen von React-Komponenten sind, die mit Daten aus ihrer API gef√ºllt sind.  Insbesondere w√§hrend dieses Prozesses wurde Ruby on Rails systematisch aufgegeben.  Tats√§chlich plant Airbnb, auf einen neuen Dienst umzusteigen, der ausschlie√ülich auf Node.js basiert. Dank dessen werden vollst√§ndig vorbereitete Seiten, die auf dem Server gerendert werden, an die Browser der Benutzer geliefert.  Dieser Service generiert den gr√∂√üten Teil des HTML-Codes f√ºr alle Airbnb-Produkte.  Die betreffende Rendering-Engine unterscheidet sich von den meisten Backend-Diensten des Unternehmens dadurch, dass sie nicht in Ruby oder Java geschrieben ist.  Es unterscheidet sich jedoch von den traditionellen hoch geladenen Node.js-Diensten, auf denen die in Airbnb verwendeten mentalen Modelle und Hilfstools basieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/rg/zm/64/rgzm64dbdvumj6ycekqpoxbqxhw.png"></a> <br><a name="habracut"></a><br>
<h2>  <font color="#3AC1EF">Node.js Plattform</font> </h2><br>  Wenn Sie an die Node.js-Plattform denken, k√∂nnen Sie sich vorstellen, wie eine bestimmte Anwendung, die unter Ber√ºcksichtigung der Funktionen dieser Plattform f√ºr die asynchrone Datenverarbeitung erstellt wurde, schnell und effizient Hunderte oder Tausende paralleler Verbindungen bedient.  Der Service holt die ben√∂tigten Daten von √ºberall her und verarbeitet sie ein wenig, damit sie den Anforderungen einer gro√üen Anzahl von Kunden entsprechen.  Der Inhaber einer solchen Anwendung hat keinen Grund, sich zu beschweren, er ist √ºberzeugt von dem von ihm verwendeten leichten Modell der gleichzeitigen Datenverarbeitung (in diesem Material verwenden wir das Wort "simultan", um den Begriff "gleichzeitig" f√ºr den Begriff "parallel" - "parallel" zu vermitteln).  Sie l√∂st die f√ºr sie gestellte Aufgabe perfekt. <br><br>  Server Side Rendering (SSR) √§ndert die Grundideen und f√ºhrt zu einer √§hnlichen Vision des Problems.  Das Rendern von Servern erfordert daher viele Rechenressourcen.  Der Code in der Node.js-Umgebung wird in einem einzelnen Thread ausgef√ºhrt. Daher kann der Code zur L√∂sung von Rechenproblemen (im Gegensatz zu E / A-Aufgaben) gleichzeitig, jedoch nicht parallel ausgef√ºhrt werden.  Die Node.js-Plattform kann eine gro√üe Anzahl paralleler E / A-Vorg√§nge verarbeiten. Beim Rechnen √§ndert sich jedoch die Situation. <br><br>  Da beim Anwenden von serverseitigem Rendering der rechnerische Teil der Anforderungsverarbeitungsaufgabe im Vergleich zu dem Teil, der sich auf Eingabe / Ausgabe bezieht, zunimmt, wirken sich gleichzeitig eingehende Anforderungen auf die Serverantwortgeschwindigkeit aus, da sie um Prozessorressourcen konkurrieren.  Es ist zu beachten, dass bei Verwendung von asynchronem Rendering weiterhin ein Wettbewerb um Ressourcen besteht.  Asynchrones Rendern l√∂st die Reaktionsf√§higkeit eines Prozesses oder Browsers, verbessert jedoch nicht die Situation durch Verz√∂gerungen oder Parallelit√§t.  In diesem Artikel konzentrieren wir uns auf ein einfaches Modell, das ausschlie√ülich Rechenlasten enth√§lt.  Wenn es sich um eine gemischte Last handelt, die sowohl Eingabe- / Ausgabe- als auch Berechnungsoperationen umfasst, erh√∂hen gleichzeitig eingehende Anforderungen die Verz√∂gerung, ber√ºcksichtigen jedoch den Vorteil eines h√∂heren Systemdurchsatzes. <br><br>  Betrachten Sie einen Befehl der Form <code>Promise.all([fn1, fn2])</code> .  Wenn <code>fn1</code> oder <code>fn2</code> Versprechen sind, die vom E / A-Subsystem aufgel√∂st werden, ist es w√§hrend der Ausf√ºhrung dieses Befehls m√∂glich, eine parallele Ausf√ºhrung von Operationen zu erreichen.  Es sieht so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96e/6f8/d81/96e6f8d8187475775542576cabbc51ca.png"></div><br>  <i><font color="#999999">Parallele Ausf√ºhrung von Operationen mittels des Eingabe / Ausgabe-Subsystems</font></i> <br><br>  Wenn <code>fn1</code> und <code>fn2</code> Rechenaufgaben sind, werden sie wie folgt ausgef√ºhrt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e8/03d/803/8e803d80347cb302f3e86af0bbcd1e84.png"></div><br>  <i><font color="#999999">Rechenaufgaben</font></i> <br><br>  Eine der Operationen muss auf den Abschluss der zweiten Operation warten, da in Node.js nur ein Thread vorhanden ist. <br><br>  Beim Rendern von Servern tritt dieses Problem auf, wenn der Serverprozess mehrere gleichzeitige Anforderungen verarbeiten muss.  Die Verarbeitung solcher Anfragen wird verz√∂gert, bis fr√ºher eingegangene Anfragen bearbeitet werden.  So sieht es aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/135/03e/54f/13503e54f4aa44cd1481c0848e7406c7.png"></div><br>  <i><font color="#999999">Gleichzeitige Anforderungen verarbeiten</font></i> <br><br>  In der Praxis besteht die Anforderungsverarbeitung h√§ufig aus vielen asynchronen Phasen, selbst wenn sie eine ernsthafte Rechenlast f√ºr das System bedeuten.  Dies kann zu einer noch schwierigeren Situation f√ºhren, wenn Aufgaben f√ºr die Verarbeitung solcher Anforderungen gewechselt werden. <br><br>  Angenommen, unsere Abfragen bestehen aus einer Task-Kette, die dieser √§hnelt: <code>renderPromise().then(out =&gt; formatResponsePromise(out)).then(body =&gt; res.send(body))</code> .  Wenn ein Paar solcher Anforderungen mit einem kleinen Intervall zwischen ihnen im System eintrifft, k√∂nnen wir das folgende Bild beobachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/958/ecf/070/958ecf0704405b06a60e230631ac7730.png"></div><br>  <i><font color="#999999">Verarbeitungsanforderungen, die in einem kleinen Intervall eintreffen, sind das Problem des Kampfes um Prozessorressourcen</font></i> <br><br>  In diesem Fall dauert die Verarbeitung jeder Anforderung etwa doppelt so lange wie die Verarbeitung einer einzelnen Anforderung.  Mit zunehmender Anzahl gleichzeitig verarbeiteter Anfragen wird die Situation noch schlimmer. <br><br>  Dar√ºber hinaus ist eines der typischen Ziele der SSR-Implementierung die M√∂glichkeit, denselben oder einen sehr √§hnlichen Code sowohl auf dem Client als auch auf dem Server zu verwenden.  Der wesentliche Unterschied zwischen diesen Umgebungen besteht darin, dass die Clientumgebung im Wesentlichen eine Umgebung ist, in der ein Client ausgef√ºhrt wird, und Serverumgebungen naturgem√§√ü Multi-Client-Umgebungen sind.  Was auf dem Client gut funktioniert, wie Singletones oder andere Ans√§tze zum Speichern des globalen Status der Anwendung, f√ºhrt zu Fehlern, Datenlecks und im Allgemeinen zu Verwirrung, w√§hrend viele auf dem Server eingehende Anforderungen verarbeitet werden. <br><br>  Diese Funktionen werden zu Problemen in einer Situation, in der Sie mehrere Anforderungen gleichzeitig verarbeiten m√ºssen.  In einer gem√ºtlichen Umgebung der Entwicklungsumgebung, die von einem Client in der Person eines Programmierers verwendet wird, funktioniert normalerweise alles unter normalen Belastungen ganz normal. <br><br>  Dies f√ºhrt zu einer Situation, die sich stark von den klassischen Anwendungsbeispielen f√ºr Node.j unterscheidet.  Es sollte beachtet werden, dass wir die JavaScript-Laufzeit f√ºr die zahlreichen verf√ºgbaren Bibliotheken verwenden, und zwar aufgrund der Tatsache, dass sie von Browsern unterst√ºtzt wird, und nicht aufgrund ihres Modells f√ºr die gleichzeitige Datenverarbeitung.  In dieser Anwendung zeigt das asynchrone Modell der gleichzeitigen Datenverarbeitung alle seine Nachteile, die nicht durch Vorteile kompensiert werden, die entweder sehr gering oder √ºberhaupt nicht sind. <br><br><h2>  <font color="#3AC1EF">Hypernova-Projekt-Tutorials</font> </h2><br>  Unser neuer Rendering-Service Hyperloop wird der prim√§re Service sein, mit dem Airbnb-Benutzer interagieren.  Daher spielen Zuverl√§ssigkeit und Leistung eine entscheidende Rolle, um die Arbeit mit einer Ressource zu vereinfachen.  Bei der Einf√ºhrung von Hyperloop in die Produktion ber√ºcksichtigen wir die Erfahrungen, die wir bei der Arbeit mit unserem fr√ºheren Server-Rendering-System <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hypernova</a> gesammelt haben. <br><br>  Hypernova funktioniert nicht wie unser neuer Service.  Dies ist ein reines Rendering-System.  Es wird von unserem monolithischen Rail-Dienst namens Monorail aufgerufen und gibt nur HTML-Snippets f√ºr bestimmte gerenderte Komponenten zur√ºck.  In vielen F√§llen stellt dieses ‚ÄûSnippet‚Äú den L√∂wenanteil der Seite dar, und Rails stellt nur das Seitenlayout bereit.  Mit der Legacy-Technologie k√∂nnen Teile einer Seite mithilfe von ERB miteinander verkn√ºpft werden.  In jedem Fall l√§dt Hypernova jedoch keine Daten, die zum Erstellen der Seite erforderlich sind.  Dies ist die Aufgabe von Rails. <br><br>  Somit haben Hyperloop und Hypernova eine √§hnliche Rechenleistung.  Gleichzeitig bietet Hypernova als Produktionsdienstleister und f√ºr die Verarbeitung erheblicher Verkehrsmengen ein gutes Testfeld, um zu verstehen, wie sich der Hypernova-Ersatz unter Kampfbedingungen verh√§lt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cee/51a/2f7/cee51a2f7e198d242ce8e5294f4e972f.png"></div><br>  <i><font color="#999999">Hypernova-Workflow</font></i> <br><br>  So funktioniert Hypernova  Benutzeranfragen gehen an unsere Rails-Hauptanwendung Monorail, die die Eigenschaften der React-Komponenten sammelt, die auf einer Seite angezeigt werden m√ºssen, und eine Anfrage an Hypernova sendet, wobei diese Eigenschaften und Komponentennamen √ºbergeben werden.  Hypernova rendert Komponenten mit Eigenschaften, um den HTML-Code zu generieren, der an die Monorail-Anwendung zur√ºckgegeben werden muss, die diesen Code dann in die Seitenvorlage einbettet und alles an den Client zur√ºcksendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/d7d/35b/86dd7d35b582f66de058a0aa60f5ad0a.png"></div><br>  <i><font color="#999999">Senden einer fertigen Seite an einen Client</font></i> <br><br>  Im Notfall (dies kann ein Fehler oder ein Antwortzeitlimit sein) in Hypernova gibt es eine Fallback-Option, bei der die Komponenten und ihre Eigenschaften ohne den auf dem Server generierten HTML-Code in die Seite eingebettet werden. Danach wird alles an den Client gesendet und dort gerendert hoffentlich erfolgreich.  Dies f√ºhrte uns zu der Tatsache, dass wir den Hypernova-Dienst nicht als kritischen Teil des Systems betrachteten.  Infolgedessen k√∂nnten wir das Auftreten einer bestimmten Anzahl von Fehlern und Situationen zulassen, in denen eine Zeit√ºberschreitung ausgel√∂st wird.  Durch Anpassen der Anforderungszeitlimits setzen wir sie basierend auf den Beobachtungen auf ungef√§hr Stufe P95.  Daher ist es nicht √ºberraschend, dass das System mit einer Basis-Timeout-Antwortrate von weniger als 5% arbeitete. <br><br>  In Situationen, in denen der Verkehr Spitzenwerte erreichte, konnten wir feststellen, dass bis zu 40% der Anfragen an Hypernova durch Zeit√ºberschreitungen in der Einschienenbahn geschlossen wurden.  Auf der Hypernova-Seite haben wir Spitzen von <code>BadRequestError: Request aborted</code> geringerer H√∂he an.  Diese Fehler traten au√üerdem unter normalen Bedingungen auf, w√§hrend im normalen Betrieb aufgrund der Architektur der L√∂sung die verbleibenden Fehler nicht besonders auff√§llig waren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/746/8c1/192/7468c11924fcf883eb3a6e73c734a263.png"></div><br>  <i><font color="#999999">Spitzenzeitlimitwerte (rote Linien)</font></i> <br><br>  Da unser System ohne Hypernova funktionieren k√∂nnte, haben wir diesen Funktionen nicht viel Aufmerksamkeit geschenkt. Sie wurden eher als st√∂rende Kleinigkeiten als als ernsthafte Probleme wahrgenommen.  Wir haben diese Probleme durch die Funktionen der Plattform erkl√§rt, da der Start der Anwendung aufgrund des ziemlich schwierigen anf√§nglichen Speicherbereinigungsvorgangs, aufgrund der Besonderheiten der Codekompilierung und des Daten-Caching und aus anderen Gr√ºnden langsam ist.  Wir hatten gehofft, dass die neuen React- oder Node-Versionen Leistungsverbesserungen enthalten w√ºrden, die die M√§ngel des langsamen Starts des Dienstes abmildern w√ºrden. <br><br>  Ich vermutete, dass das, was geschah, sehr wahrscheinlich auf einen schlechten Lastausgleich oder die Folge von Problemen bei der Bereitstellung der L√∂sung zur√ºckzuf√ºhren war, als sich zunehmende Verz√∂gerungen aufgrund einer √ºberm√§√üigen Rechenlast f√ºr die Prozesse zeigten.  Ich habe dem System eine zus√§tzliche Schicht hinzugef√ºgt, um Informationen √ºber die Anzahl der gleichzeitig von einzelnen Prozessen verarbeiteten Anforderungen zu protokollieren und F√§lle aufzuzeichnen, in denen der Prozess mehr als eine Anforderung zur Verarbeitung erhalten hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/5c2/70c/ce15c270c4ccdcd301f40fad7312e769.png"></div><br>  <i><font color="#999999">Forschungsergebnisse</font></i> <br><br>  Wir betrachteten den langsamen Start des Dienstes als Schuld an den Verz√∂gerungen, aber tats√§chlich wurde das Problem durch parallele Anforderungen verursacht, die um die CPU-Zeit k√§mpften.  Den Messergebnissen zufolge stellte sich heraus, dass die von der Anforderung im Vorgriff auf den Abschluss der Verarbeitung anderer Anforderungen aufgewendete Zeit der f√ºr die Verarbeitung der Anforderung aufgewendeten Zeit entspricht.  Dar√ºber hinaus bedeutete dies, dass eine Zunahme der Verz√∂gerungen aufgrund der gleichzeitigen Verarbeitung von Anforderungen gleichbedeutend mit einer Zunahme der Verz√∂gerungen aufgrund einer Zunahme der Rechenkomplexit√§t des Codes ist, was zu einer Zunahme der Systemlast bei der Verarbeitung jeder Anfrage f√ºhrt. <br><br>  Dies machte au√üerdem deutlicher, dass der <code>BadRequestError: Request aborted</code> nicht sicher durch einen langsamen Systemstart erkl√§rt werden konnte.  Der Fehler ging vom Parsing-Code des Anforderungshauptteils aus und trat auf, als der Client die Anforderung abbrach, bevor der Server den Anforderungshauptteil vollst√§ndig lesen konnte.  Der Client hat aufgeh√∂rt zu arbeiten, die Verbindung geschlossen und uns die Daten entzogen, die erforderlich sind, um die Anforderung weiter zu verarbeiten.  Es ist viel wahrscheinlicher, dass dies geschah, weil wir mit der Verarbeitung der Anforderung begonnen haben. Danach stellte sich heraus, dass die Ereignisschleife ein blockiertes Rendering f√ºr eine andere Anforderung war, und wir kehrten dann zur unterbrochenen Aufgabe zur√ºck, um sie abzuschlie√üen. Als Ergebnis stellte sich jedoch heraus, dass der Client Wer uns diese Anfrage gesendet hat, hat bereits die Verbindung getrennt und die Anfrage abgebrochen.  Dar√ºber hinaus waren die in Anfragen an Hypernova √ºbermittelten Daten im Durchschnitt im Bereich von mehreren hundert Kilobyte recht umfangreich, und dies trug nat√ºrlich nicht zur Verbesserung der Situation bei. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b4/b62/bc6/0b4b62bc6a1b5e902413711b0d3272e0.png"></div><br>  <i><font color="#999999">Ein Fehler, der durch das Trennen eines Clients verursacht wurde, der nicht auf eine Antwort gewartet hat</font></i> <br><br>  Wir haben uns entschlossen, dieses Problem mit einigen Standardwerkzeugen zu l√∂sen, mit denen wir betr√§chtliche Erfahrung hatten.  Es handelt sich um einen Reverse-Proxy-Server ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nginx</a> ) und einen Load Balancer ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HAProxy</a> ). <br><br><h2>  <font color="#3AC1EF">Reverse Proxy und Load Balancing</font> </h2><br>  Um die Multi-Core-Prozessorarchitektur zu nutzen, f√ºhren wir mehrere Hypernova-Prozesse mit dem integrierten Node.js- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clustermodul aus</a> .  Da diese Prozesse unabh√§ngig sind, k√∂nnen wir eingehende Anfragen gleichzeitig verarbeiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9df/cbe/aae/9dfcbeaae2d82fa13007670288d8b461.png"></div><br>  <i><font color="#999999">Parallele Verarbeitung von gleichzeitig eintreffenden Anfragen</font></i> <br><br>  Das Problem hierbei ist, dass jeder Knotenprozess die ganze Zeit √ºber voll besch√§ftigt ist, um eine Anforderung zu verarbeiten, einschlie√ülich des Lesens des Hauptteils der vom Client gesendeten Anforderung (Monorail spielt in diesem Fall seine Rolle).  Obwohl wir viele Abfragen in einem einzigen Prozess gleichzeitig lesen k√∂nnen, f√ºhrt dies beim Rendern zu einer Abwechslung der Rechenoperationen. <br><br>  Die Verwendung von Knotenprozessressourcen ist an die Client- und Netzwerkgeschwindigkeit gebunden. <br><br>  Als L√∂sung f√ºr dieses Problem k√∂nnen wir einen puffernden Reverse-Proxy-Server in Betracht ziehen, mit dem wir Kommunikationssitzungen mit Clients aufrechterhalten k√∂nnen.  Die Inspiration f√ºr diese Idee war der Einhorn-Webserver, den wir f√ºr unsere Rails-Anwendungen verwenden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die</a> vom Einhorn erkl√§rten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzipien</a> erkl√§ren perfekt, warum dies so ist.  Zu diesem Zweck haben wir Nginx verwendet.  Nginx liest die Anforderung vom Client in den Puffer und leitet die Anforderung erst an den Knotenserver weiter, nachdem sie vollst√§ndig gelesen wurde.  Diese Daten√ºbertragungssitzung wird auf dem lokalen Computer √ºber die Loopback-Schnittstelle oder mithilfe von Unix-Dom√§nensockets durchgef√ºhrt. Dies ist viel schneller und zuverl√§ssiger als die Daten√ºbertragung zwischen separaten Computern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/50e/77b/a2050e77b5ff48219773729978481244.png"></div><br>  <i><font color="#999999">Nginx puffert Anforderungen und sendet sie dann an den Knotenserver</font></i> <br><br>  Aufgrund der Tatsache, dass nginx jetzt Leseanfragen bearbeitet, konnten wir eine gleichm√§√üigere Beladung der Knotenprozesse erreichen. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/eb0/875/beaeb08758e4926cb3072670993f606f.png"></div><br>  <i><font color="#999999">Gleichm√§√üige Prozessbelastung mit Nginx</font></i> <br><br>  Dar√ºber hinaus haben wir nginx verwendet, um einige Anforderungen zu verarbeiten, f√ºr die kein Zugriff auf Knotenprozesse erforderlich ist.  Die Erkennungs- und Routingschicht unseres Dienstes verwendet <code>/ping</code> Anforderungen, die das System nicht stark belasten, um die Kommunikation zwischen Hosts zu √ºberpr√ºfen.  Durch die Verarbeitung all dessen in Nginx wird eine erhebliche zus√§tzliche (wenn auch geringe) Arbeitslast f√ºr Node.js vermieden. <br><br>  Die n√§chste Verbesserung betrifft den Lastausgleich.  Wir m√ºssen fundierte Entscheidungen √ºber die Verteilung von Anforderungen zwischen Knotenprozessen treffen.  Das <code>cluster</code> Modul verteilt Anforderungen gem√§√ü dem Round-Robin-Algorithmus, in den meisten F√§llen mit Versuchen, Prozesse zu umgehen, die nicht auf Anforderungen reagieren.  Bei diesem Ansatz erh√§lt jeder Prozess eine Anforderung in der Reihenfolge ihrer Priorit√§t. <br><br>  Das <code>cluster</code> Modul verteilt Verbindungen, keine Anforderungen, sodass dies alles nicht wie erforderlich funktioniert.  Die Situation wird noch schlimmer, wenn dauerhafte Verbindungen verwendet werden.  Jede permanente Verbindung vom Client ist an einen bestimmten Workflow gebunden, was die effiziente Verteilung von Aufgaben erschwert. <br><br>  Der Round-Robin-Algorithmus ist gut, wenn die Anforderungsverz√∂gerungen nur geringf√ºgig variieren.  Zum Beispiel in der unten dargestellten Situation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/883/4f2/ed5/8834f2ed56f7410de5f306f15e66e5e9.png"></div><br>  <i><font color="#999999">Round-Robin-Algorithmus und Verbindungen, √ºber die Anforderungen stabil empfangen werden</font></i> <br><br>  Dieser Algorithmus ist bereits nicht so gut, wenn Sie Anforderungen unterschiedlicher Art verarbeiten m√ºssen, f√ºr deren Verarbeitung m√∂glicherweise v√∂llig unterschiedliche Zeitkosten erforderlich sind.  Die letzte an einen bestimmten Prozess gesendete Anforderung muss warten, bis alle zuvor gesendeten Anforderungen verarbeitet wurden, selbst wenn ein anderer Prozess in der Lage ist, eine solche Anforderung zu verarbeiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/037/381/8c8/0373818c8632668b96f2ae77c32c9be2.png"></div><br>  <i><font color="#999999">Ungleichm√§√üige Prozesslast</font></i> <br><br>  Wenn Sie die oben gezeigten Abfragen rationaler verteilen, erhalten Sie so etwas wie die in der folgenden Abbildung gezeigte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a3/b32/9448a3b328094d81d73480e6b0e9d6d6.png"></div><br>  <i><font color="#999999">Rationale Verteilung von Anforderungen nach Threads</font></i> <br><br>  Mit diesem Ansatz wird das Warten minimiert und es wird m√∂glich, Antworten auf Anfragen schneller zu senden. <br><br>  Dies kann erreicht werden, indem Anforderungen in eine Warteschlange gestellt und nur dann einem Prozess zugewiesen werden, wenn keine andere Anforderung verarbeitet wird.  Zu diesem Zweck verwenden wir HAProxy. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fda/2cc/367/fda2cc367f401ef351cad7bff55a13ea.png"></div><br>  <i><font color="#999999">HAProxy und Prozesslastausgleich</font></i> <br><br>  Als wir HAProxy verwendet haben, um die Last auf Hypernova auszugleichen, haben wir Timeout-Peaks sowie <code>BadRequestErrors</code> Fehler vollst√§ndig eliminiert. <br><br>  Gleichzeitige Anforderungen waren auch die Hauptursache f√ºr Verz√∂gerungen w√§hrend des normalen Betriebs, und dieser Ansatz reduzierte solche Verz√∂gerungen.  Eine der Konsequenzen davon war, dass jetzt nur 2% der Anforderungen durch Timeout geschlossen wurden und nicht 5% mit denselben Timeout-Einstellungen.  Die Tatsache, dass wir es geschafft haben, von einer Situation mit 40% Fehlern zu einer Situation mit einer Zeit√ºberschreitung zu wechseln, die in 2% der F√§lle ausgel√∂st wurde, hat gezeigt, dass wir uns in die richtige Richtung bewegen.  Infolgedessen sehen unsere Benutzer heute den Ladebildschirm der Website viel seltener.  Es sollte beachtet werden, dass die Systemstabilit√§t f√ºr uns beim erwarteten √úbergang zu einem neuen System von besonderer Bedeutung sein wird, das nicht √ºber denselben Sicherungsmechanismus wie Hypernova verf√ºgt. <br><br><h2>  <font color="#3AC1EF">Details zum System und seinen Einstellungen</font> </h2><br>  Damit dies alles funktioniert, m√ºssen Sie die Anwendungen nginx, HAProxy und Node konfigurieren.  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel einer</a> √§hnlichen Anwendung, die Nginx und HAProxy verwendet und analysiert, welche Sie das Ger√§t des betreffenden Systems verstehen k√∂nnen.  Dieses Beispiel basiert auf dem System, das wir in der Produktion verwenden, es ist jedoch vereinfacht und modifiziert, so dass es im Auftrag eines nicht privilegierten Benutzers im Vordergrund ausgef√ºhrt werden kann.  In der Produktion sollte alles mit einem Supervisor konfiguriert werden (wir verwenden Runit oder h√§ufiger Kubernetes). <br><br>  <a href="">Die Nginx-Konfiguration ist</a> ziemlich Standard. Sie verwendet einen Server, der Port 9000 √ºberwacht und f√ºr Proxy-Anforderungen an den HAProxy-Server konfiguriert ist, der Port 9001 √ºberwacht (in unserer Konfiguration verwenden wir Unix-Dom√§nensockets). <br><br>  Dar√ºber hinaus f√§ngt dieser Server Anforderungen an den <code>/ping</code> Endpunkt ab, um Anforderungen zur √úberpr√ºfung der Netzwerkkonnektivit√§t direkt zu bearbeiten.         nginx ,     <code>worker_processes</code>  1,     nginx ‚Äî           HAProxy  Node-.  ,       ,    ,  Hypernova,     ( ).             . <br><br>  Node.js <code>cluster</code>        .        HAProxy,        <code>cluster</code> ,    .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pool-hall</a> .  ‚Äî ,        ,   ,   <code>cluster</code> ,        .  <a href=""></a>   <code>pool-hall</code>     ,      . <br><br>  <a href=""> HAProxy</a> ,     9001       ,    9002  9005.     ‚Äî <code>maxconn 1</code> ,     .          .       HAProxy (    8999). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/232/d95/515/232d95515b1541bccfab440f8fe12cc8.png"></div><br> <i><font color="#999999">  HAProxy</font></i> <br><br> HAProxy            .    ,    <code>maxconn</code> .    <code>static-rr</code> (static round-robin),  ,  ,       .   ,      round-robin, ,        , ,   ,     .     ,          ,   .      . <br><br> ,       ,        .       (   ).         ,   ,     ,   ,     .  ,                   ,        . <br><br><h2> <font color="#3AC1EF">  HAProxy</font> </h2><br>         HAProxy.       ,         ,    ,               .  ,    ,    (  )   .      ,        ,    <code>cluster</code> .     ,    . <br><br>       <code>ab</code> (Apache Benchmark)   10000   .       -   .       : <br><br><pre> <code class="hljs powershell">ab <span class="hljs-literal"><span class="hljs-literal">-l</span></span> <span class="hljs-literal"><span class="hljs-literal">-c</span></span> &lt;CONCURRENCY&gt; <span class="hljs-literal"><span class="hljs-literal">-n</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span> http://&lt;HOSTNAME&gt;:<span class="hljs-number"><span class="hljs-number">9000</span></span>/render</code> </pre> <br>     15    4-  -,    <code>ab</code>     ,        .       ( <code>concurrency=5</code> ),    ( <code>concurrency=13</code> ),     ,        ( <code>concurrency=20</code> ).      ,      . <br><br>         ,  -,      .          ,      .       ,  ,   ,     ,       .  ,     ,       ,     . <br><br>    ,   ‚Äî      . <br><br>     <code>maxconn 1</code>     ,  ,         . <br><br>      HTTP  TCP  ,    ,     ,  .   ,      <code>maxconn</code> ,       .     ,            ,          (, ,    ). <br><br>  ,         , ,   ,  ,      ,       . <br><br>    ‚Äî  ,     .    <code>option redispatch</code>    <code>retries 3</code> ,    ,          ,   , ,    ,   .            . <br><br>     ,  - ,       .        ,       .   ,          ,     .     100    ,        10 ,    ,    .        ,      .   ,            <code>accept</code> . <br><br>      ,        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">backlog</a> )    ,    .       SYN-ACK ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,   , ,        ACK  ).      ,      ,     ,       ,      . <br><br>      ,   ,    ,   ,       .    ,       ,      1.   <code>maxconn</code>                .     0  ,   ,     ,  ,           ,     .       ,     .         -  ,      ,         .  <code>abortonclose</code>        ,    .  ,        <code>abortonclose</code> .            nginx. <br><br>  ,     ,    .       (    )   ,       ,        ,     ,       ,  .  HAProxy          ,      ,        (       ).               ,     ,         ,    HTML.          ,   ,       .  ,       ,       (     ,  ,     ).            ,   ,            .   ,  ,   ,  .           HAProxy,            MAINT    HAProxy. <br><br>   ,     ,   ,  <code>server.close</code>  Node.js    ,     HAProxy   ,       ,      ,      .     ,     ,       ,     ,   ,     . <br><br>  ,  ,    <code>balance first</code> ,           (   <code>worker1</code> )        15%   ,    ,   ,     <code>balance static-rr</code> .        ,       ¬´¬ª .      .     (12 ),  , , -      .   ,  ,       ,   ¬´¬ª     ¬´¬ª.        . <br><br> , ,      Node <code>server.maxconnections</code> , ( ,   ),   ,  ,   ,         .        ,    <code>maxconnection</code> ,      ,  ,    .     JavaScript,          (        ).  ,    ,        ,          .  ,     ,   ,      HAProxy  Node    ,       .     ,        ,         . <br><br>   ,      ,   , , <a href=""></a> . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>     Node.js      .     , , ,    -.      Node.js    .   , ,       ,    ,   ,        , ,  nginx  HAProxy. <br><br> ,   Airbnb  ,   Node.js     . <br><br>  <b>Liebe Leser!</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie in Ihren Projekten serverseitiges Rendering? </font></font><br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418009/">https://habr.com/ru/post/de418009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417995/index.html">Geplante √Ñnderungen an FZ-152</a></li>
<li><a href="../de417997/index.html">Beginnen Sie mit sich selbst oder 60 Tage Kubuntu</a></li>
<li><a href="../de417999/index.html">Deutsch: Ingenieurperspektive</a></li>
<li><a href="../de418001/index.html">5 Modelle effektiver Teamarbeit</a></li>
<li><a href="../de418005/index.html">Softwareentwickler stimmen der Definition von ‚ÄûSpezialhardware‚Äú des FSB nicht zu</a></li>
<li><a href="../de418011/index.html">Einzelseiten und SEO. Optimierungsgeheimnisse</a></li>
<li><a href="../de418013/index.html">Der Intel Core i7-8086K (Teil 3)</a></li>
<li><a href="../de418015/index.html">Neuer Vasyuki. Innovative Entwicklung Moskaus bis 2100</a></li>
<li><a href="../de418017/index.html">Analyse des Verhaltens des Pegasus-Trojaners im Netzwerk</a></li>
<li><a href="../de418023/index.html">Zeiger in C sind abstrakter als Sie vielleicht denken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>