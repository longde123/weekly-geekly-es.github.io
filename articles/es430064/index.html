<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òîÔ∏è üè© üëßüèæ C ++: una sesi√≥n de arqueolog√≠a espont√°nea y por qu√© no debes usar funciones variables al estilo de C üíπ üßó üßó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todo comenz√≥, como siempre, con un error. Esta es la primera vez que trabajo con la interfaz nativa de Java y en la parte de C ++ envolv√≠ una funci√≥n ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++: una sesi√≥n de arqueolog√≠a espont√°nea y por qu√© no debes usar funciones variables al estilo de C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430064/"> Todo comenz√≥, como siempre, con un error.  Esta es la primera vez que trabajo con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz nativa de Java</a> y en la parte de C ++ envolv√≠ una funci√≥n que crea un objeto Java.  Esta funci√≥n, <code>CallVoidMethod</code> , es variable, es decir  Adem√°s de un puntero al entorno <abbr title="Interfaz nativa de Java">JNI</abbr> , un puntero al tipo de objeto a crear y un identificador para el m√©todo llamado (en este caso, el constructor), toma un n√∫mero arbitrario de otros argumentos.  Lo cual es l√≥gico, porque  estos otros argumentos se pasan al m√©todo llamado en el lado de Java, y los m√©todos pueden ser diferentes, con un n√∫mero diferente de argumentos de cualquier tipo. <br><br>  En consecuencia, tambi√©n hice que mi envoltorio fuera variable.  Para pasar un n√∫mero arbitrario de argumentos a <code>CallVoidMethod</code> utilic√© <code>va_list</code> , porque es diferente en este caso.  S√≠, eso es lo que <code>va_list</code> envi√≥ a <code>CallVoidMethod</code> .  Y dej√≥ caer la falla de segmentaci√≥n banal JVM. <br><br>  En 2 horas logr√© probar varias versiones de la JVM, del 8 al 11, porque: en primer lugar, esta es mi primera experiencia con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="M√°quina virtual Java">JVM</a> , y en este asunto confi√© en StackOverflow m√°s que en m√≠ mismo, y en segundo lugar, alguien luego, en StackOverflow, aconsej√© en este caso no usar OpenJDK, sino OracleJDK, y no 8, sino 10. Y solo entonces finalmente not√© que, adem√°s de la variable <code>CallVoidMethod</code> hay <code>CallVoidMethodV</code> , que toma un n√∫mero arbitrario de argumentos a trav√©s de <code>va_list</code> . <br><br>  Lo que no me gust√≥ m√°s de esta historia fue que no not√© de inmediato la diferencia entre los puntos suspensivos (puntos suspensivos) y <code>va_list</code> .  Y habi√©ndome dado cuenta, no pod√≠a explicarme cu√°l era la diferencia fundamental.  Entonces, tenemos que lidiar con puntos suspensivos, y con <code>va_list</code> , y (ya que todav√≠a estamos hablando de C ++) con plantillas variables. <br><a name="habracut"></a><br><h3>  ¬øQu√© pasa con los puntos suspensivos y va_list se dice en el Est√°ndar? </h3><br>  El Est√°ndar C ++ describe solo las diferencias entre sus requisitos y los del Est√°ndar C. Las diferencias en s√≠ se discutir√°n m√°s adelante, pero por ahora explicar√© brevemente lo que dice el Est√°ndar C (comenzando con C89). <br><br><ul><li>  Puede declarar una funci√≥n que tome un n√∫mero arbitrario de argumentos.  Es decir  Una funci√≥n puede tener m√°s argumentos que par√°metros.  Para hacer esto, la lista de sus par√°metros debe terminar con puntos suspensivos, pero al menos un par√°metro fijo <i>[C11 6.9.1 / 8]</i> tambi√©n debe estar presente: <br><br><pre> <code class="plaintext hljs">void foo(int parm1, int parm2, ...);</code> </pre> </li><li>  La informaci√≥n sobre el n√∫mero y los tipos de argumentos correspondientes a los puntos suspensivos no se pasa a la funci√≥n misma.  Es decir  despu√©s del √∫ltimo par√°metro nombrado ( <code>parm2</code> en el ejemplo anterior) <i>[C11 6.7.6.3/9]</i> . <br></li><li>  Para acceder a estos argumentos, debe usar el tipo <code>va_list</code> declarado en el <code>&lt;stdarg.h&gt;</code> y 4 macros (3 antes del est√°ndar C11): <code>va_start</code> , <code>va_arg</code> , <code>va_end</code> y <code>va_copy</code> (comenzando con C11) <i>[C11 7.16]</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Por ejemplo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int add(int count, ...) { int result = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; ++i) { result += va_arg(args, int); } va_end(args); return result; }</code> </pre> <br>  S√≠, la funci√≥n no sabe cu√°ntos argumentos tiene.  Ella necesita pasar de alguna manera este n√∫mero.  En este caso, a trav√©s de un √∫nico argumento con nombre (otra opci√≥n com√∫n es pasar <code>NULL</code> como √∫ltimo argumento, como en <code>execl</code> , o 0). </div></div></li><li>  El √∫ltimo argumento nombrado no puede tener una clase de almacenamiento de <code>register</code> ; no puede ser una funci√≥n o una matriz.  De lo contrario, comportamiento indefinido <i>[C11 7.16.1.4/4]</i> . </li><li>  Adem√°s, para el √∫ltimo argumento nombrado y para todos los sin nombre, se aplica la " <i>promoci√≥n de argumento por defecto</i> " ( <i>promoci√≥n de argumento por defecto</i> ; si hay una buena traducci√≥n de este concepto al ruso, con mucho gusto lo uso).  Esto significa que si el argumento tiene el tipo <code>char</code> , <code>short</code> (con o sin signo) o <code>float</code> , entonces se debe acceder a los par√°metros correspondientes como <code>int</code> , <code>int</code> (con o sin signo) o <code>double</code> .  De lo contrario, comportamiento indefinido <i>[C11 7.16.1.1/2]</i> . </li><li>  Sobre el tipo <code>va_list</code> solo se dice que est√° declarado en <code>&lt;stdarg.h&gt;</code> y est√° completo (es decir, se conoce el tama√±o de un objeto de este tipo) <i>[C11 7.16 / 3]</i> . </li></ul><br><h3>  Por qu√©  Pero porque! </h3><br>  No hay muchos tipos en C.  ¬øPor qu√© se declara <code>va_list</code> en el Est√°ndar, pero no se dice nada sobre su estructura interna? <br><br>  ¬øPor qu√© necesitamos puntos suspensivos si se puede pasar un n√∫mero arbitrario de argumentos a una funci√≥n a trav√©s de <code>va_list</code> ?  Se podr√≠a decir ahora: "como az√∫car sint√°ctico", pero hace 40 a√±os, estoy seguro, no hab√≠a tiempo para el az√∫car. <br><br>  Philip James Plauger <i>Phillip James Plauger</i> en el libro <i>The Standard C library</i> - 1992 - dice que inicialmente C fue creado exclusivamente para computadoras PDP-11.  Y all√≠ fue posible clasificar todos los argumentos de la funci√≥n usando aritm√©tica de puntero simple.  El problema apareci√≥ con la popularidad de C y la transferencia del compilador a otras arquitecturas.  La primera edici√≥n de <i>The C Programming Language por</i> <i>Brian Kernighan</i> y Dennis Ritchie - 1978 - declara expl√≠citamente: <blockquote>  Por cierto, no hay una forma aceptable de escribir una funci√≥n port√°til de un n√∫mero arbitrario de argumentos, porque  No hay una forma port√°til para que la funci√≥n llamada descubra cu√°ntos argumentos se le pasaron cuando se llam√≥.  ... <code>printf</code> , la funci√≥n de lenguaje C m√°s t√≠pica de un n√∫mero arbitrario de argumentos, ... no es port√°til y debe implementarse para cada sistema. </blockquote>  Este libro describe <code>printf</code> , pero a√∫n no tiene <code>vprintf</code> , y no menciona el tipo y las macros <code>va_*</code> .  Aparecen en la segunda edici√≥n del lenguaje de programaci√≥n C (1988), y este es el m√©rito del comit√© para el desarrollo del primer est√°ndar C (C89, tambi√©n conocido como ANSI C).  El comit√© agreg√≥ el <code>&lt;stdarg.h&gt;</code> al Est√°ndar, tomando como base <code>&lt;varargs.h&gt;</code> , creado por Andrew Koenig con el objetivo de aumentar la portabilidad del sistema operativo UNIX.  <code>va_*</code> decidi√≥ dejar <code>va_*</code> macros como macros para que sea m√°s f√°cil para los compiladores existentes admitir el nuevo est√°ndar. <br><br>  Ahora, con el advenimiento de C89 y la familia <code>va_*</code> , se ha hecho posible crear funciones variables port√°tiles.  Y aunque la estructura interna de esta familia todav√≠a no se describe de ninguna manera, y no hay requisitos para ello, ya est√° claro por qu√©. <br><br>  Por pura curiosidad, puede encontrar ejemplos de la implementaci√≥n de <code>&lt;stdarg.h&gt;</code> .  Por ejemplo, la misma "Biblioteca est√°ndar de C" proporciona un ejemplo para <b>Borland Turbo C ++</b> : <br><br><div class="spoiler">  <b class="spoiler_title">&lt;stdarg.h&gt; de Borland Turbo C ++</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#ifndef _STADARG #define _STADARG #define _AUPBND 1 #define _ADNBND 1 typedef char* va_list #define va_arg(ap, T) \ (*(T*)(((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND))) #define va_end(ap) \ (void)0 #define va_start(ap, A) \ (void)((ap) = (char*)&amp;(A) + _Bnd(A, _AUPBND)) #define _Bnd(X, bnd) \ (sizeof(X) + (bnd) &amp; ~(bnd)) #endif</code> </pre> <br></div></div><br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ABI SystemV</a> mucho m√°s nuevo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para AMD64</a> usa este tipo para <code>va_list</code> : <br><br><div class="spoiler">  <b class="spoiler_title">va_list de SystemV ABI AMD64</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1];</code> </pre> <br></div></div><br>  En general, podemos decir que el tipo y las macros <code>va_*</code> proporcionan una interfaz est√°ndar para atravesar argumentos de una funci√≥n variable, y su implementaci√≥n por razones hist√≥ricas depende del compilador, las plataformas de destino y la arquitectura.  Adem√°s, una elipsis (es decir, funciones variables en general) apareci√≥ en C antes que <code>va_list</code> (es decir, el encabezado <code>&lt;stdarg.h&gt;</code> ).  Y <code>va_list</code> no se cre√≥ para reemplazar los puntos suspensivos, sino para permitir a los desarrolladores escribir sus funciones variables port√°tiles. <br><br>  C ++ mantiene en gran medida la compatibilidad con C, por lo que todo lo anterior se aplica a √©l.  Pero tambi√©n hay caracter√≠sticas. <br><br><h3>  Funciones variables en C ++ </h3><br>  El grupo de trabajo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WG21</a> ha estado involucrado en el desarrollo del est√°ndar C ++.  En 1989, se tom√≥ como base el reci√©n creado Est√°ndar C89, que cambi√≥ gradualmente para describir el propio C ++.  En 1995, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se recibi√≥ la</a> propuesta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N0695</a> de <i>John Micco</i> , en la cual el autor sugiri√≥ cambiar las restricciones para las macros <code>va_*</code> : <br><br><ul><li>  Porque  C ++, a diferencia de C, le permite obtener la direcci√≥n de <code>register</code> de las variables, luego el √∫ltimo argumento nombrado de una funci√≥n variable puede tener esta clase de almacenamiento. <br></li><li>  Porque  los enlaces que aparecieron en C ++ violan la regla no escrita de las funciones variables de C (el tama√±o del par√°metro debe coincidir con el tama√±o de su tipo declarado), entonces el √∫ltimo argumento nombrado no puede ser un enlace.  De lo contrario, comportamiento vago. <br></li><li>  Porque  en C ++ no existe el concepto de " <i>elevar el tipo de argumento por defecto</i> ", entonces la frase <br><blockquote>  Si el par√°metro <code>parmN</code> se declara con ... un tipo que no es compatible con el tipo que resulta despu√©s de la aplicaci√≥n de las promociones de argumento predeterminadas, el comportamiento es indefinido </blockquote>  debe ser reemplazado por <blockquote>  Si el par√°metro <code>parmN</code> se declara con ... un tipo que no es compatible con el tipo que resulta al pasar un argumento para el que no hay par√°metro, el comportamiento es indefinido </blockquote></li></ul>  Ni siquiera traduje el √∫ltimo punto para compartir mi dolor.  Primero, la " <i>escalada de tipo de argumento predeterminado</i> " en C ++ Standard permanece <i>[C ++ 17 8.2.2 / 9]</i> .  Y en segundo lugar, durante mucho tiempo me pregunt√© el significado de esta frase, en comparaci√≥n con el Est√°ndar C, donde todo est√° claro.  Solo despu√©s de leer N0695 finalmente entend√≠: quiero decir lo mismo. <br><br>  Sin embargo, los 3 cambios fueron adoptados <i>[C ++ 98 18.7 / 3]</i> .  De vuelta en C ++, el requisito de que una funci√≥n variable tenga al menos un par√°metro con nombre (en este caso no puede acceder a los dem√°s, pero m√°s sobre eso m√°s adelante) ha desaparecido, y la lista de tipos v√°lidos de argumentos sin nombre se ha complementado con punteros a los miembros de la clase y tipos de <abbr title="Datos antiguos simples">POD</abbr> . <br><br>  El est√°ndar C ++ 03 no trajo ning√∫n cambio a las funciones variacionales.  C ++ 11 comenz√≥ a convertir un argumento sin nombre de tipo <code>std::nullptr_t</code> a <code>void*</code> y permiti√≥ a los compiladores, a su discreci√≥n, admitir tipos con constructores y destructores no triviales <i>[C ++ 11 5.2.2 / 7]</i> .  C ++ 14 permiti√≥ el uso de funciones y matrices como el √∫ltimo par√°metro nombrado <i>[C ++ 14 18.10 / 3]</i> , y C ++ 17 prohibi√≥ el uso de la expansi√≥n del paquete de par√°metros ( <i>expansi√≥n del paquete</i> ) y las variables capturadas por el lambda <i>[C ++ 17 21.10.1 / 1]</i> . <br><br>  Como resultado, C ++ agreg√≥ funciones variadas a sus dificultades.  Solo vale la pena el soporte de tipo no especificado con constructores / destructores no triviales.  A continuaci√≥n, intentar√© reducir todas las caracter√≠sticas no obvias de las funciones variables en una lista y complementarla con ejemplos espec√≠ficos. <br><br><h3>  C√≥mo usar funciones variables de manera f√°cil e incorrecta </h3><br><ol><li>  Es incorrecto declarar el √∫ltimo argumento nombrado con un tipo promocionado, es decir  <code>char</code> , <code>char</code> <code>signed char</code> , <code>unsigned char</code> , <code>singed short</code> , <code>unsigned short</code> o <code>float</code> .  El resultado seg√∫n la Norma ser√° un comportamiento indefinido. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo inv√°lido</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(float n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> <br></div></div><br>  De todos los compiladores que ten√≠a a mano (gcc, clang, MSVC), solo <b>clang</b> emiti√≥ una advertencia. <br><br><div class="spoiler">  <b class="spoiler_title">Advertencia de argot</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object that undergoes default argument promotion to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  Y aunque en todos los casos el c√≥digo compilado se comport√≥ correctamente, no debe contar con √©l. <br><br><div class="spoiler">  <b class="spoiler_title">Estara bien</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(double n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es incorrecto declarar el √∫ltimo argumento nombrado como referencia.  Cualquier enlace  El est√°ndar en este caso tambi√©n promete un comportamiento indefinido. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo inv√°lido</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int&amp; n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> compil√≥ este c√≥digo sin un solo comentario.  <b>lang 6.0.0</b> emiti√≥ una advertencia, pero a√∫n as√≠ la compil√≥. <br><br><div class="spoiler">  <b class="spoiler_title">Advertencia de argot</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object of reference type to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  En ambos casos, el programa funcion√≥ correctamente (por suerte, no puede confiar en √©l).  Pero <b>MSVC 19.15.26730 se</b> distingui√≥: se neg√≥ a compilar el c√≥digo, porque  <code>va_start</code> argumento <code>va_start</code> no <code>va_start</code> ser una referencia. <br><br><div class="spoiler">  <b class="spoiler_title">Error de MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vadefs.h(151): error C2338: va_start argument must not have reference type and must not be parenthesized</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bueno, la opci√≥n correcta se ve, por ejemplo, as√≠</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int* n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es incorrecto solicitar <code>va_arg</code> elevar el tipo - <code>char</code> , <code>short</code> o <code>float</code> . <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo inv√°lido</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); } int main() { foo(0, 1, 2.0f, 3); return 0; }</code> </pre> </div></div><br>  Es m√°s interesante aqu√≠.  <b>gcc</b> at compilation advierte que es necesario usar <code>double</code> lugar de <code>float</code> , y si este c√≥digo a√∫n se ejecuta, el programa terminar√° con un error. <br><br><div class="spoiler">  <b class="spoiler_title">Advertencia de CCG</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:15: warning: 'float' is promoted to 'double' when passed through '...' std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~~ ./test.cpp:9:15: note: (so you should pass 'double' not 'float' to 'va_arg') ./test.cpp:9:15: note: if this code is reached, the program will abort</code> </pre> </div></div><br>  De hecho, el programa se bloquea con una queja sobre una instrucci√≥n no v√°lida. <br>  Un an√°lisis de volcado muestra que el programa recibi√≥ una se√±al SIGILL.  Y tambi√©n muestra la estructura de <code>va_list</code> .  Para 32 bits esto es <br><br><pre> <code class="diff hljs">va = 0xfffc6918 ""</code> </pre> <br>  es decir  <code>va_list</code> es solo <code>char*</code> .  Para 64 bits: <br><br><pre> <code class="diff hljs">va = {{gp_offset = 16, fp_offset = 48, overflow_arg_area = 0x7ffef147e7e0, reg_save_area = 0x7ffef147e720}}</code> </pre> <br>  es decir  exactamente lo que se describe en SystemV ABI AMD64. <br><br>  <b>El sonido met√°lico</b> en la compilaci√≥n advierte sobre un comportamiento indefinido y tambi√©n sugiere reemplazar el <code>float</code> por el <code>double</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Advertencia de argot</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:26: warning: second argument to 'va_arg' is of promotable type 'float'; this va_arg has undefined behavior because arguments will be promoted to 'double' [-Wvarargs] std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~</code> </pre> </div></div><br>  Pero el programa ya no se bloquea, la versi√≥n de 32 bits produce: <br><br><pre> <code class="diff hljs">1 0 1073741824</code> </pre> <br>  64 bit: <br><br><pre> <code class="diff hljs">1 0 3</code> </pre> <br>  <b>MSVC</b> produce exactamente los mismos resultados, solo sin previo aviso, incluso con <code>/Wall</code> . <br><br>  Aqu√≠ se podr√≠a suponer que la diferencia entre 32 y 64 bits se debe al hecho de que en el primer caso, el ABI pasa todos los argumentos a trav√©s de la pila a la funci√≥n llamada, y en el segundo, los primeros cuatro (Windows) o seis (Linux) argumentos a trav√©s de los registros del procesador, el resto a trav√©s de apilar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki</a> ].  Pero no, si llama a <code>foo</code> no con 4 argumentos, sino con 19, y los genera de la misma manera, el resultado ser√° el mismo: desorden completo en la versi√≥n de 32 bits y ceros para todos los <code>float</code> en la de 64 bits.  Es decir  el punto es, por supuesto, en ABI, pero no en el uso de registros para pasar argumentos. <br><br><div class="spoiler">  <b class="spoiler_title">Bueno, claro, por supuesto, hacerlo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, double) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es incorrecto pasar una instancia de una clase con un constructor o destructor no trivial como argumento sin nombre.  A menos que, por supuesto, el destino de este c√≥digo lo entusiasme al menos un poco m√°s que "compilar y ejecutar aqu√≠ y ahora". <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo inv√°lido</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; struct Bar { Bar() { std::cout &lt;&lt; "Bar default ctor" &lt;&lt; std::endl; } Bar(const Bar&amp;) { std::cout &lt;&lt; "Bar copy ctor" &lt;&lt; std::endl; } ~Bar() { std::cout &lt;&lt; "Bar dtor" &lt;&lt; std::endl; } }; struct Cafe { Cafe() { std::cout &lt;&lt; "Cafe default ctor" &lt;&lt; std::endl; } Cafe(const Cafe&amp;) { std::cout &lt;&lt; "Cafe copy ctor" &lt;&lt; std::endl; } ~Cafe() { std::cout &lt;&lt; "Cafe dtor" &lt;&lt; std::endl; } }; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto b = va_arg(va, Bar); va_end(va); } int main() { Bar b; Cafe c; foo(1, b, c); return 0; }</code> </pre> </div></div><br>  Clang es el m√°s estricto de todos  Simplemente se niega a compilar este c√≥digo porque el segundo argumento, <code>va_arg</code> no <code>va_arg</code> un tipo de POD, y advierte que el programa se <code>va_arg</code> en el inicio. <br><br><div class="spoiler">  <b class="spoiler_title">Advertencia de argot</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:23:31: error: second argument to 'va_arg' is of non-POD type 'Bar' [-Wnon-pod-varargs] const auto b = va_arg(va, Bar); ^~~ ./test.cpp:31:12: error: cannot pass object of non-trivial type 'Bar' through variadic function; call will abort at runtime [-Wnon-pod-varargs] foo(1, b, c); ^</code> </pre> </div></div><br>  As√≠ ser√°, si a√∫n compila con el indicador <code>-Wno-non-pod-varargs</code> . <br><br>  <b>MSVC</b> advierte que el uso de tipos con constructores no triviales en este caso no es port√°til. <br><br><div class="spoiler">  <b class="spoiler_title">Advertencia de MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">d:\my documents\visual studio 2017\projects\test\test\main.cpp(31): warning C4840:    "Bar"         </code> </pre> </div></div><br>  Pero el c√≥digo se compila y se ejecuta correctamente.  Lo siguiente se obtiene en la consola: <br><br><div class="spoiler">  <b class="spoiler_title">Resultado de lanzamiento</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Es decir  se crea una copia solo al momento de llamar a <code>va_arg</code> , y resulta que el argumento se pasa por referencia.  De alguna manera no es obvio, pero la Norma lo permite. <br><br>  <b>gcc 6.3.0</b> compila sin un solo comentario.  La salida es la misma: <br><br><div class="spoiler">  <b class="spoiler_title">Resultado de lanzamiento</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> tampoco advierte sobre nada, pero el comportamiento est√° cambiando: <br><br><div class="spoiler">  <b class="spoiler_title">Resultado de lanzamiento</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Cafe copy ctor Bar copy ctor Before va_arg Bar copy ctor Bar dtor Bar dtor Cafe dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Es decir  Esta versi√≥n del compilador pasa argumentos por valor, y cuando se llama, <code>va_arg</code> hace otra copia.  Ser√≠a divertido buscar esta diferencia al cambiar de la sexta a la s√©ptima versi√≥n de gcc si los constructores / destructores tienen efectos secundarios. <br><br>  Por cierto, si pasa expl√≠citamente y solicita una referencia a la clase: <br><br><div class="spoiler">  <b class="spoiler_title">Otro c√≥digo equivocado</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto&amp; b = va_arg(va, Bar&amp;); va_end(va); } int main() { Bar b; Cafe c; foo(1, std::ref(b), c); return 0; }</code> </pre> </div></div><br>  entonces todos los compiladores arrojar√°n un error.  Seg√∫n lo requiera la Norma. <br><br>  En general, si realmente lo desea, es mejor pasar los argumentos por puntero. <br><br><div class="spoiler">  <b class="spoiler_title">Como este</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto* b = va_arg(va, Bar*); va_end(va); } int main() { Bar b; Cafe c; foo(1, &amp;b, &amp;c); return 0; }</code> </pre> </div></div><br></li></ol><br><h3>  Resoluci√≥n de sobrecarga y funciones variables </h3><br>  Por un lado, todo es simple: la coincidencia con puntos suspensivos es peor que la coincidencia con un argumento con nombre normal, incluso en el caso de una conversi√≥n de tipo est√°ndar o definida por el usuario. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de sobrecarga</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } int main() { foo(1); foo(1ul); foo(); return 0; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Resultado de lanzamiento</b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function C variadic function</code> </pre> </div></div><br>  Pero esto solo funciona hasta que la llamada a <code>foo</code> sin argumentos deba considerarse por separado. <br><br><div class="spoiler">  <b class="spoiler_title">Llama a foo sin argumentos</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Salida del compilador</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:16:9: error: call of overloaded 'foo()' is ambiguous foo(); ^ ./test.cpp:3:6: note: candidate: void foo(...) void foo(...) ^~~ ./test.cpp:8:6: note: candidate: void foo() void foo() ^~~</code> </pre> </div></div><br>  Todo est√° de acuerdo con el Est√°ndar: no hay argumentos, no hay comparaci√≥n con los puntos suspensivos, y cuando se resuelve la sobrecarga, la funci√≥n variante no es peor que la habitual. <br><br><h3>  Sin embargo, ¬øcu√°ndo vale la pena usar funciones variables? </h3><br>  Bueno, las funciones variantes a veces no se comportan de manera muy obvia y en el contexto de C ++ pueden resultar f√°cilmente poco portables.  Hay muchos consejos en Internet como "No crear o usar funciones variables de C", pero no van a eliminar su soporte del Est√°ndar C ++.  Entonces, ¬øhay alg√∫n beneficio en estas caracter√≠sticas?  Bueno ahi. <br><br><ul><li>  El caso m√°s com√∫n y obvio es la compatibilidad con versiones anteriores.  Aqu√≠ incluir√© el uso de bibliotecas C de terceros (mi caso con JNI) y la provisi√≥n de la API C para la implementaci√≥n de C ++. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="La falla de sustituci√≥n no es un error">SFINAE</a>  Aqu√≠, es muy √∫til que en C ++ una funci√≥n variable no tenga que tener argumentos nombrados, y que al resolver funciones sobrecargadas, una funci√≥n variable se considere la √∫ltima (si hay al menos un argumento).  Y como cualquier otra funci√≥n, una funci√≥n variable solo puede declararse, pero nunca llamarse. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static void detect(const U&amp;); static int detect(...); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; };</code> </pre> </div></div><br>  Aunque en C ++ 14 puedes hacerlo un poco diferente. <br><br><div class="spoiler">  <b class="spoiler_title">Otro ejemplo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static constexpr bool detect(const U*) { return true; } template &lt;class U&gt; static constexpr bool detect(...) { return false; } public: static constexpr bool value = detect&lt;T&gt;(nullptr); };</code> </pre> </div></div><br>  Y en este caso ya es necesario mirar con qu√© argumentos se puede llamar <code>detect(...)</code> .  Preferir√≠a cambiar un par de l√≠neas y usar una alternativa moderna a las funciones variables, desprovistas de todas sus deficiencias. <br></li></ul><br><h3>  Plantillas variantes o c√≥mo crear funciones a partir de un n√∫mero arbitrario de argumentos en C ++ moderno </h3><br>  Douglas Gregor, Jaakko J√§rvi y Gary Powell propusieron la idea de plantillas variables en 2004, es decir.  7 a√±os antes de la adopci√≥n del est√°ndar C ++ 11, en el que estas plantillas variables fueron oficialmente compatibles.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La Norma incluy√≥ una tercera revisi√≥n de su propuesta, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde el principio, se crearon plantillas variables para que los programadores tuvieran la oportunidad de crear funciones de tipo seguro (¬°y port√°til!) A partir de un n√∫mero arbitrario de argumentos. </font><font style="vertical-align: inherit;">Otro objetivo es simplificar el soporte para plantillas de clase con un n√∫mero variable de par√°metros, pero ahora solo estamos hablando de funciones variables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las plantillas variables trajeron tres conceptos nuevos a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ [C ++ 17 17.5.3]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metros de plantilla de paquete ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de par√°metro de plantilla</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - es una plantilla de par√°metros, en lugar de la que es posible transferir cualquier (incluyendo 0) n√∫mero de argumento de plantilla;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un paquete de par√°metros de funci√≥n (paquete de par√°metros de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): en consecuencia, este es un par√°metro de funci√≥n que toma cualquier (incluido 0) n√∫mero de argumentos de funci√≥n;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la expansi√≥n del paquete ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expansi√≥n del paquete</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) es lo √∫nico que se puede hacer con el paquete de par√°metros.</font></font><br></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { printf(format.c_str(), args...); }</code> </pre> <br>  <code>class ... Args</code> ‚Äî   , <code>Args ... args</code> ‚Äî   ,  <code>args...</code> ‚Äî    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el Est√°ndar mismo se proporciona una lista completa de d√≥nde y c√≥mo se pueden expandir los paquetes de par√°metros </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3 / 4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Y en el contexto de la discusi√≥n de las funciones variables, es suficiente decir que:</font></font><br><br><ul><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El paquete de par√°metros de funci√≥n se puede expandir a la lista de argumentos de otra funci√≥n</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void bar(const std::string&amp; format, Args ... args) { foo&lt;Args...&gt;(format.c_str(), args...); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o a la lista de inicializaci√≥n</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { const auto list = {args...}; }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o a la lista de captura lambda</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { auto lambda = [&amp;format, args...] () { printf(format.c_str(), args...); }; lambda(); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otro paquete de par√°metros de funci√≥n puede expandirse en una expresi√≥n de convoluci√≥n</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; int foo(Args ... args) { return (0 + ... + args); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las convoluciones aparecieron en C ++ 14 y pueden ser unarias y binarias, derecha e izquierda. </font><font style="vertical-align: inherit;">La descripci√≥n m√°s completa, como siempre, est√° en el Est√°ndar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 8.1.6]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ambos tipos de paquetes de par√°metros se pueden ampliar en el operador sizeof ...</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(Args ... args) { const auto size1 = sizeof...(Args); const auto size2 = sizeof...(args); }</code> </pre> </div></div><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al revelar el paquete de puntos suspensivos expl√≠cita se necesita para apoyar las distintas plantillas ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patrones</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) la divulgaci√≥n y para evitar esta ambig√ºedad.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Por ejemplo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo() { using OneTuple = std::tuple&lt;std::tuple&lt;Args&gt;...&gt;; using NestTuple = std::tuple&lt;std::tuple&lt;Args...&gt;&gt;; }</code> </pre> <br> <code>OneTuple</code> ‚Äî      ( <code>std:tuple&lt;std::tuple&lt;int&gt;&gt;, std::tuple&lt;double&gt;&gt;</code> ),  <code>NestTuple</code> ‚Äî ,     ‚Äî   ( <code>std::tuple&lt;std::tuple&lt;int, double&gt;&gt;</code> ). </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejemplo de implementaci√≥n de printf usando plantillas variables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ya mencion√©, las plantillas variables tambi√©n se crearon como un reemplazo directo para las funciones variables de C. Los autores de estas plantillas propusieron su versi√≥n muy simple pero segura de tipos </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, una de las primeras funciones variables en C.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf en plantillas</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void printf(const char* s) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') throw std::runtime_error("invalid format string: missing arguments"); std::cout &lt;&lt; *s++; } } template &lt;typename T, typename ... Args&gt; void printf(const char* s, T value, Args ... args) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') { std::cout &lt;&lt; value; return printf(++s, args...); } std::cout &lt;&lt; *s++; } throw std::runtime_error("extra arguments provided to printf"); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sospecho que apareci√≥ este patr√≥n de enumeraci√≥n de argumentos variables, a trav√©s de una llamada recursiva de funciones sobrecargadas. </font><font style="vertical-align: inherit;">Pero todav√≠a prefiero la opci√≥n sin recurrencia.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf en plantillas y sin recursividad</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;typename ... Args&gt; void printf(const std::string&amp; fmt, const Args&amp; ... args) { size_t fmtIndex = 0; size_t placeHolders = 0; auto printFmt = [&amp;fmt, &amp;fmtIndex, &amp;placeHolders]() { for (; fmtIndex &lt; fmt.size(); ++fmtIndex) { if (fmt[fmtIndex] != '%') std::cout &lt;&lt; fmt[fmtIndex]; else if (++fmtIndex &lt; fmt.size()) { if (fmt[fmtIndex] == '%') std::cout &lt;&lt; '%'; else { ++fmtIndex; ++placeHolders; break; } } } }; ((printFmt(), std::cout &lt;&lt; args), ..., (printFmt())); if (placeHolders &lt; sizeof...(args)) throw std::runtime_error("extra arguments provided to printf"); if (placeHolders &gt; sizeof...(args)) throw std::runtime_error("invalid format string: missing arguments"); }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resoluci√≥n de sobrecarga y funciones de plantilla variable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al resolver, estas funciones variadas se consideran, despu√©s de otras, como est√°ndar y menos especializadas. </font><font style="vertical-align: inherit;">Pero no hay problema en el caso de una llamada sin argumentos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de sobrecarga</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } template &lt;class T&gt; void foo(T) { std::cout &lt;&lt; "Template function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); foo(2.0); foo(1, 2); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado de lanzamiento</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function without arguments Template function Template variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se resuelve la sobrecarga, una funci√≥n de plantilla variable solo puede omitir una funci√≥n de variable C (aunque ¬øpor qu√© mezclarlas?). </font><font style="vertical-align: inherit;">Excepto, por supuesto! </font><font style="vertical-align: inherit;">- Llamada sin argumentos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llama sin argumentos</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado de lanzamiento</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Template variadic function C variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay una comparaci√≥n con puntos suspensivos: la funci√≥n correspondiente pierde, no hay comparaci√≥n con puntos suspensivos, y la funci√≥n de plantilla es inferior a la que no es de plantilla. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una nota r√°pida sobre la velocidad de las funciones de plantilla variable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 2008, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo√Øc Joly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> present√≥ su propuesta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2772</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al Comit√© de Normalizaci√≥n de C ++ </font><font style="vertical-align: inherit;">, en el que demostr√≥ en la pr√°ctica que las funciones de plantilla variable funcionan m√°s lentamente que funciones similares, cuyo argumento es la lista de inicializaci√≥n ( </font></font><code>std::initializer_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Y aunque esto contradec√≠a las justificaciones te√≥ricas del propio autor, Joli propuso implementarlo </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisamente con la ayuda de listas de inicializaci√≥n, y no con plantillas variables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero ya en 2009, apareci√≥ una refutaci√≥n. </font><font style="vertical-align: inherit;">En las pruebas de Joli, se descubri√≥ un "grave error" (parece, incluso para s√≠ mismo). </font><font style="vertical-align: inherit;">Nuevas pruebas (ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) mostraron que las funciones de plantilla variable son a√∫n m√°s r√°pidas y, a veces, significativamente. </font><font style="vertical-align: inherit;">Lo cual no es sorprendente ya que </font><font style="vertical-align: inherit;">la lista de inicializaci√≥n hace copias de sus elementos, y para plantillas variables puede contar mucho en la etapa de compilaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, en C ++ 11 y est√°ndares posteriores </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son funciones de plantilla ordinarias, se pasa un n√∫mero arbitrario de argumentos a trav√©s de la lista de inicializaci√≥n.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Breve resumen y conclusi√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entonces, funciones variables de estilo C: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No conocen ni el n√∫mero de sus argumentos ni sus tipos. </font><font style="vertical-align: inherit;">El desarrollador debe usar parte de los argumentos de la funci√≥n para pasar informaci√≥n sobre el resto.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Levanta impl√≠citamente los tipos de argumentos sin nombre (y el √∫ltimo nombre). </font><font style="vertical-align: inherit;">Si te olvidas de eso, obtienes un comportamiento vago.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantienen la compatibilidad con versiones anteriores de C puro y, por lo tanto, no admiten pasar argumentos por referencia. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de C ++ 11, no se </font></font><abbr title="Datos antiguos simples"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">admit√≠an</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argumentos que no </font><font style="vertical-align: inherit;">fueran de tipos </font><abbr title="Plain Old Data"><font style="vertical-align: inherit;">POD</font></abbr><font style="vertical-align: inherit;"> , y desde C ++ 11, el soporte para tipos no triviales se dejaba a discreci√≥n del compilador.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El comportamiento del c√≥digo depende del compilador y su versi√≥n. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √∫nico uso permitido de funciones variables es interactuar con la API de C en c√≥digo C ++. </font><font style="vertical-align: inherit;">Para todo lo dem√°s, incluido </font></font><abbr title="La falla de sustituci√≥n no es un error"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , hay funciones de plantilla variables que:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conozca el n√∫mero y los tipos de todos sus argumentos. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escriba safe, no cambie los tipos de sus argumentos. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Admiten pasar argumentos en cualquier forma: por valor, por puntero, por referencia, por enlace universal. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al igual que cualquier otra funci√≥n de C ++, no hay restricciones en los tipos de argumentos. </font></font><br></li><li>        (   C ),   . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las funciones de plantilla variable pueden ser m√°s detalladas en comparaci√≥n con sus contrapartes de estilo C y, a veces, incluso requieren su propia versi√≥n sobrecargada sin plantilla (recorrido recursivo de argumentos). </font><font style="vertical-align: inherit;">Son m√°s dif√≠ciles de leer y escribir. </font><font style="vertical-align: inherit;">Pero todo esto est√° m√°s que pagado por la ausencia de las deficiencias enumeradas y la presencia de las ventajas enumeradas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, la conclusi√≥n es simple: las funciones variadas en el estilo C permanecen en C ++ solo debido a la compatibilidad con versiones anteriores, y ofrecen una amplia gama de opciones para dispararle a la pierna. </font><font style="vertical-align: inherit;">En C ++ moderno, es muy recomendable no escribir otros nuevos y, si es posible, no utilizar las funciones de C variables existentes. </font><font style="vertical-align: inherit;">Las funciones de plantilla variable pertenecen al mundo de C ++ moderno y son mucho m√°s seguras. </font><font style="vertical-align: inherit;">√ösalos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Literatura y Fuentes </font></font></h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PJ Plauger, la biblioteca est√°ndar de C</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan y Dennis M. Ritchie, The C Programming Language, 1st Edition</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan y Dennis M. Ritchie, The C Programming Language, 2nd Edition</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Norma C11, borrador N1570</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 98 est√°ndar</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 03 est√°ndar</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11 est√°ndar, borrador N3337</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est√°ndar C ++ 14, borrador N4296</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17 est√°ndar, borrador N4659</font></font></a> <br></li></ul><br><h3>  PS </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es f√°cil encontrar y descargar versiones electr√≥nicas de los libros mencionados en la red. </font><font style="vertical-align: inherit;">Pero no estoy seguro de que sea legal, as√≠ que no doy enlaces.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430064/">https://habr.com/ru/post/es430064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430052/index.html">¬øPor qu√© es importante que los desarrolladores de hardware realicen cusdev de calidad?</a></li>
<li><a href="../es430054/index.html">HolyJS 2018 Mosc√∫: transmisi√≥n gratuita en l√≠nea, fiesta y rap de ciencia y tecnolog√≠a</a></li>
<li><a href="../es430058/index.html">Procesos de oleaje en l√≠neas hidr√°ulicas. Los fundamentos</a></li>
<li><a href="../es430060/index.html">Hackspace, Denis Perevalov, Anastasia Krokhaleva: la magia de la programaci√≥n</a></li>
<li><a href="../es430062/index.html">Microservicios Desarrollo y refactorizaci√≥n de patrones con ejemplos Java</a></li>
<li><a href="../es430068/index.html">Orden de la cris√°lida</a></li>
<li><a href="../es430070/index.html">La pila y la cola son dos paradigmas malos y qu√© se puede hacer al respecto.</a></li>
<li><a href="../es430072/index.html">Subestimado Swift del lado del servidor: Entrevista con Paul Hudson</a></li>
<li><a href="../es430074/index.html">C√≥mo casi atrap√© un virus tratando de vender botas</a></li>
<li><a href="../es430076/index.html">Transmisi√≥n gratuita de DotNext 2018 Mosc√∫</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>