<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçà üìï üßú Armadilhas do HttpClient no .NET üèÑ ü§≥üèΩ üë©üèº‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuando uma s√©rie de artigos sobre "armadilhas", n√£o posso ignorar o System.Net.HttpClient, que √© frequentemente usado na pr√°tica, mas h√° v√°rios p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Armadilhas do HttpClient no .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424873/">  Continuando uma s√©rie de artigos sobre "armadilhas", n√£o posso ignorar o System.Net.HttpClient, que √© frequentemente usado na pr√°tica, mas h√° v√°rios problemas s√©rios que podem n√£o ser imediatamente vis√≠veis. <br><br>  Um problema bastante comum na programa√ß√£o √© que os desenvolvedores se concentram apenas na funcionalidade de um componente em particular, ignorando completamente um componente n√£o funcional muito importante, que pode afetar o desempenho, a escalabilidade, a facilidade de recupera√ß√£o em caso de falhas, seguran√ßa etc.  Por exemplo, o mesmo HttpClient √© aparentemente um componente elementar, mas h√° v√°rias perguntas: quanto ele cria conex√µes paralelas ao servidor, quanto tempo elas permanecem, como se comportar√° se o nome DNS que foi acessado anteriormente for alternado para um endere√ßo IP diferente ?  Vamos tentar responder a estas perguntas no artigo. <br><a name="habracut"></a><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vazamento de conex√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Limitar conex√µes simult√¢neas ao servidor</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conex√µes de longa dura√ß√£o e cache DNS</a> </li></ol><br><a name="1"></a>  O primeiro problema com o HttpClient √© o <b>vazamento de conex√£o</b> n√£o √≥bvio.  Muitas vezes, eu precisava conhecer o c√≥digo em que ele √© criado para executar cada solicita√ß√£o: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid textId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">$"http://someservice.com/api/v1/some-text/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{textId}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br>  Infelizmente, essa abordagem leva a um grande desperd√≠cio de recursos e a uma alta probabilidade de obter um estouro da lista de conex√µes abertas.  Para mostrar claramente o problema, basta executar o seguinte c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient()) { client.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); } } }</code> </pre><br>  E, no final, veja a lista de conex√µes abertas via netstat: <br><br><pre> PS C: \ Desenvolvimento \ Exerc√≠cios&gt; netstat -n |  padr√£o de cadeia de sele√ß√£o "178.248.237.68"<font></font>
<font></font>
   TCP 192.168.1.13:43684 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43685 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43686 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43687 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13:43689 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003690 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003691 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003692 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003693 178.248.237.68-00-0043 TIME_WAIT
   TCP 192.168.1.13-00-003695 178.248.237.68-00-0043 TIME_WAIT
</pre><br>  <i>Aqui, a op√ß√£o -n √© usada para acelerar a sa√≠da, pois, caso contr√°rio, o netstat para cada IP procurar√° o nome de dom√≠nio e 178.248.237.68 procurar√° o endere√ßo IP do habr.com no momento da reda√ß√£o deste documento.</i> <br><br>  No total, vemos que, apesar da constru√ß√£o de uso e mesmo que o programa tenha sido completamente conclu√≠do, as conex√µes com o servidor permaneceram "paralisadas".  E eles ser√£o interrompidos pelo tempo indicado na chave do Registro HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Services \ Tcpip \ Parameters \ TcpTimedWaitDelay. <br><br>  Uma pergunta pode surgir imediatamente - como o .NET Core se comporta nesses casos?  O que est√° no Windows, o que est√° no Linux - exatamente o mesmo, porque essa reten√ß√£o de conex√£o ocorre no n√≠vel do sistema e n√£o no n√≠vel do aplicativo.  O status TIME_WAIT √© um estado especial do soquete depois de fechado pelo aplicativo, e isso √© necess√°rio para processar pacotes que ainda podem passar pela rede.  Para o Linux, a dura√ß√£o desse estado √© especificada em segundos em / proc / sys / net / ipv4 / tcp_fin_timeout e, √© claro, pode ser alterada, se necess√°rio. <br><br><a name="2"></a>  O segundo problema do HttpClient √© o <b>limite</b> n√£o √≥bvio <b>de conex√µes simult√¢neas com o servidor</b> .  Suponha que voc√™ use o familiar .NET Framework 4.7, com a ajuda do qual desenvolve um servi√ßo altamente carregado, onde h√° chamadas para outros servi√ßos via HTTP.  O poss√≠vel problema com vazamento de conex√£o foi resolvido, portanto, a mesma inst√¢ncia HttpClient √© usada para todas as solicita√ß√µes.  O que poderia estar errado? <br><br>  O problema pode ser facilmente visto executando o seguinte c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  <i>O recurso especificado no link permite adiar a resposta do servidor pelo tempo especificado, neste caso - 5 segundos.</i> <br><br>  Como √© f√°cil perceber ap√≥s a execu√ß√£o do c√≥digo acima - a cada 5 segundos, apenas 2 respostas chegam, embora 10 solicita√ß√µes simult√¢neas tenham sido criadas.  Isso se deve ao fato de que a intera√ß√£o com o HTTP em uma estrutura .NET normal, entre outras coisas, passa por uma classe especial System.Net.ServicePointManager que controla v√°rios aspectos das conex√µes HTTP.  Esta classe possui uma propriedade DefaultConnectionLimit que indica quantas conex√µes simult√¢neas podem ser criadas para cada dom√≠nio.  E, portanto, historicamente, o valor padr√£o de uma propriedade √© 2. <br><br>  Se voc√™ adicionar o exemplo de c√≥digo acima no in√≠cio <br><br><pre> <code class="cs hljs">ServicePointManager.DefaultConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  a execu√ß√£o do exemplo acelerar√° notavelmente, pois as solicita√ß√µes ser√£o executadas em lotes de 5. <br><br>  E antes de seguir como isso funciona no .NET Core, um pouco mais deve ser dito sobre o ServicePointManager.  A propriedade discutida acima indica o n√∫mero padr√£o de conex√µes que ser√£o usadas nas conex√µes subseq√ºentes a qualquer dom√≠nio.  Mas junto com isso, √© poss√≠vel controlar os par√¢metros para cada nome de dom√≠nio individualmente e isso √© feito atrav√©s da classe ServicePoint: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk"</span></span>)); delayServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.ConnectionLimit = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  Ap√≥s a execu√ß√£o desse c√≥digo, qualquer intera√ß√£o com o Habr atrav√©s da mesma inst√¢ncia HttpClient utilizar√° 5 conex√µes simult√¢neas e 3 conex√µes com o site "slowwly". <br><br>  H√° outra nuance interessante aqui - o limite no n√∫mero de conex√µes para endere√ßos locais (localhost) √© int.MaxValue por padr√£o.  Veja os resultados da execu√ß√£o desse c√≥digo sem primeiro definir o DefaultConnectionLimit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); Console.WriteLine(habrServicePoint.ConnectionLimit); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>)); Console.WriteLine(localServicePoint.ConnectionLimit);</code> </pre><br>  Agora vamos para o .NET Core.  Embora o ServicePointManager ainda exista no espa√ßo para nome System.Net, ele n√£o afeta o comportamento do HttpClient no .NET Core.  Em vez disso, os par√¢metros de conex√£o HTTP podem ser controlados usando o HttpClientHandler (ou SocketsHttpHandler, sobre o qual falaremos mais adiante): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler(); handler.MaxConnectionsPerServer = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { tasks.Add(SendRequest(client, <span class="hljs-string"><span class="hljs-string">"http://slowwly.robertomurray.co.uk/delay/5000/url/https://habr.com"</span></span>)); } Task.WaitAll(tasks.ToArray()); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(url); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Received response </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{response.StatusCode}</span></span></span><span class="hljs-string"> from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{url}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  O exemplo acima se comportar√° exatamente da mesma forma que o exemplo inicial do .NET Framework comum - para estabelecer apenas duas conex√µes por vez.  Mas se voc√™ remover a linha com o conjunto de propriedades MaxConnectionsPerServer, o n√∫mero de conex√µes simult√¢neas ser√° muito maior, pois, por padr√£o no .NET Core, o valor dessa propriedade √© int.MaxValue. <br><br><a name="3"></a>  E agora vamos examinar o terceiro problema n√£o √≥bvio com as configura√ß√µes padr√£o, que podem n√£o ser menos cr√≠ticas que as duas anteriores - <b>conex√µes de longa dura√ß√£o e cache de DNS</b> .  Ao estabelecer uma conex√£o com um servidor remoto, o nome do dom√≠nio √© resolvido primeiro para o endere√ßo IP correspondente e, em seguida, o endere√ßo recebido √© colocado no cache por algum tempo para acelerar as conex√µes subseq√ºentes.  Al√©m disso, para economizar recursos, na maioria das vezes a conex√£o n√£o √© fechada ap√≥s cada solicita√ß√£o, mas mantida aberta por um longo tempo. <br><br>  Imagine que o sistema que estamos desenvolvendo funcione normalmente sem for√ßar a reinicializa√ß√£o se o servidor com o qual ele interage mudou para um endere√ßo IP diferente.  Por exemplo, se voc√™ alternar para outro data center devido a uma falha no atual.  Mesmo se uma conex√£o permanente for interrompida devido a uma falha no primeiro data center (o que tamb√©m pode acontecer rapidamente), o cache DNS n√£o permitir√° que o sistema responda rapidamente a essa altera√ß√£o.  O mesmo vale para chamadas para o endere√ßo em que o balanceamento de carga √© feito por meio de round-robin DNS. <br><br>  No caso de uma estrutura .NET "normal", esse comportamento pode ser controlado pelo ServicePointManager e ServicePoint (todos os par√¢metros listados abaixo assumem valores em milissegundos): <br><br><ul><li>  ServicePointManager.DnsRefreshTimeout - indica quanto tempo o endere√ßo IP recebido para cada nome de dom√≠nio ser√° armazenado em cache; o valor padr√£o √© 2 minutos (120000). </li><li>  ServicePoint.ConnectionLeaseTimeout - indica quanto tempo a conex√£o pode ser mantida aberta.  Por padr√£o, n√£o h√° limite de tempo para as conex√µes; qualquer conex√£o pode ser mantida por um tempo arbitrariamente longo, pois esse par√¢metro √© -1.  Configur√°-lo como 0 far√° com que cada conex√£o seja fechada imediatamente ap√≥s a solicita√ß√£o ser conclu√≠da. </li><li>  ServicePoint.MaxIdleTime - Indica ap√≥s que per√≠odo de inatividade a conex√£o ser√° fechada.  Ina√ß√£o significa que n√£o h√° transfer√™ncia de dados atrav√©s da conex√£o.  Por padr√£o, o valor desse par√¢metro √© 100 segundos (100000). </li></ul><br>  Agora, para melhorar a compreens√£o desses par√¢metros, combinaremos todos eles em um cen√°rio.  Suponha que ningu√©m alterou DnsRefreshTimeout e MaxIdleTime e sejam 120 e 100 segundos, respectivamente.  Com isso, ConnectionLeaseTimeout foi definido para 60 segundos.  O aplicativo estabelece apenas uma conex√£o, atrav√©s da qual envia solicita√ß√µes a cada 10 segundos. <br><br>  Com essas configura√ß√µes, a conex√£o ser√° fechada a cada 60 segundos (ConnectionLeaseTimeout), mesmo que transfira dados periodicamente.  O fechamento e a recria√ß√£o ocorrer√£o de forma a n√£o interferir na execu√ß√£o correta das solicita√ß√µes - se o tempo acabar e no momento em que a solicita√ß√£o ainda estiver sendo executada, a conex√£o ser√° fechada ap√≥s a conclus√£o da solicita√ß√£o.  Cada vez que uma conex√£o √© recriada, o endere√ßo IP correspondente ser√° retirado do cache primeiro e somente se sua resolu√ß√£o expirar (120 segundos), o sistema enviar√° uma solicita√ß√£o ao servidor DNS. <br><br>  O par√¢metro MaxIdleTime n√£o desempenhar√° um papel nesse cen√°rio, pois a conex√£o n√£o fica ociosa por mais de 10 segundos. <br><br>  A propor√ß√£o ideal desses par√¢metros depende muito da situa√ß√£o espec√≠fica e dos requisitos n√£o funcionais: <br><br><ul><li>  Se voc√™ n√£o pretende alternar de maneira transparente os endere√ßos IP atr√°s do nome de dom√≠nio que seu aplicativo acessa e, ao mesmo tempo, voc√™ precisa minimizar o custo das conex√µes de rede, as configura√ß√µes padr√£o parecem uma boa op√ß√£o. </li><li>  Se houver necessidade de alternar entre os endere√ßos IP no caso de uma falha, voc√™ pode definir DnsRefreshTimeout como 0 e ConnectionLeaseTimeout com o valor n√£o negativo que melhor lhe convier.  Qual deles depende especificamente da rapidez com que voc√™ precisa mudar para outro IP.  Obviamente, voc√™ deseja ter a resposta mais r√°pida poss√≠vel a uma falha, mas aqui voc√™ precisa encontrar o valor ideal, que, por um lado, fornece um tempo de comuta√ß√£o aceit√°vel, por outro lado, n√£o prejudica o rendimento e o tempo de resposta do sistema, recriando conex√µes com freq√º√™ncia. <br></li><li>  Se voc√™ precisar da rea√ß√£o mais r√°pida poss√≠vel para alterar o endere√ßo IP, por exemplo, como no caso de balanceamento via round-robin DNS, tente definir DnsRefreshTimeout e ConnectionLeaseTimeout como 0, mas isso ser√° extremamente in√∫til: para cada solicita√ß√£o, o servidor DNS ser√° pesquisado primeiro e, em seguida, A conex√£o com o n√≥ de destino ser√° restabelecida. <br></li><li>  Pode haver situa√ß√µes em que definir ConnectionLeaseTimeout como 0 com um DnsRefreshTimeout diferente de zero pode ser √∫til, mas n√£o consigo criar um script apropriado imediatamente.  Logicamente, isso significa que, para cada solicita√ß√£o, as conex√µes ser√£o criadas novamente, mas os endere√ßos IP ser√£o retirados do cache sempre que poss√≠vel. </li></ul><br>  A seguir, √© apresentado um exemplo de c√≥digo que pode ser usado para observar o comportamento dos par√¢metros descritos acima: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); ServicePointManager.DnsRefreshTimeout = <span class="hljs-number"><span class="hljs-number">120000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> habrServicePoint = ServicePointManager.FindServicePoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>)); habrServicePoint.MaxIdleTime = <span class="hljs-number"><span class="hljs-number">100000</span></span>; habrServicePoint.ConnectionLeaseTimeout = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { client.GetAsync(<span class="hljs-string"><span class="hljs-string">"https://habr.com"</span></span>).Wait(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>); }</code> </pre><br>  <i>Enquanto o programa de teste est√° em execu√ß√£o, voc√™ pode executar o netstat atrav√©s do PowerShell em um loop para monitorar as conex√µes que ele estabelece.</i> <br><br>  Imediatamente, deve-se dizer como gerenciar os par√¢metros descritos no .NET Core.  As configura√ß√µes do ServicePointManager, como no caso de ConnectionLimit, n√£o funcionar√£o.  O Core possui um tipo especial de manipulador HTTP que implementa dois dos tr√™s par√¢metros descritos acima - SocketsHttpHandler: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SocketsHttpHandler(); handler.PooledConnectionLifetime = TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">60</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ConnectionLeaseTimeout handler.PooledConnectionIdleTimeout = TimeSpan.FromSeconds(100); // MaxIdleTime var client = new HttpClient(handler);</span></span></code> </pre><br>  N√£o h√° par√¢metro que controla o tempo de armazenamento em cache dos registros DNS no .NET Core.  Os casos de teste mostram que o cache n√£o funciona - ao criar uma nova conex√£o DNS, a resolu√ß√£o √© executada novamente; portanto, para opera√ß√£o normal sob condi√ß√µes em que o nome de dom√≠nio solicitado pode alternar entre endere√ßos IP diferentes, basta definir PooledConnectionLifetime para o valor desejado. <br><br>  Al√©m de tudo, √© preciso dizer que todos esses problemas n√£o poderiam ter sido despercebidos pelos desenvolvedores da Microsoft e, portanto, a partir do .NET Core 2.1, apareceu uma f√°brica de clientes HTTP que permite resolver alguns deles - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-">https://docs.microsoft.com/en- us / dotnet / standard / microservices-architecture / implement-resilient-applications / use-httpclientfactory-to-implement-resilient-http-orders</a> .  Al√©m disso, al√©m de gerenciar o tempo de vida das conex√µes, o novo componente oferece oportunidades para a cria√ß√£o de clientes digitados, al√©m de outras coisas √∫teis.  Neste artigo e nos links dele, h√° informa√ß√µes e exemplos suficientes sobre o uso do HttpClientFactory, portanto, n√£o considerarei os detalhes associados a ele neste artigo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424873/">https://habr.com/ru/post/pt424873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424861/index.html">Uma cobra na caixa de correio e o que faz F #</a></li>
<li><a href="../pt424865/index.html">Descobertas part√≠culas elementares de design</a></li>
<li><a href="../pt424867/index.html">Desenvolvimento hexapod do zero (parte 1) - design</a></li>
<li><a href="../pt424869/index.html">Como o novo recurso do iOS 12 me lembrou que √© hora de curar</a></li>
<li><a href="../pt424871/index.html">Elon Musk e Tesla resolvem lit√≠gios com a Comiss√£o de Valores Mobili√°rios dos EUA</a></li>
<li><a href="../pt424877/index.html">Sistema de refrigera√ß√£o de freio fluido</a></li>
<li><a href="../pt424879/index.html">Disponibilidade da interface Palestra Yandex</a></li>
<li><a href="../pt424881/index.html">Newtoo - desenvolvendo um mecanismo de navegador completo do zero em 2018?</a></li>
<li><a href="../pt424887/index.html">O que Lida n√£o diz nada: o in√≠cio da carreira de um desenvolvedor. Princ√≠pios ou como se tornar um Middl</a></li>
<li><a href="../pt424889/index.html">Olhando para dentro do coprocessador Intel 8087</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>