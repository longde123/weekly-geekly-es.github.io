<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔜 👨‍🎤 😴 EFORTH untuk kalkulator yang dapat diprogram 👨🏼‍🔬 👩‍👦‍👦 🔍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah artikel pertama dalam seri 161eForth v0.5b, berakhir di sini: habr.com/en/post/452572 

 Penerjemah EFORTH sekarang juga menggunakan kalkul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH untuk kalkulator yang dapat diprogram</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452398/">  <i>Ini adalah artikel pertama dalam seri 161eForth v0.5b, berakhir di sini:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/en/post/452572</a> <br><br>  Penerjemah EFORTH sekarang juga menggunakan kalkulator Electronics MK-161 domestik!  Pada 17 Mei, versi v0.5b berhasil lulus tes saya, serta lima tes penulisan TEST-TEST4.  Saya telah mencapai apa yang bisa dilakukan sendiri, tetapi saya pikir ini hanya setengah dari pertempuran.  Inilah saatnya untuk memperkenalkan alat baru kepada masyarakat dengan membuka kode 161eForth untuk pengujian publik.  Saya punya daftar apa yang harus diperbaiki dan di mana "bekerja pada stabilitas."  Saran dan komentar Anda akan diperhitungkan saat menyelesaikan pekerjaan dan merilis versi 1.0 <br><br>  Ketika mentransfer versi terbaru eForth ke platform domestik, dua rintangan berhasil diatasi - kecepatan relatif rendah dari mesin 8-bit, yang diprogram dalam bahasa inputnya sendiri, dan jumlah sederhana dari memori biner yang tersedia (lihat 2.4.1), total 4.096 byte. <br><img src="https://habrastorage.org/webt/lx/76/pw/lx76pw2yfjmfnqz4wxg9pp_m6ya.jpeg"><br><a name="habracut"></a><br>  Saat menulis 161eForth, solusi siap pakai yang disiapkan untuk Callisto, bahasa input generasi berikutnya untuk PMK domestik, digunakan.  Ini adalah teknologi untuk mengimplementasikan mesin benteng di atas ALU desimal dan arsitektur "Harvard", driver konsol, dan tata letak keyboard alfanumerik, serta terminal perangkat lunak yang berdasarkan padanya, yang beroperasi melalui port serial RS-232.  Selain Electronics MK-161 dan distribusi 161eForth, Anda mungkin memerlukan keyboard tambalan buatan sendiri di mana huruf-huruf dari huruf Rusia dan Inggris ditandatangani pada tombol.  Huruf-huruf disusun menurut abjad baris demi baris, dari kiri ke kanan dan dari atas ke bawah. <br><img src="https://habrastorage.org/webt/ff/pu/ry/ffpury7pflujlbysn28jipoylgg.png"><br><br>  Dr. Chen-Hanson Ting, penulis versi modern eForth, menekankan dalam bukunya [1] pentingnya memahami dua komponen Benteng.  Ini adalah interpreter internal ("alamat") yang memungkinkan peralatan untuk mengeksekusi kode dijahit Fort, dan interpreter eksternal ("teks") yang bertanggung jawab untuk berdialog dengan seseorang. <br><br>  Dalam dua artikel, saya akan membahas secara terperinci solusi paling radikal yang digunakan dalam implementasi masing-masing dari dua penafsir ini di Electronics.  Mempelajari solusi ini dapat berguna dan menginspirasi untuk bermigrasi eForth ke perangkat lain dengan memori dan kinerja yang terbatas.  Memahami artikel akan membantu dengan pengantar awal untuk mikrokalkulator (PMC) yang dapat diprogram dan Fort.  Saya akan menjelaskan saat-saat sulit yang unik untuk Electronics MK dan penerjemah eForth. <br><br>  Untuk mulai dengan, kata-kata eForth dibagi menjadi umum dan sistemik.  <b>Ukuran surat itu penting.</b>  <b>Nama-nama kata biasa didefinisikan dalam huruf besar, dan sistem - huruf kecil.</b>  Saya juga membuat inovasi di eForth dalam huruf kecil.  Penulis eForth menyarankan untuk melakukan dialog utama dalam mode CAPS.  Saat Anda perlu menggunakan kata sistem, alihkan waktu ke huruf kecil (kombinasi tombol FP). <br><br>  Dalam artikel tersebut, semua kata ditulis dalam huruf kapital agar menonjol dari teks.  Dalam beberapa implementasi eForth awal, header kata sistem dikeluarkan dan tidak di-output oleh perintah WORDS.  Ini membantu menyederhanakan penampilan eForth dan menghemat perhatian mereka yang menggunakan Fort untuk pertama kalinya.  Dalam 161eForth, judul kata-kata ini disimpan terutama karena adanya dekompiler kata kolon SEE (lihat video No. 3 di akhir artikel), yang tidak akan menampilkan nama-nama kata sistem jika judulnya dihapus. <br><br>  Untuk merampingkan artikel dan menjadikannya bermanfaat sebagai referensi, saya harus menggunakan beberapa istilah sebelum mendefinisikannya.  Profesional Fort dan PMK harus terbiasa dengan istilah-istilah ini.  Pemula terkadang harus melihat di bagian tetangga (saya meletakkan tautan di tempat yang tepat) atau membaca kembali artikel beberapa kali. <br><br>  161eForth sendiri diletakkan di sini, bersama dengan teks sumber, grafik di layar keyboard dan kata-kata bantuan.txt dengan deskripsi dari semua kata yang diimplementasikan: <a href="">http://the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  Saya juga memposting 5 video kecil di YouTube yang menggambarkan operasi 161eForth bagi mereka yang tidak memiliki MK-161.  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menonton seluruh daftar putar di YouTube</a> .  Di bawah ini adalah yang pertama, 4 sisanya di akhir artikel. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RxarUWHdNTE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  eForth dan implementasinya </h2><br>  eForth dirancang sebagai pengganti modern untuk penerjemah fig-Fort yang dikenal luas.  Untuk mentransfer ke MK-161, saya memilih versi 32-bit 5.2 dari penerjemah 86eForth dengan kode dijahit tidak langsung, ditulis pada tahun 2016 pada MASM assembler untuk sistem operasi Windows.  Versi ini dijelaskan secara rinci dalam edisi ketiga eForth dan Zen [1].  Mereka yang tahu bahasa Inggris, saya sarankan Anda untuk mencari dan mempelajari buku ini, sangat berguna untuk memahami keutamaan. <br><br>  Dalam surat pribadi, penulis mengonfirmasi bahwa 86eForth502.asme dari buku ini adalah versi terbaru eForth.  Di Internet, Anda dapat menemukan banyak informasi berbahasa Inggris tentang ini dan versi eForth sebelumnya. <br><br>  Pengembangan eForth mengikuti jalur ilmiah yang diajarkan oleh Profesor Wirth menggunakan contoh bahasa pemrogramannya Oberon.  Setiap versi eForth berikutnya adalah penyederhanaan dari versi sebelumnya.  Segala sesuatu yang dapat ditiadakan telah dihapus dari lidah.  Masih ada serangkaian konstruksi bahasa ekspresif yang kuat dan dipikirkan dengan cermat, yang kekuatannya telah diuji pada lebih dari 40 implementasi eForth untuk berbagai platform.  Sekarang dengan kalkulator! <br><br>  Menjadi dialek Fort yang minimalis, eForth tidak bertujuan untuk memenangkan perlombaan melawan Fort terkecil.  Seperangkat kata yang ia tawarkan cukup praktis dan dapat dengan mudah diperluas oleh programmer ke arah yang diperlukan untuk tugas-tugasnya. <br><br>  Versi pertama eForth dirilis pada tahun 1990 dalam assembler MASM untuk 8086 prosesor dan bekerja di bawah MS-DOS.  Itu berisi 31 kata inti yang bergantung pada mesin dan 191 kata tingkat tinggi.  Idenya sederhana - Anda menerjemahkan hanya 31 kata ke assembler Anda, dan segera mendapatkan eForth di komputer Anda. <br><br>  Pendekatan ini telah dikritik di Internet, karena cara untuk meminimalkan jumlah kata dalam assembler telah menyebabkan kinerja yang sangat rendah untuk sistem embedded.  Sudah di versi kedua eForth, jumlah maksimum kata-kata mulai diimplementasikan dalam assembler, yang meluruskan kemiringan ke arah tidak hanya portabel, tetapi juga sistem pemrograman praktis. <br><br>  Selama beberapa tahun, Bill Munch, penulis asli eForth, dan rekannya Dr. Chen-Hanson Ting merilis rilis eForth secara paralel.  Setiap versi memiliki karakteristiknya sendiri.  Opsi eForth untuk platform yang berbeda juga telah dimasukkan oleh programmer lain. <br><br>  Versi 5.2, dirilis pada 2016, berisi 71 kata "kode" dan 110 kata "titik dua".  Seperempat abad pencarian ideal telah menyebabkan berkurangnya jumlah kata secara signifikan.  Pada saat yang sama, untuk alasan kinerja, persentase kata yang diterapkan pada level rendah meningkat. <br><br>  Usulan 161eForth menikmati manfaat besar dari kemajuan ini, tetapi tidak berpura-pura mengembangkan garis trunk.  Implementasi saya memberi programmer semua alat yang ada dalam versi 5.2.  Ketika arsitektur MK-161 membuat implementasi beberapa kata yang sulit tidak mungkin atau tidak berarti, alih-alih membuang kelebihannya, saya memberikan programer pengganti yang lengkap, mengambilnya dari standar ANSI / ISO [4].  Mereka yang mencari minimalis dapat secara mandiri membuang kata-kata "ekstra", karena secara tradisi ,eForth dilengkapi dengan kode sumber. <br><br>  Saat menerapkan eForth, saya berpegang pada pemahaman penulis.  Sebagai contoh, menurut pendapat saya, sebuah loop UNTUK BERIKUTNYA dengan nilai awal n harus mengeksekusi tepat n kali.  Kesimpulan yang sama akhirnya datang Chuck Moore, penulis bahasa Forth dan colorForth.  Sayangnya, eForth menggunakan konvensi yang sudah ketinggalan zaman dan mengeksekusi siklus seperti itu n + 1 kali, dengan penghitung dari n hingga 0. Saya tidak memperbaiki ini dan beberapa kekurangan lainnya, lebih memilih kompatibilitas 161 eForth dengan implementasi untuk platform lain. <br><br>  Karena 161eForth adalah sistem pemrograman on-board praktis pertama untuk Elektronik MK-161, dengan pengecualian bahasa pabrik, saya menelusuri sejarah panjang eForth dan mengembalikan beberapa kata ke bahasa yang berguna pada platform lain dan mungkin diminati sekarang. <br><br>  Misalnya, variabel baru-lama 'BOOT berisi token (lihat 3.1) kata, yang dieksekusi pertama setelah lingkungan diinisialisasi, tetapi sebelum dialog dimulai.  Secara default, 'BOOT berisi token TLOAD untuk menafsirkan kode dari "area teks" (lihat 2.4.2).  Hal ini memungkinkan pemrogram untuk menyesuaikan eForth untuk dirinya sendiri tanpa mengkompilasi ulang lingkungan, yang masih mustahil diproduksi di papan "Elektronik". <br><br>  Tugas prioritas implementasi adalah menghemat memori biner (lihat 2.4.1) dan meningkatkan kinerja.  Solusi mereka menyebabkan penurunan dramatis dalam jumlah kata tingkat tinggi, karena kode mereka menempati memori yang berharga ini, karena peningkatan jumlah kata inti cepat yang diterapkan dalam memori program yang murah (lihat 2.4.3). <br><br>  Sebagai hasilnya, 161eForth berisi 129 kata kode, 78 kata tingkat tinggi dan menempati memori biner MK-161 1.816 byte, yaitu kurang dari setengahnya.  Ini memberi harapan untuk metakompilasi bagian tingkat tinggi langsung di papan Elektronik. <br><br>  Kode sumber untuk eForth MK-161 dibagi menjadi dua bagian besar.  Inti yang ditulis dalam sistem perintah MK-161 terkandung dalam file eForth0.mkl.  Kata-kata tingkat tinggi didefinisikan dalam SP-Forth dan ditempatkan dalam file eForth.f. <br><br>  Distribusi juga memiliki file bantuan words.txt, yang mendokumentasikan semua kata-kata penting dengan notasi tumpukan dan penjelasan singkat, dalam satu baris. <br><br><h3>  1.1 Kode sumber kernel eForth0.mkl </h3><br>  Kernel eForth berisi kode yang dapat dieksekusi yang beroperasi dalam memori program MK-161 (lihat 2.4.3), yang dikompilasi pada komputer ke dalam file eForth0.mkp dengan cara standar, misalnya, kompiler MKL2MKP yang dipatenkan. <br><br>  Kode sumber kernel yang terkandung dalam file eForth0.mkl ditulis dalam <i>bahasa Latin mnemonics</i> .  Sebagai contoh, perintah IPE untuk membaca register E (alias R14) ditulis dalam mnemonik ini sebagai RME.  Menjadi tidak biasa bagi pemilik PMK Soviet, mnemonik Latin nyaman untuk mengetik dari keyboard komputer.  Memang, lebih mudah untuk mengetik FX ^ 2 yang aneh daripada terbiasa sejak kecil Fx². <br><br>  File eForth0.mkp adalah preset kernel.  Selain kode primitif, ini berisi header kernel dan daftar nama tblNames, yang ditransfer eForth.f selama decoding ke register desimal (lihat 2.4.4).  Berdasarkan eForth0.mkp-lah inti eForth.mkp akan dibuat (lihat 2.4.3), jadi eForth0.mkl harus dikompilasi terlebih dahulu. <br><br><h3>  1.2 Kode sumber untuk kata-kata tingkat tinggi eForth.f </h3><br>  File eForth.f diumpankan ke input dari kompiler domestik luar biasa SP-Forth [5].  File berisi definisi semua kata tingkat tinggi.  Seiring waktu, mereka dapat diidentifikasi pada eForth itu sendiri dan mungkin dikompilasi langsung di papan Elektronik MK-161. <br><br>  Selama kompilasi, eForth.f membaca inti eForth0.mkp kosong dan dengan bantuannya membuat tiga file dalam direktori saat ini untuk memuat selanjutnya ke MK-161: eForth.mkp, eForth.mkd dan eForth.mkb.  Ini adalah eForth.mkb yang berisi isi kata-kata tingkat tinggi, meskipun tajuknya terletak di file eForth.mkd. <br><br>  File keempat, eForth.mkt, secara manual ditulis dalam eForth dan dapat diedit di atas kapal MK-161 menggunakan editor teks bawaan.  Masing-masing dari empat file ini akan saya analisis secara lebih rinci di bawah ini (lihat 2.4). <br><br><h2>  2. Elektronik MK-161 </h2><br>  Sebuah pabrik dari Novosibirsk menyebut MK-161 sebuah akronim lama.  Itu adalah nama kalkulator pertama di USSR.  Sistem instruksi MK-161 mewarisi sistem komando kalkulator Soviet "Electronics B3-34" dan "Electronics MK-61."  Ini berarti bahwa program yang ditulis untuk kalkulator Soviet akan menggunakan MK-161 tanpa perubahan atau dengan perubahan kecil. <br><br>  Kebalikannya tidak benar.  eForth tidak akan pergi ke PMK Soviet, karena  menggunakan banyak sumber daya yang pertama kali muncul di MK-152/161 dan tidak tersedia dalam model seri sebelumnya. <br><br>  Pertimbangkan fitur-fitur bahasa input dan arsitektur MK-161, yang memengaruhi 161eForth (selanjutnya hanya eForth) dan memberikan implementasi eForth yang dibahas sebagai "aksen Rusia." <br><br>  Yang pertama dari fitur-fitur ini adalah perjanjian <b>"senior at junior address", yang</b> secara konsisten dipertahankan dalam MK-161.  Misalnya, angka 1000 = 3 × 256 + 232 akan ditulis dalam dua byte berturut-turut, seperti 3 dan 232. <br><br><h3>  2.1 Mengatasi Tidak Langsung </h3><br>  Pemrograman PMK Soviet mendengar tentang pengalamatan tidak langsung.  Untuk <i>pengalamatan langsung,</i> kami secara eksplisit menunjukkan nomor register yang kami maksud.  Misalnya, P IP 44 mempertimbangkan konten register 44. Kunci P yang muncul di MK-152 digunakan untuk mengakses register dengan nomor 15 atau lebih - register ini tidak ada di PMK Soviet. <br><br>  Dalam <i>pengalamatan tidak langsung,</i> jumlah register yang diperlukan tidak diketahui sebelumnya.  Nomor ini ada di register yang berbeda.  Misalnya, jika register 8 berisi angka 44, perintah K PI 8 mempertimbangkan konten register 44 (R44). <br><br>  Tombol K dan P dapat digabungkan.  Misalnya, perintah RK BP 20 akan mentransfer kontrol (GOTO dalam bahasa Latin mnemonics) ke alamat yang disimpan dalam R20. <br><br>  Fitur yang ternyata penting bagi interpreter internal eForth terkait dengan peningkatan / penurunan register awal selama pengalamatan tidak langsung.  Fitur ini diwarisi dari PMK Soviet. <br><br>  Sebagai contoh, perintah pembacaan tidak langsung KI 0, KI 1, KI 2 dan KI 3 mengurangi isi register 0, 1, 2 atau 3 oleh satu ke register yang diinginkan. Perintah KI 4, KI 5 dan KI 6 sebelum membaca, tambah isi register 4, 5, atau 6 per satu. <br><br>  "Modifikasi" register alamat ini memungkinkan Anda untuk memproses seluruh grup register dalam satu lingkaran.  Ini mirip dengan ++ R dan --R di C.  Nomor register register penting.  Dialah yang menentukan apakah akan meningkat (register 4-6) atau berkurang (register 0-3) dengan pengalamatan tidak langsung. <br><br>  Arsitektur 161eForth dipengaruhi oleh fakta bahwa peningkatan register 4-6 dengan pengalamatan tidak langsung adalah <i>awal</i> .  Akibatnya, penafsiran penunjuk (IP) yang terletak di R6 selalu <i>menunjuk ke byte terakhir dari</i> kode yang dijahit.  Di 86eForth, IP selalu menunjukkan byte berikutnya yang belum dibaca. <br><br>  Ini juga berlaku untuk pointer tumpukan kembali (RP) yang disimpan dalam register 2. R2 selalu menunjuk ke atas tumpukan kembali. <br><br>  Fitur yang berguna dari MK-161 adalah tidak adanya kenaikan / penurunan register jika pengalamatan tidak langsung terjadi dengan kunci R. yang baru. Misalnya, RKIP02 menghitung angka dari atas tumpukan kembali tanpa mengubah pointer.  Ini adalah tim Fort R @ yang siap pakai.  Dari penjelasan di atas, berikut bahwa nilai baca adalah satu kurang dari alamat token berikutnya, yang akan dieksekusi setelah kembali dari kata "titik dua". <br><br>  Ketika Anda harus mengembangkan atau mempelajari kata-kata yang berinteraksi erat dengan interpreter internal eForth, pastikan untuk sepenuhnya memahami titik halus ini terkait dengan <b>berlebihan</b> . <br><br><h3>  2.2 Tabel, dipesan dan asosiatif </h3><br>  Tabel MK-161 terletak di memori program (lihat 2.4.3).  Mereka muncul di "Electronics MK" Novosibirsk dan sama sekali tidak terbiasa dengan para ahli PMK Soviet.  Alamat tabel yang digunakan selalu disimpan dalam register 9042, tetapi aksesnya berbeda. <br><br>  <i>Tabel dipesan</i> adalah array bilangan bulat 16-bit yang tidak ditandatangani.  eForth berisi tabel tblTokens dengan alamat primitif (lihat 3.1.1) - Fort kata yang ditulis dalam sistem perintah MK-161.  Penerjemah alamat (lihat 3.2) menggunakan tblTokens untuk mengeksekusi kode dijahit dengan cepat, jadi eForth berusaha untuk selalu memuat alamat tabel ini di R9042. <br><br>  Untuk mengakses tabel yang dipesan, Anda perlu menulis nomor item yang diinginkan di R9210.  Angka n dalam register X akan digantikan oleh nilai elemen tabel dengan angka n, hitungan dimulai dari nol. <br><br>  <i>Tabel asosiatif</i> ("pencarian berdasarkan nilai") secara aktif digunakan oleh eForth, terutama oleh primitif (FIND), mencari kata dengan namanya.  Selain itu, tabel asosiatif tblCHPUT digunakan saat mencetak huruf ke layar untuk memproses umpan baris dan kode kontrol lainnya. <br><br>  Untuk mencari elemen n dalam tabel asosiatif, tulis n ke R9212.  Angka n dalam register X (manajemen menyebutnya "indeks") akan diganti dengan nilai 16-bit yang dicatat dalam tabel segera setelah "indeks" n. <br><br>  Kehadiran fungsi pencarian yang cepat, meskipun sederhana ini diimplementasikan dalam bahasa assembly di "firmware" MK-161 membantu eForth mencapai kinerja yang dapat diterima ketika mengenali nama kata dan menyusun program.  Tentu saja, untuk ini saya harus mengembangkan bukan tabel pengenalan nama yang paling sederhana, "dipertajam" untuk fungsi ini.  Kami akan membicarakan hal ini secara lebih rinci di artikel kedua. <br><br><h3>  2.3 Interupsi dan Konsol </h3><br>  "MK Electronics" memungkinkan pemiliknya untuk menulis program dalam bahasa input yang merespons peristiwa tertentu - seperti menekan atau melepaskan tombol, mengakhiri penghitung waktu. <br><br>  eForth secara aktif menggunakan <i>sistem interupsi</i> ini untuk input keyboard dan kursor yang berkedip ketika diminta untuk input tersebut, dan untuk input / output melalui port serial universal (RS-232). <br><br>  Huruf-huruf yang dimasukkan dari keyboard dalam antrian bufKbd saat Anda menekan tombol.  Ini sangat mudah dan menghemat waktu pada sistem dengan kecepatan rendah.  Alfabet dan penggantian kasus ditangani oleh interupsi KeyPress dan tidak memakan ruang antrian.  Tekan lama pada tombol panggil ulang otomatis. <br><br>  Ketika garis 8 huruf penuh, dan eForth belum siap untuk memproses input (situasinya sangat jarang), MK-161 akan mengeluarkan mencicit yang tidak bahagia.  Tentu saja, saya tidak ingin menerapkan semua pekerjaan alami keyboard ini pada penerjemah, tetapi untuk mengeluarkan MK-161 di luar kotak sebagai layanan dari program bawaan (firmware).  Tapi apa, seperti kata mereka, kaya. <br><br>  Setelah mulai bekerja, seluruh output eForth diarahkan ke <i>layar grafik</i> MK-161.  Keluaran huruf di atasnya dilakukan oleh rutinitas CNCut yang relatif sederhana.  Satu-satunya kesulitan di sini adalah penerapan kode kontrol BS, "ruang belakang".  MK-161 menggunakan font proporsional.  Oleh karena itu, dalam tblBS buffer khusus Anda harus mengingat posisi karakter yang ditampilkan, dari mana kode output BS kemudian mengambilnya. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama dialog, pengguna dapat menggunakan kata IO&gt; untuk mengalihkan semua input / output ke port serial RS-232, yang memungkinkan untuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memprogram MK-161 dari keyboard komputer yang sudah dikenal atau dari MK-161 lain</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kata CON&gt; mengembalikan kendali ke konsol kalkulator.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4 Area Memori dan Instalasi eForth pada MK-161 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memori "MK-161 Electronics" terdiri dari memori program yang dapat dialamatkan secara terpisah dan memori register data. Pada gilirannya, memori register heterogen dan dibagi menjadi tiga area besar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mendaftar dengan angka dari 0 hingga 999 menyimpan "angka desimal". Ini adalah register biasa, seperti pada "Elektronik B3-34" dan kalkulator lainnya. Mereka hanya mampu menyimpan bukan 8, tetapi 12 tempat desimal "mantissa". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register dengan angka dari 1000 hingga 8167 menyimpan integer dari 0 hingga 255. 3 Kbytes terakhir dari area ini dengan alamat dari 5096 hingga 8167 disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">area teks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register dengan angka dari 9000 hingga 9999 disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">register fungsi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Area layanan ini dari ruang alamat menyerupai port I / O mikroprosesor. </font><font style="vertical-align: inherit;">Dengan bantuan perintah tulis dan baca, alamat ini digunakan untuk mengakses perangkat I / O, sistem interupsi, dll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menginstal eForth pada Electronics MK-161, cukup untuk mentransfer empat file ke kalkulator, misalnya, menggunakan program dari produsen MK.EXE:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tulis eForth.mkp ke memori program mulai dari halaman 0. Versi 0.5b menempati 74 halaman. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tulis eForth.mkd ke memori data desimal </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tulis eForth.mkb ke memori data biner </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tulis eForth.mkt ke memori teks </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah mentransfer ke kalkulator, saya sarankan segera </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyimpan keempat file ini di direktori terpisah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "disk elektronik" bawaan. </font><font style="vertical-align: inherit;">Karena mereka memiliki nama yang sama, Anda dapat mengunduh eForth segera sekaligus sebagai "paket".</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.1 Memori biner ("byte") MK-161: eForth.mkb </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register Electronics MK dengan angka dari 1000 hingga 5095 digunakan untuk menyimpan angka dari 0 hingga 255. Area memori register kalkulator ini disebut biner. Dua register biner berturut-turut dapat diakses dari eForth sebagai “sel” 16-bit tunggal, dan (seperti di semua tempat pada MK-161), 8 bit atas berada dalam register dengan angka yang lebih rendah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth menggunakan "memori biner" kecil ini sebagai yang utama. Kata-kata bekerja dengannya! dan @, DI SINI dan ALLOT, hanya dari sini penerjemah alamat mengeksekusi kode dijahit (lihat 3.2). Berikut adalah variabel eForth, buffer input teks (TIB), kamus, dan tumpukan rollback tblBS untuk mengimplementasikan backspace. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4096 byte sangat sederhana, dengan standar modern. Oleh karena itu, upaya besar telah dikeluarkan untuk membawa ke bidang memori lain segala sesuatu yang mungkin.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.2 Area teks: eForth.mkt </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera setelah memori biner adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">area teks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , register dengan angka dari 5095 ke 8167. Secara teknis, ini adalah register byte yang sama, tetapi kemampuan untuk menuliskannya ke disk dan membaca sebagai file terpisah membuat area ini spesial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata TLOAD digunakan untuk bekerja dengan "teks" di eForth. </font><font style="vertical-align: inherit;">Ini memberi makan seluruh area ini ke input penerjemah teks, sebagai string, 3072 huruf. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada perbedaan pendapat tentang cara memecah teks menjadi beberapa baris. </font><font style="vertical-align: inherit;">Seorang editor yang tergabung dalam MK Electronics bersikukuh pada panjang garis 24 karakter. </font><font style="vertical-align: inherit;">Callisto menggunakan konvensi Fort, di mana string berisi 64 karakter. </font><font style="vertical-align: inherit;">eForth memberi pengguna pilihan untuk menghitung semua teks sebagai satu garis panjang. </font><font style="vertical-align: inherit;">Anda dapat menggunakan editor bawaan MK-161. </font><font style="vertical-align: inherit;">Anda dapat menulis sendiri, kompatibel dengan Callisto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut adalah konten awal eForth.mkt, untuk kenyamanan, dibagi menjadi tiga baris: </font></font><br><br><pre><code class="plaintext hljs">: hi ." , %user%!" CR ; ' hi 'boot ! hi \</code> </pre> <br>  Baris pertama mendefinisikan kata baru hai yang menyapa pengguna.  Baris kedua mengambil token kata ini (lihat 3.1) dan menempatkannya dalam variabel 'BOOT (lihat 1).  Sekarang area teks akan berhenti mengkompilasi setiap kali eForth dimulai.  Sebaliknya, salam yang sudah dikompilasi akan dieksekusi. <br><br>  Baris terakhir memulai kata hi, menampilkan salam di layar.  Kata \ melengkapi interpretasi teks, mengembalikan kontrol ke konsol. <br><br>  Untuk mengkompilasi file teks sewenang-wenang, Anda harus pergi ke kalkulator dengan perintah BYE, pergi ke menu utama dan memuat file yang diinginkan dalam mode DOS.  Anda juga dapat mentransfer file mkt dari komputer.  Kunci C / P akan mengembalikan Anda ke eForth, setelah itu dengan perintah TLOAD Anda dapat mengkompilasi file yang dimuat ke dalam area teks. <br><br><h4>  2.4.3 Memori program: eForth.mkp </h4><br>  Memori program MK-161 adalah ruang alamat yang terisolasi.  Itu juga menyimpan byte, tetapi mereka hanya baca.  Memori program berisi 10.000 "langkah", yang ternyata berlebihan untuk eForth.  Lebih dari seperempat memori program ternyata gratis, yang memberikan cadangan yang baik untuk pengembangan penerjemah. <br><br>  Hanya dalam memori program "kode kata" dapat diimplementasikan.  Juga, tabel pengenalan nama dan semua string teks yang dikenal di-render di sini, yang menghemat memori biner. <br><br>  Beberapa kata, seperti C @, COUNT, dan TYPE, dapat mengatasi memori program jika alamatnya bukan angka positif.  Misalnya, frasa 0 C @ dihitung sebagai "langkah" (byte) dari alamat 0 memori program. <br><br><h4>  2.4.4 Memori desimal: eForth.mkd </h4><br>  Register dari MK Electronics dengan angka dari 0 hingga 999 disebut desimal dan mengandung angka yang digunakan untuk perhitungan biasa pada kalkulator - 12 angka desimal dari "mantissa" dan 2 angka desimal dari "pesanan".  Benteng dirancang untuk bekerja dengan bilangan bulat hingga 4 byte, sumber daya seperti itu jelas berlebihan untuk eForth. <br><br>  Memori desimal digunakan untuk menghemat memori biner yang berharga.  Tumpukan data dan pengembalian dilakukan di sini.  Judul kata disimpan di sini - baik yang ditentukan pengguna dan disematkan, satu register per judul.  Pendekatan ini memungkinkan Anda untuk mendefinisikan kembali kata-kata genap dengan nama standar. <br><br>  Tumpukan dalam memori desimal mengarah ke sejumlah fitur karakteristik Benteng pada MK-161.  Pertama, rentang nilai elemen stack sangat besar, dapat mengakomodasi bilangan bulat 32-bit.  Kebutuhan untuk "bilangan bulat ganda" pada MK-161 menghilang, meskipun demi kompatibilitas saya telah menerapkan kata-kata yang sesuai eForth.  "Bilangan bulat ganda" disajikan pada MK-161, sebagai dua elemen tumpukan yang berisi angka dari 0 hingga 65535, menyandikan satu bilangan bulat 32-bit dengan tanda pada kode tambahan.  Tinggi 16 bit dari angka ini ditempatkan di atas, yaitu di alamat terendah. <br><br>  Operasi logis bitwise DAN, ATAU, XOR, dan TIDAK memperlakukan argumen mereka sebagai bilangan bulat 16-bit.  Hasil dari 32768 hingga 65535 dikonversi ke angka negatif dari -32768 hingga -1.  Di eForth, false dikodekan dengan nol dan kebenaran minus satu.  Juga benar adalah nilai selain nol. <br><br>  Fitur kedua dari tumpukan data 161eForth adalah bahwa ia berisi angka yang ditandatangani.  Ketika kata @ membaca angka 65535 dari "sel" 16-bit, kata itu secara otomatis dikonversi ke -1.  Sebuah <b>kata "tidak bertanda" khusus U @</b> disediakan untuk menghitung secara langsung 65535, dengan tanda tambah. <br><br>  Saya ingat bahwa demi kecepatan, <b>dua elemen teratas dari tumpukan</b> data tidak terletak di memori desimal, tetapi langsung <b>di register X dan Y.</b> <br><br>  Fakta bahwa register desimal dapat mengandung angka fraksional dan angka floating point tidak digunakan oleh eForth.  Mesin virtual eForth menggunakan register ini untuk menyimpan bilangan bulat desimal 12-bit yang sudah ditandatangani.  Register desimal diakses dengan kata-kata C @ dan C!  - yang sama yang bekerja dengan register tunggal. <br><br><h2>  3. Penerjemah internal </h2><br>  Inti eForth adalah program yang ditulis dalam bahasa input MK-161.  Perintah MAIN pertamanya mentransfer kontrol ke kode MAIN, yang pertama-tama mengetahui keadaan reboot.  Jika itu disebabkan oleh token yang salah, MK-161 akan mencicit.  Pada start-up pertama, dan juga setelah menyalakan MK-161, layar dihapus.  Selanjutnya, MAIN memanggil subitut Init untuk menginisialisasi sistem interupsi dan semua yang dibutuhkan driver konsol MK-161. <br><br>  Setelah menginisialisasi tumpukan dan pengembalian data, bagian level rendah dari permulaan selesai.  Hal-hal luar biasa terjadi untuk mesin dengan arsitektur Harvard - eForth melanjutkan untuk mengeksekusi "kode berkabel" dari memori byte.  Kehormatan menjadi yang pertama milik kata yang alamat tajuknya dicatat di R43.  Ini biasanya kata DINGIN. <br><br>  Bagaimana <i>kata-kata tingkat tinggi</i> (IED) diatur?  Kata apa pun terdiri dari dua bagian, satu badan dan satu judul.  <i>Header</i> disimpan dalam desimal.  Ini membantu interpreter eksternal dan dekompiler menemukan nama dan isi kata.  Judul ini juga berisi <i>bidang "leksikon"</i> - satu set bendera yang membantu penerjemah eksternal memproses kata yang ditemukan dengan benar.  Interpreter internal jauh lebih penting bagi badan VCA yang terletak di memori biner dan disimpan dalam kamus.  Dia bahkan dapat mengeksekusi kata-kata yang tidak memiliki heading. <br><br>  <i>Badan</i> VCA dimulai dengan byte dari <i>bidang kode</i> , yang berisi alamat <i>prosesor dari</i> kata yang diberikan.  Empat penangan VCA ditulis dalam bahasa input MK-161 dan mulai pada halaman pertama memori program.  Kami akan menganalisis semuanya (lihat 3.3), tetapi yang utama disebut DOLST dan terletak di alamat 02, segera setelah perintah MAIN BP dipertimbangkan.  Pawang ini mengeksekusi kata-kata Fort yang didefinisikan dengan titik dua. <br><br>  Setelah byte <i>bidang</i> kode <i>adalah bidang parameter yang</i> panjangnya sewenang <i>-</i> wenang.  Dalam "kata-kata titik dua", bidang parameter berisi "kode dijahit" - urutan token 16-bit, masing-masing menunjukkan satu tindakan yang ditugaskan untuk itu. <br><br>  Pertama, kami akan mempertimbangkan token secara lebih rinci.  Kemudian kita akan mempelajari interpreter internal INEXT, yang mentransfer dari satu token ke eksekusi berikutnya.  EForth menyebut INEXT sebagai penangan primitif.  Kami menyimpulkan tur interpreter internal ini dengan menganalisis keempat prosesor IED. <br><br><h3>  3.1 Token </h3><br>  <i>Token</i> mewakili kata dalam kode dan tumpukan yang dijahit, yang memungkinkannya dieksekusi dengan cepat.  Token adalah penunjuk ke badan kata, tetapi arsitektur kasar dari MK-161 membuat penyesuaian sendiri untuk ide sederhana ini.  Mari kita menganalisis semua jenis token, dimulai dengan token primitif. <br><br><h4>  3.1.1 Token Primitif </h4><br>  Semua kata yang termasuk dalam distribusi eForth diberi nomor dari 0 hingga 206. Penomoran ini end-to-end, dengan mempertimbangkan primitif dan VCA.  Ini dilakukan agar dengan jumlah kata itu mudah untuk mengembalikan <i>namanya</i> .  Nama-nama ini disimpan dalam memori program.  Tautan ke nama yang diinginkan mudah ditemukan melalui tabel header. <br><br>  <b>Angka primitif adalah tokennya</b> .  Seperti token apa pun, primitif mengambil dua byte dalam kode dijahit.  Yang pertama adalah nol.  Yang kedua berisi nomornya.  Tabel tblTokens memungkinkan Anda untuk dengan cepat menemukan alamat kode primitif dengan nomor ini.  Alamat tblTokens disimpan secara permanen di R9042 (lihat 2.2), artinya, semuanya selalu ada untuk mengeksekusi primitif. <br><br>  Kata XT&gt; memungkinkan Anda untuk mengetahui alamat kode primitif dengan nomornya (token).  Karena kode primitif selalu terletak di memori program, alamat yang diterima selalu negatif (lihat 2.4.3). <br><br><h4>  3.1.2 Token VCA </h4><br>  VCA dapat memiliki nomor sendiri dan nama standar yang terkait, atau dapat sepenuhnya baru, dibuat oleh pengguna.  Dalam semua kasus, <b>token VCA adalah alamat bidang kode-nya</b> (lihat 3), yaitu angka dari 1000 hingga 5095. <br><br>  Dalam kode dijahit, token VCA ditulis dengan cara yang sangat tidak biasa.  Jumlah ratusan (angka dari 10 hingga 50) ditulis dalam byte pertama, sisanya dari membagi token dengan 100 (angka dari 0 hingga 99) dalam byte kedua. <br><br>  Misalnya, token 1234 akan diwakili oleh dua byte 12 dan 34. Kompilasi ini, dan token lainnya, dilakukan dengan menggunakan kata COMPILE yang diambil dari standar ANSI.  Untuk menulis dan membaca token VCA dalam kode dijahit, kata-kata XT!  dan XT @.  Mereka mengakses alamat (lihat 3.1.4), dan kata XT @ juga dapat membaca token primitif. <br><br><h4>  3.1.3 Literal integer </h4><br>  <i>Seluruh literal</i> adalah semacam token primitif.  Mereka cukup tidak biasa untuk dipertimbangkan secara terpisah. <br><br>  Dalam kode dijahit, token DOLIT dan DOLITM menempati empat byte.  Dua byte pertama berisi token primitif yang sudah dipertimbangkan, yaitu 0 dan jumlah primitif.  Dua byte berikutnya berisi bilangan bulat yang akan diberikan literal pada tumpukan data selama eksekusi. <br><br>  DOLITM berbeda karena mengubah tanda nomor sebelum meletakkannya di tumpukan.  Ini dirancang untuk menerapkan angka negatif. <br><br><h4>  3.1.4 Alamat Literal </h4><br>  Seperti seluruh literal, tiga <i>literal alamat</i> BRANCH ,? BRANCH, dan DONXT masing-masing menempati 4 byte dalam kode dijahit.  2 byte pertama berisi token primitif, dua byte terakhir adalah alamat lompat. <br><br>  Alamat tersebut direkam dalam format yang sama dengan token VCA (lihat 3.1.2).  Byte pertama berisi jumlah ratusan, yang kedua berisi sisa dari membagi alamat dengan 100. Saya ingat bahwa karena berlebihan (lihat 2.1), alamat transisi tidak berisi alamat token yang diinginkan, tetapi angka kurang per satu. <br><br>  Token DONXT membantu mengimplementasikan "akhir siklus" FOR-NEXT (lihat 1).  Lompatan tanpa syarat CABANG diperlukan untuk mengimplementasikan loop BEGIN-AGAIN yang tak terbatas.  Cabang bersyarat? CABANG mentransfer kontrol jika nol ada di atas tumpukan data (salah).  Ini berfungsi untuk mengimplementasikan pernyataan IF-THEN bersyarat, keluar dari "loop tidak terbatas" BEGIN-UNTIL dan BEGIN-WHILE-REPEAT. <br><br><h4>  3.1.5 String literal </h4><br>  <i>String literal</i> adalah jenis token VCA.  Dalam kode dijahit string literal, setelah token, ada byte dengan panjang string, setelah itu adalah string itu sendiri, dari byte pertama ke yang terakhir. <br><br>  EForth memiliki tiga string literal: $ "| ,." | |  dan batalkan "|. Mereka didefinisikan dalam file eForth0.mkl masing-masing sebagai STRQP, DOTQP, dan ABORQ. Pekerjaan" literal "utama dilakukan untuk mereka dengan kata do $, token DOSTR. <br><br>  Untuk membuat ukuran artikel masuk akal, saya tidak bisa terlalu memikirkan topik menarik ini, tapi senang mengetahui tentang ketersediaannya di eForth. <br><br><h3>  3.2 Penerjemah alamat </h3><br>  Sudah waktunya untuk mempertimbangkan <i>token interpreter</i> , yang alamatnya selalu dituliskan dalam register 9. Kebanyakan primitif menyelesaikan pekerjaan mereka dengan perintah K BP 9, yang mentransfer kendali ke label INEXT. <br><br><pre> <code class="plaintext hljs">INEXT: 6 Fx≠0 NPrime NData:  2 6 + 7 F⟳ 7 8 F⟳ 8</code> </pre> <br>  Pertama, penerjemah alamat membaca byte pertama dari token berikutnya dengan perintah KIP6.  Jika nol, ini primitif dan kode di bawah label NPrime akan menangani token. <br><br>  Label NData menunjukkan pemrosesan token VCA.  Byte pertama dikalikan dengan seratus oleh perintah VP 2, setelah itu KIP6 + menambahkan byte kedua dari token ke hasilnya (lihat 3.1.2).  Tanda baca dimasukkan oleh tim P7 ke dalam "register kerja" WP (R7). <br><br>  Kita tahu bahwa token VCA adalah alamat bidang kode-nya, yang berisi alamat prosesor.  Perintah KIP7 P8 membaca byte bidang kode dalam R8, dan perintah KBP8 mentransfer kontrol ke prosesor VCA.  Pawang tahu bahwa R7 berisi nomor satu kurang dari alamat bidang parameter kata yang sedang diproses. <br><br>  Perintah F⟳ dengan kode 25 "dirapikan" di tumpukan.  Faktanya adalah bahwa eForth menyimpan dua elemen teratas dari tumpukan data secara langsung dalam register X dan Y dari tumpukan MK-161.  Solusi semacam itu mempercepat pekerjaan, tetapi membuatnya perlu untuk memastikan bahwa data penting ini tidak hilang. <br><br>  Masih harus dipahami bagaimana penerjemah alamat mengeksekusi primitif. <br><br><pre> <code class="plaintext hljs">NPrime: F⟳ 6 9210 8 F⟳ 8</code> </pre> <br>  Perintah KIP6 membaca byte kedua dari token primitif.  Perintah RRP9210 P8 membaca alamat primitif ini dari tabel tblTokens (lihat 2.2 dan 3.1.1), dan KBP8 mentransfer kontrol ke primitif ini. <br><br>  Seperti di atas, F⟳ menghapus kelebihan dari tumpukan, mengembalikan konten register X dan Y. <br><br>  Penerjemah alamat eForth sangat kecil sehingga digandakan beberapa kali dalam memori program.  Salinan utama dijalankan oleh perintah K BP 9, yang melengkapi sebagian besar primitif. <br><br>  Sebagai latihan, saya sarankan mempelajari implementasi kata EXECUTE, ditempatkan setelah label EXECU.  Ini adalah varian INEXT, yang membaca token bukan dari kode dijahit, tetapi mengambilnya dari tumpukan data. <br><br><h3>  3.3 Penangan VCA </h3><br>  Empat varietas VCA memiliki empat penangan yang berbeda: DOLST, DOVAR, DOCON, dan DOCONM.  Kita telah melihat di atas bahwa penerjemah alamat sebelum memanggil pawang meninggalkan dalam R7 alamat bidang kode dari kata yang sedang diproses. <br><br>  eForth.f mempelajari alamat penangan ini dengan membaca header kernel dari file eForth0.mkp.  Ini membantunya untuk mengkompilasi VCA untuk Electronics MK-161 dengan benar dengan menempatkan hasilnya di file eForth.mkb. <br><br><h4>  3.3.1 Kata Colon: DOLST dan EXIT </h4><br>  Topik penting berikutnya setelah INEXT adalah apa yang dilakukan penerjemah internal ketika menemukan token kata yang didefinisikan melalui titik dua.  Bidang kode kata seperti itu berisi angka 2, jadi INEXT mentransfer kontrol ke penangan DOLST, yang melakukan pekerjaan yang diperlukan untuk mulai menafsirkan daftar token baru. <br><br><pre> <code class="plaintext hljs">DOLST: 6 2 F⟳ 7 6 F⟳ INEXT:</code> </pre> <br>  Daftar 2, seperti yang telah kita bahas (lihat 2.1), berisi pointer stack return RP.  Perintah IP6 KP2 menuliskan nilai R6, Interpretation Pointer (IP), ke tumpukan kembali.  Nantinya ini akan membantu untuk mengingat posisi saat ini dalam daftar token lama, di mana INEXT menemukan kata titik dua.  Sekarang IP7 P6 mengatur ulang IP ke awal daftar baru. <br><br>  Segera setelah kode DOLST, kode INEXT ditempatkan, yang akan mengeksekusi kata pertama dari daftar token baru.  Seperti di tempat lain, perintah F  membantu menjaga dua elemen teratas dari tumpukan data. <br><br>  Kata Colon biasanya diakhiri dengan token EXITT, yang melakukan sebaliknya, dibandingkan dengan DOLST - ia mengambil nilai IP lama dari tumpukan kembali dan kembali ke interpretasi dari daftar token lama. <br><br><pre> <code class="plaintext hljs">EXITT: 02 6 x 1 2 + 2 F⟳ INEXT:</code> </pre> <br>  Perintah RKIP02 P6 membaca nilai IP lama dari atas tumpukan kembali (lihat 2.1).  Setelah itu, perintah Cx 1 IP2 + P2 mengoreksi nilai RP, meningkatkannya dengan satu.  Perintah F⟳ mengembalikan tumpukan, setelah itu INEXT mengeksekusi kata berikutnya dari daftar token lama. <br><br>  Tentu saja, INEXT tidak dapat digunakan setelah DOLST dan setelah EXITT secara bersamaan.  Untuk melakukan ini, saya menerapkan satu trik kuno dari zaman Uni Soviet.  Anda juga bisa menguasainya dengan memeriksa baris yang sesuai di file eForth0.mkl. <br><br><h4>  3.3.2 DOVAR, penangan variabel dan array </h4><br>  Kata-kata yang dihasilkan oleh kata-kata BUAT dan VARIABEL menggunakan penangan DOVAR yang sama.  Pawang ini mendorong pada stack alamat variabel yang terletak di bidang parameter, yang langsung muncul setelah byte bidang kode.  Variabel VARIABEL menempati 2 byte, dan array yang dibuat menggunakan CREATE mengandung sebanyak byte yang diinginkan oleh programmer. <br><br><pre> <code class="plaintext hljs">DOVAR: ⇔ 3 x 1 7 + 9</code> </pre> <br>  Perintah ⇔ KP3 menyimpan konten register Y di tumpukan data.Pada saat yang sama, nomor dari atas tumpukan dimasukkan ke RY, membebaskan RX ke nilai baru.  Setelah perintah Cx 1 IP7 +, nilai baru ini di bagian atas tumpukan menjadi alamat bidang parameter kata yang dapat dieksekusi.  KBP9 mentransfer kontrol ke INEXT, tanpa trik apa pun, beralih ke kata berikutnya. <br><br><h4>  3.3.3 Penangan Konstan: DOCON dan DOCONM </h4><br>  Tidak seperti DOVAR, <i>pengendali konstan</i> mengakses bidang parameter dari kata itu sendiri.  DOCON membaca nilai konstan 16-bit darinya.  Nilai ini selalu positif. <br><br><pre> <code class="plaintext hljs">DOCON: ⇔ 3 ⇔ 7 5 x 256 5 × 5 + 9</code> </pre> <br>  Perintah ⇔ KP3 ⇔ simpan RY di tumpukan data.  Tapi kali ini, bagian atas tumpukan data kembali ke RX.  Perintah IP7 P5 memaksanya kembali ke RY, sambil mempersiapkan register pointer R5 untuk membaca nilai konstanta.  Selanjutnya, Cx 256 menggantikan sampah di register X dengan nomor 256. <br><br>  Instrumen KIP5 × KIP5 + membaca konstanta dari bidang parameter ke atas tumpukan data, yaitu di RX.  Seperti yang kita ingat, di MK-161 byte pertama selalu tinggi.  Ini dikalikan dengan 256, setelah itu byte terkecil dari konstanta ditambahkan ke produk.  Semua pekerjaan selesai, KBP9 mentransfer kontrol ke kata berikutnya. <br><br>  DOCONM bekerja dengan cara yang persis sama, hanya tanda konstan setelah membaca perubahan yang berlawanan.  Konstanta negatif diimplementasikan pada MK-161 sebagai prosesor terpisah demi kecepatan: <br><br><pre> <code class="plaintext hljs">DOCONM: ⇔ 3 ⇔ 7 5 x 256 5 × 5 + /-/ 9</code> </pre> <br>  Sekarang kita telah benar-benar mengetahui bagaimana eForth mengeksekusi kodenya pada MK-161 Electronics dari area data, bahkan menyentuh topik yang lebih dalam dari string literal (lihat 3.1.5). <br><br>  Dalam artikel kedua seri ini, saya akan berbicara tentang penerjemah “teks” eksternal, menganalisis, tabel tajuk dan pengenalan nama.  Bagian penerjemah ini mengharuskan saya untuk mengembangkan solusi yang jauh lebih radikal, dengan latar belakang yang dibahas di atas adalah Benteng tradisional, tua dan baik. <br><br>  Pemrograman Happy Fort! <br><br><h2>  Sastra </h2><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth dan Zen - Edisi ke-3, 2017. Tersedia di Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Bahasa Fort dan implementasinya.  - L.: Teknik mesin.  Leningrad  Departemen, 1988. </li><li>  Semenov Yu.A.  Pemrograman dalam bahasa FORT.  - M.: Radio dan komunikasi, 1991. </li><li>  ANS Keempat standar.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terjemahan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi SP-Forth</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Offete Store (Prosiding Dr. Chen-Hanson Ting)</a> , tempat Anda dapat mengunduh 86eForth v5.2 untuk Windows, dokumentasi dalam bahasa Inggris. </li></ol><br><br><h2>  Ilustrasi video </h2><br>  Keempat video kecil ini dilanjutkan.  Video pertama di awal artikel. <br><br>  Bagian 2 dari 5. Tes TEST-TEST4 dari buku "eForth and Zen", edisi ke-3, pada MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7UuQSozjuJ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Bagian 3 dari 5. LIHAT dekompiler. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/K-mWJuL1fiQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Bagian 4 dari 5. Breakpoint BYE, terminal RS-232 dan akses jarak jauh ke MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Cfj60ICJrHU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Bagian 5 dari 5. Kata penutup. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oAAX29TpH9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452398/">https://habr.com/ru/post/id452398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452384/index.html">Prosesor akan mempercepat optik menjadi 800 Gb / dtk: cara kerjanya</a></li>
<li><a href="../id452388/index.html">Saringan Eratosthenes di luar O (n). Bukti</a></li>
<li><a href="../id452390/index.html">Software Defined Radio - bagaimana cara kerjanya? Bagian 3</a></li>
<li><a href="../id452392/index.html">Pilihan dataset pembelajaran mesin</a></li>
<li><a href="../id452394/index.html">Opus tentang Yang Mulia Clay. Bagian Dua - Viva, Cyanoacrylate! Viva, superglue</a></li>
<li><a href="../id452400/index.html">Bisnis tidak efektif</a></li>
<li><a href="../id452402/index.html">Eksperimen dengan dioda terowongan analog</a></li>
<li><a href="../id452404/index.html">Lima tren ITSM utama untuk tahun ini</a></li>
<li><a href="../id452408/index.html">Toilet Maine Coon</a></li>
<li><a href="../id452410/index.html">Bash diluncurkan secara detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>