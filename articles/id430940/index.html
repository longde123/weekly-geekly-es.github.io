<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“  ğŸ‘©ğŸ¾â€âš•ï¸ ğŸ”¥ SDK untuk Anda, SDK untuk saya, SDK untuk semua orang! Cara membuat SDK dan mengapa diperlukan ğŸ‘‚ğŸ¿ ğŸ…ğŸ¼ ğŸ…ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 


 Perusahaan kami membuat layanan untuk menyimpan dan memproses data dari perangkat industri (pompa, bor dan peralatan industri lainn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SDK untuk Anda, SDK untuk saya, SDK untuk semua orang! Cara membuat SDK dan mengapa diperlukan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430940/"><p><img src="https://habrastorage.org/webt/pk/ur/nt/pkurntejpmw1zarvuwn67jvh61k.jpeg"></p><br><p>  Halo semuanya! </p><br><p>  Perusahaan kami membuat layanan untuk menyimpan dan memproses data dari perangkat industri (pompa, bor dan peralatan industri lainnya).  Kami menyimpan data pelanggan kami dan menyediakan fungsionalitas untuk analisis mereka: membuat laporan, grafik, dan banyak lagi lainnya. </p><br><p>  Dan dalam perjalanannya, kami memperhatikan bahwa integrasi setiap klien baru sangat tertunda, dan jumlah berbagai kesalahan terus meningkat.  Kemudian menjadi jelas bahwa sudah waktunya untuk berurusan dengan ini.  Seperti yang ditunjukkan oleh analisis situasi, departemen TI masing-masing klien kami mengembangkan solusi mereka sendiri untuk mengumpulkan data secara lokal dari perangkat dan mengirimkannya ke layanan kami.  Ini memperumit fakta bahwa, dengan mempertimbangkan kekhasan industri, tidak selalu ada akses ke Internet dan perlu untuk menyimpan data secara lokal dan mengirimkannya sesegera mungkin.  Dan ada sejumlah besar nuansa seperti itu, yang mengarah pada peningkatan jumlah kesalahan. </p><br><p>  Dan kemudian kami menyadari bahwa solusi terbaik dalam situasi ini adalah mengembangkan SDK dan memberikannya kepada klien.  Segera saya mulai mencari praktik terbaik dan pertimbangan tentang pengembangan SDK dan sangat terkejut - praktis tidak ada apa-apa di RuNet, tetapi hanya ada sedikit informasi tentang Internet Basurmani dan tersebar.  Nah, tugasnya jelas, dipikirkan dan diimplementasikan. </p><br><p>  Tetapi kurangnya informasi tentang topik ini yang menciptakan keinginan untuk memberi tahu masyarakat tentang pemikiran, keputusan yang dibuat, dan kesimpulan tentang pengembangan SDK.  Artikel ini membahas solusi untuk .NET, tetapi ini adalah konsep, sehingga akan menarik bagi banyak orang.  Detail di bawah potongan! </p><a name="habracut"></a><br><h2 id="pora-opredelyatsya">  Sudah saatnya ditentukan </h2><br><p>  Mari kita mulai dengan mendefinisikan apa itu SDK dan mengapa itu mungkin diperlukan. </p><br><blockquote>  SDK (dari perangkat pengembangan perangkat lunak bahasa Inggris) adalah seperangkat alat pengembangan yang memungkinkan spesialis perangkat lunak untuk membuat aplikasi untuk paket perangkat lunak tertentu, perangkat lunak pengembangan dasar, platform perangkat keras, sistem komputer, konsol game, sistem operasi dan platform lainnya.  SDK memanfaatkan setiap platform dan mengurangi waktu integrasi. <br>  ... <br>  Seorang insinyur perangkat lunak biasanya menerima SDK dari pengembang sistem target. </blockquote><p>  Ya, itu masuk akal.  Dengan kata sederhana, SDK adalah paket perpustakaan, sehingga klien dapat dengan mudah dan cepat mulai bekerja dengan sistem Anda (dalam artikel ini kami akan berbicara tentang layanan kami, tetapi semua yang dijelaskan dalam artikel ini berlaku untuk jenis SDK lainnya) atau melakukan tindakan yang sama. </p><br><p>  Namun, seperti pendekatan apa pun, SDK Path memiliki kelebihan dan kekurangan. </p><br><h3 id="preimuschestva">  Manfaatnya </h3><br><p>  <strong>Integrasi kecepatan tinggi dari klien baru</strong> - pelanggan Anda perlu menulis lebih sedikit kode. </p><br><p>  <strong>Penggunaan kembali kode</strong> - kode yang sama digunakan di beberapa tempat sekaligus.  Kita dapat mengatakan bahwa ini adalah duplikasi dari paragraf sebelumnya, tetapi kita berbicara tentang fakta bahwa logika kerja ada di mana-mana sepi, yang menyiratkan </p><br><p>  <strong>Prediktabilitas perilaku</strong> - menggunakan perpustakaan yang sama membawa perilaku sistem ke standar tertentu, yang sangat memudahkan pencarian dan penghapusan kesalahan dan kerentanan. </p><br><p>  <strong>Kualitas kode</strong> adalah tempat di mana banyak orang ingin menghemat dalam pengujian (maaf atas anggaran, tenggat waktu, dan alasan lainnya).  Jelas bahwa di dunia nyata untuk menguji semua bagian proyek dengan tes adalah tugas yang sangat melelahkan.  Tetapi secara kualitatif menguji semua modul SDK, dan kemudian menggunakannya adalah cara untuk meningkatkan persentase cakupan pengujian, yang akan mengarah pada pengurangan jumlah kesalahan. </p><br><p>  <strong>Dokumentasi</strong> adalah skenario yang sama dengan tes.  Mendokumentasikan seluruh proyek cukup bermasalah.  Menggunakan kembali SDK meningkatkan persentase cakupan dokumentasi, yang menurunkan ambang batas bagi karyawan baru untuk memasuki proyek dan umumnya membantu dalam kehidupan. </p><br><p>  Semua keuntungan, pada kenyataannya, adalah konsekuensi dari hal yang paling penting - <strong>kami menulis kode dengan kualitas yang sangat tinggi sekali, dan kemudian menggunakannya kembali</strong> . </p><br><h3 id="nedostatki">  Kekurangan </h3><br><p>  <strong>Persyaratan kualitas tinggi dari kode SDK</strong> adalah hasil dari keunggulan utama.  Kesalahan dalam SDK akan menghasilkan kesalahan di semua sistem yang menggunakannya. </p><br><p>  <strong>Setting Constraints</strong> - SDK adalah sekumpulan perpustakaan untuk mengimplementasikan skrip <strong>standar</strong> .  Terkadang pengembang SDK percaya bahwa selain mengimplementasikan salah satu skenario yang disediakan, klien tidak memerlukan apa-apa, bahwa klien lebih mudah melakukan semuanya dari awal sendiri daripada membangun alas dari kruk untuk SDK. </p><br><p>  <strong>Ketergantungan dan pembaruan</strong> - saat memperluas fungsionalitas (misalnya, menyesuaikan solusi untuk klien tertentu), Anda akan merilis versi baru perpustakaan.  Tetapi ada dependensi, kumpulan versi pustaka yang berbeda untuk klien yang berbeda, dan Anda perlu memonitor kompatibilitas mundur atau versi ketat. </p><br><h3 id="kogda-sdk-deystvitelno-nuzhen">  Kapan SDK benar-benar dibutuhkan </h3><br><p>  <strong>Anda memiliki beberapa skenario standar yang diterapkan lagi dari waktu ke waktu</strong> - pada kenyataannya, kasus kami. </p><br><p>  <strong>Pengembangan internal</strong> - dalam berbagai proyek Anda menggunakan sistem logging, konfigurasi sistem, bekerja dengan HttpRequest, database, file?  Membangun <strong>SDK internal</strong> - satu set perpustakaan untuk penggunaan internal.  Anda dapat memperluas fungsionalitas SDK kapan saja, tetapi kecepatan pengembangan proyek baru, persentase cakupan dengan tes dan dokumentasi akan meningkat, dan ambang batas bagi pengembang baru untuk masuk akan berkurang. </p><br><h3 id="kogda-sdk-skoree-vsego-budet-lishnim">  Ketika SDK cenderung menjadi berlebihan </h3><br><p>  <strong>Skenario penggunaan tidak didefinisikan atau terus berubah</strong> - biarkan penerapan solusi khusus untuk pelanggan dan bantu mereka.  Tidak perlu membuat keajaiban wunderwaffle, yang hanya akan mengganggu.  Sangat relevan untuk perusahaan dan startup muda. </p><br><p>  <strong>Anda tidak tahu bagaimana melakukannya secara kualitatif</strong> - saya punya berita buruk untuk Anda: sekarang saatnya untuk belajar.  Tetapi memberikan keputusan yang bengkok kepada klien sangat, sangat salah.  Bagaimanapun, pelanggan harus dihormati. </p><br><p>  Jadi, kami memutuskan apa SDK itu, dengan kelebihan dan kekurangannya, dan kapan kami membutuhkannya.  Jika setelah itu Anda menyadari bahwa SDK benar-benar diperlukan - saya mengundang Anda untuk memulai "jalur SDK" dan mencari tahu apa yang seharusnya dan bagaimana melakukannya? </p><br><h2 id="a-vy-lyubite-lego---modulnost">  "Apakah kamu menyukai Lego?"  - Modularitas </h2><br><p>  Bayangkan semua skenario yang mungkin untuk menggunakan SDK (Anda sudah memutuskan mengapa Anda membutuhkannya, kan?) Dan buat skrip untuk perpustakaan.  Apa yang bukan pilihan?  Tapi ini pendekatan yang buruk, jadi kami tidak akan melakukannya.  Dan kita akan menjadi seperti ini: </p><br><ul><li>  pisahkan semua skrip menjadi beberapa langkah </li><li>  mengidentifikasi langkah-langkah umum </li><li>  buat daftar <strong>modul</strong> yang menerapkan semua langkah yang mungkin (satu modul bertanggung jawab untuk mengimplementasikan sesuatu yang spesifik, misalnya, bekerja dengan konfigurasi) </li></ul><br><p>  Sebagai contoh, dengan mempertimbangkan spesifikasi tugas, kita membutuhkan semua logika yang akan ditetapkan dari konfigurasi.  Kami mengimplementasikan modul untuk bekerja dengan konfigurasi (baca, tulis, perbarui, konfirmasikan, dan konfigurasi proses) dan kami akan menggunakannya dalam semua modul lainnya. </p><br><p>  Dan untuk implementasi skenario standar, kami benar-benar akan membuat modul - modul "kontrol", yang masing-masing mengimplementasikan satu skenario spesifik, menggunakan modul lain dari SDK yang sama.  Jadi, untuk implementasi skenario standar, klien hanya perlu menghubungkan modul kontrol skrip (dan dia akan menarik semua dependensi), dan untuk implementasi yang tidak standar, kami menggunakan modul dasar, juga menggunakan kembali kode. </p><br><p>  Inilah tepatnya alasan mengapa SDK tidak boleh menjadi satu perpustakaan (walaupun saya benar-benar ingin, saya mengerti. Lagi pula, ketika seluruh SDK berada dalam satu perpustakaan, Anda bisa melupakan dependensi dan segala sesuatu yang terhubung dengan mereka), tetapi menjadi satu set perpustakaan.  Keuntungan tambahan dari pendekatan ini adalah pengurangan "berat" program klien - ini akan menarik SDK kelas berat, dan hanya akan menarik modul yang diperlukan. </p><br><p>  Tetapi Anda seharusnya tidak menghasilkan modul, karena semakin banyak modul, semakin sakit kepala dari ketergantungan mereka!  Yaitu  Penting untuk membagi logika menjadi modul dengan benar, menjaga keseimbangan antara keputusan "semua dalam satu" dan "setiap modul memiliki modul sendiri." </p><br><h2 id="a-chto-tak-mozhno-bylo---universalnost">  "Jadi itu mungkin?!"  - fleksibilitas </h2><br><p>  Menyediakan klien dengan berbagai antarmuka untuk bekerja dengan perpustakaan Anda.  Saya akan memberi contoh: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadConfiguration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadConfigurationAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  Jika Anda hanya menyediakan versi sinkron, maka ketika menerapkan aplikasi asinkron, klien akan dipaksa untuk melakukan pembungkus asinkron dari metode sinkron Anda.  Jika Anda hanya menyediakan versi asinkron, situasinya mirip.  Berikan kedua hal ini kepada klien dan dia akan berterima kasih. </p><br><p>  Generik akan menjadi nilai tambah yang bagus.  Sebagai contoh, kami memiliki kelas untuk bekerja dengan konfigurasi yang mengimplementasikan metode untuk mengemas konfigurasi ke dalam sebuah string, memuat konfigurasi dari file, dll.  Konfigurasi modul tertentu akan diwarisi dari kelas dasar kami, tetapi untuk bekerja dengan kelas baru kami juga perlu menyediakan metode unpacking. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BaseConfiguration</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BaseConfiguration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>{...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BaseConfiguration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source,Type configurationType</span></span></span><span class="hljs-function">)</span></span>{...} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T FromString&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> source) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T:BaseConfiguration } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomConfiguration</span></span> : <span class="hljs-title"><span class="hljs-title">BaseConfiguration</span></span>{}</code> </pre> <br><p>  Dengan demikian, kami telah menyediakan klien dengan tiga implementasi yang dapat ia gunakan.  Generik sangat nyaman, tetapi ketika bekerja dengan tipe dinamis, mereka dapat dipanggil hanya melalui refleksi, yang tidak menguntungkan.  Prinsip umum universalitas, saya harap, jelas. </p><br><h2 id="roditel-1-roditel-2-deti----imenovanie">  "Parent 1, Parent 2, Children []" - Penamaan </h2><br><blockquote>  Apa bagian tersulit dalam seorang programmer?  Ciptakan nama untuk variabel. </blockquote><p>  Namun demikian ... Penamaan modul, kelas, properti, dan metode yang tepat akan sangat membantu mereka yang akan bekerja dengan SDK Anda.  Contoh tidak memerlukan komentar: </p><br><p>  <strong>Contoh Kinect 2.0 SDK</strong> </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skeletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Skeleton[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skeletonFrame = e.OpenSkeletonFrame()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skeletonFrame != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { skeletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Skeleton[skeletonFrame.SkeletonArrayLength]; skeletonFrame.CopySkeletonDataTo(skeletons); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skeletons.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skel = skeletons.FirstOrDefault(x =&gt; x.TrackingState == SkeletonTrackingState.Tracked); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skel == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightHand = skel.Joints[JointType.WristRight]; XValueRight.Text = rightHand.Position.X.ToString(CultureInfo.InvariantCulture); YValueRight.Text = rightHand.Position.Y.ToString(CultureInfo.InvariantCulture); ZValueRight.Text = rightHand.Position.Z.ToString(CultureInfo.InvariantCulture);</code> </pre> <br><p>  Semuanya jelas dari nama-nama kelas dan metode.  Dan jika ada penyelesaian kode dalam IDE Anda, maka sering kali mungkin untuk tidak melihat dokumentasi jika semuanya sudah jelas. </p><br><h2 id="uveren-esli-by-smert-znala-chto-takoe-byurokratiya-lyudi-by-nikogda-ne-umirali-vechno-stoya-v-ocheredi---dokumentaciya">  "Saya yakin bahwa jika Kematian tahu apa itu birokrasi, orang tidak akan pernah mati, selamanya mengantre ..." - Dokumentasi </h2><br><p>  Tetapi meskipun semua modul, kelas, metode, dan properti diberi nama dengan sangat indah dan mendesak, Anda masih perlu menulis dokumentasi.  Pertama, itu akan sangat menyelamatkan Anda (jumlah pertanyaan pelanggan dikurangi dengan urutan besarnya. Semuanya ada dalam dokumentasi), dan kedua, selalu jelas mengapa Anda melakukan ini dan bukan sebaliknya. </p><br><blockquote>  Dokumentasi dalam SDK biasanya sederhana dan ringkas.  Biasanya dibagi menjadi dua bagian: Tutorial - kursus selangkah demi selangkah dalam gaya "Membangun kota dalam 10 menit" dan bagian Referensi - referensi untuk segala sesuatu yang dapat dilakukan menggunakan SDK ini. </blockquote><p>  Kami memilih cara termudah - ringkasan + artikel.  Kami menambahkan atribut Xml untuk metode dan kelas yang bercahaya di intellisense sebagai tooltips.  Dengan menggunakan Docfx, kami membuat dokumentasi tentang atribut-atribut ini dan mendapatkan dokumentasi yang terperinci dan nyaman, yang dilengkapi dengan artikel yang menggambarkan kasus penggunaan dan contoh. </p><br><h2 id="-chtoby-chisto-bylo--kak-ya-budu-vilkoy-to-chistit---testirovanie">  "- Agar tetap bersih! - Bagaimana saya membersihkannya dengan garpu?"  - Menguji </h2><br><p>  Apa yang bisa dikatakan tentang pengujian sebagai bagian dari diskusi SDK ... Harus ada!  Solusi terbaik adalah TDD (terlepas dari kenyataan bahwa saya memiliki sikap negatif terhadap pendekatan ini, dalam hal ini saya memutuskan untuk menggunakannya).  Ya, waktu yang lama.  Ya, membosankan.  Tetapi di masa depan Anda tidak akan menggantung diri dari kejatuhan konstan SDK di samping dan konsekuensi dari kejatuhan ini. </p><br><p>  Inti dari situasi ini adalah bahwa dengan memberikan SDK kepada klien Anda kehilangan kendali: Anda tidak dapat dengan cepat memperbaiki kesalahan, sulit untuk menemukan kesalahan ini, dan Anda akan terlihat cukup bodoh dalam situasi seperti itu.  Oleh karena itu - uji.  Tes lebih baik.  Dan sekali lagi.  Dan untuk berjaga-jaga, uji tes Anda.  Dan tes tes.  Jadi, sesuatu yang saya terbawa, tetapi pentingnya menguji SDK, saya harap, jelas. </p><br><h2 id="zhertva-kotoraya-ne-mogla-protivostoyat-svoemu-proshlomu-byla-pogloschena-im---logi">  "Seorang korban yang tidak bisa menolak masa lalunya dikonsumsi olehnya" - Logi </h2><br><p>  Karena Anda memberikan SDK ke perusahaan pihak ketiga, akibatnya Anda kehilangan kendali atas situasi tersebut, jika terjadi kesalahan (pada tahap pengujian Anda semua memutuskan "itu akan berhasil," bukan?), Sebuah proses yang agak lama dan menyakitkan menunggu Anda untuk mencari kesalahan ini.  Di sinilah log membantu Anda. </p><br><p>  <strong>Log semuanya</strong> , benar-benar segalanya, dan jika terjadi kesalahan, mintalah log kepada klien Anda.  Dengan cara ini Anda akan menghemat banyak waktu dan tidak dapat menggosok wajah Anda di depan klien. </p><br><h2 id="alarm-achtung-attention---oshibki">  "Alarm! Achtung! Perhatian!"  - Kesalahan </h2><br><p><img src="https://habrastorage.org/webt/au/2d/b0/au2db0fwmmfbfxrtkw4kqmexht4.gif"><br>  Sambil memikirkan banyak hal tentang kesalahan, saya sampai pada kesimpulan yang menarik - <strong>bukan metode tunggal di SDK Anda yang harus memberikan kesalahan yang tidak dijelaskan dalam dokumentasi</strong> .  Anda harus mengakui bahwa itu sangat tidak menyenangkan ketika Anda menghubungkan perpustakaan pihak ketiga untuk bekerja dengan HttpRequest, dan ia melempar beberapa NullPointerException dan StackTrace pada Anda, yang akan membawa Anda ke dalam perut perpustakaan.  Dan Anda harus terjun ke "perut" ini, mencoba memahami seberapa dalam lubang kelinci itu, dan apa, sebenarnya, masalahnya. </p><br><p>  Oleh karena itu, saya mengusulkan solusi berikut - mendeklarasikan daftar tertutup dari kemungkinan pengecualian dan mendokumentasikannya.  Tetapi, karena  Anda tidak dapat memastikan bahwa Anda telah menyediakan segalanya, bungkus metode dalam try-catch, dan kesalahan yang tertangkap dalam yang dinyatakan.  Misalnya, ConfigurationException yang akan berisi InnerException adalah kesalahan yang diketahui.  Ini akan memungkinkan pengembang pihak ketiga untuk menangkap semua kesalahan yang mungkin terjadi, tetapi jika sesuatu terjadi, cepat cari tahu apa masalahnya. </p><br><h2 id="versii-ili-kak-ne-ukusit-sebya-za-hvost">  Versi atau "bagaimana tidak menggigit ekormu" </h2><br><p>  Untuk menghindari masalah di masa depan, saya sangat merekomendasikan menggunakan versi ketat.  Pilih sistem versi yang cocok untuk Anda dan gunakan.  Tetapi jika versi baru perpustakaan tidak memiliki kompatibilitas ke belakang, ini harus ditunjukkan.  Bagaimana mengatasinya - menurut Anda.  Tetapi Anda pasti harus memikirkannya. </p><br><h2 id="parovozik-kotoryy-smog---deploy">  "A Train That Could" - Menyebarkan </h2><br><p>  Kebutuhan akan relevansi dokumentasi dan versi menimbulkan persyaratan untuk kebenaran penyebaran.  Dalam keputusan kami, kami menggunakan solusi berikut (kruk, tetapi mereka bekerja). <br>  Ketika perlu untuk merilis rilis baru, pengembang menarik bat'nik dengan nomor rilis, dan kemudian file batch: </p><br><ul><li>  membangun rilis </li><li>  menempatkan semua perpustakaan di arsip </li><li>  membangun versi terbaru dari dokumentasi (docfx) </li><li>  menunjukkan versi rilis dalam dokumentasi dan atas nama arsip </li><li>  menempatkan semua yang terbaru di repositori git </li><li>  WebApp di MS Azure menarik komit git segar dan menerbitkan perubahan </li></ul><br><p>  Pada output kami mendapatkan versi terbaru dari situs dengan dokumentasi, dari mana Anda dapat mengunduh arsip dengan versi terbaru dari SDK. <br>  Rencana ke depan termasuk mengemas semuanya ke dalam paket Nuget dan menerbitkannya ke repositori Nuget lokal. </p><br><p>  Saya sarankan memperhatikan hal ini, karena Anda dapat secara signifikan mengurangi jumlah sakit kepala yang disebabkan oleh kurangnya informasi yang relevan tentang versi baru perpustakaan. </p><br><h2 id="-a-tak-mozhesh---fignya-smotri-kak-nado---primery--toolkit">  "-Dan kamu bisa? - Omong kosong. Lihat bagaimana seharusnya!"  - Contoh &amp; toolkit </h2><br><p>  Poin penting dalam dokumentasi adalah contoh penggunaan.  Namun selain itu, sering kali diminta untuk tidak menyediakan perpustakaan, tetapi aplikasi yang mengimplementasikan skenario paling standar.  Saya sarankan membuat aplikasi ini dengan kode sumber yang terbuka dan berkomentar dengan baik, yang akan memungkinkan Anda untuk membunuh dua burung dengan satu batu - menyediakan aplikasi yang berfungsi dan memberikan contoh menggunakan SDK. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Pengembangan SDK telah menjadi tugas baru yang menarik bagi saya, yang telah mengangkat banyak masalah arsitektur penting.  Banyak hal yang dijelaskan dalam artikel adalah hal-hal yang jelas (bagi saya), tetapi saya menganggap penting untuk mengumumkan bahkan hal-hal yang jelas untuk mendapatkan gambaran besar yang jelas. </p><br><h2 id="ps">  PS </h2><br><p>  Terima kasih telah membaca, saya akan senang atas komentar Anda.  Saya harap artikel ini bermanfaat bagi Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430940/">https://habr.com/ru/post/id430940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430930/index.html">Tentang grafik 3D dengan kata-kata sederhana</a></li>
<li><a href="../id430932/index.html">Peretas mencuri lebih dari 21 juta rubel dari bank Rusia</a></li>
<li><a href="../id430934/index.html">Asterisk dialplan extension mask generator</a></li>
<li><a href="../id430936/index.html">DEFCON 21. Konferensi DNS dapat berbahaya bagi kesehatan Anda. Bagian 2</a></li>
<li><a href="../id430938/index.html">Cara mendapatkan pesanan pertama dalam desain saat tidak ada portofolio dan pengalaman</a></li>
<li><a href="../id430942/index.html">Julia. Script dan argumen baris perintah parsing</a></li>
<li><a href="../id430944/index.html">NASA telah memutuskan para peserta untuk kompetisi mini-moon rover</a></li>
<li><a href="../id430948/index.html">Kementerian Komunikasi mengusulkan untuk memperketat kendali atas data pribadi</a></li>
<li><a href="../id430950/index.html">Membuat Bangunan Modern</a></li>
<li><a href="../id430952/index.html">Mobil listrik dan mobil hibrida harus membuat suara tambahan: mengapa ini diperlukan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>