<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📀 🌸 🤜🏻 Cara mempercepat kerja dengan API bahasa R menggunakan komputasi paralel, menggunakan contoh Yandex.Direct API (Bagian 1) 📝 🆓 👳🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahasa R saat ini adalah salah satu alat paling kuat dan multifungsi untuk bekerja dengan data, tetapi seperti yang kita tahu hampir selalu, dalam sem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mempercepat kerja dengan API bahasa R menggunakan komputasi paralel, menggunakan contoh Yandex.Direct API (Bagian 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437078/"><p>  Bahasa R saat ini adalah salah satu alat paling kuat dan multifungsi untuk bekerja dengan data, tetapi seperti yang kita tahu hampir selalu, dalam sembarang madu ada lalat di salep.  Faktanya adalah bahwa R adalah single-threaded secara default. </p><br><p>  Kemungkinan besar ini tidak akan mengganggu Anda untuk waktu yang cukup lama, dan Anda tidak mungkin mengajukan pertanyaan ini.  Tetapi misalnya, jika Anda dihadapkan dengan tugas mengumpulkan data dari sejumlah besar akun iklan dari API, misalnya Yandex.Direct, maka Anda dapat secara signifikan, setidaknya dua hingga tiga kali, mengurangi waktu yang diperlukan untuk mengumpulkan data menggunakan multithreading. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/86f/042/b60/86f042b609e10a79893f2dfbc24fd6f8.jpg" alt="gambar"></p><a name="habracut"></a><br><p> Topik multithreading di R bukanlah hal yang baru, dan telah berulang kali diangkat tentang Habré di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi publikasi terakhir berasal dari tahun 2013, dan sebagaimana mereka mengatakan bahwa segala sesuatu yang baru sudah lama terlupakan.  Selain itu, multithreading sebelumnya dibahas untuk menghitung model dan melatih jaringan saraf, dan kita akan berbicara tentang menggunakan asinkron untuk bekerja dengan API.  Meskipun demikian, saya ingin mengambil kesempatan ini untuk mengucapkan terima kasih kepada penulis artikel ini karena  mereka banyak membantu saya dalam menulis artikel ini dengan publikasi mereka. </p><br><h2 id="soderzhanie">  Isi </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu multithreading</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket apa yang akan kita gunakan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tantangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Otorisasi di Yandex.Direct, paket ryandexdirect</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi berurutan single-threaded menggunakan untuk loop</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi Multithreading di R</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket DoSNOW dan fitur multithreaded</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket DoParallel</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes kecepatan antara tiga pendekatan yang ditinjau, paket rbenchmark</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ul><br><p>  Bagian kedua dari artikel ini, yang berkaitan dengan opsi yang lebih modern untuk mengimplementasikan multithreading di R, tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h2 id="chto-takoe-mnogopotochnost">  Apa itu multithreading </h2><br><p>  <u><strong>Satu-threading (Perhitungan berurutan)</strong></u> - mode perhitungan di mana semua tindakan (tugas) dilakukan secara berurutan, total durasi semua operasi yang diberikan dalam kasus ini akan sama dengan jumlah durasi semua operasi. </p><br><p>  <u><strong>Multithreading (Parallel computing)</strong></u> - mode komputasi di mana tindakan tertentu (tugas) dilakukan secara paralel, mis.  pada saat yang sama, sedangkan total waktu pelaksanaan semua operasi tidak akan sama dengan jumlah durasi semua operasi. </p><br><p>  Untuk menyederhanakan persepsi, mari kita lihat tabel berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f01/295/d5d/f01295d5dcf31db7d8ea8826c724f271.png" alt="gambar"></p><br><p>  Baris pertama dari tabel yang diberikan adalah unit waktu bersyarat, dalam hal ini tidak masalah bagi kami detik, menit atau periode waktu lainnya. </p><br><p>  Dalam contoh ini, kita perlu melakukan 4 operasi, setiap operasi dalam kasus ini memiliki durasi perhitungan yang berbeda, dalam mode single-threaded, semua 4 operasi akan dilakukan secara berurutan, oleh karena itu, total waktu untuk pelaksanaannya adalah t1 + t2 + t3 + t4, 3 + 1 + 5 + 4 = 13. </p><br><p>  Dalam mode multi-utas, semua 4 tugas akan dilakukan secara paralel, mis.  untuk memulai tugas berikutnya, tidak perlu menunggu sampai yang sebelumnya selesai, jadi jika kita memulai tugas kita dalam 4 utas, maka total waktu perhitungan akan sama dengan waktu perhitungan dari tugas terbesar, dalam kasus kami adalah tugas t3, durasi perhitungan yang dalam contoh kami adalah 5 unit sementara, masing-masing, dan waktu pelaksanaan semua 4 operasi dalam hal ini akan sama dengan 5 unit sementara. </p><br><h2 id="kakie-pakety-my-budem-ispolzovat">  Paket apa yang akan kita gunakan </h2><br><p> Untuk perhitungan dalam mode multithreaded, kami akan menggunakan paket <code>foreach</code> , <code>doSNOW</code> dan <code>doParallel</code> . </p><br><p>  Paket <code>foreach</code> memungkinkan Anda untuk menggunakan konstruksi <code>foreach</code> , yang pada dasarnya merupakan peningkatan untuk loop. </p><br><p>  Paket <code>doSNOW</code> dan <code>doParallel</code> pada dasarnya adalah saudara kembar, memungkinkan Anda untuk membuat cluster virtual dan menggunakannya untuk melakukan komputasi paralel. </p><br><p>  Di akhir artikel, menggunakan paket <code>rbenchmark</code> kami akan mengukur dan membandingkan durasi operasi pengumpulan data dari Yandex.Direct API menggunakan semua metode yang dijelaskan di bawah ini. </p><br><p>  Untuk bekerja dengan Yandex.Direct API, kami akan menggunakan paket ryandexdirect, dalam artikel ini kami akan menggunakannya sebagai contoh, rincian lebih lanjut tentang kemampuan dan fungsinya dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> . </p><br><p>  Kode untuk menginstal semua paket yang diperlukan: </p><br><pre> <code class="plaintext hljs">install.packages("foreach") install.packages("doSNOW") install.packages("doParallel") install.packages("rbenchmark") install.packages("ryandexdirect")</code> </pre> <br><h2 id="zadacha">  Tantangan </h2><br><p>  Anda harus menulis kode yang akan meminta daftar kata kunci dari sejumlah akun iklan Yandex.Direct.  Hasilnya harus dikumpulkan dalam satu kerangka tanggal, di mana akan ada bidang tambahan dengan login akun iklan tempat kata kunci tersebut berada. </p><br><p>  Selain itu, tugas kami adalah menulis kode yang akan melakukan operasi ini secepat mungkin pada sejumlah akun iklan. </p><br><h2 id="avtorizaciya-v-yandeksdirekt">  Otorisasi di Yandex.Direct </h2><br><p>  Untuk bekerja dengan API platform periklanan Yandex.Direct, pada awalnya diharuskan untuk pergi melalui otorisasi di bawah setiap akun dari mana kami berencana untuk meminta daftar kata kunci. </p><br><p>  Semua kode yang diberikan dalam artikel ini mencerminkan contoh bekerja dengan akun iklan Yandex.Direct reguler, jika Anda bekerja di bawah akun agen, Anda perlu menggunakan argumen <em>AgencyAccount</em> dan meneruskan login akun agen untuk itu.  Anda dapat mengetahui lebih lanjut tentang bekerja dengan akun agen Yandex.Direct menggunakan paket ryandexdirect di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Untuk otorisasi diperlukan untuk menjalankan fungsi <code>yadirAuth</code> dari paket <code>yadirAuth</code> , untuk mengulangi kode di bawah ini diperlukan untuk setiap akun dari mana Anda akan meminta daftar kata kunci dan parameter mereka. </p><br><pre> <code class="plaintext hljs">ryandexdirect::yadirAuth(Login = "    ")</code> </pre> <br><p>  Proses otorisasi di Yandex.Direct melalui paket <code>ryandexdirect</code> benar-benar aman, terlepas dari kenyataan bahwa ia melewati situs pihak ketiga.  Saya sudah berbicara secara rinci tentang keamanan penggunaannya dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Seberapa Aman Menggunakan Paket R untuk Bekerja dengan API Sistem Periklanan"</a> . </p><br><p>  Setelah otorisasi, file <em>login.yadirAuth.RData</em> akan dibuat di bawah setiap akun di direktori kerja Anda, yang akan menyimpan kredensial untuk setiap akun.  Nama file akan dimulai pada login yang ditentukan dalam argumen <em>Login</em> .  Jika Anda perlu menyimpan file bukan di direktori kerja saat ini, tetapi di beberapa folder lain, gunakan argumen <em>TokenPath</em> , tetapi dalam kasus ini ketika <code>yadirGetKeyWords</code> kata kunci menggunakan fungsi <code>yadirGetKeyWords</code> Anda juga perlu menggunakan argumen <em>TokenPath</em> dan menentukan path ke folder tempat Anda menyimpan file. dengan kredensial. </p><br><h2 id="reshenie-v-odnopotochnom-posledovatelnom-rezhime-s-ispolzovaniem-cikla-for">  Solusi berurutan single-threaded menggunakan untuk loop </h2><br><p>  Cara termudah untuk mengumpulkan data dari beberapa akun sekaligus adalah dengan menggunakan <code>for</code> .  Sederhana tetapi bukan yang paling efektif, karena  salah satu prinsip pengembangan dalam bahasa R adalah untuk menghindari penggunaan loop dalam kode. </p><br><p>  Di bawah ini adalah contoh kode untuk mengumpulkan data dari 4 akun menggunakan loop for, pada kenyataannya, Anda dapat menggunakan contoh ini untuk mengumpulkan data dari sejumlah akun iklan. </p><br><div class="spoiler">  <b class="spoiler_title">Kode 1: Kami memproses 4 akun menggunakan loop biasa</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(ryandexdirect) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") #    res1 &lt;- data.frame() #    for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) temp$login &lt;- login res1 &lt;- rbind(res1, temp) }</code> </pre> </div></div><br><p>  Mengukur runtime menggunakan fungsi system.time menunjukkan hasil berikut: </p><br><p>  <strong>Waktu kerja:</strong> <br>  <u>Pengguna:</u> 178.83 <br>  <u>sistem:</u> 0,63 <br>  <u>berlalu:</u> 320.39 </p><br><p>  Pengumpulan kata kunci untuk 4 akun memerlukan waktu 320 detik, dan dari pesan informasi yang <code>yadirGetKeyWords</code> fungsi <code>yadirGetKeyWords</code> selama operasi, akun terbesar terlihat, 5970 kata kunci diterima, dan 142 detik diproses. </p><br><h2 id="reshenie-s-pomoschyu-mnogopotochnosti-v-r">  Solusi Multithreading di R </h2><br><p>  Saya sudah menulis di atas bahwa untuk multithreading kita akan menggunakan <code>doParallel</code> dan <code>doParallel</code> . </p><br><p>  Saya ingin menarik perhatian pada kenyataan bahwa hampir semua API memiliki batasannya sendiri, dan API Yandex.Direct tidak terkecuali.  Faktanya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bantuan</a> untuk bekerja dengan Yandex.Direct API mengatakan: </p><br><blockquote>  Tidak lebih dari lima permintaan API simultan diizinkan atas nama satu pengguna. </blockquote><p>  Oleh karena itu, terlepas dari kenyataan bahwa dalam hal ini kami akan mempertimbangkan contoh dengan pembuatan 4 aliran, dalam bekerja dengan Yandex.Direct Anda dapat membuat 5 aliran bahkan jika Anda mengirim semua permintaan di bawah pengguna yang sama.  Tetapi yang paling rasional untuk menggunakan 1 utas per 1 inti dari prosesor Anda, Anda dapat menentukan jumlah inti prosesor fisik menggunakan perintah <code>parallel::detectCores(logical = FALSE)</code> , jumlah core logis dapat ditemukan menggunakan <code>parallel::detectCores(logical = TRUE)</code> .  Pemahaman yang lebih terperinci tentang inti fisik dan logis seperti apa yang dimungkinkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> . </p><br><p>  Selain batas pada jumlah permintaan, ada batas harian pada jumlah poin untuk mengakses API Yandex.Direct, mungkin berbeda untuk semua akun, setiap permintaan juga mengkonsumsi jumlah titik yang berbeda tergantung pada operasi yang dilakukan.  Misalnya, untuk menanyakan daftar kata kunci Anda akan dikurangkan 15 poin untuk kueri yang selesai dan 3 poin untuk setiap 2000 kata, Anda dapat mengetahui bagaimana poin dihapuskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sertifikat resmi</a> .  Anda juga dapat melihat informasi tentang jumlah poin yang dicetak dan tersedia, serta batas harian mereka dalam pesan informasi yang dikembalikan ke konsol oleh fungsi <code>yadirGetKeyWords</code> . </p><br><pre> <code class="plaintext hljs">Number of API points spent when executing the request: 60 Available balance of daily limit API points: 993530 Daily limit of API points:996000</code> </pre> <br><p>  Mari kita berurusan dengan <code>doSNOW</code> dan <code>doParallel</code> agar. </p><br><h3 id="paket-dosnow-i-osobennosti-raboty-v-mnogopotochnom-rezhime">  Paket DoSNOW dan fitur multithreaded </h3><br><p>  Kami menulis ulang operasi yang sama untuk mode perhitungan multi-utas, membuat 4 utas dalam kasus ini, dan alih-alih <code>for</code> loop, kami menggunakan konstruksi <code>foreach</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Kode 2: Komputasi paralel dengan doSNOW</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doSNOW) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- foreach(login = logins, #  -  .combine = 'rbind', #        .packages = "ryandexdirect", #   .inorder=F ) %dopar% {cbind(yadirGetKeyWords(Login = login), login) } stopCluster(cl)</code> </pre> </div></div><br><p>  Dalam hal ini, mengukur runtime menggunakan fungsi system.time menunjukkan hasil berikut: </p><br><p>  <strong>Waktu kerja:</strong> <br>  <u>pengguna:</u> 0,17 <br>  <u>sistem:</u> 0,08 <br>  <u>berlalu:</u> 151.47 </p><br><p>  Hasil yang sama, yaitu  kami menerima koleksi kata kunci dari 4 akun Yandex.Direct dalam 151 detik, mis.  2 kali lebih cepat.  Selain itu, saya hanya menulis dalam contoh terakhir berapa lama untuk memuat daftar kata kunci dari akun terbesar (142 detik), yaitu  dalam contoh ini, total waktu hampir identik dengan waktu pemrosesan akun terbesar.  Faktanya adalah bahwa dengan bantuan fungsi <code>foreach</code> , kami secara bersamaan meluncurkan proses pengumpulan data dalam 4 aliran, yaitu  pada saat yang sama mengumpulkan data dari keempat akun, masing-masing, total waktu sama dengan waktu pemrosesan akun terbesar. </p><br><p>  Saya <code>makeCluster</code> memberikan sedikit penjelasan pada <em>kode 2</em> , fungsi <code>makeCluster</code> bertanggung jawab atas jumlah utas, dalam hal ini kami membuat sekelompok 4 inti prosesor, tetapi seperti yang saya tulis sebelumnya ketika bekerja dengan Yandex.Direct API, Anda dapat membuat 5 utas, terlepas dari berapa banyak akun. Anda perlu memproses 5-15-100 atau lebih, Anda dapat mengirim 5 permintaan ke API secara bersamaan. </p><br><p>  Selanjutnya, fungsi <code>registerDoSNOW</code> memulai cluster yang dibuat. </p><br><p>  Setelah itu kita menggunakan konstruksi <code>foreach</code> , seperti yang saya katakan sebelumnya, konstruksi ini merupakan peningkatan untuk loop.  Anda menetapkan penghitung sebagai argumen pertama, dalam contoh yang saya sebut <em>login</em> dan itu akan mengulangi elemen-elemen vektor <em>login</em> di setiap iterasi, kita akan mendapatkan hasil yang sama di loop <code>for</code> jika kita menulis <code>for ( login in logins)</code> . </p><br><p>  Selanjutnya, Anda perlu menunjukkan dalam argumen <em>.com</em> . Fungsi yang Anda gunakan untuk menggabungkan hasil yang diperoleh pada setiap iterasi, opsi yang paling umum adalah: </p><br><ul><li>  <code>rbind</code> - gabungkan tabel yang dihasilkan baris demi baris di bawah satu sama lain; </li><li>  <code>cbind</code> - gabungkan tabel yang dihasilkan di kolom; </li><li>  <code>"+"</code> - merangkum hasil yang diperoleh pada setiap iterasi. </li></ul><br><p>  Anda juga dapat menggunakan fungsi lain, bahkan yang ditulis sendiri. </p><br><p>  Argumen <em>.inorder = F</em> memungkinkan Anda untuk mempercepat fungsi sedikit lebih banyak jika Anda tidak peduli bagaimana cara menggabungkan hasil, dalam hal ini urutannya tidak penting bagi kami. </p><br><p>  Selanjutnya adalah operator <code>%dopar%</code> , yang memulai loop dalam mode komputasi paralel, jika Anda menggunakan operator <code>%do%</code> , maka iterasi akan dieksekusi secara berurutan, serta ketika menggunakan loop biasa <code>for</code> biasa. </p><br><p>  Fungsi <code>stopCluster</code> menghentikan cluster. </p><br><p>  Multithreading, atau lebih tepatnya konstruksi <code>foreach</code> dalam mode multithreaded, memiliki beberapa fitur, pada kenyataannya, dalam hal ini, kami memulai setiap proses paralel dalam sesi R baru yang bersih.  Oleh karena itu, untuk menggunakan fungsi umum dan objek di dalamnya yang ditentukan di luar konstruksi <code>foreach</code> , Anda perlu mengekspornya menggunakan argumen <em>.export</em> .  Argumen ini mengambil vektor teks yang berisi nama-nama objek yang akan Anda gunakan di dalam <code>foreach</code> . </p><br><p>  Juga, <code>foreach</code> , dalam mode paralel, tidak melihat paket-paket yang sebelumnya terhubung secara default, sehingga mereka juga harus dilewatkan di dalam foreach menggunakan argumen <em>.packages</em> .  Anda juga perlu mentransfer paket dengan mencantumkan nama mereka dalam vektor teks, misalnya <code>.packages = c("ryandexdirect", "dplyr", "lubridate")</code> .  Dalam contoh <em>kode di</em> atas <em>2</em> , kita hanya dengan cara ini memuat paket <strong>ryandexdirect</strong> pada setiap iterasi <code>foreach</code> . </p><br><h3 id="paket-doparallel">  Paket DoParallel </h3><br><p>  Seperti yang saya tulis di atas, paket <code>doSNOW</code> dan <code>doParallel</code> adalah kembar, sehingga mereka memiliki sintaks yang sama. </p><br><div class="spoiler">  <b class="spoiler_title">Kode 5: Komputasi paralel dengan doParallel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doParallel) logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoParallel(cl) res3 &lt;- data.frame() res3 &lt;- foreach(login=logins, .combine= 'rbind', .inorder=F) %dopar% {cbind(ryandexdirect::yadirGetKeyWords(Login = login), login) stopCluster(cl)</code> </pre> </div></div><br><p>  <strong>Waktu kerja:</strong> <br>  <u>pengguna:</u> 0,25 <br>  <u>sistem:</u> 0,01 <br>  <u>berlalu:</u> 173.28 </p><br><p>  Seperti yang dapat Anda lihat dalam kasus ini, waktu eksekusi sedikit berbeda dari contoh sebelumnya dari kode komputasi paralel menggunakan paket <code>doSNOW</code> . </p><br><h2 id="test-skorosti-mezhdu-tremya-rassmotrennymi-podhodami">  Tes kecepatan antara tiga pendekatan ditinjau </h2><br><p>  Sekarang jalankan tes kecepatan menggunakan paket <code>rbenchmark</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a63/b9d/2d4/a63b9d2d476203e701c1c789f013793b.png" alt="gambar"></p><br><p>  Seperti yang Anda lihat, bahkan pada pengujian 4 akun, paket <code>doSNOW</code> dan <code>doParallel</code> menerima data dengan kata kunci 2 kali lebih cepat daripada urutan untuk loop, jika Anda membuat sekelompok 5 core dan memproses 50 atau 100 akun, perbedaannya akan menjadi lebih signifikan. </p><br><div class="spoiler">  <b class="spoiler_title">Kode 6: Skrip untuk membandingkan kecepatan multithreading dan komputasi sekuensial</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   library(ryandexdirect) library(foreach) library(doParallel) library(doSNOW) library(rbenchmark) #         for for_fun &lt;- function(logins) { res1 &lt;- data.frame() for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) res1 &lt;- rbind(res1, temp) } return(res1) } #         foreach   doSNOW dosnow_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login } }) stopCluster(cl) return(res2) } #         foreach   doParallel dopar_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoParallel(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login) } }) stopCluster(cl) return(res2) } #          within(benchmark(for_cycle = for_fun(logins = logins), dosnow = dosnow_fun(logins = logins), doparallel = dopar_fun(logins = logins), replications = c(20), columns=c('test', 'replications', 'elapsed'), order=c('elapsed', 'test')), { average = elapsed/replications })</code> </pre></div></div><br><p>  Sebagai kesimpulan, saya akan memberikan penjelasan tentang <em>kode 5</em> di atas, yang dengannya kami menguji kecepatan kerja. </p><br><p>  Awalnya, kami membuat tiga fungsi: </p><br><p>  <code>for_fun</code> - fungsi yang meminta kata kunci dari beberapa akun, mengurutkannya secara berurutan melalui siklus reguler. </p><br><p>  <code>dosnow_fun</code> - fungsi yang meminta daftar kata kunci dalam mode multithreaded, menggunakan paket <code>doSNOW</code> . </p><br><p>  <code>dopar_fun</code> - fungsi yang meminta daftar kata kunci dalam mode multithreaded, menggunakan paket <code>doParallel</code> . </p><br><p>  Selanjutnya, di dalam konstruksi di dalam, kita menjalankan fungsi <code>benchmark</code> dari paket <code>rbenchmark</code> , menentukan nama tes (for_cycle, dosnow, doparallel), dan masing-masing fungsi yang kita tentukan fungsi, masing-masing: <code>for_fun(logins = logins)</code> ;  <code>dosnow_fun(logins = logins)</code> ;  <code>dopar_fun(logins = logins)</code> . </p><br><p>  Argumen <em>replikasi</em> bertanggung jawab untuk jumlah tes, yaitu  berapa kali kita akan menjalankan setiap fungsi. </p><br><p>  Argumen <em>kolom</em> memungkinkan Anda menentukan kolom mana yang ingin Anda terima, dalam kasus kami 'pengujian', 'replikasi', 'berlalu' berarti mengembalikan kolom: nama pengujian, jumlah pengujian, total waktu pelaksanaan semua pengujian. </p><br><p>  Anda juga dapat menambahkan kolom terhitung, ( <code>{ average = elapsed/replications }</code> ), yaitu  output akan menjadi kolom rata-rata yang akan membagi total waktu dengan jumlah tes, jadi kami menghitung waktu eksekusi rata-rata dari setiap fungsi. </p><br><p>  <em>order</em> bertanggung jawab untuk menyortir hasil tes. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Pada artikel ini, pada prinsipnya, metode yang cukup universal untuk mempercepat pekerjaan dengan API dijelaskan, tetapi setiap API memiliki batasnya, oleh karena itu, khususnya dalam formulir ini, dengan begitu banyak utas, contoh di atas cocok untuk bekerja dengan Yandex.Direct API, untuk menggunakannya dengan API dari layanan lain, pada awalnya perlu membaca dokumentasi tentang batas-batas dalam API untuk jumlah permintaan yang dikirim secara bersamaan, jika tidak, Anda mungkin mendapatkan kesalahan <code>Too Many Requests</code> . </p><br><p>  Kelanjutan artikel ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437078/">https://habr.com/ru/post/id437078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437068/index.html">ILV Membuka 2,7 Juta Alamat IP</a></li>
<li><a href="../id437070/index.html">Alat Data Survei Ilmu 2019</a></li>
<li><a href="../id437072/index.html">Melemahkan kacang dalam aturan Habr</a></li>
<li><a href="../id437074/index.html">Google dapat memblokir layanan berita di Eropa</a></li>
<li><a href="../id437076/index.html">Jatuhnya dan pemulihan cetakan</a></li>
<li><a href="../id437084/index.html">Dari Belum Dipetakan ke Obra Dinn: Lucas Pope berbicara tentang karirnya dalam pengembangan game</a></li>
<li><a href="../id437086/index.html">Media: Peretas meretas ke dalam basis data Komisi Sekuritas AS dan menghasilkan jutaan dari perdagangan orang dalam</a></li>
<li><a href="../id437088/index.html">Promosi startup di luar negeri: cara menjangkau ratusan ribu pembaca berbahasa Inggris dengan Medium</a></li>
<li><a href="../id437092/index.html">Keamanan algoritma pembelajaran mesin. Serangan Python</a></li>
<li><a href="../id437094/index.html">Kami memompa Atlassian Service Desk - pengumuman mitap dan siaran langsung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>