<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äç‚úàÔ∏è ‚§µÔ∏è üìê √úben Sie in der Arbeit mit Custom-Reifen des Redd-Komplexes üçÖ ü§º üíî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel haben wir uns mit der Theorie des Managements von tausend kleinen Dingen im Redd-Komplex befasst, aber um das Volumen nicht zu verg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úben Sie in der Arbeit mit Custom-Reifen des Redd-Komplexes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484706/">  Im <a href="https://habr.com/ru/post/483724/">letzten Artikel haben</a> wir uns mit der Theorie des Managements von tausend kleinen Dingen im Redd-Komplex befasst, aber um das Volumen nicht zu vergr√∂√üern, haben wir die √úbung beim n√§chsten Mal verschoben.  Es ist an der Zeit, praktische Experimente durchzuf√ºhren.  Diejenigen, die den Redd-Komplex nicht verwenden, werden in diesem Artikel auch n√ºtzliche Informationen finden, n√§mlich die Methodik zum Senden von Vendor-Befehlen an USB-Laufwerke von Linux, da der STM32-Controller im Komplex, wie bereits erw√§hnt, die Funktion eines SD-Leseger√§ts √ºbernimmt, d. H. fahren. <br><br><img src="https://habrastorage.org/webt/_e/hh/5n/_ehh5nw2j8tiw7myjovthvvc_va.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Vorherige Zyklusartikel</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs und Debugging am Beispiel des Speichertests.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">Entwicklung der einfachsten "Firmware" f√ºr in Redd installierte FPGAs.</a>  <a href="https://habr.com/ru/post/453682/">Teil 2. Programmcode.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">Entwicklung eines eigenen Kerns zur Einbettung in ein FPGA-basiertes Prozessorsystem.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">Entwicklung von Programmen f√ºr den Zentralprozessor Redd am Beispiel des Zugangs zum FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">Die ersten Versuche mit dem Streaming-Protokoll am Beispiel der CPU- und Prozessorkommunikation im Redd-FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Frohe Quartusel, oder wie der Prozessor zu einem solchen Leben gekommen ist.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">Code-Optimierungsmethoden f√ºr Redd.</a>  <a href="https://habr.com/ru/post/467353/">Teil 1: Cache-Effekt.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">Code-Optimierungsmethoden f√ºr Redd.</a>  <a href="https://habr.com/ru/post/468027/">Teil 2: Nicht zwischengespeicherter Speicher und Parallelbusbetrieb.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Umfassende Codeoptimierung: Austausch eines Taktgenerators zur Verbesserung der Systemleistung.</a> </li><li>  <a href="https://habr.com/ru/post/477662/">Zugriff auf auf FTDI-Controllern implementierte Redd-Busse</a> </li><li>  <a href="https://habr.com/ru/post/483724/">Arbeiten Sie mit Custom-Reifen Komplex Redd</a> </li></ol><br></div></div><br><h2>  Laufwerksklassifizierung nach Befehlssystemen </h2><br>  Bei der Arbeit mit Laufwerken sollten Sie zwischen einer physischen Schnittstelle und einem Befehlssystem unterscheiden.  Insbesondere CD / DVD / BD-Laufwerke und andere Optiken.  Traditionell werden sie an ein SATA-Kabel (fr√ºher IDE) angeschlossen.  Aber speziell auf dieser Leitung laufen im laufenden Betrieb nur PACKET-Befehle, in deren Datenblock nach einem v√∂llig anderen Prinzip codierte Befehle abgelegt sind (von welchem ‚Äã‚Äãwerden wir gleich erfahren).  Deshalb werden wir jetzt nicht so sehr √ºber Dr√§hte sprechen, sondern √ºber die Teams, die in ihnen laufen.  Ich kenne drei g√§ngige Befehlssysteme f√ºr die Arbeit mit Antrieben. <br><br><ul><li>  MMC  Es wird von SD-Karten verstanden.  Ehrlich gesagt ist dies f√ºr mich das mysteri√∂seste Befehlssystem.  Wie man sie einreicht, scheint klar, aber wie man das Laufwerk verwaltet, ohne das Dokument sorgf√§ltig zu lesen, das viele √úbergangsdiagramme enth√§lt - ich bin immer verwirrt.  Zum Gl√ºck st√∂rt uns das heute nicht mehr, denn obwohl wir mit einer SD-Karte arbeiten, arbeitet der STM32-Controller im ‚ÄûBlack-Box‚Äú -Modus damit. </li><li>  ATA  Diese Befehle wurden zun√§chst auf dem IDE-Bus und dann auf SATA ausgef√ºhrt.  Ein wunderbares Befehlssystem, aber wir erw√§hnen heute auch nur, dass es existiert. </li><li>  SCSI  Dieses Befehlssystem wird auf einer Vielzahl von Ger√§ten verwendet.  Betrachten Sie die Verwendung in Laufwerken.  Dort laufen heute SCSI-Teams zun√§chst √ºber die Leitungen des SAS-Busses (√ºbrigens sind mittlerweile auch SSDs mit SAS-Schnittstelle in Mode).  Seltsamerweise funktionieren optische Laufwerke, die physisch an den SATA-Bus angeschlossen sind, auch √ºber SCSI-Befehle.  Auf dem USB-Bus werden die Befehle auch im SCSI-Format abgelegt, wenn nach dem Massenspeicherger√§testandard gearbeitet wird.  Der STM32-Mikrocontroller ist √ºber den USB-Bus mit dem Redd-Komplex verbunden. In unserem Fall folgen die Befehle dem folgenden Pfad: <br><br><img src="https://habrastorage.org/webt/hy/iy/f4/hyiyf4m9sjgr8etz8ily8joxsrc.png"><br></li></ul><br>  Vom PC zum Controller √ºber USB liegen die Befehle im SCSI-Format vor.  Der Controller codiert die Befehle gem√§√ü der MMC-Regel und sendet sie √ºber den SDIO-Bus.  Wir m√ºssen aber ein Programm f√ºr den PC schreiben, damit die Teams uns im SCSI-Format lassen.  Sie werden vom Massenspeicherger√§t-Ger√§tetreiber vorbereitet, mit dem wir √ºber den Dateisystemtreiber kommunizieren.  Ist es m√∂glich, Anforderungen mit anderen Ger√§ten f√ºr diese Anforderungen zu mischen?  Lass es uns richtig machen. <br><br><h2>  Details zum SCSI-Befehlssystem </h2><br>  Wenn Sie sich der Sache formal n√§hern, finden Sie die Beschreibung des SCSI-Standards auf t10.org, aber wir sind realistisch.  Niemand wird es freiwillig lesen.  Genauer gesagt, nicht seine, sondern ihre: Es gibt einen ganzen Stapel offener Dokumente und einen Berg geschlossener Dokumente. Nur ein extremer Bedarf l√§sst Sie in die komplexe Sprache eintauchen, in der der Standard geschrieben ist (dies gilt √ºbrigens f√ºr den ATA-Standard auf t13.org).  Es ist viel einfacher, die Dokumentation f√ºr echte Laufwerke zu lesen.  Es ist in einer lebendigeren Sprache geschrieben, und hypothetische, aber nicht wirklich verwendete Teile werden daraus herausgeschnitten.  W√§hrend der Vorbereitung des Artikels stie√ü ich auf ein ziemlich neues Dokument (2016) aus dem <b>SCSI Commands Reference Manual</b> von Seagate (direkter Link <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">www.seagate.com/files/staticfiles/support/docs/manual/Interface%20manuals/100293068j.pdf),</a> aber wie immer Ich wei√ü nicht, wie lange sie leben wird.  Ich denke, wenn jemand dieses Befehlssystem beherrschen m√∂chte, sollte er mit diesem Dokument beginnen.  Wir erinnern uns nur, dass SD-Leseger√§te eine noch kleinere Teilmenge der Befehle aus dieser Beschreibung implementieren. <br><br>  Kurz gesagt, eine Befehlseinheit mit einer L√§nge von 6 bis 16 Bytes wird an das Laufwerk gesendet.  Ein Datenblock kann entweder vom PC zum Laufwerk oder vom Laufwerk zum PC an den Befehlsblock angeh√§ngt werden (der SCSI-Standard erm√∂glicht auch den bidirektionalen Austausch, f√ºr das Massenspeicherger√§t √ºber USB ist jedoch nur ein Block zul√§ssig, was bedeutet, dass die Richtung nur einer ist).  Im Anweisungsblock ist das erste Byte immer der Befehlscode.  Die verbleibenden Bytes sind die Argumente.  Die Regeln zum Ausf√ºllen der Argumente werden ausschlie√ülich durch die Details der Implementierung des Befehls beschrieben. <br><br><img src="https://habrastorage.org/webt/xt/1l/eb/xt1lebwoznye5dag98pwbtiuxfm.png"><br><br>  Zuerst habe ich viele Beispiele in den Artikel eingef√ºgt, aber dann habe ich festgestellt, dass sie das Lesen erschweren.  Daher empfehle ich jedem, die Felder des Befehls READ CAPACITY (10) aus Tabelle 119 des Seigate-Dokuments und die Felder des Befehls READ (10) aus Tabelle 97 desselben Dokuments zu vergleichen (siehe Link oben).  Wer keine Verbindung gefunden hat - sei nicht beunruhigt.  Das wollte ich zeigen.  Neben dem Feld ‚ÄûBefehl‚Äú im Null-Byte h√§ngt der Zweck aller Felder ausschlie√ülich von den Besonderheiten eines bestimmten Befehls ab.  Sie m√ºssen das Dokument immer √∂ffnen und den Zweck der verbleibenden Felder darin untersuchen. <br><br>  Also: <br><br><ul><li>  Um mit dem Antrieb zu kommunizieren, sollten Sie einen Befehlsblock mit einer L√§nge von 6 bis 16 Bytes bilden (abh√§ngig vom Format des Befehls ist die genaue Anzahl in der Dokumentation dazu angegeben). </li><li>  Das wichtigste ist das Null-Byte des Blocks: Er legt den Befehlscode fest. </li><li>  Die verbleibenden Blockbytes haben keinen eindeutigen Zweck.  Um zu verstehen, wie diese ausgef√ºllt werden, sollten Sie die Dokumentation f√ºr ein bestimmtes Team √∂ffnen. </li><li>  Ein Datenblock, der zu oder von einem Laufwerk √ºbertragen werden kann, kann an einen Befehl angeh√§ngt werden. </li></ul><br>  Eigentlich ist das alles.  Wir haben die Regeln f√ºr die Ausgabe von SCSI-Befehlen kennengelernt.  Jetzt k√∂nnen wir sie einreichen, es w√ºrde eine Dokumentation dar√ºber geben.  Aber wie geht das auf Betriebssystemebene? <br><br><h2>  Linux SCSI-Befehle </h2><br><h3>  Suchen Sie nach dem Zielger√§t </h3><br>  √ñffnen Sie zum Ausgeben von Befehlen das Festplattenger√§t.  Lass uns seinen Namen finden.  Dazu gehen wir genauso vor wie im <a href="https://habr.com/ru/post/477662/">Artikel √ºber serielle Schnittstellen</a> .  Sehen wir uns die Liste der ‚ÄûDateien‚Äú im <b>Verzeichnis / dev an</b> (denken Sie daran, dass auf Linux-Ger√§ten auch Dateien angezeigt werden und ihre Liste mit demselben <b>ls-Befehl</b> angezeigt wird). <br><br>  Heute widmen wir uns dem virtuellen Verzeichnislaufwerk: <br><br><img src="https://habrastorage.org/webt/t_/py/kj/t_pykjsq2_2gdno-u0oc9wdpltm.png"><br><br>  Wir schauen uns den Inhalt an: <br><br><img src="https://habrastorage.org/webt/cp/yp/n_/cpypn_cslhfibis7ixhbez64q4y.png"><br><br>  Ein vertrauter Satz verschachtelter Verzeichnisse!  Wir versuchen, das Verzeichnis <b>by-id</b> mit der <b>Option ‚Äìl</b> des <b>Befehls ls zu betrachten</b> , die uns bereits aus dem Artikel √ºber serielle Schnittstellen bekannt ist: <br><br><img src="https://habrastorage.org/webt/jq/8s/zn/jq8sznkl6pimg5oxevbdp8m7l4w.png"><br><br>  Hervorgehobene W√∂rter sprechen f√ºr sich.  Dies ist ein Laufwerk, das die interne SD-Karte des Redd-Komplexes enth√§lt.  Gro√üartig!  Jetzt wissen wir, dass das Ger√§t <b>MIR_Redd_Internal_SD</b> dem Ger√§t <b>/ dev / sdb und / dev / sdb1 entspricht</b> .  Die, die ohne die Nummer das Laufwerk selbst ist, werden wir damit arbeiten, und mit der Nummer ist es das Dateisystem, das sich auf dem eingelegten Datentr√§ger befindet.  <b>Wenn Sie</b> mit einer SD-Karte arbeiten, ist <b>/ dev / sdb</b> das Leseger√§t und <b>/ dev / sdb1</b> das Dateisystem der eingelegten Karte. <br><br><h3>  Funktion des Betriebssystems zum Ausgeben von Befehlen </h3><br>  In der Regel werden in jedem Betriebssystem alle nicht standardm√§√üigen Vorg√§nge mit Ger√§ten durch direkte Anforderungen an den Treiber ausgef√ºhrt.  Unter Linux steht die Funktion <b>ioctl ()</b> zum Senden solcher Anforderungen zur Verf√ºgung.  Unser Fall ist keine Ausnahme.  Als Argument √ºbergeben wir die in der Header-Datei sg.h beschriebene SG_IO-Anforderung.  <b>Dort</b> ist auch die Struktur <b>sg_io_hdr_t beschrieben</b> , die die Anforderungsparameter enth√§lt.  Ich werde nicht die vollst√§ndige Struktur angeben, da nicht alle Felder ausgef√ºllt werden m√ºssen.  Ich werde nur das Wichtigste von ihnen geben: <br><br><pre><code class="plaintext hljs">typedef struct sg_io_hdr { int interface_id; /* [i] 'S' for SCSI generic (required) */ int dxfer_direction; /* [i] data transfer direction */ unsigned char cmd_len; /* [i] SCSI command length ( &lt;= 16 bytes) */ unsigned char mx_sb_len; /* [i] max length to write to sbp */ unsigned short int iovec_count; /* [i] 0 implies no scatter gather */ unsigned int dxfer_len; /* [i] byte count of data transfer */ void * dxferp; /* [i], [*io] points to data transfer memory or scatter gather list */ unsigned char * cmdp; /* [i], [*i] points to command to perform */ unsigned char * sbp; /* [i], [*o] points to sense_buffer memory */ unsigned int timeout; /* [i] MAX_UINT-&gt;no timeout (unit: millisec) */</code> </pre> <br>  Es macht keinen Sinn, Felder zu beschreiben, die in Kommentaren gut dokumentiert sind ( <b>interface_id, dxfer_direction, timeout</b> ).  Der Artikel w√§chst bereits. <br><br>  Das Feld <b>cmd_len</b> enth√§lt die Anzahl der Bytes im Befehlsblock, und <b>cmdp enth√§lt</b> einen Zeiger auf diesen Block.  Sie k√∂nnen nicht auf einen Befehl verzichten, daher darf die Anzahl der Bytes nicht Null sein (von 6 bis 16). <br><br>  Daten sind optional.  Wenn dies der <b>Fall</b> ist, wird die L√§nge des ausgew√§hlten Puffers im Feld <b>dxfer_len</b> und ein Zeiger darauf im Feld <b>dxferp</b> angegeben.  Ein Laufwerk kann physisch weniger Daten als die angegebene Puffergr√∂√üe √ºbertragen.  Die √úbertragungsrichtung wird im Feld <b>dxfer_direction</b> angegeben.  G√ºltige Werte f√ºr USB-Massenspeicherger√§te sind: <b>SG_DXFER_NONE, SG_DXFER_TO_DEV, SG_DXFER_FROM_DEV</b> .  In der Header-Datei gibt es noch etwas, aber der Massenspeicherger√§te-Standard erlaubt keine physische Implementierung. <br><br>  Sie k√∂nnen auch die R√ºckgabe eines erweiterten Fehlercodes ( <b>SENSE</b> ) <b>anfordern</b> .  Was es ist, ist im Abschnitt 2.4 des Segate-Dokuments zu finden.  Die L√§nge des zugewiesenen Puffers wird im Feld <b>mx_sb_len angegeben</b> , und der Zeiger auf den Puffer selbst wird im Feld <b>sbp angegeben</b> . <br><br>  Wie Sie sehen k√∂nnen, ist alles, wor√ºber ich oben gesprochen habe, in dieser Struktur enthalten (und Sie k√∂nnen erweiterte Informationen √ºber den Fehler erhalten).  Weitere <b>Informationen zum</b> Arbeiten mit <b>SG_IO-</b> Anfragen finden Sie hier: <a href="http://sg.danny.cz/sg/sg_io.html">sg.danny.cz/sg/sg_io.html</a> <br><br><h3>  Wir senden einen Standardbefehl an das Laufwerk </h3><br>  Nun, wir haben das Format des Befehls herausgefunden, wir haben herausgefunden, an welches Ger√§t es gesendet werden soll, wir haben herausgefunden, welche Funktion aufzurufen ist.  Versuchen wir, einen Standardbefehl an unser Ger√§t zu senden.  Sei dies der Befehl, um den Laufwerksnamen zu erhalten.  So wird es im Sigeyt-Dokument beschrieben: <br><br><img src="https://habrastorage.org/webt/nj/qk/ca/njqkcamj1tnhjznoczjnrdfni60.png"><br><br>  Bitte beachten Sie, dass gem√§√ü der SCSI-Ideologie alle Felder in Standardbefehlen in der Big-Endian-Notation ausgef√ºllt sind, d. H. Dem h√∂chsten Byte vorw√§rts.  Deshalb f√ºllen wir das Feld mit der Pufferl√§nge nicht im Format "0x80, 0x00", sondern im Gegenteil - "0x00, 0x80".  Dies ist aber in Standardbefehlen.  In Sonderf√§llen ist alles m√∂glich, konsultieren Sie immer die Beschreibung.  Eigentlich m√ºssen nur der Befehlscode ( <b>12h</b> ) und die L√§nge ausgef√ºllt werden.  Wir fordern eine Seite Null an, und die √ºbrigen Felder sind entweder reserviert oder veraltet oder standardm√§√üig auf Null gesetzt.  Also f√ºllen Sie sie alle mit Nullen. <br><br><div class="spoiler">  <b class="spoiler_title">Wir machen ein Programm, das diesen Befehl gibt:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmd12h[] = { 0x12,0x00,0x00,0x00,0x80,0x00}; uint8_t data[0x80]; uint8_t sense[0x80]; header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmd12h); header.cmdp = cmd12h; //  header.dxfer_len = sizeof(data); header.dxferp = data; header.dxfer_direction = SG_DXFER_TO_FROM_DEV; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br><br>  Wie man solche Programme auf einem entfernten Redd-Ger√§t ausf√ºhrt, haben wir bereits in einem der <a href="https://habr.com/ru/post/456008/">vorhergehenden Artikel</a> besprochen.  Richtig, ich habe beim ersten Start sofort einen Fehler beim Aufrufen der Funktion <b>open () erhalten</b> .  Es stellte sich heraus, dass der Benutzer standardm√§√üig nicht √ºber ausreichende Rechte zum √ñffnen von Plattenger√§ten verf√ºgt.  Welcher von mir ein Linux-Spezialist ist, habe ich oft geschrieben, aber im Netzwerk konnte ich feststellen, dass Sie zur Behebung dieses Problems die Zugriffsrechte auf das Ger√§t √§ndern k√∂nnen, indem Sie den folgenden Befehl eingeben: <br><br>  <b>sudo chmod 666 / dev / sdb</b> <br><br>  Mein Chef (und er ist ein gro√üartiger Spezialist f√ºr dieses Betriebssystem) stellte sp√§ter jedoch fest, dass die L√∂sung g√ºltig ist, bis das Betriebssystem neu gestartet wird.  Um die Rechte sicher zu erhalten, m√ºssen Sie den Benutzer der <b>Datentr√§gergruppe</b> hinzuf√ºgen. <br><br>  Welchen dieser beiden Pfade wir auch gehen, setzen Sie, nachdem alles funktioniert hat, einen Haltepunkt auf die Zeile <b>close (s_fd);</b>  und √ºberpr√ºfen Sie die Ergebnisse zu dem Zeitpunkt, zu dem sie in der Entwicklungsumgebung erzielt werden (da das Programm nicht einmal eint√§gig ist, haben wir keine Zeit und M√ºhe, Mapper einzuf√ºgen, wenn die Entwicklungsumgebung uns alles zeigen kann).  Der Wert von <b>res</b> ist Null.  Das Team hat also fehlerfrei gearbeitet. <br><br><img src="https://habrastorage.org/webt/ih/2o/40/ih2o40ujbpv2p0qk9m_qiwdw9do.png"><br><br>  Was ist in den Puffer gekommen?  Als ich das Wort <b>data</b> in die Adresse f√ºr den Speicherauszug eingab, wurde mir mitgeteilt, dass der Wert nicht berechnet werden konnte. Ich musste <b>&amp; data</b> eingeben <b>.</b>  .  Es ist seltsam, denn <b>Daten</b> sind ein Zeiger. Wenn Sie unter Windows debuggen, funktioniert alles, aber ich stelle nur fest, dass dies folgenderma√üen funktioniert: Sehen Sie sich das so erhaltene Ergebnis an: <br><br><img src="https://habrastorage.org/webt/bj/tk/ae/bjtkaehd8ucyzdufbdsn1392tgm.png"><br><br>  Richtig, sie haben uns den Namen und die Revision des Laufwerks zur√ºckgegeben.  Weitere Informationen zum Format der resultierenden Struktur finden Sie im Segate-Dokument (Abschnitt 3.6.2, Tabelle 59).  Der Lesepuffer wurde nicht gef√ºllt, aber die IOCTL-Beschreibung der Anforderung besagt, dass er nur gef√ºllt wird, wenn ein Fehler auftritt, der etwas in diesem Puffer zur√ºckgibt.  W√∂rtlich: <b>Sense-Daten (werden nur verwendet, wenn 'status' CHECK CONDITION ist oder (driver_status &amp; DRIVER_SENSE) true ist)</b> . <br><br><h2>  Benutzerdefiniertes Befehlsformat f√ºr Redd Internal SD Drive </h2><br>  Nachdem wir nicht nur die trockene Beschreibung der Norm studiert haben, sondern auch alles in der Praxis ausprobiert haben und f√ºhlen, was ein Befehlsblock ist, k√∂nnen wir bereits das Befehlsformat anzeigen, mit dem Sie nicht standardm√§√üige Funktionen aufrufen k√∂nnen, die der STM32-Steuerung auf der Platine des Komplexes "geflasht" werden.  Ich habe den Befehlscode am Anfang des herstellerspezifischen Befehlsbereichs ausgew√§hlt.  Es ist gleich 0xC0.  In den Beschreibungen der SCSI-Befehle wird <b>traditionell C0h geschrieben</b> .  Die L√§nge des Befehls betr√§gt immer 10 Bytes.  Das Format des Teams ist einheitlich und in der folgenden Tabelle dargestellt. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Byte</b> </td><td>  <b>Termin</b> </td></tr><tr><td>  0 </td><td>  Befehlscode C0h </td></tr><tr><td>  1 </td><td>  Unterbefehlscode </td></tr><tr><td>  2 </td><td rowspan="4">  Argument arg1.  In Little Endian-Notation setzen (Low-Byte-Forward) </td></tr><tr><td>  3 </td></tr><tr><td>  4 </td></tr><tr><td>  5 </td></tr><tr><td>  6 </td><td rowspan="4">  Argument arg2.  In Little Endian-Notation setzen (Low-Byte-Forward) </td></tr><tr><td>  7 </td></tr><tr><td>  8 </td></tr><tr><td>  9 </td></tr></tbody></table></div><br>  Wie Sie sehen, werden die Argumente in der Little-Endian-Notation angegeben.  Auf diese Weise k√∂nnen Sie den Befehl in Form einer Struktur beschreiben und direkt auf seine Felder zugreifen, ohne auf die Byte-Permutationsfunktion zur√ºckgreifen zu m√ºssen.  Ausrichtungsprobleme (Doppelw√∂rter in der Struktur haben Offsets, die nicht ein Vielfaches von vier sind) auf x86- und x64-Architekturen sind es nicht wert. <br><br>  Unterbefehlscodes werden durch die folgende Aufz√§hlung beschrieben: <br><pre> <code class="plaintext hljs">enum vendorSubCommands { subCmdSdEnable = 0, // 00 Switch SD card to PC or Outside subCmdSdPower, // 01 Switch Power of SD card On/Off subCmdSdReinit, // 02 Reinitialize SD card (for example, after Power Cycle) subCmdSpiFlashEnable, // 03 Switch SPI Flash to PC or Outside subCmdSpiFlashWritePage, // 04 Write Page to SPI Flash subCmdSpiFlashReadPage, // 05 Read Page from SPI Flash subCmdSpiFlashErasePage,// 06 Erase Pages on SPI Flash (4K block) subCmdRelaysOn, // 07 Switch relays On by mask subCmdRelaysOff, // 08 Switch relays off by mask subCmdRelaysSet, // 09 Set state of all relays by data subCmdFT4222_1_Reset, // 0A Activate Reset State or switch chip to normal mode subCmdFT4222_2_Reset, // 0B Activate Reset State or switch chip to normal mode subCmdFT4222_3_Reset, // 0C Activate Reset State or switch chip to normal mode subCmdFT4232_Reset, // 0D Activate Reset State or switch chip to normal mode subCmdFT2232_Reset, // 0E Activate Reset State or switch chip to normal mode subCmdMAX3421_Reset, // 0F Activate Reset State or switch chip to normal mode subCmdFT4222_1_Cfg, // 10 Write to CFG pins of FT4222_1 subCmdFT4222_2_Cfg, // 11 Write to CFG pins of FT4222_2 subCmdFT4222_3_Cfg, // 12 Write to CFG pins of FT4222_3 };</code> </pre><br>  Sie k√∂nnen in Gruppen eingeteilt werden. <br><br><h3>  Ger√§te in internen und externen Modus schalten </h3><br>  Die <b>Befehle</b> <b>subCmdSdEnable</b> und <b>subCmdSpiFlashEnable</b> schalten die SD-Karte bzw. den SPI-Flash um.  Der Parameter <b>arg1</b> √ºbergibt einen der folgenden Werte: <br><br><pre> <code class="plaintext hljs">enum enableMode { enableModeToPC = 0, enableModeOutside };</code> </pre> <br>  Standardm√§√üig sind beide Ger√§te an einen PC angeschlossen. <br><br><h3>  Netzschalter </h3><br>  Das SDIO-Protokoll erfordert w√§hrend der Initialisierung einige Manipulationen.  Manchmal ist es n√ºtzlich, die SD-Karte in den Ausgangszustand zur√ºckzusetzen (z. B. wenn die Leitungen zu einem externen Anschluss umgeschaltet werden).  Schalten Sie dazu das Ger√§t aus und wieder ein.  Dies kann mit dem <b>Befehl subCmdSdPower erfolgen</b> .  Im Argument <b>arg1 wird</b> einer der folgenden Werte √ºbergeben: 0 - Ausschalten, 1 - Einschalten.  Denken Sie daran, Zeit zu geben, um die Kondensatoren auf der Stromleitung zu entladen. <br><br>  Nach dem Einschalten sollte die Karte, sofern sie mit dem PC verbunden ist, neu initialisiert werden.  Verwenden Sie dazu den Befehl <b>subCmdSdReinit</b> (er hat keine Argumente). <br><br><h3>  Arbeiten Sie mit dem SPI-Flash-Laufwerk </h3><br>  Wenn die SD-Karte als volles Laufwerk an das System angeschlossen ist, ist der Zugriffschip in der aktuellen Version sehr begrenzt.  Sie k√∂nnen jeweils nur auf die einzelnen Seiten (256 Byte) zugreifen.  Die Speicherkapazit√§t des Mikrokreislaufs ist so bemessen, dass der Vorgang selbst bei der Arbeit an der Seite nicht viel Zeit in Anspruch nimmt. Dieser Ansatz vereinfacht jedoch die ‚ÄûFirmware‚Äú des Mikrocontrollers erheblich. <br><br>  Der Befehl <b>subCmdSpiFlashReadPage</b> liest die Seite.  Die Adresse wird im Parameter arg1 angegeben, die Anzahl der zu sendenden Seiten im Parameter arg2.  In der aktuellen Version sollte die Anzahl der Seiten jedoch gleich eins sein.  Der Befehl gibt 256 Datenbytes zur√ºck. <br><br>  F√ºr sie ist der Befehl <b>subCmdSpiFlashWritePage</b> gespiegelt.  Argumente f√ºr sie werden nach dem gleichen Prinzip ausgef√ºllt.  Die Richtung der Daten√ºbertragung ist zum Ger√§t. <br><br>  Die Besonderheit des Flash-Speichers besteht darin, dass w√§hrend der Aufzeichnung nur einzelne Bits durch Null-Bits ersetzt werden k√∂nnen.  Um sie auf einen einzelnen Wert zur√ºckzusetzen, sollten die Seiten gel√∂scht werden.  <b>Hierf√ºr</b> gibt es einen Befehl <b>subCmdSpiFlashErasePage</b> .  Aufgrund der Eigenschaften der verwendeten Mikroschaltung wird zwar keine einzelne Seite, die im Parameter <b>arg1 festgelegt</b> ist, gel√∂scht, sondern ein 4-Kilobyte-Block, der diese Seite enth√§lt. <br><br><h3>  Solid State Relay Management </h3><br>  Der Komplex verf√ºgt √ºber sechs Halbleiterrelais.  Es gibt drei Teams, die sie verwalten. <br><br>  <b>subCmdRelaysSet</b> - legt den Wert aller sechs Relais gleichzeitig fest.  Im Parameter <b>arg1 wird ein</b> Wert √ºbergeben, von dem jedes Bit seinem eigenen Relais entspricht (Nullbit - Relais mit Index 0, erstes Bit mit Index 1 usw.).  Ein einziger Bitwert schlie√üt das Relais, ein Nullwert √∂ffnet es. <br><br>  Diese Arbeitsweise ist gut, wenn alle Relais als eine Gruppe arbeiten.  Wenn sie unabh√§ngig voneinander arbeiten, m√ºssen Sie bei diesem Ansatz eine Puffervariable starten, die den Statuswert aller Relais speichert.  Wenn verschiedene Relais von verschiedenen Programmen gesteuert werden, wird das Problem des Speicherns des Gesamtwerts extrem akut.  In diesem Fall k√∂nnen Sie zwei weitere Befehle verwenden: <br><br>  <b>subCmdRelaysOn</b> - <b>Aktiviert</b> ausgew√§hlte Relais nach Maske.  Die Relais, die den Einheitenbits im Argument <b>arg1</b> entsprechen, werden aktiviert.  Die Relais, die Nullen in der Maske entsprechen, behalten ihren aktuellen Status bei. <br><br>  Der Befehl <b>subCmdRelaysOff, der es spiegelt, schaltet</b> die ausgew√§hlten Relais √ºber die Maske aus.  Die Relais, die den einzelnen Bits im Argument <b>arg1 entsprechen</b> , werden ausgeschaltet.  Die Relais, die Nullen in der Maske entsprechen, behalten ihren aktuellen Status bei. <br><br><h3>  Setzen Sie die FTDI- und Maxim-Controller zur√ºck </h3><br>  Um R√ºcksetzsignale an FTDI- und Maxim-Mikroschaltungen zu senden, wird die Befehlsgruppe <b>subCmdFT4222_1_Reset</b> , <b>subCmdFT4222_2_Reset</b> , <b>subCmdFT4222_3_Reset</b> , <b>subCmdFT4232_Reset</b> , <b>subCmdFT2232_Reset</b> und <b>subCmdMAX3421_ verwendet</b> .  An ihren Namen k√∂nnen Sie erkennen, welche Chips sie durch R√ºcksetzsignale steuern.  Die FT4222-Br√ºcken sind, wie bereits erw√§hnt, zwei in der Schaltung (ihre Indizes sind 1 und 2). Eine weitere FT4222-Br√ºcke √ºbertr√§gt Daten an den MAX3421-Chip, auf die wir im n√§chsten Artikel eingehen werden. <br><br>  Der Parameter <b>arg1</b> √ºbergibt einen der folgenden Werte: <br><br><pre> <code class="plaintext hljs">enum ResetState { resetStateActive =0, resetStateNormalOperation };</code> </pre> <br>  Standardm√§√üig sind alle Br√ºcken in einem normalen Betriebszustand.  Wie bereits in einem <a href="https://habr.com/ru/post/483724/">vorherigen Artikel erw√§hnt</a> , sind wir uns nicht sicher, ob diese Funktionalit√§t ben√∂tigt wird. Wenn jedoch kein direkter Zugriff auf das Ger√§t besteht, ist es besser, alles und jedes remote zur√ºcksetzen zu k√∂nnen. <br><br><h3>  Konfigurationszeilen von FT4222-Chips wechseln </h3><br>  FT4222-Chips haben vier Modi.  Es ist unwahrscheinlich, dass jemand einen anderen Modus als "00" ben√∂tigt. Wenn Sie ihn jedoch pl√∂tzlich ben√∂tigen, k√∂nnen Sie die <b>Befehle</b> <b>subCmdFT4222_1_Cfg</b> , <b>subCmdFT4222_2_Cfg</b> und <b>subCmdFT4222_3_Cfg</b> zum <b>Umschalten</b> f√ºr den ersten, zweiten und dritten <b>Chip verwenden</b> .  Der Wert der Zeilen CFG0 und CFG1 wird in den unteren beiden Bits des Parameters <b>arg1 eingestellt</b> . <br><br><h2>  Praktische Erfahrung in der Ausgabe von Befehlen an die STM32-Steuerung </h2><br>  Um das theoretische Material in der Praxis zu testen, werden wir versuchen, die SD-Karte auszutauschen.  <b>Setzen Sie dazu den</b> Befehl <b>subCmdSdEnable</b> mit dem Code 0x00 und dem Argument <b>enableModeOutside</b> mit dem Code 0x01 ab.  Gro√üartig.  Wir haben das Programm wie folgt umgeschrieben. <br><br><div class="spoiler">  <b class="spoiler_title">Umgeschriebenes Programm:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmdSdToOutside[] = { 0xC0,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t cmdSdToPC[] = { 0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t sense[32]; memset(sense, 0, sizeof(sense)); header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmdSdToOutside); header.cmdp = cmdSdToOutside; //  ( ) header.dxfer_len = 0; header.dxferp = 0; header.dxfer_direction = SG_DXFER_NONE; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); //   header.cmdp = cmdSdToPC; res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br>  Wir haben die Befehlsl√§nge auf zehn Bytes ge√§ndert und den Datenblock entfernt.  Nun, sie haben den Befehlscode nach Bedarf mit Argumenten aufgeschrieben.  Ansonsten bleibt alles beim Alten.  Wir fangen an ... und ... nichts funktioniert.  Die Funktion <b>ioctl ()</b> gibt einen Fehler zur√ºck.  Der Grund ist im <b>SG_IO-</b> Befehlsdokument beschrieben.  Tatsache ist, dass wir den herstellerspezifischen Befehl <b>C0h geben</b> und Folgendes w√∂rtlich √ºber sie gesagt wird: <br><blockquote>  Jeder andere SCSI-Befehl (Opcode), der nicht f√ºr den SG-Treiber angegeben wurde, ben√∂tigt O_RDWR.  Jeder andere SCSI-Befehl (Opcode), der nicht f√ºr die Blockschicht SG_IO ioctl erw√§hnt wird, ben√∂tigt einen Benutzer mit der F√§higkeit CAP_SYS_RAWIO. </blockquote><br>  Wie der Chef mir erkl√§rte (ich erz√§hle nur seine Worte), <b>werden die</b> Werte der <b>F√§higkeiten</b> einer ausf√ºhrbaren Datei zugewiesen.  Aus diesem Grund musste ich mich von der Entwicklungsumgebung aus als <b>root anmelden</b> .  Nicht die beste L√∂sung, aber zumindest etwas.  Unter Windows sind f√ºr die Anforderung <b>IOCTL_SCSI_PASS_THROUGH_DIRECT</b> Administratorrechte erforderlich.  Vielleicht gibt jemand in den Kommentaren Ratschl√§ge, wie man das Tracing-Problem ohne solch drastische Schritte l√∂st, aber Sie k√∂nnen das bereits geschriebene Programm ohne <b>root</b> ausf√ºhren, wenn Sie die richtigen <b>F√§higkeiten daf√ºr</b> registrieren.  √Ñndern Sie in der Zwischenzeit den Benutzernamen in der Entwicklungsumgebung und setzen Sie einen Haltepunkt in der Zeile: <br><br><pre> <code class="plaintext hljs">int res = ioctl(s_fd, SG_IO, &amp;header;);</code> </pre> <br>  Bevor wir die Funktion <b>ioctl ()</b> aufrufen, sehen wir uns die Liste der Speicherger√§te an: <br><br><img src="https://habrastorage.org/webt/ys/ef/ls/yseflsambpnn83pbywoqfuazoqi.png"><br><br>  Rufen Sie <b>ioctl () auf</b> und sehen Sie sich die Liste noch einmal an: <br><br><img src="https://habrastorage.org/webt/ro/2g/33/ro2g331krziu9uslxuzo28hylxa.png"><br><br>  Das Ger√§t <b>/ dev / sdb ist</b> geblieben (grob gesagt, das ist der SD-Kartenleser selbst), und <b>/ dev / sdb1 ist</b> verschwunden.  Dieses Ger√§t entspricht dem Dateisystem auf dem Datentr√§ger.  Der Tr√§ger wurde vom Computer getrennt - er war nicht mehr sichtbar.  Wir verfolgen weiter.  Nach dem Aufruf der zweiten <b>ioctl ()</b> -Funktion sehen wir uns noch einmal die Liste der Ger√§te an: <br><br><img src="https://habrastorage.org/webt/rd/wi/zx/rdwizxqu4amrqeuhzghnrptvkly.png"><br><br>  Die SD-Karte wird erneut mit dem System verbunden, sodass <b>/ dev / sdb1</b> wieder in Position ist.  Tats√§chlich haben wir gelernt, wie man herstellerspezifische Befehle ausgibt und ein Ger√§t verwaltet, das auf dem STM32-Mikrocontroller im Redd-Komplex basiert.  Andere Befehle werden den Lesern zum unabh√§ngigen Studium √ºberlassen.  Sie k√∂nnen den Betrieb einiger von ihnen auf √§hnliche Weise steuern.  Wenn ein <b>ftdi-</b> Chip in einen Reset-Zustand wechselt, wird das entsprechende Ger√§t aus dem System entfernt.  Der Betrieb des Relais und die Steuerung der Beine der Konfiguration m√ºssen durch Messinstrumente gesteuert werden.  Sie k√∂nnen die Arbeit mit einem Flash-Laufwerk √ºberpr√ºfen, indem Sie Seiten mit anschlie√üender Lesesteuerung schreiben. <br><br><h2>  Fazit </h2><br>  Wir haben zwei gro√üe Themen untersucht, die nicht mit FPGAs im Redd-Komplex zusammenh√§ngen.  Der dritte blieb bestehen - er arbeitete mit dem MAX3421-Chip, mit dem USB 2.0 FS-Ger√§te implementiert werden k√∂nnen.  In der Tat gibt es auch Hosts, aber es gibt viele Hosts und das Motherboard.  Die Funktionalit√§t des Ger√§ts erm√∂glicht es dem Komplex, sich als USB-Flash-Laufwerk (zum Senden von Firmware-Updates), USB-Tastatur (zum Steuern externer Ger√§te) usw. auszugeben.  Wir werden dieses Thema im n√§chsten Artikel betrachten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484706/">https://habr.com/ru/post/de484706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484688/index.html">Wir n√§hern uns der Grenze der Rechenleistung - wir brauchen neue Programmierer</a></li>
<li><a href="../de484690/index.html">Seminar, Konferenz, mitap: Statistiken von 18.000 Ereignissen studieren</a></li>
<li><a href="../de484692/index.html">Vitamin C - Muss ich Nahrungserg√§nzungsmittel einnehmen oder handelt es sich um einen kommerziellen Schritt?</a></li>
<li><a href="../de484700/index.html">Java 14: Datensatzvorschau</a></li>
<li><a href="../de484702/index.html">Prestashop-Alternativen im Jahr 2020: Top-E-Commerce-Plattformen</a></li>
<li><a href="../de484708/index.html">Richard Hamming "Nicht existierendes Kapitel": Woher wissen wir, was wir wissen (Vollversion)</a></li>
<li><a href="../de484710/index.html">Versto√ü gegen die Regeln der Unity Garbage Collection</a></li>
<li><a href="../de484712/index.html">Reaktive Bin√§rkompatibilit√§t: wie wir sie anbieten</a></li>
<li><a href="../de484716/index.html">H√∂r auf, alles KI zu nennen</a></li>
<li><a href="../de484718/index.html">Moderne HP Drucker arbeiten nicht ohne Tintenabonnement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>