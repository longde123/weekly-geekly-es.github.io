<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïú ü§¨ üçΩÔ∏è Como distinguir shampoo de champignon e espetos de champagne ... Elasticsearch - procure por produtos nos bancos de dados de lojas üôÜ ‚ô†Ô∏è üõåüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desafio 


 Uma das grandes tarefas do aplicativo para armazenar e analisar compras √© procurar produtos id√™nticos ou muito pr√≥ximos no banco de dados,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como distinguir shampoo de champignon e espetos de champagne ... Elasticsearch - procure por produtos nos bancos de dados de lojas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433070/"><h1 id="zadacha">  Desafio </h1><br><p> Uma das grandes tarefas do aplicativo para armazenar e analisar compras √© procurar produtos id√™nticos ou muito pr√≥ximos no banco de dados, que cont√©m nomes variados e obscuros de produtos obtidos de recibos.  Existem dois tipos de solicita√ß√£o de entrada: </p><br><ol><li>  Um nome espec√≠fico com abrevia√ß√µes, que s√≥ pode ser entendido por caixas em um supermercado local ou compradores √°vidos. </li><li>  Uma consulta de idioma natural inserida pelo usu√°rio na cadeia de pesquisa. </li></ol><br><p>  Normalmente, os pedidos do primeiro tipo s√£o provenientes dos produtos no pr√≥prio cheque, quando o usu√°rio precisa encontrar produtos mais baratos.  Nossa tarefa √© selecionar o produto an√°logo mais semelhante no check-in em outras lojas pr√≥ximas.  √â importante escolher a marca de produto mais adequada e, se poss√≠vel, o volume. </p><br><p><img src="https://habrastorage.org/webt/yp/_d/ny/yp_dnyvhrlrrrr6v0pa_6sz_ibk.jpeg"></p><a name="habracut"></a><br><p>  O segundo tipo de solicita√ß√£o √© uma solicita√ß√£o simples do usu√°rio para procurar um produto espec√≠fico na loja mais pr√≥xima.  A solicita√ß√£o pode ser uma descri√ß√£o muito geral e n√£o exclusiva do produto.  Pode haver pequenos desvios da solicita√ß√£o.  Por exemplo, se um usu√°rio procurar leite 3,2% e, em nosso banco de dados, apenas 2,5% leite, ainda queremos mostrar pelo menos esse resultado. </p><br><p><img src="https://habrastorage.org/webt/ar/0-/03/ar0-03doeo4rgkrbni26iz9rek4.jpeg"></p><br><h1 id="osobennosti-dataseta--problemy-dlya-resheniya">  Conjunto de dados de recursos - problemas a serem resolvidos </h1><br><p>  As informa√ß√µes no recibo do produto est√£o longe de serem ideais.  Nem sempre existem muitas abrevia√ß√µes claras, erros gramaticais, erros de digita√ß√£o, v√°rias tradu√ß√µes, letras latinas no meio do alfabeto cir√≠lico e conjuntos de caracteres que fazem sentido apenas para a organiza√ß√£o interna de uma loja em particular. <br>  Por exemplo, um pur√™ de ma√ß√£ e banana com queijo cottage pode ser facilmente escrito no cheque da seguinte maneira: </p><br><p><img src="https://habrastorage.org/webt/kv/gg/23/kvgg23lcyv2h5gulck5k_9x1a-s.jpeg"></p><cut></cut><br><h1 id="o-tehnologii">  Sobre a tecnologia </h1><br><p>  O Elasticsearch √© uma tecnologia bastante popular e acess√≠vel para implementar a pesquisa.  Este √© um mecanismo de pesquisa da API JSON REST usando Lucene e escrito em Java.  As principais vantagens do Elastic s√£o velocidade, escalabilidade e toler√¢ncia a falhas.  Mecanismos semelhantes s√£o usados ‚Äã‚Äãpara pesquisas complexas no banco de dados de documentos.  Por exemplo, uma pesquisa levando em considera√ß√£o a morfologia do idioma ou uma pesquisa por coordenadas geogr√°ficas. </p><br><h1 id="napravleniya-dlya-eksperimentov-i-uluchsheniy">  Instru√ß√µes para experimenta√ß√£o e aprimoramento </h1><br><p>  Para entender como voc√™ pode melhorar sua pesquisa, √© necess√°rio analisar o sistema de pesquisa em seus componentes personalizados.  Para o nosso caso, a estrutura do sistema se parece com isso. </p><br><ol><li>  A sequ√™ncia de entrada da pesquisa passa pelo analisador, que de certa maneira divide a sequ√™ncia em tokens - unidades de pesquisa que pesquisam entre dados que tamb√©m s√£o armazenados como tokens. </li><li>  Depois, h√° uma pesquisa direta desses tokens para cada documento no banco de dados existente.  Ap√≥s localizar o token em um determinado documento (que tamb√©m √© apresentado no banco de dados como um conjunto de tokens), sua relev√¢ncia √© calculada de acordo com o modelo de similaridade selecionado (o chamaremos de Modelo de Relev√¢ncia).  Pode ser um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TF / IDF</a> simples (Termo Frequ√™ncia - Frequ√™ncia Inversa de Documento) ou pode ser outros modelos mais complexos ou espec√≠ficos. </li><li>  No pr√≥ximo est√°gio, o n√∫mero de pontos marcados por cada token individual √© agregado de uma certa maneira.  Os par√¢metros de agrega√ß√£o s√£o definidos pela sem√¢ntica da consulta.  Um exemplo dessas agrega√ß√µes pode ser pesos adicionais para determinados tokens (valor agregado), condi√ß√µes para a presen√ßa obrigat√≥ria de um token, etc.  O resultado desse est√°gio √© Pontua√ß√£o - a avalia√ß√£o final da relev√¢ncia de um documento espec√≠fico do banco de dados em rela√ß√£o √† solicita√ß√£o inicial. </li></ol><br><p><img src="https://habrastorage.org/webt/_u/yg/zp/_uygzp1ohyyhtksrfuwbfvmi3r0.jpeg"></p><br><p>  √â poss√≠vel distinguir tr√™s componentes configur√°veis ‚Äã‚Äãseparadamente do dispositivo de pesquisa, em cada um dos quais voc√™ pode destacar suas pr√≥prias maneiras e m√©todos de aprimoramento. </p><br><ol><li>  Analisadores </li><li>  Modelo de similaridade </li><li>  Melhorias no tempo de consulta </li></ol><br><p>  A seguir, consideraremos cada componente individualmente e analisaremos configura√ß√µes de par√¢metros espec√≠ficas que ajudaram a melhorar a pesquisa no caso de nomes de produtos. </p><br><h3 id="query-time-uluchsheniya">  Melhorias no tempo de consulta </h3><br><p>  Para entender o que podemos melhorar na solicita√ß√£o, damos um exemplo da solicita√ß√£o inicial. </p><br><pre><code class="sql hljs">{ "query": { "multi_match": { "query": "  105", "type": "most_fields", "fields": ["name"], "minimum_should_match": "70%" } }, ‚Äúsize‚Äù: 100, ‚Äúmin_score‚Äù: 15 }</code> </pre> <br><p>  Usamos o tipo de consulta most_fields, pois prevemos a necessidade de uma combina√ß√£o de v√°rios analisadores para o campo "nome do produto".  Esse tipo de consulta permite combinar resultados de pesquisa para diferentes atributos do objeto que cont√©m o mesmo texto, analisados ‚Äã‚Äãde maneiras diferentes.  Uma alternativa a essa abordagem √© usar as consultas best_fields ou cross_fields, mas elas n√£o s√£o adequadas para o nosso caso, pois a pesquisa √© calculada entre os v√°rios atributos do objeto (por exemplo: nome e descri√ß√£o).  Somos confrontados com a tarefa de levar em considera√ß√£o v√°rios aspectos de um atributo - o nome do produto. </p><br><p>  O que pode ser configurado: </p><br><ul><li>  Combina√ß√£o ponderada de diferentes analisadores. <br>  Inicialmente, todos os elementos de pesquisa t√™m o mesmo peso - e, portanto, a mesma import√¢ncia.  Isso pode ser alterado adicionando o par√¢metro 'boost', que aceita valores num√©ricos.  Se o par√¢metro for maior que 1, o elemento de pesquisa ter√° um impacto maior nos resultados, respectivamente, menor que 1 - menor. </li><li>  Separa√ß√£o dos analisadores em 'should' e 'must'. <br>  Nomeadamente, certos analisadores devem coincidir e alguns s√£o opcionais, ou seja, insuficientes.  No nosso caso, o analisador de n√∫meros pode ser um exemplo dos benef√≠cios dessa separa√ß√£o.  Se apenas o n√∫mero corresponder no nome do produto na solicita√ß√£o e no nome do produto no banco de dados, isso n√£o ser√° uma condi√ß√£o suficiente para sua equival√™ncia.  N√£o queremos ver esses produtos como resultado.  Ao mesmo tempo, se a solicita√ß√£o for "creme 10%", queremos que todo creme com 10% de gordura tenha uma grande vantagem sobre o creme com 20% de gordura. </li><li>  O par√¢metro minimum_should_match.  Quantos tokens devem necessariamente corresponder na solicita√ß√£o e no documento do banco de dados?  Este par√¢metro trabalha em conjunto com o tipo de nossa solicita√ß√£o (most_fields) e verifica o n√∫mero m√≠nimo de tokens correspondentes para cada um dos campos (no nosso caso, para cada analisador). </li><li>  Par√¢metro Min_score.  Documentos de triagem de limite com pontos insuficientes.  O problema √© que n√£o h√° velocidade m√°xima conhecida.  A pontua√ß√£o resultante depende de uma solicita√ß√£o espec√≠fica e de um banco de dados espec√≠fico de documentos.  √Äs vezes, pode ser 150, e √†s vezes 2, mas esses dois valores significam que o objeto do banco de dados √© relevante para a solicita√ß√£o.  N√£o podemos comparar as pontua√ß√µes dos resultados de diferentes consultas. <br><ul><li>  Constante <br>  Ap√≥s o monitoramento suficiente dos valores finais da velocidade para consultas diferentes, √© poss√≠vel identificar uma borda aproximada, ap√≥s a qual, para a maioria das consultas, os resultados se tornam inapropriados.  Essa √© a decis√£o mais f√°cil, mas tamb√©m a mais est√∫pida, o que leva a uma pesquisa de baixa qualidade. </li><li>  Tente analisar as pontua√ß√µes obtidas para uma solicita√ß√£o espec√≠fica ap√≥s realizar uma pesquisa com m√≠nimo ou zero min_score. <br>  A ideia √© que, ap√≥s um certo momento, voc√™ possa observar um salto acentuado na dire√ß√£o da diminui√ß√£o da velocidade.  Resta apenas determinar esse salto para parar a tempo.  Essa abordagem funcionaria bem em consultas semelhantes: <br><img src="https://habrastorage.org/webt/9z/qo/-u/9zqo-uovb_75ytduyti4byhmeyo.png"><br>  O salto pode ser encontrado por m√©todos estat√≠sticos.  Infelizmente, por√©m, nem em todas as solicita√ß√µes esse salto est√° presente e √© facilmente identific√°vel. </li><li>  Calcule a velocidade ideal e defina min_score como uma certa fra√ß√£o do ideal, o que pode ser feito de duas maneiras: <br><ul><li>  A partir da descri√ß√£o detalhada dos c√°lculos fornecidos pelo pr√≥prio Elastic ao definir o par√¢metro explique: true.  Essa √© uma tarefa dif√≠cil, exigindo um entendimento completo da arquitetura de consulta e dos algoritmos computacionais usados ‚Äã‚Äãpelo Elastic. </li><li>  Por um pequeno truque.  Recebemos uma solicita√ß√£o, adicionamos um novo produto ao nosso banco de dados com o mesmo nome, fazemos uma pesquisa e obtemos a velocidade m√°xima.  Como haver√° uma correspond√™ncia de 100% no nome, o valor resultante ser√° ideal.  √â essa abordagem que usamos em nosso sistema, pois as preocupa√ß√µes com o alto custo dessa opera√ß√£o em rela√ß√£o ao tempo n√£o foram confirmadas. </li></ul></li></ul></li><li>  Altere o algoritmo de pontua√ß√£o, respons√°vel pelo valor final da relev√¢ncia.  Isso pode levar em considera√ß√£o a dist√¢ncia da loja (d√™ mais pontos aos produtos mais pr√≥ximos), pre√ßos dos produtos (d√™ mais pontos aos produtos com o pre√ßo mais prov√°vel) etc. </li></ul><br><h3 id="analizatory">  Analisadores </h3><br><p>  O analisador analisa a sequ√™ncia de entrada em tr√™s est√°gios e gera tokens na sa√≠da - unidades de pesquisa: </p><br><p><img src="https://habrastorage.org/webt/cd/vc/u8/cdvcu8tw-9wsrgelal2ii0waeio.jpeg"></p><br><p>  Primeiro, as altera√ß√µes ocorrem no n√≠vel do caractere da sequ√™ncia.  Isso pode substituir, excluir ou adicionar caracteres a uma sequ√™ncia.  Em seguida, um tokenizador entra em a√ß√£o, projetado para dividir a string em tokens.  O tokenizador padr√£o divide a string em tokens de acordo com os sinais de pontua√ß√£o.  Na √∫ltima etapa, os tokens recebidos s√£o filtrados e processados. </p><br><p>  Considere quais varia√ß√µes das etapas se tornaram √∫teis no nosso caso. </p><br><h5 id="char-filters">  Filtros de caracteres </h5><br><ul><li>  De acordo com as especificidades do idioma russo, seria √∫til processar caracteres como th e e substitu√≠-los por e e e, respectivamente. </li><li>  Executar translitera√ß√£o - a transfer√™ncia de caracteres de uma escrita por caracteres de outra escrita.  No nosso caso, esse √© o processamento de nomes escritos em latim ou misturados com os dois alfabetos.  A translitera√ß√£o pode ser implementada usando o plug-in ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ICU Analysis Plugin</a> ) como um filtro de token (ou seja, ele processa n√£o a string original, mas os tokens finais).  Decidimos escrever nossa translitera√ß√£o, pois n√£o est√°vamos muito felizes com o algoritmo no plug-in.  A id√©ia √© substituir primeiro as ocorr√™ncias do conjunto de quatro caracteres (por exemplo, "SHCH =&gt; u‚Äù), depois as ocorr√™ncias de tr√™s caracteres, etc. A ordem na qual os filtros de s√≠mbolos s√£o usados ‚Äã‚Äã√© importante, pois o resultado depender√° da ordem. </li><li>  Substitua Latin c, cercado por cir√≠lico, por russo p.  A necessidade disso foi identificada ap√≥s a an√°lise dos nomes no banco de dados - muitos nomes em cir√≠lico inclu√≠am o latim c, que significa cir√≠lico c.  Quando como se o nome estivesse completamente em latim, o latim C significa cir√≠lico k ou c.  Portanto, antes da translitera√ß√£o, √© necess√°rio substituir o caractere c. </li><li>  Removendo n√∫meros muito grandes de nomes.  √Äs vezes, nos nomes dos produtos, h√° um n√∫mero de identifica√ß√£o interno (por exemplo, 3387522 K.Ts. Maslo sunflower.raf. 0,9l), que n√£o tem nenhum significado no caso geral. </li><li>  Substituindo v√≠rgulas por pontos.  Por que isso √© necess√°rio?  Para que os n√∫meros, por exemplo, o teor de gordura do leite 3.2 e 3.2 sejam equivalentes </li></ul><br><h5 id="tokenizer">  Tokenizer </h5><br><ul><li>  Tokenizador padr√£o - separa as linhas de acordo com o espa√ßo e os sinais de pontua√ß√£o (por exemplo, "twix extra 2" -&gt; "twix extra", "extra", "2") </li><li>  Token EdgeNGram - divide cada palavra em tokens de um determinado comprimento (geralmente um intervalo de n√∫meros), come√ßando com o primeiro caractere (por exemplo, para N = [3, 6]: "twix extra 2" -&gt; "twee", "tweak", ‚ÄúTwix‚Äù, ‚Äúex‚Äù, ‚Äúext‚Äù, ‚Äúext‚Äù, ‚Äúextra‚Äù) </li><li>  Tokenizer for numbers - seleciona apenas n√∫meros de uma string pesquisando uma express√£o regular (por exemplo, ‚Äútwix extra 2 4.5‚Äù -&gt; ‚Äú2‚Äù, ‚Äú4.5‚Äù) </li></ul><br><h5 id="token-filter">  Filtro de token </h5><br><ul><li>  Filtro em min√∫sculas </li><li>  Filtro de Stamming - executa um algoritmo de stamming para cada token.  Stemming √© determinar a forma inicial de uma palavra (por exemplo, "arroz" -&gt; "arroz") </li><li>  An√°lise fon√©tica.  √â necess√°rio para minimizar a influ√™ncia de erros de digita√ß√£o e diferentes maneiras de escrever a mesma palavra nos resultados da pesquisa.  A tabela mostra os v√°rios algoritmos dispon√≠veis para an√°lise fon√©tica e o resultado de seu trabalho em casos problem√°ticos.  No primeiro caso (Shampoo / champanhe / champignon / champignon), o sucesso √© determinado pela gera√ß√£o de codifica√ß√µes diferentes, no restante - o mesmo. </li></ul><br><p><img src="https://habrastorage.org/webt/gi/oi/x6/gioix68jytjyfxexdt3pvjpatze.png"></p><br><h3 id="similarity-model">  Modelo de similaridade </h3><br><p>  O modelo de relev√¢ncia √© necess√°rio para determinar em que medida a coincid√™ncia de um token afeta a relev√¢ncia do objeto do banco de dados em rela√ß√£o √† solicita√ß√£o.  Suponha que se o token na solicita√ß√£o e o produto do banco de dados corresponderem - isso certamente n√£o √© ruim, mas diz pouco sobre a conformidade do produto com a solicita√ß√£o.  Assim, a coincid√™ncia de diferentes tokens carrega valores diferentes.  Para levar isso em considera√ß√£o, √© necess√°rio um modelo de relev√¢ncia.  Elastic fornece muitos modelos diferentes.  Se voc√™ realmente os entende, pode escolher um modelo muito espec√≠fico e adequado para um caso espec√≠fico.  A escolha pode ser baseada no n√∫mero de palavras usadas com frequ√™ncia (como o mesmo token), uma avalia√ß√£o da import√¢ncia de tokens longos (quanto mais longo significa melhor? Pior? N√£o importa?), Que resultados queremos ver no final etc.  Exemplos de modelos propostos no Elastic podem ser TF-IDF (o modelo mais simples e compreens√≠vel), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Okapi BM25</a> (TF-IDF aprimorado, o modelo padr√£o), Diverg√™ncia ao acaso, Diverg√™ncia √† independ√™ncia, etc.  Cada modelo tamb√©m possui op√ß√µes personaliz√°veis.  Ap√≥s v√°rias experi√™ncias com o modelo, o modelo padr√£o Okapi BM25 apresentou o melhor resultado, mas com par√¢metros diferentes dos predefinidos. </p><br><h1 id="ispolzovanie-kategoriy">  Usando categorias </h1><br><p>  No decorrer do trabalho com a pesquisa, informa√ß√µes adicionais muito importantes sobre o produto - sua categoria - foram disponibilizadas.  Voc√™ pode ler mais sobre como implementamos a categoriza√ß√£o no artigo.Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eu entendo, como muitos doces, ou a classifica√ß√£o de mercadorias, verificando o aplicativo</a> .  At√© ent√£o, baseamos nossa pesquisa apenas na compara√ß√£o de nomes de produtos, agora √© poss√≠vel comparar a categoria de solicita√ß√£o e produtos no banco de dados. <br>  As op√ß√µes poss√≠veis para usar essas informa√ß√µes s√£o uma correspond√™ncia obrigat√≥ria no campo categoria (formatado como um filtro de resultados), uma vantagem adicional na forma de pontos para produtos com a mesma categoria (como no caso de n√∫meros) e a classifica√ß√£o dos resultados por categoria (primeira correspond√™ncia e depois todas as outras).  Para o nosso caso, a √∫ltima op√ß√£o funcionou melhor.  Isso ocorre porque nosso algoritmo de categoriza√ß√£o √© bom demais para usar o segundo m√©todo e n√£o bom o suficiente para usar o primeiro.  Estamos confiantes o suficiente no algoritmo e queremos que a correspond√™ncia de categoria seja uma grande vantagem.  No caso de adicionar pontos adicionais √† velocidade (segundo m√©todo), as mercadorias da mesma categoria subir√£o na lista, mas ainda perder√£o para algumas mercadorias mais correspondidas por nome.  No entanto, o primeiro m√©todo tamb√©m n√£o nos conv√©m, pois ainda s√£o poss√≠veis erros na categoriza√ß√£o.  √Äs vezes, a solicita√ß√£o pode conter informa√ß√µes insuficientes para determinar corretamente a categoria ou h√° muito poucos produtos nessa categoria no raio imediato do usu√°rio.  Nesse caso, ainda queremos mostrar resultados com uma categoria diferente, mas ainda relevantes pelo nome do produto. <br>  O segundo m√©todo tamb√©m √© bom porque n√£o "estraga" a velocidade dos produtos como resultado da pesquisa e permite que voc√™ continue usando a velocidade m√≠nima calculada sem obst√°culos. <br>  A implementa√ß√£o espec√≠fica da classifica√ß√£o pode ser vista na consulta final. </p><br><h1 id="finalnaya-model">  Modelo final </h1><br><p>  A sele√ß√£o do modelo final de pesquisa incluiu a gera√ß√£o de v√°rios mecanismos de pesquisa, sua avalia√ß√£o e compara√ß√£o.  Na maioria das vezes, a compara√ß√£o foi baseada em um dos par√¢metros.  Suponha que em um caso espec√≠fico precis√°ssemos calcular o melhor tamanho para o tokenizador edgeNgram (ou seja, escolha o intervalo mais eficaz de N).  Para isso, geramos os mesmos mecanismos de pesquisa, com apenas uma diferen√ßa no tamanho desse intervalo.  Depois disso, foi poss√≠vel determinar o melhor valor para esse par√¢metro. <br>  Os modelos foram avaliados usando a m√©trica nDCG (ganho cumulativo descontado descontado normalizado), uma m√©trica para avaliar a qualidade do ranking.  Consultas predefinidas foram enviadas para cada modelo de pesquisa, ap√≥s o qual a m√©trica nDCG foi calculada com base nos resultados de pesquisa recebidos. <br>  Analisadores que entraram no modelo final: </p><br><p><img src="https://habrastorage.org/webt/nb/-m/ti/nb-mtitufklquryy-5o3m2trrl4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5n/y3/6g/5ny36gkpfblbdtr5xvu8b4fx_r4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/2r/er/zv/2rerzvbqvsdgezshkhpfeds2mc0.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5h/tv/69/5htv691pabkoks90jq08h6nmdxo.jpeg"></p><br><p>  O modelo padr√£o (Okapi - BM25) com o par√¢metro b = 0,5 foi escolhido como modelo de relev√¢ncia.  O valor padr√£o √© 0,75.  Este par√¢metro mostra at√© que ponto o comprimento do nome do produto normaliza a vari√°vel tf (termo frequ√™ncia).  Um n√∫mero menor, no nosso caso, funciona melhor, pois um nome longo geralmente n√£o afeta o significado de uma √∫nica palavra.  Ou seja, a palavra "chocolate" no nome "chocolate com avel√£s trituradas em um pacote de 25 pe√ßas" n√£o perde seu valor pelo fato de o nome ser longo o suficiente. </p><br><p>  A consulta final √© assim: </p><br><p><img src="https://habrastorage.org/webt/ol/9y/5n/ol9y5nfbppfwyxhqaskziiypuru.jpeg"></p><br><p>  Experimentalmente, a melhor combina√ß√£o de analisadores e pesos foi revelada. </p><br><p>  Como resultado da classifica√ß√£o, os produtos com a mesma categoria v√£o para o in√≠cio dos resultados e depois para todos os outros.  A classifica√ß√£o pelo n√∫mero de pontos (velocidade) √© armazenada em cada subconjunto. </p><br><p>  Por simplicidade, o limite de velocidade √© definido como 15 nesta solicita√ß√£o, embora em nosso sistema utilizemos o par√¢metro calculado que foi descrito anteriormente. </p><br><h1 id="v-buduschem">  No futuro </h1><br><p>  Pensamos em melhorar a pesquisa, resolvendo um dos problemas mais embara√ßosos do nosso algoritmo, que √© a exist√™ncia de um milh√£o e uma maneira diferente de encurtar uma palavra de 5 letras.  Pode ser resolvido pelo processamento inicial de nomes para revelar abrevia√ß√µes.  Uma maneira de resolver isso √© tentar comparar o nome abreviado do nosso banco de dados com um dos nomes do banco de dados com os nomes completos "corretos".  Essa decis√£o encontra seus obst√°culos definitivos, mas parece uma mudan√ßa promissora. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433070/">https://habr.com/ru/post/pt433070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433058/index.html">Quinteto como uma entidade b√°sica para descrever uma √°rea de assunto</a></li>
<li><a href="../pt433060/index.html">Por que n√£o acredito em marcas de micropigmenta√ß√£o</a></li>
<li><a href="../pt433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Compare C√¢meras CFTV</a></li>
<li><a href="../pt433064/index.html">Gerenciamento de incidentes: "voc√™ n√£o pode desistir" ou a arte de colocar v√≠rgulas</a></li>
<li><a href="../pt433066/index.html">Copo HighLoad # 2. Campeonato para desenvolvedores de back-end de volta ao servi√ßo</a></li>
<li><a href="../pt433072/index.html">Como hackear a prote√ß√£o contra c√≥pia do console Sega Dreamcast</a></li>
<li><a href="../pt433074/index.html">Mudando para o Kotlin em um projeto Android: Dicas e Truques</a></li>
<li><a href="../pt433076/index.html">Como criamos nossa biblioteca da Galeria do Android para exibir conte√∫do de m√≠dia</a></li>
<li><a href="../pt433078/index.html">Escrevemos rob√¥s de negocia√ß√£o usando a estrutura gr√°fica StockSharp. Parte 2</a></li>
<li><a href="../pt433082/index.html">Bombear as contas de outras pessoas se tornou um crime na Cor√©ia do Sul</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>