<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦋 🎽 ☃️ Hasura. Architecture GraphQL à SQL Server haute performance 👐🏾 🧝🏾 🚚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article «Architecture d'un moteur GraphQL vers SQL performant» . 

 Il s'agit de la traduction d'un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hasura. Architecture GraphQL à SQL Server haute performance</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428133/">  Bonjour, Habr!  Je vous présente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Architecture d'un moteur GraphQL vers SQL performant»</a> . <br><br>  Il s'agit de la traduction d'un article sur sa structure interne et sur les optimisations et les solutions architecturales apportées par Hasura - un serveur GraphQL léger hautes performances, qui agit comme une couche entre votre application Web et la base de données PostgreSQL. <br><br>  Il vous permet de générer un schéma GraphQL basé sur une base de données existante ou d'en créer une nouvelle.  Il prend en charge les abonnements GraphQL de la boîte basés sur les déclencheurs Postgres, le contrôle d'accès dynamique, la génération automatique de jointures, résout le problème des demandes N + 1 (traitement par lots) et bien plus encore. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tb/tq/nt/tbtqntldyuxalrgy5wvz9exu5kc.png" width="400"></div><a name="habracut"></a><br>  Vous pouvez utiliser des contraintes de clés étrangères dans PostgreSQL pour obtenir des données hiérarchiques dans une seule requête.  Par exemple, vous pouvez exécuter cette requête afin d'obtenir les albums et leurs pistes correspondantes (si une clé étrangère est créée dans la table "piste" qui pointe vers la table "album") <br><br><pre><code class="hljs dos">{ album (where: {year: {_eq: <span class="hljs-number"><span class="hljs-number">2018</span></span>}}) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> tracks { id <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre> <br>  Comme vous l'avez peut-être deviné, vous pouvez demander des données de n'importe quelle profondeur.  Cette API, combinée au contrôle d'accès, permet aux applications Web d'interroger les données de PostgreSQL sans écrire leur propre backend.  Il est conçu pour répondre aux requêtes le plus rapidement possible, avoir une bande passante élevée, tout en économisant du temps processeur et de la consommation de mémoire sur le serveur.  Nous parlerons des solutions architecturales qui nous ont permis d'y parvenir. <br><br><h2>  Cycle de vie de la demande </h2><br>  Une demande envoyée à Hasura passe par les étapes suivantes: <br><br><ol><li>  <b>Réception de sessions</b> : la demande tombe dans la passerelle, qui vérifie la clé (le cas échéant) et ajoute divers en-têtes, par exemple l'identifiant et le rôle d'utilisateur. </li><li>  <b>Analyse des demandes</b> : Hasura reçoit la demande, analyse les en-têtes pour obtenir des informations sur l'utilisateur, crée GraphQL AST en fonction du corps de la demande. </li><li>  <b>Validation des demandes</b> : une vérification est effectuée pour voir si la demande est sémantiquement correcte, puis les droits d'accès correspondant au rôle de l'utilisateur sont appliqués. </li><li>  <b>Exécution de la requête</b> : la requête est convertie en SQL et envoyée à Postgres. </li><li>  <b>Génération de réponse</b> : le résultat de la requête SQL est traité et envoyé au client (la <i>passerelle peut utiliser gzip si nécessaire</i> ). </li></ol><br><h2>  Buts </h2><br>  Les exigences sont approximativement les suivantes: <br><br><ol><li>  La pile HTTP doit ajouter une surcharge minimale et être capable de gérer de nombreuses demandes simultanées pour un débit élevé. </li><li>  Génération SQL rapide à partir d'une requête GraphQL. </li><li>  La requête SQL générée doit être efficace pour Postgres. </li><li>  Le résultat de la requête SQL doit être renvoyé de Postgres. </li></ol><br><h2>  Traitement des requêtes GraphQL </h2><br>  Il existe plusieurs approches pour obtenir les données requises pour une requête GraphQL: <br><br><h3>  Résolveurs conventionnels </h3><br>  L'exécution de requêtes GraphQL implique généralement l'appel d'un résolveur pour chaque champ. <br>  Dans l'exemple de requête, nous obtenons les albums sortis en 2018, puis pour chacun d'eux, nous demandons les pistes qui lui correspondent - un problème classique de requêtes N + 1.  Le nombre de requêtes augmente de façon exponentielle avec l'augmentation de la profondeur des requêtes. <br><br>  Les demandes faites par Postgres seront: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">2018</span></span>;</code> </pre><br>  Cette demande nous renverra tous les albums.  Supposons que le nombre d'albums retournés par la demande soit égal à N. Ensuite, pour chaque album, nous exécuterions la demande suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album_id = &lt;album-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt;</code> </pre><br>  Au total, vous obtenez N + 1 requêtes pour obtenir toutes les données nécessaires. <br><br><h3>  Demandes groupées </h3><br>  Des outils tels que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chargeur de données</a> sont conçus pour résoudre le problème des demandes N + 1 en utilisant le traitement par lots.  Le nombre de requêtes SQL pour les données incorporées ne dépend plus de la taille de l'échantillon initial, car  Maintenant, cela affecte le nombre de nœuds dans la requête GraphQL.  Dans ce cas, 2 demandes à Postgres sont nécessaires pour obtenir les données requises: <br><br>  Nous obtenons des albums: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Nous obtenons les pistes pour les albums que nous avons reçus dans la demande précédente: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album_id <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> {the <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> album ids}</code> </pre><br>  Au total, 2 requêtes sont reçues.  Nous avons évité d'exécuter des requêtes SQL sur les pistes de chaque album individuel; à la place, nous avons utilisé l'opérateur WHERE pour obtenir toutes les pistes nécessaires en une seule requête à la fois. <br><br><h3>  Se joint </h3><br>  Dataloader est conçu pour fonctionner avec différentes sources de données et ne permet pas d'exploiter les capacités d'une source particulière.  Dans notre cas, Postgres est la seule source de données et, comme toutes les bases de données relationnelles, il offre la possibilité de collecter des données à partir de plusieurs tables avec une seule requête à l'aide de l'opérateur JOIN.  Nous pouvons déterminer toutes les tables nécessaires à une requête GraphQL et générer une seule requête SQL à l'aide de JOIN pour obtenir toutes les données.  Il s'avère que les données nécessaires à toute requête GraphQL peuvent être obtenues à l'aide d'une seule requête SQL.  Ces données sont converties avant d'être envoyées au client. <br><br>  Une telle demande: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> album_id, album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> album_title, track.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> track_id, track.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> track_title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Nous renverra ces données: <br><br><pre> <code class="sql hljs">album_id, album_title, track_id, track_title 1, Album1, 1, track1 1, Album1, 2, track2 2, Album2, NULL, NULL</code> </pre><br>  Ensuite, il sera converti en JSON et envoyé au client: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"Album1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tracks"</span></span>: [ {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"track1"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"track2"</span></span>} ] }, { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"Album2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tracks"</span></span> : [] } ]</code> </pre><br><h2>  Optimisation de la génération de réponse </h2><br>  Nous avons constaté que la plupart du temps dans le traitement des requêtes est consacré à la fonction de conversion du résultat d'une requête SQL en JSON. <br><br>  Après plusieurs tentatives d'optimisation de cette fonction de différentes manières, nous avons décidé de la transférer vers Postgres.  Postgres 9.4 ( <i>sorti à l'époque de la première version de Hasura</i> ) a ajouté une fonction d'agrégation JSON qui nous a aidés à faire ce que nous voulions.  Après cette optimisation, les requêtes SQL ont commencé à ressembler à ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> json_agg(r.*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> title, json_agg(track.*) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> album.id ) r</code> </pre><br>  Le résultat de cette requête aura une colonne et une ligne, et cette valeur sera envoyée au client sans autre conversion.  Selon nos tests, cette approche est environ 3 à 6 fois plus rapide que la fonction de conversion Haskell. <br><br><h2>  Déclarations préparées </h2><br>  Les requêtes SQL générées peuvent être assez volumineuses et complexes selon le niveau d'imbrication de la requête et les conditions d'utilisation.  En règle générale, les applications Web ont un ensemble de requêtes qui sont exécutées à plusieurs reprises avec différents paramètres.  Par exemple, la requête précédente doit être exécutée pour 2017, au lieu de 2018. Les instructions préparées conviennent mieux aux cas où il existe une requête SQL complexe répétitive dans laquelle seuls les paramètres sont modifiés. <br><br>  Disons que cette requête est exécutée pour la première fois: <br><br><pre> <code class="hljs dos">{ album (where: {year: {_eq: <span class="hljs-number"><span class="hljs-number">2018</span></span>}}) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> tracks { id <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre><br>  Nous créons une instruction préparée pour la requête SQL au lieu de l'exécuter: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">PREPARE</span></span> prep_1 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> json_agg(r.*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> title, json_agg(track.*) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> album.</code> </pre><br>  Après quoi nous l'exécutons immédiatement: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> prep_1(<span class="hljs-string"><span class="hljs-string">'2018'</span></span>);</code> </pre><br>  Lorsque vous devez exécuter la requête GraphQL pour 2017, nous appelons simplement la même instruction préparée avec un argument différent: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> prep_1(<span class="hljs-string"><span class="hljs-string">'2017'</span></span>);</code> </pre><br>  Cela donne une augmentation de vitesse d'environ 10 à 20% en fonction de la complexité de la requête GraphQL. <br><br><h2>  Haskell </h2><br>  Haskell fonctionne bien pour plusieurs raisons: <br><br><ul><li>  Langage compilé avec d'excellentes performances ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus de détails ici</a> ). </li><li>  Pile HTTP très efficace ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">warp</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture de warp</a> ). </li><li>  Notre expérience linguistique précédente. </li></ul><br><h2>  En fin de compte </h2><br>  Toutes les optimisations mentionnées ci-dessus entraînent des avantages de performance assez sérieux: <br><br><img src="https://habrastorage.org/webt/oq/fl/gj/oqflgjy29zi_ar0amyy6xfggvbc.png"><br><br>  En fait, la faible consommation de mémoire et les retards insignifiants par rapport aux appels directs à PostgreSQL permettent dans la plupart des cas de remplacer les ORM dans votre backend par des appels API GraphQL. <br><br>  <b>Repères:</b> <br><br>  Banc d'essai: <br><br><ol><li>  Ordinateur portable avec 8 Go de RAM et i7 </li><li>  Postgres s'exécutant sur le même ordinateur </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wrk</a> , a été utilisé comme outil de comparaison et pour divers types de demandes, nous avons essayé de "maximiser" les rps </li><li>  Une instance de Hasura GraphQL Engine </li><li>  Taille du pool de connexions: 50 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jeu de données</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chinook</a> </li></ol><br><br>  <b>Demande 1: tracks_media_some</b> <br><br><pre> <code class="hljs pgsql">query tracks_media_some { tracks (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: {composer: {_eq: "Kurt Cobain"}}){ id <span class="hljs-type"><span class="hljs-type">name</span></span> album { id title } media_type { <span class="hljs-type"><span class="hljs-type">name</span></span> } }}</code> </pre><br><ul><li>  Demandes par seconde: 1375 req / s </li><li>  Retard: 17,5 ms </li><li>  CPU: ~ 30% </li><li>  RAM: ~ 30 Mo (Hasura) + 90 Mo (Postgres) </li></ul><br>  <b>Demande 2: tracks_media_all</b> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> tracks_media_all { <span class="hljs-section"><span class="hljs-section">tracks</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name media_type { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } }}</code> </pre><br><ul><li>  Demandes par seconde: 410 req / s </li><li>  Retard: 59 ms </li><li>  CPU: ~ 100% </li><li>  RAM: ~ 30 Mo (Hasura) + 130 Mo (Postgres) </li></ul><br>  <b>Demande 3: album_tracks_genre_some</b> <br><br><pre> <code class="hljs pgsql">query albums_tracks_genre_some { albums (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: {artist_id: {_eq: <span class="hljs-number"><span class="hljs-number">127</span></span>}}) { id title tracks { id <span class="hljs-type"><span class="hljs-type">name</span></span> genre { <span class="hljs-type"><span class="hljs-type">name</span></span> } } }}</code> </pre><br><ul><li>  Demandes par seconde: 1029 req / s </li><li>  Retard: 24 ms </li><li>  CPU: ~ 30% </li><li>  RAM: ~ 30 Mo (Hasura) + 90 Mo (Postgres) </li></ul><br>  <b>Demande 4: album_tracks_genre_all</b> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> albums_tracks_genre_all { <span class="hljs-section"><span class="hljs-section">albums</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> title tracks { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name genre { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } } }</code> </pre><br><ul><li>  Demandes par seconde: 328 req / s </li><li>  Retard: 73 ms </li><li>  CPU: 100% </li><li>  RAM: ~ 30 Mo (Hasura) + 130 Mo (Postgres) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428133/">https://habr.com/ru/post/fr428133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428123/index.html">Semaine de la sécurité 41: Bonne nouvelle</a></li>
<li><a href="../fr428125/index.html">Qui sont les analyses de produits et pourquoi sont-elles nécessaires dans une équipe?</a></li>
<li><a href="../fr428127/index.html">Cache Nginx: tout nouveau - vieux bien oublié</a></li>
<li><a href="../fr428129/index.html">Une logique floue simple collée «de ce qui était» pour un moteur à turbine à gaz</a></li>
<li><a href="../fr428131/index.html">Toute la vérité sur RTOS. Article # 17. Groupes de drapeaux d'événements: introduction et services de base</a></li>
<li><a href="../fr428135/index.html">Comment configurer ou désactiver les peluches dans l'éditeur de code intégré</a></li>
<li><a href="../fr428137/index.html">Olympiade, concours d'idées, conférences sur la gestion de projets informatiques et projections de films: 10 événements à venir à l'Université ITMO</a></li>
<li><a href="../fr428141/index.html">Le backend pour le frontend, ou comment Yandex.Market crée une API sans béquilles</a></li>
<li><a href="../fr428143/index.html">Approche de mise en œuvre de ReactJS RBAC</a></li>
<li><a href="../fr428147/index.html">Script pour collecter des citations et reconnaître le texte d'une vidéo en Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>