<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèΩ üïã üëÖ BTRFS f√ºr die Kleinsten üññüèª ü•õ ü§£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Chabravchane. Ich arbeite bei Veeam Software und bin einer der Entwickler unserer Linux-Backup-L√∂sung. Durch die Besetzung bin ich zuf√§llig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BTRFS f√ºr die Kleinsten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/458250/"> Guten Tag, Chabravchane.  Ich arbeite bei Veeam Software und bin einer der Entwickler unserer Linux-Backup-L√∂sung.  Durch die Besetzung bin ich zuf√§llig auf BTRFS gesto√üen.  In j√ºngerer Zeit ist es vom Status ‚Äûnoch nicht geeignet‚Äú zum Status ‚Äûstabil‚Äú √ºbergegangen.  Und w√§hrend die ersten Benutzer im Netzwerk Problembereiche und Stabilit√§tsprobleme diskutierten, stie√üen wir bei Veeam mit einem Zauberstab darauf und versuchten, es zu sichern.  Es stellte sich, gelinde gesagt, nicht sehr viel heraus - es ist zu unterschiedlich, nicht wie herk√∂mmliche Dateisysteme.  Ich musste viele Aspekte studieren und viele Rechen sammeln, bevor wir lernten, damit zu arbeiten.  W√§hrend des Lernprozesses hat es BTRFS geschafft, mich sowohl auf gute als auch auf weniger gute Weise zu beeindrucken.  Ich bin sicher, sie wird keinen IT-Spezialisten aus der Linux-Welt gleichg√ºltig lassen: Einige werden spucken, andere werden loben. <br><br>  Wenn Sie von diesem Dateisystem geh√∂rt haben, aber nicht wissen, warum es ist, sich f√ºr Details interessieren oder suchen, wo Sie es kennenlernen k√∂nnen, lade ich Sie zu cat ein. <br><a name="habracut"></a><br><h1>  Einf√ºhrung </h1><br>  BTRFS (B-Tree Filesystem) - Dateisystem f√ºr Unix-√§hnliche Betriebssysteme, basierend auf der Copy-on-Write-Technik (CoW), das eine einfache Skalierung des Dateisystems, ein hohes Ma√ü an Datenzuverl√§ssigkeit und -sicherheit, Konfigurationsflexibilit√§t und einfache Verwaltung bei gleichzeitiger Wartung bietet zur gleichen Zeit hohe Geschwindigkeit.  Zumindest sagt das die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haupt-Wiki-Seite</a> . <br><br>  Um die Formalit√§ten zu erf√ºllen, listen wir die Hauptmerkmale von btrfs auf: <br><br><ul><li>  Maximale Dateigr√∂√üe 2 ^ 64 Bytes <br></li><li>  Dynamische Inode-Tabelle <br></li><li>  Datendeduplizierung <br></li><li>  Effektive Dateispeicherung in sehr kleinen und sehr gro√üen Gr√∂√üen <br></li><li>  Subwolums und Snapshots erstellen <br></li><li>  Subvolumenquoten <br></li><li>  Pr√ºfsummen f√ºr Daten und Metadaten <br></li><li>  Die M√∂glichkeit, mehrere Laufwerke in einem einzigen Dateisystem zu kombinieren <br></li><li>  Erstellen einer RAID-Konfiguration auf Dateisystemebene <br></li><li>  Datenkomprimierung <br></li><li>  Defragmentierungsdaten im laufenden Betrieb <br></li></ul><br>  Ich m√∂chte Sie sofort warnen, dass sich BTRFS aktiv entwickelt und einige Punkte von Version zu Version unterschiedlich sein k√∂nnen.  √úber den Link <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://btrfs.wiki.kernel.org/index.php/Changelog k√∂nnen</a> Sie herausfinden, wann welche Funktionen hinzugef√ºgt, ge√§ndert oder behoben wurden. <br><br>  Ja, BTRFS ist ein junges und modernes Dateisystem, das eine Vielzahl von Aufgaben l√∂st, jedoch nicht ohne Nachteile: <br><br><ul><li>  Die aktive Entwicklung f√ºhrt zu einer √Ñnderung aller wichtigen Punkte, auf die sich Drittanbieter bei der Arbeit verlassen k√∂nnen. <br></li><li>  Trotz der Zusicherungen der Entwickler hinsichtlich der Stabilit√§t von BTRFS treten bei Benutzern regelm√§√üig Probleme auf, die m√∂glicherweise zu Datenverlust f√ºhren.  In der Regel ‚Äûschweben‚Äú sie in der Natur, weshalb sie noch nicht untersucht und korrigiert wurden. <br></li><li>  Hohe Anf√§lligkeit f√ºr Fragmentierung. <br></li><li>  Sp√§rliche und manchmal veraltete Dokumentation. <br></li></ul><br>  Eine ganze Seite ist den Problemen des Dateisystems in verschiedenen Versionen der Kernel gewidmet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://btrfs.wiki.kernel.org/index.php/Gotchas</a> .  Ich rate Ihnen dringend, dort nachzuschauen - es stellt sich als sehr interessant und nicht offensichtlich heraus. <br><br><h1>  BTRFS-Struktur </h1><br>  Das vereinfachte BTRFS-Ger√§t kann in folgende Ebenen unterteilt werden: <br><br><img src="https://habrastorage.org/webt/zz/n8/zj/zzn8zjyt0dai6ge9rifhgcdwg0q.png"><br><br>  Blockger√§te befinden sich auf der untersten Ebene und stellen einen oder mehrere separate physische Adressr√§ume dar (dasselbe ‚Äûphysische‚Äú wie die Blockger√§te selbst, dies sind jedoch bereits Details).  Durch spezielle Strukturen werden die zugewiesenen physischen Speicherbl√∂cke zu einem einzigen virtuellen Adressraum zusammengefasst. <br><br>  Metadatenstrukturen und Bl√∂cke mit Benutzerdaten (Extents) werden bereits auf logischer Ebene angesprochen.  Infolgedessen k√∂nnen sich Daten, die sich sequentiell auf einer logischen Ebene befinden, physisch auf verschiedenen Blockger√§ten befinden. <br><br>  Metadatenstrukturen k√∂nnen in Ebenen unterteilt werden.  Nat√ºrlich werde ich sie nicht klassifizieren - es gibt viele von ihnen, und solche Details auf niedriger Ebene sind das Thema eines separaten Artikels.  Hier ist es wichtig, dass sich einige Strukturen in der Hierarchie als h√∂her als andere herausstellen, und ganz oben wird es eine Struktur geben, die ein Subvolumen ist. <br><br>  Subvolume ist eine Art Einstiegspunkt oder vielmehr die Stammelemente des Dateisystems.  Sie bilden eine separate Ebene der Datendarstellung, die die Arbeit der unteren Ebenen zusammenfasst und Benutzerdaten in der √ºblichen Form darstellt: Verzeichnisse und Dateien.  Dar√ºber hinaus sind Subw√∂lfe ein Schl√ºsselelement des CoW-Mechanismus in BTRFS.  Dieselben Dateien in zwei Subvolumes k√∂nnen sich als derselbe Datensatz auf den unteren Ebenen herausstellen. <br><br>  Die letzte Schicht ist die Datenschicht.  Wie der Benutzer sie sieht.  Dies sind Dateien und Verzeichnisse, die sich im Subvolume befinden. <br><br>  Aber genug Theorie.  Es ist Zeit, weiter zu √ºben! <br><br><h1>  Btrfs-Progs </h1><br>  Dies ist ein Standardsatz von Dienstprogrammen zum Verwalten von BTRFS.  Abh√§ngig vom Distributionspaket kann das Paket mit diesen Dienstprogrammen im Repository unterschiedliche Namen haben: <b>btrfsprogs</b> , <b>btrfs-progs</b> , <b>btrfs-tools</b> usw.  Wenn Ihr Repository nichts √Ñhnliches hatte, k√∂nnen Sie es jederzeit manuell kompilieren. Die Quellen sind nicht weit entfernt - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/kdave/btrfs-progs</a> . <br>  Die wichtigsten Dienstprogramme in diesem Paket sind <b>btrfs</b> und <b>mkfs.btrfs</b> .  Ab dem zweiten, denke ich, ist alles sehr klar - es ist notwendig, BTRFS auf einem Blockger√§t zu erstellen.  Erstens ist <b>btrfs</b> das Hauptdienstprogramm, mit dem Sie den Rest erledigen k√∂nnen.  Eine Art "Schweizer Messer". <br><br>  In diesem Artikel habe ich Version v4.15.1 verwendet.  Das Dienstprogramm entwickelt sich sehr aktiv und es gibt sp√ºrbare Unterschiede von Version zu Version.  Wenn Sie also nicht √ºber den erforderlichen Befehl verf√ºgten, √ºberpr√ºfen Sie die Version des Dienstprogramms <b>btrfs.</b> M√∂glicherweise ist sie bereits veraltet. <br><br>  Wahrscheinlich befinden sich auch die Dienstprogramme <b>btrfsck</b> und <b>btrfstune</b> im Paket. <br><br><ul><li>  Die erste dient dazu, das Dateisystem auf Fehler und nachfolgende Korrekturen zu √ºberpr√ºfen. Ich empfehle jedoch nicht, es zu verwenden. Es befindet sich im <i>veralteten</i> Status und seine Funktionalit√§t wurde in den Befehl <b>btrfs check</b> verschoben. </li><li>  Mit der zweiten Option k√∂nnen Sie einige n√ºtzliche Vorg√§nge f√ºr btrfs ausf√ºhren, z. B. die eindeutige Kennung des Dateisystems (FS UUID) √§ndern oder bestimmte Funktionen des Dateisystems aktivieren. </li></ul><br>  Zus√§tzlich zu den oben aufgef√ºhrten Dienstprogrammen enth√§lt das Paket mehrere weitere Dienstprogramme, die jedoch haupts√§chlich zum Debuggen von btrfs ben√∂tigt werden und in diesem Artikel nicht hilfreich sind. <br><br><h1>  Formatieren einer Festplatte in BTRFS </h1><br>  In der Praxis ist alles einfacher.  Beginnen wir mit einem Laufwerk. <br>  Das Formatieren einer einzelnen Festplatte in btrfs erfolgt mit dem √ºblichen Befehl: <br><br><pre><code class="bash hljs">mkfs.btrfs /dev/sdc -L single_drive</code> </pre> <br>  Als Antwort gibt das Dienstprogramm die Parameter des erstellten Dateisystems an die Konsole aus: <br><br><pre> <code class="bash hljs">btrfs-progs v4.15.1 See http://btrfs.wiki.kernel.org <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. Label:       single_drive UUID:        59307d69-6d2f-4d2e-aae2-a5189ad3c256 Node size:     16384 Sector size:    4096 Filesystem size:  1.00GiB Block group profiles: Data:       single 8.00MiB Metadata:     DUP 51.19MiB System:      DUP 8.00MiB SSD detected:    no Incompat features: extref, skinny-metadata Number of devices: 1 Devices:  ID    SIZE PATH   1   1.00GiB /dev/sdc</code> </pre><br>  Lassen Sie uns die dargestellten Parameter durchgehen. <br><br><ul><li>  <b>Label</b> - Ein Label- oder Dateisystemname.  Sie wird vom Schalter <code>-L</code> angegeben und ist ein optionaler Parameter. </li><li>  <b>UUID</b> ist eine eindeutige Kennung, mit der der btrfs-Kernel Instanzen voneinander unterscheidet. </li><li>  <b>Knotengr√∂√üe</b> - Die Gr√∂√üe der B-Tree-Elemente, in denen Metadaten gespeichert sind.  Sie kann mit <code>-n | --nodesize</code>  <code>-n | --nodesize</code> , und es muss ein Vielfaches der Gr√∂√üe der <code>-n | --nodesize</code> sein.  Die geringe Gr√∂√üe des Knotens f√ºhrt zu einer Zunahme der H√∂he des B-Baums (einer Zunahme der Anzahl von Knoten) und infolgedessen zu einer Abnahme der Konkurrenz um das Blockieren eines einzelnen Knotens.  Andererseits macht die geringe Gr√∂√üe des Knotens die Dateisysteminstanz anf√§lliger f√ºr Fragmentierung.  Gro√üe Knoten tragen andererseits zu einer besseren Metadatenverpackung auf der Festplatte bei, wodurch die Fragmentierung verringert wird. <br>  Der Nachteil ist eine l√§ngere Datenzugriffszeit f√ºr die Aktualisierung desselben Knotens durch mehrere Threads.  Auf Kerneln, die √§lter als 3.11 sind, betr√§gt die Gr√∂√üe des Knotens standardm√§√üig 16384 Byte oder die Gr√∂√üe der Betriebssystemspeicherseite (der gr√∂√üere dieser beiden Werte). </li><li>  <b>Sektorgr√∂√üe</b> - Die Menge an Speicherplatz, die ein Vielfaches des Speicherplatzes ist, der auf physischer Ebene zugewiesen und freigegeben wird.  Sie entspricht der Seitengr√∂√üe des virtuellen Speichers des Betriebssystems, sofern mit dem <code>-s</code> nichts anderes angegeben ist. </li><li>  <b>Dateisystemgr√∂√üe</b> - Die Gesamtkapazit√§t des Dateisystems (Daten plus Metadaten).  Manuell mit dem Schalter <code>-b</code> einstellen.  Standardm√§√üig ist das gesamte Volume des Blockger√§ts belegt. </li><li>  <b>Inkompatible Funktionen</b> - Eine Liste der Funktionen, die in den erstellten btrfs enthalten sind und die Abw√§rtskompatibilit√§t mit √§lteren Kernelversionen beeintr√§chtigen.  Wenn Abw√§rtskompatibilit√§t erforderlich ist, k√∂nnen Sie Folgendes deaktivieren: <br><br><pre> <code class="bash hljs">--features ^extref,^skinny-metadata.</code> </pre> <br>  √úbrigens k√∂nnen Sie mit dem folgenden Aufruf √ºberpr√ºfen, welche Funktionen der aktuelle Kernel unterst√ºtzt: <br><br><pre> <code class="bash hljs">mkfs.btrfs --features list-all</code> </pre> </li><li>  <b>Anzahl der Ger√§te und Ger√§te</b> - Wie viele Blockger√§te sind an der erstellten btrfs-Instanz beteiligt, und eine Liste aller Ger√§te. </li><li>  Wir sollten auch √ºber den Parameter <b>Blockgruppenprofile</b> sprechen.  Es gibt das zutreffende Datensatzprofil f√ºr jeden der drei Datentypen an: Daten, Metadaten und System.  Zur√ºck zur verallgemeinerten Struktur von btrfs k√∂nnen wir sagen: <br><br><ul><li>  Daten sind Benutzerdaten; </li><li>  Metadaten sind eine Kombination aus einer Subvolumebene und einer Ebene aus Metadaten und Extents. </li><li>  System sind Strukturen zum Abbilden des Adressraums des physischen Speichers in einen kontinuierlichen Raum logischer Adressen. </li></ul><br>  Ein Aufzeichnungsprofil ist eine M√∂glichkeit, Daten auf physischer Ebene zu speichern: <br><br><ul><li>  Einzelne Datenspeicherung in einer einzigen Kopie; </li><li>  DUP - Vervielf√§ltigung von Daten auf einem Medium; </li><li>  RAIDX ist eine der Konfigurationen von RAID0, RAID1, RAID10, RAID5 und RAID6. </li></ul><br></li></ul><br>  Wenn Sie ein Blockger√§t markieren, wendet btrfs standardm√§√üig eine Duplizierung auf Metadaten und Systemdaten an, und Benutzerdaten verbleiben in einer einzigen Kopie auf dem Datentr√§ger.  Wenn Sie btrfs auf mehreren Datentr√§gern gleichzeitig erstellen, wird das Profil "RAID0" standardm√§√üig auf Benutzerdaten und "RAID1" auf Metadaten angewendet. <br>  Diese Gruppe von Parametern wird mit zwei Schl√ºsseln gesteuert: <code>-d</code> f√ºr Daten und <code>-m</code> f√ºr Metadaten und Systemdaten. <br><br>  Aber es gibt eine Nuance ... Bei SSDs ist das anders.  Tatsache ist, dass wenn wir ein SSD-Laufwerk (oder ein Flash-Laufwerk) markieren w√ºrden, das Dateisystem standardm√§√üig keine Metadaten duplizieren w√ºrde.  SSDs k√∂nnen die Datendeduplizierung verl√§ngern, um die Lebensdauer von Speicherelementen zu verl√§ngern.  Das hei√üt,  Mit zwei logischen Kopien der Daten wird tats√§chlich nur eine auf dem Medium aufgezeichnet.  Wenn ein Speichersegment ausf√§llt, werden daher ‚Äûbeide Kopien‚Äú der Daten besch√§digt.  Durch zweimaliges Schreiben von Daten wird die SSD-Ressource au√üerdem einfach schneller verbraucht. <br><br>  Um den Medientyp zu bestimmen, √ºberpr√ºft btrfs den Inhalt der Datei <i>/ sys / block / DEV / queue / rotational</i> , wobei "DEV" der Name des zu √ºberpr√ºfenden Blockger√§ts ist. <br>  Selbstverst√§ndlich kann auch bei einer SSD das Speicherprofil erzwungen werden. <br><br>  Um eine btrfs-Instanz auf mehreren Ger√§ten zu erstellen, geben Sie diese einfach mit einem Leerzeichen an: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -L double_drive</code> </pre> <br>  oder mit Profilen: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -d raid1 -m raid1 -L raid1_drive</code> </pre> <br>  Es ist zu beachten, dass die Medien nicht dieselbe Gr√∂√üe haben m√ºssen, auch wenn die vollst√§ndige Spiegelung verwendet wird.  Sobald jedoch nicht gen√ºgend Speicherplatz auf dem kleinsten Laufwerk vorhanden ist, um Speicher zuzuweisen, zeigt das Dateisystem eine Meldung an, dass kein freier Speicherplatz vorhanden ist, obwohl physisch m√∂glicherweise noch freier Speicherplatz auf anderen Medien vorhanden ist. <br><br><h1>  Montage </h1><br>  Der erste Mount von frisch erstellten btrfs unterscheidet sich nicht von anderen Dateisystemen: <br><br><pre> <code class="bash hljs">mount /dev/sdc /mnt</code> </pre> <br>  Befindet sich das Dateisystem auf mehreren Festplatten, reicht es zum Mounten aus, eine davon anzugeben. <br><br>  Im Allgemeinen umfasst das Mounten von btrfs immer das Mounten eines oder mehrerer seiner Subvolumes.  Wenn der Befehl mount nicht angegeben ist, welches Subvolume gemountet werden soll, liest btrfs aus dem speziellen Datensatz die ID des Subvolumes, das standardm√§√üig gemountet werden muss.  Dieser Eintrag kann sp√§ter mit dem Befehl <code>btrfs set-default</code> ge√§ndert werden. Wenn Sie ihn jedoch zum ersten Mal auf btrfs bereitstellen, gibt es nur ein Subvolume - das Root-Volume.  Es ist standardm√§√üig f√ºr die Montage angegeben. <br><br>  Die Root-Unterwelt auf btrfs ist immer vorhanden.  Es wird zusammen mit dem Dateisystem angezeigt und kann in Zukunft nicht mehr ge√§ndert werden. <br><br>  Es gibt zwei M√∂glichkeiten, ein anderes als das Standard-Subvolume bereitzustellen: <br>  Geben Sie den Pfad vom Root-Subvolume btrfs an: <br><br><pre> <code class="bash hljs">mount -o subvol=/path/to/subvol /dev/sdc /mnt</code> </pre> <br>  Geben Sie entweder die Subvolume-ID an: <br><br><pre> <code class="bash hljs">mount -o subvolid=257 /dev/sdc /mnt</code> </pre> <br>  Wie bereits erw√§hnt, wird eines der btrfs-Subvolumes standardm√§√üig als gemountet angegeben.  Finden Sie heraus, welches m√∂glich ist, indem Sie Folgendes tun: <br><br><pre> <code class="bash hljs">btrfs subvolume get-default /path/to/any/subvolume</code> </pre> <br>  Um den Standard-Submount zu installieren, k√∂nnen Sie den folgenden Befehl verwenden: <br><br><pre> <code class="bash hljs">btrfs subvolume <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-default 258 /path/to/any/subvolume</code> </pre> <br>  Der Pfad zum Subvolume wird in diesem Fall nur ben√∂tigt, um die spezifische btrfs-Instanz anzugeben, f√ºr die der Befehl gilt.  Dies muss √ºbrigens keine Unterwelt sein, der Pfad zu einem Verzeichnis ist ebenfalls geeignet. <br><br>  Der Befehl <code>mount</code> akzeptiert eine Vielzahl von Optionen zum Steuern der Funktionen von btrfs: Defragmentierung, Cache-Leeren, Komprimierung, Cow, Protokollierung, Balance, SSD-Unterst√ºtzung und viele andere f√ºr btrfs spezifische Dinge.  Ich werde sie im Rahmen dieses Artikels nicht ber√ºcksichtigen, weil  Sie werden f√ºr die Feinabstimmung des Dateisystems ben√∂tigt, und in den allermeisten F√§llen k√∂nnen Sie auf sie verzichten. <br><br><h1>  Subvolumen ist </h1><br>  Ein Subvolume ist ein Schl√ºsselelement von btrfs, das verschiedene Funktionen ausf√ºhrt: <br><br><ul><li>  Speicherung von Benutzerdaten und anderem Teilvolumen, <br></li><li>  Bereitstellung des Zugriffs auf Daten (Montage), <br></li><li>  CoW-Mechanismus <br></li><li>  Schnappsch√ºsse erstellen. <br></li></ul><br>  In erster N√§herung ist das Subvolumen ein normales Verzeichnis.  Sie k√∂nnen sie umbenennen / verschieben, ihren Inhalt anzeigen, Dateien darin platzieren und √§ndern.  Es sind keine speziellen Dienstprogramme erforderlich. <br><br>  Das Erstellen und L√∂schen eines Subvolumes erfolgt auf gemounteten btrfs mit speziellen Befehlen: <br><br><pre> <code class="bash hljs">btrfs subvolume create /mnt/subvolume_name btrfs subvolume delete /mnt/subvolume_name</code> </pre> <br>  Ich stelle fest, dass, wenn Sie versuchen, das Subvolume mit dem Dateimanager oder dem Dienstprogramm <b>rm</b> zu entfernen, der Vorgang mit einem Fehler endet, der <i>nicht zul√§ssig</i> ist (der Vorgang ist nicht zul√§ssig). <br><br>  <b>UPD:</b> Ab Kernel Version 4.18.0 k√∂nnen Sub-Volleys mit dem Dienstprogramm <b>rm</b> oder den Dateimanager-Tools gel√∂scht werden.  Anscheinend war es ein Fehler, keine Funktion.  Vielen Dank an Prototik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Habravchanin</a> f√ºr die Klarstellung. <br><br>  Nach dem Erstellen eines Subvolumes k√∂nnen Sie dessen Eigenschaften sehen: <br><br><pre> <code class="bash hljs">btrfs subvolume show /mnt/subvolume_name Name:          subx UUID:          09af45e8-d2b2-b342-8a92-fa270ac82d0a Parent UUID:      - Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      268 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Lassen Sie uns die Haupteigenschaften des Subwolumes durchgehen: <br><br><ul><li>  <b>Name</b> - Der Name des Subvolumes <br></li><li>  <b>UUID</b> ist eine universelle eindeutige Kennung, die haupts√§chlich dazu dient, Subwoofer-Snapshot-Beziehungen zu bestimmen. <br></li><li>  <b>√úbergeordnete UUID</b> - Kennung des Subvolume-Vorfahren, von dem der aktuelle abgeleitet ist. <br></li><li>  <b>Empfangene UUID</b> - Kennung des Subvolume-Vorfahren, der √ºber <i>btrfs send</i> gesendet wurde. <br></li><li>  <b>Subvolume ID</b> - eine eindeutige Kennung f√ºr die Platzierung im B-Baum, <br></li><li>  <b>Generierung</b> - Transaktionsnummer bei der letzten Aktualisierung der Subvolume-Metadaten, <br></li><li>  <b>Gen bei der Erstellung</b> - Transaktionsnummer zum Zeitpunkt der Erstellung des Subvolumes, <br></li><li>  <b>√úbergeordnete ID</b> - Kennung des Subvolumens, in das das aktuelle eingebettet ist. <br></li><li>  <b>Die ID der obersten Ebene entspricht</b> genau der <b>ID</b> der Eltern. <br></li><li>  <b>Flags</b> - Flags (tats√§chlich ist nur 1 Flag <i>schreibgesch√ºtzt</i> ), <br></li><li>  <b>Schnappsch√ºsse</b> - Eine Liste von Schnappsch√ºssen aus diesem Subvolume. <br></li></ul><br>  Das Subvolume hat einen weiteren Parameter - dies ist sein Pfad vom Stammelement btrfs.  Der Pfad wird angezeigt, wenn das Subvolume aufgelistet wird: <br><br><pre> <code class="plaintext hljs">btrfs subvolume list /path/to/any/btrfs/mountpoint</code> </pre> <br>  Aber hier ist alles einfach und klar - es macht nicht einmal Sinn, die Ausgabe des Befehls zu bringen. <br>  Wie bei den Befehlen <code>get-default</code> und <code>set-default</code> k√∂nnen Sie hier den Pfad zu einem beliebigen Subvolume angeben. Das Ergebnis √§ndert sich nicht.  Dieser Pfad wird verwendet, um das Root-Subbolum btrfs zu finden.  Danach wird der gesamte Subwolum-Baum gelesen. <br><br>  Wenn Sie versuchen, das Subvolume beispielsweise mit dem Dienstprogramm <b>cp zu</b> kopieren, ist der Kopiervorgang erfolgreich. Infolgedessen wird jedoch nicht das Subvolume erstellt, sondern das √ºbliche Verzeichnis.  Btrfs bietet jedoch ein viel flexibleres Werkzeug zum Erstellen solcher Kopien - Schnappsch√ºsse. <br><br><h1>  Schnappschuss ist </h1><br>  Snapshot ist auch eine Unterwelt mit erweiterten Eigenschaften. <br><br>  Ihr Hauptunterschied besteht darin, dass der Schnappschuss Aufzeichnungen dar√ºber enth√§lt, aus welchem ‚Äã‚ÄãSubwolum er hergestellt wurde.  Dies sind die Felder <b>Parent UUID</b> und <b>Received UUID</b> .  Im Subwoofer sind diese Felder ebenfalls vorhanden, sie sind jedoch immer leer.  Tats√§chlich sind ein Schnappschuss und ein Subvolumen ein und dasselbe. <br>  Beim Erstellen k√∂nnen Sie den Snapshot mit der <code>-r</code> f√ºr √Ñnderungen blockieren. <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot -r /path/to/subvol /path/to/snapshot</code> </pre> <br>  In diesem Fall bleiben die Dateien garantiert in dem Zustand, in dem sie sich zum Zeitpunkt der Erstellung des Snapshots befanden. <br><br>  Das schreibgesch√ºtzte Flag kann auch manuell gesteuert werden. Dies funktioniert f√ºr jedes Subvolume: <br><br><pre> <code class="plaintext hljs">btrfs property get /path/to/subvol ro btrfs property set /path/to/subvol ro true</code> </pre> <br>  Wenn wir uns nun die Eigenschaften des Snapshots ansehen, sehen wir das ausgef√ºllte <b>√ºbergeordnete UUID-</b> Feld: <br><br><pre> <code class="plaintext hljs">btrfs subvolume show /path/to/snapshot Name:          subx UUID:          d08612d8-596a-11e9-8647-d663bd873d93 Parent UUID:      09af45e8-d2b2-b342-8a92-fa270ac82d0a Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      269 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Ein wichtiges Merkmal der Snapshot-Operation ist, dass sie nicht rekursiv ist.  Anstelle eines verschachtelten Subvolumes werden im Snapshot leere Verzeichnisse erstellt. <br><br>  Wenden wir uns dem folgenden Beispiel zu. <br><br>  Im Dateisystem befindet sich ein Subwoofer ‚Äûsub0‚Äú, in dem sich ein Subwoofer <i>subA</i> und ein Verzeichnis <i>dirB befinden</i> .  In jedem von ihnen befinden sich <i>fileA</i> bzw. <i>fileB</i> . <br><br>  Schnappschuss entfernen: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0 snap0</code> </pre> <br><img src="https://habrastorage.org/webt/cf/or/w-/cforw-vhzoma9iub2hcyejkbh84.png"><br><br>  Der <i>erstellte</i> Snapshot <i>Snap0</i> erbt alle Dateien und Verzeichnisse des √ºbergeordneten Snapshots. Der SubA- <i>Subwoofer</i> wird jedoch nicht im Snapshot angezeigt.  Stattdessen wird im Snapshot nur ein leeres Verzeichnis angezeigt, d. H.  Der Inhalt des SubA- <i>Subvolumes</i> wird nicht vererbt. <br><br>  Einerseits ist dies gut - wir entfernen den Schnappschuss aus einem bestimmten Subvolume, und alle verschachtelten sind f√ºr uns nicht von Interesse.  Wenn andererseits ein rekursiver Snapshot erforderlich ist, hat btrfs keine L√∂sung f√ºr dieses Problem.  Wir m√ºssen nach Arbeitsrunden suchen. <br><br>  Die erste Problemumgehung basiert auf der Tatsache, dass der Snapshot ohne schreibgesch√ºtztes Flag entfernt wurde, sodass Sie die Situation ganz einfach beheben k√∂nnen: <br><br><ul><li>  Entfernen Sie das zus√§tzliche Verzeichnis aus dem Snapshot <br><br><pre> <code class="plaintext hljs">rmdir snap0/subA</code> </pre> <br></li><li>  Entfernen Sie den Snapshot aus einem verschachtelten Subvolume <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snap0/subA</code> </pre> <br></li></ul><br><img src="https://habrastorage.org/webt/ja/u3/fy/jau3fyzmzjxzxweajh-tmjld-iw.png"><br><br>  Wenn der Schnappschuss mit dem schreibgesch√ºtzten Flag entfernt wurde, funktioniert die obige Option nicht, da  In <i>snap0 k√∂nnen</i> Sie weder das Verzeichnis l√∂schen noch einen Snapshot platzieren.  Es gibt nur eine Option: Platzieren Sie Schnappsch√ºsse in der N√§he des Snap0- <i>Subwoofers</i> : <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snapA</code> </pre> <br>  und mounten <i>Sie</i> dann <i>snapA</i> in <i>snap0</i> snapshot, das Verzeichnis daf√ºr ist bereits vorhanden: <br><br><pre> <code class="plaintext hljs">mount -o subvol=snapA snap0/subA</code> </pre> <br><img src="https://habrastorage.org/webt/mu/-w/nn/mu-wnnj0jiyyinnxokz08nuipag.png"><br><br>  In jedem Fall ist es wichtig zu verstehen, dass rekursive Schnappsch√ºsse alle zu unterschiedlichen Zeiten in unterschiedlichen Vorg√§ngen aufgenommen werden.  Es kann nicht von einer atomaren Entfernung eines Schnappschusses aus mehreren Subvolumina gesprochen werden. <br><br><h1>  Beim Schreiben kopieren </h1><br>  Ein bisschen √ºber Subvolume und CoW-Ansatz.  Stellen Sie sich vor, ein Subvolume befindet sich im Dateisystem und eine Datei befindet sich darin (im Idealfall - die Datei ist nicht fragmentiert).  Als n√§chstes wird ein Schnappschuss vom Subwolly entfernt. <br><br><img src="https://habrastorage.org/webt/hg/yo/sl/hgyoslduv5eeenpopaqu3dk7qyw.png"><br><br>  Im Dateisystem wird ein neues Subvolume (Snapshot) mit genau demselben Inhalt wie das urspr√ºngliche Subvolume angezeigt.  Das Erstellen eines Schnappschusses erfolgt fast augenblicklich - die Daten der Datei selbst werden nicht kopiert.  Stattdessen werden zus√§tzliche Metadaten erstellt und ein Snapshot zusammen mit dem √ºbergeordneten Subvolume wird zum Eigent√ºmer der Datei.  Tats√§chlich gab es nur eine Datei auf der Festplatte, aber jetzt geh√∂rt sie sowohl zum Subvolume als auch zum Snapshot. <br>  Wenn Sie jetzt die Datei im Subvolume √§ndern, wirken sich die √Ñnderungen nicht auf die Datei im Snapshot aus.  Wenn beim Erstellen des Snapshots das schreibgesch√ºtzte Flag nicht gesetzt wurde, kann auch die Datei im Snapshot ge√§ndert werden. <br><br><img src="https://habrastorage.org/webt/7n/1e/0t/7n1e0tkdlxsuqkpjmtinix0yiys.png"><br><br>  Technisch gesehen werden beim √Ñndern einer Datei nur diese √Ñnderungen aufgezeichnet.  Die Quelldatei wird also auf der Festplatte gespeichert, plus ein Delta, das die Originaldatei von der ge√§nderten unterscheidet.  Wenn Sie eines der Subvolumes l√∂schen (mit dem zweiten meine ich einen Snapshot), werden √ºbersch√ºssige Daten, die von niemandem mehr verwendet werden, von der Festplatte gel√∂scht, und nur die aktuelle Version der Datei verbleibt auf der Festplatte (aus Sicht des verbleibenden Subvolumes). <br><br>  <i>Ein kurzer Hinweis</i> : Nach dem Entfernen verschwindet der Subwoofer sofort aus den Augen des Benutzers und das Dienstprogramm gibt die Steuerung an das Terminal zur√ºck. Die Daten auf der Festplatte werden jedoch f√ºr einige Zeit durch den Hintergrundprozess bereinigt.  Das hei√üt, im Gegensatz zum Entfernen eines regul√§ren Verzeichnisses muss nicht auf den tats√§chlichen Abschluss des L√∂schvorgangs gewartet werden.  Wenn Sie mit diesem Prozess synchronisieren und warten m√ºssen, bis er abgeschlossen ist, k√∂nnen Sie beim Aufruf von <b>delete den</b> Schalter <code>--commit-after</code> angeben.  Der Befehl <b>btrfs subvolume list</b> , <b>der</b> mit der <b>Option</b> <code>-d</code> <b>aufgerufen wird</b> , zeigt eine Liste der Subvolumes an, die vom Benutzer gel√∂scht wurden und gerade von der Festplatte gel√∂scht werden. <br><br>  Dar√ºber hinaus k√∂nnen Sie mit btrfs Dateien im Dateisystem klonen, ohne auf Snapshots zur√ºckgreifen zu m√ºssen.  Dies erfolgt durch regelm√§√üiges Kopieren mit der <code>--reflink</code> : <br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always /original/file /copied/file</code> </pre> <br>  Der Schl√ºssel <code>reflink=always</code> teilt dem Dateisystem mit, dass beim Kopieren der CoW-Mechanismus verwendet werden soll.  Nach dem Kopieren k√∂nnen Dateien unabh√§ngig voneinander ge√§ndert werden, sodass wir das gleiche Verhalten wie nach dem Erstellen eines Snapshots erhalten.  Warum brauchen wir dann Subbolen? <br><br>  Subtolums auf btrfs spielen die Rolle eines √ºbergeordneten Steuerungswerkzeugs f√ºr ganze Datens√§tze: Erstens ist es die atomare Schnappschussentfernung aus allen Daten eines Subvolumens (im Fall von --reflink-Atomizit√§t nur auf Dateiebene), und zweitens ist es m√∂glich zu sehen, von wem es geerbt wird oder schnell den Datensatz auf eine fr√ºhere Version usw. zur√ºcksetzen. <br>  Somit bietet btrfs die M√∂glichkeit, Dateizust√§nde zu gew√ºnschten Zeitpunkten zu erfassen, wobei Subvolume als √ºbergeordnetes Mittel zur Verwaltung dieser Zust√§nde verwendet wird. <br><br><h1>  Subvolume Recovery </h1><br>  In den Weiten stellt sich oft die Frage: "Ich habe einen Subwoofer, ich habe einen Schnappschuss, wie man einen R√ºckw√§rtsgang macht?"  Dieser Ansatz gilt nicht f√ºr btrfs, weil  Es gibt keine M√∂glichkeit, "den Subwolly zur√ºckzurollen".  Stattdessen bietet btrfs eine Strategie an, um den Subwolly durch seinen Snapshot zu ersetzen.  In der Tat, warum etwas zur√ºcksetzen, wenn der Schnappschuss selbst dieses Objekt ist, das wir mit Zur√ºcksetzen erhalten m√∂chten. <br><br>  Stellen Sie sich dieses Szenario vor: Auf btrfs gibt es ein Subvolume, in dem sich die Dateien einer Datenbank befinden (also oder andere wichtige Daten).  Snapshots werden regelm√§√üig aus diesem Subvolume entfernt, und irgendwann m√ºssen die Daten zur√ºckgesetzt werden.  In diesem Fall entfernen wir einfach das Subwolum und verwenden stattdessen den daraus entnommenen Snapshot. Wenn wir diese Daten nicht ebenfalls verderben m√∂chten, entfernen wir einen weiteren Snapshot aus dem Snapshot.  Wenn die urspr√ºngliche Unterwelt nicht gemountet und als normales Verzeichnis verwendet wurde, muss sie entweder gel√∂scht oder verschoben / umbenannt werden, und an ihrer Stelle sollte ein Snapshot platziert werden. <br><br><img src="https://habrastorage.org/webt/sn/os/od/snosodoezxac3a-2s7xzmpqa-js.png"><br><br>  In der Konsole k√∂nnte es ungef√§hr so ‚Äã‚Äãaussehen: <br><br><ul><li>  Benennen Sie den Subwolly um <br><br><pre> <code class="plaintext hljs">mv the_subvolume the_subvol.old</code> </pre> </li><li>  Setzen Sie seinen Schnappschuss anstelle des Subvolumens ein <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot the_snapshot the_subvolume</code> </pre> </li></ul><br>  Wenn das Subvolume √ºber den Mount-Punkt bereitgestellt und verwendet wurde, reicht es aus, das Subvolume zu entfernen und an seiner Stelle einen Snapshot bereitzustellen. <br><br><img src="https://habrastorage.org/webt/4z/mi/sw/4zmisws4w5keyk7mhsr6eaav-ri.png"><br><br><ul><li>  Nehmen Sie den Subwoofer ab <br><br><pre> <code class="plaintext hljs">umount /mnt/</code> </pre> </li><li>  Sie k√∂nnen einen Schnappschuss eines Schnappschusses erstellen, um die letzten √ºberlebenden Daten nicht zu verderben: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot /path/to/snapshot /path/to/snapshot_copy</code> </pre> </li><li>  Schnappschuss einbinden: <br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/snapshot_copy /mnt</code> </pre> </li></ul><br>  Der Vollst√§ndigkeit halber werde ich es noch einmal versuchen und etwas anders.  Das Subvolumen, in dem √Ñnderungen auftreten, ist der <i>Hauptzweig</i> . <br><br><img src="https://habrastorage.org/webt/gh/pt/m7/ghptm7ykmordfcur4bdddehng6c.jpeg"><br><br>  Beim Erstellen eines Snapshots wird der Status der Dateien auf der Festplatte festgelegt.  Von nun an ist ein Schnappschuss ein Brunch der Hauptniederlassung.  Alle weiteren √Ñnderungen an <i>main</i> wirken sich in keiner Weise auf den Schnappschuss aus.  Rollback auf Snapshot bedeutet, die Verwendung des <i>Hauptzweigs zu</i> beenden und vollst√§ndig auf Brunch umzuschalten.  Der <i>Hauptzweig</i> kann als unn√∂tig gel√∂scht werden.  Somit ist btrfs praktisch ein Versionskontrollsystem, jedoch ohne die M√∂glichkeit, Zweige wieder zusammenzuf√ºhren. <br><br><h1>  Dateisystembaum </h1><br>  Einer der nicht offensichtlichen Punkte bei der Verwendung von btrfs ist die Aufteilung der Systemdaten in Subvolumes.  Nat√ºrlich gibt es keinen ‚Äûrichtigen‚Äú Ansatz f√ºr dieses Problem.  Es gibt jedoch drei M√∂glichkeiten, die Struktur des Subvolumens zu organisieren: eine flache Struktur, verschachtelt und gemischt. <br><br>  Eine flache Struktur bedeutet, dass das Subvolumen in einer flachen Liste im Root-Subvolumen platziert wird.  Sie k√∂nnen beispielsweise das Stammverzeichnis des Dateisystems (nennen wir es <i>Stammverzeichnis</i> ), das Benutzerverzeichnis <i>home</i> , das Verzeichnis mit der Site <i>/ var / www</i> und die Datenbank, die sich beispielsweise in <i>/ var / database befindet,</i> als separate Subvolumes ausw√§hlen. <br><br><img src="https://habrastorage.org/webt/ga/yp/ma/gaypma96_mzvjtlwjyh3atw5qgm.png"><br><br>  Der Einfachheit halber kann ein Teilvolumen in Verzeichnissen abgelegt werden, wie beispielsweise im Fall des Teilvolumens <i>var / www</i> . <br><br>  Bei diesem Ansatz muss das gesamte Subvolumen bereitgestellt werden.  Das <i>Root-</i> Sub muss einen Mount-Punkt / haben und darin die Verzeichnisse <i>home</i> und <i>var enthalten</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Montage </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wurzel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ home</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muss sabvolyum installiert werden zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hause</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und im Verzeichnis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / databas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein e - sabvolyumy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenbank</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somit kann der Baum von btrfs-subvolume willk√ºrlich im virtuellen Dateisystem des Betriebssystems angezeigt werden, und daf√ºr gibt es bereits genug. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorteile:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Benutzer sieht nur das gemountete Subvolumen. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist einfach, den Subwoofer auszutauschen (einen abmontieren, den anderen montieren). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leicht zu entfernender Subwoofer. </font></font><br></li></ul><br>  Nachteile: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist leicht zu verwechseln, wo es installiert werden soll. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºr jedes Subvolume sollte ein Eintrag in fstab vorhanden sein. Wenn Snapshots ‚ÄûRollbacks‚Äú enthalten, m√ºssen auch die entsprechenden Eintr√§ge in fstab aktualisiert werden. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die verschachtelte Struktur des Subvolumes schl√§gt eine einfache Verwendung des Subvolumes anstelle einiger Verzeichnisse vor. </font></font><br><br><img src="https://habrastorage.org/webt/v2/41/e5/v241e5bwrguy3_f76frc2k3ygwk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall muss zus√§tzlich zum Root-Subvolume nichts mehr gemountet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorteile:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle Subvolumina sind sichtbar, die Struktur ist leicht wahrzunehmen, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie m√ºssen nichts erneut mounten, alles ist wie bei einem "normalen" Dateisystem. </font></font><br></li></ul><br>  Nachteile: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alle Subvolumes sind sichtbar, vielleicht m√∂chten sich einige vor dem Benutzer verstecken. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist schwierig, das Subwolum zu entfernen / zu ersetzen (der Grund daf√ºr sind verschachtelte Subw√∂lfe). </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, der dritte Ansatz ist gemischt. </font><font style="vertical-align: inherit;">Es beinhaltet eine Kombination der ersten beiden, um die Vorteile beider zu maximieren. </font><font style="vertical-align: inherit;">Es ist jedoch m√∂glich, dass dieser spezielle Ansatz zu einer komplexen, schwer zu √§ndernden, verwirrten Struktur mit einer gro√üen Anzahl von Eintr√§gen in fstab f√ºhrt. </font><font style="vertical-align: inherit;">Es h√§ngt alles von der </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√ºchternheit</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des Systemadministrators ab.</font></font><br><br><img src="https://habrastorage.org/webt/bv/qw/zv/bvqwzvl0wqspgvlaknnd3l9eyqo.png"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Festplatte hinzuf√ºgen / entfernen, ausgleichen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> btrfs bietet eine hervorragende Funktionalit√§t - die M√∂glichkeit, Hot-Block-Ger√§te direkt w√§hrend des Betriebs des Dateisystems hinzuzuf√ºgen: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device add /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oder l√∂schen: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device remove /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbrigens k√∂nnen Sie in einem Add / Delete-Aufruf mehrere Festplatten angeben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der angegebene Pfad ist wiederum der Pfad zu einem beliebigen Subvolume des BTRFS, auf das der Befehl angewendet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns √ºberpr√ºfen, wie viele und welche Blockger√§te von btrfs gesteuert werden:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem show /path/to/btrfs Label: none uuid: 52961dda-df84-4e2d-9727-e93e7738df81       Total devices 2 FS bytes used 192.00KiB       devid  1 size 20.00GiB used 132.00MiB path /dev/sdc       devid  2 size 50.00GiB used 0.00B path /dev/sdd</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,00B</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendeten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feld gibt an </font><font style="vertical-align: inherit;">, dass die hinzugef√ºgte Festplatte leer ist. Um es mit Daten gem√§√ü dem Aufzeichnungsprofil zu f√ºllen, m√ºssen Sie Folgendes ausgleichen:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Befehl </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verteilt Daten auf Datentr√§gern entsprechend dem ausgew√§hlten Aufzeichnungsprofil neu. Im Fall von RAID1 f√ºhrt der Saldo beispielsweise zum Klonen von Daten vom Originalger√§t, im Fall von RAID0 zu einer gleichm√§√üigeren Verteilung von Daten auf zwei Festplatten usw. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolge des Gleichgewichts werden die Daten auf der Platte dichter geschrieben, wenn zuvor Hohlr√§ume auf der Platte vorhanden waren, d. H. Defragmentierung wird sich herausstellen. Es ist jedoch wichtig zu verstehen, dass dies nicht genau ‚Äûdiese‚Äú Defragmentierung ist. In diesem Fall betrachtet der Befehl </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht den logischen Inhalt, sondern arbeitet nur mit Datenbl√∂cken. Sie achtet nicht darauf, dass eine Datei auf der Festplatte verteilt ist. Stattdessen </font><font style="vertical-align: inherit;">√ºbertr√§gt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenbl√∂cke von einem Ort zum anderen.</font></font> Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine zum Ausgleich fragmentierte Datei bleibt danach fragmentiert. </font></font> Aber!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Fragmentierung auf der Ebene der Datenbl√∂cke nimmt immer noch ab, und dies kann verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Verwirrung zu vermeiden, sagen wir Folgendes: Die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balance-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operation </font><font style="vertical-align: inherit;">reduziert die Fragmentierung auf der Ebene der Datenbl√∂cke, hat jedoch keinen Einfluss auf die Dateifragmentierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Befehl </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bietet auch die M√∂glichkeit, das Aufnahmeprofil zu √§ndern. </font><font style="vertical-align: inherit;">Beispielsweise wurde das DUP-Profil auf der Festplatte verwendet, und nach dem Hinzuf√ºgen der Festplatte wurde beschlossen, RAID1 vollst√§ndig zu erstellen. </font><font style="vertical-align: inherit;">Verwenden Sie dazu den Filter </font></font><code>convert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start -dconvert=raid1 -mconvert=raid1 /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit den Optionen </font></font><code>-dconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und werden </font></font><code>-mconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neue Datensatzprofile f√ºr Daten bzw. Metadaten festgelegt. </font><font style="vertical-align: inherit;">Es gibt auch die Option -sconvert, mit der das Systemdatenschreibprofil ge√§ndert werden kann. Sie m√ºssen jedoch auch den Schalter -f (--force) hinzuf√ºgen, um den Vorgang zu erzwingen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen besteht der Hauptzweck von Filtern darin, die Regeln f√ºr den Ausgleichsvorgang festzulegen: Welche Bl√∂cke m√ºssen verarbeitet und welche nicht ber√ºhrt werden. </font><font style="vertical-align: inherit;">So k√∂nnen Sie beispielsweise nur Bl√∂cke betreffen, die mit einem bestimmten Aufzeichnungsprofil (Filterprofile) aufgezeichnet wurden, oder Bl√∂cke, die √ºber einem bestimmten Prozentsatz belegt sind (Verwendungsfilter), oder nur Gruppen von Bl√∂cken, die sich auf eine bestimmte Festplatte beziehen (Devid-Filter) usw. </font><font style="vertical-align: inherit;">Sie k√∂nnen √ºbrigens noch kombiniert werden. </font><font style="vertical-align: inherit;">Im Allgemeinen sind die Funktionen von Filtern sehr umfangreich und haupts√§chlich f√ºr die Durchf√ºhrung eines selektiven Datenausgleichs erforderlich.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentierung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider ist btrfs aufgrund seiner Architektur √§u√üerst anf√§llig f√ºr Ph√§nomene wie Fragmentierung. </font><font style="vertical-align: inherit;">Tatsache ist, dass Daten immer an einen neuen Speicherort auf der Festplatte geschrieben werden. </font><font style="vertical-align: inherit;">Selbst wenn Sie die Datei lesen, nichts mit den Daten tun und sie in dieselbe Datei zur√ºckschreiben, werden die Daten in einen neuen Bereich auf der Festplatte verschoben. </font><font style="vertical-align: inherit;">Das gleiche passiert, wenn Sie die Daten in der Datei nur teilweise aktualisieren - die √Ñnderungen werden in einen neuen Bereich auf der Festplatte geschrieben. </font><font style="vertical-align: inherit;">Daher werden h√§ufige Fragmentdateien sehr stark ge√§ndert, wodurch die "Streuung" von Fragmenten im Allgemeinen √ºber mehrere Festplatten erh√∂ht wird. </font><font style="vertical-align: inherit;">Dies f√ºhrt zu einer erh√∂hten Belastung der CPU und einem unn√∂tigen Speicherverbrauch. </font><font style="vertical-align: inherit;">Am fragmentiertesten sind Datenbanken und Images von virtuellen Maschinen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen die </font><b><font style="vertical-align: inherit;">Dateifragmentierung</font></b><font style="vertical-align: inherit;"> mit dem Dienstprogramm </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filefrag auswerten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (nicht in btrfs-progs enthalten). </font></font><br><br><pre> <code class="plaintext hljs">filefrag /path/to/your/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es zeigt die Anzahl der zum Speichern der Datei verwendeten Speicherbereiche. </font><font style="vertical-align: inherit;">Einfach ausgedr√ºckt: Je weniger Extents beteiligt sind, desto weniger fragmentiert ist die Datei. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei Methoden, um die Fragmentierung von btrfs zu bek√§mpfen: die Defragmentierung und die Flagge </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Defragmentierung kann auf eine einzelne Datei oder auf ein Subvolume / Verzeichnis angewendet werden, auch rekursiv. </font><font style="vertical-align: inherit;">Der Befehl lautet wie folgt:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem defragment /path/to/file/or/dir</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich muss sagen, dass dieses Team nicht immer zu den erwarteten Ergebnissen f√ºhrt. </font><font style="vertical-align: inherit;">Kleine, leicht fragmentierte Dateien (10 - 20 Bereiche) nach der Defragmentierung k√∂nnen in noch mehr Teile aufgeteilt werden. </font><font style="vertical-align: inherit;">Dar√ºber hinaus unterbricht die Defragmentierung von btrfs in einigen Versionen des Kernels die Deduplizierung von Dateien und macht sie zu echten physischen Kopien.</font></font> Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schnappsch√ºsse auf physischer Ebene werden zu vollst√§ndigen Kopien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite M√∂glichkeit, die Fragmentierung zu bek√§mpfen, besteht in einem Dateiattribut </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="plaintext hljs">chattr +C /path/to/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Attribut </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nur auf eine neue oder leere Datei gesetzt werden. </font><font style="vertical-align: inherit;">Der Mechanismus zum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kopieren beim Schreiben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird deaktiviert </font><font style="vertical-align: inherit;">, sodass btrfs beim Aktualisieren des Inhalts einer Datei immer mit einem festen Festplattenbereich arbeitet und Daten √ºber vorhandene (auf physischer Ebene) schreibt. </font><font style="vertical-align: inherit;">Von den Minuspunkten von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nocow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird auch die √úberpr√ºfung der Pr√ºfsumme f√ºr diese Datei deaktiviert. </font><font style="vertical-align: inherit;">Mit anderen Worten, keine Kuh - keine Pr√ºfsumme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie das Attribut nat√ºrlich manuell ein</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Datei ist eine undankbare Aufgabe. Wenn dieses Flag des Verzeichnisses / Subvolumes gesetzt ist, erben alle darin erstellten neuen Dateien das Flag automatisch. Gleiches gilt f√ºr die erstellten verschachtelten Verzeichnisse. Wenn zu dem Zeitpunkt, als das Attribut aktiviert wurde, sich bereits Daten im Verzeichnis befanden, hat dies keine Auswirkungen auf sie. Das Attribut </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nur auf eine neue oder leere Datei festgelegt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere M√∂glichkeit, das Flag automatisch zu setzen, </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, das Dateisystem mit der folgenden Option bereitzustellen </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/subvol,nodatacow /dev/sdXX /path/to/mountpoint</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Option bewirkt, dass die Option automatisch eine Verbindung herstellt </font></font><code>nodatasum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass f√ºr neu erstellte Dateien keine Pr√ºfsummen berechnet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie √ºblich gibt es eine Nuance: Sie k√∂nnen nicht nur einen Subwoofer mit einer Option montieren </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Entweder hat jedes Subvolumen eine Option </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder keine. Alles wird vom ersten gemounteten Subvolume entschieden: Wenn eine Option angegeben wurde </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden alle nachfolgenden Mounts automatisch mit dieser Option ausgef√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein nicht offensichtlicher Moment tritt auf, wenn Sie eine Datei mit einem Flag versehen </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den Snapshot aus dem Subvolume entfernen, in dem sich diese Datei befindet. In diesem Fall ignoriert btrfs das Flag, </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn mehr als ein Subvolumen auf den aktualisierten Datenblock verweist. Daher trotz der Flagge</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Die Datei erbt sie √ºbrigens auch im Snapshot.) √Ñnderungen an den Dateien werden in einen neuen Bereich auf der Festplatte verschoben, und die Datei wird erneut fragmentiert. </font><font style="vertical-align: inherit;">Wenn der Datenblock in der Datei mehrmals aktualisiert wird, f√§llt er beim ersten Mal in einen neuen Bereich auf der Festplatte, und bei nachfolgenden Eintr√§gen wird er in diesem neuen Bereich "an Ort und Stelle" aktualisiert.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tricks und Misserfolge </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie btrfs-progs verwenden, k√∂nnen Sie den vollst√§ndigen Namen des Befehls weglassen: </font></font><br><br><pre> <code class="plaintext hljs">btrfs sub cre = btrfs subvolume create</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es reicht nur das Zusammentreffen der ersten Zeichen, die den Befehl eindeutig bestimmen: </font></font><br><br><pre> <code class="plaintext hljs">su = subvolume, fi = filesystem, ba = balance, de = device;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, das Prinzip ist klar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider kann btrfs keinen Snapshot des Verzeichnisses erstellen, aber es gibt eine Problemumgehung:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie ein Subvolume </font></font><br><br><pre> <code class="plaintext hljs">btrfs subvolume create ./subvol</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kopieren Sie Dateien aus dem Verzeichnis in das Subvolume: </font></font><br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always your/dir/. ./subvol</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schl√ºssel </font></font><code>reflink=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet den CoW-Mechanismus, d.h. </font><font style="vertical-align: inherit;">Die Daten werden nicht kopiert, aber Links zu ihnen werden auf einer niedrigen Ebene erstellt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt enth√§lt die Unterwelt alle Dateien, die sich im Verzeichnis befanden, und Sie k√∂nnen den Snapshot daraus entfernen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen das </font><font style="vertical-align: inherit;">Attribut nicht auf eine </font><font style="vertical-align: inherit;">vorhandene Datendatei festlegen. </font><font style="vertical-align: inherit;">Sie k√∂nnen jedoch den folgenden Weg gehen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leere Datei erstellen </font></font><br><br><pre> <code class="plaintext hljs">touch nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setze ihm eine Flagge </font></font><code>nocow</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordnen Sie Speicherplatz f√ºr eine neue Datei zu </font></font><br><br><pre> <code class="plaintext hljs">fallocate -l10g nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kopieren Sie den Inhalt einer vorhandenen Datei nach </font></font><br><br><pre> <code class="plaintext hljs">cp -v oldcowfile nocowfile</code> </pre> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn btrfs nicht mehr gen√ºgend Speicherplatz hat, kann selbst das L√∂schen einer Datei den Fehler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Kein Speicherplatz mehr auf dem Ger√§t"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verursachen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºr die L√∂sung wird empfohlen, ein tempor√§res Laufwerk mit einer Gr√∂√üe von vorzugsweise mindestens 1 GB an btrfs anzuschlie√üen. </font><font style="vertical-align: inherit;">Bereinigen Sie dann die Daten. </font><font style="vertical-align: inherit;">Entfernen Sie dann das tempor√§re Laufwerk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balance-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operation </font><font style="vertical-align: inherit;">, die ohne Angabe von Schreibprofilen aufgerufen wird, √§ndert sie implizit von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raid1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Was √ºbrigens auf der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gotchas-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seite steht </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies geschieht nach dem Hinzuf√ºgen der Festplatte zu btrfs, das das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dup-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schreibprofil verwendet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Denken Sie daran, dass beim Formatieren eines einzelnen Laufwerks in btrfs das </font><font style="vertical-align: inherit;">Standard- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dup-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Profil </font><font style="vertical-align: inherit;">f√ºr Metadaten und Systemdaten verwendet wird.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vielleicht das wichtigste </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie das Erstellen von Klonen von Blockger√§ten auf niedriger Ebene mit btrfs. Als ‚Äûintelligentes‚Äú Dateisystem liest btrfs bei einigen Vorg√§ngen (meistens beim Mounten) die Systemdaten auf Blockger√§ten erneut, um alle Teile des Dateisystems zu finden. Wenn im Suchvorgang zwei Blockger√§te mit denselben UUIDs gefunden werden, akzeptiert btrfs diese als Teil derselben Instanz. Wenn sich jedoch herausstellt, dass diese beiden Ger√§te das Original und sein Klon sind, wei√ü der Treiber nach dem Mounten allein, wie das Dateisystem funktioniert, aber es ist klar, dass dies nicht zu etwas Gutem f√ºhren wird. Im schlimmsten Fall f√ºhrt dies zu einer irreversiblen Datenbesch√§digung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Festplatten wirklich auf einfache Weise mit btrfs klonen m√∂chten, m√ºssen Sie √§u√üerst vorsichtig sein. </font><font style="vertical-align: inherit;">Im Allgemeinen sollte ein Klon f√ºr den Betriebssystemkern nicht als Blockger√§t sichtbar sein, solange das Original im System vorhanden ist, und umgekehrt. </font><font style="vertical-align: inherit;">Unter dieser Bedingung k√∂nnen Sie die UUID des Klons √§ndern (gut oder das Original, hier optional). </font><font style="vertical-align: inherit;">Das </font><font style="vertical-align: inherit;">mit dem Paket </font><b><font style="vertical-align: inherit;">btrfs-progs </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gelieferte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dienstprogramm </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune hilft dabei</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="plaintext hljs">btrfstune -u /path/to/device</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und noch einmal: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein ‚Äûintelligentes‚Äú Dienstprogramm, das die UUID nicht nur auf der Festplatte, sondern im gesamten Dateisystem √§ndert. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie beim Aufruf alle Blockger√§te liest, um die UUID auf allen Ger√§ten zu ersetzen, die sich auf das Dateisystem beziehen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstelle einer Schlussfolgerung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie in diesem Moment nichts verstehen, ist dies normal. Btrfs ist nicht trivial und erliegt m√∂glicherweise nicht sofort. Jedes Mal, wenn es mir so vorkam, als w√ºrde ich sie jetzt verstehen, warf sie eine √úberraschung und lie√ü sie bestehende Dinge √ºberdenken. Ich kann nicht sagen, dass ich im Moment alles verstanden habe - beim Schreiben habe ich etwas Neues gefunden, obwohl ich bereits aufgrund meiner Erfahrung geschrieben habe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich w√ºrde den Prozess des Mastering von btrfs mit dem √úbergang von einem prozeduralen Programmierstil zu einem objektorientierten vergleichen. Der erste Eindruck ist "Wow, wie gro√üartig", aber dann schreiben Sie beharrlich weiterhin prozeduralen Code, der in Klassen eingeschlossen ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dem Artikel habe ich versucht, kein Wasser zu gie√üen - um alles √ºber den Fall zu schreiben. </font><font style="vertical-align: inherit;">Trotzdem stellte sich heraus, dass es ziemlich umfangreich war. </font><font style="vertical-align: inherit;">Aber bei weitem nicht alles war zu sagen - man kann immer noch √ºber btrfs schreiben und schreiben. </font><font style="vertical-align: inherit;">Dieser Artikel ist nur die Spitze des Eisbergs. </font><font style="vertical-align: inherit;">Der Anfang besteht darin, seine Philosophie zu verstehen und sie zu nutzen. </font><font style="vertical-align: inherit;">Und jetzt ist es Zeit zu enden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank f√ºr das Lesen bis zum Ende. </font><font style="vertical-align: inherit;">Ich hoffe nicht m√ºde. </font><font style="vertical-align: inherit;">Schreiben Sie in die Kommentare, was Sie sonst noch wissen m√∂chten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen Sie Backups, meine Herren. </font><font style="vertical-align: inherit;">Und lassen Sie sie nie n√ºtzlich sein.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458250/">https://habr.com/ru/post/de458250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458240/index.html">Wie k√ºnstliche Intelligenz, Drohnen und Kameras die Sicherheit von Stra√üen und Br√ºcken gew√§hrleisten</a></li>
<li><a href="../de458242/index.html">Der neue Raumschiffoperator in C ++ 20</a></li>
<li><a href="../de458244/index.html">Eine endlose und l√§cherliche Liste dessen, was Sie wissen m√ºssen, um √∂ffentliche Wi-Fi-Netzwerke sicher nutzen zu k√∂nnen</a></li>
<li><a href="../de458246/index.html">Zuf√§llige Zuf√§lle im Leben oder wie sich herausstellte, dass Ihnen in einer Traktorenfabrik ein Kuchen pr√§sentiert wurde</a></li>
<li><a href="../de458248/index.html">Vereinfachen Sie Ihren Code mit Rocket Science: C ++ 20s Raumschiff-Operator</a></li>
<li><a href="../de458252/index.html">Mathematisches Modell eines superlangen Radioteleskops</a></li>
<li><a href="../de458256/index.html">Ist es nicht Zeit f√ºr eine Gehirnw√§sche?</a></li>
<li><a href="../de458260/index.html">Eine andere M√∂glichkeit, Docker-Images f√ºr Java-Anwendungen zu optimieren</a></li>
<li><a href="../de458262/index.html">Online-Designer des Besprechungsraums - Auswahl der optimalen L√∂sung f√ºr die Videokonferenz</a></li>
<li><a href="../de458264/index.html">10 Prinzipien des selbstdokumentierenden Codes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>