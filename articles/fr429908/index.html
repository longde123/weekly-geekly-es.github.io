<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêê üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üë®üèø‚Äçüç≥ Comment utiliser les coroutines dans les aliments et dormir paisiblement la nuit üë®üèº‚Äçü§ù‚Äçüë®üèª üèÅ üë©üèæ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les coroutines sont un outil puissant pour l'ex√©cution de code asynchrone. Ils travaillent en parall√®le, communiquent entre eux et consomment peu de r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment utiliser les coroutines dans les aliments et dormir paisiblement la nuit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/429908/">  Les coroutines sont un outil puissant pour l'ex√©cution de code asynchrone.  Ils travaillent en parall√®le, communiquent entre eux et consomment peu de ressources.  Il semblerait que sans crainte, les coroutines puissent √™tre introduites en production.  Mais il y a des peurs et elles interf√®rent. <br><br>  <strong>Le rapport de Vladimir Ivanov</strong> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a> concerne le fait que le diable n'est pas si terrible et que vous pouvez utiliser des coroutines d√®s maintenant: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pourquoi coroutines, pas RxJava</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les craintes qui g√™nent les d√©veloppeurs</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment cr√©er un cache en utilisant des coroutines</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment g√©rer correctement les erreurs</a> . </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1lEG1CPkRaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√Ä propos du conf√©rencier</strong> : Vladimir Ivanov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">dzigoro</a> ) est un d√©veloppeur Android de premier plan √† <strong>EPAM</strong> avec 7 ans d'exp√©rience, aime l'architecture de solutions, React Native et le d√©veloppement iOS, et a √©galement la certification <strong>Google Cloud Architect</strong> . <br><a name="habracut"></a><br><blockquote>  Tout ce que vous lisez est un produit de la production d'exp√©rience et d'√©tudes diverses, alors prenez-le tel quel, sans aucune garantie. <br></blockquote><h2><a name="coroutine"></a>  Coroutines, Kotlin et RxJava </h2><br>  Pour information: l'√©tat actuel de la corutine est dans la version, √† gauche Beta.  <strong>Kotlin 1.3</strong> est sorti, les coroutines sont d√©clar√©es stables et il y a la paix dans le monde. <br><br><img src="https://habrastorage.org/webt/it/jm/db/itjmdbtgjewt6v1kihv_5urqxie.png"><br><br>  J'ai r√©cemment men√© une enqu√™te sur Twitter aupr√®s des utilisateurs de coroutine: <br><br><ul><li>  13% des coroutines dans les aliments.  Tout va bien; </li><li>  25% les essaient dans le projet pour animaux de compagnie; </li><li>  24% - Qu'est-ce que Kotlin? </li><li>  La majeure partie de 38% de RxJava est partout. </li></ul><br>  Les statistiques ne sont pas heureuses.  Je pense que <strong>RxJava est un outil trop complexe</strong> pour les t√¢ches dans lesquelles il est couramment utilis√© par les d√©veloppeurs.  Les coroutines conviennent mieux pour contr√¥ler le fonctionnement asynchrone. <br><br>  Dans mes rapports pr√©c√©dents, j'ai parl√© de la refonte de RxJava vers les coroutines de Kotlin, donc je ne m'attarderai pas l√†-dessus en d√©tail, mais je ne ferai que rappeler les principaux points. <br><br><h3>  Pourquoi utilisons-nous des coroutines? </h3><br>  Parce que si nous utilisons RxJava, les exemples d'impl√©mentation habituels ressemblent √† ceci: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClientRx</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;GithubUser&gt; fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;List&lt;GithubRepository&gt;&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//RxJava 2 implementation</span></span></span></span></code> </pre> <br>  Nous avons une interface, par exemple, nous √©crivons un client GitHub et voulons effectuer quelques op√©rations pour cela: <br><br><ol><li>  Utilisateur de connexion. <br></li><li>  Obtenez une liste des r√©f√©rentiels GitHub. <br></li></ol><br>  Dans les deux cas, les fonctions renverront des objets m√©tier simples: GitHubUser ou une liste de GitHubRepository. <br><br>  Le code d'impl√©mentation de cette interface est le suivant: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) compositeDisposable.add(apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } )) }</code> </pre><br>  - Nous prenons <strong>compositeDisposable</strong> pour qu'il n'y ait pas de fuite m√©moire. <br>  - Ajoutez un appel √† la premi√®re m√©thode. <br>  - Nous utilisons des op√©rateurs pratiques pour obtenir l'utilisateur, par exemple <strong>flatMap</strong> . <br>  - Nous obtenons une liste de ses r√©f√©rentiels. <br>  - Nous √©crivons une <strong>Boilerplate</strong> pour qu'elle <strong>fonctionne</strong> sur les bons threads. <br>  - Lorsque tout est pr√™t, nous affichons la liste des r√©f√©rentiels pour l'utilisateur connect√©. <br><br>  <strong>Difficult√©s du code RxJava:</strong> <br><br><ul><li>  <strong>La complexit√©</strong>  √Ä mon avis, le code est trop compliqu√© pour la simple t√¢che de deux appels r√©seau et d'afficher quelque chose sur l' <strong>interface utilisateur</strong> . </li><li>  <strong>Traces de pile non li√©es.</strong>  Les traces de pile ne sont presque pas li√©es au code que vous √©crivez. </li><li>  <strong>D√©passement des ressources</strong> <strong>.</strong>  RxJava g√©n√®re beaucoup d'objets sous le capot et les performances peuvent diminuer. </li></ul><br>  <strong>Quel sera le m√™me code avec les coroutines jusqu'√† la version 0.26?</strong> <br><br>  √Ä 0,26, l'API a chang√© et nous parlons de production.  Personne n'a encore r√©ussi √† appliquer 0,26 dans la prod, mais nous y travaillons. <br><br>  <strong>Avec les coroutines, notre interface va changer de fa√ßon assez importante</strong> .  Les fonctions cesseront de renvoyer les simples et autres objets d'assistance.  Ils renverront imm√©diatement des objets m√©tier: GitHubUser et une liste de GitHubRepository.  Les fonctions GitHubUser et GitHubRepository auront des modificateurs de <strong>suspension</strong> .  C'est bien, car suspendre ne nous oblige presque √† rien: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : GithubUser suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : List&lt;GithubRepository&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Base interface</span></span></span></span></code> </pre><br>  Si vous regardez le code qui utilise d√©j√† l'impl√©mentation de cette interface, il changera consid√©rablement par rapport √† RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLogin</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { val auth = BasicAuthorization(login, pass) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) val userlnfo = async { apiClient.login(auth) }.await() val repoUrl = userlnfo.repos_url val list = async { apiClient.getRepositories(repoUrl, auth) }.await() showRepositories( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list.map { it -&gt; it.full_name } ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: RuntimeException) { showToast(<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } } }</code> </pre><br>  - L'action principale a lieu o√π nous appelons <strong>async coroutine builder</strong> , attendons une r√©ponse et obtenons <strong>userlnfo</strong> . <br>  - Nous utilisons les donn√©es de cet objet. <br>  - Effectuez un autre appel <strong>asynchrone</strong> et appelez en <strong>attente</strong> . <br><br>  Tout semble comme si aucun travail asynchrone ne se passait, et nous √©crivons simplement les commandes dans la colonne et elles sont ex√©cut√©es.  En fin de compte, nous faisons ce qui doit √™tre fait sur l'interface utilisateur. <br><br>  <strong>Pourquoi les coroutines sont-elles meilleures?</strong> <br><br><ul><li>  Ce code est plus facile √† lire.  Il est √©crit comme s'il √©tait coh√©rent. </li><li>  Tr√®s probablement, les performances de ce code sont meilleures que sur RxJava. </li><li>  Il est tr√®s simple d'√©crire des tests, mais nous y reviendrons un peu plus tard. </li></ul><br><h2>  2 marches sur le c√¥t√© <br></h2><br>  √âcartons-nous un peu, il y a encore quelques points √† discuter. <br><br><h3>  √âtape 1. withContext vs launch / async <br></h3><br>  En plus de <strong>coroutine builder async,</strong> il existe <strong>coroutine builder withContext</strong> . <br><br>  <strong>Lancez</strong> ou <strong>async</strong> cr√©ez un nouveau <strong>contexte Coroutine</strong> , ce qui n'est pas toujours n√©cessaire.  Si vous avez un contexte Coroutine que vous souhaitez utiliser dans l'application, vous n'avez pas besoin de le recr√©er.  Vous pouvez simplement r√©utiliser un existant.  Pour ce faire, vous aurez besoin d'un g√©n√©rateur de coroutine avec Context.  Il r√©utilise simplement le contexte Coroutine existant.  Ce sera 2-3 fois plus rapide, mais maintenant c'est une question sans principes.  Si les chiffres exacts sont int√©ressants, alors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici la question</a> sur <strong>stackoverflow</strong> avec des rep√®res et des d√©tails. <br><br><blockquote>  <strong>R√®gle g√©n√©rale:</strong> utilisez withContext sans aucun doute l√† o√π il tient s√©mantiquement.  Mais si vous avez besoin d'un chargement parall√®le, par exemple plusieurs images ou √©l√©ments de donn√©es, alors async / wait est votre choix. <br></blockquote><br><h3>  √âtape 2. Refactoring <br></h3><br>  Et si vous refactorisez une cha√Æne RxJava vraiment complexe?  Je suis tomb√© sur cela en production: <br><br><pre> <code class="java hljs">observable1.getSubject().zipWith(observable2.getSubject(), (t1, t2) -&gt; { <span class="hljs-comment"><span class="hljs-comment">// side effects return true; }).doOnError { // handle errors } .zipWith(observable3.getSubject(), (t3, t4) -&gt; { // side effects return true; }).doOnComplete { // gather data } .subscribe()</span></span></code> </pre><br>  J'avais une cha√Æne compliqu√©e avec un <strong>sujet public</strong> , avec des <strong>fermetures</strong> √† <strong>glissi√®re</strong> et <strong>des</strong> <strong>effets secondaires</strong> dans chaque <strong>fermeture √©clair</strong> qui envoyaient autre chose au bus de l'√©v√©nement.  La t√¢che au moins √©tait de se d√©barrasser du bus d'√©v√©nement.  Je me suis assis pendant une journ√©e, mais je n'ai pas pu refactoriser le code pour r√©soudre le probl√®me.  <strong>La bonne d√©cision s'est av√©r√©e de tout jeter et de r√©√©crire le code sur coroutine en 4 heures</strong> . <br><br>  Le code ci-dessous est tr√®s similaire √† ce que j'ai obtenu: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val firstChunkJob = async { call1 } val secondChunkJob = async { call2 } val thirdChunkJob = async { call3 } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( firstChunkJob.await(), secondChunkJob.await(), thirdChunkJob.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-comment"><span class="hljs-comment">// handle errors }</span></span></code> </pre><br>  - Nous faisons async pour une t√¢che, pour les deuxi√®me et troisi√®me. <br>  - Nous attendons le r√©sultat et mettons tout cela dans un objet. <br>  - C'est fait! <br><br>  Si vous avez des cha√Ænes complexes et qu'il y a des coroutines, alors refactorisez simplement.  C'est vraiment rapide. <br><br><h2><a name="fear"></a>  Qu'est-ce qui emp√™che les d√©veloppeurs d'utiliser des coroutines dans prod? <br></h2><br>  √Ä mon avis, en tant que d√©veloppeurs, nous ne sommes actuellement emp√™ch√©s d'utiliser des coroutines que par crainte de quelque chose de nouveau: <br><br><ul><li>  Nous ne savons pas quoi faire du <strong>cycle</strong> de <strong>vie</strong> , de l' <strong>activit√©</strong> et du cycle de vie des fragments.  Comment travailler avec des coroutines dans ces cas? </li><li>  Il n'y a aucune exp√©rience dans la r√©solution de t√¢ches complexes quotidiennes en production √† l'aide de corutine. </li><li>  Pas assez d'outils.  Un tas de biblioth√®ques et de fonctions ont √©t√© √©crites pour RxJava.  Par exemple <strong>RxFCM</strong> .  RxJava lui-m√™me a beaucoup d'op√©rateurs, ce qui est bien, mais qu'en est-il de la coroutine? </li><li>  Nous ne comprenons pas vraiment comment tester les coroutines. </li></ul><br><blockquote>  Si nous nous d√©barrassons de ces quatre peurs, nous pouvons dormir paisiblement la nuit et utiliser des coroutines en production. <br></blockquote><br>  Voyons point par point. <br><br><h3>  1. Gestion du cycle de vie <br></h3><br><ul><li>  Les coroutines peuvent fuir comme <strong>jetables</strong> ou <strong>AsyncTask</strong> .  Ce probl√®me doit √™tre r√©solu manuellement. </li><li>  Pour √©viter une <strong>exception de pointeur nul</strong> al√©atoire <strong>, les</strong> coroutines doivent √™tre arr√™t√©es. </li></ul><br><h4>  Arr√™ter <br></h4><br>  Connaissez-vous <strong>Thread.stop ()</strong> ?  Si vous l'avez utilis√©, alors pas pour longtemps.  Dans <strong>JDK 1.1, la</strong> m√©thode a √©t√© imm√©diatement d√©clar√©e obsol√®te, car il est impossible de prendre et d'arr√™ter un certain morceau de code et il n'y a aucune garantie qu'il se terminera correctement.  Tr√®s probablement, vous n'obtiendrez que <strong>la corruption de m√©moire</strong> . <br><br>  Par cons√©quent, <strong>Thread.stop () ne fonctionne pas</strong> .  Vous avez besoin que l'annulation soit coop√©rative, c'est-√†-dire le code de l'autre c√¥t√© pour savoir que vous l'annulez. <br><br>  Comment appliquons-nous les arr√™ts avec RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val compositeDisposable = CompositeDisposable() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.add( apiClientRx.requestSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(result -&gt; {}) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.dispose() }</code> </pre><br><br>  Dans RxJava, nous <strong>utilisons CompositeDisposable</strong> . <br><br>  - Ajoutez la variable <strong>compositeDisposable</strong> √† l'activit√© dans le fragment ou dans le pr√©sentateur, o√π nous utilisons RxJava. <br>  - Dans <strong>onDestro</strong> y ajoutez <strong>Dispose</strong> et toutes les exceptions disparaissent d'elles-m√™mes. <br><br>  Environ le m√™me principe avec les coroutines: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: Job? = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI) { val user = apiClient.requestSomething() ‚Ä¶ } } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job?.cancel() }</code> </pre><br>  Prenons un exemple de <strong>t√¢che simple</strong> . <br><br>  En r√®gle g√©n√©rale, <strong>les constructeurs de coroutine</strong> renvoient un <strong>travail</strong> et, dans certains cas, sont <strong>report√©s</strong> . <br><br>  - Nous pouvons m√©moriser ce travail. <br>  - Donnez la commande <strong>"lancer" le</strong> <strong>g√©n√©rateur de coroutine</strong> .  Le processus d√©marre, quelque chose se passe, le r√©sultat de l'ex√©cution est m√©moris√©. <br>  - Si nous ne transmettons rien d'autre, alors ¬´lancer¬ª d√©marre la fonction et nous renvoie un lien vers le travail. <br>  - Le travail est m√©moris√©, et dans onDestroy, nous disons <strong>¬´annuler¬ª</strong> et tout fonctionne bien. <br><br>  <strong>Quel est le probl√®me de l'approche?</strong>  Chaque travail a besoin d'un champ.  Vous devez conserver une liste des travaux pour les annuler tous ensemble.  L'approche conduit √† la duplication de code, ne le faites pas. <br><br>  La bonne nouvelle, c'est que nous avons des <strong>alternatives</strong> : <strong>CompositeJob</strong> et <strong>Lifecycle job</strong> . <br><br>  CompositeJob est un analogue de compositeDisposable.  Cela ressemble √† ceci <strong>:</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: CompositeJob = CompositeJob() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.add(launch(UI) { val user = apiClient.requestSomething() ... }) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.cancel() }</code> </pre><br>  - Pour un fragment, nous commen√ßons un travail. <br>  - Nous mettons tout le <strong>travail</strong> dans CompositeJob et donnons la commande: <strong>"job.cancel () pour tout le monde!"</strong>  . <br><br>  L'approche est facilement impl√©ment√©e en 4 lignes, sans compter la d√©claration de classe: <br><br><pre> <code class="java hljs">Class CompositeJob { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val map = hashMapOf&lt;String, Job&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(job: Job, key: String = job.hashCode()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span></span>= map.put(key, job)?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String)</span></span></span><span class="hljs-function"> </span></span>= map[key]?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= map.forEach { _ ,u -&gt; u.cancel() } }</code> </pre><br><br>  Vous aurez besoin de: <br><br>  - <strong>carte</strong> avec une cl√© de cha√Æne, <br>  - <strong>ajouter une</strong> m√©thode, dans laquelle vous ajouterez un travail, <br>  - param√®tre <strong>cl√©</strong> facultatif. <br><br>  Si vous souhaitez utiliser la m√™me cl√© pour le m√™me travail, veuillez.  Sinon, <strong>hashCode</strong> r√©soudra notre probl√®me.  Ajoutez le travail √† la carte que nous avons pass√©e et annulez le pr√©c√©dent avec la m√™me cl√©.  Si nous remplissons trop la t√¢che, le r√©sultat pr√©c√©dent ne nous int√©resse pas.  Nous l'annulons et le conduisons √† nouveau. <br><br>  L'annulation est simple: nous obtenons le travail par cl√© et l'annulons.  La deuxi√®me annulation pour la carte enti√®re annule tout.  Tout le code est √©crit en une demi-heure sur quatre lignes et cela fonctionne.  Si vous ne voulez pas √©crire, prenez l'exemple ci-dessus. <br><br><h4>  Travail adapt√© au cycle de vie </h4><br>  Avez-vous utilis√© <strong>Android Lifecycle</strong> , <strong>propri√©taire</strong> ou <strong>observateur de</strong> <strong>Lifecycle</strong> ? <br><img src="https://habrastorage.org/webt/ud/pi/eq/udpieqn_xba30yasl2buwbs2bay.png"><br><br>  Notre <strong>activit√©</strong> et nos <strong>fragments</strong> ont certains √©tats.  Faits saillants: <strong>cr√©√©,</strong> <strong>d√©marr√©</strong> et <strong>repris</strong> .  Il existe diff√©rentes transitions entre les √âtats.  <strong>LifecycleObserver</strong> vous permet de vous abonner √† ces transitions et de faire quelque chose lorsqu'une des transitions se produit. <br><br>  Cela semble assez simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObserver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_RESUME) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_PAUSE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre><br>  Vous raccrochez l'annotation avec un param√®tre sur la m√©thode, et elle est appel√©e avec la transition correspondante.  Utilisez simplement cette approche pour coroutine: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidJob</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lifecycle</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ init { lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_DESTROY) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.d(<span class="hljs-string"><span class="hljs-string">"AndroidJob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cancelling a coroutine"</span></span>) cancel() } }</code> </pre><br>  - Vous pouvez √©crire la classe de base <strong>AndroidJob</strong> . <br>  - Nous transf√©rerons le <strong>cycle de vie √† la</strong> classe. <br>  - L'interface <strong>LifecycleObserver</strong> impl√©mentera le travail. <br><br>  Tout ce dont nous avons besoin: <br><br>  - Dans le constructeur, ajoutez √† Lifecycle en tant qu'observateur. <br>  - Abonnez-vous √† <strong>ON_DESTROY</strong> ou √† toute autre chose qui nous int√©resse. <br>  - Faire annuler dans ON_DESTROY. <br>  - <strong>Obtenez</strong> un <strong>parentJob</strong> dans votre fragment. <br>  - Appelez le constructeur <strong>Joy jobs</strong> ou le <strong>cycle de vie de</strong> votre fragment d'activit√©.  Aucune diff√©rence. <br>  - Passez ce <strong>parentJob en</strong> tant que <strong>parent</strong> . <br><br>  Le code fini ressemble √† ceci: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentJob = AndroidJob(lifecycle) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI, parent = parentJob) { <span class="hljs-comment"><span class="hljs-comment">// code } }</span></span></code> </pre><br>  Lorsque vous annulez parent, toutes les coroutines enfant sont annul√©es et vous n'avez plus besoin d'√©crire quoi que ce soit dans le fragment.  Tout se passe automatiquement, plus ON_DESTROY.  L'essentiel <strong>,</strong> n'oubliez pas de passer <strong>parent = parentJob</strong> . <br><br><blockquote>  Si vous utilisez, vous pouvez √©crire une r√®gle de charpie simple qui vous mettra en √©vidence: "Oh, vous avez oubli√© votre parent!" <br></blockquote><br>  Avec <strong>&nbsp;</strong>  Gestion de cycle de vie tri√©e.  Nous avons quelques outils qui vous permettent de faire tout cela facilement et confortablement. <br><br>  Qu'en est-il des sc√©narios complexes et des t√¢ches non triviales en production? <br><br><h3>  2. Cas d'utilisation complexes <br></h3><br>  Les sc√©narios complexes et les t√¢ches non triviales sont: <br><br>  - <strong>Op√©rateurs</strong> - op√©rateurs complexes dans RxJava: flatMap, debounce, etc. <br>  - <strong>Gestion</strong> des erreurs <strong>- gestion</strong> des erreurs complexes.  Pas seulement <strong>try..catch</strong> , mais imbriqu√© par exemple. <br>  - La <strong>mise en cache</strong> <strong>est une</strong> t√¢che non triviale.  En production, nous avons rencontr√© un cache et voulions obtenir un outil pour r√©soudre facilement le probl√®me de mise en cache avec les coroutines. <br><br><h4>  R√©p√©ter </h4><br>  Quand nous avons pens√© aux op√©rateurs pour coroutine, la premi√®re option √©tait <strong>repeatWhen ()</strong> . <br><br>  Si quelque chose s'est mal pass√© et que Corutin n'a pas pu atteindre le serveur √† l'int√©rieur, nous voulons r√©essayer plusieurs fois avec une sorte de repli exponentiel.  La raison est peut-√™tre une mauvaise connexion et nous obtiendrons le r√©sultat souhait√© en r√©p√©tant l'op√©ration plusieurs fois. <br><br>  Avec les coroutines, cette t√¢che est facilement impl√©ment√©e: <br><br><pre> <code class="java hljs">suspend fun &lt;T&gt; retryDeferredWithDelay( deferred: () -&gt; Deferred&lt;T&gt;, tries: Int = <span class="hljs-number"><span class="hljs-number">3</span></span>, timeDelay: Long = <span class="hljs-number"><span class="hljs-number">1000L</span></span> ): T { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1</span></span>..tries) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred().await() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; tries) delay(timeDelay) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException() }</code> </pre><br><br>  Impl√©mentation de l'op√©rateur: <br><br>  - Il prend <strong>diff√©r√©</strong> . <br>  - Vous devrez appeler <strong>async</strong> pour obtenir cet objet. <br>  - Au lieu de <strong>diff√©r√©,</strong> vous pouvez passer √† la fois un bloc de suspension et g√©n√©ralement n'importe quelle <strong>fonction de suspension.</strong> <br>  - La boucle <strong>for</strong> - vous attendez le r√©sultat de votre coroutine.  Si quelque chose se produit et que le compteur de r√©p√©tition n'est pas √©puis√©, r√©essayez via <strong>Delay</strong> .  Sinon, alors non. <br><br>  La fonction peut √™tre facilement personnalis√©e: mettez un retard exponentiel ou passez une fonction lambda qui calculera le retard en fonction des circonstances. <br><br>  Utilisez-le, cela fonctionne! <br><br><h4>  Zips </h4><br>  On les rencontre aussi souvent.  L√† encore, tout est simple: <br><br><pre> <code class="java hljs">suspend fun &lt;T1, T2, R&gt; zip( source1: Deferred&lt;T1&gt;, source2: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zipper.apply(sourcel.await(), source2.await()) } suspend fun &lt;T1, T2, R&gt; Deferred&lt;T1&gt;.zipWith( other: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other, zipper) }</code> </pre><br>  - Utilisez la <strong>fermeture √©clair</strong> et appelez en attente sur votre diff√©r√©. <br>  - Au lieu de diff√©r√©, vous pouvez utiliser la fonction de suspension et le g√©n√©rateur de coroutine avec withContext.  Vous transmettrez le contexte dont vous avez besoin. <br><br>  Cela fonctionne √† nouveau et j'esp√®re avoir supprim√© cette peur. <br><br><a name="cache"></a><h3>  Cache </h3><br><br>  Avez-vous une impl√©mentation de cache en production avec RxJava?  Nous utilisons RxCache. <br><img src="https://habrastorage.org/webt/tz/ym/tn/tzymtn1tykponnxcmz0qqi_qjmi.png"><br><br>  Dans le diagramme de gauche: <strong>View</strong> et <strong>ViewModel</strong> .  √Ä droite, les sources de donn√©es: les appels r√©seau et la base de donn√©es. <br><br>  Si nous voulons que quelque chose soit mis en cache, le cache sera une autre source de donn√©es. <br><br>  Types de cache: <br><br><ul><li>  <strong>Source</strong> r√©seau pour les appels r√©seau. </li><li>  <strong>Cache en m√©moire</strong> . </li><li>  <strong>Cache persistant</strong> avec expiration √† stocker sur le disque afin que le cache survive au red√©marrage de l'application. </li></ul><br>  √âcrivons un <strong>cache</strong> simple et primitif pour le troisi√®me cas.  Le constructeur de Coroutine withContext vient √† la rescousse. <br><br><pre> <code class="java hljs">launch(UI) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = withContext(dispatcher) { persistence.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { memory.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { network.getData() } memory.cache(url, data) persistence.cache(url, data) } } }</code> </pre><br>  - Vous ex√©cutez chaque op√©ration avec withContext et voyez si des donn√©es arrivent. <br>  - Si les donn√©es de <strong>persistance</strong> ne viennent pas, vous essayez de les obtenir √† partir de <strong>memory.cache</strong> . <br>  - S'il n'y a pas non plus de memory.cache, contactez la <strong>source r√©seau</strong> et r√©cup√©rez vos donn√©es.  N'oubliez pas, bien s√ªr, de mettre toutes les caches. <br><br>  Il s'agit d'une impl√©mentation plut√¥t primitive et il y a beaucoup de questions, mais la m√©thode fonctionne si vous avez besoin d'un cache au m√™me endroit.  Pour les t√¢ches de production, ce cache n'est pas suffisant.  Il faut quelque chose de plus compliqu√©. <br><br><h4>  Rx a RxCache </h4><br>  Pour ceux qui utilisent encore RxJava, vous pouvez utiliser RxCache.  Nous l'utilisons toujours aussi.  <strong>RxCache</strong> est une biblioth√®que sp√©ciale.  Vous permet de mettre en cache des donn√©es et de g√©rer son cycle de vie. <br><br>  Par exemple, vous voulez dire que ces donn√©es expireront apr√®s 15 minutes: "S'il vous pla√Æt, apr√®s cette p√©riode de temps, n'envoyez pas de donn√©es depuis le cache, mais envoyez-moi de nouvelles donn√©es." <br><br>  La biblioth√®que est merveilleuse en ce qu'elle soutient d√©clarativement l'√©quipe.  La d√©claration est tr√®s similaire √† ce que vous faites avec <strong>Retrofit</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureConfigCacheProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ProviderKey</span></span>(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@LifeCache</span></span>(duration = <span class="hljs-number"><span class="hljs-number">15</span></span>, timeUnit = TimeUnit.MINUTES) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( result: Observable&lt;Features&gt;, cacheName: DynamicKey )</span></span></span><span class="hljs-function">: Observable&lt;Reply&lt;Features&gt;&gt; }</span></span></code> </pre><br>  - Vous dites que vous avez un <strong>CacheProvider</strong> . <br>  - D√©marrez une m√©thode et dites que la <strong>dur√©e de</strong> vie de <strong>LifeCache est de</strong> 15 minutes.  La cl√© par laquelle il sera disponible est <strong>Fonctionnalit√©s</strong> . <br>  - Renvoie <strong>Observable &lt;Reply</strong> , o√π <strong>Reply</strong> est un objet de biblioth√®que auxiliaire pour travailler avec le cache. <br><br>  L'utilisation est assez simple: <br><br><pre> <code class="java hljs">val restObservable = configServiceRestApi.getFeatures() val features = featureConfigCacheProvider.getFeatures( restObservable, DynamicKey(CACHE_KEY) )</code> </pre><br>  - Depuis le cache Rx, acc√©dez √† <strong>RestApi</strong> . <br>  - <strong>Tournez-vous</strong> vers <strong>CacheProvider</strong> . <br>  - Nourrissez-le d'un observable. <br>  - La biblioth√®que elle-m√™me saura quoi faire: allez dans le cache ou non, si le temps est √©coul√©, tournez-vous vers <strong>Observable</strong> et effectuez une autre op√©ration. <br><br>  L'utilisation de la biblioth√®que est tr√®s pratique et j'aimerais en obtenir une similaire pour coroutine. <br><br><h4>  Coroutine Cache en d√©veloppement </h4><br>  Dans EPAM, nous √©crivons la biblioth√®que <strong>Coroutine Cache</strong> , qui ex√©cutera toutes les fonctions de RxCache.  Nous avons √©crit la premi√®re version et l'avons ex√©cut√©e au sein de l'entreprise.  D√®s la sortie de la premi√®re version, je me ferai un plaisir de la publier sur mon Twitter.  Cela ressemblera √† ceci: <br><br><pre> <code class="java hljs">val restFunction = configServiceRestApi.getFeatures() val features = withCache(CACHE_KEY) { restFunction() }</code> </pre><br>  Nous aurons une fonction suspendre <strong>getFeatures</strong> .  Nous passerons la fonction sous forme de bloc √† une fonction sp√©ciale d'ordre sup√©rieur avec <strong>Cache</strong> , qui <strong>d√©terminera</strong> ce qui doit √™tre fait. <br><br>  Peut-√™tre ferons-nous la m√™me interface pour prendre en charge les fonctions d√©claratives. <br><br><a name="err"></a><h3>  Gestion des erreurs <br></h3><br><img src="https://habrastorage.org/webt/sd/qq/uc/sdqqucxxckqchfozdoknxa3vi-k.png"><br><br>  La gestion simple des erreurs est souvent trouv√©e par les d√©veloppeurs et est g√©n√©ralement r√©solue assez simplement.  Si vous n'avez pas de choses compliqu√©es, alors dans catch vous attrapez l' <strong>exception</strong> et regardez ce qui s'est pass√© l√†-bas, √©crivez dans le journal ou affichez une erreur √† l'utilisateur.  Sur l'interface utilisateur, vous pouvez facilement le faire. <br><br>  Dans les cas simples, tout est normalement simple - la gestion des erreurs avec les coroutines se fait via <strong>try-catch-finally</strong> . <br><br>  En production, en plus des cas simples, il y a: <br><br>  - Try <strong>-catch</strong> imbriqu√©, <br>  - De nombreux types d' <strong>exceptions</strong> , <br>  - Erreurs dans le r√©seau ou dans la logique m√©tier, <br>  - Erreurs utilisateur.  Il a de nouveau fait quelque chose de mal et √©tait √† bl√¢mer pour tout. <br><br>  Nous devons nous y pr√©parer. <br><br>  Il existe 2 solutions: <strong>CoroutineExceptionHandler</strong> et l'approche avec les <strong>classes Result</strong> . <br><br><h3>  Gestionnaire d'exceptions Coroutine <br></h3><br>  Il s'agit d'une classe sp√©ciale pour g√©rer les cas d'erreurs complexes.  <strong>ExceptionHandler</strong> vous permet de prendre votre <strong>exception</strong> comme argument comme une erreur et de la g√©rer. <br><br>  Comment traitons-nous habituellement les erreurs complexes? <br><br>  L'utilisateur a appuy√© sur quelque chose, le bouton n'a pas fonctionn√©.  Il doit dire ce qui n'a pas fonctionn√© et le diriger vers une action sp√©cifique: v√©rifier Internet, le Wi-Fi, r√©essayer plus tard ou supprimer l'application et ne plus jamais l'utiliser.  Dire cela √† l'utilisateur peut √™tre assez simple: <br><br><pre> <code class="java hljs">val handler = CoroutineExceptionHandler(handler = { , error -&gt; hideProgressDialog() val defaultErrorMsg = <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span> val errorMsg = when (error) { is ConnectionException -&gt; userFriendlyErrorMessage(error, defaultErrorMsg) is HttpResponseException -&gt; userFriendlyErrorMessage(Endpoint.EndpointType.ENDPOINT_SYNCPLICITY, error) is EncodingException -&gt; <span class="hljs-string"><span class="hljs-string">"Failed to decode data, please try again"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; defaultErrorMsg } Toast.makeText(context, errorMsg, Toast.LENGTH_SHORT).show() })</code> </pre><br>  - Obtenons le message par d√©faut: "Quelque chose s'est mal pass√©!"  et analyser l'exception. <br>  - S'il s'agit d'une <strong>exception ConnectionException,</strong> nous prenons un message localis√© des ressources: ¬´Mec, allume le Wi-Fi et tes probl√®mes dispara√Ætront.  Je le garantis. " <br>  - Si le <strong>serveur a dit quelque chose de mal</strong> , alors vous devez dire au client: ¬´D√©connectez-vous et reconnectez-vous¬ª, ou ¬´Ne faites pas cela √† Moscou, faites-le dans un autre pays¬ª, ou ¬´D√©sol√©, camarade.  Tout ce que je peux faire, c'est simplement dire que quelque chose s'est mal pass√©. ¬ª <br>  - S'il s'agit d'une <strong>erreur</strong> compl√®tement <strong>diff√©rente</strong> , par exemple, par <strong>manque de m√©moire</strong> , nous disons: "Quelque chose s'est mal pass√©, je suis d√©sol√©." <br>  - Tous les messages sont affich√©s. <br><br>  Ce que vous √©crivez dans <strong>CoroutineExceptionHandler</strong> sera ex√©cut√© sur le m√™me <strong>Dispatcher</strong> o√π vous ex√©cutez la coroutine.  Par cons√©quent, si vous donnez la commande "Launch" UI, alors tout se passe sur l'interface utilisateur.  Vous n'avez pas besoin de <strong>r√©partition</strong> s√©par√©e <strong>,</strong> ce qui est tr√®s pratique. <br><br>  L'utilisation est simple: <br><br><pre> <code class="java hljs">launch(uiDispatcher + handler) { ... }</code> </pre><br>  Il y a un op√©rateur <strong>plus</strong> .  Dans le contexte Coroutine, ajoutez un <strong>gestionnaire</strong> et tout fonctionne, ce qui est tr√®s pratique.  Nous l'avons utilis√© pendant un certain temps. <br><br><h3>  Classes de r√©sultats <br></h3><br>  Plus tard, nous avons r√©alis√© que le CoroutineExceptionHandler pourrait √™tre manquant.  Le r√©sultat, qui est form√© par le travail de coroutine, peut consister en plusieurs donn√©es, provenant de diff√©rentes parties ou traiter plusieurs situations. <br><br>  L'approche <strong>Classes de r√©sultats</strong> permet de faire face √† ce probl√®me: <br><br><pre> <code class="java hljs">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val payload: String)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val exception: Exception)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  - Dans votre logique m√©tier, vous d√©marrez une <strong>classe de r√©sultats</strong> . <br>  - Marquer comme <strong>scell√©</strong> . <br>  - Vous h√©ritez de la classe deux autres classes de donn√©es: <strong>Success</strong> et <strong>Error</strong> . <br> ‚Äî  <strong>Success</strong>   ,     . <br> ‚Äî  <strong>Error</strong>  exception. <br><br>     -  : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>= withContext(CommonPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isSessionValidForTask() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-meta"><span class="hljs-meta">@withContext</span></span> Result.Error(Exception()) } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Result.Success(restApi.call()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { Result.Error(e) } }</code> </pre><br>  Coroutine context ‚Äî Coroutine builder withContex     . <br><br> ,  : <br><br> ‚Äî   ,   error.     . <br> ‚Äî   RestApi   -. <br> ‚Äî   ,   <strong>Result.Success</strong> . <br> ‚Äî   ,  <strong>Result.Error</strong> . <br><br>      - ,  ExceptionHandler   . <br><br> Result classes ,   .   Result classes,      ExceptionHandler  try-catch. <br><br><h3> 3.  <br></h3><br> ,       .    <strong>unit-</strong> ,   ,    .       unit-. <br><br> ,   .   ,   unit-,    2 : <br><br><ol><li> <strong>Replacing context</strong> .   ,    ; </li><li> <strong>Mocking coroutines</strong> .   . </li></ol><br><h4> Replacing context <br></h4><br>   presenter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { ‚Ä¶ } }</code> </pre><br> ,    <strong>login</strong>    ,     UI-.      ,        ,  <strong>         </strong> .    ,    ,   unit-. <br><br>   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val coroutineContext = UI)</span></span></span><span class="hljs-function"> </span></span>{ launch(coroutineContext) { ... } }</code> </pre><br> ‚Äî   login   coroutineContext. ,            .  Kotlin   ,     UI  . <br> ‚Äî   Coroutine builder   Coroutine Contex,    . <br><br>  unit-   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val presenter = LoginPresenter () presenter.login(Unconfined) }</code> </pre><br><br> ‚Äî    <strong>LoginPresenter</strong>   login   - , ,  Unconfined. <br> ‚Äî <strong>Unconfined</strong> ,      ,    .         . <br><br><h4> Mocking coroutines <br></h4><br>   ‚Äî  .    <strong>Mockk</strong>  unit-.     unit-    Kotlin,      .  suspend-        <strong>coEvery</strong>        -. <br><br>   login     <strong>githubUser</strong> : <br><br><pre> <code class="java hljs">coEvery { apiClient.login(any()) } returns githubUser</code> </pre><br>    <strong>Mockito-kotlin</strong> ,     ‚Äî    . ,    ,     : <br><br><pre> <code class="java hljs">given { runBlocking { apiClient.login(any()) } }.willReturn (githubUser)</code> </pre><br>    <strong>runBlocking</strong> .  <strong>given-</strong>    ,    . <br><br>        <strong>Presenter</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val githubUser = GithubUser(<span class="hljs-string"><span class="hljs-string">'login'</span></span>) val presenter = LoginPresenter(mockApi) presenter.login (Unconfined) assertEquals(githubUser, presenter.user()) }</code> </pre><br> ‚Äî   -, , <strong>GitHubUser</strong> . <br> ‚Äî  LoginPresenter      API,     .      . <br> ‚Äî   <strong>presenter.login</strong>  Unconfined   ,   Presenter    ,   . <br><br>  !    . <br><br><h2>  Pour r√©sumer <br></h2><br><br><ul><li> <strong> Rx-   .</strong>      .      ,  RxJava  RxJava.     -  ‚Äî   ,   . </li><li> <strong>   .</strong>   ,       . Unit- ‚Äî       ,  ,     ,    .  ‚Äî welcome! </li><li> <strong>   .</strong>   ,  ,   ,   ,      .       . </li></ul><br><br><h3>  Liens utiles <br></h3><br><ul><li>      ,      Android GDE   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Android Coroutine Recipes</a> .     ,      : lifeCircle, coroutineContexts,   Coroutine builders   . </li><li> <a href="">  </a>  GitHub. </li><li>     Android  Kotlin,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> <strong>Codelab</strong></a> . </li><li>           .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a>       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong> Medium</strong></a>     ¬´¬ª      Android,   async-   . </li></ul><br><blockquote>  <strong>Actualit√©s</strong> <br><br> 30    Mail.ru   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>      .  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>   . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ,   ,       ,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">youtube-</a>       AppsConf 2018 ‚Äî    :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429908/">https://habr.com/ru/post/fr429908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429892/index.html">xonsh - python comme remplacement de shell</a></li>
<li><a href="../fr429894/index.html">Utilisation d'un ≈ìil de poisson sur un Raspberry Pi 3 avec ROS - Partie 2</a></li>
<li><a href="../fr429898/index.html">DMS (Dealership Management System) - Mise en place d'EcoSystems d'information pour la gestion des r√©seaux de concessionnaires</a></li>
<li><a href="../fr429902/index.html">Page Rank dans l'√®re du Web 2.0 - Partie 1</a></li>
<li><a href="../fr429904/index.html">Histoires dr√¥les et tristes sur le d√©veloppement de jeux informatiques</a></li>
<li><a href="../fr429910/index.html">AppsConf Rises</a></li>
<li><a href="../fr429912/index.html">D√©veloppement de biblioth√®que: de l'API √† la version publique</a></li>
<li><a href="../fr429914/index.html">OpenSceneGraph: graphique de sc√®ne et pointeurs intelligents</a></li>
<li><a href="../fr429916/index.html">Comment construire et construire</a></li>
<li><a href="../fr429918/index.html">Monde virtuel Intel. Partie 2: SMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>