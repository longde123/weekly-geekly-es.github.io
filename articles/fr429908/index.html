<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐐 👩‍👩‍👦‍👦 👨🏿‍🍳 Comment utiliser les coroutines dans les aliments et dormir paisiblement la nuit 👨🏼‍🤝‍👨🏻 🏁 👩🏾‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les coroutines sont un outil puissant pour l'exécution de code asynchrone. Ils travaillent en parallèle, communiquent entre eux et consomment peu de r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment utiliser les coroutines dans les aliments et dormir paisiblement la nuit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/429908/">  Les coroutines sont un outil puissant pour l'exécution de code asynchrone.  Ils travaillent en parallèle, communiquent entre eux et consomment peu de ressources.  Il semblerait que sans crainte, les coroutines puissent être introduites en production.  Mais il y a des peurs et elles interfèrent. <br><br>  <strong>Le rapport de Vladimir Ivanov</strong> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a> concerne le fait que le diable n'est pas si terrible et que vous pouvez utiliser des coroutines dès maintenant: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pourquoi coroutines, pas RxJava</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les craintes qui gênent les développeurs</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment créer un cache en utilisant des coroutines</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment gérer correctement les erreurs</a> . </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1lEG1CPkRaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>À propos du conférencier</strong> : Vladimir Ivanov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">dzigoro</a> ) est un développeur Android de premier plan à <strong>EPAM</strong> avec 7 ans d'expérience, aime l'architecture de solutions, React Native et le développement iOS, et a également la certification <strong>Google Cloud Architect</strong> . <br><a name="habracut"></a><br><blockquote>  Tout ce que vous lisez est un produit de la production d'expérience et d'études diverses, alors prenez-le tel quel, sans aucune garantie. <br></blockquote><h2><a name="coroutine"></a>  Coroutines, Kotlin et RxJava </h2><br>  Pour information: l'état actuel de la corutine est dans la version, à gauche Beta.  <strong>Kotlin 1.3</strong> est sorti, les coroutines sont déclarées stables et il y a la paix dans le monde. <br><br><img src="https://habrastorage.org/webt/it/jm/db/itjmdbtgjewt6v1kihv_5urqxie.png"><br><br>  J'ai récemment mené une enquête sur Twitter auprès des utilisateurs de coroutine: <br><br><ul><li>  13% des coroutines dans les aliments.  Tout va bien; </li><li>  25% les essaient dans le projet pour animaux de compagnie; </li><li>  24% - Qu'est-ce que Kotlin? </li><li>  La majeure partie de 38% de RxJava est partout. </li></ul><br>  Les statistiques ne sont pas heureuses.  Je pense que <strong>RxJava est un outil trop complexe</strong> pour les tâches dans lesquelles il est couramment utilisé par les développeurs.  Les coroutines conviennent mieux pour contrôler le fonctionnement asynchrone. <br><br>  Dans mes rapports précédents, j'ai parlé de la refonte de RxJava vers les coroutines de Kotlin, donc je ne m'attarderai pas là-dessus en détail, mais je ne ferai que rappeler les principaux points. <br><br><h3>  Pourquoi utilisons-nous des coroutines? </h3><br>  Parce que si nous utilisons RxJava, les exemples d'implémentation habituels ressemblent à ceci: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClientRx</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;GithubUser&gt; fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;List&lt;GithubRepository&gt;&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//RxJava 2 implementation</span></span></span></span></code> </pre> <br>  Nous avons une interface, par exemple, nous écrivons un client GitHub et voulons effectuer quelques opérations pour cela: <br><br><ol><li>  Utilisateur de connexion. <br></li><li>  Obtenez une liste des référentiels GitHub. <br></li></ol><br>  Dans les deux cas, les fonctions renverront des objets métier simples: GitHubUser ou une liste de GitHubRepository. <br><br>  Le code d'implémentation de cette interface est le suivant: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) compositeDisposable.add(apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } )) }</code> </pre><br>  - Nous prenons <strong>compositeDisposable</strong> pour qu'il n'y ait pas de fuite mémoire. <br>  - Ajoutez un appel à la première méthode. <br>  - Nous utilisons des opérateurs pratiques pour obtenir l'utilisateur, par exemple <strong>flatMap</strong> . <br>  - Nous obtenons une liste de ses référentiels. <br>  - Nous écrivons une <strong>Boilerplate</strong> pour qu'elle <strong>fonctionne</strong> sur les bons threads. <br>  - Lorsque tout est prêt, nous affichons la liste des référentiels pour l'utilisateur connecté. <br><br>  <strong>Difficultés du code RxJava:</strong> <br><br><ul><li>  <strong>La complexité</strong>  À mon avis, le code est trop compliqué pour la simple tâche de deux appels réseau et d'afficher quelque chose sur l' <strong>interface utilisateur</strong> . </li><li>  <strong>Traces de pile non liées.</strong>  Les traces de pile ne sont presque pas liées au code que vous écrivez. </li><li>  <strong>Dépassement des ressources</strong> <strong>.</strong>  RxJava génère beaucoup d'objets sous le capot et les performances peuvent diminuer. </li></ul><br>  <strong>Quel sera le même code avec les coroutines jusqu'à la version 0.26?</strong> <br><br>  À 0,26, l'API a changé et nous parlons de production.  Personne n'a encore réussi à appliquer 0,26 dans la prod, mais nous y travaillons. <br><br>  <strong>Avec les coroutines, notre interface va changer de façon assez importante</strong> .  Les fonctions cesseront de renvoyer les simples et autres objets d'assistance.  Ils renverront immédiatement des objets métier: GitHubUser et une liste de GitHubRepository.  Les fonctions GitHubUser et GitHubRepository auront des modificateurs de <strong>suspension</strong> .  C'est bien, car suspendre ne nous oblige presque à rien: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : GithubUser suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : List&lt;GithubRepository&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Base interface</span></span></span></span></code> </pre><br>  Si vous regardez le code qui utilise déjà l'implémentation de cette interface, il changera considérablement par rapport à RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLogin</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { val auth = BasicAuthorization(login, pass) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) val userlnfo = async { apiClient.login(auth) }.await() val repoUrl = userlnfo.repos_url val list = async { apiClient.getRepositories(repoUrl, auth) }.await() showRepositories( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list.map { it -&gt; it.full_name } ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: RuntimeException) { showToast(<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } } }</code> </pre><br>  - L'action principale a lieu où nous appelons <strong>async coroutine builder</strong> , attendons une réponse et obtenons <strong>userlnfo</strong> . <br>  - Nous utilisons les données de cet objet. <br>  - Effectuez un autre appel <strong>asynchrone</strong> et appelez en <strong>attente</strong> . <br><br>  Tout semble comme si aucun travail asynchrone ne se passait, et nous écrivons simplement les commandes dans la colonne et elles sont exécutées.  En fin de compte, nous faisons ce qui doit être fait sur l'interface utilisateur. <br><br>  <strong>Pourquoi les coroutines sont-elles meilleures?</strong> <br><br><ul><li>  Ce code est plus facile à lire.  Il est écrit comme s'il était cohérent. </li><li>  Très probablement, les performances de ce code sont meilleures que sur RxJava. </li><li>  Il est très simple d'écrire des tests, mais nous y reviendrons un peu plus tard. </li></ul><br><h2>  2 marches sur le côté <br></h2><br>  Écartons-nous un peu, il y a encore quelques points à discuter. <br><br><h3>  Étape 1. withContext vs launch / async <br></h3><br>  En plus de <strong>coroutine builder async,</strong> il existe <strong>coroutine builder withContext</strong> . <br><br>  <strong>Lancez</strong> ou <strong>async</strong> créez un nouveau <strong>contexte Coroutine</strong> , ce qui n'est pas toujours nécessaire.  Si vous avez un contexte Coroutine que vous souhaitez utiliser dans l'application, vous n'avez pas besoin de le recréer.  Vous pouvez simplement réutiliser un existant.  Pour ce faire, vous aurez besoin d'un générateur de coroutine avec Context.  Il réutilise simplement le contexte Coroutine existant.  Ce sera 2-3 fois plus rapide, mais maintenant c'est une question sans principes.  Si les chiffres exacts sont intéressants, alors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici la question</a> sur <strong>stackoverflow</strong> avec des repères et des détails. <br><br><blockquote>  <strong>Règle générale:</strong> utilisez withContext sans aucun doute là où il tient sémantiquement.  Mais si vous avez besoin d'un chargement parallèle, par exemple plusieurs images ou éléments de données, alors async / wait est votre choix. <br></blockquote><br><h3>  Étape 2. Refactoring <br></h3><br>  Et si vous refactorisez une chaîne RxJava vraiment complexe?  Je suis tombé sur cela en production: <br><br><pre> <code class="java hljs">observable1.getSubject().zipWith(observable2.getSubject(), (t1, t2) -&gt; { <span class="hljs-comment"><span class="hljs-comment">// side effects return true; }).doOnError { // handle errors } .zipWith(observable3.getSubject(), (t3, t4) -&gt; { // side effects return true; }).doOnComplete { // gather data } .subscribe()</span></span></code> </pre><br>  J'avais une chaîne compliquée avec un <strong>sujet public</strong> , avec des <strong>fermetures</strong> à <strong>glissière</strong> et <strong>des</strong> <strong>effets secondaires</strong> dans chaque <strong>fermeture éclair</strong> qui envoyaient autre chose au bus de l'événement.  La tâche au moins était de se débarrasser du bus d'événement.  Je me suis assis pendant une journée, mais je n'ai pas pu refactoriser le code pour résoudre le problème.  <strong>La bonne décision s'est avérée de tout jeter et de réécrire le code sur coroutine en 4 heures</strong> . <br><br>  Le code ci-dessous est très similaire à ce que j'ai obtenu: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val firstChunkJob = async { call1 } val secondChunkJob = async { call2 } val thirdChunkJob = async { call3 } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( firstChunkJob.await(), secondChunkJob.await(), thirdChunkJob.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-comment"><span class="hljs-comment">// handle errors }</span></span></code> </pre><br>  - Nous faisons async pour une tâche, pour les deuxième et troisième. <br>  - Nous attendons le résultat et mettons tout cela dans un objet. <br>  - C'est fait! <br><br>  Si vous avez des chaînes complexes et qu'il y a des coroutines, alors refactorisez simplement.  C'est vraiment rapide. <br><br><h2><a name="fear"></a>  Qu'est-ce qui empêche les développeurs d'utiliser des coroutines dans prod? <br></h2><br>  À mon avis, en tant que développeurs, nous ne sommes actuellement empêchés d'utiliser des coroutines que par crainte de quelque chose de nouveau: <br><br><ul><li>  Nous ne savons pas quoi faire du <strong>cycle</strong> de <strong>vie</strong> , de l' <strong>activité</strong> et du cycle de vie des fragments.  Comment travailler avec des coroutines dans ces cas? </li><li>  Il n'y a aucune expérience dans la résolution de tâches complexes quotidiennes en production à l'aide de corutine. </li><li>  Pas assez d'outils.  Un tas de bibliothèques et de fonctions ont été écrites pour RxJava.  Par exemple <strong>RxFCM</strong> .  RxJava lui-même a beaucoup d'opérateurs, ce qui est bien, mais qu'en est-il de la coroutine? </li><li>  Nous ne comprenons pas vraiment comment tester les coroutines. </li></ul><br><blockquote>  Si nous nous débarrassons de ces quatre peurs, nous pouvons dormir paisiblement la nuit et utiliser des coroutines en production. <br></blockquote><br>  Voyons point par point. <br><br><h3>  1. Gestion du cycle de vie <br></h3><br><ul><li>  Les coroutines peuvent fuir comme <strong>jetables</strong> ou <strong>AsyncTask</strong> .  Ce problème doit être résolu manuellement. </li><li>  Pour éviter une <strong>exception de pointeur nul</strong> aléatoire <strong>, les</strong> coroutines doivent être arrêtées. </li></ul><br><h4>  Arrêter <br></h4><br>  Connaissez-vous <strong>Thread.stop ()</strong> ?  Si vous l'avez utilisé, alors pas pour longtemps.  Dans <strong>JDK 1.1, la</strong> méthode a été immédiatement déclarée obsolète, car il est impossible de prendre et d'arrêter un certain morceau de code et il n'y a aucune garantie qu'il se terminera correctement.  Très probablement, vous n'obtiendrez que <strong>la corruption de mémoire</strong> . <br><br>  Par conséquent, <strong>Thread.stop () ne fonctionne pas</strong> .  Vous avez besoin que l'annulation soit coopérative, c'est-à-dire le code de l'autre côté pour savoir que vous l'annulez. <br><br>  Comment appliquons-nous les arrêts avec RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val compositeDisposable = CompositeDisposable() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.add( apiClientRx.requestSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(result -&gt; {}) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.dispose() }</code> </pre><br><br>  Dans RxJava, nous <strong>utilisons CompositeDisposable</strong> . <br><br>  - Ajoutez la variable <strong>compositeDisposable</strong> à l'activité dans le fragment ou dans le présentateur, où nous utilisons RxJava. <br>  - Dans <strong>onDestro</strong> y ajoutez <strong>Dispose</strong> et toutes les exceptions disparaissent d'elles-mêmes. <br><br>  Environ le même principe avec les coroutines: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: Job? = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI) { val user = apiClient.requestSomething() … } } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job?.cancel() }</code> </pre><br>  Prenons un exemple de <strong>tâche simple</strong> . <br><br>  En règle générale, <strong>les constructeurs de coroutine</strong> renvoient un <strong>travail</strong> et, dans certains cas, sont <strong>reportés</strong> . <br><br>  - Nous pouvons mémoriser ce travail. <br>  - Donnez la commande <strong>"lancer" le</strong> <strong>générateur de coroutine</strong> .  Le processus démarre, quelque chose se passe, le résultat de l'exécution est mémorisé. <br>  - Si nous ne transmettons rien d'autre, alors «lancer» démarre la fonction et nous renvoie un lien vers le travail. <br>  - Le travail est mémorisé, et dans onDestroy, nous disons <strong>«annuler»</strong> et tout fonctionne bien. <br><br>  <strong>Quel est le problème de l'approche?</strong>  Chaque travail a besoin d'un champ.  Vous devez conserver une liste des travaux pour les annuler tous ensemble.  L'approche conduit à la duplication de code, ne le faites pas. <br><br>  La bonne nouvelle, c'est que nous avons des <strong>alternatives</strong> : <strong>CompositeJob</strong> et <strong>Lifecycle job</strong> . <br><br>  CompositeJob est un analogue de compositeDisposable.  Cela ressemble à ceci <strong>:</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: CompositeJob = CompositeJob() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.add(launch(UI) { val user = apiClient.requestSomething() ... }) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.cancel() }</code> </pre><br>  - Pour un fragment, nous commençons un travail. <br>  - Nous mettons tout le <strong>travail</strong> dans CompositeJob et donnons la commande: <strong>"job.cancel () pour tout le monde!"</strong>  . <br><br>  L'approche est facilement implémentée en 4 lignes, sans compter la déclaration de classe: <br><br><pre> <code class="java hljs">Class CompositeJob { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val map = hashMapOf&lt;String, Job&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(job: Job, key: String = job.hashCode()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span></span>= map.put(key, job)?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String)</span></span></span><span class="hljs-function"> </span></span>= map[key]?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= map.forEach { _ ,u -&gt; u.cancel() } }</code> </pre><br><br>  Vous aurez besoin de: <br><br>  - <strong>carte</strong> avec une clé de chaîne, <br>  - <strong>ajouter une</strong> méthode, dans laquelle vous ajouterez un travail, <br>  - paramètre <strong>clé</strong> facultatif. <br><br>  Si vous souhaitez utiliser la même clé pour le même travail, veuillez.  Sinon, <strong>hashCode</strong> résoudra notre problème.  Ajoutez le travail à la carte que nous avons passée et annulez le précédent avec la même clé.  Si nous remplissons trop la tâche, le résultat précédent ne nous intéresse pas.  Nous l'annulons et le conduisons à nouveau. <br><br>  L'annulation est simple: nous obtenons le travail par clé et l'annulons.  La deuxième annulation pour la carte entière annule tout.  Tout le code est écrit en une demi-heure sur quatre lignes et cela fonctionne.  Si vous ne voulez pas écrire, prenez l'exemple ci-dessus. <br><br><h4>  Travail adapté au cycle de vie </h4><br>  Avez-vous utilisé <strong>Android Lifecycle</strong> , <strong>propriétaire</strong> ou <strong>observateur de</strong> <strong>Lifecycle</strong> ? <br><img src="https://habrastorage.org/webt/ud/pi/eq/udpieqn_xba30yasl2buwbs2bay.png"><br><br>  Notre <strong>activité</strong> et nos <strong>fragments</strong> ont certains états.  Faits saillants: <strong>créé,</strong> <strong>démarré</strong> et <strong>repris</strong> .  Il existe différentes transitions entre les États.  <strong>LifecycleObserver</strong> vous permet de vous abonner à ces transitions et de faire quelque chose lorsqu'une des transitions se produit. <br><br>  Cela semble assez simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObserver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_RESUME) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_PAUSE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ … } }</code> </pre><br>  Vous raccrochez l'annotation avec un paramètre sur la méthode, et elle est appelée avec la transition correspondante.  Utilisez simplement cette approche pour coroutine: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidJob</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lifecycle</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ init { lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_DESTROY) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.d(<span class="hljs-string"><span class="hljs-string">"AndroidJob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cancelling a coroutine"</span></span>) cancel() } }</code> </pre><br>  - Vous pouvez écrire la classe de base <strong>AndroidJob</strong> . <br>  - Nous transférerons le <strong>cycle de vie à la</strong> classe. <br>  - L'interface <strong>LifecycleObserver</strong> implémentera le travail. <br><br>  Tout ce dont nous avons besoin: <br><br>  - Dans le constructeur, ajoutez à Lifecycle en tant qu'observateur. <br>  - Abonnez-vous à <strong>ON_DESTROY</strong> ou à toute autre chose qui nous intéresse. <br>  - Faire annuler dans ON_DESTROY. <br>  - <strong>Obtenez</strong> un <strong>parentJob</strong> dans votre fragment. <br>  - Appelez le constructeur <strong>Joy jobs</strong> ou le <strong>cycle de vie de</strong> votre fragment d'activité.  Aucune différence. <br>  - Passez ce <strong>parentJob en</strong> tant que <strong>parent</strong> . <br><br>  Le code fini ressemble à ceci: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentJob = AndroidJob(lifecycle) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI, parent = parentJob) { <span class="hljs-comment"><span class="hljs-comment">// code } }</span></span></code> </pre><br>  Lorsque vous annulez parent, toutes les coroutines enfant sont annulées et vous n'avez plus besoin d'écrire quoi que ce soit dans le fragment.  Tout se passe automatiquement, plus ON_DESTROY.  L'essentiel <strong>,</strong> n'oubliez pas de passer <strong>parent = parentJob</strong> . <br><br><blockquote>  Si vous utilisez, vous pouvez écrire une règle de charpie simple qui vous mettra en évidence: "Oh, vous avez oublié votre parent!" <br></blockquote><br>  Avec <strong>&nbsp;</strong>  Gestion de cycle de vie triée.  Nous avons quelques outils qui vous permettent de faire tout cela facilement et confortablement. <br><br>  Qu'en est-il des scénarios complexes et des tâches non triviales en production? <br><br><h3>  2. Cas d'utilisation complexes <br></h3><br>  Les scénarios complexes et les tâches non triviales sont: <br><br>  - <strong>Opérateurs</strong> - opérateurs complexes dans RxJava: flatMap, debounce, etc. <br>  - <strong>Gestion</strong> des erreurs <strong>- gestion</strong> des erreurs complexes.  Pas seulement <strong>try..catch</strong> , mais imbriqué par exemple. <br>  - La <strong>mise en cache</strong> <strong>est une</strong> tâche non triviale.  En production, nous avons rencontré un cache et voulions obtenir un outil pour résoudre facilement le problème de mise en cache avec les coroutines. <br><br><h4>  Répéter </h4><br>  Quand nous avons pensé aux opérateurs pour coroutine, la première option était <strong>repeatWhen ()</strong> . <br><br>  Si quelque chose s'est mal passé et que Corutin n'a pas pu atteindre le serveur à l'intérieur, nous voulons réessayer plusieurs fois avec une sorte de repli exponentiel.  La raison est peut-être une mauvaise connexion et nous obtiendrons le résultat souhaité en répétant l'opération plusieurs fois. <br><br>  Avec les coroutines, cette tâche est facilement implémentée: <br><br><pre> <code class="java hljs">suspend fun &lt;T&gt; retryDeferredWithDelay( deferred: () -&gt; Deferred&lt;T&gt;, tries: Int = <span class="hljs-number"><span class="hljs-number">3</span></span>, timeDelay: Long = <span class="hljs-number"><span class="hljs-number">1000L</span></span> ): T { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1</span></span>..tries) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred().await() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; tries) delay(timeDelay) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException() }</code> </pre><br><br>  Implémentation de l'opérateur: <br><br>  - Il prend <strong>différé</strong> . <br>  - Vous devrez appeler <strong>async</strong> pour obtenir cet objet. <br>  - Au lieu de <strong>différé,</strong> vous pouvez passer à la fois un bloc de suspension et généralement n'importe quelle <strong>fonction de suspension.</strong> <br>  - La boucle <strong>for</strong> - vous attendez le résultat de votre coroutine.  Si quelque chose se produit et que le compteur de répétition n'est pas épuisé, réessayez via <strong>Delay</strong> .  Sinon, alors non. <br><br>  La fonction peut être facilement personnalisée: mettez un retard exponentiel ou passez une fonction lambda qui calculera le retard en fonction des circonstances. <br><br>  Utilisez-le, cela fonctionne! <br><br><h4>  Zips </h4><br>  On les rencontre aussi souvent.  Là encore, tout est simple: <br><br><pre> <code class="java hljs">suspend fun &lt;T1, T2, R&gt; zip( source1: Deferred&lt;T1&gt;, source2: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zipper.apply(sourcel.await(), source2.await()) } suspend fun &lt;T1, T2, R&gt; Deferred&lt;T1&gt;.zipWith( other: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other, zipper) }</code> </pre><br>  - Utilisez la <strong>fermeture éclair</strong> et appelez en attente sur votre différé. <br>  - Au lieu de différé, vous pouvez utiliser la fonction de suspension et le générateur de coroutine avec withContext.  Vous transmettrez le contexte dont vous avez besoin. <br><br>  Cela fonctionne à nouveau et j'espère avoir supprimé cette peur. <br><br><a name="cache"></a><h3>  Cache </h3><br><br>  Avez-vous une implémentation de cache en production avec RxJava?  Nous utilisons RxCache. <br><img src="https://habrastorage.org/webt/tz/ym/tn/tzymtn1tykponnxcmz0qqi_qjmi.png"><br><br>  Dans le diagramme de gauche: <strong>View</strong> et <strong>ViewModel</strong> .  À droite, les sources de données: les appels réseau et la base de données. <br><br>  Si nous voulons que quelque chose soit mis en cache, le cache sera une autre source de données. <br><br>  Types de cache: <br><br><ul><li>  <strong>Source</strong> réseau pour les appels réseau. </li><li>  <strong>Cache en mémoire</strong> . </li><li>  <strong>Cache persistant</strong> avec expiration à stocker sur le disque afin que le cache survive au redémarrage de l'application. </li></ul><br>  Écrivons un <strong>cache</strong> simple et primitif pour le troisième cas.  Le constructeur de Coroutine withContext vient à la rescousse. <br><br><pre> <code class="java hljs">launch(UI) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = withContext(dispatcher) { persistence.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { memory.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { network.getData() } memory.cache(url, data) persistence.cache(url, data) } } }</code> </pre><br>  - Vous exécutez chaque opération avec withContext et voyez si des données arrivent. <br>  - Si les données de <strong>persistance</strong> ne viennent pas, vous essayez de les obtenir à partir de <strong>memory.cache</strong> . <br>  - S'il n'y a pas non plus de memory.cache, contactez la <strong>source réseau</strong> et récupérez vos données.  N'oubliez pas, bien sûr, de mettre toutes les caches. <br><br>  Il s'agit d'une implémentation plutôt primitive et il y a beaucoup de questions, mais la méthode fonctionne si vous avez besoin d'un cache au même endroit.  Pour les tâches de production, ce cache n'est pas suffisant.  Il faut quelque chose de plus compliqué. <br><br><h4>  Rx a RxCache </h4><br>  Pour ceux qui utilisent encore RxJava, vous pouvez utiliser RxCache.  Nous l'utilisons toujours aussi.  <strong>RxCache</strong> est une bibliothèque spéciale.  Vous permet de mettre en cache des données et de gérer son cycle de vie. <br><br>  Par exemple, vous voulez dire que ces données expireront après 15 minutes: "S'il vous plaît, après cette période de temps, n'envoyez pas de données depuis le cache, mais envoyez-moi de nouvelles données." <br><br>  La bibliothèque est merveilleuse en ce qu'elle soutient déclarativement l'équipe.  La déclaration est très similaire à ce que vous faites avec <strong>Retrofit</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureConfigCacheProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ProviderKey</span></span>(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@LifeCache</span></span>(duration = <span class="hljs-number"><span class="hljs-number">15</span></span>, timeUnit = TimeUnit.MINUTES) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( result: Observable&lt;Features&gt;, cacheName: DynamicKey )</span></span></span><span class="hljs-function">: Observable&lt;Reply&lt;Features&gt;&gt; }</span></span></code> </pre><br>  - Vous dites que vous avez un <strong>CacheProvider</strong> . <br>  - Démarrez une méthode et dites que la <strong>durée de</strong> vie de <strong>LifeCache est de</strong> 15 minutes.  La clé par laquelle il sera disponible est <strong>Fonctionnalités</strong> . <br>  - Renvoie <strong>Observable &lt;Reply</strong> , où <strong>Reply</strong> est un objet de bibliothèque auxiliaire pour travailler avec le cache. <br><br>  L'utilisation est assez simple: <br><br><pre> <code class="java hljs">val restObservable = configServiceRestApi.getFeatures() val features = featureConfigCacheProvider.getFeatures( restObservable, DynamicKey(CACHE_KEY) )</code> </pre><br>  - Depuis le cache Rx, accédez à <strong>RestApi</strong> . <br>  - <strong>Tournez-vous</strong> vers <strong>CacheProvider</strong> . <br>  - Nourrissez-le d'un observable. <br>  - La bibliothèque elle-même saura quoi faire: allez dans le cache ou non, si le temps est écoulé, tournez-vous vers <strong>Observable</strong> et effectuez une autre opération. <br><br>  L'utilisation de la bibliothèque est très pratique et j'aimerais en obtenir une similaire pour coroutine. <br><br><h4>  Coroutine Cache en développement </h4><br>  Dans EPAM, nous écrivons la bibliothèque <strong>Coroutine Cache</strong> , qui exécutera toutes les fonctions de RxCache.  Nous avons écrit la première version et l'avons exécutée au sein de l'entreprise.  Dès la sortie de la première version, je me ferai un plaisir de la publier sur mon Twitter.  Cela ressemblera à ceci: <br><br><pre> <code class="java hljs">val restFunction = configServiceRestApi.getFeatures() val features = withCache(CACHE_KEY) { restFunction() }</code> </pre><br>  Nous aurons une fonction suspendre <strong>getFeatures</strong> .  Nous passerons la fonction sous forme de bloc à une fonction spéciale d'ordre supérieur avec <strong>Cache</strong> , qui <strong>déterminera</strong> ce qui doit être fait. <br><br>  Peut-être ferons-nous la même interface pour prendre en charge les fonctions déclaratives. <br><br><a name="err"></a><h3>  Gestion des erreurs <br></h3><br><img src="https://habrastorage.org/webt/sd/qq/uc/sdqqucxxckqchfozdoknxa3vi-k.png"><br><br>  La gestion simple des erreurs est souvent trouvée par les développeurs et est généralement résolue assez simplement.  Si vous n'avez pas de choses compliquées, alors dans catch vous attrapez l' <strong>exception</strong> et regardez ce qui s'est passé là-bas, écrivez dans le journal ou affichez une erreur à l'utilisateur.  Sur l'interface utilisateur, vous pouvez facilement le faire. <br><br>  Dans les cas simples, tout est normalement simple - la gestion des erreurs avec les coroutines se fait via <strong>try-catch-finally</strong> . <br><br>  En production, en plus des cas simples, il y a: <br><br>  - Try <strong>-catch</strong> imbriqué, <br>  - De nombreux types d' <strong>exceptions</strong> , <br>  - Erreurs dans le réseau ou dans la logique métier, <br>  - Erreurs utilisateur.  Il a de nouveau fait quelque chose de mal et était à blâmer pour tout. <br><br>  Nous devons nous y préparer. <br><br>  Il existe 2 solutions: <strong>CoroutineExceptionHandler</strong> et l'approche avec les <strong>classes Result</strong> . <br><br><h3>  Gestionnaire d'exceptions Coroutine <br></h3><br>  Il s'agit d'une classe spéciale pour gérer les cas d'erreurs complexes.  <strong>ExceptionHandler</strong> vous permet de prendre votre <strong>exception</strong> comme argument comme une erreur et de la gérer. <br><br>  Comment traitons-nous habituellement les erreurs complexes? <br><br>  L'utilisateur a appuyé sur quelque chose, le bouton n'a pas fonctionné.  Il doit dire ce qui n'a pas fonctionné et le diriger vers une action spécifique: vérifier Internet, le Wi-Fi, réessayer plus tard ou supprimer l'application et ne plus jamais l'utiliser.  Dire cela à l'utilisateur peut être assez simple: <br><br><pre> <code class="java hljs">val handler = CoroutineExceptionHandler(handler = { , error -&gt; hideProgressDialog() val defaultErrorMsg = <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span> val errorMsg = when (error) { is ConnectionException -&gt; userFriendlyErrorMessage(error, defaultErrorMsg) is HttpResponseException -&gt; userFriendlyErrorMessage(Endpoint.EndpointType.ENDPOINT_SYNCPLICITY, error) is EncodingException -&gt; <span class="hljs-string"><span class="hljs-string">"Failed to decode data, please try again"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; defaultErrorMsg } Toast.makeText(context, errorMsg, Toast.LENGTH_SHORT).show() })</code> </pre><br>  - Obtenons le message par défaut: "Quelque chose s'est mal passé!"  et analyser l'exception. <br>  - S'il s'agit d'une <strong>exception ConnectionException,</strong> nous prenons un message localisé des ressources: «Mec, allume le Wi-Fi et tes problèmes disparaîtront.  Je le garantis. " <br>  - Si le <strong>serveur a dit quelque chose de mal</strong> , alors vous devez dire au client: «Déconnectez-vous et reconnectez-vous», ou «Ne faites pas cela à Moscou, faites-le dans un autre pays», ou «Désolé, camarade.  Tout ce que je peux faire, c'est simplement dire que quelque chose s'est mal passé. » <br>  - S'il s'agit d'une <strong>erreur</strong> complètement <strong>différente</strong> , par exemple, par <strong>manque de mémoire</strong> , nous disons: "Quelque chose s'est mal passé, je suis désolé." <br>  - Tous les messages sont affichés. <br><br>  Ce que vous écrivez dans <strong>CoroutineExceptionHandler</strong> sera exécuté sur le même <strong>Dispatcher</strong> où vous exécutez la coroutine.  Par conséquent, si vous donnez la commande "Launch" UI, alors tout se passe sur l'interface utilisateur.  Vous n'avez pas besoin de <strong>répartition</strong> séparée <strong>,</strong> ce qui est très pratique. <br><br>  L'utilisation est simple: <br><br><pre> <code class="java hljs">launch(uiDispatcher + handler) { ... }</code> </pre><br>  Il y a un opérateur <strong>plus</strong> .  Dans le contexte Coroutine, ajoutez un <strong>gestionnaire</strong> et tout fonctionne, ce qui est très pratique.  Nous l'avons utilisé pendant un certain temps. <br><br><h3>  Classes de résultats <br></h3><br>  Plus tard, nous avons réalisé que le CoroutineExceptionHandler pourrait être manquant.  Le résultat, qui est formé par le travail de coroutine, peut consister en plusieurs données, provenant de différentes parties ou traiter plusieurs situations. <br><br>  L'approche <strong>Classes de résultats</strong> permet de faire face à ce problème: <br><br><pre> <code class="java hljs">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val payload: String)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val exception: Exception)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  - Dans votre logique métier, vous démarrez une <strong>classe de résultats</strong> . <br>  - Marquer comme <strong>scellé</strong> . <br>  - Vous héritez de la classe deux autres classes de données: <strong>Success</strong> et <strong>Error</strong> . <br> —  <strong>Success</strong>   ,     . <br> —  <strong>Error</strong>  exception. <br><br>     -  : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>= withContext(CommonPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isSessionValidForTask() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-meta"><span class="hljs-meta">@withContext</span></span> Result.Error(Exception()) } … <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Result.Success(restApi.call()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { Result.Error(e) } }</code> </pre><br>  Coroutine context — Coroutine builder withContex     . <br><br> ,  : <br><br> —   ,   error.     . <br> —   RestApi   -. <br> —   ,   <strong>Result.Success</strong> . <br> —   ,  <strong>Result.Error</strong> . <br><br>      - ,  ExceptionHandler   . <br><br> Result classes ,   .   Result classes,      ExceptionHandler  try-catch. <br><br><h3> 3.  <br></h3><br> ,       .    <strong>unit-</strong> ,   ,    .       unit-. <br><br> ,   .   ,   unit-,    2 : <br><br><ol><li> <strong>Replacing context</strong> .   ,    ; </li><li> <strong>Mocking coroutines</strong> .   . </li></ol><br><h4> Replacing context <br></h4><br>   presenter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { … } }</code> </pre><br> ,    <strong>login</strong>    ,     UI-.      ,        ,  <strong>         </strong> .    ,    ,   unit-. <br><br>   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val coroutineContext = UI)</span></span></span><span class="hljs-function"> </span></span>{ launch(coroutineContext) { ... } }</code> </pre><br> —   login   coroutineContext. ,            .  Kotlin   ,     UI  . <br> —   Coroutine builder   Coroutine Contex,    . <br><br>  unit-   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val presenter = LoginPresenter () presenter.login(Unconfined) }</code> </pre><br><br> —    <strong>LoginPresenter</strong>   login   - , ,  Unconfined. <br> — <strong>Unconfined</strong> ,      ,    .         . <br><br><h4> Mocking coroutines <br></h4><br>   —  .    <strong>Mockk</strong>  unit-.     unit-    Kotlin,      .  suspend-        <strong>coEvery</strong>        -. <br><br>   login     <strong>githubUser</strong> : <br><br><pre> <code class="java hljs">coEvery { apiClient.login(any()) } returns githubUser</code> </pre><br>    <strong>Mockito-kotlin</strong> ,     —    . ,    ,     : <br><br><pre> <code class="java hljs">given { runBlocking { apiClient.login(any()) } }.willReturn (githubUser)</code> </pre><br>    <strong>runBlocking</strong> .  <strong>given-</strong>    ,    . <br><br>        <strong>Presenter</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val githubUser = GithubUser(<span class="hljs-string"><span class="hljs-string">'login'</span></span>) val presenter = LoginPresenter(mockApi) presenter.login (Unconfined) assertEquals(githubUser, presenter.user()) }</code> </pre><br> —   -, , <strong>GitHubUser</strong> . <br> —  LoginPresenter      API,     .      . <br> —   <strong>presenter.login</strong>  Unconfined   ,   Presenter    ,   . <br><br>  !    . <br><br><h2>  Pour résumer <br></h2><br><br><ul><li> <strong> Rx-   .</strong>      .      ,  RxJava  RxJava.     -  —   ,   . </li><li> <strong>   .</strong>   ,       . Unit- —       ,  ,     ,    .  — welcome! </li><li> <strong>   .</strong>   ,  ,   ,   ,      .       . </li></ul><br><br><h3>  Liens utiles <br></h3><br><ul><li>      ,      Android GDE   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Android Coroutine Recipes</a> .     ,      : lifeCircle, coroutineContexts,   Coroutine builders   . </li><li> <a href="">  </a>  GitHub. </li><li>     Android  Kotlin,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> <strong>Codelab</strong></a> . </li><li>           .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a>       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong> Medium</strong></a>     «»      Android,   async-   . </li></ul><br><blockquote>  <strong>Actualités</strong> <br><br> 30    Mail.ru   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>      .  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>   . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ,   ,       ,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">youtube-</a>       AppsConf 2018 —    :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429908/">https://habr.com/ru/post/fr429908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429892/index.html">xonsh - python comme remplacement de shell</a></li>
<li><a href="../fr429894/index.html">Utilisation d'un œil de poisson sur un Raspberry Pi 3 avec ROS - Partie 2</a></li>
<li><a href="../fr429898/index.html">DMS (Dealership Management System) - Mise en place d'EcoSystems d'information pour la gestion des réseaux de concessionnaires</a></li>
<li><a href="../fr429902/index.html">Page Rank dans l'ère du Web 2.0 - Partie 1</a></li>
<li><a href="../fr429904/index.html">Histoires drôles et tristes sur le développement de jeux informatiques</a></li>
<li><a href="../fr429910/index.html">AppsConf Rises</a></li>
<li><a href="../fr429912/index.html">Développement de bibliothèque: de l'API à la version publique</a></li>
<li><a href="../fr429914/index.html">OpenSceneGraph: graphique de scène et pointeurs intelligents</a></li>
<li><a href="../fr429916/index.html">Comment construire et construire</a></li>
<li><a href="../fr429918/index.html">Monde virtuel Intel. Partie 2: SMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>