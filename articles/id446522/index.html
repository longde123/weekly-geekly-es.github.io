<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏿 👩🏾‍🤝‍👨🏽 💃🏼 Swift 5.1 - apa yang baru? 🐕 🛌🏽 🦇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Swift 5.0 menjadi tersedia dengan rilis Xcode 10.2, tetapi bekerja pada versi berikutnya berlanjut dan sudah ada berita tentang apa yang dapat Anda ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift 5.1 - apa yang baru?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446522/"><img src="https://habrastorage.org/webt/fi/zt/dn/fiztdnga2fbfx1-9joaxn3crp_o.png"><br><br>  Swift 5.0 menjadi tersedia dengan rilis Xcode 10.2, tetapi bekerja pada versi berikutnya berlanjut dan sudah ada berita tentang apa yang dapat Anda harapkan di dalamnya. <br><br>  Fitur utama dari <b>Swift 5.1</b> adalah <b>stabilitas modul</b> , yang memungkinkan kita untuk menggunakan pustaka pihak ketiga tanpa khawatir tentang versi kompiler Swift mana mereka diciptakan.  Sepertinya <b>stabilitas ABI yang</b> kami dapatkan di Swift 5.0, tetapi ada sedikit perbedaan: stabilitas ABI menyelesaikan perbedaan dalam versi Swift saat runtime, dan stabilitas modul pada waktu kompilasi. <br><br>  Selain inovasi penting ini, kami akan menerima beberapa peningkatan penting dalam Swift, dan dalam artikel ini kami akan membahasnya dengan contoh-contoh sehingga Anda dapat melihatnya dalam aksi. <br><a name="habracut"></a><br><h3>  Diri Universal </h3><br>  <a href="">SE-0068</a> memperluas penggunaan <b>Diri</b> , sehingga mengacu pada jenis yang mengandungnya dalam kelas, struktur, dan enumerasi.  Ini biasanya berguna untuk tipe dinamis ketika perlu untuk menentukan tipe yang tepat dari sesuatu saat runtime. <br><br>  Sebagai contoh, pertimbangkan kode berikut: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">maximumActiveRequests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDebugData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Maximum network requests: \(NetworkManager.maximumActiveRequests)."</span></span>) } }</code> </pre> <br>  Di sini kita mendefinisikan properti statis <b>maximumActiveRequests</b> di dalam kelas <b>NetworkManager</b> dan menambahkan metode <b>printDebugData ()</b> untuk mencetak properti ini.  Semuanya baik-baik saja di sini, tetapi hanya sampai kami memutuskan untuk mewarisi dari <b>NetworkManager</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThrottledNetworkManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">maximumActiveRequests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br>  Dalam pewaris ini, kita mengubah properti maksimumActiveRequests sehingga sekarang menjadi sama dengan satu, tetapi jika kita memanggil <b>printDebugData ()</b> , itu akan <b>menyimpulkan</b> nilai dari kelas induk: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> manager = <span class="hljs-type"><span class="hljs-type">ThrottledNetworkManager</span></span>() manager.printDebugData()</code> </pre> <br>  Di sini kita harus mendapatkan 1 bukannya 4, dan inilah penyelamatan SE-0068: kita dapat menggunakan <b>Self</b> <u>(dengan</u> huruf <u>kapital 'S')</u> untuk merujuk pada tipe saat ini.  Jadi sekarang kita dapat menulis ulang metode <b>printDebugData ()</b> dari kelas induk seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImprovedNetworkManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">maximumActiveRequests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDebugData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Maximum network requests: \(Self.maximumActiveRequests)."</span></span>) } }</code> </pre> <br>  Yaitu, <b>Self</b> bekerja dengan cara yang sama seperti itu bekerja dalam protokol di versi Swift sebelumnya. <br><br><h3>  Peringatan untuk ambiguitas <b>tidak ada</b> </h3><br>  <b>Opsional</b> di Swift diimplementasikan sebagai enumerasi dengan dua opsi: <b>beberapa</b> dan <b>tidak ada</b> .  Ini dapat menyebabkan kebingungan jika kita membuat enumerasi kita sendiri yang tidak memiliki opsi dan membungkusnya dalam <b>opsional</b> .  Sebagai contoh: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BorderStyle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> solid(thickness: <span class="hljs-type"><span class="hljs-type">Int</span></span>) }</code> </pre> <br>  Saat menggunakan non-opsional, semuanya bersih: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> border1: <span class="hljs-type"><span class="hljs-type">BorderStyle</span></span> = .<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(border1)</code> </pre> <br>  Ini akan menghasilkan "tidak ada".  Tetapi jika kita menggunakan opsional untuk enumerasi ini, maka kita akan menghadapi masalah: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> border2: <span class="hljs-type"><span class="hljs-type">BorderStyle?</span></span> = .<span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(border2)</code> </pre><br>  Nil akan dicetak di sini, karena Swift percaya bahwa .none berarti opsional <u>kosong</u> , meskipun sebenarnya opsional <u>dengan nilai</u> BorderStyle.none. <br>  Dalam Swift 5.1, jika terjadi ambiguitas, peringatan akan ditampilkan: <br>  "Anggap saja maksudmu 'Opsional. Tidak Ada';  Apakah maksud Anda 'BorderStyle.none' bukan? " <br>  Dengan demikian, pengembang akan diberitahu bahwa dengan kodenya tidak semuanya bisa mulus. <br><br><h3>  Pencocokan enumerasi opsional dan non-opsional </h3><br>  Swift cukup pintar untuk memahami konstruksi sakelar / kasus saat menggabungkan teks opsional / non-opsional dan nilai integer, tetapi tidak dalam hal enumerasi. <br><br>  Sekarang di Swift 5.1 kita dapat menggunakan sakelar / kasing untuk mencocokkan opsi enumerasi-opsional dan non-opsional: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildStatus</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> starting <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> inProgress <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> complete } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> status: <span class="hljs-type"><span class="hljs-type">BuildStatus?</span></span> = .inProgress <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> status { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .inProgress: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Build is starting…"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .complete: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Build is complete!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Some other build status"</span></span>) }</code> </pre> <br>  Swift dapat memetakan enumerasi opsional ke opsi non-opsional, dan "Build sedang dimulai ..." akan ditampilkan di sini. <br><br><h3>  Bandingkan koleksi yang dipesan </h3><br>  <a href="">SE-0240</a> memperkenalkan kemampuan untuk menghitung perbedaan antara koleksi yang dipesan, serta menerapkan hasil perbandingan yang dihasilkan untuk koleksi.  Ini mungkin menarik bagi pengembang yang memiliki koleksi kompleks dalam tampilan tabel dan perlu menambah atau menghapus banyak elemen menggunakan animasi. <br><br>  Prinsip dasarnya sederhana - Swift 5.1 menyediakan <b>perbedaan</b> metode baru <b>(dari :)</b> , yang menentukan perbedaan antara dua koleksi berurutan - elemen mana yang akan ditambahkan dan yang akan dihapus.  Ini berlaku untuk semua koleksi yang dipesan yang berisi item yang mematuhi protokol <b>Setara</b> . <br><br>  Untuk mendemonstrasikan ini, kita akan membuat dua array nilai, menghitung perbedaan satu dari yang lain, dan kemudian pergi melalui daftar perbedaan dan menerapkannya untuk membuat dua koleksi sama. <br><br>  Catatan: karena Swift sekarang didistribusikan sebagai bagian dari sistem operasi Apple, alat bahasa baru harus digunakan dengan cek <b>#available</b> untuk memastikan bahwa kode berjalan pada OS yang mendukung fungsi yang diperlukan.  Untuk fungsionalitas yang berjalan pada OS yang tidak dikenal dan tidak diumumkan yang mungkin dirilis di masa mendatang, nomor versi khusus digunakan, "9999", yang berarti: "Kami belum tahu nomor versi yang benar". <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scores1 = [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">91</span></span>, <span class="hljs-number"><span class="hljs-number">95</span></span>, <span class="hljs-number"><span class="hljs-number">98</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scores2 = [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">98</span></span>, <span class="hljs-number"><span class="hljs-number">95</span></span>, <span class="hljs-number"><span class="hljs-number">91</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #available(iOS <span class="hljs-number"><span class="hljs-number">9999</span></span>, *) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> diff = scores2.difference(from: scores1) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> change <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> diff { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> change { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .remove(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset, <span class="hljs-number"><span class="hljs-number">_</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span>): scores1.remove(at: offset) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .insert(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element, <span class="hljs-number"><span class="hljs-number">_</span></span>): scores1.insert(element, at: offset) } } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(scores1) }</code> </pre> <br>  Untuk animasi yang lebih maju, kita bisa menggunakan parameter ketiga di daftar perbedaan yang dihasilkan: <b>relatedWith</b> .  Jadi, alih-alih <b>.insert (biarkan offset, biarkan elemen, _),</b> kita dapat menulis .insert (biarkan offset, biarkan elemen, <b>biarkan terkait Dengan</b> ).  Ini memberi kita kemampuan untuk melacak secara bersamaan pasangan perubahan: memindahkan elemen dalam koleksi dua posisi ke bawah menghapus elemen dan kemudian menambahkannya, dan <b>terkait Dengan</b> "mengikat" kedua perubahan ini bersama-sama dan memungkinkan Anda untuk mempertimbangkan gerakan ini. <br><br>  Alih-alih menerapkan perbedaan secara manual, satu per satu, Anda dapat menerapkannya dalam satu gerakan menggunakan metode <b>penerapan () baru</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #available(iOS <span class="hljs-number"><span class="hljs-number">9999</span></span>, *) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> diff = scores2.difference(from: scores1) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = scores1.applying(diff) ?? [] }</code> </pre> <br><h3>  Membuat Array tidak diinisialisasi </h3><br>  <a href="">SE-0245</a> memperkenalkan penginisialisasi baru untuk array yang tidak mengisinya dengan nilai default.  Itu tersedia sebelumnya sebagai API pribadi, yang berarti bahwa Xcode tidak meminta itu dalam penyelesaian kode, tetapi Anda dapat menggunakannya jika Anda membutuhkannya dan Anda memahami risiko bahwa fungsi ini mungkin tidak di masa depan. <br><br>  Untuk menggunakan penginisialisasi, atur ukuran array, lalu berikan penutup yang mengisi array dengan nilai.  Penutupan akan menerima pointer yang tidak aman ke buffer yang bisa berubah, serta parameter kedua yang menunjukkan berapa banyak nilai yang sebenarnya Anda gunakan. <br><br>  Sebagai contoh, kita dapat membuat array 10 integer acak seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> randomNumbers = <span class="hljs-type"><span class="hljs-type">Array</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;(_unsafeUninitializedCapacity: <span class="hljs-number"><span class="hljs-number">10</span></span>) { buffer, initializedCount <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">10</span></span> { buffer[x] = <span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">10</span></span>) } initializedCount = <span class="hljs-number"><span class="hljs-number">10</span></span> }</code> </pre> <br>  Ada beberapa aturan: <br><br><ol><li>  Anda tidak perlu menggunakan seluruh volume yang Anda minta, tetapi Anda tidak bisa melebihi itu.  Artinya, jika Anda mengatur ukuran array ke 10, maka Anda dapat mengatur <b>initializedCount</b> dalam rentang dari 0 hingga 10, tetapi tidak 11. </li><li>  jika Anda tidak menginisialisasi elemen yang digunakan dalam array, misalnya, Anda menetapkan <b>initializedCount</b> ke 5, tetapi tidak memberikan nilai nyata ke elemen 0 hingga 4, maka mereka kemungkinan besar akan menerima nilai acak.  Seperti yang Anda tahu, ini adalah pilihan yang buruk. </li><li>  Jika Anda tidak menyetel <b>initializedCount</b> , maka itu akan sama dengan 0 dan semua data yang Anda tetapkan akan hilang. </li></ol><br>  Ya, kami dapat menulis ulang kode menggunakan <b>peta ()</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> randomNumbers2 = (<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">9</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">10</span></span>) }</code> </pre> <br>  Ini jelas lebih mudah dibaca, tetapi tidak begitu efektif: kami membuat rentang, lalu array kosong baru, menetapkan ukuran, dan "menelusuri" seluruh rentang, menerapkan penutupan untuk setiap elemen. <br><br><h3>  Kesimpulan </h3><br>  Swift 5.1 masih dalam pengembangan, dan meskipun cabang terakhir untuk Swift sendiri telah berlalu, perubahan dari beberapa proyek terkait lainnya masih terlihat. <br><br>  Jadi, perubahan yang paling penting adalah <b>stabilitas modul</b> , dan diketahui bahwa tim pengembangan bekerja keras dalam hal ini.  Mereka tidak memberikan tanggal rilis yang pasti, meskipun mereka mengatakan bahwa Swift 5.1 memiliki waktu pengembangan yang jauh lebih singkat dibandingkan dengan Swift 5.0, yang membutuhkan konsentrasi energi dan perhatian yang luar biasa.  Kami dapat mengasumsikan akses ke WWDC19, tetapi jelas bahwa ini tidak terjadi ketika Anda perlu bergegas ke tanggal tertentu. <br><br>  Poin lain yang patut diperhatikan.  Dua perubahan pada daftar ini ("Peringatan jika ada ketidakjelasan opsi tidak ada" dan "Pencocokan enumerasi opsional dan non-opsional") bukanlah hasil dari evolusi Swift, tetapi diakui sebagai bug dan disesuaikan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446522/">https://habr.com/ru/post/id446522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446510/index.html">CLRium # 5: Pengumpul Sampah. Workshop NET. Terbesar</a></li>
<li><a href="../id446512/index.html">Pekerja Inti NET sebagai Layanan Windows</a></li>
<li><a href="../id446516/index.html">Visualisasi waktu kelahiran Roshan</a></li>
<li><a href="../id446518/index.html">Firewall aplikasi web</a></li>
<li><a href="../id446520/index.html">Bagaimana semuanya dimulai: kisah drone terbang</a></li>
<li><a href="../id446530/index.html">Word2vec dalam gambar</a></li>
<li><a href="../id446532/index.html">Upwork memperkenalkan biaya untuk hak menulis kepada pelanggan potensial</a></li>
<li><a href="../id446534/index.html">Visual Studio 2019 Dirilis</a></li>
<li><a href="../id446536/index.html">Antrian dan JMeter: Pertukaran dengan Penerbit dan Pelanggan</a></li>
<li><a href="../id446538/index.html">PhotoGuru beralih ke "sisi gelap" dan "lebih bijaksana"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>