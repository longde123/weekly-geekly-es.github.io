<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏻 🚠 🧝🏻 Kasus 5 + 1 di mana spesifikasi REST API memainkan peran besar 👩🏾‍🎨 ⌨️ 🎣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan fokus pada penulisan dan mendukung spesifikasi yang berguna dan relevan untuk proyek REST API, yang akan menghemat banyak kode tambah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kasus 5 + 1 di mana spesifikasi REST API memainkan peran besar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427601/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/b1/dg/ob/b1dgobh5dxfw3q-firfz-77qu-0.png"></div><br><p> Artikel ini akan fokus pada penulisan dan mendukung spesifikasi yang berguna dan relevan untuk proyek REST API, yang akan menghemat banyak kode tambahan, serta secara serius meningkatkan integritas, keandalan, dan transparansi proyek secara keseluruhan. </p><br><h3 id="chto-takoe-restful-api">  Apa itu API tenang? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dde/ee8/857/ddeee88570832b82d7a7ff7231255c3f.png"></div><br><p>  Ini hanya mitos. </p><br><p>  Serius, jika Anda berpikir proyek Anda memiliki API RESTful, Anda hampir pasti salah.  Gagasan RESTful adalah membangun API yang dalam segala hal mematuhi aturan dan batasan arsitektur yang dijelaskan oleh gaya REST, tetapi dalam kondisi nyata hal ini <em>hampir mustahil</em> . </p><a name="habracut"></a><br><p>  Di satu sisi, REST mengandung terlalu banyak definisi yang kabur dan ambigu.  Sebagai contoh, beberapa istilah dari kamus tentang metode HTTP dan kode status tidak digunakan untuk tujuan yang dimaksudkan dalam praktiknya, sementara banyak dari mereka tidak digunakan sama sekali. </p><br><p>  Di sisi lain, REST menciptakan terlalu banyak batasan.  Sebagai contoh, penggunaan sumber daya atom di dunia nyata tidak rasional untuk API yang digunakan oleh aplikasi seluler.  Penolakan lengkap untuk menyimpan status di antara permintaan pada dasarnya adalah larangan mekanisme sesi pengguna yang digunakan di banyak API. </p><br><p>  <strong>Tapi tunggu, tidak semuanya begitu buruk!</strong> </p><br><h3 id="zachem-nuzhna-specifikaciya-rest-api">  Mengapa kita memerlukan spesifikasi REST API? </h3><br><p>  Terlepas dari kekurangan ini, dengan pendekatan yang masuk akal, REST tetap menjadi dasar yang sangat baik untuk merancang API yang sangat keren.  API semacam itu harus memiliki keseragaman internal, struktur yang jelas, dokumentasi yang nyaman dan cakupan uji unit yang baik.  Semua ini dapat dicapai dengan mengembangkan <strong>spesifikasi</strong> kualitas untuk API Anda. </p><br><p>  Paling sering, <em>spesifikasi</em> REST API dikaitkan dengan <em>dokumentasinya</em> .  Berbeda dengan yang pertama (yang merupakan deskripsi formal API Anda), dokumentasi ini dimaksudkan untuk dibaca oleh orang-orang: misalnya, pengembang aplikasi seluler atau web menggunakan API Anda. </p><br><p>  Namun, selain benar-benar membuat dokumentasi, deskripsi API yang tepat masih dapat membawa banyak manfaat.  Dalam artikel ini saya ingin berbagi contoh bagaimana, dengan menggunakan spesifikasi yang kompeten, Anda dapat: </p><br><ul><li>  membuat pengujian unit lebih sederhana dan lebih dapat diandalkan; </li><li>  mengkonfigurasi preprocessing dan validasi data input; </li><li>  mengotomatiskan serialisasi dan memastikan integritas respons; </li><li>  dan bahkan memanfaatkan pengetikan statis. </li></ul><br><h3 id="openapi">  Openapi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/222/aae/af9/222aaeaf95adf9cb50af1ed7702d4c9b.png" width="500"></div><br><p>  Format yang diterima secara umum untuk menggambarkan API REST hari ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>OpenAPI</strong></a> , yang juga dikenal sebagai <em>Swagger</em> .  Spesifikasi ini adalah satu file dalam format JSON atau YAML, yang terdiri dari tiga bagian: </p><br><ul><li>  header yang berisi nama, deskripsi, dan versi API, serta informasi tambahan; </li><li>  deskripsi semua sumber daya, termasuk pengidentifikasi, metode HTTP, semua parameter input, serta kode dan format badan respons, dengan tautan ke definisi; </li><li>  semua definisi objek dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Skema JSON</strong></a> yang dapat digunakan baik dalam parameter input maupun respons. </li></ul><br><p>  OpenAPI memiliki kelemahan serius - <em>kompleksitas struktur dan, seringkali, redundansi</em> .  Untuk proyek kecil, isi file spesifikasi JSON dapat dengan cepat tumbuh hingga beberapa ribu baris.  File ini tidak mungkin disimpan secara manual dalam formulir ini.  Ini adalah ancaman serius terhadap gagasan mempertahankan spesifikasi terbaru saat API berevolusi. </p><br><p>  Ada banyak editor visual yang memungkinkan Anda untuk menggambarkan API dan membentuk spesifikasi OpenAPI yang dihasilkan.  Pada gilirannya, layanan tambahan dan solusi cloud didasarkan pada mereka, misalnya, <em>Swagger</em> , <em>Apiary</em> , <em>Stoplight</em> , <em>Restlet,</em> dan lainnya. </p><br><p>  Namun, bagi saya, layanan seperti itu sangat tidak nyaman karena sulitnya mengedit spesifikasi dan menggabungkannya dengan proses penulisan kode.  Minus lainnya adalah ketergantungan pada set fungsi masing-masing layanan tertentu.  Sebagai contoh, hampir tidak mungkin untuk mengimplementasikan pengujian unit lengkap hanya melalui layanan cloud.  Pembuatan kode dan bahkan pembuatan "colokan" untuk titik akhir, meskipun tampaknya sangat mungkin, praktis tidak berguna dalam praktiknya. </p><br><h3 id="tinyspec">  Tinyspec </h3><br><p>  Pada artikel ini, saya akan menggunakan contoh berdasarkan format deskripsi REST API asli - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>tinyspec</strong></a> .  Formatnya adalah file kecil yang menggambarkan titik akhir dan model data yang digunakan dalam proyek dengan sintaks yang intuitif.  File disimpan di sebelah kode, yang memungkinkan Anda untuk memeriksanya dan mengeditnya tepat saat proses penulisan.  Pada saat yang sama, tinyspec secara otomatis dikompilasi menjadi OpenAPI yang lengkap, yang dapat segera digunakan dalam proyek.  Saatnya untuk memberi tahu Anda bagaimana tepatnya. </p><br><p>  Dalam artikel ini, saya akan memberikan contoh dari Node.js (koa, express) dan Ruby on Rails, meskipun praktik ini berlaku untuk sebagian besar teknologi, termasuk Python, PHP, dan Java. </p><br><h2 id="kogda-eschyo-specifikaciya-okazyvaetsya-neveroyatno-poleznoy">  Ketika spec sangat berguna </h2><br><h3 id="1-unit-testy-endpointov">  1. Tes unit titik akhir </h3><br><p>  <em>Pengembangan yang didorong oleh perilaku (BDD) sangat</em> ideal untuk mengembangkan REST API.  Cara yang paling mudah untuk menulis tes unit bukan untuk kelas individu, model dan pengontrol, tetapi untuk titik akhir tertentu.  Di setiap pengujian, Anda meniru permintaan HTTP nyata dan memeriksa respons server.  Di Node.js, untuk meniru permintaan tes, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">supertest</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://www.chaijs.com/plugins/chai-">chai-http</a> , di Ruby on Rails - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">airborne</a> . </p><br><p> Misalkan kita memiliki skema <code>User</code> dan titik akhir <code>GET /users</code> yang mengembalikan semua pengguna.  Berikut adalah sintaksis tinyspec yang menjelaskan ini: </p><br><ol><li>  File <em>User.models.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">User {name, isAdmin: b, age?: i}</code> </pre> <br><ol><li>  File <em>users.endpoints.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">GET /users =&gt; {users: User[]}</code> </pre> <br><p>  Begini tampilan pengujian kami: </p><br><h4 id="nodejs">  Node.js </h4><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].name).to.be(<span class="hljs-string"><span class="hljs-string">'string'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].isAdmin).to.be(<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].age).to.be.oneOf([<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>]); }); });</code> </pre> <br><h4 id="ruby-on-rails">  Ruby on Rails </h4><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect_json_types(<span class="hljs-string"><span class="hljs-string">'users.*'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">isAdmin:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:boolean</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:integer_or_null</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Saat kami memiliki spesifikasi yang menjelaskan format respons server, kami dapat menyederhanakan pengujian dan cukup <em>memeriksa respons terhadap spesifikasi ini</em> .  Untuk melakukan ini, kami akan mengambil keuntungan dari fakta bahwa model tinyspec kami diubah menjadi definisi OpenAPI, yang pada gilirannya sesuai dengan format Skema JSON. </p><br><p>  <em>Objek literal apa pun</em> di JS (atau <code>Hash</code> di Ruby, <code>dict</code> dengan Python, <em>array asosiatif</em> dalam PHP, dan bahkan <code>Map</code> di Jawa) dapat diuji kepatuhannya dengan skema JSON.  Dan bahkan ada plugin yang sesuai untuk kerangka pengujian, misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jest-ajv</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chai-ajv-json-schema</a> (npm) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">json_matchers</a> (rubygem) untuk RSpec. </p><br><p>  Sebelum menggunakan skema, Anda harus menghubungkannya ke proyek.  Pertama, kita akan membuat file spesifikasi openapi.json berdasarkan tinyspec (tindakan ini dapat secara otomatis dilakukan sebelum setiap percobaan dijalankan): </p><br><pre> <code class="bash hljs">tinyspec -j -o openapi.json</code> </pre> <br><h4 id="nodejs-1">  Node.js </h4><br><p>  Sekarang kita dapat menggunakan JSON yang diterima dalam proyek dan mengambil kunci <code>definitions</code> darinya, yang berisi semua skema JSON.  Skema dapat berisi referensi silang ( <code>$ref</code> ), oleh karena itu, jika kita memiliki skema bersarang (misalnya, <code>Blog {posts: Post[]}</code> ), maka kita perlu "memperluas" mereka untuk menggunakannya dalam validasi.  Untuk melakukan ini, kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">json-schema-deref-sync</a> (npm). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deref <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'json-schema-deref-sync'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spec = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./openapi.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schemas = deref(spec).definitions; describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Chai expect(users[0]).to.be.validWithSchema(schemas.User); // Jest expect(users[0]).toMatchSchema(schemas.User); }); });</span></span></code> </pre> <br><h4 id="ruby-on-rails-1">  Ruby on Rails </h4><br><p>  <code>json_matchers</code> dapat menangani <code>$ref</code> links, tetapi membutuhkan file terpisah dengan skema dalam sistem file dengan cara tertentu, jadi pertama-tama Anda harus "membagi" <code>swagger.json</code> menjadi banyak file kecil (lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ): </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./spec/support/json_schemas.rb require 'json' require 'json_matchers/rspec' JsonMatchers.schema_root = 'spec/schemas' # Fix for json_matchers single-file restriction file = File.read 'spec/schemas/openapi.json' swagger = JSON.parse(file, symbolize_names: true) swagger[:definitions].keys.each do |key| File.open("spec/schemas/#{key}.json", 'w') do |f| f.write(JSON.pretty_generate({ '$ref': "swagger.json#/definitions/#{key}" })) end end</span></span></code> </pre> <br><p>  Setelah itu, kita dapat menulis tes kita seperti ini: </p><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect(result[<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]).to match_json_schema(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Catatan: menulis tes dengan cara ini sangat nyaman.  Terutama jika IDE Anda mendukung tes yang sedang berjalan dan debugging (seperti WebStorm, RubyMine, dan Visual Studio).  Dengan demikian, Anda tidak dapat menggunakan perangkat lunak lain sama sekali, dan seluruh siklus pengembangan API dikurangi menjadi 3 langkah berturut-turut: </p><br><ol><li>  desain spesifikasi (mis. dalam tinyspec); </li><li>  menulis serangkaian tes lengkap untuk titik akhir yang ditambahkan / diubah; </li><li>  mengembangkan kode yang memenuhi semua tes. </li></ol><br><h3 id="2-validaciya-vhodnyh-dannyh">  2. Validasi input </h3><br><p>  OpenAPI menggambarkan format tidak hanya tanggapan, tetapi juga memasukkan data.  Ini memungkinkan kami untuk <em>memvalidasi data yang</em> diterima dari pengguna saat permintaan. </p><br><p>  Misalkan kita memiliki spesifikasi berikut yang menjelaskan pembaruan data pengguna, serta semua bidang yang dapat diubah: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># user.models.tinyspec UserUpdate !{name?, age?: i} # users.endpoints.tinyspec PATCH /users/:id {user: UserUpdate} =&gt; {success: b}</span></span></code> </pre> <br><p>  Sebelumnya kami melihat plugin untuk validasi di dalam tes, namun untuk kasus yang lebih umum ada modul validasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ajv</a> (npm) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">json-schema</a> (rubygem), mari kita gunakan dan tulis controller dengan validasi. </p><br><h4 id="nodejs-koa">  Node.js (Koa) </h4><br><p>  Ini adalah contoh untuk <strong>Koa</strong> , penerus Express, tetapi untuk Express, kodenya akan terlihat serupa. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ajv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ajv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); <span class="hljs-comment"><span class="hljs-comment">// Standard resource update action in Koa. router.patch('/:id', async (ctx) =&gt; { const updateData = ctx.body.user; // Validation using JSON schema from API specification. await validate(schemas.UserUpdate, updateData); const user = await User.findById(ctx.params.id); await user.update(updateData); ctx.body = { success: true }; }); async function validate(schema, data) { const ajv = new Ajv(); if (!ajv.validate(schema, data)) { const err = new Error(); err.errors = ajv.errors; throw err; } }</span></span></code> </pre> <br><p>  Dalam contoh ini, jika data input tidak memenuhi spesifikasi, server akan mengembalikan respons <code>500 Internal Server Error</code> kepada klien.  Untuk mencegah hal ini terjadi, kami dapat mencegat kesalahan validator dan membentuk respons kami sendiri, yang akan berisi informasi lebih rinci tentang bidang tertentu yang belum lulus tes, dan juga <em>mematuhi spesifikasi</em> . </p><br><p>  Tambahkan deskripsi model <code>FieldsValidationError</code> di file <code>FieldsValidationError</code> : </p><br><pre> <code class="python hljs">Error {error: b, message} InvalidField {name, message} FieldsValidationError &lt; Error {fields: InvalidField[]}</code> </pre> <br><p>  Dan sekarang kami menunjukkannya sebagai salah satu jawaban yang mungkin dari titik akhir kami: </p><br><pre> <code class="python hljs">PATCH /users/:id {user: UserUpdate} =&gt; <span class="hljs-number"><span class="hljs-number">200</span></span> {success: b} =&gt; <span class="hljs-number"><span class="hljs-number">422</span></span> FieldsValidationError</code> </pre> <br><p>  Pendekatan ini akan memungkinkan Anda untuk menulis unit test yang memverifikasi kebenaran pembentukan kesalahan dengan data yang salah diterima dari klien. </p><br><h3 id="3-serializaciya-modeley">  3. Serialisasi model </h3><br><p>  Hampir semua kerangka kerja server modern menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ORM dengan satu</a> atau lain cara.  Ini berarti bahwa sebagian besar sumber daya yang digunakan dalam API di dalam sistem disajikan dalam bentuk model, instans dan koleksi mereka. </p><br><p>  Proses menghasilkan representasi JSON dari entitas ini untuk transmisi dalam respons API disebut <em>serialisasi</em> .  Ada beberapa plugin untuk kerangka kerja berbeda yang melakukan fungsi serialisasi, misalnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sequelize-to-json</a> (npm), act_as_api (rubygem), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsonapi-rails</a> (rubygem).  Bahkan, plugin ini memungkinkan model tertentu untuk menentukan daftar bidang yang harus dimasukkan dalam objek JSON, serta aturan tambahan, misalnya, untuk mengganti nama atau secara dinamis menghitung nilai. </p><br><p>  Kesulitan dimulai ketika kita perlu memiliki beberapa representasi JSON berbeda dari model yang sama atau ketika suatu objek berisi entitas bersarang - asosiasi.  Ada kebutuhan untuk <em>pewarisan, penggunaan kembali, dan penautan serialis</em> . </p><br><p>  Modul yang berbeda menyelesaikan masalah ini dengan cara yang berbeda, tetapi mari kita berpikir, dapatkah spesifikasi membantu kita lagi?  Memang, pada kenyataannya, semua informasi tentang persyaratan untuk representasi JSON, semua kemungkinan kombinasi bidang, termasuk entitas bersarang, sudah ada di dalamnya.  Jadi kita bisa menulis serializer otomatis. </p><br><p>  Saya membawa perhatian Anda pada modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekuel-serialisasi kecil</a> (npm), yang memungkinkan Anda melakukan ini untuk model Sequelize.  Ini mengambil contoh dari model atau array, serta sirkuit yang diperlukan, dan iteratif membangun objek serial, dengan mempertimbangkan semua bidang yang diperlukan dan menggunakan sirkuit bersarang untuk entitas terkait. </p><br><p>  Jadi, anggaplah kita harus kembali dari API semua pengguna yang memiliki posting blog, termasuk komentar pada posting tersebut.  Kami menggambarkan ini menggunakan spesifikasi berikut: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.tinyspec Comment {authorId: i, message} Post {topic, message, comments?: Comment[]} User {name, isAdmin: b, age?: i} UserWithPosts &lt; User {posts: Post[]} # blogUsers.endpoints.tinyspec GET /blog/users =&gt; {users: UserWithPosts[]}</span></span></code> </pre> <br><p>  Sekarang kita dapat membangun kueri menggunakan Sequelize dan mengembalikan objek berseri yang sama persis dengan spesifikasi yang baru saja dijelaskan di atas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> serialize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sequelize-serialize'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/blog/users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> User.findAll({ <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">association</span></span>: User.posts, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [Post.comments] }] }); ctx.body = serialize(users, schemas.UserWithPosts); });</code> </pre> <br><p>  Ini hampir ajaib, bukan? </p><br><h3 id="4-staticheskaya-tipizaciya">  4. Pengetikan statis </h3><br><p>  Jika Anda sangat keren sehingga Anda menggunakan TypeScript atau Flow, Anda mungkin sudah bertanya-tanya, <em>"Bagaimana dengan tipe statis tersayang?!"</em>  .  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul sw2dts</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">swagger</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-to-flowtype,</a> Anda dapat menghasilkan semua definisi yang diperlukan berdasarkan skema JSON dan menggunakannya untuk mengetik tes statis, input data dan serializer. </p><br><pre> <code class="bash hljs">tinyspec -j sw2dts ./swagger.json -o Api.d.ts --namespace Api</code> </pre> <br><p>  Sekarang kita bisa menggunakan tipe di controller: </p><br><pre> <code class="hljs pgsql">router.patch(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>, async (ctx) =&gt; { // Specify <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request data <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> const userData: Api.UserUpdate = ctx.request.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; // Run spec validation await <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.UserUpdate, userData); // Query the <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = await <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.findById(ctx.params.id); await <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(userData); // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> serialized result const serialized: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = serialize(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); ctx.body = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: serialized }; });</code> </pre> <br><p>  Dan dalam tes: </p><br><pre> <code class="hljs pgsql">it(<span class="hljs-string"><span class="hljs-string">'Update user'</span></span>, async () =&gt; { // Static <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> data. const updateData: Api.UserUpdate = { <span class="hljs-type"><span class="hljs-type">name</span></span>: MODIFIED }; const res = await request.patch(<span class="hljs-string"><span class="hljs-string">'/users/1'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: updateData }); // <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> helper <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request response: const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = res.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.be.validWithSchema(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.containSubset(updateData); });</code> </pre> <br><p>  Harap perhatikan bahwa definisi tipe yang dihasilkan dapat digunakan tidak hanya dalam proyek API itu sendiri, tetapi juga dalam proyek aplikasi klien untuk menggambarkan jenis fungsi di mana API bekerja.  Pengembang pelanggan angular akan sangat senang dengan hadiah ini. </p><br><h3 id="5-privedenie-tipov-query-string">  5. Ketikkan konversi string kueri </h3><br><p>  Jika karena alasan tertentu API Anda menerima permintaan dengan jenis <code>application/x-www-form-urlencoded</code> MIME <code>application/x-www-form-urlencoded</code> dan bukan <code>application/json</code> , badan permintaan akan terlihat seperti ini: </p><br><pre> <code class="python hljs">param1=value&amp;param2=<span class="hljs-number"><span class="hljs-number">777</span></span>&amp;param3=false</code> </pre> <br><p>  Hal yang sama berlaku untuk parameter kueri (misalnya, dalam permintaan GET).  Dalam hal ini, server web tidak akan dapat mengenali jenis secara otomatis - semua data akan berada dalam bentuk string (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini ada diskusi</a> dalam repositori modul qpm npm), jadi setelah parsing Anda akan mendapatkan objek berikut: </p><br><pre> <code class="python hljs">{ param1: <span class="hljs-string"><span class="hljs-string">'value'</span></span>, param2: <span class="hljs-string"><span class="hljs-string">'777'</span></span>, param3: <span class="hljs-string"><span class="hljs-string">'false'</span></span> }</code> </pre> <br><p>  Dalam hal ini, permintaan tidak akan divalidasi sesuai dengan skema, yang berarti bahwa perlu secara manual memverifikasi bahwa setiap parameter memiliki format yang benar dan membawanya ke jenis yang diperlukan. </p><br><p>  Seperti yang Anda duga, ini dapat dilakukan dengan menggunakan semua skema yang sama dari spesifikasi kami.  Bayangkan kita memiliki titik akhir dan skema seperti itu: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># posts.endpoints.tinyspec GET /posts?PostsQuery # post.models.tinyspec PostsQuery { search, limit: i, offset: i, filter: { isRead: b } }</span></span></code> </pre> <br><p>  Berikut adalah contoh permintaan ke titik akhir tersebut </p><br><pre> <code class="python hljs">GET /posts?search=needle&amp;offset=<span class="hljs-number"><span class="hljs-number">10</span></span>&amp;limit=<span class="hljs-number"><span class="hljs-number">1</span></span>&amp;filter[isRead]=true</code> </pre> <br><p>  Mari kita menulis fungsi <code>castQuery</code> , yang akan <code>castQuery</code> semua parameter ke tipe yang diperlukan untuk kita.  Akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">castQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query, schema</span></span></span><span class="hljs-function">) </span></span>{ _.mapValues(query, (value, key) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type } = schema.properties[key] || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value || !type) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'integer'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-string"><span class="hljs-string">'false'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }); }</code> </pre> <br><p>  Implementasinya yang lebih lengkap dengan dukungan untuk skema bersarang, array, dan tipe <code>null</code> tersedia dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema cast-with-schema</a> (npm).  Sekarang kita dapat menggunakannya dalam kode kita: </p><br><pre> <code class="javascript hljs">router.get(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// Cast parameters to expected types const query = castQuery(ctx.query, schemas.PostsQuery); // Run spec validation await validate(schemas.PostsQuery, query); // Query the database const posts = await Post.search(query); // Return serialized result ctx.body = { posts: serialize(posts, schemas.Post) }; });</span></span></code> </pre> <br><p>  Perhatikan bagaimana dari empat baris kode titik akhir, tiga skema penggunaan dari spesifikasi. </p><br><h2 id="luchshie-praktiki">  Praktik terbaik </h2><br><h3 id="otdelnye-shemy-dlya-sozdaniya-i-izmeneniya">  Skema terpisah untuk membuat dan memodifikasi </h3><br><p>  Biasanya, skema yang menggambarkan respons server berbeda dari skema yang menggambarkan input yang digunakan untuk membuat dan memodifikasi model.  Misalnya, daftar bidang yang tersedia untuk permintaan <code>POST</code> dan <code>PATCH</code> harus dibatasi secara ketat, sedangkan dalam permintaan <code>PATCH</code> , biasanya semua bidang skema dibuat opsional.  Skema yang menentukan jawabannya mungkin lebih gratis. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generasi</a> otomatis titik akhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tinyspec CRUDL</a> menggunakan postfix <code>New</code> dan <code>Update</code> .  <code>User*</code> dapat didefinisikan sebagai berikut: </p><br><pre> <code class="python hljs">User {id, email, name, isAdmin: b} UserNew !{email, name} UserUpdate !{email?, name?}</code> </pre> <br><p>  Cobalah untuk tidak menggunakan skema yang sama untuk berbagai jenis tindakan untuk menghindari masalah keamanan yang tidak disengaja karena penggunaan kembali atau warisan skema lama. </p><br><h3 id="semantika-v-nazvaniyah-shem">  Semantik dalam nama skema </h3><br><p>  Isi dari model yang sama dapat bervariasi di titik akhir yang berbeda.  Gunakan postfix <code>With*</code> dan <code>For*</code> dalam nama skema untuk menunjukkan bagaimana mereka berbeda dan untuk apa mereka.  Dalam model tinyspec juga dapat diwarisi dari satu sama lain.  Sebagai contoh: </p><br><pre> <code class="python hljs">User {name, surname} UserWithPhotos &lt; User {photos: Photo[]} UserForAdmin &lt; User {id, email, lastLoginAt: d}</code> </pre> <br><p>  Postfix dapat bervariasi dan dikombinasikan.  Yang utama adalah bahwa nama mereka mencerminkan esensi dan menyederhanakan keakraban dengan dokumentasi. </p><br><h3 id="razdelenie-endpointov-po-tipu-klienta">  Pemisahan titik akhir berdasarkan jenis klien </h3><br><p>  Seringkali titik akhir yang sama mengembalikan data yang berbeda tergantung pada jenis klien atau peran pengguna yang mengakses titik akhir.  Misalnya, titik akhir <code>GET /users</code> dan <code>GET /messages</code> bisa sangat berbeda untuk pengguna aplikasi seluler Anda dan untuk manajer back office.  Pada saat yang sama, mengubah nama titik akhir itu sendiri bisa menjadi terlalu rumit. </p><br><p>  Untuk menggambarkan titik akhir yang sama beberapa kali, Anda bisa menambahkan tipenya dalam tanda kurung setelah jalur.  Selain itu, berguna untuk menggunakan tag: ini akan membantu untuk membagi dokumentasi titik akhir Anda menjadi grup, yang masing-masing akan dirancang untuk kelompok klien tertentu dari API Anda.  Sebagai contoh: </p><br><pre> <code class="python hljs">Mobile app: GET /users (mobile) =&gt; UserForMobile[] CRM admin panel: GET /users (admin) =&gt; UserForAdmin[]</code> </pre> <br><h2 id="dokumentaciya-rest-api">  Dokumentasi API SISA </h2><br><p>  Setelah Anda memiliki spesifikasi dalam format tinyspec atau OpenAPI, Anda dapat menghasilkan dokumentasi yang indah dalam HTML dan menerbitkannya untuk menyenangkan pengembang yang menggunakan API Anda. </p><br><p>  Selain layanan cloud yang disebutkan sebelumnya, ada alat CLI yang mengonversi OpenAPI 2.0 ke HTML dan PDF, setelah itu Anda dapat mengunduhnya ke hosting statis apa pun.  Contoh: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bootprint-openapi</a> (npm, digunakan secara default di tinyspec) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">swagger2markup-cli</a> (jar, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh penggunaan</a> , itu akan digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud Tinyspec</a> ) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">redoc-cli</a> (npm) </li><li>  widdershins (npm) </li></ul><br><p>  <em>Apakah Anda tahu lebih banyak contoh?</em>  <em>Bagikan di komentar.</em> </p><br><p>  Sayangnya, OpenAPI 3.0, dirilis setahun yang lalu, masih kurang didukung, dan saya tidak dapat menemukan contoh dokumentasi yang layak berdasarkan itu: baik di antara solusi cloud, maupun di antara alat CLI.  Untuk alasan yang sama, OpenAPI 3.0 belum didukung di tinyspec. </p><br><h3 id="publikaciya-v-github">  Terbitkan ke GitHub </h3><br><p>  Salah satu cara termudah untuk menerbitkan dokumentasi adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub Pages</a> .  Cukup aktifkan dukungan halaman statis untuk direktori <code>/docs</code> di pengaturan repositori Anda dan simpan dokumentasi HTML di folder ini. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/09b/5ad/775/09b5ad7757239f4405cb370cb59c6a7b.png"></p><br><p>  Anda dapat menambahkan perintah untuk menghasilkan dokumentasi melalui tinyspec atau alat CLI lain dalam <code>scripts</code> di <code>package.json</code> dan memperbarui dokumentasi dengan setiap komit: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"docs"</span></span>: <span class="hljs-string"><span class="hljs-string">"tinyspec -h -o docs/"</span></span>, <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run docs"</span></span> }</code> </pre> <br><h3 id="continuous-integration">  Integrasi berkelanjutan </h3><br><p>  Anda dapat memasukkan pembuatan dokumentasi dalam siklus CI dan mempublikasikannya, misalnya, di Amazon S3 di bawah alamat yang berbeda tergantung pada lingkungan atau versi API Anda, misalnya: / <code>/docs/2.0</code> <code>/docs/stable</code> <code>/docs/2.0</code> , <code>/docs/stable</code> , <code>/docs/staging</code> . </p><br><h3 id="tinyspec-cloud">  Awan Tinyspec </h3><br><p>  Jika Anda menyukai sintaks tinyspec, Anda dapat mendaftar sebagai pengadopsi awal di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tinyspec.cloud</a> .  Kami akan membangun berdasarkan layanan cloud dan CLI untuk publikasi otomatis dokumentasi dengan beragam pilihan templat dan kemampuan untuk mengembangkan templat kami sendiri. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Mengembangkan REST API mungkin merupakan aktivitas paling menyenangkan dari semua yang ada dalam proses bekerja di web modern dan layanan seluler.  Tidak ada kebun binatang peramban, sistem operasi dan ukuran layar, semuanya sepenuhnya berada di bawah kendali kami - "di ujung jari Anda". </p><br><p>  Mempertahankan spesifikasi dan bonus saat ini dalam bentuk berbagai otomatisasi, yang disediakan secara bersamaan, menjadikan proses ini semakin menyenangkan.  API semacam itu menjadi terstruktur, transparan, dan andal. </p><br><p>  <em>Sebenarnya, bahkan, jika kita terlibat dalam penciptaan mitos, lalu mengapa kita tidak menjadikannya indah?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427601/">https://habr.com/ru/post/id427601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427587/index.html">Jawa terkonsentrasi untuk satu setengah ribu orang. Bagaimana Joker 2018</a></li>
<li><a href="../id427589/index.html">Kami menulis obrolan online di Websockets menggunakan Swoole</a></li>
<li><a href="../id427591/index.html">Arsitektur sebagai beban</a></li>
<li><a href="../id427593/index.html">Magic Perintah Cepat di Vivaldi 2.1</a></li>
<li><a href="../id427595/index.html">Coba Micronaut atau Sayang, saya mengurangi kerangka</a></li>
<li><a href="../id427603/index.html">Cara akhirnya mulai menulis tes dan tidak menyesalinya</a></li>
<li><a href="../id427605/index.html">Bagaimana platform crowdsourcing Yandex membantu melatih drone dan mengevaluasi kualitas layanan</a></li>
<li><a href="../id427607/index.html">Datacenter di Swiss: bekerja seperti jarum jam</a></li>
<li><a href="../id427609/index.html">Memecahkan persamaan dengan pembagian integer tanpa kekuatan kasar</a></li>
<li><a href="../id427611/index.html">Kisah bagaimana saya memperbarui Yandex MapKit di iOS atau peta, uang, 2 pemetaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>