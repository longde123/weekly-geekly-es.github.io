<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äç‚úàÔ∏è üë®üèª‚Äçüî¨ üí∑ Reator, WebFlux, Kotlin Coroutines ou Assincronia com um exemplo simples üö≤ üì∂ üèáüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muitos servi√ßos no mundo moderno, na maioria das vezes, "n√£o fazem nada". Suas tarefas s√£o reduzidas a solicita√ß√µes de outros bancos de dados / servi√ß...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reator, WebFlux, Kotlin Coroutines ou Assincronia com um exemplo simples</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/477052/"><img src="https://habrastorage.org/webt/oc/vm/jy/ocvmjybd42pjwnaqjaxeyz_dxlo.png"><br><br><p>  Muitos servi√ßos no mundo moderno, na maioria das vezes, "n√£o fazem nada".  Suas tarefas s√£o reduzidas a solicita√ß√µes de outros bancos de dados / servi√ßos / caches e agrega√ß√£o de todos esses dados de acordo com v√°rias regras e l√≥gica de neg√≥cios.  Portanto, n√£o √© de surpreender que idiomas como o Golang apare√ßam, com um sistema competitivo embutido conveniente que facilita a organiza√ß√£o de c√≥digos sem bloqueio. </p><br><p>  No mundo da JVM, as coisas s√£o um pouco mais complicadas.  H√° um grande n√∫mero de estruturas e bibliotecas que bloqueiam threads quando usadas.  Portanto, o pr√≥prio stdlib pode fazer a mesma coisa √†s vezes.  E em Java n√£o h√° mecanismo semelhante √†s goroutines em Golang. </p><br><p>  No entanto, a JVM est√° se desenvolvendo ativamente e novas oportunidades interessantes aparecem.  Existe o Kotlin com corotinas, que em seu uso s√£o muito semelhantes √†s goroutinas Gorang (embora elas sejam implementadas de uma maneira completamente diferente).  Existe o JEP Loom, que trar√° fibras para a JVM no futuro.  Uma das estruturas da Web mais populares - Spring - recentemente adicionou a capacidade de criar servi√ßos completamente sem bloqueio no Webflux.  E com o recente lan√ßamento do Spring boot 2.2, a integra√ß√£o com o Kotlin √© ainda melhor. </p><br><p>  Proponho, usando o exemplo de um pequeno servi√ßo para transferir dinheiro de um cart√£o para outro, escrever um aplicativo no Spring boot 2.2 e no Kotlin para integra√ß√£o com v√°rios servi√ßos externos. </p><a name="habracut"></a><br><p>  √â bom que voc√™ j√° esteja familiarizado com Java, Kotlin, Gradle, Spring, Spring boot 2, Reator, <s>fluxo da</s> Web <s>, Tomcat, Netty, Kotlin ororines, Gradle Kotlin DSL ou mesmo tenha um doutorado.</s>  Mas se n√£o, isso n√£o importa.  O c√≥digo ser√° simplificado ao m√°ximo e, mesmo que voc√™ n√£o seja do mundo da JVM, espero que tudo fique claro para voc√™. </p><br><p>  Se voc√™ planeja escrever um servi√ßo, verifique se tudo o que voc√™ precisa est√° instalado: </p><br><ul><li>  Java 8+ </li><li>  Docker e Docker Compose; </li><li>  cURL e preferencialmente <a href="https://stedolan.github.io/jq/download/">jq</a> ; </li><li>  Git </li><li>  de prefer√™ncia um IDE para Kotlin (Intellij Idea, Eclipse, VS, <s>vim</s> etc.).  Mas √© poss√≠vel em um notebook. </li></ul><br><p>  Os exemplos conter√£o os dois espa√ßos em branco para a implementa√ß√£o no servi√ßo e uma implementa√ß√£o j√° escrita.  Primeiro, execute a instala√ß√£o e montagem e observe mais de perto os servi√ßos e suas APIs. </p><br><blockquote> O exemplo de servi√ßos e a pr√≥pria API s√£o feitos apenas para fins ilustrativos; n√£o transfira tudo <code>AS IS</code> para o seu produto! </blockquote><p>  Primeiro, clonamos o reposit√≥rio com servi√ßos para n√≥s mesmos, a integra√ß√£o com a qual faremos isso e vamos para o diret√≥rio: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/spring-demo-services &amp;&amp; cd spring-demo-services</code> </pre> <br><p>  Em um terminal separado, coletamos todos os aplicativos usando <code>gradle</code> , onde, ap√≥s uma compila√ß√£o bem-sucedida, todos os servi√ßos ser√£o lan√ßados usando o <code>docker-compose</code> . </p><br><pre> <code class="plaintext hljs">./gradlew build &amp;&amp; docker-compose up</code> </pre> <br><p>  Enquanto tudo √© baixado e instalado, considere um projeto com servi√ßos. </p><br><img src="https://habrastorage.org/webt/go/mp/mb/gompmbrgtjwsuz9pnpbaxbuksg8.png"><br><p>  Uma solicita√ß√£o com um token, n√∫mero de cart√£o para transfer√™ncia e a quantia a ser transferida entre cart√µes ser√° recebida na entrada do servi√ßo (servi√ßo de demonstra√ß√£o): </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"authToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"auth-token1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardFrom"</span></span>: <span class="hljs-string"><span class="hljs-string">"55593478"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardTo"</span></span>: <span class="hljs-string"><span class="hljs-string">"55592020"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"amount"</span></span>: <span class="hljs-string"><span class="hljs-string">"10.1"</span></span> }</code> </pre> <br><p>  De acordo com o token <code>authToken</code> , <code>authToken</code> precisa acessar o servi√ßo <code>AUTH</code> e obter <code>userId</code> , com o qual pode fazer uma solicita√ß√£o ao <code>USER</code> e extrair todas as informa√ß√µes adicionais sobre o usu√°rio.  <code>AUTH</code> tamb√©m retornar√° informa√ß√µes sobre quais dos tr√™s servi√ßos podemos acessar.  Resposta de amostra de <code>AUTH</code> : </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"userId"</span></span>: <span class="hljs-number"><span class="hljs-number">158</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"paymentAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"userAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Para transferir entre cart√µes, v√° primeiro com cada n√∫mero de cart√£o no <code>CARD</code> .  Em resposta a solicita√ß√µes, receberemos <code>cardId</code> ; em seguida, enviaremos uma solicita√ß√£o para <code>PAYMENT</code> e faremos uma transfer√™ncia.  E a √∫ltima - mais uma vez, enviamos uma solicita√ß√£o para <code>PAYMENT</code> com <code>fromCardId</code> e descobrimos o saldo atual. </p><br><p>  Para emular um pequeno atraso nos servi√ßos, o valor da vari√°vel de ambiente TIMEOUT √© lan√ßado em todos os cont√™ineres, nos quais o atraso da resposta √© definido em milissegundos.  E para diversificar as respostas do <code>AUTH</code> , √© poss√≠vel variar o valor de <code>SUCCESS_RATE</code> , que controla a probabilidade de uma resposta <code>true</code> para o servi√ßo. </p><br><p>  Arquivo Docker-compose.yaml: </p><br><pre> <code class="plaintext hljs">version: '3' services: service-auth: build: service-auth image: service-auth:1.0.0 environment: - SUCCESS_RATE=1.0 - TIMEOUT=100 ports: - "8081:8080" service-card: build: service-card image: service-card:1.0.0 environment: - TIMEOUT=100 ports: - "8082:8080" service-payment: build: service-payment image: service-payment:1.0.0 environment: - TIMEOUT=100 ports: - "8083:8080" service-user: build: service-user image: service-user:1.0.0 environment: - TIMEOUT=100 ports: - "8084:8080"</code> </pre> <br><p>  Para todos os servi√ßos, o encaminhamento de porta de 8081 a 8084 √© feito para alcan√ß√°-los facilmente. </p><br><p>  Vamos passar a escrever o <code>Demo service</code> .  Primeiro, vamos tentar escrever a implementa√ß√£o o mais desastrada poss√≠vel, sem assincronia e simultaneidade.  Para fazer isso, use o Spring boot 2.2.1, Kotlin e um espa√ßo em branco para o servi√ßo.  Clonamos o reposit√≥rio e vamos para o ramo <code>spring-mvc-start</code> : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/demo-service &amp;&amp; cd demo-service &amp;&amp; git checkout spring-mvc-start</code> </pre> <br><p>  V√° para o arquivo <code>demo.Controller</code> .  Ele tem o √∫nico m√©todo <code>processRequest</code> vazio para o qual uma implementa√ß√£o deve ser gravada. </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { .. }</code> </pre> <br><p>  Um pedido de transfer√™ncia entre cart√µes ser√° recebido na entrada do m√©todo. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceRequest</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authToken: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFrom: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardTo: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: BigDecimal )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Para quem n√£o conhece o Spring</b> <div class="spoiler_text"><p>  O Spring possui um DI interno que funciona com base em anota√ß√µes.  O DemoController √© marcado com a anota√ß√£o <code>RestController</code> especial: al√©m de registrar o bean no DI, ele tamb√©m adiciona seu processamento como um controlador.  O PostProcessor localiza todos os m√©todos marcados com a anota√ß√£o <code>PostMapping</code> e os adiciona como um ponto de extremidade para o servi√ßo com o m√©todo <code>POST</code> . </p><br><p>  O manipulador tamb√©m cria uma classe de proxy para o DemoController, na qual todos os argumentos necess√°rios s√£o passados ‚Äã‚Äãpara o m√©todo <code>processRequest</code> .  No nosso caso, esse √© apenas um argumento, marcado com a anota√ß√£o <code>@RequestBody</code> .  Portanto, no proxy, esse m√©todo ser√° chamado com o conte√∫do JSON desserializado na classe <code>ServiceRequest</code> . </p></div></div><br><p>  Para facilitar, todos os m√©todos de integra√ß√£o com outros servi√ßos j√° foram criados, basta conect√°-los corretamente.  Existem apenas cinco m√©todos, um para cada a√ß√£o.  As chamadas para outros servi√ßos s√£o implementadas na chamada de <strong>bloqueio</strong> do Spring <code>RestTemplate</code> . </p><br><p>  Exemplo de m√©todo para chamar <code>AUTH</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: AuthInfo { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restTemplate.getForEntity(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/{token}"</span></span>, AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">token) .body ?: throw RuntimeException</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"couldn't find user by token='</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">'"</span></span>) }</code> </pre> <br><p>  Vamos seguir para a implementa√ß√£o do m√©todo.  Os coment√°rios indicam o procedimento e qual resposta √© esperada na sa√≠da: </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-comment"><span class="hljs-comment">//1) get auth info from service by token -&gt; userId //2) find user info by userId from 1. //3) 4) find cards info for each card in serviceRequest // 5) make transaction for known cards by calling sendMoney(id1, id2, amount) // 6) after payment get payment info by fromCardId TODO("return SuccessResponse") // SuccessResponse( // amount = , // userName = , // userSurname = , // userAge = // ) }</span></span></code> </pre> <br><p>  Primeiro, implementamos o m√©todo da maneira mais simples poss√≠vel, sem levar em conta que o <code>AUTH</code> pode nos negar acesso a outros servi√ßos.  Tente fazer voc√™ mesmo.  Quando ocorre (ou ap√≥s alternar para a ramifica√ß√£o <code>spring-mvc</code> ), voc√™ pode verificar a opera√ß√£o do servi√ßo da seguinte maneira: </p><br><div class="spoiler">  <b class="spoiler_title">implementa√ß√£o do ramo spring-mvc</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = findUser(authInfo.userId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = findCardInfo(serviceRequest.cardFrom) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = findCardInfo(serviceRequest.cardTo) sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = getPaymentInfo(cardFromInfo.cardId) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Inicie o servi√ßo (na pasta de servi√ßo de demonstra√ß√£o): </p><br><pre> <code class="plaintext hljs">./gradlew bootRun</code> </pre> <br><p>  Enviamos uma solicita√ß√£o para o endpoint: </p><br><pre> <code class="plaintext hljs">./demo-request.sh</code> </pre> <br><p>  Em resposta, temos algo parecido com isto: </p><br><pre> <code class="plaintext hljs">‚ûú demo-service git:(spring-mvc) ‚úó ./demo-request.sh + curl -XPOST http://localhost:8080/ -d @demo-payment-request.json -H 'Content-Type: application/json; charset=UTF-8' + jq . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 182 0 85 100 97 20 23 0:00:04 0:00:04 --:--:-- 23 { "amount": 989.9, "userName": "Vasia", "userSurname": "Pupkin", "userAge": 18, "status": true }</code> </pre> <br><p>  No total, voc√™ precisa fazer 6 solicita√ß√µes para implementar o servi√ßo.  E, dado que cada um deles responde com um atraso de 100 ms, o tempo total n√£o pode ser inferior a 600 ms.  Na realidade, s√£o cerca de 700 ms, levando em considera√ß√£o toda a sobrecarga.  At√© agora, o c√≥digo √© bastante simples e, se agora queremos adicionar uma verifica√ß√£o de resposta <code>AUTH</code> para acessar outros servi√ßos, isso n√£o ser√° dif√≠cil de fazer (como qualquer outra refatora√ß√£o). </p><br><p>  Mas vamos pensar em como voc√™ pode acelerar a execu√ß√£o da consulta.  Se voc√™ n√£o levar em considera√ß√£o a verifica√ß√£o da resposta do <code>AUTH</code> , teremos 2 tarefas independentes: </p><br><ul><li>  obtendo <code>userId</code> e solicitando dados do <code>USER</code> ; </li><li>  receber <code>cardId</code> para cada cart√£o, efetuar um pagamento e receber o valor total. </li></ul><br><p>  Essas tarefas podem ser executadas independentemente uma da outra.  O tempo total de execu√ß√£o depender√° da cadeia de chamadas mais longa (neste caso, a segunda) e ser√° executado no total por 300 ms + X ms de sobrecarga. </p><br><p>  Dado que as chamadas em si est√£o bloqueando, a √∫nica maneira de executar solicita√ß√µes paralelas √© execut√°-las em threads separados.  Voc√™ pode criar um segmento separado para cada chamada, mas ser√° muito caro.  Outra maneira √© executar tarefas no ThreadPool.  √Ä primeira vista, essa solu√ß√£o parece apropriada e o tempo realmente diminui.  Por exemplo, podemos executar consultas no CompletableFuture.  Ele permite executar tarefas em segundo plano chamando m√©todos com o postfix <code>async</code> .  E se voc√™ n√£o especificar um ThreadPool espec√≠fico ao chamar m√©todos, as tarefas ser√£o iniciadas em <code>ForkJoinPool.commonPool()</code> .  Tente escrever uma implementa√ß√£o voc√™ mesmo ou v√° para o ramo <code>spring-mvc-async</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Implementa√ß√£o a partir da ramifica√ß√£o spring-mvc-async</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfoFuture = CompletableFuture.supplyAsync { getAuthInfo(serviceRequest.authToken) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoFuture = authInfoFuture.thenApplyAsync { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> waitAll = CompletableFuture.allOf(cardFromInfo, cardToInfo) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoFuture = waitAll .thenApplyAsync { sendMoney(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, cardToInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, serviceRequest.amount) } .thenApplyAsync { getPaymentInfo(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Se agora medirmos o tempo de solicita√ß√£o, ele estar√° na regi√£o de 360 ‚Äã‚Äãms.  Comparado com a vers√£o original, o tempo total diminuiu quase 2 vezes.  O c√≥digo em si se tornou um pouco mais complicado, mas at√© agora ainda n√£o √© dif√≠cil modific√°-lo.  E se aqui queremos adicionar uma verifica√ß√£o de resposta do <code>AUTH</code> , isso n√£o √© dif√≠cil. </p><br><p>  Mas e se tivermos um grande n√∫mero de solicita√ß√µes de entrada para o pr√≥prio servi√ßo?  Diga cerca de 1000 solicita√ß√µes simult√¢neas?  Com essa abordagem, verifica-se rapidamente que todos os threads do ThreadPool est√£o ocupados fazendo chamadas de bloqueio.  E chegamos √† conclus√£o de que a vers√£o atual tamb√©m n√£o √© adequada. </p><br><p>  Resta apenas fazer algo com o servi√ßo chama a si mesmos.  Voc√™ pode modificar as consultas e torn√°-las sem bloqueio.  Em seguida, os m√©todos para chamar os servi√ßos retornar√£o CompletableFuture, Flux, Observable, Adiado, Promise ou um objeto semelhante no qual criar uma cadeia de expectativas.  Com essa abordagem, n√£o precisamos fazer chamadas em fluxos separados - ser√° suficiente ter um (ou pelo menos um pequeno conjunto separado de fluxos) que j√° emprestamos para processar solicita√ß√µes. </p><br><p>  Podemos agora suportar a carga pesada no servi√ßo?  Para responder a essa pergunta, observe atentamente o Tomcat, usado no Spring boot 2.2.1 no starter <code>org.springframework.boot:spring-boot-starter-web</code> .  Ele √© criado para que um thread do ThreadPool seja alocado para cada solicita√ß√£o de entrada para seu processamento.  E, na aus√™ncia de fluxos livres, novos pedidos se tornar√£o uma "fila" de espera.  Mas nosso servi√ßo em si envia apenas solicita√ß√µes para outros servi√ßos.  Alocar um fluxo inteiro sob ele e bloque√°-lo at√© que todas as respostas cheguem, parece, para dizer o m√≠nimo, sup√©rfluas. </p><br><p>  Felizmente, o Spring recentemente tornou poss√≠vel o uso de um servidor da web sem bloqueio baseado no Netty ou no Undertow.  Para fazer isso, voc√™ s√≥ precisa alterar o <code>spring-boot-starter-web</code> para <code>spring-boot-starter-webflux</code> <code>spring-boot-starter-web</code> <code>spring-boot-starter-webflux</code> e alterar ligeiramente o m√©todo para processar solicita√ß√µes nas quais a solicita√ß√£o e a resposta ser√£o "agrupadas" no Mono.  Isso se deve ao fato de o Webflux ser constru√≠do com base no Reator e, portanto, agora no m√©todo voc√™ precisa criar uma cadeia de transforma√ß√µes Mono. <br></p><p>  Tente escrever sua pr√≥pria implementa√ß√£o sem bloqueio do m√©todo.  Para fazer isso, v√° para o ramo <code>spring-webflux-start</code> .  Observe que o iniciador do Spring Boot foi alterado, onde a vers√£o com o Webflux agora √© usada, e a implementa√ß√£o de solicita√ß√µes para outros servi√ßos que foram reescritos para usar o <code>WebClient</code> sem bloqueio tamb√©m foi alterada. </p><br><p>  Exemplo de m√©todo para chamar AUTH: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Mono&lt;AuthInfo&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebClient.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() .uri(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">"</span></span>) .retrieve() .bodyToMono(AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  A implementa√ß√£o do primeiro exemplo √© inserida no conte√∫do do m√©todo <code>processRequest</code> em um coment√°rio.  Tente reescrever voc√™ mesmo no Reactor.  Como da √∫ltima vez, primeiro fa√ßa a vers√£o sem levar em conta as verifica√ß√µes do <code>AUTH</code> e depois veja como √© dif√≠cil adicion√°-las: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-comment"><span class="hljs-comment">// val authInfo = getAuthInfo(serviceRequest.authToken) // // val userInfo = findUser(authInfo.userId) // // val cardFromInfo = findCardInfo(serviceRequest.cardFrom) // val cardToInfo = findCardInfo(serviceRequest.cardTo) // // sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) // // val paymentInfo = getPaymentInfo(cardFromInfo.cardId) // // log.info("result") // // return SuccessResponse( // amount = paymentInfo.currentAmount, // userName = userInfo.name, // userSurname = userInfo.surname, // userAge = userInfo.age // ) TODO() }</span></span></code> </pre> <br><p>  Depois de lidar com isso, voc√™ pode comparar com minha implementa√ß√£o no <code>spring-webflux</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Implementa√ß√£o a partir do ramo spring-webflux</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cacheRequest = serviceRequest.cache() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoMono = cacheRequest.flatMap { getAuthInfo(it.authToken) }.flatMap { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoMono = cacheRequest.flatMap { findCardInfo(it.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoMono = cacheRequest.flatMap { findCardInfo(it.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoMono = cardFromInfoMono.zipWith(cardToInfoMono) .flatMap { (cardFromInfo, cardToInfo) -&gt; cacheRequest.flatMap { request -&gt; sendMoney(cardFromInfo.cardId, cardToInfo.cardId, request.amount).map { cardFromInfo } } }.flatMap { getPaymentInfo(it.cardId) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userInfoMono.zipWith(paymentInfoMono) .map { (userInfo, paymentInfo) -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) } }</code> </pre> </div></div><br><p>  Concorde que agora escrever uma implementa√ß√£o (em compara√ß√£o com a abordagem de bloqueio anterior) se tornou mais dif√≠cil.  E se queremos adicionar verifica√ß√µes "esquecidas" do <code>AUTH</code> , isso n√£o ser√° t√£o f√°cil de fazer. </p><br><p>  Essa √© a ess√™ncia da abordagem reativa.  √â √≥timo para a constru√ß√£o de cadeias de processamento n√£o ramificadas.  Mas se a ramifica√ß√£o aparecer, o c√≥digo n√£o ser√° mais t√£o simples. </p><br><p>  As corotinas da Kotlin, que s√£o muito amig√°veis ‚Äã‚Äãcom qualquer c√≥digo ass√≠ncrono / reativo, podem ajudar aqui.  Al√©m disso, h√° um grande n√∫mero de inv√≥lucros por escrito para o <a href="">Reator</a> , o <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">CompletableFuture</a> etc.  Mas mesmo que voc√™ n√£o encontre o caminho certo, sempre poder√° escrev√™-lo, usando <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html">construtores</a> especiais. </p><br><p>  Vamos reescrever a implementa√ß√£o em corotinas.  Para fazer isso, v√° para a <code>spring-webflux-coroutines-start</code> .  As depend√™ncias necess√°rias s√£o adicionadas a ele em build.gradle.kts: </p><br><pre> <code class="kotlin hljs">implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-core:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactive:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactor:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  E o m√©todo <code>processRequest</code> muda um <code>processRequest</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { <span class="hljs-comment"><span class="hljs-comment">//TODO() }</span></span></code> </pre> <br><p>  Ele n√£o precisa mais do Mono e se traduz simplesmente em uma fun√ß√£o de suspens√£o (gra√ßas √† integra√ß√£o do Spring e Kotlin).  Considerando que criaremos coroutines adicionais no m√©todo, precisaremos criar um escoteiro infantil <code>coroutineScope</code> (para entender os motivos da cria√ß√£o de um escopo adicional, consulte a publica√ß√£o de Roman Elizarov sobre <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">simultaneidade estruturada</a> ).  Observe que outras chamadas de servi√ßo n√£o foram alteradas.  Eles retornam o mesmo Mono no qual o m√©todo de <code>suspend</code> waititFirst pode ser chamado para "aguardar" o resultado da consulta. </p><br><p>  Se as corotinas ainda s√£o um novo conceito para voc√™, existe um <a href="">guia</a> maravilhoso com uma descri√ß√£o detalhada.  Tente escrever sua pr√≥pria implementa√ß√£o do m√©todo <code>processRequest</code> ou v√° para o ramo <code>spring-webflux-coroutines</code> : </p><br><div class="spoiler">  <b class="spoiler_title">implementa√ß√£o do ramo spring-webflux-coroutines</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { log.info(<span class="hljs-string"><span class="hljs-string">"start"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken).awaitFirst() findUser(authInfo.userId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoDeferred = async { findCardInfo(serviceRequest.cardFrom).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoDeferred = async { findCardInfo(serviceRequest.cardTo).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = cardFromInfoDeferred.await() sendMoney(cardFromInfo.cardId, cardToInfoDeferred.await().cardId, serviceRequest.amount).awaitFirst() getPaymentInfo(cardFromInfo.cardId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoDeferred.await() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoDeferred.await() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p>  Voc√™ pode comparar o c√≥digo com a abordagem reativa.  Com as corotinas, voc√™ n√£o precisa pensar em todos os pontos de ramifica√ß√£o com anteced√™ncia.  Podemos simplesmente chamar m√©todos de <code>await</code> e ramificar tarefas ass√≠ncronas em <code>async</code> nos lugares certos.  O c√≥digo permanece o mais semelhante poss√≠vel √† vers√£o direta original, que n√£o √© nada dif√≠cil de mudar.  E um fator importante √© que as corotinas s√£o simplesmente incorporadas ao c√≥digo reativo. </p><br><p>  Voc√™ pode at√© gostar mais da abordagem reativa para esta tarefa, mas muitas das pessoas pesquisadas acham mais dif√≠cil.  Em geral, ambas as abordagens resolvem o problema e voc√™ pode usar a que mais gosta.  A prop√≥sito, recentemente em Kotlin tamb√©m h√° a oportunidade de criar corotinas "frias" com o Flow, que s√£o muito semelhantes ao Reator.  √â verdade que eles ainda est√£o no est√°gio experimental, mas agora voc√™ pode examinar a implementa√ß√£o atual e experiment√°-la no seu c√≥digo. </p><br><p>  Quero terminar aqui e finalmente deixar links √∫teis: </p><br><ul><li>  <a href="">Coroutine Guide</a> </li><li>  <a href="">Reator de corotinas</a> </li><li>  <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">Coroutines CompletableFuture</a> </li><li>  <a href="https://www.youtube.com/results%3Fsearch_query%3D%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B2%2B%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%2B%25D0%25BA%25D0%25BE%25D1%2580%25D1%2583%25D1%2582%25D0%25B8%25D0%25BD%25D1%258B">Roman Elizarov sobre corotinas</a> </li><li>  <a href="https://medium.com/%40elizarov/kotlin-flows-and-coroutines-256260fb3bdb">Fluxos e corotinas de Kotlin</a> </li><li>  <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">Concorr√™ncia estruturada</a> </li><li>  <a href="https://blog.karumi.com/spring-boot-loves-kotlin/">Bota de primavera ama Kotlin</a> </li></ul><br><p>  Espero que voc√™ tenha se interessado e tenha conseguido escrever uma implementa√ß√£o do m√©todo para todos os m√©todos.  E, √© claro, eu quero acreditar que voc√™ gosta da op√ß√£o com corotinas mais =) </p><br><p>  Obrigado a todos que leram at√© o fim! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477052/">https://habr.com/ru/post/pt477052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477042/index.html">Otimiza√ß√£o da estrat√©gia de blackjack de Monte Carlo</a></li>
<li><a href="../pt477044/index.html">Automa√ß√£o de testes de ponta a ponta de um sistema de informa√ß√£o integrado. Parte 2. T√©cnico</a></li>
<li><a href="../pt477046/index.html">.Net Meetup em Raiffeisenbank 28/11 + Transmiss√£o</a></li>
<li><a href="../pt477048/index.html">Por que uma empresa com uma capitaliza√ß√£o de US $ 55 bilh√µes pensou em deixar a bolsa</a></li>
<li><a href="../pt477050/index.html">Sexta-feira negra de 2019 para vigil√¢ncia por v√≠deo e nuvens.</a></li>
<li><a href="../pt477054/index.html">Webasto Anuncia Sistema Modular de Bateria Automotiva</a></li>
<li><a href="../pt477058/index.html">Enterprise Agile Russia no Raiffeisenbank 26/11 + Transmiss√£o</a></li>
<li><a href="../pt477060/index.html">O DataArt sediar√° uma palestra aberta de Andrey Terekhov, Chefe do Departamento de Programa√ß√£o de Sistemas, Matmekh, Universidade Estadual de S√£o Petersburgo</a></li>
<li><a href="../pt477062/index.html">Como o compilador de otimiza√ß√£o funciona</a></li>
<li><a href="../pt477072/index.html">Desenvolvimento do cliente ou como lan√ßar um produto sem falhas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>