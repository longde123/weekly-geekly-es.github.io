<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚ÄçüöÄ ‚òùüèΩ üñïüèª Was ist neu in CUBA 7? üèôÔ∏è ü•ò üíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist neu in CUBA 7? 


 Vor drei Jahren haben wir die zweite √∂ffentlich verf√ºgbare Hauptversion des Frameworks angek√ºndigt. CUBA 6 war die bahnbrec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist neu in CUBA 7?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/444558/"><h1 id="whats-new-in-cuba-7">  Was ist neu in CUBA 7? </h1><br><p>  Vor drei Jahren haben wir die zweite √∂ffentlich verf√ºgbare Hauptversion des Frameworks angek√ºndigt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA 6</a> war die bahnbrechende Version - die Lizenzierung wurde von propriet√§r auf Apache 2.0 umgestellt.  In jenen Tagen konnten wir nicht einmal erraten, wohin es den Rahmen langfristig bringen w√ºrde.  Die CUBA-Community begann exponentiell zu wachsen, daher haben wir viele m√∂gliche (und manchmal unm√∂gliche) M√∂glichkeiten kennengelernt, wie Entwickler das Framework verwenden.  Jetzt freuen wir uns, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA 7 vorstellen zu k√∂nnen</a> , was hoffentlich die Entwicklung f√ºr alle Community-Mitglieder koh√§renter und erfreulicher macht, von denen, die gerade ihre Reise in CUBA und Java begonnen haben, bis hin zu erfahrenen Unternehmensentwicklern und Java-Experten. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d60/280/788/d602807880920f1c89cc34aa4c944f11.png" alt="Kuba"></p><a name="habracut"></a><br><h2 id="development-tools">  Entwicklungswerkzeuge </h2><br><p>  Einen gro√üen Teil des CUBA-Erfolgs verdanken wir nat√ºrlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA Studio</a> .  Es hat die √ºberarbeitete Java-Unternehmensroutine bemerkenswert vereinfacht und sie vielerorts auf einfache Konfigurationen in den visuellen Designern zur√ºckgef√ºhrt: Sie m√ºssen weder die Persistence API noch Gradle oder sogar Spring kennen, um eine vollst√§ndige und funktionsreiche CRUD-Anwendung zu entwickeln - Studio wird dies tun f√ºr dich. </p><br><p>  Das Studio war eine separate Webanwendung, und diese Tatsache verursachte einige erhebliche Einschr√§nkungen: </p><br><ul><li>  Erstens war Studio keine voll funktionsf√§hige IDE, daher mussten Entwickler zwischen Studio und IntelliJ IDEA oder Eclipse wechseln, um Gesch√§ftslogik zu entwickeln und von bequemer Navigation, Code-Vervollst√§ndigung und anderen wichtigen Dingen zu profitieren, was √§rgerlich war. </li><li>  Zweitens wurde diese magische Einfachheit durch massives Parsen und Generieren von Quellcode aufgebaut.  Die Verbesserung der Funktionen zur Codegenerierung w√ºrde bedeuten, dass eine voll funktionsf√§hige IDE entwickelt wird - ein zu ehrgeiziges Unterfangen. </li></ul><br><p>  Wir beschlossen, uns auf die Schulter eines anderen Riesen zu st√ºtzen, um diese Einschr√§nkungen zu √ºberwinden.  Studio wurde von JetBrains in IntelliJ IDEA integriert.  Jetzt k√∂nnen Sie es als Plugin f√ºr Ihre IntelliJ IDEA installieren oder als separates Standalone-Bundle herunterladen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eba/91f/e64/eba91fe64a5025522853a054d2e6d720.png" alt="kuba1"></p><br><p>  Dies er√∂ffnet neue Horizonte: </p><br><ul><li>  Unterst√ºtzung f√ºr andere JVM-Sprachen (und Kotlin an erster Stelle) </li><li>  Verbesserte Hot-Bereitstellung </li><li>  Intuitive Navigation durch das gesamte Projekt </li><li>  Intelligentere Hinweise und Codegeneratoren </li></ul><br><p>  Derzeit befindet sich das neue Studio in der aktiven Entwicklung: Wir portieren Funktionen aus der alten Version.  Kurzfristig ist auch geplant, webbasierte Designer mithilfe der nativen IntelliJ-Benutzeroberfl√§che erneut zu implementieren und die Projektnavigation zu verbessern. </p><br><h2 id="stack-upgrade">  Stapel-Upgrade </h2><br><p>  Traditionell wurde der zugrunde liegende Stack auch stark aktualisiert, z. B. Java 8/11, Vaadin 8, Spring 5. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fb4/f9a/5f9/fb4f9a5f937e543e339dfba51e637f2e.png" alt="cuba2"></p><br><p>  Standardm√§√üig verwenden neue Projekte Java 8, aber Sie k√∂nnen die Java-Version angeben, indem Sie der Datei build.gradle die folgende Klausel hinzuf√ºgen: </p><br><pre><code class="plaintext hljs">subprojects { sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11 }</code> </pre> <br><p>  Das Upgrade auf Vaadin 8 war eine gro√üe Herausforderung, da die Vaadin-Datenbindungs-API massiv ge√§ndert wurde.  Gl√ºcklicherweise abstrahiert CUBA Entwickler von Vaadin-Interna, indem es sie in eine eigene API-Schicht einwickelt.  Das CUBA-Team hat gro√üartige Arbeit geleistet, indem es Interna neu implementiert hat und seine eigene API unber√ºhrt gelassen hat.  Dies bedeutet, dass die Kompatibilit√§t vollst√§ndig gespeichert ist und Sie direkt nach der Migration eines Projekts auf CUBA 7 ohne Refactoring von Vaadin 8 profitieren k√∂nnen. </p><br><p>  Die vollst√§ndige Liste der aktualisierten Abh√§ngigkeiten finden Sie in den offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versionshinweisen</a> . </p><br><h2 id="new-screens-api">  Neue Bildschirm-API </h2><br><p>  Dieser Abschnitt k√∂nnte auch als "API f√ºr die ersten Bildschirme" bezeichnet werden, da CUBA noch nie eine offiziell deklarierte API in der Webclient-Ebene hatte.  Es stammt aus der Geschichte des Frameworks und bestimmten Annahmen, die in der ersten Phase getroffen wurden: </p><br><ul><li>  Deklarativ-zentrierter Ansatz - Alles, was deklarativ beschrieben werden kann, sollte in einem Bildschirmdeskriptor deklariert und nicht in seinem Controller codiert werden </li><li>  Standardbildschirme (Browser und Editor) bieten konkrete allgemeine Funktionen, die nicht ge√§ndert werden m√ºssen </li></ul><br><p>  Seit die ersten tausend Mitglieder unserer Community beigetreten sind, haben wir festgestellt, wie vielf√§ltig die Anforderungen an "Standard" -CRUD-Bildschirme sind - weit √ºber die urspr√ºnglich entworfenen Funktionen hinaus.  Trotzdem konnten wir lange Zeit Anfragen nach benutzerdefiniertem Verhalten auch ohne API-Schicht bearbeiten - dank einer anderen Annahme der ersten Stufe - Open Inheritance.  Effektiv Open Inheritance bedeutet, dass Sie jede √∂ffentliche oder gesch√ºtzte Methode einer zugrunde liegenden Klasse √ºberschreiben k√∂nnen, um ihr Verhalten an Ihre Bed√ºrfnisse anzupassen.  Dies mag nach einer Heilung f√ºr alle Krankheiten klingen, gibt Ihnen jedoch nicht einmal einen kurzfristigen Vertrag: Was ist, wenn die √ºberschriebene Methode in zuk√ºnftigen Versionen des Frameworks umbenannt, gel√∂scht oder einfach nie verwendet wird? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4ed/043/150/4ed0431505177eab85281d6f583f4bc4.png" alt="cuba3"></p><br><p>  Als Reaktion auf die wachsende Nachfrage der Community haben wir uns entschlossen, eine neue Bildschirm-API einzuf√ºhren.  Die API bietet klare und langfristige Erweiterungspunkte ohne versteckte deklarative Magie, ist flexibel und sehr einfach zu bedienen. </p><br><h3 id="screen-declaration">  Bildschirmdeklaration </h3><br><p>  In CUBA 7 ist die Bildschirmdeklaration √§u√üerst einfach: </p><br><pre> <code class="plaintext hljs">@UiController("new-screen") // screen id public class NewScreen extends Screen { }</code> </pre> <br><p>  Aus dem obigen Beispiel k√∂nnen wir ersehen, dass die Bildschirmkennung direkt √ºber der Controller-Klasse explizit definiert ist.  Mit anderen Worten, Bildschirm-ID und Controller-Klasse entsprechen jetzt eindeutig einander.  Gute Nachrichten, jetzt k√∂nnen Bildschirme auf sichere Weise direkt von ihrer Controller-Klasse angesprochen werden: </p><br><pre> <code class="plaintext hljs">@Inject private ScreenBuilders screenBuilders; @Subscribe private void onBeforeClose(BeforeCloseEvent event) { screenBuilders.screen(this) .withScreenClass(SomeConfirmationScreen.class) .build() .show(); }</code> </pre> <br><p>  Der Bildschirmdeskriptor wird zu einem erg√§nzenden Teil anstatt zu einem obligatorischen.  Das Layout kann programmgesteuert erstellt oder als XML-Bildschirmdeskriptor deklariert werden, der durch die Annotation @UiDescriptor √ºber die Controller-Klasse definiert wird.  Dies erleichtert das Lesen und Verstehen von Controllern und Layouts erheblich - dieser Ansatz ist dem in der Android-Entwicklung verwendeten sehr √§hnlich. </p><br><p>  Zuvor war es auch erforderlich, einen Bildschirmdeskriptor in der Datei web-screen.xml zu registrieren und ihm eine Kennung zuzuweisen.  In CUBA 7 wird diese Datei aus Kompatibilit√§tsgr√ºnden beibehalten. F√ºr die Erstellung von Bildschirmen auf neue Weise ist jedoch keine solche Registrierung erforderlich. </p><br><h3 id="screens-lifecycle">  Bildschirmlebenszyklus </h3><br><p>  Die neue API f√ºhrt klare und selbsterkl√§rende Ereignisse im Bildschirmlebenszyklus ein: </p><br><ul><li>  Init </li><li>  Nachher </li><li>  Vorab </li><li>  Aftershow </li><li>  Vorher schlie√üen </li><li>  Nach dem Schlie√üen </li></ul><br><p>  Alle bildschirmbezogenen Ereignisse in CUBA 7 k√∂nnen wie folgt abonniert werden: </p><br><pre> <code class="plaintext hljs">@UiController("new-screen") public class NewScreen extends Screen { @Subscribe private void onInit(InitEvent event) { } @Subscribe private void onBeforeShow(BeforeShowEvent event) { } }</code> </pre> <br><p>  Wenn Sie die neue API mit dem alten Ansatz vergleichen, sehen Sie, dass wir keine Hook-Methoden √ºberschreiben, die in der Hierarchie der √ºbergeordneten Klassen dunkel aufgerufen werden, sondern die Logik in klar vordefinierten Punkten des Bildschirmlebenszyklus definieren. </p><br><h3 id="event-handling-and-functional-delegates">  Ereignisbehandlung und funktionale Delegierte </h3><br><p>  Im vorherigen Abschnitt haben wir gelernt, wie Sie die Lebenszyklusereignisse abonnieren. Was ist also mit anderen Komponenten?  Sollten wir weiterhin alle erforderlichen Listener auf die Bildschirminitialisierung verteilen, wie dies in 6.x-Versionen der Fall war?  Die neue API ist sehr einheitlich, sodass das Abonnieren anderer Ereignisse den Ereignissen im Lebenszyklus absolut √§hnlich ist. </p><br><p>  Nehmen wir ein einfaches Beispiel mit zwei UI-Elementen: einer Schaltfl√§che und einem W√§hrungsfeld, sodass der XML-Deskriptor folgenderma√üen aussieht: </p><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; &lt;window xmlns="http://schemas.haulmont.com/cuba/screen/window.xsd" caption="msg://caption" messagesPack="com.company.demo.web"&gt; &lt;layout&gt; &lt;hbox spacing="true"&gt; &lt;currencyField id="currencyField" currency="$" currencyLabelPosition="LEFT"/&gt; &lt;button id="calcPriceBtn" caption="Calculate Price"/&gt; &lt;/hbox&gt; &lt;/layout&gt; &lt;/window&gt;</code> </pre> <br><p>  Durch Klicken auf die Schaltfl√§che rufen wir den Middleware-Dienst auf und geben eine Nummer zur√ºck, die in das W√§hrungsfeld wechselt.  Das W√§hrungsfeld sollte seinen Stil abh√§ngig vom Preiswert √§ndern. </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private PricingService pricingService; @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Subscribe("calcPriceBtn") private void onCalcPriceBtnClick(Button.ClickEvent event) { currencyField.setValue(pricingService.calculatePrice()); } @Subscribe("currencyField") private void onPriceChange(HasValue.ValueChangeEvent&lt;BigDecimal&gt; event) { BigDecimal price = pricingService.calculatePrice(); currencyField.setStyleName(getStyleNameByPrice(price)); } private String getStyleNameByPrice(BigDecimal price) { ... } }</code> </pre> <br><p>  Im obigen Beispiel sehen wir zwei Ereignishandler: Einer wird aufgerufen, wenn auf die Schaltfl√§che geklickt wird, und ein anderer wird ausgef√ºhrt, wenn das W√§hrungsfeld seinen Wert √§ndert - so einfach ist das. </p><br><p>  Stellen wir uns nun vor, wir m√ºssen unseren Preis validieren und √ºberpr√ºfen, ob sein Wert positiv ist.  Der einfachste Weg w√§re, w√§hrend der Bildschirminitialisierung einen Validator hinzuzuf√ºgen: </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Subscribe private void onInit(InitEvent event) { currencyField.addValidator(value -&gt; { if (value.compareTo(BigDecimal.ZERO) &lt;= 0) throw new ValidationException("Price should be greater than zero"); }); } }</code> </pre> <br><p>  In realen Anwendungen wird ein Bildschirmeinstiegspunkt normalerweise mit dieser Art von Bildschirmelementinitialisierern √ºbers√§t.  Um dieses Problem zu beheben, bietet CUBA die n√ºtzliche Anmerkung <code>@Install</code> .  Mal sehen, wie es in unserem Fall helfen kann: </p><br><pre> <code class="plaintext hljs">@UiController("demo_MyFirstScreen") @UiDescriptor("my-first-screen.xml") public class MyFirstScreen extends Screen { @Inject private CurrencyField&lt;BigDecimal&gt; currencyField; @Install(to = "currencyField", subject = "validator") private void currencyFieldValidator(BigDecimal value) { if (value.compareTo(BigDecimal.ZERO) &lt;= 0) throw new ValidationException("Price should be greater than zero"); } }</code> </pre> <br><p>  Tats√§chlich delegieren wir die Validierungslogik aus unserem W√§hrungsfeld an die <em>CurrencyFieldValidator-</em> Methode in unserem Bildschirm.  Dies mag etwas kompliziert aussehen, Entwickler √ºbernehmen diese Funktion jedoch √ºberraschend schnell. </p><br><h3 id="screen-builders--notifications--dialogs">  Screen Builder / Benachrichtigungen / Dialoge </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/b4b/83a/d7bb4b83a2ac4b60988f0a7e59b91dae.png" alt="cuba4"></p><br><p>  CUBA 7 stellt au√üerdem eine Reihe n√ºtzlicher Komponenten mit flie√üenden APIs vor: </p><br><ul><li><p>  <strong>ScreenBuilders</strong> kombiniert flie√üende Fabriken, um Standard-Lookups, Editoren und benutzerdefinierte Bildschirme zu generieren.  Das folgende Beispiel zeigt, wie Sie einen Bildschirm von einem anderen aus √∂ffnen k√∂nnen.  Beachten Sie, dass die <em>build ()</em> -Methode die Bildschirminstanz des richtigen Typs zur√ºckgibt, ohne dass eine unsichere Umwandlung erforderlich ist. </p><br><p>  CurrencyConversionsrencyConversions = screenBuilders.screen (this) <br>  .withScreenClass (CurrencyConversions.class) <br>  .withLaunchMode (OpenMode.DIALOG) <br>  .build (); <br>  rencyConversions.setBaseCurrency (Currency.EUR); <br>  rencyConversions.show (); </p><br></li><li><p>  <strong>Die Bildschirmkomponente</strong> bietet eine Abstraktion auf niedrigerer Ebene zum Erstellen und Anzeigen von Bildschirmen anstelle von <em>ScreenBuilders</em> .  Es bietet auch Zugriff auf die Informationen zu allen ge√∂ffneten Bildschirmen in Ihrer CUBA-Anwendung ( <em>Screens # getOpenedScreens</em> ), falls Sie diese durchlaufen m√ºssen. </p><br></li><li><p>  <strong>Die</strong> Komponenten <strong>Benachrichtigungen</strong> und <strong>Dialoge</strong> bieten praktische, selbsterkl√§rende Schnittstellen.  Hier ist ein Beispiel zum Erstellen und Anzeigen eines Dialogfelds und einer Benachrichtigung: </p><br><p>  dialogs.createOptionDialog () <br>  .withCaption ("Mein erster Dialog") <br>  .withMessage ("M√∂chten Sie dem CUBA-Team danken?") <br>  .withActions ( <br>  neue DialogAction (DialogAction.Type.YES) .withHandler (e -&gt; <br>  notifications.create () <br>  .withCaption ("Danke!") <br>  .withDescription ("Wir sch√§tzen alle Community-Mitglieder") <br>  .withPosition (Notifications.Position.MIDDLE_CENTER) <br>  .withHideDelayMs (3000) <br>  .show ()), <br>  neue DialogAction (DialogAction.Type.CANCEL) <br>  ) <br>  .show (); </p><br></li></ul><br><h3 id="data-binding">  Datenbindung </h3><br><p>  CUBA erm√∂glicht eine extrem schnelle Entwicklung von Backoffice-Benutzeroberfl√§chen, indem nicht nur fortschrittliche visuelle Tools mit umfangreichen Funktionen zur Codegenerierung bereitgestellt werden, sondern auch eine Vielzahl von datensensitiven Komponenten, die sofort verf√ºgbar sind.  Solche Komponenten m√ºssen nur wissen, mit welchen Daten sie arbeiten, und der Rest wird automatisch verwaltet, z. B. Suchlisten, Auswahlfelder, verschiedene Raster mit CRUD-Operationen usw. </p><br><p>  Vor Version 7 wurde die Datenbindung √ºber sogenannte Datenquellen implementiert - Objekte, die eine einzelne Entit√§t oder eine Sammlung von Entit√§ten umschlie√üen, um sie reaktiv mit datensensitiven Komponenten zu verkn√ºpfen.  Dieser Ansatz funktionierte sehr gut, in Bezug auf die Implementierung war es jedoch ein Monolith.  Die monolithische Architektur verursacht normalerweise Probleme bei der Anpassung. In CUBA 7 wurde dieser feste Felsblock in drei Datenkomponenten aufgeteilt: </p><br><ul><li>  <strong>Data Loader</strong> ist ein Datenprovider f√ºr Datencontainer.  Datenlader speichern keine Daten, sondern √ºbergeben lediglich alle erforderlichen Abfrageparameter an einen Datenspeicher und f√ºttern Datencontainer mit dem resultierenden Datensatz. </li><li>  <strong>Der</strong> Datencontainer speichert die geladenen Daten (eine einzelne Entit√§t oder eine Anzahl von Entit√§ten) und stellt sie den datensensitiven Komponenten auf reaktive Weise zur Verf√ºgung: Alle √Ñnderungen der umschlossenen Entit√§ten werden den entsprechenden UI-Komponenten ausgesetzt und umgekehrt, alle √Ñnderungen in Die UI-Komponenten f√ºhren zu den entsprechenden √Ñnderungen in ihrem Datencontainer. </li><li>  <strong>Der Datenkontext</strong> ist ein leistungsstarker Daten√§nderungsmanager, der √Ñnderungen verfolgt und alle ge√§nderten Entit√§ten festschreibt.  Eine Entit√§t kann in einem Datenkontext zusammengef√ºhrt werden, sodass eine Kopie der urspr√ºnglichen Entit√§t mit dem einzigen, aber sehr wichtigen Unterschied bereitgestellt wird: Alle √Ñnderungen der resultierenden Entit√§t und aller Entit√§ten, auf die sie verweist (einschlie√ülich Sammlungen), werden verfolgt, gespeichert und entsprechend verpflichtet. </li></ul><br><p>  Datenkomponenten k√∂nnen in Bildschirmdeskriptoren deklariert oder mithilfe einer speziellen Factory - <em>DataComponents</em> - programmgesteuert instanziiert werden. </p><br><h3 id="miscellaneous">  Verschiedenes </h3><br><p>  Ufff, die wichtigsten Teile der neuen Bildschirm-API werden beschrieben. Lassen Sie mich daher kurz andere wichtige Funktionen in der Web-Client-Ebene auflisten: </p><br><ul><li>  <strong>URL-Verlauf und Navigation</strong> .  Diese Funktion l√∂st ein sehr h√§ufiges SPA-Problem mit der Schaltfl√§che "Zur√ºck" in einem Webbrowser, bietet eine einfache M√∂glichkeit, Routen zu Anwendungsbildschirmen zuzuweisen, und erm√∂glicht einer API, den aktuellen Status eines Bildschirms in ihrer URL wiederzugeben. </li><li>  <strong>Formular anstelle von FieldGroup</strong> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FieldGroup</a> ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">datensensitive</a> Komponente zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzeigen</a> und √Ñndern von Feldern einer einzelnen Entit√§t.  Daraus folgt die tats√§chliche Benutzeroberfl√§che, die zur Laufzeit f√ºr ein Feld angezeigt wird.  Mit anderen Worten, wenn Sie ein <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datumsfeld</a></em> in Ihrer Entit√§t haben, wird es als <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datumsfeld angezeigt</a></em> .  Wenn Sie dieses Feld jedoch programmgesteuert <em>bearbeiten m√∂chten</em> , m√ºssen Sie dieses Feld in die Bildschirmsteuerung <em>einf√ºgen</em> und manuell in den richtigen Typ <em>umwandeln</em> ( <em>in unserem Beispiel DateField</em> ).  Sp√§ter √§ndern wir unseren Feldtyp in einen anderen und unsere Anwendung st√ºrzt zur Laufzeit ab ... Das Formular behebt dieses Problem durch explizite Feldtypdeklaration.  Weitere Informationen zu dieser neuen Komponente finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li><li>  <strong>Die Integration von JavaScript-Komponenten von Drittanbietern</strong> wird erheblich vereinfacht. Befolgen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Dokumentation</a> , um benutzerdefinierte JavaScript-Komponenten in eine CUBA-Anwendung einzubetten. </li><li>  <strong>HTML / CSS-</strong> Attribute k√∂nnen jetzt einfach direkt aus dem XML-Bildschirmdeskriptor definiert oder programmgesteuert festgelegt werden.  Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li></ul><br><h2 id="middleware-features">  Middleware-Funktionen </h2><br><p>  Der vorherige Block √ºber die neue Bildschirm-API war gr√∂√üer als ich erwartet hatte, also werde ich in diesem Abschnitt versuchen, ordentlich zu sein! </p><br><h3 id="entity-changed-event">  Entity Changed Event </h3><br><p>  Entity Changed Event ist ein Spring-Anwendungsereignis, das ausgel√∂st wird, wenn Ihre Entit√§t den Weg zu einem Datenspeicher gefunden hat, physisch eingef√ºgt wurde und sich nur einen Zentimeter von der Festschreibung entfernt befindet.  Hier k√∂nnen Sie einige zus√§tzliche √úberpr√ºfungen durchf√ºhren (z. B. die Produktverf√ºgbarkeit auf Lager pr√ºfen, bevor Sie eine Bestellung best√§tigen) und diese √§ndern (z. B. die Gesamtsummen neu berechnen), bevor sie f√ºr andere Transaktionen sichtbar werden (nat√ºrlich mit gelesener Isolationsstufe).  Sie k√∂nnen dieses Ereignis auch als letzte M√∂glichkeit verwenden, um das Festschreiben der Transaktion zu unterbrechen, indem Sie eine Ausnahme ausl√∂sen. Dies kann in einigen Eckf√§llen hilfreich sein. </p><br><p>  Es gibt auch eine M√∂glichkeit, das Ereignis "Entity Changed" direkt nach dem Festschreiben abzufangen. </p><br><p>  Folgen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Kapitel</a> der Dokumentation, um ein Beispiel zu sehen. </p><br><h3 id="transactional-data-manager">  Transaktionsdaten-Manager </h3><br><p>  Bei der Entwicklung einer Anwendung arbeiten wir normalerweise mit getrennten Entit√§ten - solchen, die von keiner Transaktion verwaltet werden.  Die Arbeit mit getrennten Entit√§ten ist jedoch nicht immer m√∂glich, insbesondere wenn versucht wird, die ACID-Anforderungen zu erf√ºllen. Dies ist der Fall, wenn Sie den Transaktionsdatenmanager verwenden k√∂nnen.  Es sieht dem normalen Datenmanager sehr √§hnlich, unterscheidet sich jedoch in folgenden Aspekten: </p><br><ul><li>  Es kann einer vorhandenen Transaktion beitreten (falls sie im Transaktionskontext aufgerufen wird) oder eine eigene Transaktion erstellen. </li><li>  Es gibt keine <em>Festschreibungsmethode</em> , aber es gibt die Speichermethode, die nicht zum sofortigen Festschreiben f√ºhrt, sondern wartet, bis die angeh√§ngte Transaktion festgeschrieben wird. </li></ul><br><p>  Ein Beispiel f√ºr die Verwendung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h3 id="jpa-lifecycle-callbacks">  JPA Lifecycle Callbacks </h3><br><p>  Schlie√ülich unterst√ºtzt CUBA 7 JPA-Lifecycle-R√ºckrufe.  Um keine gut geschriebenen Informationen dar√ºber zu replizieren, wof√ºr diese R√ºckrufe verwendet werden k√∂nnen, m√∂chte ich nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Link</a> teilen, der das Thema vollst√§ndig abdeckt. </p><br><h2 id="what-about-compatibility">  Was ist mit Kompatibilit√§t? </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d41/044/292/d410442925950409df8fdab04102dd95.png" alt="cuba5"></p><br><p>  Eine faire Frage f√ºr jede gr√∂√üere Ver√∂ffentlichung, besonders wenn es so viele scheinbar bahnbrechende √Ñnderungen gibt!  Wir haben all diese neuen Funktionen und APIs unter Ber√ºcksichtigung der Abw√§rtskompatibilit√§t entwickelt: </p><br><ul><li>  Die alte Bildschirm-API wird in CUBA 7 unterst√ºtzt und √ºber die neue unter der Haube implementiert :) </li><li>  Wir haben auch Adapter f√ºr die alte Datenbindung bereitgestellt, die weiterhin f√ºr die altmodischen Bildschirme funktionieren. </li></ul><br><p>  Gute Nachrichten, der Migrationspfad von Version 6 auf Version 7 sollte also recht einfach sein. </p><br><h2 id="conclusion">  Fazit </h2><br><p>  Abschlie√üend m√∂chte ich erw√§hnen, dass es weitere wichtige Neuerungen gibt, insbesondere bei der Lizenzierung: </p><br><ul><li>  Das Limit von 10 Entit√§ten f√ºr Studio ist jetzt weg </li><li>  Reporting, BPM, Diagramme und Karten sowie Addons f√ºr die Volltextsuche sind jetzt kostenlos und Open Source. </li><li>  Die kommerzielle Version von Studio bietet visuellen Designern zus√§tzlichen Entwicklungskomfort f√ºr Entit√§ten, Bildschirme, Men√ºs und andere Plattformelemente, w√§hrend sich die kostenlose Version auf die Arbeit mit Code konzentriert </li><li>  Bitte beachten Sie, dass f√ºr 6.x und √§ltere Versionen der Plattform und Studio die Lizenzbedingungen gleich bleiben! </li></ul><br><p>  Abschlie√üend m√∂chte ich mich noch einmal bei den Community-Mitgliedern f√ºr die Unterst√ºtzung und das Feedback bedanken.  Ich hoffe du wirst Version 7 lieben!  Die vollst√§ndige Liste der √Ñnderungen finden Sie traditionell in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versionshinweisen</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444558/">https://habr.com/ru/post/de444558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444548/index.html">Pers√∂nliche Erfahrung: Wie wir uns in Lateinamerika f√ºr die F√∂rderung hispanischer Startups engagiert haben</a></li>
<li><a href="../de444550/index.html">Zur Frage der Teilung</a></li>
<li><a href="../de444552/index.html">TDMS Fairway. Arbeiten Sie mit Fachwissen</a></li>
<li><a href="../de444554/index.html">Die einfachste JSON RESTful API unter Elixir</a></li>
<li><a href="../de444556/index.html">Die Farbe des Mondes und der Sonne aus dem Weltraum in den Werten von RGB und Farbtemperatur</a></li>
<li><a href="../de444560/index.html">Wir laden Sie zur Konferenz ‚ÄûClouds. Modetrends ‚Äù26. M√§rz 2019</a></li>
<li><a href="../de444562/index.html">Modernisierung von GHIDRA. Lader f√ºr Rum Sega Mega Drive</a></li>
<li><a href="../de444564/index.html">Digitale Produktentwicklung mit mentalen Modellen</a></li>
<li><a href="../de444566/index.html">Sikorsky f√ºhrte eine Demonstration eines unbemannten Hubschraubers mit einem Mann an Bord durch</a></li>
<li><a href="../de444568/index.html">Top 10 Fehler von C ++ - Projekten im Jahr 2018 gefunden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>