<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¥ üà≥ ü§æ Execu√ß√£o de c√≥digo personalizado no GO üç† üëö üêï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Isso √© realmente tudo sobre contratos inteligentes. 
 Mas se voc√™ n√£o imagina o que √© um contrato inteligente e, em geral, est√° longe de criptografar,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Execu√ß√£o de c√≥digo personalizado no GO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425985/"><h2>  Isso √© realmente tudo sobre contratos inteligentes. </h2><br>  Mas se voc√™ n√£o imagina o que √© um contrato inteligente e, em geral, est√° longe de criptografar, ent√£o o que √© um procedimento armazenado em um banco de dados, voc√™ pode imaginar completamente.  O usu√°rio cria trechos de c√≥digo que funcionam no nosso servidor.  √â conveniente para o usu√°rio escrev√™-los e public√°-los, e √© seguro execut√°-los. <br><a name="habracut"></a><br>  Infelizmente, ainda n√£o desenvolvemos a seguran√ßa, ent√£o agora n√£o vou descrev√™-la, mas darei algumas dicas. <br><br>  Tamb√©m escrevemos no Go, e seu tempo de execu√ß√£o imp√µe algumas restri√ß√µes muito espec√≠ficas, a principal delas √© que, em geral, n√£o podemos vincular a outro projeto que n√£o esteja em movimento, isso interromper√° nosso tempo de execu√ß√£o toda vez que executarmos c√≥digo de terceiros.  Em geral, temos a op√ß√£o de usar algum tipo de int√©rprete, para o qual encontramos um WASM completamente sadio e um s√£ completamente sadio, mas de alguma forma n√£o quero adicionar clientes a Lua, mas agora com o WASM h√° mais problemas do que benef√≠cios, est√° em um estado preliminar , que √© atualizado todos os meses, portanto, aguardaremos at√© que a especifica√ß√£o seja estabelecida.  N√≥s o usamos como um segundo mecanismo. <br><br>  Como resultado de longas batalhas com sua pr√≥pria consci√™ncia, foi decidido escrever contratos inteligentes no GO.  O fato √© que, se voc√™ construir a arquitetura para executar o c√≥digo GO compilado, ter√° que transferir essa execu√ß√£o para um processo separado, como se lembra, por seguran√ßa, e transferir para um processo separado √© uma perda de desempenho no IPC, embora no futuro, quando entendamos o volume do execut√°vel c√≥digo, foi at√© agrad√°vel de alguma maneira termos escolhido essa solu√ß√£o.  O fato √© que √© escal√°vel, embora adicione um atraso a cada chamada individual.  Podemos aumentar muitos tempos de execu√ß√£o remotos. <br><br>  Um pouco mais sobre as decis√µes tomadas para que fique claro.  Cada contrato inteligente consiste em duas partes, uma parte √© o c√≥digo da classe e a segunda s√£o os dados do objeto; portanto, no mesmo c√≥digo, podemos, uma vez publicado o c√≥digo, criar muitos contratos que se comportar√£o basicamente da mesma forma, mas com configura√ß√µes diferentes e com um estado diferente.  Se conversarmos mais, ent√£o isso j√° √© sobre blockchain e n√£o o t√≥pico desta hist√≥ria. <br><br><h2>  E assim, executamos GO </h2><br>  Decidimos usar o mecanismo de plug-in, que n√£o est√° apenas pronto e bom.  Ele faz o seguinte, compilamos o que ser√° um plugin de uma maneira especial em uma biblioteca compartilhada e, em seguida, carregamos, encontramos os s√≠mbolos nele e passamos a execu√ß√£o para l√°.  Mas o problema √© que o GO tem um tempo de execu√ß√£o, e isso √© quase um megabyte de c√≥digo, e por padr√£o esse tempo de execu√ß√£o tamb√©m est√° indo para esta biblioteca, e temos um tempo de execu√ß√£o raznipipenny em todos os lugares.  Mas agora decidimos seguir em frente, tendo certeza de que poderemos derrot√°-lo no futuro. <br><br>  Tudo √© simples quando voc√™ cria sua biblioteca, voc√™ a constr√≥i com o key - buildmode = plugin e obt√©m o arquivo .so, que voc√™ abre. <br><br><pre><code class="go hljs">p, err := plugin.Open(path)</code> </pre> <br>  Procurando o personagem que voc√™ est√° interessado: <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(Method)</code> </pre> <br>  E agora, dependendo de a vari√°vel ser uma fun√ß√£o ou uma fun√ß√£o, voc√™ pode cham√°-la ou us√°-la como vari√°vel. <br><br>  Sob esse cap√¥, existe um dlopen (3) simples, carregamos a biblioteca, verificamos que √© um plug-in e fornecemos o wrapper sobre ele. Ao criar o wrapper, todos os caracteres exportados s√£o agrupados na interface {} e armazenados.  Se for uma fun√ß√£o, deve ser reduzida ao tipo correto de fun√ß√£o e simplesmente chamada, se a vari√°vel - funcionar como uma vari√°vel. <br><br>  O principal a lembrar √© que, se um s√≠mbolo √© uma vari√°vel, ele √© global durante todo o processo e voc√™ n√£o pode us√°-lo sem pensar. <br><br>  Se um tipo foi declarado no plug-in, esse tipo faz sentido em um pacote separado, para que o processo principal possa trabalhar com ele, por exemplo, passando como argumentos para as fun√ß√µes do plug-in.  Isso √© opcional, voc√™ n√£o pode usar vapor e usar reflex√£o. <br><br>  Nossos contratos s√£o objetos da "classe" correspondente e, no in√≠cio, a inst√¢ncia desse objeto era armazenada em nossa vari√°vel exportada, para que pud√©ssemos criar outra mesma vari√°vel: <br><br><pre> <code class="go hljs">export, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"EXPORT"</span></span>) obj := reflect.New(reflect.ValueOf(export).Elem().Type()).Interface()</code> </pre> <br>  E j√° dentro dessa vari√°vel local do tipo correto, desserialize o estado do objeto.  Depois que o objeto √© restaurado, podemos chamar m√©todos nele.  Ap√≥s o qual o objeto √© serializado e adicionado de volta √† loja, aplausos, chamamos o m√©todo no contrato. <br><br>  Se voc√™ estiver interessado em saber como, mas com pregui√ßa de ler a documenta√ß√£o, ent√£o: <br><br><pre> <code class="go hljs">method := reflect.ValueOf(obj).MethodByName(Method) res:= method.Call(in)</code> </pre> <br>  No meio, voc√™ ainda precisa preencher a matriz com interfaces vazias contendo o tipo correto de argumento; se estiver interessado, veja por si mesmo como foi feito, as fontes est√£o abertas, embora seja dif√≠cil encontrar esse lugar na <a href="">hist√≥ria</a> . <br><br>  Em geral, tudo funcionou para n√≥s, voc√™ pode escrever c√≥digo com algo como uma classe, coloc√°-lo no blockchain, criar um contrato dessa classe novamente no blockchain, fazer uma chamada de m√©todo e o novo estado do contrato √© gravado de volta no blockchain.  √ìtimo!  Como criar um novo contrato com o c√≥digo dispon√≠vel?  Muito simples, temos fun√ß√µes de construtor que retornam um objeto rec√©m-criado, que √© o novo contrato.  At√© agora, tudo funciona atrav√©s da reflex√£o e o usu√°rio deve escrever: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EXPORT ContractType</code> </pre> <br>  Para que possamos saber qual s√≠mbolo √© uma representa√ß√£o do contrato e realmente us√°-lo como modelo. <br><br>  N√≥s realmente n√£o gostamos.  E n√≥s batemos forte. <br><br><h2>  An√°lise </h2><br>  Em primeiro lugar, o usu√°rio n√£o deve escrever nada sup√©rfluo e, em segundo lugar, temos a ideia de que a intera√ß√£o do contrato com o contrato deve ser simples e testada sem aumentar a blockchain, a blockchain √© lenta e dif√≠cil. <br><br>  Portanto, decidimos quebrar o contrato em um inv√≥lucro, que √© gerado com base no contrato e no modelo do inv√≥lucro, em princ√≠pio, uma solu√ß√£o compreens√≠vel.  Em primeiro lugar, o wrapper cria um objeto de exporta√ß√£o para n√≥s e, em segundo lugar, substitui a biblioteca com a qual o contrato √© coletado quando o usu√°rio escreve o contrato, a biblioteca de base √© usada com os mokas internos e, quando o contrato √© publicado, √© substitu√≠do por um de combate que funciona com o pr√≥prio blockchain . <br><br>  Para come√ßar, voc√™ precisa analisar o c√≥digo e entender o que geralmente temos, encontrar a estrutura que √© herdada do BaseContract para gerar um wrapper em torno dele. <br><br>  Isso √© feito de maneira simples: lemos o arquivo com o c√≥digo em [] byte, embora o analisador possa ler os arquivos, √© bom ter o texto em algum lugar ao qual todos os elementos AST se referem, eles se referem ao n√∫mero de bytes no arquivo e, no futuro, queremos receber o c√≥digo de estrutura como ele √©, apenas pegamos algo parecido. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pf *ParsedFile)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codeOfNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(pf.code[n.Pos()<span class="hljs-number"><span class="hljs-number">-1</span></span> : n.End()<span class="hljs-number"><span class="hljs-number">-1</span></span>]) }</code> </pre> <br>  Na verdade, analisamos o arquivo e obtemos o n√≥ AST mais alto do qual rastrearemos o arquivo. <br><br><pre> <code class="go hljs">fileSet = token.NewFileSet() node, err := parser.ParseFile(fileSet, name, code, parser.ParseComments)</code> </pre> <br>  Em seguida, analisamos o c√≥digo a partir do n√≥ superior e coletamos tudo de interessante em uma estrutura separada. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, decl := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Decls { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> d := decl.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.GenDecl: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.FuncDecl: ‚Ä¶ } }</code> </pre> <br>  Decls, ele j√° foi analisado em uma matriz, uma lista de tudo o que √© definido no arquivo, mas √© uma matriz de interfaces Decl que n√£o descreve o que est√° dentro; portanto, cada elemento deve ser convertido em um tipo espec√≠fico. Aqui os autores do idioma se afastaram da ideia de usar interfaces, a interface em go / ast √© bastante uma classe base. <br><br>  Estamos interessados ‚Äã‚Äãem n√≥s do tipo GenDecl e FuncDecl.  GenDecl √© a defini√ß√£o de uma vari√°vel ou tipo, e voc√™ precisa verificar qual √© exatamente o tipo interno e, mais uma vez, convert√™-lo no tipo TypeDecl com o qual voc√™ j√° pode trabalhar.  FuncDecl √© mais simples - √© uma fun√ß√£o e, se o campo Recv for preenchido, esse √© um m√©todo da estrutura correspondente.  Coletamos tudo isso em um armazenamento conveniente, porque usamos texto / modelo e ele n√£o tem muito poder expressivo. <br><br>  A √∫nica coisa que precisamos lembrar separadamente √© o nome do tipo de dado que √© herdado do BaseContract, e vamos dan√ßar ao redor dele. <br><br><h2>  Gera√ß√£o de c√≥digo </h2><br>  E assim, conhecemos todos os tipos e fun√ß√µes que est√£o em nosso contrato e precisamos poder chamar um m√©todo em um objeto a partir do nome do m√©todo recebido e da matriz serializada de argumentos.  Afinal, no momento da gera√ß√£o do c√≥digo, conhecemos todo o dispositivo do contrato, ent√£o colocamos ao lado do arquivo do contrato pr√≥ximo a outro arquivo, com o mesmo nome de pacote, no qual colocamos todas as importa√ß√µes necess√°rias, os tipos j√° est√£o definidos no arquivo principal e s√£o desnecess√°rios. <br><br>  E aqui est√° o principal, wrappers sobre fun√ß√µes.  O nome do wrapper √© complementado por algum tipo de prefixo e agora √© f√°cil encontr√°-lo. <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"INSMETHOD_"</span></span> + Method) wrapper, ok := symbol.(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ph proxyctx.ProxyHelper, object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, result []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Cada inv√≥lucro tem a mesma assinatura; portanto, quando o chamamos do programa principal, n√£o precisamos de reflex√µes extras; a √∫nica coisa √© que os inv√≥lucros da fun√ß√£o s√£o diferentes dos inv√≥lucros do m√©todo, eles n√£o recebem e n√£o retornam o estado do objeto. <br><br>  O que temos dentro do inv√≥lucro? <br><br>  Criamos uma matriz de vari√°veis ‚Äã‚Äãvazias correspondentes aos argumentos da fun√ß√£o, colocamos em uma vari√°vel do tipo uma matriz de interfaces e desserializamos os argumentos, se formos um m√©todo, tamb√©m devemos serializar o estado do objeto, geralmente algo como isto: <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .Methods }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INSMETHOD_</span></span></span></span>{{ $method.Name }}(ph proxyctx.ProxyHelper, object []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, data []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error) { self := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>({{ $.ContractType }}) err := ph.Deserialize(object, self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ $method.ArgumentsZeroList }} err = ph.Deserialize(data, &amp;args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $method.Results }} {{ $method.Results }} := self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ end }} state := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize(self, &amp;state) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $i := $method.ErrorInterfaceInRes }} ret{{ $i }} = ph.MakeErrorSerializable(ret{{ $i }}) {{ end }} ret := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} { {{ $method.Results }} }, &amp;ret) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, ret, err } {{ end }}</code> </pre><br>  Um leitor atento estar√° interessado no que √© um auxiliar de proxy?  - este √© um objeto t√£o combinado que ainda precisamos, mas, por enquanto, usamos sua capacidade de serializar e desserializar. <br><br>  Bem, quem l√™ pergunta: "Mas esses s√£o seus argumentos, de onde eles s√£o?"  Aqui tamb√©m est√° uma resposta compreens√≠vel: sim, o texto / modelo n√£o possui estrelas suficientes do c√©u; √© por isso que calculamos essas linhas no c√≥digo, e n√£o no modelo. <br><br>  method.ArgumentsZeroList cont√©m algo como <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg0 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> Var arg1 <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ‚Äú‚Äù Var arg2 ackwardType = ackwardType{} Args := []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{&amp;arg0, &amp;arg1, &amp;arg2}</code> </pre> <br>  E Argumentos, portanto, cont√©m "arg0, arg1, arg2". <br><br>  Assim, podemos chamar o que quisermos, com qualquer assinatura. <br><br>  Mas n√£o podemos serializar nenhuma resposta, o fato √© que os serializadores funcionam com reflex√£o e n√£o d√£o acesso a campos de estruturas n√£o exportados, √© por isso que temos um m√©todo auxiliar de proxy especial que pega um objeto de interface de erro e cria um objeto de tipo base a partir dele. Erro, que difere do usual, pois o texto do erro est√° no campo exportado, e podemos serializ√°-lo, embora com algumas perdas. <br><br>  Mas se usarmos um esterilizador gerador de c√≥digo, nem precisamos dele, somos compilados no mesmo pacote, temos acesso a campos n√£o exportados. <br><br><h2>  Mas e se quisermos chamar um contrato de um contrato? </h2><br>  Voc√™ n√£o entende a profundidade do problema se acha f√°cil chamar um contrato a partir de um contrato.  O fato √© que a validade de outro contrato deve ser confirmada por consenso e o fato dessa chamada deve ser assinado no blockchain, em geral, simplesmente compilar com outro contrato e invocar seu m√©todo n√£o funcionar√°, embora eu realmente queira.  Mas somos amigos dos programadores, portanto devemos dar a eles a oportunidade de fazer tudo diretamente e ocultar todos os truques sob o cap√¥ do sistema.  Assim, o desenvolvimento do contrato √© como se houvesse chamadas diretas, e os contratos se alternam de forma transparente, mas quando coletamos o contrato para publica√ß√£o, colocamos um proxy em vez de outro contrato, que apenas conhece seu endere√ßo e assinaturas de chamada sobre o contrato. <br><br>  Como organizar tudo isso?  - Teremos que armazenar outros contratos em um diret√≥rio especial que nosso gerador possa reconhecer e criar proxies para cada contrato importado. <br><br>  Ou seja, se nos conhecemos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ‚ÄúContractsDir/ContractAddress<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>  Escrevemos na lista de contratos importados. <br><br>  A prop√≥sito, para isso, voc√™ n√£o precisa saber o c√≥digo-fonte do contrato, apenas a descri√ß√£o que j√° coletamos; por isso, se publicarmos essa descri√ß√£o em algum lugar e todas as chamadas passarem pelo sistema principal, n√£o nos importamos com o que outro contrato est√° escrito no idioma; se pudermos chamar m√©todos, podemos escrever um esbo√ßo para ele no Go, que parecer√° um pacote com um contrato que pode ser chamado diretamente.  Planos napole√¥nicos, vamos come√ßar. <br><br>  Em princ√≠pio, j√° temos um m√©todo auxiliar de proxy, com esta assinatura: <br><br><pre> <code class="go hljs">RouteCall(ref Address, method <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error)</code> </pre> <br>  Esse m√©todo pode ser chamado diretamente do contrato, ele chama de contrato remoto, retorna uma resposta serializada que precisamos analisar e retornar ao nosso contrato. <br><br>  Mas √© necess√°rio que o usu√°rio pare√ßa tudo: <br><br><pre> <code class="go hljs">ret := contractPackage.GetObject(Address).Method(arg1,arg2, ‚Ä¶)</code> </pre> <br>  Vamos come√ßar, primeiramente, no proxy, voc√™ precisa listar todos os tipos que s√£o usados ‚Äã‚Äãnas assinaturas dos m√©todos de contrato, mas, como lembramos, para cada n√≥ AST podemos obter sua representa√ß√£o textual e agora chegou a hora desse mecanismo. <br><br>  Em seguida, precisamos criar um tipo de contrato, em princ√≠pio, ele j√° conhece sua classe, apenas um endere√ßo √© necess√°rio. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> {{ .ContractType }} <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Reference Address }</code> </pre> <br>  Em seguida, precisamos implementar de alguma forma a fun√ß√£o GetObject, que no endere√ßo da blockchain retornar√° uma inst√¢ncia de proxy que sabe trabalhar com este contrato e, para o usu√°rio, parece uma inst√¢ncia de contrato. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Address)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ .ContractType }})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;{{ .ContractType }}{Reference: ref} }</code> </pre> <br>  Curiosamente, o m√©todo GetObject no modo de depura√ß√£o do usu√°rio √© diretamente um m√©todo de estrutura BaseContract, mas n√£o h√° nada, nada nos impede, observando o SLA, de fazer o que for conveniente para n√≥s.  Agora podemos criar um contrato de proxy, cujos m√©todos controlamos.  Resta realmente criar m√©todos. <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .MethodsProxies }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ $.ContractType }})</span></span></span></span> {{ $method.Name }}( {{ $method.Arguments }} ) ( {{ $method.ResultsTypes }} ) { {{ $method.InitArgs }} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> argsSerialized []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> err := proxyctx.Current.Serialize(args, &amp;argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } res, err := proxyctx.Current.RouteCall(r.Reference, <span class="hljs-string"><span class="hljs-string">"{{ $method.Name }}"</span></span>, argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } {{ $method.ResultZeroList }} err = proxyctx.Current.Deserialize(res, &amp;resList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {{ $method.Results }} } {{ end }}</code> </pre> <br>  Aqui est√° a mesma hist√≥ria com a constru√ß√£o da lista de argumentos, j√° que somos pregui√ßosos e armazenamos exatamente o ast.Node do m√©todo, para c√°lculos s√£o necess√°rias muitas convers√µes de tipo que os modelos n√£o conhecem, para que tudo seja preparado com anteced√™ncia.  Com fun√ß√µes, tudo fica seriamente mais complicado, e esse √© o t√≥pico de outro artigo. <br><br>  As fun√ß√µes que temos s√£o construtores de objetos e h√° muita √™nfase em como os objetos s√£o realmente criados em nosso sistema, o fato de a cria√ß√£o ser registrada em um executor remoto, o objeto √© transferido para outro executor, √© verificado e salvo ali, e existem muitas maneiras de salvar, em v√£o essa √°rea de conhecimento √© chamada cripta.  E a id√©ia √© basicamente simples, um inv√≥lucro no qual apenas o endere√ßo √© armazenado e m√©todos que serializam a chamada e puxam nosso processador singleton, que faz o resto.  N√£o podemos usar o auxiliar de proxy transmitido, porque o usu√°rio n√£o o passou para n√≥s, ent√£o tivemos que torn√°-lo um singleton. <br><br>  Outro truque - na verdade, ainda usamos o contexto de chamada, esse √© um objeto que armazena informa√ß√µes sobre quem, quando, por que, por que nosso contrato inteligente foi chamado, com base nessas informa√ß√µes, o usu√°rio decide se deve executar a execu√ß√£o e, se poss√≠vel ent√£o como. <br><br>  Anteriormente, pass√°vamos o contexto simplesmente, era um campo n√£o express√°vel no tipo BaseContract com um setter e getter, e o setter permitia definir o campo apenas uma vez, para que o contexto fosse definido antes da execu√ß√£o do contrato e o usu√°rio pudesse apenas l√™-lo. <br><br>  Mas aqui est√° o problema, o usu√°rio s√≥ l√™ esse contexto, se ele faz uma chamada para algum tipo de fun√ß√£o do sistema, por exemplo, uma chamada de proxy para outro contrato, essa chamada de proxy n√£o recebe nenhum contexto, j√° que ningu√©m passa para ele.  E ent√£o o armazenamento local de goroutine entra em cena.  Decidimos n√£o escrever por conta pr√≥pria, mas use github.com/tylerb/gls. <br><br>  Permite definir e definir o contexto para a goroutina atual.  Assim, se nenhuma goroutine foi criada dentro do contrato, apenas definimos o contexto em gls antes de iniciar o contrato, agora fornecemos ao usu√°rio n√£o um m√©todo, mas apenas uma fun√ß√£o. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">core</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicCallContext</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gls.Get(<span class="hljs-string"><span class="hljs-string">"ctx"</span></span>).(*core.LogicCallContext) }</code> </pre> <br>  E ele o usa alegremente, mas n√≥s o usamos em RouteCall (), por exemplo, para entender qual contrato est√° atualmente invocando algu√©m. <br><br>  Em princ√≠pio, o usu√°rio pode criar goroutine, mas se o fizer, o contexto ser√° perdido; portanto, precisamos fazer algo com isso; por exemplo, se o usu√°rio usar a palavra-chave go, ser√° necess√°rio agrupar essas chamadas em nosso wrapper, que o contexto lembrar√° e criar√° goroutine e restaure o contexto, mas este √© o t√≥pico de outro artigo. <br><br><h2>  Todos juntos </h2><br>  Basicamente, gostamos de como a cadeia de ferramentas da linguagem GO funciona, na verdade, s√£o v√°rios comandos diferentes que fazem uma coisa, que s√£o executados juntos quando voc√™ constr√≥i, por exemplo.  Decidimos fazer o mesmo, uma equipe coloca o arquivo do contrato em um diret√≥rio tempor√°rio, o segundo coloca um wrapper e chama pela terceira vez, o que cria um proxy para cada contrato importado, o quarto compila tudo, o quinto publica no blockchain.  E h√° um comando para execut√°-los todos na ordem correta. <br><br>  Hoje, temos agora uma cadeia de ferramentas e um tempo de execu√ß√£o para o lan√ßamento do GO from GO.  Ainda existem muitos problemas, por exemplo, voc√™ precisa de alguma forma descarregar o c√≥digo n√£o utilizado, precisa determinar de alguma forma que ele trava e reiniciar o processo suspenso, mas essas s√£o tarefas claras sobre como resolv√™-lo. <br><br>  Sim, √© claro, o c√≥digo que escrevemos n√£o finge ser uma biblioteca, n√£o pode ser usado diretamente, mas ler um exemplo de gera√ß√£o de c√≥digo de trabalho √© sempre bom, ao mesmo tempo em que senti falta dele.  Por conseguinte, parte da gera√ß√£o de c√≥digo pode ser visualizada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compilador</a> , mas como √© iniciada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">executor</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425985/">https://habr.com/ru/post/pt425985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425973/index.html">Como criamos o armazenamento do S3 DataLine. Experimentos, testes e um pouco sobre hipop√≥tamos</a></li>
<li><a href="../pt425975/index.html">Converta palavras e frases em anagrama</a></li>
<li><a href="../pt425977/index.html">Flexbox: qual √© o tamanho dessa caixa flex√≠vel?</a></li>
<li><a href="../pt425981/index.html">Carreira do novato na LK: trancos e barrancos para crescer lentamente para a frente</a></li>
<li><a href="../pt425983/index.html">Seguran√ßa de v√¥o</a></li>
<li><a href="../pt425989/index.html">Sob o cap√¥ do Graveyard Keeper: como os efeitos gr√°ficos s√£o implementados</a></li>
<li><a href="../pt425991/index.html">Como criamos hospedagem</a></li>
<li><a href="../pt425993/index.html">Como preencher a lacuna de g√™nero em tecnologia</a></li>
<li><a href="../pt425995/index.html">Visualize FHIR - o padr√£o de TI para medicina</a></li>
<li><a href="../pt425997/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 11: Linguagem de Programa√ß√£o Ur / Web, Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>