<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎤 🍶 👂🏾 Suspensão sobre bloqueio 🙍🏾 🎅🏻 🐄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo tem como objetivo mostrar como usar Kotlin Coroutines e remover Reaxtive eXtensions (Rx) . 
 Benefícios 


 Para começar, vamos considerar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suspensão sobre bloqueio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465529/"><p>  Este artigo tem como objetivo mostrar como usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kotlin Coroutines</a> e remover <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reaxtive eXtensions (Rx)</a> . </p><br><h2 id="benefits">  Benefícios </h2><br><p>  Para começar, vamos considerar quatro benefícios das Coroutines sobre Rx: </p><br><h3 id="suspending-over-blocking">  Suspensão sobre bloqueio </h3><br><p>  Para executar código sem bloqueio usando Rx, você escreveria algo como isto: </p><br><pre><code class="kotlin hljs">Observable.interval(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS) .subscribe { textView.text = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$it</span></span></span><span class="hljs-string"> seconds have passed"</span></span> }</code> </pre> <br><p>  O que está criando efetivamente um novo thread.  Threads são objetos pesados ​​em termos de memória e desempenho. </p><br><p>  Ambos são críticos no mundo do desenvolvimento móvel. </p><br><p>  Você pode obter o mesmo comportamento usando o seguinte snippet: </p><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>){ textView.text = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it++}</span></span></span><span class="hljs-string"> seconds have passed"</span></span> delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) } }</code> </pre> <br><p>  Essencialmente, as Coroutines são threads leves, mas não criamos nenhum thread real. <br>  Aqui estamos usando a função delay () sem bloqueio, que é uma função de suspensão especial que não bloqueia um thread, mas suspende a Coroutine. <a name="habracut"></a></p><br><h3 id="natural-backpressure-handling-over-manual">  Manuseio de contrapressão natural sobre manual </h3><br><p>  Contrapressão é quando observáveis ​​produzem itens mais rapidamente do que seus observadores os consomem. <br>  Ao usar o Rx, é necessário especificar explicitamente como você lidará com a contrapressão. <br>  Existem 2 abordagens básicas: </p><br><ul><li>  Use operadores de limitação, buffers ou janelas </li><li>  O modelo de tração reativa </li></ul><br><p>  Enquanto as corotinas podem suspender, elas fornecem uma resposta natural para lidar com a contrapressão. <br>  Portanto, nenhuma ação adicional é necessária. </p><br><h3 id="sync-code-style-over-async">  Estilo de código de sincronização sobre async </h3><br><p>  A natureza básica de um aplicativo móvel é reagir às ações do usuário.  É por isso que as eXtensions reativas seriam uma boa escolha. </p><br><p>  No entanto, você precisa escrever um código em um estilo funcional.  Se você costumava escrever em estilo imperativo, poderia ser um pouco difícil. </p><br><p>  Enquanto as Coroutines permitem que você escreva código assíncrono como se fossem funções usuais de sincronização.  Por exemplo, </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTextFromRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = remote.getText() textView.text = text }</code> </pre> <br><p>  Mesmo que eu esteja trabalhando com estilo funcional por um longo tempo, ainda é mais fácil ler e depurar um código imperativo. </p><br><h3 id="native-over-3rd-party-lib">  Nativo acima da biblioteca de terceiros </h3><br><p>  As corotinas são um recurso nativo do Kotlin. </p><br><p>  Você não precisa adicionar nenhuma dependência adicional.  Atualmente, todas as principais bibliotecas podem lidar com corotinas. </p><br><p>  Por exemplo, </p><br><p>  Retrofit </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : List&lt;User&gt; }</code> </pre> <br><p>  Quarto </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserEntity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Portanto, você pode criar um aplicativo que seja totalmente suspenso - iniciando a camada da interface do usuário, passando pelo domínio e terminando na camada de dados. </p><br><h2 id="app">  O aplicativo </h2><br><p>  Vamos ao que interessa.  Criaremos um aplicativo clássico de detalhes mestre. <br>  A primeira página conteria uma lista infinita de entregas. <br>  No clique do item, abriremos uma página de detalhes. <br>  Além disso, ofereceremos suporte ao modo offline - todos os dados serão armazenados em cache. <br>  Além disso, usarei a arquitetura MVVM onde a função ViewModel é desempenhada pelo Fragment, em vez do ViewModel do AAC.  Existem várias razões: <br>  Fragmentos geralmente são muito carecas - basta vincular o viewModel ao XML. </p><br><p>  Recursos como definir a cor da barra de status não podem ser feitos no AAC ViewModel - é necessário acionar o método do fragmento.  O uso de fragmentos como ViewModel nos permitiria armazenar toda a funcionalidade relacionada (gerenciando uma determinada tela) em uma classe. </p><br><p>  Primeiro, vamos criar o BaseViewModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B : BaseBindings, V : ViewDataBinding</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> CoroutineScope(Dispatchers.IO){ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: B <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewBinding: V <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) retainInstance = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: View? { viewBinding = DataBindingUtil.inflate(inflater, layoutId, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewBinding.root } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewBinding.lifecycleOwner = viewLifecycleOwner viewBinding.setVariable(BR.bindings, bindings) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() } }</code> </pre> <br><p>  Marcamos nosso ViewModel como CoroutineScope, para que possamos iniciar corotinas dentro dos modelos de vista e quaisquer corotinas lançadas seriam limitadas ao ciclo de vida de um fragmento. </p><br><p>  Temos que especificar explicitamente o método <code>cancel()</code> chamada do ciclo de vida do final do escopo para cancelar todas as solicitações em execução para evitar vazamentos de memória. </p><br><p>  Definimos <code>retainInstance = true</code> para que, na configuração, o fragmento não seja recriado, para que possamos concluir todas as solicitações de execução longa. </p><br><p>  Além disso, precisamos definir o lifecycleOwner como binding para ativar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ligação de dados bidirecional</a> . </p><br><h2 id="exception-handling">  Manipulação de exceção </h2><br><p>  De acordo com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação da</a> Coroutines: </p><br><pre> <code class="plaintext hljs">Coroutine builders come in two flavors: propagating exceptions automatically (launch and actor) or exposing them to users (async and produce). The former treat exceptions as unhandled, similar to Java's Thread.uncaughtExceptionHandler</code> </pre> <br><p>  Como estamos usando o construtor de lançamentos na maioria dos casos, precisamos especificar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoroutineExceptionHandler</a> <br>  CoroutineExceptionHandler é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoroutineContext.Element</a> que pode ser usado para criar um contexto de corotina usando o operador plus. <br>  Declararei o manipulador estático da seguinte maneira: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; Timber.e(throwable) }</code> </pre> <br><p>  E mude o BaseViewModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B : BaseBindings, V : ViewDataBinding</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> CoroutineScope(Dispatchers.IO + exceptionHandler)</code> </pre> <br><p>  A partir daqui, qualquer exceção ocorrida na rotina lançada dentro do escopo do ViewModel seria entregue ao manipulador fornecido. <br>  Em seguida, preciso declarar minha API e DAO: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveriesApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"deliveries"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeliveries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"offset"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"limit"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;DeliveryResponse&gt; } <span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM </span></span><span class="hljs-subst"><span class="hljs-meta"><span class="hljs-meta-string"><span class="hljs-subst">${DeliveryEntity.TABLE_NAME}</span></span></span></span><span class="hljs-meta"><span class="hljs-meta-string">"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: DataSource.Factory&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, DeliveryEntity&gt; <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delivery: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DeliveryEntity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Como você pode ver, marquei os métodos como suspensos, para que possamos declarar apenas os objetos de resposta esperados.  Além disso, o cancelamento da rotina principal também cancelará as chamadas de rede. <br>  O mesmo para o DAO. <br>  A única diferença é que queremos fornecer a capacidade de observar o banco de dados. <br>  A maneira mais fácil é usar o suporte integrado a dados ao vivo.  Mas se marcarmos getAll () como suspenso, isso causaria um erro de compilação <br>  erro: </p><br><pre> <code class="plaintext hljs">Not sure how to convert a Cursor to this method's return type ...</code> </pre> <br><p>  Aqui não precisamos suspender porque: </p><br><ul><li>  Solicitações de banco de dados são executadas em segundo plano por padrão </li><li>  O LiveData resultante reconhece o ciclo de vida, para que não seja necessário cancelá-lo manualmente </li></ul><br><p>  De alguma forma, precisamos combinar fontes de dados remotas e locais. <br>  Vale a pena lembrar - deve haver um único ponto de verdade. <br>  De acordo com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o design offline primeiro</a> , seria o armazenamento local.  Portanto, observaríamos o estado do banco de dados.  Quando não há nada para recuperar, solicitamos dados remotos e os inserimos no banco de dados. <br>  Vamos apresentar a classe Listing </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Listing</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pagedList: LiveData&lt;PagedList&lt;T&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState: LiveData&lt;DataState&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshState: LiveData&lt;DataState&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refresh: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retry: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )</code> </pre> <br><p>  Vamos val por val: </p><br><ul><li>  pagedList - os principais dados que são construídos como PagedList para permitir rolagem infinita e agrupados com LiveData para permitir a observação de dados </li><li>  dataState - um dos três estados em que nossos dados podem estar: Sucesso, Execução, Erro.  Também agrupado no LiveData para observar alterações </li><li>  refreshState - quando acionamos a atualização de dados através do deslize para atualizar, precisamos de alguma ferramenta pela qual distinguimos entre o feedback da solicitação de atualização e o feedback da solicitação da próxima página.  Para o primeiro, queremos mostrar um erro no final da lista, mas, para o erro de atualização, queremos mostrar uma mensagem do sistema e ocultar um carregador. </li><li>  refresh () - retorno de chamada a ser acionado ao deslizar para atualizar </li><li><p>  retry () - retorno de chamada para disparar em erro de carregamento de pagedList <br>  Em seguida, modelo de exibição de lista: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryListViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeliveryListBindings, DeliveryListBinding</span></span></span><span class="hljs-class">&gt;</span></span>(), DeliveryListBindings, DeliveryListItemBindings, DeliveryListErrorBindings { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = R.layout.delivery_list <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: DeliveryListBindings = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryGateway: DeliveryGateway <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject { parametersOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> listing = deliveryGateway.getDeliveries() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState = listing.dataState <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isRefreshing = Transformations.switchMap(listing.refreshState) { MutableLiveData(it == DataState.Loading) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) setupList() setupRefresh() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapter = DeliveriesAdapter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) viewBinding.deliveries.adapter = adapter viewBinding.deliveries.setHasFixedSize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) listing.pagedList.observe(viewLifecycleOwner, Observer { adapter.submitList(it) }) listing.dataState.observe(viewLifecycleOwner, Observer { adapter.updateDataState(it) }) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupRefresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.refreshState.observe(viewLifecycleOwner, Observer { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DataState.Error) { Toast.makeText(context, it.message, LENGTH_SHORT).show() } }) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.refresh() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDeliveryClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delivery: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Delivery</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { view?.findNavController()?.navigate(DeliveryListViewModelDirections.toDetails(delivery)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRetryClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.retry() } }</code> </pre> <br><p>  Vamos começar com a declaração de classe. </p><br></li></ul><br><p>  Primeiro de tudo DeliveryListBindings e DeliveryListBinding.  Primeiro é a nossa interface declarada para colar o modelo de visualização com a visualização XML.  O segundo é a classe gerada automaticamente com base em XML.  Precisamos do segundo para definir nossa interface de ligações e ciclo de vida para XML. </p><br><p>  Além disso, é uma boa prática referenciar vistas usando essa ligação gerada automaticamente em vez de usar o sintético de kotlin. </p><br><p>  Pode haver um caso em que a referência sintética não existe na visualização atual.  Com a ligação de dados, você falhará rapidamente, mesmo no estágio de compilação. </p><br><p>  A seguir, três interfaces: DeliveryListBindings, DeliveryListItemBindings, DeliveryListErrorBindings. </p><br><ol><li>  <em>DeliveryListBindings</em> - ligações para a própria tela.  Por exemplo, ele contém o método refresh () chamado de furto vertical. </li><li>  <em>DeliveryListItemBindings</em> - ligações para um item na lista.  Por exemplo, onClicked () </li><li>  <em>DeliveryListErrorBindings</em> - ligações para exibição de erro, que também é o item de lista mostrado no estado de erro.  Por exemplo, ele contém o método retry () </li></ol><br><p>  Assim, estamos lidando com tudo no modelo de visualização única, pois é uma tela única, mas também seguindo o princípio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segregação de Interface</a> </p><br><p>  Vamos dar atenção especial a esta linha: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryGateway: DeliveryGateway <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject { parametersOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }</code> </pre> <br><p>  <em>DeliveryGateway</em> precisa executar solicitações fora do encadeamento principal.  Portanto, ele precisa declarar métodos como suspensos ou CoroutineScope para lançar novas corotinas nesse escopo.  Escolheríamos a segunda abordagem, pois precisamos dos nossos LiveData desde o início e esperaríamos apenas atualizações.  É muito semelhante a se inscrever na instância liveData quando estamos passando o lifecycleOwner (que geralmente se refere a 'this').  Aqui estão da mesma maneira que estamos passando 'isso' como CoroutineScope </p><br><p>  A interface CoroutineScope consiste em um único campo - CoroutineContext.  Em essência, um escopo e um contexto são as mesmas coisas.  A diferença entre um contexto e um escopo está na finalidade pretendida. </p><br><p>  Para saber mais sobre isso, eu recomendaria um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> de Roman Elizarov.  Portanto, fornecer escopo ao <em>DeliveryGateway</em> também resultará no uso do mesmo contexto.  Especificamente thread, trabalho e manipulador de exceções. <br>  Agora vamos dar uma olhada no DeliveryGateway: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryBoundGateway</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> db: DataBase, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: DeliveriesApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryDao: DeliveryDao, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineScope: CoroutineScope ) : DeliveryGateway { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boundaryCallback = DeliveriesBoundaryCallback( api = api, coroutineScope = coroutineScope, handleResponse = { insertIntoDatabase(it) } ) <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeliveries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Listing&lt;Delivery&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshTrigger = MutableLiveData&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshState = Transformations.switchMap(refreshTrigger) { refresh() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pagingConfig = Config( initialLoadSizeHint = PAGE_SIZE, pageSize = PAGE_SIZE, prefetchDistance = PAGE_SIZE ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveries = deliveryDao.getAll() .toLiveData( config = pagingConfig, boundaryCallback = boundaryCallback ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Listing( pagedList = deliveries, dataState = boundaryCallback.dataState, retry = { boundaryCallback.helper.retryAllFailed() }, refresh = { refreshTrigger.value = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }, refreshState = refreshState ) } <span class="hljs-comment"><span class="hljs-comment">/** * When refresh is called, we simply run a fresh network request and when it arrives, clear * the database table and insert all new items in a transaction. * &lt;p&gt; * Since the PagedList already uses a database bound data source, it will automatically be * updated after the database transaction is finished. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: LiveData&lt;DataState&gt; { boundaryCallback.refresh() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState = MutableLiveData&lt;DataState&gt;() dataState.value = DataState.Loading coroutineScope.launch { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveries = api.getDeliveries(<span class="hljs-number"><span class="hljs-number">0</span></span>, PAGE_SIZE) db.withTransaction { deliveryDao.clear() insertIntoDatabase(deliveries) } dataState.postValue(DataState.Loaded) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { Timber.w(throwable) dataState.postValue(DataState.Error(throwable.message)) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataState } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertIntoDatabase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(deliveries: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DeliveryResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { deliveries.forEach { delivery -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> entity = deliveryConverter.fromNetwork(delivery) deliveryDao.insert(entity) } } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PAGE_SIZE = <span class="hljs-number"><span class="hljs-number">20</span></span> } }</code> </pre> <br><p>  Aqui estamos construindo a estrutura do LiveData desde o início e, em seguida, usando corotinas para carregar dados e publicá-los no LiveData.  Além disso, estamos usando a implementação de <em>PagedList.BoundaryCallback () para colar o banco de dados local e a API remota.</em>  <em>Quando chegamos ao final da lista paginada, <em>boundaryCallback</em> é acionado e carrega a próxima parte dos dados.</em> <br></p><p>  Como você pode ver, estamos usando o coroutineScope para lançar novas coroutines. </p><br><p>  Como esse escopo é igual ao ciclo de vida do fragmento - todas as solicitações pendentes seriam canceladas no retorno de chamada <code>onDestroy()</code> do fragmento. </p><br><p>  A página de detalhes da entrega é bem direta - passamos um objeto Delivery como Parcelable da tela principal, usando o plug-in save args do componente de navegação.  Na tela de detalhes, basta ligar um dado objeto a um XML. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeliveryBindings, DeliveryBinding</span></span></span><span class="hljs-class">&gt;</span></span>(), DeliveryBindings { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = R.layout.delivery <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: DeliveryBindings = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> args: DeliveryViewModelArgs <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> navArgs() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewBinding.delivery = args.delivery viewBinding.image.clipToOutline = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h2 id="contact-me">  Entre em contato comigo </h2><br><p>  Aqui está o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> para o código-fonte do github. </p><br><p>  Você pode deixar comentários e questões em aberto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465529/">https://habr.com/ru/post/pt465529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465519/index.html">Exposição PRO // Movement.Expo</a></li>
<li><a href="../pt465521/index.html">Fly-fly-pétala ... ou uma história sobre como o designer de UX promoveu seu produto no Instagram</a></li>
<li><a href="../pt465523/index.html">Mais uma cobra Android com Kivy, Python</a></li>
<li><a href="../pt465525/index.html">Relatórios móveis no Oracle BI EE 12c - um, dois, três. Metodologia do Curso de Oracle BI EE 12c CAD</a></li>
<li><a href="../pt465527/index.html">A longa jornada do RFC 4357 ao RFC 8645 ou como gerenciar chaves de criptografia</a></li>
<li><a href="../pt465531/index.html">Descompactando listas aninhadas de profundidade indefinida</a></li>
<li><a href="../pt465535/index.html">Quem implementa o IPv6 e o ​​que dificulta o seu desenvolvimento</a></li>
<li><a href="../pt465537/index.html">Yandex: uma casa inteligente para adultos</a></li>
<li><a href="../pt465539/index.html">766 km - um novo recorde de alcance para o LoRaWAN</a></li>
<li><a href="../pt465541/index.html">Das empresas às pequenas e médias empresas: compartilhamos nossa experiência na adaptação de soluções corporativas para pequenas e médias empresas com monetização usando o modelo SaaS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>