<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤭 🚬 💸 OpenSceneGraph：基本编程技术 🤟🏽 🖥️ 🧓🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 考虑到OpenSceneGraph引擎及其提供的软件的细节，本文将不仅仅关注图形，而是应如何组织使用图形的应用程序。 

 众所周知，任何软件产品成功的关键都是设计良好的体系结构，该体系结构能够维护和扩展编写的代码。 从这个意义上讲，我们正在考虑的引擎处于较高水平，为开发人员提供了非常广泛...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph：基本编程技术</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437688/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="图片"><br><h1> 引言 </h1><br> 考虑到OpenSceneGraph引擎及其提供的软件的细节，本文将不仅仅关注图形，而是应如何组织使用图形的应用程序。 <br><br> 众所周知，任何软件产品成功的关键都是设计良好的体系结构，该体系结构能够维护和扩展编写的代码。 从这个意义上讲，我们正在考虑的引擎处于较高水平，为开发人员提供了非常广泛的工具包，提供了灵活的模块化体系结构的构建。 <br><br> 本文篇幅相当长，概述了开发人员引擎提供的各种工具和技术（如果需要，可提供设计模式）。 本文的所有部分都提供了示例，其代码可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的存储库中获取</a> 。 <br><a name="habracut"></a><br><h1>  1.解析命令行选项 </h1><br> 在C / C ++中，命令行参数通过参数传递给main（）函数。 在过去的示例中，我们仔细地将这些参数标记为未使用，现在我们将使用它们来告诉我们的程序启动时一些数据。 <br><br>  OSG具有内置的命令行解析工具。 <br><br> 创建以下示例 <br><br><div class="spoiler">  <b class="spoiler_title">命令行示例</b> <div class="spoiler_text">  <strong>主文件</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre> <br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); std::string filename; args.read(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"--model"</span></span></span><span class="hljs-meta">, filename); osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br> 在QtCreator中设置程序启动参数 <br><br><img src="https://habrastorage.org/webt/41/le/8p/41le8pjjdv2q-in3idhgnpe6-ao.png"><br><br> 运行程序执行，我们得到结果（卡车模型<a href="">取自相同的OpenSceneGraph-Data</a> ） <br><br><img src="https://habrastorage.org/webt/t-/_o/bb/t-_obbiwlzwuax1e336kqd6tosy.png"><br><br> 现在让我们逐行看一个示例 <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>;</code> </pre><br> 创建osg :: ArgumentParser命令行解析器类的实例。 创建后，将向类构造函数传递由操作系统的main（）函数接受的参数。 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filename; args.read(<span class="hljs-string"><span class="hljs-string">"--model"</span></span>, filename);</code> </pre><br> 我们分析参数，即在其中寻找“ –model”键，并将其值放入字符串文件名中。 因此，使用此密钥，我们将具有三维模型的文件名传输到程序。 接下来，我们加载此模型并显示它 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  osg :: ArgumentParser类的read（）方法有很多重载，使您不仅可以从命令行读取字符串值，还可以读取整数，浮点数，向量等。 例如，您可以读取float类型的某个参数 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> size = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; args.read(<span class="hljs-string"><span class="hljs-string">"--size"</span></span>, size);</code> </pre><br> 如果此参数未在命令行上显示，则其值将保留初始化size变量后的值。 <br><br><h1>  2.通知和日志记录机制 </h1><br>  OpenSceneGraph具有通知机制，可让您在渲染过程中以及由开发人员启动时显示调试消息。 在跟踪和调试程序时，这是一个很大的帮助。  OSG通知系统支持引擎核心级别及其插件的诊断信息（错误，警告，通知）的输出。 开发人员可以在程序操作期间使用osg :: notify（）函数显示诊断消息。 <br><br> 通过操作符重载&lt;&lt;，此函数可以用作标准C ++库的标准输出流。 它以消息级别作为参数：始终，致命，警告，通知，信息，DEBUG_INFO和DEBUG_FP。 举个例子 <br><br><pre> <code class="cpp hljs">osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some warning message"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br> 显示带有用户定义文本的警告。 <br><br>  OSG通知可以包含有关程序状态，计算机图形子系统的扩展以及引擎可能出现的问题的重要信息。 <br><br> 在某些情况下，需要将此数据输出到控制台，而不是将其输出到文件（以日志的形式）或任何其他界面，包括图形小部件，而不是输出到控制台。 该引擎包含一个特殊的类osg :: NotifyHandler，该类将通知重定向到开发人员需要的输出流。 <br><br> 通过一个简单的示例，考虑如何将通知输出重定向到文本日志文件。 编写以下代码 <br><br><div class="spoiler">  <b class="spoiler_title">通知范例</b> <div class="spoiler_text">  <strong>主文件</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;fstream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class LogFileHandler : public osg::NotifyHandler { public: LogFileHandler(const std::string &amp;file) { _log.open(file.c_str()); } virtual ~LogFileHandler() { _log.close(); } virtual void notify(osg::NotifySeverity severity, const char *msg) { _log </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; msg; } protected: std::ofstream _log; }; int main(int argc, char *argv[]) { osg::setNotifyLevel(osg::INFO); osg::setNotifyHandler(new LogFileHandler("../logs/log.txt")); osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data loaded." &lt;&lt; std::endl; return -1; } osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br> 为了重定向输出，我们编写LogFileHandler类，它是osg :: NotifyHandler的后继。 此类的构造函数和析构函数控制与文本文件关联的_log输出流的打开和关闭。  notify（）方法是类似的基类方法，我们将其重新定义为在操作期间通过msg参数输出到OSG发送的文件通知。 <br><br>  <strong>类LogFileHandler</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogFileHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NotifyHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LogFileHandler(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;file) { _log.open(file.c_str()); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~LogFileHandler() { _log.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NotifySeverity severity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg)</span></span></span><span class="hljs-function"> </span></span>{ _log &lt;&lt; msg; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ofstream _log; };</code> </pre><br> 接下来，在主程序中，进行必要的设置 <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::INFO);</code> </pre><br> 设置INFO通知的级别，即将有关引擎运行的所有信息（包括当前的正常运行通知）输出到日志。 <br><br><pre> <code class="cpp hljs">osg::setNotifyHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogFileHandler(<span class="hljs-string"><span class="hljs-string">"../logs/log.txt"</span></span>));</code> </pre><br> 安装通知处理程序。 接下来，我们处理命令行参数，在其中传递加载模型的路径 <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data loaded."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br> 同时，我们处理命令行上缺少数据的情况，使用OSG_FATAL宏以手动模式在日志中显示一条消息。 使用以下参数运行程序 <br><br><img src="https://habrastorage.org/webt/mc/h4/so/mch4sot5pfjjpq9vb2dlolnjllm.png"><br><br> 输出到这样的日志文件 <br><br><div class="spoiler">  <b class="spoiler_title">OSG日志示例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll OSGReaderWriter wrappers loaded OK CullSettings::readEnvironmentalVariables() void StateSet::setGlobalDefaults() void StateSet::setGlobalDefaults() ShaderPipeline disabled. StateSet::setGlobalDefaults() Setting up GL2 compatible shaders CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce8f0 CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce330 View::setSceneData() Reusing existing scene0xa514220 CameraManipulator::computeHomePosition(0, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 CameraManipulator::computeHomePosition(0xa52f138, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 Viewer::realize() - No valid contexts found, setting up view across all screens. Applying osgViewer::ViewConfig : AcrossAllScreens . . . . ShaderComposer::~ShaderComposer() 0xa5ce330 ShaderComposer::~ShaderComposer() 0xa5ce8f0 ShaderComposer::~ShaderComposer() 0xa5d6228 close(0x1)0xa5d3e50 close(0)0xa5d3e50 ContextData::unregisterGraphicsContext 0xa5d3e50 DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. ShaderComposer::~ShaderComposer() 0xa5de4e0 close(0x1)0xa5ddba0 close(0)0xa5ddba0 ContextData::unregisterGraphicsContext 0xa5ddba0 Done destructing osg::View DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll</code> </pre><br></div></div><br> 没关系，此信息对您而言似乎毫无意义-将来，这样的结论可以帮助调试程序中的错误。 <br><br> 默认情况下，OSG将消息发送到std :: cout标准输出，并将错误消息发送到std :: cerr流。 但是，通过覆盖通知处理程序（如示例中所示），可以将此输出重定向到任何输出流，包括GUI元素。 <br><br> 请记住，设置较高级别的通知（例如FATAL）时，系统将忽略所有较低级别的通知。 例如，在类似情况下 <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::FATAL); . . . osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some message."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br> 自定义消息将不会显示。 <br><br><h1>  3.拦截几何属性 </h1><br>  osg :: Geometry类管理一组描述顶点的数据，并使用一组有序的图元显示多边形网格。 但是，此类不了解模型的拓扑元素，例如面，边以及它们之间的关系。 这种细微差别可防止诸如在制作模型动画时移动某些面孔之类的事情。  OSG当前不支持此功能。 <br><br> 但是，引擎实现了许多函子，使您可以重新读取任何对象的几何属性，并使用它们对多边形网格的拓扑进行建模。 在C ++中，函子是一种允许您将对象用作函数的构造。 <br><br>  osg :: Drawable类为开发人员提供了四种类型的函子： <br><br><ol><li>  osg :: Drawable :: AttributeFunctor-读取顶点的属性作为指针数组。 它具有许多用于应用不同数据类型的顶点属性的虚拟方法。 要使用此函子，您必须描述该类并覆盖其一个或多个方法，在该方法中将执行开发人员所需的操作 <br></li></ol><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Drawable::AttributeType type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, osg::Vec3* ptr )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  3-     ptr. //      }</span></span></code> </pre><br><ol><li>  osg :: Drawable :: ConstAttributeFunctor-先前函子的只读版本：指向向量数组的指针作为常量参数传递 <br></li><li>  osg :: PrimitiveFunctor-模仿渲染OpenGL对象的过程。 以渲染对象为幌子，调用了开发人员重写的函子方法。 该仿函数具有两个重要的模板子类：osg :: TemplatePrimitiveFunctor &lt;&gt;和osg :: TriangleFunctor &lt;&gt;。 这些类接收原始顶点作为参数，并使用operator（）运算符将它们传递给用户方法。 <br></li><li>  osg :: PrimitiveIndexFunctor-执行与上一个函子相同的操作，但接受图元的顶点索引作为参数。 <br></li></ol><br> 从osg :: Drawable派生的类（例如osg :: ShapeDrawable和osg :: Geometry）具有用于应用各种函子的accept（）方法。 <br><br><h1>  4.使用原始函子的示例 </h1><br> 我们以收集关于三角形面和我们先前确定的某些几何形状的点的信息为例来说明所描述的功能。 <br><br><div class="spoiler">  <b class="spoiler_title">函子示例</b> <div class="spoiler_text">  <strong>主文件</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/TriangleFunctor&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> std::string vec2str(const osg::Vec3 &amp;v) { std::string tmp = std::to_string(vx()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vy()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vz()); return tmp; } struct FaceCollector { void operator()(const osg::Vec3 &amp;v1, const osg::Vec3 &amp;v2, const osg::Vec3 &amp;v3) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Face vertices: " &lt;&lt; vec2str(v1) &lt;&lt; "; " &lt;&lt; vec2str(v2) &lt;&lt; "; " &lt;&lt; vec2str(v3) &lt;&lt; std::endl; } }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUAD_STRIP, 0, 10)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br> 省略了我们多次考虑的创建几何的过程，让我们注意以下几点。 我们定义一个FaceCollector结构，为此我们重新定义operator（），如下所示 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FaceCollector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Face vertices: "</span></span> &lt;&lt; vec2str(v1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v2) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v3) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br> 调用此运算符时，它将显示引擎传输给它的三个顶点的坐标。 需要使用vec2str函数将osg :: Vec3向量的组件转换为std :: string。 要调用函子，请创建函子的实例，然后通过accept（）方法将其传递给几何对象 <br><br><pre> <code class="cpp hljs">osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor);</code> </pre><br> 如上所述，此调用模仿了几何图形的渲染，通过调用重写的仿函数方法来替换图形本身。 在这种情况下，将在构成示例几何图形的每个三角形的“绘制”期间调用它。 <br><br> 在屏幕上，我们得到了这样的几何 <br><br><img src="https://habrastorage.org/webt/ai/-a/6v/ai-a6vj4eeubetgk0bpicmjbgfm.png"><br><br> 和这样的累赘控制台 <br><br><pre> <code class="plaintext hljs">Face vertices: 0.000000 0.000000 0.000000; 0.000000 0.000000 1.000000; 1.000000 0.000000 0.000000 Face vertices: 0.000000 0.000000 1.000000; 1.000000 0.000000 1.500000; 1.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 0.000000; 1.000000 0.000000 1.500000; 2.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 1.500000; 2.000000 0.000000 1.000000; 2.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 0.000000; 2.000000 0.000000 1.000000; 3.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 1.000000; 3.000000 0.000000 1.500000; 3.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 0.000000; 3.000000 0.000000 1.500000; 4.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 1.500000; 4.000000 0.000000 1.000000; 4.000000 0.000000 0.000000</code> </pre><br> 实际上，当调用geom-&gt; accept（...）时，不会渲染三角形，而是模拟OpenGL调用，而不是模拟三角形的顶点数据，而是模拟它们的渲染 <br><br><img src="https://habrastorage.org/webt/gx/gp/il/gxgpilewn7pw26w9tdy-e28ypds.png"><br><br>  osg :: TemplatePrimitiveFunctor类不仅收集有关三角形的数据，而且还收集任何其他OpenGL原语的数据。 要实现此数据的处理，必须在template参数中覆盖以下运算符 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   void operator()( const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool );</span></span></code> </pre><br><br><h1>  5.访客模式 </h1><br> 访问者模式用于访问操作以更改场景图的元素，而无需更改这些元素的类。 访客类实现所有相关的虚拟功能，以通过双重调度机制将其应用于各种类型的元素。 使用这种机制，开发人员可以通过在特殊操作员的帮助下实现所需的功能来创建自己的访问者实例，并将访问者动态绑定到各种类型的场景图元素，而无需更改元素本身的功能。 这是扩展元素功能而不定义这些元素的子类的好方法。 <br><br> 为了在OSG中实现此机制，定义了osg :: NodeVisitor类。 从osg :: NodeVisitor继承的类在场景图周围移动，访问每个节点，并将开发人员定义的操作应用于该节点。 这是用于干预节点更新和裁剪不可见节点以及应用与修改场景节点的几何形状有关的其他一些操作的主要类，例如osgUtil :: SmoothingVisitor，osgUtil :: Simplifier和osgUtil :: TriStripVisitor。 <br><br> 要对访问者进行子类化，我们必须重写osg :: NodeVisitor基类提供的一个或多个虚拟重载的apply（）方法。 大多数主要的OSG节点类型都具有这些方法。 当遍历场景图时，访问者将自动为每个访问的节点调用apply（）方法。 开发人员将覆盖他需要的每种节点类型的apply（）方法。 <br><br> 在执行apply（）方法时，开发人员必须在适当的时候调用osg :: NodeVisitor基类的traverse（）方法。 如果当前节点没有可以进行转换的子节点，则这将启动访问者到下一个节点的过渡，该节点是层次结构级别的子节点或邻居节点。 缺少对遍历（）的调用意味着停止遍历场景图，其余场景图将被忽略。 <br><br>  apply（）方法的重载具有统一的格式 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Node&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Geode&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Group&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Transform&amp; )</span></span></span></span>;</code> </pre><br> 要绕过访问者对象的当前节点的子图，必须设置爬网模式，例如， <br><br><pre> <code class="cpp hljs">ExampleVisitor visitor; visitor-&gt;setTraversalMode( osg::NodeVisitor::TRAVERSE_ALL_CHILDREN ); node-&gt;accept( visitor );</code> </pre><br> 旁路模式由多个枚举器设置 <br><br><ol><li>  TRAVERSE_ALL_CHILDREN-在所有子节点之间移动。 <br></li><li>  TRAVERSE_PARENTS-从当前节点传回，而不到达根节点 <br></li><li>  TRAVERSE_ACTIVE_CHILDREN-绕过专用活动节点，即那些通过osg :: Switch节点激活可见性的节点。 <br></li></ol><br><br><h1>  6.燃烧舱的结构分析 </h1><br> 开发人员始终可以分析由从文件加载的模型生成的场景图的那部分。 <br><br><div class="spoiler">  <b class="spoiler_title">函子示例</b> <div class="spoiler_text">  <strong>主文件</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class InfoVisitor : public osg::NodeVisitor { public: InfoVisitor() : _level(0) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } std::string spaces() { return std::string(_level * 2, ' '); } virtual void apply(osg::Node &amp;node); virtual void apply(osg::Geode &amp;geode); protected: unsigned int _level; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Node &amp;node) { std::cout &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; "::" &lt;&lt; node.className() &lt;&lt; std::endl; _level++; traverse(node); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Geode &amp;geode) { std::cout &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; "::" &lt;&lt; geode.className() &lt;&lt; std::endl; _level++; for (unsigned int i = 0; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); std::cout &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; "::" &lt;&lt; drawable-&gt;className() &lt;&lt; std::endl; } traverse(geode); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data leaded. " &lt;&lt; std::endl; return -1; } InfoVisitor infoVisitor; root-&gt;accept(infoVisitor); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br> 我们创建InfoVisitor类，并从osg :: NodeVisitor继承它 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InfoVisitor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeVisitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: InfoVisitor() : _level(<span class="hljs-number"><span class="hljs-number">0</span></span>) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(_level * <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node &amp;node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Geode &amp;geode)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _level; };</code> </pre><br>  protected _level属性将指向我们的访问者类当前所在的场景图的级别。 在构造函数中，初始化级别计数器并设置节点遍历的模式-绕过所有子节点。 <br><br> 现在重新定义节点的apply（）方法 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Node &amp;node) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; traverse(node); _level--; }</code> </pre><br> 在这里，我们将输出当前节点的类型。 节点的libraryName（）方法显示实现该节点的OSG库的名称，而className方法显示节点类的名称。 这些方法是通过使用OSG库代码中的宏来实现的。 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br> 之后，我们增加图级别计数器，并调用traverse（）方法，以开始向子节点的更高级别的过渡。 从遍历（）返回之后，我们再次减小计数器值。 很容易猜到traverse（）引发了对apply（）方法的重复调用，对于从当前节点开始的子图，已经重复了traverse（）。 我们得到递归的访问者执行，直到命中场景图的末端节点。 <br><br> 对于类型为osg :: Geode的终端节点，其apply（）方法的重载将被覆盖 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Geode &amp;geode) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; geode.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } traverse(geode); _level--; }</code> </pre><br> 使用类似的工作代码，除了我们在连接到当前几何节点的所有几何对象上显示数据 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br> 在main（）函数中，我们处理命令行参数，通过该参数我们传递加载到场景中的模型列表并形成场景 <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data leaded. "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br> 同时，我们处理与命令行中缺少模型文件名有关的错误。 现在，我们创建一个访问者类，并将其传递给场景图以执行 <br><br><pre> <code class="cpp hljs">InfoVisitor infoVisitor; root-&gt;accept(infoVisitor);</code> </pre><br> 接下来是启动查看器的步骤，我们已经完成了很多次。 用参数启动程序之后 <br><br><pre> <code class="bash hljs">$ visitor ../data/cessnafire.osg</code> </pre><br> 我们将在控制台看到以下输出 <br><br><pre> <code class="plaintext hljs">osg::Group osg::MatrixTransform osg::Geode osg::Geometry osg::Geometry osg::MatrixTransform osgParticle::ModularEmitter osgParticle::ModularEmitter osgParticle::ParticleSystemUpdater osg::Geode osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem</code> </pre><br> 实际上，我们得到了加载场景的完整树。 请问，哪里有那么多节点？ 一切都非常简单-.osg格式的模型本身是容器，该容器不仅存储有关模型几何数据的数据，而且还以OSG场景的子图形式存储有关其结构的其他信息。 模型的几何形状，转换，实现烟雾和火焰的粒子效果都是OSG场景图的所有节点。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何场景都可以从* .osg下载或从查看器中卸载为* .osg格式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是应用访客机制的简单示例。</font><font style="vertical-align: inherit;">实际上，在内部访问者中，您可以在程序运行时执行很多操作来修改节点。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.通过重写traverse（）方法来控制场景图中节点的行为 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用OSG的一种重要方法是重写traverse（）方法。每次绘制框架时都会调用此方法。它们接受类型为osg :: NodeVisitor＆的参数，该参数报告当前正在执行场景图的哪个通道（更新，事件处理或剪辑）。大多数OSG主机都重写此方法来实现其功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应当记住，重写traverse（）方法可能很危险，因为它会影响遍历场景图的过程，并可能导致场景的错误显示。如果要向几种类型的节点添加新功能，也很不方便。在这种情况下，将使用节点回调，有关其的对话将降低一些。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经知道osg :: Switch节点可以控制其子节点的显示，包括某些节点的显示和关闭其他节点的显示。</font><font style="vertical-align: inherit;">但是他不知道如何自动执行此操作，因此我们将基于旧节点创建一个新节点，该节点将根据内部计数器的值在不同时间点在子节点之间切换。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animswitch示例</font></font></b> <div class="spoiler_text">  <strong>主文件</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AnimatingSwitch : public osg::Switch { public: AnimatingSwitch() : osg::Switch(), _count(0) {} AnimatingSwitch(const AnimatingSwitch &amp;copy, const osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); virtual void traverse(osg::NodeVisitor &amp;nv); protected: unsigned int _count; }; void AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { if (!((++_count) % 60) ) { setValue(0, !getValue(0)); setValue(1, !getValue(1)); } osg::Switch::traverse(nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;AnimatingSwitch&gt; root = new AnimatingSwitch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看一下这个例子。</font><font style="vertical-align: inherit;">我们正在创建一个新的AnimatingSwitch类，该类继承自osg :: Switch。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimatingSwitch</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Switch { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor &amp;nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此类包含默认构造函数。 </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 以及根据OSG要求创建的用于复制的构造函数 </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复制的构造函数应包含以下参数：对要复制的类实例的常量引用，以及用于指定类的复制设置的osg :: CopyOp参数。</font><font style="vertical-align: inherit;">跟着很奇怪的字母</font></font><br><br><pre> <code class="cpp hljs">META_Node(osg, AnimatingSwitch);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个宏，它构成从osg :: Node派生的类的后代所必需的结构。</font><font style="vertical-align: inherit;">在我们重视该宏之前，重要的是在定义所有子类时，从osg :: Switch继承时必须存在该宏。</font><font style="vertical-align: inherit;">该类包含受保护的字段_count-我们根据其切换的计数器。</font><font style="vertical-align: inherit;">我们在重写traverse（）方法时实现了切换</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 每当计数器的值（增加每个方法调用的值）为60的倍数时，就会切换节点的显示状态。我们编译示例并运行它 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于traverse（）方法不断为各种类型的节点重新定义，因此它应提供一种获取转换矩阵和渲染状态的机制，以供其重载算法进一步使用。</font><font style="vertical-align: inherit;">输入参数osg :: NodeVisitor是使用节点进行各种操作的关键。</font><font style="vertical-align: inherit;">特别是，它指示场景图的当前遍历类型，例如更新，处理事件和修剪不可见的面孔。</font><font style="vertical-align: inherit;">前两个与节点回调有关，在研究动画时将予以考虑。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过将osg :: NodeVisitor转换为osg :: CullVisitor对象来标识剪辑通道</font></font><br><br><pre> <code class="cpp hljs">osgUtil::CullVisitor *cv = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgUtil::CullVisitor *&gt;(&amp;nv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cv) { <span class="hljs-comment"><span class="hljs-comment">///  - ,     }</span></span></code> </pre><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.回调机制 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一篇文章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们通过在场景渲染周期内更改其变换的参数来实现场景对象的动画。正如很多次提到的那样，这种方法在多线程渲染中包含潜在的危险应用程序行为。为了解决此问题，使用了遍历场景图时执行的回调机制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引擎中有几种回调类型。回调由特殊类实现，其中osg :: NodeCallback设计为处理场景节点的更新过程，而osg :: Drawable :: UpdateCallback，osg :: Drawable :: EventCallback和osg :: Drawable：CullCallback-执行相同的功能，但是用于几何对象。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">osg :: NodeCallback类具有开发人员提供的可重写虚拟运算符（）运算符，用于实现其自身的功能。</font><font style="vertical-align: inherit;">为了使回调起作用，您必须通过调用setUpdateCallback（）或addUpdateCallback（）方法将调用类的实例附加到将对其进行处理的节点。</font><font style="vertical-align: inherit;">渲染每一帧时，在场景图中的节点更新期间会自动调用operator（）运算符。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下表列出了OSG中可供开发人员使用的回调。</font></font><br><br><table><thead><tr><th> 名 </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 回调函子 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 虚方法 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 附着对象的方法 </font></font></th></tr></thead><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 节点更新 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运算子（） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg ::节点:: setUpdateCallback（） </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 节点事件 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运算子（） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg ::节点:: setEventCallback（） </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 节点裁剪 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运算子（） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg ::节点:: setCullCallback（） </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 几何更新 </font></font></td><td> osg::Drawable::UpdateCallback </td><td> update() </td><td> osg::Drawable::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Drawable::EventCallback </td><td> event() </td><td> osg::Drawable::setEventCallback() </td></tr><tr><td>   </td><td> osg::Drawable::CullCallback </td><td> cull() </td><td> osg::Drawable::setCullCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setEventCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setEvevtCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PreDrawCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PostDrawCallback() </td></tr></tbody></table><br><br><h1> 9.  osg::Switch     </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稍微高一点，我们写了一个示例，说明了切换两种飞机模型的情况。</font><font style="vertical-align: inherit;">现在我们将重复这个示例，但是我们将使用OSG回调机制正确地完成所有操作。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带示例的回调</font></font></b> <div class="spoiler_text">  <strong>主文件</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class SwitchingCallback : public osg::NodeCallback { public: SwitchingCallback() : _count(0) {} virtual void operator()(osg::Node *node, osg::NodeVisitor *nv); protected: unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void SwitchingCallback::operator()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = static_cast&lt;osg::Switch *&gt;(node); if ( !((++_count) % 60) &amp;&amp; switchNode ) { switchNode-&gt;setValue(0, !switchNode-&gt;getValue(0)); switchNode-&gt;setValue(1, !switchNode-&gt;getValue(0)); } traverse(node, nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1, true); root-&gt;addChild(model2, false); root-&gt;setUpdateCallback( new SwitchingCallback ); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 您必须创建一个从osg :: NodeCallback继承的类，该类控制osg :: Switch节点 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwitchingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SwitchingCallback() : _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node *node, osg::NodeVisitor *nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_count计数器将控制osg :: Switch节点从一个子节点映射到另一个子节点的切换，具体取决于其值。</font><font style="vertical-align: inherit;">在构造函数中，我们初始化计数器，然后重新定义虚拟操作符（）方法</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SwitchingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } traverse(node, nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用工作的节点通过node参数传递给它。</font><font style="vertical-align: inherit;">由于我们肯定知道这将是osg :: Switch类型的节点，因此我们将指向该节点的指针静态转换为指向该switch节点的指针</font></font><br><br><pre> <code class="cpp hljs">osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将使用此指针的有效值以及计数器值为60的倍数切换显示的子节点。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不要忘记调用traverse（）方法以继续场景图的递归遍历 </font></font><br><br><pre> <code class="cpp hljs">traverse(node, nv);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 程序代码的其余部分都很简单，除了以下行 </font></font><br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SwitchingCallback );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们将创建的回调分配给osg :: Switch类型的根节点。</font><font style="vertical-align: inherit;">该程序的工作方式与前面的示例相似</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们已经使用了神秘的traverse（）方法来实现两个目的：在后继类中重写此方法，并在osg :: NodeVisitor类上调用此方法以继续遍历场景图。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在刚刚检查的示例中，我们使用调用traverse（）的第三个选项，将指向节点的指针和指向访问者实例的指针作为参数传递。与前两种情况一样，如果在该节点上未调用traverse（），则场景图的爬网将停止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addUpdateCallback（）方法还用于向节点添加回调。与setUpdateCallback（）不同，它用于向现有回调中添加另一个回调。因此，同一节点可能有多个回调。</font></font><br><br><h1> 结论 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查了使用OpenSceneGraph图形引擎开发应用程序时使用的基本技术。</font><font style="vertical-align: inherit;">但是，这与我想谈的所有要点相去甚远（尽管事实证明这篇文章很长），因此</font></font><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">待续...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437688/">https://habr.com/ru/post/zh-CN437688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437676/index.html">利用大学和企业加速器在美国启动B2B初创企业</a></li>
<li><a href="../zh-CN437680/index.html">我在YouTube上的DIY收藏</a></li>
<li><a href="../zh-CN437682/index.html">编写另一个Kubernetes模板工具</a></li>
<li><a href="../zh-CN437684/index.html">最高算法-有偏纲</a></li>
<li><a href="../zh-CN437686/index.html">学习去：编写具有端到端加密的p2p Messenger</a></li>
<li><a href="../zh-CN437694/index.html">分析实用程序Files.walkFileTree（）;</a></li>
<li><a href="../zh-CN437696/index.html">＃283移动开发人员的有趣材料摘要（1月21日至27日）</a></li>
<li><a href="../zh-CN437698/index.html">WIPO翻译专利翻译服务-我的经验</a></li>
<li><a href="../zh-CN437702/index.html">Google求职面试解析：同义查询</a></li>
<li><a href="../zh-CN437704/index.html">对学校课程的丰富知识可以指示不是最高的智力</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>