<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏾 🏒 😝 Praktikum bei JetBrains und wie ich es fast geschafft hätte 👵🏼 🌕 🏂🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie viele junge Entwickler schaue ich, wenn der Wunsch besteht, einen Job / ein Praktikum zu finden, in Richtung cooler IT-Unternehmen. 

 Kürzlich ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Praktikum bei JetBrains und wie ich es fast geschafft hätte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454354/"><img src="https://habrastorage.org/getpro/habr/post_images/d42/5b8/da4/d425b8da4aec5f7359e39503e9f1d700.jpg" alt="Bild"><br><br>  Wie viele junge Entwickler schaue ich, wenn der Wunsch besteht, einen Job / ein Praktikum zu finden, in Richtung cooler IT-Unternehmen. <br><br>  Kürzlich habe ich versucht, in die Reihen der JetBrains einzusteigen, und unter dem Schnitt bin ich bereit, meine Erfahrungen zu teilen. <br><a name="habracut"></a><br><h3>  Warum war es „fast“ erfolgreich? </h3><br>  Sicher haben Sie sofort eine solche Frage. <br><br>  Meiner Meinung nach habe ich einen guten Lebenslauf mit einer Reihe von Erfolgen und guten Fähigkeiten, die ich in den letzten 8-9 Jahren Tag für Tag verbessert habe. <br><br>  Ich habe die Testaufgabe abgeschlossen (und es scheint mir gut zu sein), zuvor das Büro von JB in meiner Stadt besucht, mit HH und einigen Entwicklern des Unternehmens gesprochen und als Ergebnis ein Praktikum ohne Kommentare verweigert. <br><br>  Der Grund liegt höchstwahrscheinlich in der Tatsache, dass JetBrains Studenten ausschließlich für das Praktikum auswählt, und im Moment habe ich gerade den 11. abgeschlossen und die Prüfungen nacheinander bestanden. <br><br>  Nun, dies ist eine Gelegenheit für ein weiteres ganzes Jahr, sich hochzuziehen und sich für das nächste Jahr zu bewerben. <br><br><h3>  Analyse der Testaufgabe </h3><br>  Die Fristen für die Einreichung von Bewerbungen für Praktika und das Testen von Testaufgaben sind abgelaufen. Dies bedeutet, dass jeder, der sie gelöst hat, einschließlich mir, eine Analyse dieser Aufgaben veröffentlichen kann, damit sich jeder interessierte Student im nächsten Jahr mit dem ungefähren Auftragsniveau vertraut machen kann, bevor er mit JB-Praktika beginnt dem er sich stellen muss und in welchem ​​Fall um sein Wissen zu sammeln. <br><br>  Ich habe mich für ein Praktikum beim Corotin Debugger-Entwicklungsteam für Kotlin beworben. <br><br>  Die Aufgabe dieses Teams während eines Praktikums für diejenigen, die es in diesem Jahr absolviert haben, wird es sein, diesen Teil des Debuggers und seine Integration in die IDE abzuschließen. <br><br>  Die Aufgabe wurde ein wenig erwartet - einen Debugger für einen kleinen PL zu schreiben. <br><br>  Ich würde nicht sagen, dass es komplex ist, eher das Gegenteil.  Es erfordert keine gründlichen Kenntnisse der Theorie des Konstruierens von Übersetzern und eine coole Fähigkeit.  Wer sich jedoch für ein Praktikum in diesem Bereich bewirbt, sollte zumindest über diese Grundlagen verfügen und diese Aufgabe problemlos bewältigen können.  Ich war überrascht, als ich mich entschied, auf github nach Schlüsselwörtern für die Lösungen meiner "Konkurrenten" zu suchen und 1-2 mehr oder weniger funktionierende Lösungen gegen etwa 6-7 leere Repositories oder mit ein paar Codeteilen zu finden, nach denen die Leute aufgaben.  Vielleicht sah ich schlecht aus, aber die Ergebnisse gefielen mir trotzdem nicht.  Wenn dieser Beitrag von Personen gelesen wird, die diese Aufgabe aufgegeben haben, müssen Sie dies in Zukunft nicht mehr tun.  Im Extremfall hat es gereicht, ein paar Tage auf der Aufgabe zu sitzen, und ich bin sicher, dass Sie sich damit befassen würden. <br><br><div class="spoiler">  <b class="spoiler_title">Der Text der Quest selbst</b> <div class="spoiler_text">  Ziel: Implementierung einer schrittweisen Codeausführung für die triviale Programmiersprache Guu. <br><br>  Achtung: In der folgenden Beschreibung werden einige wichtige Punkte absichtlich weggelassen.  Sie liegen in der Regel in Ihrem Ermessen.  Wenn es völlig unverständlich ist, schreiben Sie an (hier ist die Mail, die ich entfernen wollte). <br><br>  Ein Guu-Programm besteht aus einer Reihe von Verfahren.  Jede Prozedur beginnt mit dem Zeilensub (Subname) und endet mit der Deklaration einer anderen Prozedur (oder dem Ende der Datei, wenn die Prozedur in der Datei die letzte ist).  Die Ausführung beginnt mit sub main. <br><br>  Der Hauptteil einer Prozedur besteht aus einer Reihe von Anweisungen, die sich jeweils in einer separaten Zeile befinden.  Am Anfang einer Zeile können unbedeutende Tabulatoren oder Leerzeichen auftreten.  Leerzeilen werden ignoriert.  Es gibt keine Kommentare zu Guu. <br><br>  Guu hat nur drei Operatoren: - set (varname) (neuer Wert) - Setzen eines neuen ganzzahligen Werts für die Variable.  - call (subname) - rufe die Prozedur auf.  Anrufe können rekursiv sein.  - print (varname) - Gibt den Wert der Variablen auf dem Bildschirm aus. <br><br>  Variablen in Guu haben einen globalen Geltungsbereich.  Das folgende Programm zeigt die Zeile a = 2 an. <br><br>  sub main <br>  setze eine 1 <br>  ruf foo an <br>  drucken a <br><br>  sub foo <br>  setze eine 2 <br><br>  Und hier ist das einfachste Programm mit unendlicher Rekursion: <br><br>  sub main <br>  Haupt anrufen <br><br>  Sie müssen einen Schritt-für-Schritt-Dolmetscher für Guu schreiben.  Beim Start sollte der Debugger in der Zeile mit der ersten Anweisung in Sub-Main anhalten und auf Befehle des Benutzers warten.  Erforderlicher Mindestsatz an Debugger-Befehlen: <br><br>  i - Schritt in, der Debugger geht in Aufruf (Subname). <br>  o - Schritt über, der Debugger geht nicht in den Aufruf. <br>  trace - Stack-Trace-Ausführung mit Zeilennummern ab Haupt ... <br>  var - Druckwerte aller deklarierten Variablen. <br><br>  Das Kommunikationsformat des Benutzers mit dem Debugger liegt im oben genannten Ermessen.  Sie können entweder eine minimalistische GDB-ähnliche Oberfläche oder eine Konsole oder eine grafische Benutzeroberfläche auswählen.  Die Namen der Debugger-Befehle können bei Bedarf geändert werden. <br><br>  Um dieses Problem zu lösen, können Sie eine beliebige Programmiersprache von TIOBE TOP 50 und einen Open-Source-Compiler / Interpreter verwenden. <br><br>  Bei der Bewertung wird die Arbeit bewertet: <br><br>  Die Gesamtleistung des Programms; <br>  Die Qualität des Quellcodes und die Verfügbarkeit von Tests; <br>  Einfach zu erweiternde Funktionalität (z. B. Unterstützung für neue Sprachanweisungen oder Debugger-Anweisungen). <br>  Eine Lösung mit Anweisungen zum Erstellen muss im Git-Repository veröffentlicht werden (z. B. auf GitHub oder BitBucket).  In der Antwort müssen Sie einen Link zum Repository angeben.  Ein Link zu einem privaten GitHub-Repository ist ebenfalls geeignet, nur Sie müssen mich hinzufügen. <br></div></div><br>  Ich schreibe in C ++, Java und Object Pascal. <br><br>  Anfangs gab es Gedanken, alles in mein MPS zu schreiben, aber ich dachte, es wäre nicht sehr bequem, nach einem JB-Mitarbeiter zu suchen, und ich reichte den Antrag 2 Tage vor Abschluss der Einreichung ein (Prüfungen trotzdem ...), und Es war schon Abend vor dem Fenster - ich beschloss, schnell alles in bekannteren Sprachen zu schreiben. <br><br>  Meiner Meinung nach eignet sich Pascal am besten zur Lösung des Problems, zumindest aufgrund der bequemsten Implementierung von Zeichenfolgen ... <br><br>  Zumindest für mich.  Außerdem ist es in TIOBE TOP 50, also habe ich mutig die IDE gestartet, nämlich Lazarus, weil  Er ist nicht kommerziell :) und machte sich daran, das Problem zu lösen. <br><br>  Trotz der Tatsache, dass sie JB bis zu 7 Tage Zeit geben, habe ich ungefähr eine Stunde gebraucht, um das Projekt abzuschließen, und es stellte sich heraus, dass das Projekt ungefähr 500 Codezeilen umfasste. <br><br><h3>  Wo soll ich anfangen? </h3><br>  Zunächst müssen Sie sich vorstellen, wie das Debuggen von Code letztendlich funktioniert. <br><br>  Wir müssen die schrittweise Codeausführung implementieren - das heißt, jede Anweisung sollte in Form einer Struktur / Klasse dargestellt werden, und im Allgemeinen sollten die Anweisungen wie eine Liste dieser Klassen aussehen oder sich wie in meiner Implementierung aufeinander beziehen und eine Sequenz bilden (ich werde aufschreiben, warum ich es später getan habe). <br><br>  Um diese Sequenz zu erhalten, muss unser Debugger den Code in der vorgeschlagenen Sprache verarbeiten. Dies bedeutet, dass wir auch einen kleinen Parser sowie eine syntaktische und semantische Analyse des Codes implementieren müssen. <br><br>  Beginnen wir mit der Implementierung des Parsers.  Weil  Da die Guu-Sprache aus einer Reihe von Token besteht, die durch ein Leerzeichen getrennt sind, ist es logisch, zuerst einen kleinen und einfachen Tokenizer zu schreiben: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; tokenNum: word)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := Trim(s); s := StringReplace(s, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, [rfReplaceAll]); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> tokenNum &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, <span class="hljs-number"><span class="hljs-number">1</span></span>, p) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; dec(tokenNum); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, p, Length(s)); Result := s; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Als nächstes deklarieren Sie die Aufzählung der Token: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuToken = (opSub, opSet, opCall, opPrint, opUnknown); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GuuToken: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[opSub..opPrint] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ( <span class="hljs-string"><span class="hljs-string">'sub'</span></span>, <span class="hljs-string"><span class="hljs-string">'set'</span></span>, <span class="hljs-string"><span class="hljs-string">'call'</span></span>, <span class="hljs-string"><span class="hljs-string">'print'</span></span> );</code> </pre><br>  Und die Anweisungsklasse selbst, in die wir die Codezeilen analysieren werden: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpType : TGuuToken; OpArgs : TStringList; OpLine : Cardinal; OpUnChangedLine: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; NextOp : TGuuOp; OpReg : Pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In OpType wird die Anweisung in OpArgs gespeichert - der Rest der Konstruktion. <br>  OpLine, OpUnChangedLine - Informationen für den Debugger. <br><br>  NextOp ist ein Zeiger auf die nächste Anweisung.  Wenn es gleich nil ist (null in Pascal), gibt es keine weiteren Anweisungen und Sie müssen den Code vervollständigen oder über den Rückrufstapel zurückkehren. <br><br>  OpReg ist ein kleines Zeigerregister, das später für eine kleine Optimierung der Codeausführung verwendet wird. <br><br>  Nachdem die Klassendeklaration geschrieben wurde, entschied ich, dass die kompakteste und schönste Lösung darin bestehen würde, den Parser und ein wenig Analyse in seinem Konstruktor hinzuzufügen, was ich als nächstes tat: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * That method parse code line. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; w: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; OpArgs := TStringList.Create; OpLine := LineNum; OpUnChangedLine := Line; NextOp := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; OpReg := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; s := GetToken(Line, <span class="hljs-number"><span class="hljs-number">1</span></span>); OpType := TGuuToken(AnsiIndexStr(s, GuuToken)); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub : <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// sub &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "sub" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opSet : begin // set &lt;var&gt; &lt;value&gt; OpArgs.Add(GetToken(Line, 2)); OpArgs.Add(GetToken(Line, 3)); w := 1; while w &lt; Length(OpArgs[1]) + 1 do begin if not (OpArgs[1][w] in ['0'..'9']) then begin writeln('[Syntax error]: Invalid variable assigment "', Line, '" at line ', OpLine, '.'); halt; end; inc(w); end; if (Length(OpArgs[0]) = 0) or (Length(OpArgs[1]) = 0) or (Length(GetToken(Line, 4)) &gt; 0) then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end end; opCall : begin // call &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "call" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opPrint: begin // print &lt;var&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "print" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; else begin writeln('[Syntax error]: Invalid token "', s, '" at line ', OpLine, '.'); halt; end; end; end; destructor TGuuOp.Destroy; begin FreeAndNil(OpArgs); inherited; end;</span></span></code> </pre><br>  Hier überprüfen wir im Wesentlichen den Beginn der Konstruktion (d. H. Das erste Wort) und betrachten dann die verbleibenden Token und ihre Anzahl.  Wenn etwas mit dem Code eindeutig nicht stimmt, wird ein Fehler angezeigt. <br><br>  Im Hauptcode lesen wir einfach den Code in der TStringList aus der Datei, rufen die TGuuOp-Konstruktoren zeilenweise auf und speichern die Zeiger auf die Klasseninstanzen in GuuOps: TList. <br><br>  Ankündigungen: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LabelNames: TStringList; GuuOps, GuuVars: TList; SubMain: TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>;</code> </pre><br>  Zusammen mit der Code-Analyse wäre es schön, noch ein paar Aktionen auszuführen: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Parsing code lines and define variables and labels. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; GV: TGuuVar; c: cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Trim(Line) &lt;&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp.Create(LineNum, Line); GuuOps.Add(Op); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Op.OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// define variable and/or optimisation var calling GV := nil; c := 0; while c &lt; GuuVars.Count do begin if TGuuVar(GuuVars[c]).gvName = Op.OpArgs[0] then begin GV := TGuuVar(GuuVars[c]); break; end; inc(c); end; if GV = nil then begin GV := TGuuVar.Create(Op.OpArgs[0]); GuuVars.Add(GV); end; Op.OpReg := GV; end; opSub: begin // Check for label dublicade declaration if Op.OpArgs[0] = 'main' then SubMain := Op; if LabelNames.IndexOf(Op.OpArgs[0]) &lt;&gt; -1 then begin writeln('[Error]: Dublicate sub "', Op.OpArgs[0], '" declaration at line ', Op.OpLine, '.'); halt; end else LabelNames.Add(Op.OpArgs[0]); end; end; end; end;</span></span></code> </pre><br>  Zu diesem Zeitpunkt können Sie die Einstiegspunkte zum Zeitpunkt der Neudefinition überprüfen und an OpReg denken. Ich habe damit einen Zeiger auf eine Guu-Variable gespeichert. <br><br>  Apropos Variablen, ich habe diesen kleinen Code in eine separate Einheit gebracht: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uVars; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuVar = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> gvName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; gvVal: variant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuVar</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; gvName := VarName; gvVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  Jetzt haben wir Code analysiert, der in der Syntax korrekt zu sein scheint.  Es bleibt zu analysieren, und Sie können beginnen, das Wichtigste auszuführen - das Debuggen. <br><br>  Als nächstes müssen Sie eine kleine semantische Analyse implementieren und gleichzeitig alles für die Ausführung und das Debuggen von Code vorbereiten: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSemantic</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Semantic analyse and calls optimisation. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c, x: cardinal; op: TGuuOp; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GuuOps.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpType &lt;&gt; opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Operation outside sub at line '</span></span>, TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; c := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> c &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TGuuOp(GuuOps[c]).OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub:; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; op := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpType = opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> op := TGuuOp(GuuOps[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> TGuuOp(GuuOps[c]).OpReg := op <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Calling to not exist sub "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuVars.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuVar(GuuVars[x]).gvName = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c]).OpReg := TGuuVar(GuuVars[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[c]).OpReg = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Variable "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" for print doesn''t exist at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(c); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Schreiben Sie in TGuuOp.NextOp jedes Tokens einen Zeiger auf das nächste Token. <br>  Für den Anruf-Opcode machen wir es schwierig und einfach - in NextOp schreiben wir einen Zeiger auf den aufgerufenen Einstiegspunkt. <br><br>  Wir überprüfen die Ausgabevariablen auch über die print-Anweisung ... <br><br>  Vielleicht wurden sie nicht vor dem Abschluss angekündigt? <br><br>  Jetzt müssen Sie die Codeausführung implementieren.  Kehren Sie zur TGuuOp-Klasse zurück und implementieren Sie die Step-Methode: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-comment"><span class="hljs-comment">(* * That method execute instruction. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; CBSize: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Trace.Add(<span class="hljs-string"><span class="hljs-string">'-&gt; Sub "'</span></span> + OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'"'</span></span>); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StepInto <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NextOp &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallBacks.Add(NextOp); Result := TGuuOp(OpReg); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(OpReg); CBSize := CallBacks.Count; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((Op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (CallBacks.Count &gt; CBSize)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Trace.Count &lt; STACK_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Op = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(CallBacks[CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]); CallBacks.Delete(CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Trace.Delete(Trace.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Op := Op.Step(StepInto, CallBacks, Trace); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(TGuuVar(OpReg).gvName, <span class="hljs-string"><span class="hljs-string">' = '</span></span>, TGuuVar(OpReg).gvVal); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuVar(OpReg).gvVal := OpArgs[<span class="hljs-number"><span class="hljs-number">1</span></span>]; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Um eine Zugriffsverletzung im Falle einer Schleife zu vermeiden, ist es besser, den Stapel zu begrenzen, was ich getan habe. <br>  Die oben deklarierte Konstante STACK_SIZE = 2048 ist nur dafür verantwortlich. <br><br>  Jetzt ist es endlich Zeit, den Hauptcode unseres Debuggers zu schreiben: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> code: TStringList; c: Cardinal; cmd: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; CallBacks: TList; Trace: TStringList; DebugMode: boolean = true; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ParamCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// Initialisation if not FileExists(ParamStr(1)) then begin writeln('[Error]: Can''t open file "', ParamStr(1), '".'); halt; end; if ParamCount &gt; 1 then if LowerCase(ParamStr(2)) = '/run' then DebugMode := false; code := TStringList.Create; code.LoadFromFile(ParamStr(1)); GuuOps := TList.Create; GuuVars := TList.Create; // Parsing and preparing LabelNames := TStringList.Create; c := 0; while c &lt; code.Count do begin ParseNext(c + 1, Trim(code[c])); inc(c); end; FreeAndNil(LabelNames); CheckSemantic; if SubMain = nil then begin writeln('[Error]: Sub "main" doesn''t exist!'); halt; end; // Start code execution CurrentOp := SubMain; CallBacks := TList.Create; Trace := TStringList.Create; if DebugMode then begin //Out code and features ClrScr; writeln('Code for debugging:'); writeln('.....'); c := 0; while c &lt; code.Count do begin writeln(FillSpaces(IntToStr(c + 1), 4), '| ', code[c]); inc(c); end; writeln('"""""'); FreeAndNil(code); writeln(sLineBreak, 'Features:', sLineBreak, '* i - step into.', sLineBreak, '* o - step over.', sLineBreak, '* trace - print stack trace.', sLineBreak, '* var - print variables list.', sLineBreak, '* x - exit.', sLineBreak); // Execution loop while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin write('Line ', CurrentOp.OpLine, ' ~&gt; '); readln(cmd); // Execute commands if cmd = 'i' then CurrentOp := CurrentOp.Step(true, CallBacks, Trace) else if cmd = 'o' then CurrentOp := CurrentOp.Step(false, CallBacks, Trace) else if cmd = 'trace' then begin writeln('| Trace:'); c := 0; while c &lt; Trace.Count do begin writeln('| ', Trace[c]); inc(c); end; writeln('| -&gt; Line ', CurrentOp.OpLine, ': "', CurrentOp.OpUnChangedLine, '".') end else if cmd = 'var' then begin writeln('| Variables list:'); c := 0; while c &lt; GuuVars.Count do begin writeln('| ', TGuuVar(GuuVars[c]).gvName, ' = ', TGuuVar(GuuVars[c]).gvVal); inc(c); end; end else if cmd = 'x' then halt; // Check for method end &amp; make callback if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end else begin // Only run mode (/run) FreeAndNil(code); while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin CurrentOp := CurrentOp.Step(false, CallBacks, Trace); if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end; if Trace.Count &gt;= STACK_SIZE then writeln('[Runtime error]: Stack overflow!'); FreeAndNil(CallBacks); FreeAndNil(Trace); end else writeln( 'Guu debugger v1.0.', sLineBreak, 'Author: Pavel Shiryaev (@RoPi0n).', sLineBreak, 'Run: svmc guu_debugger.vmc &lt;guu source file&gt; [arg]', sLineBreak, 'Args:', sLineBreak, ' /run - Run Guu code.' ); end.</span></span></code> </pre><br>  Je nach Auftragsbedingung kann die Schnittstelle nach Ihren Wünschen implementiert werden. <br><br>  Es wäre möglich, eine vollwertige Benutzeroberfläche zu implementieren und SynEdit mit dem Projekt zu verbinden, aber meiner Meinung nach ist es eine leere Arbeit, die die Fähigkeiten nicht widerspiegelt und außerdem nicht bezahlt wird :) <br><br>  Also habe ich mich auf eine kleine Konsolen-Benutzeroberfläche beschränkt. <br><br>  Der obige Code ist nicht kompliziert, daher können Sie ihn kommentarlos hinterlassen.  Darin nehmen wir fertige TGuuOps und nennen sie Step. <br><br>  Screenshots des gelösten Problems: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33e/ad0/efa/33ead0efa3a07d77d1a6c07010847035.jpg" alt="Bild"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e1/7eb/41e/3e17eb41e99abece612f09b146464f67.jpg" alt="Bild"><br><br>  Ausgabe von Fehlerinformationen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/1c5/ea4/6591c5ea44e67f5068bd7fb0e9c2341e.jpg" alt="Bild"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a0/3f0/733/2a03f07336c5af1333f259d43e4a1396.jpg" alt="Bild"><br><br>  Link zum Repository meiner Lösung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klicken Sie auf</a> <br><br><h3>  Zusammenfassung </h3><br>  Es gibt keine besonderen Ergebnisse.  Ich muss den größten Teil des Sommers einem geschäftigen Urlaub widmen und nach einer Universität suchen (na ja, falls ich die Prüfung natürlich gut bestehe), anstatt zwei Monate im JetBrains-Team zu arbeiten und zu trainieren. <br><br>  Vielleicht erscheint nächstes Jahr ein neuer Beitrag bei Habré, der bereits den Praktikumsprozess bei JB oder in einem anderen für mich interessanten Unternehmen beschreibt :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454354/">https://habr.com/ru/post/de454354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454336/index.html">Kunde: - Wie viel kostet eine Kopie von Facebook?</a></li>
<li><a href="../de454340/index.html">% tutnazvanievu% ist die erste Universität der Welt, an der Jetpacks offiziell entwickelt werden</a></li>
<li><a href="../de454346/index.html">Effizienzalgorithmen: Nobelic 2019 Surveillance Camera Review</a></li>
<li><a href="../de454348/index.html">Verwalten des Status mit React Hooks - Ohne Redux- und Kontext-API</a></li>
<li><a href="../de454352/index.html">Mathematische Unsicherheiten in Python</a></li>
<li><a href="../de454356/index.html">Habr Weekly # 3 / Runet gegen TV, ARM gegen Intel, Vereinheitlichung von Staatsdaten, ohne Smartphone im Jahr 2019, sowjetische Zukunftsträume</a></li>
<li><a href="../de454366/index.html">Sieg bei PHDays 9. Wir teilen Life Hacks in drei Teilen. Teil 2</a></li>
<li><a href="../de454368/index.html">Entwicklerwettbewerb für TeamCity-Plugins</a></li>
<li><a href="../de454372/index.html">Wöchentliche Nachrichten: Huawei hat immer noch Probleme, "Quantentelefon" in der Russischen Föderation, ARM hat neue Prozessoren</a></li>
<li><a href="../de454374/index.html">Der Fotopolymer-3D-Drucker eines Heimvideoprojektors erstellt Objekte ohne Ebenen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>