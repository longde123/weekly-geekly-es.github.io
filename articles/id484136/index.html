<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✨ 👘 👩🏿‍🔧 Python (+ numba) lebih cepat dari C - benarkah ?! Bagian 1. Teori 🤛 🔖 🕵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk waktu yang lama saya akan menulis artikel tentang numba dan membandingkan kecepatannya dengan si. Artikel Haskell “ Lebih cepat dari C ++; lebih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python (+ numba) lebih cepat dari C - benarkah ?! Bagian 1. Teori</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484136/"><p>  Untuk waktu yang lama saya akan menulis artikel tentang numba dan membandingkan kecepatannya dengan si.  Artikel Haskell “ <a href="https://habr.com/ru/post/483864/">Lebih cepat dari C ++;</a>  <a href="https://habr.com/ru/post/483864/">lebih lambat dari PHP</a> ”didorong untuk bertindak.  Dalam komentar pada artikel ini, mereka menyebutkan perpustakaan numba dan secara ajaib dapat memperkirakan kecepatan eksekusi kode dalam python ke kecepatan dalam s.  Dalam artikel ini, setelah ulasan singkat tentang numba (bagian 1), analisis situasi ini sedikit lebih rinci ( <a href="https://habr.com/ru/post/484142/">bagian 2</a> ). </p><br><p><img src="https://habrastorage.org/webt/a8/i_/ej/a8i_ejoqo5krkvtbdxo7fahp3p8.jpeg"></p><a name="habracut"></a><br><p> Kerugian utama dari python dianggap kecepatannya.  Python overclocking dengan berbagai keberhasilan dimulai hampir dari hari-hari pertama keberadaannya: <a href="https://ru.wikipedia.org/wiki/Shedskin" rel="nofollow">kulit domba</a> , <a href="https://ru.wikipedia.org/wiki/Shedskin" rel="nofollow">psyco</a> , <a href="https://ru.wikipedia.org/wiki/Unladen_Swallow" rel="nofollow">dangkal</a> <a href="https://ru.wikipedia.org/wiki/Nuitka" rel="nofollow">unladen</a> , <a href="https://github.com/iskandr/parakeet" rel="nofollow">parkit</a> , <a href="https://ru.wikipedia.org/wiki/Nuitka" rel="nofollow">theano</a> , <a href="https://pythran.readthedocs.io/en/latest/" rel="nofollow">nuitka</a> , <a href="https://ru.wikipedia.org/wiki/Cython" rel="nofollow">pythran</a> , <a href="https://ru.wikipedia.org/wiki/Cython" rel="nofollow">cython</a> , <a href="https://ru.wikipedia.org/wiki/PyPy" rel="nofollow">pypy</a> , <a href="https://en.wikipedia.org/wiki/Numba" rel="nofollow">numba</a> . <br><img src="https://habrastorage.org/webt/yy/4u/gr/yy4ugrto-i7axd0v6ds5cj58lmk.png"><br>  Sampai saat ini, tiga terakhir adalah yang paling laris.  <code>Cython</code> (jangan dikacaukan dengan cpython) - sangat berbeda secara semantik dari python biasa.  Bahkan, ini adalah bahasa yang terpisah - hibrida dari C dan python.  Adapun <code>pypy</code> (implementasi alternatif dari penerjemah python menggunakan kompilasi jit) dan <code>numba</code> (perpustakaan untuk kompilasi kode dalam llvm), mereka pergi dengan cara yang berbeda.  <code>pypy</code> awalnya menyatakan dukungan untuk semua konstruksi python.  Di numba, mereka melanjutkan dari fakta bahwa itu paling sering memerlukan cpu bound - perhitungan matematis, masing-masing, mereka mengidentifikasi bagian dari bahasa yang terkait dengan perhitungan dan mulai meng-overclock, secara bertahap meningkatkan "cakupan" (misalnya, hingga saat ini tidak ada dukungan garis) , sekarang dia telah muncul).  Dengan demikian, tidak seluruh program di-overclock di <code>numba</code> , tetapi <em>fungsi-fungsi terpisah</em> , ini memungkinkan Anda untuk menggabungkan kecepatan tinggi dan kompatibilitas dengan perpustakaan yang <code>numba</code> tidak (belum) mendukung.  Numpy didukung (dengan batasan kecil) di <code>pypy</code> dan <code>numba</code> . </p><br><p><img src="https://habrastorage.org/webt/c0/7l/_y/c07l_ygigxdy7wsfwnyn_nfm2v4.png" width="30%" align="right">  Kenalan saya dengan Numba dimulai pada 2015 dengan pertanyaan tentang stackoverflow tentang kecepatan multiplikasi matriks dalam python: <a href="https://stackoverflow.com/questions/27809511/efficient-outer-product-in-python" rel="nofollow">Produk luar yang efisien dalam python</a> </p><br><p>  Sejak itu, banyak peristiwa telah terjadi di masing-masing perpustakaan, tetapi gambar sehubungan dengan <code>numba</code> / <code>cython</code> / <code>pypy</code> tidak berubah <code>numba</code> : <code>numba</code> menyalip <code>cython</code> melalui penggunaan instruksi prosesor asli ( <code>cython</code> tidak bisa jit), dan <code>pypy</code> - karena pelaksanaan byvecode byte yang lebih efisien . </p><br><p>  Numba sangat berguna bagi saya di tempat kerja (memproses gambar hiperspektral) dan dalam pengajaran (integrasi numerik, menyelesaikan persamaan diferensial). </p><br><h4 id="kak-ustanovit">  cara mengatur </h4><br><p>  Beberapa tahun yang lalu ada masalah dengan instalasi, sekarang semuanya diselesaikan: itu menginstal sama baiknya baik melalui <code>pip install numba</code> dan melalui <code>conda install numba</code> .  llvm diperketat dan diinstal secara otomatis. </p><br><h4 id="kak-uskoryat">  cara mempercepat </h4><br><p>  Untuk mempercepat suatu fungsi, Anda harus memasukkan dekorator njit sebelum mendefinisikannya: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> njit @njit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> s = <span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): s += sqrt(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s</code> </pre> <br><p>  Akselerasi <strong>40</strong> kali. </p><br><p>  Akar diperlukan, karena jika tidak, numba akan mengenali jumlah dari perkembangan aritmatika (!) Dan menghitungnya dalam waktu yang konstan. </p><br><h4 id="jit-vs-njit">  jit vs njit </h4><br><p>  Sebelumnya, hanya mode <code>@jit</code> (bukan <code>@njit</code> ) yang relevan.  Intinya adalah bahwa dalam mode ini Anda dapat menggunakan operasi yang tidak didukung oleh numba: numba dengan kecepatan tinggi mencapai operasi seperti pertama, kemudian melambat, dan sampai akhir pelaksanaan fungsi berlanjut pada kecepatan Python biasa, bahkan jika tidak ada lagi "terlarang" yang ditemui dalam fungsi ( yang disebut mode objek), yang jelas tidak rasional.  Sekarang <code>@jit</code> bertahap meninggalkan <code>@jit</code> , selalu disarankan untuk menggunakan @njit (atau dalam bentuk penuh <code>@jit(nopython=True)</code> ): dalam mode ini, numba bersumpah dengan pengecualian di tempat-tempat seperti itu - lebih baik menulis ulang mereka agar tidak kehilangan kecepatan. </p><br><h4>  apa yang bisa mempercepat </h4><br><p>  Dalam fungsi yang di-overclock, hanya sebagian dari fungsi python dan numba yang dapat digunakan.  Semua operator, fungsi dan kelas dibagi menjadi dua bagian sehubungan dengan numba: yang numba "pahami" dan yang "tidak pahami". </p><br><p>  Ada dua daftar seperti itu dalam dokumentasi numba (dengan contoh): </p><br><ul><li>  subset dari fungsi <a href="https://numba.pydata.org/numba-doc/dev/reference/pysupported.html" rel="nofollow">python yang</a> familier untuk numbe dan </li><li>  bagian dari fungsi <a href="https://numba.pydata.org/numba-doc/dev/reference/numpysupported.html" rel="nofollow">numpy yang</a> akrab dengan numbe. </li></ul><br><p>  Dari yang patut diperhatikan dalam daftar ini: </p><br><ul><li>  numba "memahami" daftar Python dengan penambahan cepat (diamortisasi O (1)) sampai akhir yang numpy "tidak mengerti" (meskipun hanya yang homogen dari unsur-unsur dari jenis yang sama), </li><li>  array numpy yang tidak di python dasar.  Mengerti juga </li><li>  tuple: mereka bisa, seperti python biasa, mengandung elemen dari tipe yang berbeda. </li><li>  kamus: numba memiliki implementasi sendiri dari kamus yang diketik.  Semua kunci harus dari jenis yang sama, persis seperti nilainya.  Dict python tidak dapat dilewatkan ke numba, tetapi numba <code>numba.typed.Dict</code> dapat dibuat dengan python dan ditransfer ke / dari numba (sementara di python bekerja sedikit lebih lambat daripada python). </li><li>  namun baru-baru ini str dan byte, hanya karena parameter input tidak dapat dibuat (belum?). </li></ul><br><p>  Dia sama sekali tidak mengerti perpustakaan lain (khususnya, scipy dan panda). </p><br><p>  Tetapi bahkan bagian bahasa yang dia mengerti sudah cukup untuk meng-overclock sebagian besar kode untuk aplikasi ilmiah yang menjadi fokus utama numba. </p><br><h4>  penting! </h4><br><p>  Dari fungsi overclock, hanya fungsi overclock, bukan overclock, yang dapat dipanggil. <br>  (meskipun fungsi overclock dapat dipanggil dari overclocked dan tidak overclocked). </p><br><h4>  global </h4><br><p>  Dalam fungsi yang di-overclock, variabel global menjadi konstanta: nilainya tetap pada saat fungsi dikompilasi ( <a href="https://python-nsu.bitbucket.io/numba/globals.html" rel="nofollow">contoh</a> ).  =&gt; Jangan gunakan variabel global dalam fungsi overclock (kecuali untuk konstanta). </p><br><h4>  tanda tangan </h4><br><p>  Dalam nomor fungsi masing-masing, satu atau beberapa jenis argumen input dan output dipetakan, yaitu  tanda tangan.  Ketika fungsi pertama kali dipanggil, tanda tangan dihasilkan dan kode fungsi biner yang sesuai dikompilasi secara otomatis.  Ketika diluncurkan dengan jenis argumen lain, tanda tangan baru dan binari baru akan dibuat (yang lama akan dipertahankan).  Dengan demikian, "keluar ke mode" dalam hal kecepatan eksekusi untuk setiap tanda tangan terjadi, mulai dari yang kedua dengan jenis argumen ini.  Begitu juga </p><br><ul><li>  “Warm up the cache” dengan meluncurkan dengan array input ukuran kecil, atau </li><li>  tentukan argumen <code>@jit(cache=True)</code> untuk menyimpan kode yang dikompilasi ke disk dengan pemuatan otomatisnya selama peluncuran program berikutnya (meskipun dalam praktiknya hari ini peluncuran pertama masih sedikit lebih lambat daripada yang berikutnya, tetapi lebih cepat daripada tanpa <code>cache=True</code> ) . </li></ul><br><p>  Ada cara ketiga.  Tanda tangan dapat diatur secara manual: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> int16, int32 @njit(int32(int16, int16)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y &gt;&gt;&gt; f.signatures [(int16, int16)]</code> </pre> <br><p>  Ketika Anda menjalankan fungsi dengan tanda tangan yang ditentukan dalam dekorator, jalankan pertama akan cepat: kompilasi akan terjadi pada saat python melihat definisi fungsi, dan bukan pada awal pertama.  Mungkin ada beberapa tanda tangan, urutan urutannya penting. </p><br><p>  Peringatan: metode terakhir ini tidak aman di masa mendatang.  Para penulis numba memperingatkan bahwa sintaks untuk menentukan jenis dapat berubah di masa depan, <code>@jit</code> / <code>@njit</code> tanpa tanda tangan adalah opsi yang lebih aman dalam hal ini. </p><br><p>  tanda tangan mulai menunjukkan tanda tangan hanya ketika python mengetahui tentang mereka, yaitu, setelah panggilan fungsi pertama, atau jika mereka diatur secara manual. </p><br><p>  Selain tanda tangan <code>f.signatures</code> tanda tangan dapat dilihat melalui <code>f.inspect_types()</code> - selain jenis parameter input, fungsi ini akan menunjukkan jenis parameter output serta jenis semua variabel lokal. </p><br><p>  Selain jenis parameter input dan output, dimungkinkan untuk menentukan jenis variabel lokal secara manual: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> int16, int32 @njit(int32(int16, int16), locals={<span class="hljs-string"><span class="hljs-string">'z'</span></span>: int32}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> z = y + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + z</code> </pre> <br><h4 id="int">  int </h4><br><p>  Di numba, bilangan bulat tidak memiliki aritmatika panjang seperti pada python "sederhana", tetapi ada tipe standar dari berbagai lebar dari <code>int8</code> ke <code>int64</code> ( <a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html" rel="nofollow">ketik tabel</a> dalam dokumentasi).  Ada juga tipe <code>int_</code> (dan juga <code>float_</code> ), yang Anda gunakan memberi numba kesempatan untuk memilih lebar bidang yang optimal (dari sudut pandangnya). </p><br><h4 id="klassy">  kelas </h4><br><p>  Pada umumnya ada dukungan untuk kelas (@ jitclass), tetapi sejauh ini masih eksperimental, jadi lebih baik untuk menghindari menggunakannya untuk saat ini (saat ini, dalam pengalaman saya, jauh lebih lambat dengan mereka daripada tanpa mereka). </p><br><h4 id="custom-dtypes">  dtypes khusus </h4><br><p>  Numba mendukung alternatif tertentu untuk kelas dari numpy - structured array, atau, dengan kata lain, dtype khusus.  Mereka bekerja pada kecepatan yang sama dengan array numpy biasa, mereka sedikit lebih nyaman untuk diindeks (misalnya, <code>a['y2']</code> lebih mudah dibaca daripada <code>a[3]</code> ).  Menariknya, di numba, tidak seperti numpy, <code>a.y2</code> lebih ringkas diizinkan bersama dengan sintaksis yang biasa <code>a['y2']</code> .  Tetapi secara umum, dukungan mereka pada numba menyisakan banyak yang harus diinginkan, dan beberapa operasi, bahkan jelas pada numpy, dengan mereka di numba dicatat cukup non-sepele. </p><br><h4 id="gpu">  GPU </h4><br><p>  Ia mampu mengeksekusi kode overclock pada GPU, dan berbeda dengan yang sama, misalnya, pycuda atau pytorch, tidak hanya pada nvidia, tetapi juga pada kartu amd'shnyh.  Dengan ini, sejauh ini saya hanya memiliki sedikit pengetahuan.  Berikut ini adalah artikel tentang Habre 2016 <a href="https://habr.com/ru/post/317328/">Perbandingan kinerja perhitungan GPU dalam Python dan C.</a>  Di sana, kecepatan yang sebanding dengan C diperoleh. </p><br><h4 id="ahead-of-time-kompilyaciya">  kompilasi sebelumnya </h4><br><p>  Ada mode kompilasi ( <a href="https://numba.pydata.org/numba-doc/dev/user/pycc.html" rel="nofollow">dokumentasi</a> ) normal (yaitu, bukan jit) di numba, tetapi mode ini bukan yang utama, saya tidak memahaminya. </p><br><h4 id="avtomaticheskoe-rasparallelivanie">  paralelisasi otomatis </h4><br><p>  Beberapa tugas (misalnya, mengalikan matriks dengan angka) diparalelkan secara alami.  Tetapi ada tugas yang implementasinya tidak bisa diparalelkan.  Dengan dekorator <code>@njit(parallel=True)</code> numba menganalisis kode fungsi yang di-overclock, menemukan bagian-bagian tersebut, yang masing-masing tidak dapat diparalelkan dengan sendirinya, dan menjalankannya secara bersamaan pada inti CPU yang berbeda ( <a href="https://numba.pydata.org/numba-doc/dev/user/parallel.html" rel="nofollow">dokumentasi</a> ).  Sebelumnya, Anda hanya bisa memparalelkan fungsi secara manual menggunakan <code>@vectorize</code> ( <a href="https://numba.pydata.org/numba-doc/dev/reference/jit-compilation.html" rel="nofollow">dokumentasi</a> ), yang memerlukan perubahan kode. </p><br><p>  Dalam praktiknya, tampilannya seperti ini: tambah <code>parallel=True</code> , ukur kecepatannya, jika kita beruntung dan ternyata lebih cepat - kita tinggalkan, lebih lambat - kita lepaskan.  (** Pembaruan Seperti tercantum dalam <a href="https://habr.com/ru/post/484142/">komentar</a> ke bagian kedua artikel, bendera ini memiliki banyak bug terbuka) </p><br><h4 id="osvobozhdenie-gil">  Rilis GIL </h4><br><p>  Fungsi yang didekorasi dengan <code>@jit(nogil=True)</code> dan berjalan di utas yang berbeda dapat dijalankan secara paralel.  Untuk menghindari kondisi balapan, Anda harus menggunakan sinkronisasi utas. </p><br><h4 id="dokumentaciya">  dokumentasi </h4><br><p>  Numbe masih kekurangan dokumentasi yang masuk akal.  Memang, tapi tidak semuanya ada di dalam dirinya. </p><br><h4 id="optimizaciya">  optimasi </h4><br><p>  Ada beberapa ketidakpastian ketika mengoptimalkan kode secara manual: kode unpythonic sering berjalan lebih cepat daripada pythonic. </p><br><p>  Bagi mereka yang tertarik dengan topik ini, saya dapat merekomendasikan <a href="https://www.youtube.com/watch%3Fv%3D1AwG0T4gaO0" rel="nofollow">video</a> kelas master numba dari konferensi 2017 yang cerdik (ada <a href="https://github.com/gforsyth/numba_tutorial_scipy2017" rel="nofollow">kode sumber</a> di github).  Ini benar-benar panjang dan sebagian ketinggalan jaman (misalnya, garis sudah didukung), tetapi membantu untuk mendapatkan ide umum: ada, khususnya, tentang pythonic / unpythonic, <a href="https://habr.com/ru/users/jit/" class="user_link">jit</a> (parallel = True), dll. </p><br><p>  Pada bagian <a href="https://habr.com/ru/post/484142/">kedua</a> , kami akan mempertimbangkan penggunaan numba menggunakan kode dari artikel yang disebutkan di awal artikel. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484136/">https://habr.com/ru/post/id484136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484114/index.html">Pilihan 143 terjemahan esai Paul Graham (dari 184)</a></li>
<li><a href="../id484118/index.html">32 Januari</a></li>
<li><a href="../id484120/index.html">Keterampilan yang paling dicari dalam profesi insinyur data</a></li>
<li><a href="../id484124/index.html">Nikolai Prokhorov: "Di Finlandia ada departemen besar Vneshtorg, yang memasok mobil kami ke luar negeri"</a></li>
<li><a href="../id484130/index.html">Layanan microser dengan Spring Boot. Bagian 1. Memulai</a></li>
<li><a href="../id484142/index.html">Python (+ numba) lebih cepat dari C - benarkah ?! Bagian 2. Latihan</a></li>
<li><a href="../id484146/index.html">Tipuan di Internet tidak akan hilang - apa yang harus kita lakukan?</a></li>
<li><a href="../id484148/index.html">SVM Penjelasan dari awal dan implementasi dalam python. Analisis terperinci tentang metode vektor dukungan</a></li>
<li><a href="../id484150/index.html">5 alat baru untuk membuat konten yang menyenangkan</a></li>
<li><a href="../id484152/index.html">Kontroler PAC Kecepatan Tinggi WISE-5580</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>