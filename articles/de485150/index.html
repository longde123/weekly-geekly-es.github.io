<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏻 🧑🏼 🗯️ Physik für einen mobilen PvP-Shooter oder wie wir ein zweidimensionales Spiel in ein dreidimensionales verwandeln 👨🏿‍💻 🌚 🙇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel sprach mein Kollege darüber, wie wir in unserem mobilen Multiplayer-Shooter eine zweidimensionale Physik-Engine verwendet ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Physik für einen mobilen PvP-Shooter oder wie wir ein zweidimensionales Spiel in ein dreidimensionales verwandeln</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/485150/"><img src="https://habrastorage.org/webt/fo/if/az/foifazxdmxh_smqsswnkxhn0ww4.png"><br><br>  In einem <a href="https://habr.com/ru/company/pixonic/blog/481880/">früheren Artikel</a> sprach mein Kollege darüber, wie wir in unserem mobilen Multiplayer-Shooter eine zweidimensionale Physik-Engine verwendet haben.  Und jetzt möchte ich Ihnen mitteilen, wie wir alles, was wir zuvor getan haben, von vorne begonnen haben - mit anderen Worten, wie wir unser Spiel von der 2D-Welt in die 3D-Welt übertragen haben. <br><a name="habracut"></a><br>  Alles begann damit, dass einmal ein Produzent und ein führender Spieledesigner in die Programmierabteilung kamen und uns vor eine Herausforderung stellten: Ein mobiler PvP-Top-Down-Shooter mit Dreharbeiten auf engstem Raum musste in einen Third-Person-Shooter mit Dreharbeiten auf freiem Feld umgewandelt werden.  In diesem Fall ist es wünschenswert, dass die Karte nicht so aussieht: <br><br><img src="https://habrastorage.org/webt/he/j3/2p/hej32pvogui5sukjz842wjpyqry.png"><br><br>  Und so: <br><br><img src="https://habrastorage.org/webt/n8/25/xw/n825xwkx_jsgqgoemkcor-r4ti0.jpeg"><br><br>  Die technischen Anforderungen waren wie folgt: <br><br><ul><li>  Kartengröße - 100 × 100 Meter; </li><li>  Höhenunterschied - 40 Meter; </li><li>  Unterstützung für Tunnel, Brücken; </li><li>  Schießen auf Ziele in verschiedenen Höhen; </li><li>  Kollisionen mit statischer Geometrie (wir haben keine Kollisionen mit anderen Charakteren im Spiel); </li><li>  Physik des freien Falls; </li><li>  Granatenwurf Physik. </li></ul><br>  Mit Blick auf die Zukunft kann ich sagen, dass unser Spiel nicht wie der letzte Screenshot aussah: Es stellte sich heraus, dass es eine Kreuzung zwischen der ersten und der zweiten Option war. <br><br><h2>  Option eins: geschichtete Struktur </h2><br>  Die erste Idee bestand darin, die Physik-Engine nicht zu ändern, sondern einfach mehrere Ebenen mit "Anzahl der Stockwerke" hinzuzufügen.  Es stellte sich so etwas wie Grundrisse im Gebäude heraus: <br><br><img src="https://habrastorage.org/webt/lz/dy/oq/lzdyoquthw76ajisyvgqcn7zc_i.jpeg"><br><br>  Mit diesem Ansatz mussten wir weder die Client- noch die Serveranwendungen radikal wiederholen, und im Allgemeinen schien es, dass die Aufgabe auf diese Weise ganz einfach gelöst wurde.  Bei der Implementierung sind jedoch einige kritische Probleme aufgetreten: <br><br><ol><li>  Nachdem wir die Details mit Level-Designern geklärt hatten, kamen wir zu dem Schluss, dass die Anzahl der „Stockwerke“ in einem solchen Schema beeindruckend sein kann: Einige der Karten befinden sich in einem offenen Gebiet mit sanften Hängen und Hügeln. </li><li>  Die Berechnung von Treffern beim Schießen von einer Ebene zur anderen wurde zu einer nicht trivialen Aufgabe.  Ein Beispiel für eine Problemsituation ist in der folgenden Abbildung dargestellt: Hier kann Spieler 1 in Spieler 3 gelangen, jedoch nicht in Spieler 2, da der Schusspfad Schicht 2 blockiert, obwohl sich Spieler 2 und Spieler 3 auf derselben Schicht befinden. </li></ol><br><img src="https://habrastorage.org/webt/be/rg/be/bergbenv9gtcjzpkci26w_jmsik.png"><br><br>  Kurz gesagt, wir haben die Idee der Aufteilung des Raums in 2D-Ebenen schnell aufgegeben und beschlossen, die physische Engine vollständig zu ersetzen. <br><br>  Aus diesem Grund mussten wir genau diese Engine auswählen und in vorhandene Client- und Serveranwendungen integrieren. <br><br><h2>  Option 2: Wählen Sie eine fertige Bibliothek aus </h2><br>  Da der Spielclient in Unity geschrieben ist, haben wir beschlossen, die Möglichkeit der Verwendung der in Unity standardmäßig integrierten physischen Engine - PhysX - in Betracht zu ziehen.  Im Allgemeinen erfüllte er die Anforderungen unserer Spieleentwickler, um die 3D-Physik im Spiel zu unterstützen, voll und ganz, aber es gab immer noch ein erhebliches Problem.  Es bestand darin, dass unsere Serveranwendung in C # geschrieben war, ohne Unity zu verwenden. <br><br>  Es gab die Möglichkeit, eine C ++ - Bibliothek auf einem Server zu verwenden - zum Beispiel auf demselben PhysX -, aber wir haben dies nicht ernsthaft in Betracht gezogen: Aufgrund der Verwendung von nativem Code war die Wahrscheinlichkeit von Serverabstürzen bei diesem Ansatz hoch.  Ebenfalls peinlich ist die geringe Produktivität der Interop-Vorgänge und die Einzigartigkeit der PhysX-Assembly, die ausschließlich unter Unity ausgeführt wird, mit Ausnahme der Verwendung in einer anderen Umgebung. <br><br>  Darüber hinaus wurden bei dem Versuch, diese Idee umzusetzen, andere Probleme festgestellt: <br><br><ul><li>  Die fehlende Unterstützung für die Erstellung von Unity mit IL2CPP unter Linux erwies sich als sehr kritisch, da wir in einer der neuesten Versionen unsere Spieleserver auf .Net Core 2.1 umgestellt und auf Linux-Computern bereitgestellt haben. </li><li>  Mangel an praktischen Werkzeugen für die Profilerstellung von Servern in Unity; </li><li>  Geringe Leistung der Unity-Anwendung: Wir benötigten nur eine physische Engine und nicht alle verfügbaren Funktionen in Unity. </li></ul><br>  Parallel zu unserem Projekt entwickelte das Unternehmen einen weiteren Prototyp eines Multiplayer-PvP-Spiels.  Die Entwickler verwendeten Unity-Server, und wir bekamen ziemlich viele negative Rückmeldungen bezüglich des vorgeschlagenen Ansatzes.  Eine der Beschwerden war insbesondere, dass die Unity-Server sehr "gestreamt" wurden und alle paar Stunden neu gestartet werden mussten. <br><br>  Die Kombination dieser Probleme hat uns auch dazu gebracht, diese Idee aufzugeben.  Dann haben wir beschlossen, die Spieleserver auf .Net Core 2.1 zu belassen und statt VolatilePhysics, das wir zuvor verwendet haben, eine andere in C # geschriebene offene physische Engine zu wählen.  Wir brauchten nämlich eine C # -Engine, da wir bei der Verwendung von in C ++ geschriebenen Engines Angst vor unerwarteten Abstürzen hatten. <br><br>  Als Ergebnis wurden die folgenden Motoren für Tests ausgewählt: <br><br><ul><li>  <a href="https://github.com/bepu/bepuphysics1">Bepu Physic v1</a> ; </li><li>  <a href="https://github.com/bepu/bepuphysics2">Bepu Physic v2;</a> </li><li>  <a href="https://github.com/mattleibow/jitterphysics">Jitter Physic;</a> </li><li>  <a href="https://github.com/ValtoLibraries/BulletSharp">BulletSharp</a> </li></ul><br>  Das Hauptkriterium für uns war die Leistung der Engine, die Möglichkeit ihrer Integration in Unity und ihre Unterstützung: Sie hätte nicht aufgegeben werden dürfen, wenn wir Fehler darin gefunden hätten. <br><br>  Daher haben wir die Bepu Physics v1-, Bepu Physics v2- und Jitter Physics-Engines auf Leistung getestet, und unter ihnen erwies sich Bepu Physics v2 als die produktivste.  Außerdem ist er der einzige von diesen dreien, der sich weiterhin aktiv entwickelt. <br><br>  Bepu Physics v2 erfüllte jedoch nicht das letzte verbleibende Integrationskriterium für Unity: Diese Bibliothek verwendet SIMD-Operationen und System.Numerics. Da Baugruppen auf Mobilgeräten mit IL2CPP keine SIMD-Unterstützung bieten, gingen alle Vorteile der Bepu-Optimierungen verloren.  Die Demoszene im Build für iOS auf dem iPhone 5S war sehr langsam.  Wir konnten diese Lösung nicht auf Mobilgeräten verwenden. <br><br>  Hier sollte erklärt werden, warum wir generell an der Verwendung einer physikalischen Maschine interessiert waren.  In einem meiner vorherigen <a href="https://habr.com/ru/company/pixonic/blog/415959/">Artikel habe</a> ich darüber gesprochen, wie wir den Netzwerkteil des Spiels implementiert haben und wie die lokale Vorhersage von Spieleraktionen funktioniert.  Kurz gesagt, derselbe Code wird auf dem Client und dem Server ausgeführt - dem ECS-System.  Der Client reagiert sofort auf die Aktionen des Spielers, ohne auf eine Antwort vom Server zu warten - die sogenannte Vorhersage erfolgt.  Wenn eine Antwort vom Server kommt, überprüft der Client den vorhergesagten Zustand der Welt mit dem empfangenen und wenn sie nicht übereinstimmen (falsche Vorhersage), wird basierend auf der Antwort vom Server eine Korrektur (Abstimmung) dessen durchgeführt, was der Spieler sieht. <br><br>  Die Hauptidee ist, dass wir denselben Code sowohl auf dem Client als auch auf dem Server ausführen und Situationen mit falscher Vorhersage äußerst selten sind.  Keine der physischen C # -Engines, die wir gefunden haben, erfüllte jedoch unsere Anforderungen bei der Arbeit mit Mobilgeräten: Beispielsweise konnte sie auf dem iPhone 5S keine stabilen 30 fps liefern. <br><br><h2>  Option drei, endgültig: zwei verschiedene Motoren </h2><br>  Dann beschlossen wir zu experimentieren: Verwenden Sie zwei verschiedene physische Engines auf dem Client und dem Server.  Wir dachten, dass dies in unserem Fall funktionieren könnte: Wir haben eine ziemlich einfache Kollisionsphysik in unserem Spiel, außerdem wurde sie von uns als separates ECS-System implementiert und war nicht Teil der physischen Engine.  Alles, was wir von der physischen Engine benötigten, war die Fähigkeit, Reykast- und Sweepcasts im 3D-Raum zu erstellen. <br><br>  Aus diesem Grund haben wir uns entschlossen, die integrierte Physics Unity - PhysX - auf dem Client und Bepu Physics v2 auf dem Server zu verwenden. <br><br>  Zunächst haben wir die Benutzeroberfläche für die Verwendung der physischen Engine hervorgehoben: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Prototype.Common.Physics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPhysicsWorld</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentSimulationTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tick</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SphereCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleOverlap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, BodyMobilityField bodyMobilityField, CollisionLayer layer, List&lt;Overlap&gt; overlaps, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOrphanedDynamicBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WorldState.TableSet currentWorld</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, Vector3 position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; } }</code> </pre> <br></div></div><br>  Es gab verschiedene Implementierungen dieser Schnittstelle auf dem Client und dem Server: Wie bereits erwähnt, verwendeten wir auf dem Server die Implementierung mit Bepu und auf dem Client - Unity. <br><br>  An dieser Stelle sei auf die Feinheiten der Arbeit mit unserer Physik auf dem Server hingewiesen. <br><br>  Aufgrund der Tatsache, dass der Client Weltaktualisierungen mit Verzögerung (Lag) vom Server erhält, sieht der Spieler die Welt ein wenig anders als das, was er auf dem Server sieht: Er sieht sich in der Gegenwart und den Rest der Welt in der Vergangenheit.  Aus diesem Grund hat sich herausgestellt, dass der Spieler lokal auf ein Ziel schießt, das sich auf dem Server an einer anderen Stelle befindet.  Da wir also das lokale System zur Vorhersage von Spieleraktionen verwenden, müssen wir die Verzögerungen beim Schießen auf dem Server ausgleichen. <br><br><img src="https://habrastorage.org/webt/h5/gy/k3/h5gyk3svohmmd61k-xll9wq8zps.png"><br><br>  Um dies auszugleichen, müssen wir die Geschichte der Welt für die letzten N Millisekunden auf dem Server speichern und in der Lage sein, mit Objekten aus der Geschichte einschließlich ihrer Physik zu arbeiten.  Das heißt, unser System muss in der Lage sein, Kollisionen, Rakcasts und Sweepcasts „in der Vergangenheit“ zu berechnen.  Physikalische Engines können dies in der Regel nicht und Bepu mit PhysX ist keine Ausnahme.  Daher mussten wir diese Funktionalität selbst implementieren. <br><br>  Da wir das Spiel mit einer festen Frequenz von 30 Ticks pro Sekunde simulieren, mussten wir für jeden Tick die Daten der physischen Welt speichern.  Die Idee war, nicht eine Instanz der Simulation in der physischen Maschine zu erstellen, sondern N - für jeden in der Historie gespeicherten Tick - und den zyklischen Puffer dieser Simulationen zu verwenden, um sie in der Historie zu speichern: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SimulationSlice[] _simulationHistory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimulationSlice[PhysicsConfigs.HistoryLength]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BepupPhysicsWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _currentSimulationTick = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; PhysicsConfigs.HistoryLength; i++) { _simulationHistory[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimulationSlice(_bufferPool); } }</code> </pre> <br>  In unserem ECS gibt es eine Reihe von Schreib- / Lesesystemen, die mit der Physik arbeiten: <br><br><ul><li>  InitPhysicsWorldSystem; </li><li>  SpawnPhysicsDynamicsBodiesSystem; </li><li>  DestroyPhysicsDynamicsBodiesSystem; </li><li>  UpdatePhysicsTransformsSystem; </li><li>  MovePhysicsSystem, </li></ul><br>  sowie eine Reihe von Nur-Lese-Systemen, z. B. ein System zur Berechnung von Treffern aus Schüssen, Explosionen aus Granaten usw. <br><br>  Bei jedem Tick der Weltsimulation wird zuerst das InitPhysicsWorldSystem ausgeführt, das die aktuelle Tick-Nummer (SimulationSlice) auf die physische Engine setzt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentSimulationTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tick</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldTick = tick - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newSlice = _simulationHistory[tick % PhysicsConfigs.HistoryLength]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldSlice = _simulationHistory[oldTick % PhysicsConfigs.HistoryLength]; newSlice.RestoreBodiesFromPreviousTick(oldSlice); _currentSimulationTick = tick; }</code> </pre> <br>  Die RestoreBodiesFromPreviousTick-Methode stellt die Position von Objekten in der physischen Engine zum Zeitpunkt des vorherigen Ticks aus den im Verlauf gespeicherten Daten wieder her: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreBodiesFromPreviousTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SimulationSlice previous</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldStaticCount = previous._staticIds.Count; <span class="hljs-comment"><span class="hljs-comment">// add created static objects for (int i = 0; i &lt; oldStaticCount; i++) { var oldId = previous._staticIds[i]; if (!_staticIds.Contains(oldId)) { var oldHandler = previous._staticIdToHandler[oldId]; var oldBody = previous._staticHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateStatic(oldBody.Capsule, oldBody.Description.Pose, true, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _staticHandlerToBody[handler] = body; } else { var handler = CreateStatic(oldBody.Box, oldBody.Description.Pose, false, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Box = oldBody.Box; _staticHandlerToBody[handler] = body; } } } // delete not existing dynamic objects var newDynamicCount = _dynamicIds.Count; var idsToDel = stackalloc uint[_dynamicIds.Count]; int delIndex = 0; for (int i = 0; i &lt; newDynamicCount; i++) { var newId = _dynamicIds[i]; if (!previous._dynamicIds.Contains(newId)) { idsToDel[delIndex] = newId; delIndex++; } } for (int i = 0; i &lt; delIndex; i++) { var id = idsToDel[i]; var handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } // add created dynamic objects var oldDynamicCount = previous._dynamicIds.Count; for (int i = 0; i &lt; oldDynamicCount; i++) { var oldId = previous._dynamicIds[i]; if (!_dynamicIds.Contains(oldId)) { var oldHandler = previous._dynamicIdToHandler[oldId]; var oldBody = previous._dynamicHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateDynamic(oldBody.Capsule, oldBody.BodyReference.Pose, true, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _dynamicHandlerToBody[handler] = body; } else { var handler = CreateDynamic(oldBody.Box, oldBody.BodyReference.Pose, false, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Box = oldBody.Box; _dynamicHandlerToBody[handler] = body; } } } }</span></span></code> </pre> <br></div></div><br>  Danach erstellen oder löschen die Systeme SpawnPhysicsDynamicsBodiesSystem und DestroyPhysicsDynamicsBodiesSystem Objekte in der physischen Engine, je nachdem, wie sie im letzten ECS-Tick geändert wurden.  Anschließend aktualisiert das UpdatePhysicsTransformsSystem die Position aller dynamischen Körper gemäß den Daten in ECS. <br><br>  Sobald die Daten im ECS und in der Physik-Engine synchronisiert sind, berechnen wir die Bewegung von Objekten.  Wenn alle Lese- / Schreibvorgänge abgeschlossen sind, kommen Nur-Lese-Systeme zur Berechnung der Spiellogik (Schüsse, Explosionen, Nebel des Krieges ...) ins Spiel. <br><br>  Vollständiger Implementierungscode für SimulationSlice für Bepu Physics: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuPhysics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuPhysics.Collidables; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuUtilities.Memory; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Quaternion = BepuUtilities.Quaternion; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Prototype.Physics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BepupPhysicsWorld</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimulationSlice</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, StaticBody&gt; _staticHandlerToBody = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, StaticBody&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, DynamicBody&gt; _dynamicHandlerToBody = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, DynamicBody&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _staticIdToHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _dynamicIdToHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; _staticIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; _dynamicIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> BufferPool _bufferPool; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Simulation _simulation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimulationSlice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BufferPool bufferPool</span></span></span><span class="hljs-function">)</span></span> { _bufferPool = bufferPool; _simulation = Simulation.Create(_bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NarrowPhaseCallbacks(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PoseIntegratorCallbacks(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-9.81f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); BepupRayCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BepupRayCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.RayCast(origin, direction, distance, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _simulation.Bodies.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SphereCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); SweepCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SweepCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.Sweep(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sphere(radius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(direction.Normalized()), distance, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(collidableReference.Handle, _simulation.Bodies); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = reference.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; SweepCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SweepCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.Sweep(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(direction.Normalized()), distance, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(collidableReference.Handle, _simulation.Bodies); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = reference.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleOverlap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, BodyMobilityField bodyMobilityField, CollisionLayer layer, List&lt;Overlap&gt; overlaps</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BepupOverlapHitHandler( bodyMobilityField, layer, _staticHandlerToBody, _dynamicHandlerToBody, overlaps); _simulation.Sweep( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(Vector3.Zero), <span class="hljs-number"><span class="hljs-number">0</span></span>, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Box(size.X, size.Y, size.Z); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = CreateDynamic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _dynamicHandlerToBody[handler]; body.Box = shape; _dynamicHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Box(size.X, size.Y, size.Z); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler =CreateStatic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _staticHandlerToBody[handler]; body.Box = shape; _staticHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler =CreateStatic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _staticHandlerToBody[handler]; body.Capsule = shape; _staticHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = CreateDynamic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _dynamicHandlerToBody[handler]; body.Capsule = shape; _dynamicHandlerToBody[handler] = body; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreateDynamic&lt;TShape&gt;(TShape shape, RigidPose pose, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isCapsule, <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> id, CollisionLayer collisionLayer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TShape : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>, IShape { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> activity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyActivityDescription() { SleepThreshold = <span class="hljs-number"><span class="hljs-number">-1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollidableDescription() { Shape = _simulation.Shapes.Add(shape), SpeculativeMargin = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleDescription = BodyDescription.CreateKinematic(pose, collidable, activity); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _simulation.Bodies.Add(capsuleDescription); _dynamicIds.Add(id); _dynamicIdToHandler.Add(id, handler); _dynamicHandlerToBody.Add(handler, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicBody { BodyReference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(handler, _simulation.Bodies), Id = id, IsCapsule = isCapsule, CollisionLayer = collisionLayer }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreateStatic&lt;TShape&gt;(TShape shape, RigidPose pose, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isCapsule, <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> id, CollisionLayer collisionLayer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TShape : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>, IShape { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleDescription = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticDescription() { Pose = pose, Collidable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollidableDescription() { Shape = _simulation.Shapes.Add(shape), SpeculativeMargin = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _simulation.Statics.Add(capsuleDescription); _staticIds.Add(id); _staticIdToHandler.Add(id, handler); _staticHandlerToBody.Add(handler, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticBody { Description = capsuleDescription, Id = id, IsCapsule = isCapsule, CollisionLayer = collisionLayer }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOrphanedDynamicBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TableSet currentWorld</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toDel = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>[_dynamicIds.Count]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toDelIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _dynamicIdToHandler) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentWorld.DynamicPhysicsBody.HasCmp(i.Key)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } toDel[toDelIndex] = i.Key; toDelIndex++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; toDelIndex; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = toDel[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _staticIdToHandler.ContainsKey(id) || _dynamicIdToHandler.ContainsKey(id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreBodiesFromPreviousTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SimulationSlice previous</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldStaticCount = previous._staticIds.Count; <span class="hljs-comment"><span class="hljs-comment">// add created static objects for (int i = 0; i &lt; oldStaticCount; i++) { var oldId = previous._staticIds[i]; if (!_staticIds.Contains(oldId)) { var oldHandler = previous._staticIdToHandler[oldId]; var oldBody = previous._staticHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateStatic(oldBody.Capsule, oldBody.Description.Pose, true, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _staticHandlerToBody[handler] = body; } else { var handler = CreateStatic(oldBody.Box, oldBody.Description.Pose, false, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Box = oldBody.Box; _staticHandlerToBody[handler] = body; } } } // delete not existing dynamic objects var newDynamicCount = _dynamicIds.Count; var idsToDel = stackalloc uint[_dynamicIds.Count]; int delIndex = 0; for (int i = 0; i &lt; newDynamicCount; i++) { var newId = _dynamicIds[i]; if (!previous._dynamicIds.Contains(newId)) { idsToDel[delIndex] = newId; delIndex++; } } for (int i = 0; i &lt; delIndex; i++) { var id = idsToDel[i]; var handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } // add created dynamic objects var oldDynamicCount = previous._dynamicIds.Count; for (int i = 0; i &lt; oldDynamicCount; i++) { var oldId = previous._dynamicIds[i]; if (!_dynamicIds.Contains(oldId)) { var oldHandler = previous._dynamicIdToHandler[oldId]; var oldBody = previous._dynamicHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateDynamic(oldBody.Capsule, oldBody.BodyReference.Pose, true, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _dynamicHandlerToBody[handler] = body; } else { var handler = CreateDynamic(oldBody.Box, oldBody.BodyReference.Pose, false, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Box = oldBody.Box; _dynamicHandlerToBody[handler] = body; } } } } public void Update() { _simulation.Timestep(GameState.TickDurationSec); } public void UpdateBody(uint id, Vector3 position, float angle) { if (_staticIdToHandler.TryGetValue(id, out var handler)) { _simulation.Statics.GetDescription(handler, out var staticDescription); staticDescription.Pose.Position = position; staticDescription.Pose.Orientation = Quaternion.CreateFromAxisAngle(new Vector3(0, 1, 0), angle); _simulation.Statics.ApplyDescription(handler, staticDescription); } else if(_dynamicIdToHandler.TryGetValue(id, out handler)) { BodyReference reference = new BodyReference(handler, _simulation.Bodies); reference.Pose.Position = position; reference.Pose.Orientation = Quaternion.CreateFromAxisAngle(new Vector3(0, 1, 0), angle); } } public void Dispose() { _simulation.Clear(); } } public void Dispose() { _bufferPool.Clear(); } } }</span></span></code> </pre> <br></div></div><br>  Zusätzlich zur Implementierung des Verlaufs auf dem Server mussten wir auch den Verlauf der Physik auf dem Client implementieren.  Unser Unity-Client verfügt über einen Server-Emulationsmodus (wir nennen ihn lokale Simulation), in dem der Servercode mit dem Client ausgeführt wird.  Wir verwenden diesen Modus für das Rapid Prototyping von Spielfunktionen. <br><br>  Wie Bepu hat PhysX keine Unterstützung für die Historie.  Hier haben wir dieselbe Idee angewendet, bei der für jeden Tick im Verlauf mehrere physikalische Simulationen wie auf dem Server verwendet wurden.  Bei der Arbeit mit physischen Engines legt Unity jedoch seine eigenen Besonderheiten fest.  Es ist jedoch zu beachten, dass unser Projekt auf Unity 2018.4 (LTS) entwickelt wurde und einige APIs in neueren Versionen möglicherweise geändert werden, sodass es keine Probleme wie unsere geben wird. <br><br>  Das Problem bestand darin, dass in Unity keine separate physikalische Simulation (oder in der PhysX-Terminologie eine Szene) erstellt werden konnte. Daher haben wir jeden Tick in der Geschichte der Physik in Unity als separate Szene implementiert. <br><br>  Über solche Szenen wurde eine Wrapper-Klasse geschrieben - UnityPhysicsHistorySlice: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnityPhysicsHistorySlice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SphereCastDelegate sphereCastDelegate, OverlapSphereNonAlloc overlapSphere, CapsuleCastDelegate capsuleCast, OverlapCapsuleNonAlloc overlapCapsule, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _scene = SceneManager.CreateScene(name, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreateSceneParameters() { localPhysicsMode = LocalPhysicsMode.Physics3D }); _physicsScene = _scene.GetPhysicsScene(); _sphereCast = sphereCastDelegate; _capsuleCast = capsuleCast; _overlapSphere = overlapSphere; _overlapCapsule = overlapCapsule; _boxPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PhysicsSceneObjectsPool&lt;BoxCollider&gt;(_scene, <span class="hljs-string"><span class="hljs-string">"box"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); _capsulePool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PhysicsSceneObjectsPool&lt;UnityEngine.CapsuleCollider&gt;(_scene, <span class="hljs-string"><span class="hljs-string">"sphere"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Das zweite Problem von Unity ist, dass alle Arbeiten mit Physik über die statische Klasse Physik ausgeführt werden, deren API es Ihnen nicht ermöglicht, Rakecasts und Sweepcasts in einer bestimmten Szene durchzuführen.  Diese API funktioniert nur mit einer aktiven Szene.  Die PhysX-Engine selbst ermöglicht es Ihnen jedoch, mit mehreren Szenen gleichzeitig zu arbeiten. Sie müssen nur die richtigen Methoden aufrufen.  Glücklicherweise versteckte Unity solche Methoden hinter der Physics.cs-Klassenschnittstelle. Alles, was übrig blieb, war der Zugriff darauf.  Wir haben es so gemacht: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs">MethodInfo raycastMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"Internal_SphereCast"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sphereCast = (SphereCastDelegate) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(SphereCastDelegate), raycastMethod); MethodInfo overlapSphereMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"OverlapSphereNonAlloc_Internal"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> overlapSphere = (OverlapSphereNonAlloc) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(OverlapSphereNonAlloc), overlapSphereMethod); MethodInfo capsuleCastMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"Internal_CapsuleCast"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleCast = (CapsuleCastDelegate) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CapsuleCastDelegate), capsuleCastMethod); MethodInfo overlapCapsuleMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"OverlapCapsuleNonAlloc_Internal"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> overlapCapsule = (OverlapCapsuleNonAlloc) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(OverlapCapsuleNonAlloc), overlapCapsuleMethod);</code> </pre> <br></div></div><br>  Ansonsten unterschied sich der Code zum Implementieren von UnityPhysicsHistorySlice nicht wesentlich von dem in BepuSimulationSlice. <br><br>  Somit haben wir zwei Implementierungen der Spielphysik: auf dem Client und auf dem Server. <br><br>  Der nächste Schritt ist das Testen. <br><br>  Einer der wichtigsten Indikatoren für die „Gesundheit“ unserer Kunden ist der Parameter für die Anzahl der Fehlvorhersagen beim Server.  Vor dem Umstieg auf andere physische Engines variierte dieser Indikator innerhalb von 1-2% - das heißt, während eines Kampfes von 9000 Ticks (oder 5 Minuten) wurden 90-180 Simulations-Ticks verwechselt.  Wir haben diese Ergebnisse über mehrere Releases des Spiels in der Soft Lounge erhalten.  Nachdem wir auf verschiedene Engines umgestellt hatten, erwarteten wir ein starkes Wachstum dieses Indikators - vielleicht sogar mehrmals - schließlich führten wir auf Client und Server unterschiedlichen Code aus, und es schien logisch, dass sich die Fehler in den Berechnungen durch verschiedene Algorithmen schnell ansammeln würden.  In der Praxis stellte sich heraus, dass der Diskrepanzparameter nur um 0,2-0,5% wuchs und durchschnittlich 2-2,5% pro Gefecht betrug, was für uns völlig angemessen war. <br><br>  Die meisten von uns untersuchten Engines und Technologien verwendeten auf Client und Server denselben Code.  Unsere Hypothese mit der Möglichkeit der Verwendung unterschiedlicher physikalischer Motoren wurde jedoch bestätigt.  Der Hauptgrund, warum die Diskrepanzrate so leicht angestiegen ist, war, dass wir die Bewegung von Körpern im Weltraum und Kollisionen mit einem unserer ECS-Systeme berechnen.  Dieser Code ist sowohl auf dem Client als auch auf dem Server identisch.  Bei der physischen Maschine brauchten wir eine schnelle Berechnung von Rakecasts und Sweepcasts, und die Ergebnisse dieser Operationen in der Praxis unterschieden sich für unsere beiden Maschinen nicht wesentlich. <br><br><h2>  Was zu lesen </h2><br>  Abschließend, wie üblich, hier ein paar verwandte Links: <br><br><ul><li>  <a href="https://habr.com/ru/company/pixonic/blog/481880/">Physik für einen mobilen PvP-Shooter, Teil 1</a> ; </li><li>  <a href="https://habr.com/ru/company/pixonic/blog/415959/">Netzwerkcode für einen mobilen PvP-Shooter</a> ; </li><li>  <a href="https://gafferongames.com/">Glen Fiedlers Blog über das Schreiben von Netzwerkcode in Spielen</a> ; </li><li>  <a href="https://www.gdcvault.com/play/1026322/Back-to-the-Future-Working">Deterministische Simulation und Netzwerkcode in For Honor</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485150/">https://habr.com/ru/post/de485150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485136/index.html">Istio Tracing and Monitoring: Microservices und das Unsicherheitsprinzip</a></li>
<li><a href="../de485138/index.html">Anwendungslokalisierung: Wie wir Freunde für die Übersetzung und Entwicklung gewonnen haben</a></li>
<li><a href="../de485144/index.html">Wie ich eine kaputte Basis reparierte und was daraus wurde</a></li>
<li><a href="../de485146/index.html">IT-Gehälter im zweiten Halbjahr 2019: laut Habr-Karriererechner</a></li>
<li><a href="../de485148/index.html">Dieser entzückende Unicode</a></li>
<li><a href="../de485152/index.html">Frühlingspraktikum für mobile Entwickler bei Redmadrobot</a></li>
<li><a href="../de485154/index.html">Wie man aus einem Entwickler einen Markenfreak macht: ein Motivationssystem für Programmierer</a></li>
<li><a href="../de485156/index.html">Wie man ein häuslicher Crowdfunder ist (Teil 1)</a></li>
<li><a href="../de485158/index.html">Nikolay Vavilov. Der Mann, der die ganze Welt ernähren wollte und in einer Gefängniszelle verhungerte</a></li>
<li><a href="../de485160/index.html">Was ist ich in ACID oder einer anderen Perspektive</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>