<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèª üßëüèº üóØÔ∏è Physik f√ºr einen mobilen PvP-Shooter oder wie wir ein zweidimensionales Spiel in ein dreidimensionales verwandeln üë®üèø‚Äçüíª üåö üôáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel sprach mein Kollege dar√ºber, wie wir in unserem mobilen Multiplayer-Shooter eine zweidimensionale Physik-Engine verwendet ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Physik f√ºr einen mobilen PvP-Shooter oder wie wir ein zweidimensionales Spiel in ein dreidimensionales verwandeln</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/485150/"><img src="https://habrastorage.org/webt/fo/if/az/foifazxdmxh_smqsswnkxhn0ww4.png"><br><br>  In einem <a href="https://habr.com/ru/company/pixonic/blog/481880/">fr√ºheren Artikel</a> sprach mein Kollege dar√ºber, wie wir in unserem mobilen Multiplayer-Shooter eine zweidimensionale Physik-Engine verwendet haben.  Und jetzt m√∂chte ich Ihnen mitteilen, wie wir alles, was wir zuvor getan haben, von vorne begonnen haben - mit anderen Worten, wie wir unser Spiel von der 2D-Welt in die 3D-Welt √ºbertragen haben. <br><a name="habracut"></a><br>  Alles begann damit, dass einmal ein Produzent und ein f√ºhrender Spieledesigner in die Programmierabteilung kamen und uns vor eine Herausforderung stellten: Ein mobiler PvP-Top-Down-Shooter mit Dreharbeiten auf engstem Raum musste in einen Third-Person-Shooter mit Dreharbeiten auf freiem Feld umgewandelt werden.  In diesem Fall ist es w√ºnschenswert, dass die Karte nicht so aussieht: <br><br><img src="https://habrastorage.org/webt/he/j3/2p/hej32pvogui5sukjz842wjpyqry.png"><br><br>  Und so: <br><br><img src="https://habrastorage.org/webt/n8/25/xw/n825xwkx_jsgqgoemkcor-r4ti0.jpeg"><br><br>  Die technischen Anforderungen waren wie folgt: <br><br><ul><li>  Kartengr√∂√üe - 100 √ó 100 Meter; </li><li>  H√∂henunterschied - 40 Meter; </li><li>  Unterst√ºtzung f√ºr Tunnel, Br√ºcken; </li><li>  Schie√üen auf Ziele in verschiedenen H√∂hen; </li><li>  Kollisionen mit statischer Geometrie (wir haben keine Kollisionen mit anderen Charakteren im Spiel); </li><li>  Physik des freien Falls; </li><li>  Granatenwurf Physik. </li></ul><br>  Mit Blick auf die Zukunft kann ich sagen, dass unser Spiel nicht wie der letzte Screenshot aussah: Es stellte sich heraus, dass es eine Kreuzung zwischen der ersten und der zweiten Option war. <br><br><h2>  Option eins: geschichtete Struktur </h2><br>  Die erste Idee bestand darin, die Physik-Engine nicht zu √§ndern, sondern einfach mehrere Ebenen mit "Anzahl der Stockwerke" hinzuzuf√ºgen.  Es stellte sich so etwas wie Grundrisse im Geb√§ude heraus: <br><br><img src="https://habrastorage.org/webt/lz/dy/oq/lzdyoquthw76ajisyvgqcn7zc_i.jpeg"><br><br>  Mit diesem Ansatz mussten wir weder die Client- noch die Serveranwendungen radikal wiederholen, und im Allgemeinen schien es, dass die Aufgabe auf diese Weise ganz einfach gel√∂st wurde.  Bei der Implementierung sind jedoch einige kritische Probleme aufgetreten: <br><br><ol><li>  Nachdem wir die Details mit Level-Designern gekl√§rt hatten, kamen wir zu dem Schluss, dass die Anzahl der ‚ÄûStockwerke‚Äú in einem solchen Schema beeindruckend sein kann: Einige der Karten befinden sich in einem offenen Gebiet mit sanften H√§ngen und H√ºgeln. </li><li>  Die Berechnung von Treffern beim Schie√üen von einer Ebene zur anderen wurde zu einer nicht trivialen Aufgabe.  Ein Beispiel f√ºr eine Problemsituation ist in der folgenden Abbildung dargestellt: Hier kann Spieler 1 in Spieler 3 gelangen, jedoch nicht in Spieler 2, da der Schusspfad Schicht 2 blockiert, obwohl sich Spieler 2 und Spieler 3 auf derselben Schicht befinden. </li></ol><br><img src="https://habrastorage.org/webt/be/rg/be/bergbenv9gtcjzpkci26w_jmsik.png"><br><br>  Kurz gesagt, wir haben die Idee der Aufteilung des Raums in 2D-Ebenen schnell aufgegeben und beschlossen, die physische Engine vollst√§ndig zu ersetzen. <br><br>  Aus diesem Grund mussten wir genau diese Engine ausw√§hlen und in vorhandene Client- und Serveranwendungen integrieren. <br><br><h2>  Option 2: W√§hlen Sie eine fertige Bibliothek aus </h2><br>  Da der Spielclient in Unity geschrieben ist, haben wir beschlossen, die M√∂glichkeit der Verwendung der in Unity standardm√§√üig integrierten physischen Engine - PhysX - in Betracht zu ziehen.  Im Allgemeinen erf√ºllte er die Anforderungen unserer Spieleentwickler, um die 3D-Physik im Spiel zu unterst√ºtzen, voll und ganz, aber es gab immer noch ein erhebliches Problem.  Es bestand darin, dass unsere Serveranwendung in C # geschrieben war, ohne Unity zu verwenden. <br><br>  Es gab die M√∂glichkeit, eine C ++ - Bibliothek auf einem Server zu verwenden - zum Beispiel auf demselben PhysX -, aber wir haben dies nicht ernsthaft in Betracht gezogen: Aufgrund der Verwendung von nativem Code war die Wahrscheinlichkeit von Serverabst√ºrzen bei diesem Ansatz hoch.  Ebenfalls peinlich ist die geringe Produktivit√§t der Interop-Vorg√§nge und die Einzigartigkeit der PhysX-Assembly, die ausschlie√ülich unter Unity ausgef√ºhrt wird, mit Ausnahme der Verwendung in einer anderen Umgebung. <br><br>  Dar√ºber hinaus wurden bei dem Versuch, diese Idee umzusetzen, andere Probleme festgestellt: <br><br><ul><li>  Die fehlende Unterst√ºtzung f√ºr die Erstellung von Unity mit IL2CPP unter Linux erwies sich als sehr kritisch, da wir in einer der neuesten Versionen unsere Spieleserver auf .Net Core 2.1 umgestellt und auf Linux-Computern bereitgestellt haben. </li><li>  Mangel an praktischen Werkzeugen f√ºr die Profilerstellung von Servern in Unity; </li><li>  Geringe Leistung der Unity-Anwendung: Wir ben√∂tigten nur eine physische Engine und nicht alle verf√ºgbaren Funktionen in Unity. </li></ul><br>  Parallel zu unserem Projekt entwickelte das Unternehmen einen weiteren Prototyp eines Multiplayer-PvP-Spiels.  Die Entwickler verwendeten Unity-Server, und wir bekamen ziemlich viele negative R√ºckmeldungen bez√ºglich des vorgeschlagenen Ansatzes.  Eine der Beschwerden war insbesondere, dass die Unity-Server sehr "gestreamt" wurden und alle paar Stunden neu gestartet werden mussten. <br><br>  Die Kombination dieser Probleme hat uns auch dazu gebracht, diese Idee aufzugeben.  Dann haben wir beschlossen, die Spieleserver auf .Net Core 2.1 zu belassen und statt VolatilePhysics, das wir zuvor verwendet haben, eine andere in C # geschriebene offene physische Engine zu w√§hlen.  Wir brauchten n√§mlich eine C # -Engine, da wir bei der Verwendung von in C ++ geschriebenen Engines Angst vor unerwarteten Abst√ºrzen hatten. <br><br>  Als Ergebnis wurden die folgenden Motoren f√ºr Tests ausgew√§hlt: <br><br><ul><li>  <a href="https://github.com/bepu/bepuphysics1">Bepu Physic v1</a> ; </li><li>  <a href="https://github.com/bepu/bepuphysics2">Bepu Physic v2;</a> </li><li>  <a href="https://github.com/mattleibow/jitterphysics">Jitter Physic;</a> </li><li>  <a href="https://github.com/ValtoLibraries/BulletSharp">BulletSharp</a> </li></ul><br>  Das Hauptkriterium f√ºr uns war die Leistung der Engine, die M√∂glichkeit ihrer Integration in Unity und ihre Unterst√ºtzung: Sie h√§tte nicht aufgegeben werden d√ºrfen, wenn wir Fehler darin gefunden h√§tten. <br><br>  Daher haben wir die Bepu Physics v1-, Bepu Physics v2- und Jitter Physics-Engines auf Leistung getestet, und unter ihnen erwies sich Bepu Physics v2 als die produktivste.  Au√üerdem ist er der einzige von diesen dreien, der sich weiterhin aktiv entwickelt. <br><br>  Bepu Physics v2 erf√ºllte jedoch nicht das letzte verbleibende Integrationskriterium f√ºr Unity: Diese Bibliothek verwendet SIMD-Operationen und System.Numerics. Da Baugruppen auf Mobilger√§ten mit IL2CPP keine SIMD-Unterst√ºtzung bieten, gingen alle Vorteile der Bepu-Optimierungen verloren.  Die Demoszene im Build f√ºr iOS auf dem iPhone 5S war sehr langsam.  Wir konnten diese L√∂sung nicht auf Mobilger√§ten verwenden. <br><br>  Hier sollte erkl√§rt werden, warum wir generell an der Verwendung einer physikalischen Maschine interessiert waren.  In einem meiner vorherigen <a href="https://habr.com/ru/company/pixonic/blog/415959/">Artikel habe</a> ich dar√ºber gesprochen, wie wir den Netzwerkteil des Spiels implementiert haben und wie die lokale Vorhersage von Spieleraktionen funktioniert.  Kurz gesagt, derselbe Code wird auf dem Client und dem Server ausgef√ºhrt - dem ECS-System.  Der Client reagiert sofort auf die Aktionen des Spielers, ohne auf eine Antwort vom Server zu warten - die sogenannte Vorhersage erfolgt.  Wenn eine Antwort vom Server kommt, √ºberpr√ºft der Client den vorhergesagten Zustand der Welt mit dem empfangenen und wenn sie nicht √ºbereinstimmen (falsche Vorhersage), wird basierend auf der Antwort vom Server eine Korrektur (Abstimmung) dessen durchgef√ºhrt, was der Spieler sieht. <br><br>  Die Hauptidee ist, dass wir denselben Code sowohl auf dem Client als auch auf dem Server ausf√ºhren und Situationen mit falscher Vorhersage √§u√üerst selten sind.  Keine der physischen C # -Engines, die wir gefunden haben, erf√ºllte jedoch unsere Anforderungen bei der Arbeit mit Mobilger√§ten: Beispielsweise konnte sie auf dem iPhone 5S keine stabilen 30 fps liefern. <br><br><h2>  Option drei, endg√ºltig: zwei verschiedene Motoren </h2><br>  Dann beschlossen wir zu experimentieren: Verwenden Sie zwei verschiedene physische Engines auf dem Client und dem Server.  Wir dachten, dass dies in unserem Fall funktionieren k√∂nnte: Wir haben eine ziemlich einfache Kollisionsphysik in unserem Spiel, au√üerdem wurde sie von uns als separates ECS-System implementiert und war nicht Teil der physischen Engine.  Alles, was wir von der physischen Engine ben√∂tigten, war die F√§higkeit, Reykast- und Sweepcasts im 3D-Raum zu erstellen. <br><br>  Aus diesem Grund haben wir uns entschlossen, die integrierte Physics Unity - PhysX - auf dem Client und Bepu Physics v2 auf dem Server zu verwenden. <br><br>  Zun√§chst haben wir die Benutzeroberfl√§che f√ºr die Verwendung der physischen Engine hervorgehoben: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Prototype.Common.Physics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPhysicsWorld</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentSimulationTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tick</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SphereCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleOverlap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, BodyMobilityField bodyMobilityField, CollisionLayer layer, List&lt;Overlap&gt; overlaps, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOrphanedDynamicBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WorldState.TableSet currentWorld</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, Vector3 position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; } }</code> </pre> <br></div></div><br>  Es gab verschiedene Implementierungen dieser Schnittstelle auf dem Client und dem Server: Wie bereits erw√§hnt, verwendeten wir auf dem Server die Implementierung mit Bepu und auf dem Client - Unity. <br><br>  An dieser Stelle sei auf die Feinheiten der Arbeit mit unserer Physik auf dem Server hingewiesen. <br><br>  Aufgrund der Tatsache, dass der Client Weltaktualisierungen mit Verz√∂gerung (Lag) vom Server erh√§lt, sieht der Spieler die Welt ein wenig anders als das, was er auf dem Server sieht: Er sieht sich in der Gegenwart und den Rest der Welt in der Vergangenheit.  Aus diesem Grund hat sich herausgestellt, dass der Spieler lokal auf ein Ziel schie√üt, das sich auf dem Server an einer anderen Stelle befindet.  Da wir also das lokale System zur Vorhersage von Spieleraktionen verwenden, m√ºssen wir die Verz√∂gerungen beim Schie√üen auf dem Server ausgleichen. <br><br><img src="https://habrastorage.org/webt/h5/gy/k3/h5gyk3svohmmd61k-xll9wq8zps.png"><br><br>  Um dies auszugleichen, m√ºssen wir die Geschichte der Welt f√ºr die letzten N Millisekunden auf dem Server speichern und in der Lage sein, mit Objekten aus der Geschichte einschlie√ülich ihrer Physik zu arbeiten.  Das hei√üt, unser System muss in der Lage sein, Kollisionen, Rakcasts und Sweepcasts ‚Äûin der Vergangenheit‚Äú zu berechnen.  Physikalische Engines k√∂nnen dies in der Regel nicht und Bepu mit PhysX ist keine Ausnahme.  Daher mussten wir diese Funktionalit√§t selbst implementieren. <br><br>  Da wir das Spiel mit einer festen Frequenz von 30 Ticks pro Sekunde simulieren, mussten wir f√ºr jeden Tick die Daten der physischen Welt speichern.  Die Idee war, nicht eine Instanz der Simulation in der physischen Maschine zu erstellen, sondern N - f√ºr jeden in der Historie gespeicherten Tick - und den zyklischen Puffer dieser Simulationen zu verwenden, um sie in der Historie zu speichern: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SimulationSlice[] _simulationHistory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimulationSlice[PhysicsConfigs.HistoryLength]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BepupPhysicsWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _currentSimulationTick = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; PhysicsConfigs.HistoryLength; i++) { _simulationHistory[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimulationSlice(_bufferPool); } }</code> </pre> <br>  In unserem ECS gibt es eine Reihe von Schreib- / Lesesystemen, die mit der Physik arbeiten: <br><br><ul><li>  InitPhysicsWorldSystem; </li><li>  SpawnPhysicsDynamicsBodiesSystem; </li><li>  DestroyPhysicsDynamicsBodiesSystem; </li><li>  UpdatePhysicsTransformsSystem; </li><li>  MovePhysicsSystem, </li></ul><br>  sowie eine Reihe von Nur-Lese-Systemen, z. B. ein System zur Berechnung von Treffern aus Sch√ºssen, Explosionen aus Granaten usw. <br><br>  Bei jedem Tick der Weltsimulation wird zuerst das InitPhysicsWorldSystem ausgef√ºhrt, das die aktuelle Tick-Nummer (SimulationSlice) auf die physische Engine setzt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentSimulationTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tick</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldTick = tick - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newSlice = _simulationHistory[tick % PhysicsConfigs.HistoryLength]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldSlice = _simulationHistory[oldTick % PhysicsConfigs.HistoryLength]; newSlice.RestoreBodiesFromPreviousTick(oldSlice); _currentSimulationTick = tick; }</code> </pre> <br>  Die RestoreBodiesFromPreviousTick-Methode stellt die Position von Objekten in der physischen Engine zum Zeitpunkt des vorherigen Ticks aus den im Verlauf gespeicherten Daten wieder her: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreBodiesFromPreviousTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SimulationSlice previous</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldStaticCount = previous._staticIds.Count; <span class="hljs-comment"><span class="hljs-comment">// add created static objects for (int i = 0; i &lt; oldStaticCount; i++) { var oldId = previous._staticIds[i]; if (!_staticIds.Contains(oldId)) { var oldHandler = previous._staticIdToHandler[oldId]; var oldBody = previous._staticHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateStatic(oldBody.Capsule, oldBody.Description.Pose, true, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _staticHandlerToBody[handler] = body; } else { var handler = CreateStatic(oldBody.Box, oldBody.Description.Pose, false, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Box = oldBody.Box; _staticHandlerToBody[handler] = body; } } } // delete not existing dynamic objects var newDynamicCount = _dynamicIds.Count; var idsToDel = stackalloc uint[_dynamicIds.Count]; int delIndex = 0; for (int i = 0; i &lt; newDynamicCount; i++) { var newId = _dynamicIds[i]; if (!previous._dynamicIds.Contains(newId)) { idsToDel[delIndex] = newId; delIndex++; } } for (int i = 0; i &lt; delIndex; i++) { var id = idsToDel[i]; var handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } // add created dynamic objects var oldDynamicCount = previous._dynamicIds.Count; for (int i = 0; i &lt; oldDynamicCount; i++) { var oldId = previous._dynamicIds[i]; if (!_dynamicIds.Contains(oldId)) { var oldHandler = previous._dynamicIdToHandler[oldId]; var oldBody = previous._dynamicHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateDynamic(oldBody.Capsule, oldBody.BodyReference.Pose, true, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _dynamicHandlerToBody[handler] = body; } else { var handler = CreateDynamic(oldBody.Box, oldBody.BodyReference.Pose, false, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Box = oldBody.Box; _dynamicHandlerToBody[handler] = body; } } } }</span></span></code> </pre> <br></div></div><br>  Danach erstellen oder l√∂schen die Systeme SpawnPhysicsDynamicsBodiesSystem und DestroyPhysicsDynamicsBodiesSystem Objekte in der physischen Engine, je nachdem, wie sie im letzten ECS-Tick ge√§ndert wurden.  Anschlie√üend aktualisiert das UpdatePhysicsTransformsSystem die Position aller dynamischen K√∂rper gem√§√ü den Daten in ECS. <br><br>  Sobald die Daten im ECS und in der Physik-Engine synchronisiert sind, berechnen wir die Bewegung von Objekten.  Wenn alle Lese- / Schreibvorg√§nge abgeschlossen sind, kommen Nur-Lese-Systeme zur Berechnung der Spiellogik (Sch√ºsse, Explosionen, Nebel des Krieges ...) ins Spiel. <br><br>  Vollst√§ndiger Implementierungscode f√ºr SimulationSlice f√ºr Bepu Physics: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuPhysics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuPhysics.Collidables; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuUtilities.Memory; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Quaternion = BepuUtilities.Quaternion; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Prototype.Physics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BepupPhysicsWorld</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimulationSlice</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, StaticBody&gt; _staticHandlerToBody = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, StaticBody&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, DynamicBody&gt; _dynamicHandlerToBody = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, DynamicBody&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _staticIdToHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _dynamicIdToHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; _staticIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; _dynamicIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> BufferPool _bufferPool; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Simulation _simulation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimulationSlice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BufferPool bufferPool</span></span></span><span class="hljs-function">)</span></span> { _bufferPool = bufferPool; _simulation = Simulation.Create(_bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NarrowPhaseCallbacks(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PoseIntegratorCallbacks(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-9.81f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); BepupRayCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BepupRayCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.RayCast(origin, direction, distance, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _simulation.Bodies.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SphereCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); SweepCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SweepCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.Sweep(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sphere(radius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(direction.Normalized()), distance, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(collidableReference.Handle, _simulation.Bodies); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = reference.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; SweepCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SweepCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.Sweep(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(direction.Normalized()), distance, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(collidableReference.Handle, _simulation.Bodies); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = reference.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleOverlap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, BodyMobilityField bodyMobilityField, CollisionLayer layer, List&lt;Overlap&gt; overlaps</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BepupOverlapHitHandler( bodyMobilityField, layer, _staticHandlerToBody, _dynamicHandlerToBody, overlaps); _simulation.Sweep( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(Vector3.Zero), <span class="hljs-number"><span class="hljs-number">0</span></span>, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Box(size.X, size.Y, size.Z); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = CreateDynamic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _dynamicHandlerToBody[handler]; body.Box = shape; _dynamicHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Box(size.X, size.Y, size.Z); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler =CreateStatic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _staticHandlerToBody[handler]; body.Box = shape; _staticHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler =CreateStatic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _staticHandlerToBody[handler]; body.Capsule = shape; _staticHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = CreateDynamic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _dynamicHandlerToBody[handler]; body.Capsule = shape; _dynamicHandlerToBody[handler] = body; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreateDynamic&lt;TShape&gt;(TShape shape, RigidPose pose, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isCapsule, <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> id, CollisionLayer collisionLayer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TShape : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>, IShape { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> activity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyActivityDescription() { SleepThreshold = <span class="hljs-number"><span class="hljs-number">-1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollidableDescription() { Shape = _simulation.Shapes.Add(shape), SpeculativeMargin = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleDescription = BodyDescription.CreateKinematic(pose, collidable, activity); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _simulation.Bodies.Add(capsuleDescription); _dynamicIds.Add(id); _dynamicIdToHandler.Add(id, handler); _dynamicHandlerToBody.Add(handler, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicBody { BodyReference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(handler, _simulation.Bodies), Id = id, IsCapsule = isCapsule, CollisionLayer = collisionLayer }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreateStatic&lt;TShape&gt;(TShape shape, RigidPose pose, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isCapsule, <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> id, CollisionLayer collisionLayer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TShape : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>, IShape { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleDescription = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticDescription() { Pose = pose, Collidable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollidableDescription() { Shape = _simulation.Shapes.Add(shape), SpeculativeMargin = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _simulation.Statics.Add(capsuleDescription); _staticIds.Add(id); _staticIdToHandler.Add(id, handler); _staticHandlerToBody.Add(handler, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticBody { Description = capsuleDescription, Id = id, IsCapsule = isCapsule, CollisionLayer = collisionLayer }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOrphanedDynamicBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TableSet currentWorld</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toDel = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>[_dynamicIds.Count]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toDelIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _dynamicIdToHandler) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentWorld.DynamicPhysicsBody.HasCmp(i.Key)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } toDel[toDelIndex] = i.Key; toDelIndex++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; toDelIndex; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = toDel[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _staticIdToHandler.ContainsKey(id) || _dynamicIdToHandler.ContainsKey(id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreBodiesFromPreviousTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SimulationSlice previous</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldStaticCount = previous._staticIds.Count; <span class="hljs-comment"><span class="hljs-comment">// add created static objects for (int i = 0; i &lt; oldStaticCount; i++) { var oldId = previous._staticIds[i]; if (!_staticIds.Contains(oldId)) { var oldHandler = previous._staticIdToHandler[oldId]; var oldBody = previous._staticHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateStatic(oldBody.Capsule, oldBody.Description.Pose, true, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _staticHandlerToBody[handler] = body; } else { var handler = CreateStatic(oldBody.Box, oldBody.Description.Pose, false, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Box = oldBody.Box; _staticHandlerToBody[handler] = body; } } } // delete not existing dynamic objects var newDynamicCount = _dynamicIds.Count; var idsToDel = stackalloc uint[_dynamicIds.Count]; int delIndex = 0; for (int i = 0; i &lt; newDynamicCount; i++) { var newId = _dynamicIds[i]; if (!previous._dynamicIds.Contains(newId)) { idsToDel[delIndex] = newId; delIndex++; } } for (int i = 0; i &lt; delIndex; i++) { var id = idsToDel[i]; var handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } // add created dynamic objects var oldDynamicCount = previous._dynamicIds.Count; for (int i = 0; i &lt; oldDynamicCount; i++) { var oldId = previous._dynamicIds[i]; if (!_dynamicIds.Contains(oldId)) { var oldHandler = previous._dynamicIdToHandler[oldId]; var oldBody = previous._dynamicHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateDynamic(oldBody.Capsule, oldBody.BodyReference.Pose, true, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _dynamicHandlerToBody[handler] = body; } else { var handler = CreateDynamic(oldBody.Box, oldBody.BodyReference.Pose, false, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Box = oldBody.Box; _dynamicHandlerToBody[handler] = body; } } } } public void Update() { _simulation.Timestep(GameState.TickDurationSec); } public void UpdateBody(uint id, Vector3 position, float angle) { if (_staticIdToHandler.TryGetValue(id, out var handler)) { _simulation.Statics.GetDescription(handler, out var staticDescription); staticDescription.Pose.Position = position; staticDescription.Pose.Orientation = Quaternion.CreateFromAxisAngle(new Vector3(0, 1, 0), angle); _simulation.Statics.ApplyDescription(handler, staticDescription); } else if(_dynamicIdToHandler.TryGetValue(id, out handler)) { BodyReference reference = new BodyReference(handler, _simulation.Bodies); reference.Pose.Position = position; reference.Pose.Orientation = Quaternion.CreateFromAxisAngle(new Vector3(0, 1, 0), angle); } } public void Dispose() { _simulation.Clear(); } } public void Dispose() { _bufferPool.Clear(); } } }</span></span></code> </pre> <br></div></div><br>  Zus√§tzlich zur Implementierung des Verlaufs auf dem Server mussten wir auch den Verlauf der Physik auf dem Client implementieren.  Unser Unity-Client verf√ºgt √ºber einen Server-Emulationsmodus (wir nennen ihn lokale Simulation), in dem der Servercode mit dem Client ausgef√ºhrt wird.  Wir verwenden diesen Modus f√ºr das Rapid Prototyping von Spielfunktionen. <br><br>  Wie Bepu hat PhysX keine Unterst√ºtzung f√ºr die Historie.  Hier haben wir dieselbe Idee angewendet, bei der f√ºr jeden Tick im Verlauf mehrere physikalische Simulationen wie auf dem Server verwendet wurden.  Bei der Arbeit mit physischen Engines legt Unity jedoch seine eigenen Besonderheiten fest.  Es ist jedoch zu beachten, dass unser Projekt auf Unity 2018.4 (LTS) entwickelt wurde und einige APIs in neueren Versionen m√∂glicherweise ge√§ndert werden, sodass es keine Probleme wie unsere geben wird. <br><br>  Das Problem bestand darin, dass in Unity keine separate physikalische Simulation (oder in der PhysX-Terminologie eine Szene) erstellt werden konnte. Daher haben wir jeden Tick in der Geschichte der Physik in Unity als separate Szene implementiert. <br><br>  √úber solche Szenen wurde eine Wrapper-Klasse geschrieben - UnityPhysicsHistorySlice: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnityPhysicsHistorySlice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SphereCastDelegate sphereCastDelegate, OverlapSphereNonAlloc overlapSphere, CapsuleCastDelegate capsuleCast, OverlapCapsuleNonAlloc overlapCapsule, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _scene = SceneManager.CreateScene(name, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreateSceneParameters() { localPhysicsMode = LocalPhysicsMode.Physics3D }); _physicsScene = _scene.GetPhysicsScene(); _sphereCast = sphereCastDelegate; _capsuleCast = capsuleCast; _overlapSphere = overlapSphere; _overlapCapsule = overlapCapsule; _boxPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PhysicsSceneObjectsPool&lt;BoxCollider&gt;(_scene, <span class="hljs-string"><span class="hljs-string">"box"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); _capsulePool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PhysicsSceneObjectsPool&lt;UnityEngine.CapsuleCollider&gt;(_scene, <span class="hljs-string"><span class="hljs-string">"sphere"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Das zweite Problem von Unity ist, dass alle Arbeiten mit Physik √ºber die statische Klasse Physik ausgef√ºhrt werden, deren API es Ihnen nicht erm√∂glicht, Rakecasts und Sweepcasts in einer bestimmten Szene durchzuf√ºhren.  Diese API funktioniert nur mit einer aktiven Szene.  Die PhysX-Engine selbst erm√∂glicht es Ihnen jedoch, mit mehreren Szenen gleichzeitig zu arbeiten. Sie m√ºssen nur die richtigen Methoden aufrufen.  Gl√ºcklicherweise versteckte Unity solche Methoden hinter der Physics.cs-Klassenschnittstelle. Alles, was √ºbrig blieb, war der Zugriff darauf.  Wir haben es so gemacht: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs">MethodInfo raycastMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"Internal_SphereCast"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sphereCast = (SphereCastDelegate) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(SphereCastDelegate), raycastMethod); MethodInfo overlapSphereMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"OverlapSphereNonAlloc_Internal"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> overlapSphere = (OverlapSphereNonAlloc) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(OverlapSphereNonAlloc), overlapSphereMethod); MethodInfo capsuleCastMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"Internal_CapsuleCast"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleCast = (CapsuleCastDelegate) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CapsuleCastDelegate), capsuleCastMethod); MethodInfo overlapCapsuleMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"OverlapCapsuleNonAlloc_Internal"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> overlapCapsule = (OverlapCapsuleNonAlloc) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(OverlapCapsuleNonAlloc), overlapCapsuleMethod);</code> </pre> <br></div></div><br>  Ansonsten unterschied sich der Code zum Implementieren von UnityPhysicsHistorySlice nicht wesentlich von dem in BepuSimulationSlice. <br><br>  Somit haben wir zwei Implementierungen der Spielphysik: auf dem Client und auf dem Server. <br><br>  Der n√§chste Schritt ist das Testen. <br><br>  Einer der wichtigsten Indikatoren f√ºr die ‚ÄûGesundheit‚Äú unserer Kunden ist der Parameter f√ºr die Anzahl der Fehlvorhersagen beim Server.  Vor dem Umstieg auf andere physische Engines variierte dieser Indikator innerhalb von 1-2% - das hei√üt, w√§hrend eines Kampfes von 9000 Ticks (oder 5 Minuten) wurden 90-180 Simulations-Ticks verwechselt.  Wir haben diese Ergebnisse √ºber mehrere Releases des Spiels in der Soft Lounge erhalten.  Nachdem wir auf verschiedene Engines umgestellt hatten, erwarteten wir ein starkes Wachstum dieses Indikators - vielleicht sogar mehrmals - schlie√ülich f√ºhrten wir auf Client und Server unterschiedlichen Code aus, und es schien logisch, dass sich die Fehler in den Berechnungen durch verschiedene Algorithmen schnell ansammeln w√ºrden.  In der Praxis stellte sich heraus, dass der Diskrepanzparameter nur um 0,2-0,5% wuchs und durchschnittlich 2-2,5% pro Gefecht betrug, was f√ºr uns v√∂llig angemessen war. <br><br>  Die meisten von uns untersuchten Engines und Technologien verwendeten auf Client und Server denselben Code.  Unsere Hypothese mit der M√∂glichkeit der Verwendung unterschiedlicher physikalischer Motoren wurde jedoch best√§tigt.  Der Hauptgrund, warum die Diskrepanzrate so leicht angestiegen ist, war, dass wir die Bewegung von K√∂rpern im Weltraum und Kollisionen mit einem unserer ECS-Systeme berechnen.  Dieser Code ist sowohl auf dem Client als auch auf dem Server identisch.  Bei der physischen Maschine brauchten wir eine schnelle Berechnung von Rakecasts und Sweepcasts, und die Ergebnisse dieser Operationen in der Praxis unterschieden sich f√ºr unsere beiden Maschinen nicht wesentlich. <br><br><h2>  Was zu lesen </h2><br>  Abschlie√üend, wie √ºblich, hier ein paar verwandte Links: <br><br><ul><li>  <a href="https://habr.com/ru/company/pixonic/blog/481880/">Physik f√ºr einen mobilen PvP-Shooter, Teil 1</a> ; </li><li>  <a href="https://habr.com/ru/company/pixonic/blog/415959/">Netzwerkcode f√ºr einen mobilen PvP-Shooter</a> ; </li><li>  <a href="https://gafferongames.com/">Glen Fiedlers Blog √ºber das Schreiben von Netzwerkcode in Spielen</a> ; </li><li>  <a href="https://www.gdcvault.com/play/1026322/Back-to-the-Future-Working">Deterministische Simulation und Netzwerkcode in For Honor</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485150/">https://habr.com/ru/post/de485150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485136/index.html">Istio Tracing and Monitoring: Microservices und das Unsicherheitsprinzip</a></li>
<li><a href="../de485138/index.html">Anwendungslokalisierung: Wie wir Freunde f√ºr die √úbersetzung und Entwicklung gewonnen haben</a></li>
<li><a href="../de485144/index.html">Wie ich eine kaputte Basis reparierte und was daraus wurde</a></li>
<li><a href="../de485146/index.html">IT-Geh√§lter im zweiten Halbjahr 2019: laut Habr-Karriererechner</a></li>
<li><a href="../de485148/index.html">Dieser entz√ºckende Unicode</a></li>
<li><a href="../de485152/index.html">Fr√ºhlingspraktikum f√ºr mobile Entwickler bei Redmadrobot</a></li>
<li><a href="../de485154/index.html">Wie man aus einem Entwickler einen Markenfreak macht: ein Motivationssystem f√ºr Programmierer</a></li>
<li><a href="../de485156/index.html">Wie man ein h√§uslicher Crowdfunder ist (Teil 1)</a></li>
<li><a href="../de485158/index.html">Nikolay Vavilov. Der Mann, der die ganze Welt ern√§hren wollte und in einer Gef√§ngniszelle verhungerte</a></li>
<li><a href="../de485160/index.html">Was ist ich in ACID oder einer anderen Perspektive</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>