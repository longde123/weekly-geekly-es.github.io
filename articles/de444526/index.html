<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßê üïí ‚úâÔ∏è DOTS-Stapel: C ++ & C # üßëüèº ‚õµÔ∏è üëÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine kurze Einf√ºhrung in unseren neuen datenorientierten Technologie-Stack ( DOTS ). Wir werden einige Erkenntnisse teilen, um Ihnen zu helfe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DOTS-Stapel: C ++ & C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/444526/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/qr/be/mb/qrbembbqugflv8bnrgozc2uxcpe.png" alt="Bild"></a> <br><br>  Dies ist eine kurze Einf√ºhrung in unseren neuen datenorientierten Technologie-Stack ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DOTS</a> ).  Wir werden einige Erkenntnisse teilen, um Ihnen zu helfen, zu verstehen, wie und warum Unity heute so geworden ist, und Ihnen auch zu sagen, in welche Richtung wir uns entwickeln wollen.  In Zukunft planen wir, neue Artikel im DOTS-Blog im Unity-Blog zu ver√∂ffentlichen. <br><a name="habracut"></a><br>  Sprechen wir √ºber C ++.  Dies ist die Sprache, in der die moderne Einheit geschrieben ist. <br>  Eines der komplexesten Probleme, mit denen sich ein Spieleentwickler auf die eine oder andere Weise befassen muss, ist Folgendes: Der Programmierer muss eine ausf√ºhrbare Datei mit Anweisungen bereitstellen, die f√ºr den Zielprozessor klar sind, und wenn der Prozessor diese Anweisungen ausf√ºhrt, sollte das Spiel gestartet werden. <br><br>  In dem Teil des Codes, der leistungsabh√§ngig ist, wissen wir im Voraus, wie die endg√ºltigen Anweisungen lauten sollten.  Wir brauchen nur einen einfachen Weg, der es uns erm√∂glicht, unsere Logik konsistent zu beschreiben und dann zu √ºberpr√ºfen und sicherzustellen, dass die Anweisungen, die wir ben√∂tigen, generiert werden. <br><br>  Wir glauben, dass die C ++ - Sprache f√ºr diese Aufgabe nicht allzu gut ist.  Ich m√∂chte beispielsweise, dass meine Schleife vektorisiert wird, aber es kann eine Million Gr√ºnde geben, warum der Compiler sie nicht vektorisieren kann.  Entweder wird es heute vektorisiert, und morgen nicht, aufgrund einer scheinbar geringf√ºgigen Ver√§nderung.  Es ist schwer sicherzustellen, dass alle meine C / C ++ - Compiler meinen Code sogar vektorisieren. <br><br>  Wir haben uns entschlossen, eine eigene ‚Äûrecht bequeme Methode zum Generieren von Maschinencode‚Äú zu entwickeln, die alle unsere W√ºnsche erf√ºllt.  Es w√§re m√∂glich, viel Zeit zu investieren, um die gesamte Sequenz des C ++ - Entwurfs leicht in die von uns ben√∂tigte Richtung zu biegen, aber wir entschieden, dass es viel vern√ºnftiger w√§re, unsere St√§rke in die Entwicklung einer Werkzeugkette zu investieren, die alle Entwurfsprobleme, mit denen wir konfrontiert sind, vollst√§ndig l√∂st.  Wir w√ºrden es unter Ber√ºcksichtigung genau der Aufgaben entwickeln, die der Spieleentwickler l√∂sen muss. <br><br>  Welche Faktoren priorisieren wir? <br><br><ul><li>  Leistung = richtig.  Ich sollte sagen k√∂nnen: ‚ÄûWenn diese Schleife aus irgendeinem Grund nicht vektorisiert ist, muss es sich um einen Compilerfehler handeln und nicht um eine Situation aus der Kategorie‚Äû Oh, der Code begann nur achtmal langsamer zu arbeiten, gibt aber immer noch wahre Werte, Gesch√§ft etwas! " </li><li>  Plattform√ºbergreifend.  Der Eingabecode, den ich schreibe, sollte unabh√§ngig von der Zielplattform genau gleich bleiben - sei es iOS oder Xbox. </li><li>  Wir sollten eine ordentliche Iterationsschleife haben, in der ich den f√ºr jede Architektur generierten Maschinencode leicht sehen kann, wenn ich meinen Quellcode √§ndere.  Der Maschinencode ‚ÄûViewer‚Äú sollte eine gro√üe Hilfe bei der Schulung / Erkl√§rung sein, wenn Sie verstehen m√ºssen, was all diese Maschinenanweisungen bewirken. </li><li> Sicherheit  In der Regel legen Spieleentwickler in ihrer Priorit√§tenliste keinen hohen Stellenwert f√ºr die Sicherheit ein, aber wir glauben, dass eines der coolsten Merkmale von Unity darin besteht, dass es wirklich sehr schwierig ist, das Ged√§chtnis darin zu besch√§digen.  Es sollte einen solchen Modus geben, in dem wir Code ausf√ºhren - und wir beheben eindeutig einen Fehler, durch den ein gro√üer Buchstabe eine Meldung dar√ºber anzeigt, was hier passiert ist: Zum Beispiel habe ich beim Lesen / Schreiben die Grenzen √ºberschritten oder versucht, Null zu dereferenzieren. </li></ul><br>  Nachdem wir herausgefunden haben, was f√ºr uns wichtig ist, fahren wir mit der n√§chsten Frage fort: In welcher Sprache ist es besser, Programme zu schreiben, aus denen dann ein solcher Maschinencode generiert wird?  Angenommen, wir haben folgende Optionen: <br><br><ul><li>  Eigene Sprache </li><li>  Einige Anpassungen / Teilmengen von C oder C ++ </li><li>  Teilmenge von c # </li></ul><br>  Was, C #?  F√ºr unsere inneren Schleifen, deren Leistung besonders kritisch ist?  Ja  C # ist eine ganz nat√ºrliche Wahl, mit der es im Kontext von Unity viele sehr sch√∂ne Dinge gibt: <br><br><ul><li>  Dies ist die Sprache, mit der unsere Benutzer bereits heute arbeiten. </li><li>  Es verf√ºgt √ºber eine hervorragende IDE, sowohl zum Bearbeiten / Refactoring als auch zum Debuggen. </li><li>  Es gibt bereits einen Compiler, der C # in eine Zwischen-IL konvertiert (wir sprechen √ºber den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roslyn-</a> Compiler f√ºr C # von Microsoft), und Sie k√∂nnen ihn einfach verwenden, anstatt Ihren eigenen zu schreiben.  Wir haben umfangreiche Erfahrungen mit der Konvertierung einer Zwischensprache in IL. Daher m√ºssen wir nur die Codegenerierung und Nachbearbeitung eines bestimmten Programms durchf√ºhren. </li><li>  C # hat keine C ++ - Probleme (H√∂lle mit Headern, PIMPL-Mustern, langer Kompilierungszeit) </li></ul><br>  Ich selbst schreibe sehr gerne Code in C #.  Traditionelles C # ist jedoch nicht die beste Sprache in Bezug auf die Leistung.  Das C # -Entwicklungsteam, die Teams, die in den letzten Jahren f√ºr die Standardbibliothek und die Laufzeit verantwortlich waren, haben in diesem Bereich enorme Fortschritte erzielt.  W√§hrend der Arbeit mit C # ist es jedoch unm√∂glich, genau zu steuern, wo sich Ihre Daten im Speicher befinden.  Und genau dieses Problem m√ºssen wir l√∂sen, um die Produktivit√§t zu steigern. <br><br>  Dar√ºber hinaus ist die Standardbibliothek dieser Sprache nach "Objekten auf dem Heap" und "Objekten mit Zeigern auf andere Objekte" organisiert. <br><br>  Gleichzeitig k√∂nnen Sie bei der Arbeit mit einem Codefragment, bei dem die Leistung von entscheidender Bedeutung ist, fast vollst√§ndig auf eine Standardbibliothek verzichten (Abschied von Linq, StringFormatter, List, Dictionary), Auswahloperationen (= keine Klassen, nur Strukturen), Reflektion, Deaktivierung von Garbage Collector und Virtual verbieten ruft auf und f√ºgt einige neue Container hinzu, die verwendet werden d√ºrfen (NativeArray und Firma).  In diesem Fall sehen die √ºbrigen Elemente der C # -Sprache bereits sehr gut aus.  Beispiele finden Sie im Aras-Blog, in dem ein provisorisches Pfad-Tracer-Projekt beschrieben wird. <br><br>  Eine solche Teilmenge hilft uns dabei, alle Aufgaben zu bew√§ltigen, die f√ºr die Arbeit mit hei√üen Zyklen relevant sind.  Da dies eine vollst√§ndige Teilmenge von C # ist, k√∂nnen Sie damit wie mit normalem C # arbeiten.  Beim Versuch, ins Ausland zu gehen, k√∂nnen Fehler auftreten, wir erhalten hervorragende Fehlermeldungen, wir unterst√ºtzen den Debugger und die Kompilierungsgeschwindigkeit ist so hoch, dass Sie sie bei der Arbeit mit C ++ bereits vergessen haben.  Wir bezeichnen diese Teilmenge h√§ufig als High Performance C # oder HPC #. <br><br><h3>  Burst Compiler: Was heute? </h3><br>  Wir haben einen Codegenerator / Compiler namens Burst geschrieben.  Es ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unity</a> Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2018.1</a> und h√∂her als Paket im "Vorschau" -Modus verf√ºgbar.  Es bleibt noch viel Arbeit mit ihm zu tun, aber wir freuen uns heute √ºber ihn. <br><br>  Manchmal schaffen wir es, schneller als in C ++ zu arbeiten, oft - immer noch langsamer als in C ++.  Die zweite Kategorie umfasst Leistungsfehler, die wir unserer √úberzeugung nach bew√§ltigen k√∂nnen. <br><br>  Ein einfacher Leistungsvergleich reicht jedoch nicht aus.  Nicht weniger wichtig ist, was getan werden muss, um eine solche Leistung zu erzielen.  Beispiel: Wir haben den Culling-Code aus unserem aktuellen C ++ - Renderer genommen und nach Burst portiert.  Die Leistung hat sich nicht ge√§ndert, aber in der C ++ - Version mussten wir einen unglaublichen Spagat machen, um unsere C ++ - Compiler zur Vektorisierung zu bewegen.  Die Version mit Burst war etwa viermal kompakter. <br><br>  Ehrlich gesagt, hat die ganze Geschichte mit "Sie sollten Ihren f√ºr die Leistung in C # kritischen Code neu schreiben" auf den ersten Blick niemanden im internen Unity-Team angesprochen.  F√ºr die meisten von uns klang es wie "n√§her an der Hardware!" Bei der Arbeit mit C ++.  Aber jetzt hat sich die Situation ge√§ndert.  Mit C # steuern wir den gesamten Prozess vollst√§ndig vom Kompilieren des Quellcodes bis zum Generieren von Maschinencode. Wenn uns keine Details gefallen, nehmen wir sie einfach und korrigieren sie. <br><br>  Wir werden langsam aber sicher den gesamten leistungskritischen Code von C ++ auf HPC # portieren.  In dieser Sprache ist es einfacher, die von uns ben√∂tigte Leistung zu erzielen, schwieriger, einen Fehler zu schreiben und einfacher zu arbeiten. <br><br>  Hier ist ein Screenshot von Burst Inspector, in dem Sie leicht sehen k√∂nnen, welche Montageanweisungen f√ºr Ihre verschiedenen Hot Loops generiert wurden: <br><br><img src="https://habrastorage.org/webt/sx/ui/ik/sxuiikqzzuyj6y4lhtbv6pbzm0k.png" alt="Bild"><br><br>  Unity hat viele verschiedene Benutzer.  Einige von ihnen k√∂nnen den gesamten Satz von arm64-Anweisungen aus dem Speicher abrufen, w√§hrend andere einfach ohne Begeisterung erstellen, auch ohne einen Doktortitel in Informatik. <br>  Alle Benutzer gewinnen, wenn der Bruchteil der Frame-Zeit, die f√ºr die Ausf√ºhrung von Engine-Code aufgewendet wird, beschleunigt wird (normalerweise 90% +).  Der Anteil der Arbeit mit dem ausf√ºhrbaren Code des Asset Store-Pakets nimmt erheblich zu, da die Autoren des Asset Store-Pakets HPC # √ºbernehmen. <br><br>  Fortgeschrittene Benutzer profitieren auch von der Tatsache, dass sie ihren eigenen Hochleistungscode auf HPC # schreiben k√∂nnen. <br><br><h3>  Punktoptimierung </h3><br>  In C ++ ist es sehr schwierig, den Compiler dazu zu bringen, unterschiedliche Kompromissentscheidungen zur Optimierung des Codes in verschiedenen Teilen Ihres Projekts zu treffen.  Die detaillierteste Optimierung, auf die Sie z√§hlen k√∂nnen, ist eine dateiweise Angabe des Optimierungsgrades. <br><br>  Burst ist so konzipiert, dass Sie die einzige Methode dieses Programms als Eingabe akzeptieren k√∂nnen, n√§mlich: den Einstiegspunkt in die Hot-Loop.  Burst kompiliert diese Funktion sowie alles, was sie aufruft (solche aufgerufenen Elemente m√ºssen garantiert im Voraus bekannt sein: Wir erlauben keine virtuellen Funktionen oder Funktionszeiger). <br><br>  Da Burst nur einen relativ kleinen Teil des Programms ausf√ºhrt, setzen wir die Optimierungsstufe auf 11. Burst bettet fast jede Anrufstelle ein.  Entfernen Sie if-Checks, die sonst nicht gel√∂scht w√ºrden, da wir im eingebetteten Formular umfassendere Informationen zu den Funktionsargumenten erhalten. <br><br><h3>  Wie hilft es, h√§ufige Threading-Probleme zu l√∂sen? </h3><br>  C ++ (sowie C #) helfen Entwicklern nicht besonders beim Schreiben von thread-sicherem Code. <br><br>  Selbst heute, mehr als ein Jahrzehnt nachdem ein typischer Spielprozessor mit zwei oder mehr Kernen ausgestattet wurde, ist es sehr schwierig, Programme zu schreiben, die mehrere Kerne effizient nutzen. <br><br>  Datenrennen, Nichtdeterminismus und Deadlocks sind die Hauptherausforderungen, die das Schreiben von Multithread-Code so schwierig machen.  In diesem Zusammenhang ben√∂tigen wir Funktionen aus der Kategorie "Stellen Sie sicher, dass diese Funktion und alles, was sie aufruft, niemals den globalen Status lesen oder schreiben".  Wir m√∂chten, dass alle Verst√∂√üe gegen diese Regel zu Compilerfehlern f√ºhren und nicht "Regeln bleiben, an die sich hoffentlich alle Programmierer halten".  Burst l√∂st einen Kompilierungsfehler aus. <br><br>  Wir empfehlen Unity-Benutzern dringend (und wir behalten den gleichen Wert in ihrem Kreis), Code zu schreiben, damit alle darin geplanten Datentransformationen in Aufgaben unterteilt werden.  Jede Aufgabe ist ‚Äûfunktional‚Äú und als Nebeneffekt kostenlos.  Es gibt explizit schreibgesch√ºtzte Puffer und Lese- / Schreibpuffer an, mit denen es arbeiten muss.  Jeder Versuch, auf andere Daten zuzugreifen, f√ºhrt zu einem Kompilierungsfehler. <br>  Der Taskplaner stellt sicher, dass w√§hrend der Ausf√ºhrung Ihrer Aufgabe niemand in Ihren schreibgesch√ºtzten Puffer schreibt.  Und wir garantieren, dass f√ºr die Dauer der Aufgabe niemand aus Ihrem Puffer liest, der zum Lesen und Schreiben bestimmt ist. <br><br>  Wenn Sie eine Aufgabe zuweisen, die gegen diese Regeln verst√∂√üt, wird ein Kompilierungsfehler angezeigt.  Nicht nur bei einem so ungl√ºcklichen Ereignis wie den Bedingungen des Rennens.  In der Fehlermeldung wird erl√§utert, dass Sie versuchen, eine Aufgabe zuzuweisen, die aus Puffer A gelesen werden soll. Zuvor haben Sie jedoch eine Aufgabe zugewiesen, die in A geschrieben wird. Wenn Sie dies wirklich tun m√∂chten, muss die vorherige Aufgabe als Abh√§ngigkeit angegeben werden . <br><br>  Wir glauben, dass ein solcher Sicherheitsmechanismus dazu beitr√§gt, viele Fehler zu erkennen, bevor sie behoben werden, und daher die effiziente Verwendung aller Kerne gew√§hrleistet.  Es wird unm√∂glich, Rennbedingungen oder Deadlocks zu provozieren.  Die Ergebnisse sind garantiert deterministisch, unabh√§ngig davon, wie viele Threads Sie haben oder wie oft ein Thread aufgrund eines anderen Prozesses unterbrochen wird. <br><br><h3>  Beherrsche den ganzen Stapel </h3><br>  Wenn wir all diesen Komponenten auf den Grund gehen k√∂nnen, k√∂nnen wir auch sicherstellen, dass sie sich gegenseitig bewusst sind.  Ein h√§ufiger Grund f√ºr einen Vektorisierungsfehler ist beispielsweise folgender: Der Compiler kann nicht garantieren, dass zwei Zeiger nicht auf denselben Speicherpunkt zeigen (Aliasing).  Wir wissen, dass sich zwei NativeArray auf keinen Fall so √ºberschneiden werden, da sie eine Sammlungsbibliothek geschrieben haben, und wir k√∂nnen dieses Wissen in Burst verwenden, sodass wir uns nicht weigern, nur aus Angst zu optimieren, dass zwei Zeiger auf einen gerichtet werden k√∂nnten das gleiche St√ºck Erinnerung. <br><br>  Ebenso haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unity.Mathematics-</a> Mathematikbibliothek geschrieben.  Burst sie ist "gr√ºndlich" bekannt Burst (in der Zukunft) kann in F√§llen wie math.sin () darauf hinweisen, dass die Optimierung nicht mehr m√∂glich ist.  Da f√ºr Burst math.sin () nicht nur eine gew√∂hnliche C # -Methode ist, die kompiliert werden muss, sondern auch die trigonometrischen Eigenschaften von sin (), wird sin (x) == x f√ºr kleine x-Werte verstanden (die Burst unabh√§ngig beweisen kann ), wird verstehen, dass es durch die Erweiterung in der Taylor-Reihe ersetzt werden kann, was teilweise die Genauigkeit beeintr√§chtigt.  In Zukunft plant Burst auch die Implementierung eines plattform√ºbergreifenden und designbezogenen Determinismus mit einem Gleitkomma - wir glauben, dass solche Ziele erreichbar sind. <br><br><h3>  Die Unterschiede zwischen dem Code der Spiel-Engine und dem Code des Spiels sind verschwommen </h3><br>  Wenn wir Unity-Laufzeitcode in HPC # schreiben, werden die Spiel-Engine und das Spiel als solche alle in derselben Sprache geschrieben.  Wir k√∂nnen die Laufzeitsysteme, die wir in HPC # konvertiert haben, als Quellcode verteilen.  Jeder kann von ihnen lernen, sie verbessern, sie f√ºr sich selbst anpassen.  Wir werden ein Spielfeld auf einem bestimmten Niveau haben, und nichts wird unsere Benutzer daran hindern, ein besseres Partikelsystem, eine bessere Spielphysik oder einen besseren Renderer zu schreiben als wir.  Indem wir unsere internen Entwicklungsprozesse n√§her an die Benutzerentwicklungsprozesse heranf√ºhren, k√∂nnen wir uns auch in den Schuhen des Benutzers besser f√ºhlen. Daher werden wir alle Anstrengungen unternehmen, um einen einzigen Workflow zu erstellen, anstatt zwei verschiedene. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444526/">https://habr.com/ru/post/de444526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444516/index.html">Wolfenstein 3D: Raytracing mit WebGL1</a></li>
<li><a href="../de444518/index.html">Auf dem Weg zu einer grundlegenden Theorie des Bewusstseins</a></li>
<li><a href="../de444520/index.html">2. Check Point Erste Schritte R80.20. L√∂sungsarchitektur</a></li>
<li><a href="../de444522/index.html">Die Apokalypse wird abgebrochen</a></li>
<li><a href="../de444524/index.html">Lambdas: von C ++ 11 bis C ++ 20. Teil 1</a></li>
<li><a href="../de444528/index.html">Situation: Japan kann das Herunterladen von Inhalten aus dem Netzwerk einschr√§nken - wir verstehen und diskutieren</a></li>
<li><a href="../de444530/index.html">Die Zukunft der Abh√§ngigkeitsinjektion in Android</a></li>
<li><a href="../de444534/index.html">Schwachstellen-Scan und sichere Entwicklung. Teil 1</a></li>
<li><a href="../de444536/index.html">MVCC-2. Ebenen, Dateien, Seiten</a></li>
<li><a href="../de444540/index.html">Intel ist bereit, mit der Produktion von MRAM-Speicher zu beginnen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>