<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌝 🙆🏿 🕦 Medición de tiempo con precisión de nanosegundos 🙏 💼 📅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace un par de meses llegó un momento histórico para mí. Las herramientas estándar del sistema operativo para medir el tiempo han dejado de ser sufici...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Medición de tiempo con precisión de nanosegundos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425237/"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="imagen"><br><br>  Hace un par de meses llegó un momento histórico para mí.  Las herramientas estándar del sistema operativo para medir el tiempo han dejado de ser suficientes para mí.  Tomó tiempo medir con precisión de nanosegundos y con sobrecarga de nanosegundos. <br><br>  Decidí escribir una biblioteca que resolviera este problema.  A primera vista, parecía que no había nada especial que hacer.  Pero después de un examen más detallado, como siempre, resultó que había muchos problemas interesantes que debían ser tratados.  En este artículo, hablaré sobre los problemas y cómo se resolvieron. <br><br>  Como puede medir muchos tipos diferentes de tiempo en una computadora, aclararé de inmediato que aquí hablaremos del "tiempo por cronómetro".  O la hora del reloj de pared.  Es tiempo real, tiempo transcurrido, etc.  Es decir, un tiempo "humano" simple, que detectamos al comienzo de la tarea y lo detenemos al final. <br><a name="habracut"></a><br><h3>  Microsegundo: casi para siempre </h3><br>  Los desarrolladores de sistemas de alto rendimiento en los últimos años se han acostumbrado a la escala de tiempo de microsegundos.  En microsegundos, puede leer datos de una unidad NVMe.  En microsegundos, los datos se pueden enviar a través de la red.  No para todos, por supuesto, sino para InifiniBand-network, fácilmente. <br><br>  Al mismo tiempo, el microsegundo también tenía una estructura.  Una pila de E / S completa consta de varios componentes de software y hardware.  Los retrasos introducidos por algunos de ellos se encuentran en el nivel sub-microsegundo. <br><br>  Para medir retrasos de esta magnitud, la precisión de microsegundos ya no es suficiente.  Sin embargo, no solo es importante la precisión, sino también la sobrecarga del tiempo de medición.  La llamada al sistema Linux clock_gettime () devuelve el tiempo con precisión de nanosegundos.  En una máquina que está al alcance de mi mano (CPU Intel® Xeon® E5-2630 v2 @ 2.60GHz), esta llamada se completa en aproximadamente 120 ns.  Muy buena figura.  Además, clock_gettime () funciona de manera bastante predecible.  Esto le permite tener en cuenta los gastos generales de su llamada y realmente tomar medidas con una precisión del orden de decenas de nanosegundos.  Sin embargo, ahora prestemos atención a esto.  Para medir el intervalo de tiempo, debe hacer dos llamadas de este tipo: al principio y al final.  Es decir  gastar 240 ns.  Si se miden intervalos de tiempo densamente espaciados del orden de 1-10 μs, entonces, en algunos casos, el proceso de medición en sí mismo distorsionará significativamente el proceso observado. <br><br>  Comencé esta sección con cómo la pila IO se ha acelerado en los últimos años.  Esto es nuevo, pero lejos de ser la única razón para querer medir el tiempo de forma rápida y precisa.  Tal necesidad siempre ha sido.  Por ejemplo, siempre había un código que quería acelerar por al menos 1 ciclo de reloj del microprocesador.  U otro ejemplo, del artículo original sobre la sensacional vulnerabilidad Spectre: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="imagen"><br><br>  Aquí, las líneas 72-74 miden el tiempo de ejecución de una sola operación de acceso a memoria.  Es cierto que Specter no está interesado en nanosegundos.  El tiempo se puede medir en "loros".  Volveremos a los loros y segundos. <br><br><h3>  Contador de sello de tiempo </h3><br>  La clave para una medición de tiempo rápida y precisa es un contador de microprocesador especial.  El valor de este contador generalmente se almacena en un registro separado y generalmente es accesible, pero no siempre, desde el espacio del usuario.  En diferentes arquitecturas, el contador se llama de manera diferente: <br><br><ol><li>  Contador de sello de tiempo x86 </li><li>  registro de base de tiempo en PowerPC </li><li>  contador de tiempo de intervalo en Itanium </li><li>  etc. </li></ol><br>  A continuación, siempre usaré el nombre "contador de marca de tiempo" o TSC, aunque de hecho tendré en cuenta cualquier contador, independientemente de la arquitectura. <br><br>  Por lo general, es posible leer el valor de TSC, pero nuevamente no siempre, con una sola instrucción.  Aquí hay un ejemplo para x86.  Estrictamente hablando, esta no es una instrucción pura de ensamblador, sino el ensamblador en línea de GNU: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  La instrucción rdtsc coloca dos mitades de 32 bits del registro TSC en los registros eax y edx.  De estos, puede "pegar" un solo valor de 64 bits. <br><br>  Una vez más, noto: esta (y similares) instrucciones en la mayoría de los casos se pueden llamar directamente desde el espacio del usuario.  No hay llamadas del sistema.  Gastos generales mínimos. <br><br>  ¿Qué debe hacerse ahora para medir el tiempo? <br><br><ol><li>  Ejecute una de estas instrucciones al comienzo del intervalo de tiempo que nos interese.  Recordar el valor del contador </li><li>  Ejecute una de esas instrucciones al final.  Creemos que el valor del contador desde la primera instrucción hasta la segunda aumentará.  De lo contrario, ¿por qué es necesario?  Recuerda el segundo valor </li><li>  Consideramos la diferencia entre los dos valores almacenados.  Este es nuestro tiempo </li></ol><br>  Parece simple, pero ... <br><br>  El tiempo medido por el procedimiento descrito se expresa en "loros".  No es en segundos.  Pero a veces los loros son exactamente lo que necesitas.  Hay situaciones en las que no son importantes los valores absolutos de los intervalos de tiempo, sino cómo se relacionan entre sí los diferentes intervalos.  El ejemplo anterior de Spectre demuestra exactamente esta situación.  La duración de cada acceso individual a la memoria no importa.  Solo es importante que las llamadas a algunas direcciones se ejecuten mucho más rápido que a otras (dependiendo de si los datos están almacenados en la memoria caché o en la memoria principal). <br><br>  Pero, ¿qué pasa si no se necesitan loros, sino segundos / microsegundos / nanosegundos, etc.?  Aquí se pueden distinguir dos casos fundamentalmente diferentes: <br><br><ol><li>  Se necesitan nanosegundos, pero entonces.  Es decir, está permitido hacer primero todas las mediciones necesarias en loros y almacenarlas en algún lugar para su posterior procesamiento (por ejemplo, en la memoria).  Y solo después de que se completen las mediciones, convierta lentamente los loros recolectados en segundos </li><li>  Se necesitan nanosegundos "sobre la marcha".  Por ejemplo, su proceso de medición tiene algún tipo de "consumidor" que usted no controla y que espera tiempo en el formato "humano" </li></ol><br>  El primer caso es simple, el segundo: requiere ingenio.  La conversión debe ser lo más efectiva posible.  Si consume muchos recursos, puede distorsionar en gran medida el proceso de medición.  Hablaremos sobre la conversión efectiva a continuación.  Aquí hasta ahora hemos identificado este problema y pasamos a otro. <br><br>  Los contadores de sello de tiempo no son tan simples como nos gustaría.  En algunas arquitecturas: <br><br><ol><li>  no se garantiza que el TSC se actualice a alta frecuencia.  Si el TSC se actualiza, por ejemplo, una vez cada microsegundo, entonces no será posible arreglar nanosegundos con él. </li><li>  la frecuencia con la que se actualiza el TSC puede variar con el tiempo </li><li>  en diferentes CPU presentes en el sistema, los TSC se pueden actualizar a diferentes frecuencias </li><li>  puede haber un cambio entre TSC marcando en diferentes CPU </li></ol><br>  Aquí hay un ejemplo que ilustra el último problema.  Supongamos que tenemos un sistema con dos CPU: CPU1 y CPU2.  Suponga que el TSC en la primera CPU está detrás de la segunda por el número de tics, que es equivalente a 5 segundos.  Supongamos además que se inicia una secuencia en el sistema que mide el tiempo de los cálculos, lo que él mismo hace.  Para hacer esto, la secuencia primero lee el valor de TSC, luego realiza el cálculo y luego lee el segundo valor de TSC.  Si durante toda su vida un hilo permanece en una sola CPU, en cualquiera, entonces no hay problemas.  Pero, ¿qué pasa si el subproceso comenzó en la CPU1, midió el primer valor de TSC allí y luego, en el medio de los cálculos, el sistema operativo lo movió a la CPU2, donde leyó el segundo valor de TSC?  En este caso, los cálculos parecerán 5 segundos más largos de lo que realmente son. <br><br>  Debido a los problemas enumerados anteriormente, TSC no puede servir como una fuente confiable de tiempo en algunos sistemas.  Sin embargo, en otros sistemas que "padecen" los mismos problemas, aún se puede usar TSC.  Esto es posible gracias a características arquitectónicas especiales: <br><br><ol><li>  el equipo puede generar una interrupción especial cada vez que cambia la frecuencia con la que se actualiza el TSC.  Al mismo tiempo, el equipo también brinda la oportunidad de averiguar la frecuencia actual.  Alternativamente, la frecuencia de actualización del TSC se puede colocar bajo el control del sistema operativo (consulte “Revisión ISA Power 2.0 versión B, Libro II, Capítulo 5”) </li><li>  el hardware, junto con el valor TSC, también puede proporcionar la ID de la CPU en la que se lee este valor (consulte las instrucciones Intel RDTSCP, "Manual del desarrollador de software de las arquitecturas Intel 64 e IA-32", Volumen 2) </li><li>  en algunos sistemas, puede ajustar mediante programación el valor de TSC para cada CPU (consulte las instrucciones de Intel WRMSR y registre IA32_TIME_STAMP_COUNTER, “Manual del desarrollador de software de las arquitecturas Intel 64 e IA-32”, Volumen 3) </li></ol><br>  En general, el tema de cómo se implementan los medidores de tiempo en diferentes arquitecturas es fascinante y extenso.  Si tienes tiempo e interés, te recomiendo bucear.  Entre otras cosas, aprenderá, por ejemplo, que algunos sistemas le permiten determinar mediante programación si TSC puede servir como una fuente confiable de tiempo. <br><br>  Por lo tanto, hay muchas implementaciones arquitectónicas de TSC, cada una con sus propias características.  Pero es interesante que se haya establecido una tendencia general en todo este zoológico.  <b>El hardware y los sistemas operativos modernos se esfuerzan por garantizar que</b> : <br><br><ol><li>  El TSC funciona a la misma frecuencia en cada CPU del sistema </li><li>  esta frecuencia no cambia en el tiempo </li><li>  no hay cambio entre TSC marcando en diferentes CPU </li></ol><br>  Al diseñar mi biblioteca, decidí proceder desde esta premisa, y no desde la vinagreta de las implementaciones de hardware. <br><br><h3>  La biblioteca </h3><br>  No comencé a instalar chips de hardware de diferentes arquitecturas.  En cambio, decidí que mi biblioteca estaría orientada a las tendencias.  Ella tiene un enfoque puramente empírico: <br><br><ol><li>  le permite verificar experimentalmente la confiabilidad de TSC como fuente de tiempo </li><li>  También le permite calcular experimentalmente los parámetros necesarios para convertir rápidamente las garrapatas a nanosegundos </li><li>  naturalmente, la biblioteca proporciona interfaces convenientes para leer TSC y convertir ticks a nanosegundos "sobre la marcha" </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El código de la biblioteca está disponible aquí.</a>  Se compilará y ejecutará solo en Linux. <br><br>  En el código, puede ver los detalles de la implementación de todos los métodos, que se discutirán más adelante. <br><br><h3>  Evaluación de confiabilidad de TSC </h3><br>  La biblioteca proporciona una interfaz que devuelve dos clasificaciones: <br><br><ol><li>  desplazamiento máximo entre contadores pertenecientes a diferentes CPU.  Solo se consideran las CPU disponibles para el proceso.  Por ejemplo, si un proceso tiene tres CPU disponibles, y al mismo tiempo el TSC en estas CPU es 50, 150, 20, entonces el cambio máximo será 150-20 = 130.  Naturalmente, la biblioteca no podrá obtener un cambio real máximo experimentalmente, pero dará una estimación en la que se ajustará este cambio.  ¿Qué hacer a continuación con la evaluación?  ¿Cómo usarlo?  Esto ya resuelve el código del cliente.  Pero el significado es aproximadamente el siguiente.  El desplazamiento máximo es el valor máximo por el cual la dimensión que crea el código del cliente puede distorsionarse.  Supongamos que, en nuestro ejemplo con tres CPU, el código del cliente comenzó a medir el tiempo en la CPU3 (donde TSC tenía 20) y terminó en la CPU2 (donde TSC tenía 150).  Resulta que 130 garrapatas adicionales se arrastrarán en el intervalo medido.  Y nunca más.  La diferencia entre CPU1 y CPU2 sería de solo 100 ticks.  Teniendo una estimación de 130 ticks (de hecho, será mucho más conservador), el cliente puede decidir si tal valor de distorsión le conviene o no </li><li>  ¿Aumentan los valores de TSC medidos secuencialmente en la misma CPU o en diferentes CPU?  Aquí está la idea.  Digamos que tenemos varias CPU.  Supongamos que su reloj está sincronizado y marcando la misma frecuencia.  Luego, si primero mide el tiempo en una CPU y luego lo mide nuevamente, ya en cualquiera de las CPU disponibles, entonces el segundo dígito debe ser mayor que el primero. <br><br>  Llamaré a esta estimación por debajo de la estimación de monotonicidad TSC <br></li></ol><br>  Ahora veamos cómo podemos obtener la primera estimación: <br><br><ol><li>  uno de los procesadores disponibles para el proceso se declara "básico" </li><li>  entonces se ordenan todas las otras CPU, y para cada una de ellas se calcula el cambio: <code>TSC___CPU – TSC___CPU</code> .  Esto se hace de la siguiente manera: <br><ul><li>  a) se toman tres valores medidos secuencialmente (¡uno tras otro!): <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Aquí, actual indica que el valor se midió en la CPU actual y se basa en la base </li><li>  b) el cambio <code>TSC___CPU – TSC___CPU</code> debe estar en el intervalo <code>[TSC_current – TSC_base_2, TSC_current – TSC_base_1]</code> .  Esto se da por supuesto que los TSC están funcionando a la misma frecuencia en ambas CPU. </li><li>  c) los pasos a) -b) se repiten varias veces.  Se calcula la intersección de todos los intervalos obtenidos en el paso b).  El intervalo resultante se toma como la estimación del cambio <code>TSC___CPU – TSC___CPU</code> </li></ul><br></li><li>  Después de obtener una estimación de cambio para cada CPU en relación con la base, es fácil obtener una estimación del cambio máximo entre todas las CPU disponibles: <br><ul><li>  a) se calcula el intervalo mínimo, que incluye todos los intervalos resultantes obtenidos en el paso 2 </li><li>  b) el ancho de este intervalo se toma como la estimación del cambio máximo entre TSC marcando en diferentes CPU </li></ul><br></li></ol><br>  Para evaluar la monotonía en la biblioteca, se implementa el siguiente algoritmo: <br><br><ol><li>  Digamos que un proceso tiene N CPU disponible </li><li>  Medición de TSC en CPU1 </li><li>  Medición de TSC en CPU2 </li><li>  ... </li><li>  Medición de TSC en CPUN </li><li>  Mida TSC nuevamente en CPU1 </li><li>  Verificamos que los valores medidos aumentan monotónicamente del primero al último </li></ol><br>  Aquí es importante que el primer y el último valor se midan en la misma CPU.  Y aquí está el por qué.  Digamos que tenemos 3 CPU.  Suponga que el TSC en la CPU2 se desplaza por +100 ticks en relación con el TSC en la CPU1.  Supongamos también que el TSC en la CPU3 se desplaza por +100 ticks en relación con el TSC en la CPU2.  Considere la siguiente cadena de eventos: <br><br><ul><li>  Lea el TSC en CPU1.  Deje que se obtenga un valor de 10 </li><li>  Pasaron 2 garrapatas </li><li>  Lea el TSC en la CPU2.  Debe ser 112 </li><li>  Pasaron 2 garrapatas </li><li>  Leer TSC en CPU3.  Debe ser 214 </li></ul><br>  Hasta ahora, el reloj parece sincronizado.  Pero volvamos a medir TSC en CPU1: <br><br><ul><li>  Pasaron 2 garrapatas </li><li>  Lea el TSC en CPU1.  Debe ser 16 </li></ul><br>  ¡Uy!  La monotonía está rota.  Resulta que medir los valores primero y último en la misma CPU le permite detectar cambios más o menos grandes entre los relojes.  La siguiente pregunta, por supuesto: "¿Qué tan grandes son los turnos?"  La cantidad de cambio que se puede detectar depende del tiempo que transcurra entre sucesivas mediciones de TSC.  En el ejemplo dado, estos son solo 2 ticks.  Se detectarán turnos entre horas que excedan las 2 garrapatas.  En términos generales, no se detectarán los cambios que sean inferiores al tiempo transcurrido entre mediciones sucesivas.  Entonces, cuanto más densas estén las mediciones en el tiempo, mejor.  La precisión de ambas estimaciones depende de esto.  Cuanto más densas se hacen las mediciones: <br><br><ul><li>  cuanto menor sea la estimación de turno máximo </li><li>  mayor confianza en la evaluación de la monotonía </li></ul><br>  En la siguiente sección, hablaremos sobre cómo tomar medidas ajustadas.  Agregaré aquí que mientras calcula las estimaciones de confiabilidad del TSC, la biblioteca realiza muchas más verificaciones simples de "piojos", por ejemplo: <br><br><ul><li>  verificación limitada de que los TSC en diferentes CPU están funcionando a la misma velocidad </li><li>  comprobar que los contadores realmente cambian con el tiempo y no solo muestran el mismo valor </li></ul><br><h3>  Dos métodos para recopilar valores de contador </h3><br>  En la biblioteca, implementé dos métodos para recopilar valores de TSC: <br><br><ol><li>  <b>Cambiar entre CPU</b> .  En este método, todos los datos necesarios para evaluar la confiabilidad del TSC se recopilan mediante un solo subproceso que "salta" de una CPU a otra.  Ambos algoritmos descritos en la sección anterior son adecuados para este método y no lo son para el otro. <br>  "Cambiar entre la CPU" no tiene un uso práctico.  El método se implementó por el simple hecho de "jugar".  El problema con el método es que el tiempo requerido para "arrastrar" un flujo de una CPU a otra es muy grande.  En consecuencia, pasa mucho tiempo entre sucesivas mediciones de TSC y la precisión de las estimaciones es muy baja.  Por ejemplo, se obtiene una estimación típica para el cambio máximo entre TSC en la región de 23,000 ticks. <br><br>  Sin embargo, el método tiene un par de ventajas: <br><ul><li>  Es absolutamente determinista.  Si necesita medir TSC secuencialmente en CPU1, CPU2, CPU3, simplemente lo tomamos y lo hacemos: cambie a CPU1, lea TSC, cambie a CPU2, lea TSC y, finalmente, cambie a CPU3, lea TSC </li><li>  presumiblemente, si el número de CPU en el sistema crece muy rápido, entonces el tiempo de cambio entre ellas debería crecer mucho más lentamente.  Por lo tanto, en teoría, aparentemente, puede existir un sistema, ¡un sistema muy grande!  - en el que se justificará el uso del método.  Pero aun así, esto es poco probable </li></ul><br></li><li>  <b>Mediciones ordenadas usando CAS</b> .  En este método, los datos se recopilan en paralelo mediante múltiples subprocesos.  Cada CPU disponible inicia un hilo.  Las medidas tomadas por diferentes subprocesos se organizan en una sola secuencia utilizando la operación "comparar e intercambiar".  A continuación se muestra un código que muestra cómo se hace esto. <br>  La idea del método está tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fio</a> , una herramienta popular para generar cargas de E / S. <br><br>  Las estimaciones de confiabilidad obtenidas con el poder de este método ya se ven bastante bien.  Por ejemplo, ya se obtiene una estimación del cambio máximo en el nivel de varios cientos de ticks.  Una comprobación de la monotonía le permite sincronizar el reloj en cientos de tics. <br><br>  Sin embargo, los algoritmos dados en la sección anterior no son adecuados para este método.  Para ellos es importante que los valores de TSC se midan en un orden predeterminado.  El método de "mediciones ordenadas por CAS" no lo permite.  En cambio, primero se recopila una secuencia larga de mediciones aleatorias, y luego los algoritmos (ya diferentes) intentan encontrar valores leídos en CPU "adecuadas" en esta secuencia. <br><br>  No daré estos algoritmos aquí, para no abusar de su atención.  Puedes verlos en el código.  Hay muchos comentarios  En teoría, estos algoritmos son iguales.  Un punto fundamentalmente nuevo es la verificación de cómo las secuencias TSC escritas al azar son estadísticamente "cualitativas".  También es posible establecer un nivel mínimo aceptable de significancia estadística para las estimaciones de confiabilidad del TSC. <br><br>  Teóricamente, en sistemas MUY grandes, el método "ordenado por CAS" puede dar malos resultados.  El método requiere que los procesadores compitan por el acceso a una ubicación de memoria común.  Si hay muchos procesadores, la competencia puede llegar a ser muy intensa.  Como resultado, será difícil crear una secuencia de medición con buenas propiedades estadísticas.  Sin embargo, por el momento, esta situación parece poco probable. <br></li></ol><br>  Prometí un código.  Esto es lo que parece construir mediciones en una sola cadena usando CAS. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  Este código se ejecuta en cada CPU disponible.  Todos los hilos tienen acceso a la variable compartida <code>seq_counter</code> .  Antes de leer el TSC, la secuencia lee el valor de esta variable y la almacena en la variable <code>seq_num</code> .  Luego lee TSC.  Luego intenta aumentar atómicamente seq_counter en uno, pero solo si el valor de la variable no ha cambiado desde que se leyó.  Si la operación es exitosa, esto significa que el hilo logró "replantear" el número de secuencia almacenado en <code>seq_num</code> detrás del valor medido del TSC.  El próximo número de serie, que podrá apostar (posiblemente ya en otro hilo) será uno más.  Para este número se toma de la variable <code>seq_counter</code> , y cada llamada exitosa de <code>__atomic_compare_exchange_n()</code> aumenta esta variable en uno. <br><br><div class="spoiler">  <b class="spoiler_title">__atómico con __sync ???</b> <div class="spoiler_text">  En aras del <code>__atomic</code> , debe tenerse en cuenta que el uso de las funciones integradas de la familia <code>__atomic</code> junto con una función de la familia <code>__sync</code> heredada se ve feo.  <code>__sync_synchronize()</code> usa en el código para evitar reordenar la operación de lectura TSC con la operación ascendente.  Esto requiere una barrera de memoria completa.  La familia <code>__atomic</code> formalmente no tiene una función con las propiedades correspondientes.  Aunque de hecho hay: <code>__atomic_signal_fence()</code> .  Esta función organiza cálculos de flujo con manejadores de señal que se ejecutan en el mismo flujo.  De hecho, esta es una barrera completa.  Sin embargo, esto no se establece explícitamente.  Y prefiero el código que no tiene semántica oculta.  Por <code>__sync_synchronize()</code> tanto, <code>__sync_synchronize()</code> es una barrera de memoria completa. <br></div></div><br>  Otro punto que vale la pena mencionar aquí es el cuidado de que todos los flujos involucrados en las mediciones comiencen más o menos simultáneamente.  Estamos interesados ​​en el hecho de que los valores de TSC leídos en diferentes CPU están tan mezclados como sea posible.  No estamos satisfechos con la situación cuando, por ejemplo, un subproceso comienza primero, termina su trabajo y solo entonces comienzan todos los demás.  La secuencia TSC resultante tendrá propiedades inútiles.  No se pueden extraer estimaciones de ella.  El inicio simultáneo de todos los hilos es importante, y para ello, se han tomado medidas en la biblioteca. <br><br><h3>  Convierte ticks a nanosegundos sobre la marcha </h3><br>  Después de verificar la confiabilidad de TSC, el segundo propósito principal de la biblioteca es convertir las garrapatas a nanosegundos sobre la marcha.  Tomé prestada la idea de esta conversión del ya mencionado fio.  Sin embargo, tuve que hacer algunas mejoras significativas porque, como lo mostró mi análisis, en sí mismo el procedimiento de conversión no funciona lo suficientemente bien.  Ahí tienes baja precisión. <br><br>  Comenzaré con un ejemplo. <br><br>  Idealmente, me gustaría convertir los ticks a nanosegundos como este: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  Queremos que el tiempo dedicado a la conversión sea mínimo.  Por lo tanto, nuestro objetivo es utilizar exclusivamente aritmética de enteros.  Veamos cómo esto puede amenazarnos. <br><br>  Si <code>tsc_per_ns = 3</code> , entonces una división entera simple, desde el punto de vista de la precisión, funciona bien: <code>ns_time = tsc_ticks / 3</code> . <br><br>  Pero, ¿y si <code>tsc_per_ns = 3.333</code> ?  Si este número se redondea a 3, la precisión de conversión será muy baja.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para superar este problema de la siguiente manera: </font></font><br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el factor </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es lo suficientemente grande, entonces la precisión será buena. Pero algo seguirá siendo malo. A saber, gastos generales de conversión. La división de enteros es una operación muy costosa. Por ejemplo, en x86 requiere más de 10 ciclos de reloj. Además, las operaciones de división de enteros no siempre se canalizan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvemos a escribir nuestra fórmula en forma equivalente </font></font><br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera división no es un problema. Podemos precalcular </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por adelantado. Pero la segunda división sigue siendo dolorosa. Para deshacernos de él, elija </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">igual a la potencia de dos. Después de eso, la segunda división puede ser reemplazada por un cambio de bit, una operación simple y rápida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué tan grande puedes elegir?</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Desafortunadamente, </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no puede ser arbitrariamente grande. Está limitado por la condición de que la multiplicación en el numerador no debe conducir a un desbordamiento del tipo de 64 bits. Sí, queremos usar solo tipos "nativos". Nuevamente, para mantener los gastos generales de conversión al mínimo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora veamos qué tan grande puede ser </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en nuestro ejemplo específico. Supongamos que queremos trabajar con intervalos de tiempo de hasta un año. Durante el año, TSC tiknet los siguientes tiempos: </font></font><code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Divide un valor máximo de número de tipo de 64 bits es: </font></font><code>18446744073709551615 / 105109488000000000 ~ 175.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo tanto, la expresión </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no debe ser mayor que este valor. Entonces tenemos:</font></font><code>factor &lt;= 175.5 * 3.333 ~ 584.9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La potencia más grande de dos que no excede este número es 512. Por lo tanto, nuestra fórmula de conversión toma la forma: </font></font><br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O </font></font><br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bien. Veamos ahora qué tiene esta fórmula con precisión. Un año contiene </font></font><code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nanosegundos. Nuestra fórmula da: </font></font><code>105109488000000000 * 153 / 512 = 31409671218750000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La diferencia con el valor actual es 126328781250000 nanosegundos u </font></font><code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un gran error. Queremos una mejor precisión. ¿Qué pasa si medimos intervalos de tiempo de no más de una hora? Omitiré los cálculos. Son completamente idénticos a los que acabamos de hacer. La fórmula final será: </font></font><br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El error de conversión será de solo 119,305 nanosegundos por 1 hora (que es menos de 0.2 milisegundos). Muy muy bien. Si el valor convertible máximo es incluso menos de una hora, entonces la precisión será aún mejor. ¿Pero cómo usamos esto? ¿No limite las mediciones de tiempo a una hora? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prestemos atención al siguiente momento: </font></font><br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si calculamos </font></font><code>tsc_ticks_per_1_hour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos extraer </font></font><code>number_of_hours</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A continuación, sabemos cuántos nanosegundos hay en una hora. Por lo tanto, no será difícil para nosotros traducir en nanosegundos esa parte </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que corresponde a un número entero de horas. Para completar la conversión, necesitaremos traducir en nanosegundos</font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sin embargo, sabemos que este número de garrapatas llegó en menos de una hora. Entonces, para convertirlo a nanosegundos, podemos usar la fórmula (1).</font></font><br><br>  Listo<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal mecanismo de conversión nos conviene. Resumamos y optimicemos ahora. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, queremos tener un control flexible sobre los errores de conversión. No queremos vincular los parámetros de conversión a un intervalo de tiempo de 1 hora. Sea un intervalo de tiempo arbitrario: una </font></font><br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez más, recuerde cómo convertir el resto a nanosegundos: </font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcule los parámetros de conversión (lo sabemos </font></font><code>tsc_ticks_remainder &lt; modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">): en </font><font style="vertical-align: inherit;">aras de la tedio, debe tenerse en cuenta que la última desigualdad no es equivalente a la primera en el marco de la aritmética de enteros. Pero no me detendré en esto por mucho tiempo. Solo puedo decir que la última desigualdad es más severa que la primera y, por lo tanto, segura de usar. </font><font style="vertical-align: inherit;">Una vez obtenido de la última desigualdad </font><font style="vertical-align: inherit;">, calculamos:</font></font><br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>shift</code><font style="vertical-align: inherit;"></font><br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y luego estos parámetros se utilizan para convertir el resto a nanosegundos: </font><font style="vertical-align: inherit;">Entonces, descubrimos la conversión del resto. El siguiente problema que hay que resolver - es la eliminación de </font><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">. Como siempre, queremos hacerlo rápido. Como siempre, no queremos usar la división. Por lo tanto, simplemente elegimos </font><font style="vertical-align: inherit;">igual a la potencia de dos: </font><font style="vertical-align: inherit;">Entonces:</font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br><font style="vertical-align: inherit;"></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"></font><code>number_of_moduli_periods</code><font style="vertical-align: inherit;"></font><code>tsc_ticks</code><font style="vertical-align: inherit;"></font><code>modulus</code><font style="vertical-align: inherit;"></font><br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br>  Genial<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora sabemos cómo extraer de </font></font><code>tsc_ticks</code> <code>number_of_moduli_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Y sabemos cómo convertir </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a nanosegundos. </font><font style="vertical-align: inherit;">Queda por comprender cómo convertir esa parte de las garrapatas, que es un múltiplo, en nanosegundos </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero todo es simple: </font></font><br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede calcular por adelantado. </font><font style="vertical-align: inherit;">Además, de acuerdo con la misma fórmula por la cual convertimos el resto. </font><font style="vertical-align: inherit;">Esta fórmula se puede usar por períodos de tiempo que no son más largos </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Él mismo </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por supuesto, no más que </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br>  Eso es todo!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pudimos calcular todos los parámetros necesarios para convertir las garrapatas a nanosegundos sobre la marcha. </font><font style="vertical-align: inherit;">Ahora resuma brevemente el procedimiento de conversión:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tenemos </font></font><code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este procedimiento, los parámetros </font></font><code>remainder_bit_length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>modulus, ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avance cálculo previo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si todavía estás leyendo esta publicación, entonces eres genial o genial. </font><font style="vertical-align: inherit;">Incluso es posible que sea analista de rendimiento o desarrollador de software de alto rendimiento.</font></font><br><br>  Entonces aquí.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resulta que todavía no hemos terminado :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Recuerdas cómo calculamos el parámetro </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Fue así: </font></font><br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pregunta: ¿de dónde viene </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El número de tics en un nanosegundo es un valor muy pequeño. </font><font style="vertical-align: inherit;">De hecho, mi biblioteca se </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa en su </font><font style="vertical-align: inherit;">lugar </font></font><code>(tsc_per_sec / 1000000000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es decir: </font></font><br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y hay dos preguntas interesantes:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Dónde conseguir estos </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con el primero. Fio ahora usa la cantidad de tics por milisegundo. Y hay problemas con eso. En la máquina, los parámetros de los cuales me nombraron anteriormente </font></font><code>tsc_per_msec = 2599998</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mientras </font></font><code>tsc_per_sec = 2599998971</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si llevamos estos números a una escala, su relación será muy cercana a la unidad: 0.999999626. Pero si usamos el primero, y no el segundo, entonces por cada segundo tendremos un error de 374 nanosegundos. Por lo tanto - </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además ... ¿Cómo contar </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se realiza sobre la base de la medición directa: </font><font style="vertical-align: inherit;">"algún tiempo" es un parámetro configurable. Puede ser más grande, más pequeño o igual a un segundo. Digamos que es medio segundo. Supongamos además que la diferencia real entre </font><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">resultó ser 0.6 segundos. Entonces </font><font style="vertical-align: inherit;">.</font></font><br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br><font style="vertical-align: inherit;"></font><code>end_system_time</code><font style="vertical-align: inherit;"></font><code>start_system_time</code><font style="vertical-align: inherit;"></font><code>tsc_per_sec = (end_tsc – start_tsc) / 0,6</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioteca considera varios valores de esta manera </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Y luego, utilizando métodos estándar, los "limpia" del ruido estadístico y recibe un valor único en el </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se puede confiar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el diagrama de medición de tiempo anterior, el orden de las llamadas </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y es </font><font style="vertical-align: inherit;">importante </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es importante </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que transcurra el mismo tiempo entre dos llamadas que entre dos llamadas </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Entonces será posible correlacionar fácilmente el tiempo del sistema con tics TSC. Y luego, la dispersión de valores </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede considerarse realmente aleatoria. Con este esquema de medición, los valores </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se desviarán del valor promedio en cualquier dirección con la misma probabilidad. Y será posible aplicarles métodos de filtrado estándar.</font></font><br><br><h3>  Conclusión </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quizás eso es todo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero el tema de la medición efectiva del tiempo no se limita a esto. </font><font style="vertical-align: inherit;">Hay muchos matices. </font><font style="vertical-align: inherit;">Para aquellos interesados, propongo trabajar de forma independiente en los siguientes temas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> almacenar parámetros de conversión en caché o, mejor aún, en registros </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿A qué límites se puede reducir </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(aumentando así la precisión de la conversión)?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como hemos visto, la precisión de la conversión se ve afectada no solo </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sino también por el tamaño del intervalo de tiempo, que se correlaciona con los ticks ( </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">¿Cómo equilibrar la influencia de ambos factores?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSC en la máquina virtual. </font><font style="vertical-align: inherit;">¿Puedo usarlo?</font></font></li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los métodos discutidos en este artículo nos permiten medir la escala de tiempo de un segundo con una precisión del orden de varias decenas de nanosegundos. </font><font style="vertical-align: inherit;">Esta es la precisión que realmente observo cuando uso mi biblioteca. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, el fio, del cual tomé prestados algunos métodos, pierde exactamente 700-900 nanosegundos en una segunda escala (y hay tres razones para esto). </font><font style="vertical-align: inherit;">Además, pierde velocidad de conversión debido al almacenamiento de tiempo en un formato estándar de Linux. </font><font style="vertical-align: inherit;">Sin embargo, me apresuro a tranquilizar a los fanáticos del fio. </font><font style="vertical-align: inherit;">Envié a los desarrolladores una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descripción de todos los problemas de conversión que descubrí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La gente ya está trabajando, lo arreglarán pronto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Te deseo muchos nanosegundos agradables!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425237/">https://habr.com/ru/post/es425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425227/index.html">Los investigadores han encontrado una manera de detectar y omitir las claves Honeytoken en varios servicios de Amazon.</a></li>
<li><a href="../es425229/index.html">Cómo ayudamos a CDN MegaFon.TV a no llegar a la Copa Mundial 2018</a></li>
<li><a href="../es425231/index.html">Preguntas frecuentes sobre el trabajo de una azafata</a></li>
<li><a href="../es425233/index.html">Python 3 en Facebook</a></li>
<li><a href="../es425235/index.html">Un poco más sobre gráficos, o cómo detectar dependencias entre sus aplicaciones</a></li>
<li><a href="../es425241/index.html">Desarrollador 20 años después: Vasily Lebedev sobre ICRE, educación, su libro y programación.</a></li>
<li><a href="../es425243/index.html">El manual de john willis</a></li>
<li><a href="../es425245/index.html">Anuncio de RamblerFront & # 6</a></li>
<li><a href="../es425247/index.html">Crowdsourcing en pruebas</a></li>
<li><a href="../es425249/index.html">¿Cómo es el conocimiento de LLP en la Universidad ITMO: el curso "Programación de bajo nivel"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>