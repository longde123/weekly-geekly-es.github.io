<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåù üôÜüèø üï¶ Medici√≥n de tiempo con precisi√≥n de nanosegundos üôè üíº üìÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace un par de meses lleg√≥ un momento hist√≥rico para m√≠. Las herramientas est√°ndar del sistema operativo para medir el tiempo han dejado de ser sufici...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Medici√≥n de tiempo con precisi√≥n de nanosegundos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425237/"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="imagen"><br><br>  Hace un par de meses lleg√≥ un momento hist√≥rico para m√≠.  Las herramientas est√°ndar del sistema operativo para medir el tiempo han dejado de ser suficientes para m√≠.  Tom√≥ tiempo medir con precisi√≥n de nanosegundos y con sobrecarga de nanosegundos. <br><br>  Decid√≠ escribir una biblioteca que resolviera este problema.  A primera vista, parec√≠a que no hab√≠a nada especial que hacer.  Pero despu√©s de un examen m√°s detallado, como siempre, result√≥ que hab√≠a muchos problemas interesantes que deb√≠an ser tratados.  En este art√≠culo, hablar√© sobre los problemas y c√≥mo se resolvieron. <br><br>  Como puede medir muchos tipos diferentes de tiempo en una computadora, aclarar√© de inmediato que aqu√≠ hablaremos del "tiempo por cron√≥metro".  O la hora del reloj de pared.  Es tiempo real, tiempo transcurrido, etc.  Es decir, un tiempo "humano" simple, que detectamos al comienzo de la tarea y lo detenemos al final. <br><a name="habracut"></a><br><h3>  Microsegundo: casi para siempre </h3><br>  Los desarrolladores de sistemas de alto rendimiento en los √∫ltimos a√±os se han acostumbrado a la escala de tiempo de microsegundos.  En microsegundos, puede leer datos de una unidad NVMe.  En microsegundos, los datos se pueden enviar a trav√©s de la red.  No para todos, por supuesto, sino para InifiniBand-network, f√°cilmente. <br><br>  Al mismo tiempo, el microsegundo tambi√©n ten√≠a una estructura.  Una pila de E / S completa consta de varios componentes de software y hardware.  Los retrasos introducidos por algunos de ellos se encuentran en el nivel sub-microsegundo. <br><br>  Para medir retrasos de esta magnitud, la precisi√≥n de microsegundos ya no es suficiente.  Sin embargo, no solo es importante la precisi√≥n, sino tambi√©n la sobrecarga del tiempo de medici√≥n.  La llamada al sistema Linux clock_gettime () devuelve el tiempo con precisi√≥n de nanosegundos.  En una m√°quina que est√° al alcance de mi mano (CPU Intel¬Æ Xeon¬Æ E5-2630 v2 @ 2.60GHz), esta llamada se completa en aproximadamente 120 ns.  Muy buena figura.  Adem√°s, clock_gettime () funciona de manera bastante predecible.  Esto le permite tener en cuenta los gastos generales de su llamada y realmente tomar medidas con una precisi√≥n del orden de decenas de nanosegundos.  Sin embargo, ahora prestemos atenci√≥n a esto.  Para medir el intervalo de tiempo, debe hacer dos llamadas de este tipo: al principio y al final.  Es decir  gastar 240 ns.  Si se miden intervalos de tiempo densamente espaciados del orden de 1-10 Œºs, entonces, en algunos casos, el proceso de medici√≥n en s√≠ mismo distorsionar√° significativamente el proceso observado. <br><br>  Comenc√© esta secci√≥n con c√≥mo la pila IO se ha acelerado en los √∫ltimos a√±os.  Esto es nuevo, pero lejos de ser la √∫nica raz√≥n para querer medir el tiempo de forma r√°pida y precisa.  Tal necesidad siempre ha sido.  Por ejemplo, siempre hab√≠a un c√≥digo que quer√≠a acelerar por al menos 1 ciclo de reloj del microprocesador.  U otro ejemplo, del art√≠culo original sobre la sensacional vulnerabilidad Spectre: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="imagen"><br><br>  Aqu√≠, las l√≠neas 72-74 miden el tiempo de ejecuci√≥n de una sola operaci√≥n de acceso a memoria.  Es cierto que Specter no est√° interesado en nanosegundos.  El tiempo se puede medir en "loros".  Volveremos a los loros y segundos. <br><br><h3>  Contador de sello de tiempo </h3><br>  La clave para una medici√≥n de tiempo r√°pida y precisa es un contador de microprocesador especial.  El valor de este contador generalmente se almacena en un registro separado y generalmente es accesible, pero no siempre, desde el espacio del usuario.  En diferentes arquitecturas, el contador se llama de manera diferente: <br><br><ol><li>  Contador de sello de tiempo x86 </li><li>  registro de base de tiempo en PowerPC </li><li>  contador de tiempo de intervalo en Itanium </li><li>  etc. </li></ol><br>  A continuaci√≥n, siempre usar√© el nombre "contador de marca de tiempo" o TSC, aunque de hecho tendr√© en cuenta cualquier contador, independientemente de la arquitectura. <br><br>  Por lo general, es posible leer el valor de TSC, pero nuevamente no siempre, con una sola instrucci√≥n.  Aqu√≠ hay un ejemplo para x86.  Estrictamente hablando, esta no es una instrucci√≥n pura de ensamblador, sino el ensamblador en l√≠nea de GNU: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  La instrucci√≥n rdtsc coloca dos mitades de 32 bits del registro TSC en los registros eax y edx.  De estos, puede "pegar" un solo valor de 64 bits. <br><br>  Una vez m√°s, noto: esta (y similares) instrucciones en la mayor√≠a de los casos se pueden llamar directamente desde el espacio del usuario.  No hay llamadas del sistema.  Gastos generales m√≠nimos. <br><br>  ¬øQu√© debe hacerse ahora para medir el tiempo? <br><br><ol><li>  Ejecute una de estas instrucciones al comienzo del intervalo de tiempo que nos interese.  Recordar el valor del contador </li><li>  Ejecute una de esas instrucciones al final.  Creemos que el valor del contador desde la primera instrucci√≥n hasta la segunda aumentar√°.  De lo contrario, ¬øpor qu√© es necesario?  Recuerda el segundo valor </li><li>  Consideramos la diferencia entre los dos valores almacenados.  Este es nuestro tiempo </li></ol><br>  Parece simple, pero ... <br><br>  El tiempo medido por el procedimiento descrito se expresa en "loros".  No es en segundos.  Pero a veces los loros son exactamente lo que necesitas.  Hay situaciones en las que no son importantes los valores absolutos de los intervalos de tiempo, sino c√≥mo se relacionan entre s√≠ los diferentes intervalos.  El ejemplo anterior de Spectre demuestra exactamente esta situaci√≥n.  La duraci√≥n de cada acceso individual a la memoria no importa.  Solo es importante que las llamadas a algunas direcciones se ejecuten mucho m√°s r√°pido que a otras (dependiendo de si los datos est√°n almacenados en la memoria cach√© o en la memoria principal). <br><br>  Pero, ¬øqu√© pasa si no se necesitan loros, sino segundos / microsegundos / nanosegundos, etc.?  Aqu√≠ se pueden distinguir dos casos fundamentalmente diferentes: <br><br><ol><li>  Se necesitan nanosegundos, pero entonces.  Es decir, est√° permitido hacer primero todas las mediciones necesarias en loros y almacenarlas en alg√∫n lugar para su posterior procesamiento (por ejemplo, en la memoria).  Y solo despu√©s de que se completen las mediciones, convierta lentamente los loros recolectados en segundos </li><li>  Se necesitan nanosegundos "sobre la marcha".  Por ejemplo, su proceso de medici√≥n tiene alg√∫n tipo de "consumidor" que usted no controla y que espera tiempo en el formato "humano" </li></ol><br>  El primer caso es simple, el segundo: requiere ingenio.  La conversi√≥n debe ser lo m√°s efectiva posible.  Si consume muchos recursos, puede distorsionar en gran medida el proceso de medici√≥n.  Hablaremos sobre la conversi√≥n efectiva a continuaci√≥n.  Aqu√≠ hasta ahora hemos identificado este problema y pasamos a otro. <br><br>  Los contadores de sello de tiempo no son tan simples como nos gustar√≠a.  En algunas arquitecturas: <br><br><ol><li>  no se garantiza que el TSC se actualice a alta frecuencia.  Si el TSC se actualiza, por ejemplo, una vez cada microsegundo, entonces no ser√° posible arreglar nanosegundos con √©l. </li><li>  la frecuencia con la que se actualiza el TSC puede variar con el tiempo </li><li>  en diferentes CPU presentes en el sistema, los TSC se pueden actualizar a diferentes frecuencias </li><li>  puede haber un cambio entre TSC marcando en diferentes CPU </li></ol><br>  Aqu√≠ hay un ejemplo que ilustra el √∫ltimo problema.  Supongamos que tenemos un sistema con dos CPU: CPU1 y CPU2.  Suponga que el TSC en la primera CPU est√° detr√°s de la segunda por el n√∫mero de tics, que es equivalente a 5 segundos.  Supongamos adem√°s que se inicia una secuencia en el sistema que mide el tiempo de los c√°lculos, lo que √©l mismo hace.  Para hacer esto, la secuencia primero lee el valor de TSC, luego realiza el c√°lculo y luego lee el segundo valor de TSC.  Si durante toda su vida un hilo permanece en una sola CPU, en cualquiera, entonces no hay problemas.  Pero, ¬øqu√© pasa si el subproceso comenz√≥ en la CPU1, midi√≥ el primer valor de TSC all√≠ y luego, en el medio de los c√°lculos, el sistema operativo lo movi√≥ a la CPU2, donde ley√≥ el segundo valor de TSC?  En este caso, los c√°lculos parecer√°n 5 segundos m√°s largos de lo que realmente son. <br><br>  Debido a los problemas enumerados anteriormente, TSC no puede servir como una fuente confiable de tiempo en algunos sistemas.  Sin embargo, en otros sistemas que "padecen" los mismos problemas, a√∫n se puede usar TSC.  Esto es posible gracias a caracter√≠sticas arquitect√≥nicas especiales: <br><br><ol><li>  el equipo puede generar una interrupci√≥n especial cada vez que cambia la frecuencia con la que se actualiza el TSC.  Al mismo tiempo, el equipo tambi√©n brinda la oportunidad de averiguar la frecuencia actual.  Alternativamente, la frecuencia de actualizaci√≥n del TSC se puede colocar bajo el control del sistema operativo (consulte ‚ÄúRevisi√≥n ISA Power 2.0 versi√≥n B, Libro II, Cap√≠tulo 5‚Äù) </li><li>  el hardware, junto con el valor TSC, tambi√©n puede proporcionar la ID de la CPU en la que se lee este valor (consulte las instrucciones Intel RDTSCP, "Manual del desarrollador de software de las arquitecturas Intel 64 e IA-32", Volumen 2) </li><li>  en algunos sistemas, puede ajustar mediante programaci√≥n el valor de TSC para cada CPU (consulte las instrucciones de Intel WRMSR y registre IA32_TIME_STAMP_COUNTER, ‚ÄúManual del desarrollador de software de las arquitecturas Intel 64 e IA-32‚Äù, Volumen 3) </li></ol><br>  En general, el tema de c√≥mo se implementan los medidores de tiempo en diferentes arquitecturas es fascinante y extenso.  Si tienes tiempo e inter√©s, te recomiendo bucear.  Entre otras cosas, aprender√°, por ejemplo, que algunos sistemas le permiten determinar mediante programaci√≥n si TSC puede servir como una fuente confiable de tiempo. <br><br>  Por lo tanto, hay muchas implementaciones arquitect√≥nicas de TSC, cada una con sus propias caracter√≠sticas.  Pero es interesante que se haya establecido una tendencia general en todo este zool√≥gico.  <b>El hardware y los sistemas operativos modernos se esfuerzan por garantizar que</b> : <br><br><ol><li>  El TSC funciona a la misma frecuencia en cada CPU del sistema </li><li>  esta frecuencia no cambia en el tiempo </li><li>  no hay cambio entre TSC marcando en diferentes CPU </li></ol><br>  Al dise√±ar mi biblioteca, decid√≠ proceder desde esta premisa, y no desde la vinagreta de las implementaciones de hardware. <br><br><h3>  La biblioteca </h3><br>  No comenc√© a instalar chips de hardware de diferentes arquitecturas.  En cambio, decid√≠ que mi biblioteca estar√≠a orientada a las tendencias.  Ella tiene un enfoque puramente emp√≠rico: <br><br><ol><li>  le permite verificar experimentalmente la confiabilidad de TSC como fuente de tiempo </li><li>  Tambi√©n le permite calcular experimentalmente los par√°metros necesarios para convertir r√°pidamente las garrapatas a nanosegundos </li><li>  naturalmente, la biblioteca proporciona interfaces convenientes para leer TSC y convertir ticks a nanosegundos "sobre la marcha" </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El c√≥digo de la biblioteca est√° disponible aqu√≠.</a>  Se compilar√° y ejecutar√° solo en Linux. <br><br>  En el c√≥digo, puede ver los detalles de la implementaci√≥n de todos los m√©todos, que se discutir√°n m√°s adelante. <br><br><h3>  Evaluaci√≥n de confiabilidad de TSC </h3><br>  La biblioteca proporciona una interfaz que devuelve dos clasificaciones: <br><br><ol><li>  desplazamiento m√°ximo entre contadores pertenecientes a diferentes CPU.  Solo se consideran las CPU disponibles para el proceso.  Por ejemplo, si un proceso tiene tres CPU disponibles, y al mismo tiempo el TSC en estas CPU es 50, 150, 20, entonces el cambio m√°ximo ser√° 150-20 = 130.  Naturalmente, la biblioteca no podr√° obtener un cambio real m√°ximo experimentalmente, pero dar√° una estimaci√≥n en la que se ajustar√° este cambio.  ¬øQu√© hacer a continuaci√≥n con la evaluaci√≥n?  ¬øC√≥mo usarlo?  Esto ya resuelve el c√≥digo del cliente.  Pero el significado es aproximadamente el siguiente.  El desplazamiento m√°ximo es el valor m√°ximo por el cual la dimensi√≥n que crea el c√≥digo del cliente puede distorsionarse.  Supongamos que, en nuestro ejemplo con tres CPU, el c√≥digo del cliente comenz√≥ a medir el tiempo en la CPU3 (donde TSC ten√≠a 20) y termin√≥ en la CPU2 (donde TSC ten√≠a 150).  Resulta que 130 garrapatas adicionales se arrastrar√°n en el intervalo medido.  Y nunca m√°s.  La diferencia entre CPU1 y CPU2 ser√≠a de solo 100 ticks.  Teniendo una estimaci√≥n de 130 ticks (de hecho, ser√° mucho m√°s conservador), el cliente puede decidir si tal valor de distorsi√≥n le conviene o no </li><li>  ¬øAumentan los valores de TSC medidos secuencialmente en la misma CPU o en diferentes CPU?  Aqu√≠ est√° la idea.  Digamos que tenemos varias CPU.  Supongamos que su reloj est√° sincronizado y marcando la misma frecuencia.  Luego, si primero mide el tiempo en una CPU y luego lo mide nuevamente, ya en cualquiera de las CPU disponibles, entonces el segundo d√≠gito debe ser mayor que el primero. <br><br>  Llamar√© a esta estimaci√≥n por debajo de la estimaci√≥n de monotonicidad TSC <br></li></ol><br>  Ahora veamos c√≥mo podemos obtener la primera estimaci√≥n: <br><br><ol><li>  uno de los procesadores disponibles para el proceso se declara "b√°sico" </li><li>  entonces se ordenan todas las otras CPU, y para cada una de ellas se calcula el cambio: <code>TSC___CPU ‚Äì TSC___CPU</code> .  Esto se hace de la siguiente manera: <br><ul><li>  a) se toman tres valores medidos secuencialmente (¬°uno tras otro!): <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Aqu√≠, actual indica que el valor se midi√≥ en la CPU actual y se basa en la base </li><li>  b) el cambio <code>TSC___CPU ‚Äì TSC___CPU</code> debe estar en el intervalo <code>[TSC_current ‚Äì TSC_base_2, TSC_current ‚Äì TSC_base_1]</code> .  Esto se da por supuesto que los TSC est√°n funcionando a la misma frecuencia en ambas CPU. </li><li>  c) los pasos a) -b) se repiten varias veces.  Se calcula la intersecci√≥n de todos los intervalos obtenidos en el paso b).  El intervalo resultante se toma como la estimaci√≥n del cambio <code>TSC___CPU ‚Äì TSC___CPU</code> </li></ul><br></li><li>  Despu√©s de obtener una estimaci√≥n de cambio para cada CPU en relaci√≥n con la base, es f√°cil obtener una estimaci√≥n del cambio m√°ximo entre todas las CPU disponibles: <br><ul><li>  a) se calcula el intervalo m√≠nimo, que incluye todos los intervalos resultantes obtenidos en el paso 2 </li><li>  b) el ancho de este intervalo se toma como la estimaci√≥n del cambio m√°ximo entre TSC marcando en diferentes CPU </li></ul><br></li></ol><br>  Para evaluar la monoton√≠a en la biblioteca, se implementa el siguiente algoritmo: <br><br><ol><li>  Digamos que un proceso tiene N CPU disponible </li><li>  Medici√≥n de TSC en CPU1 </li><li>  Medici√≥n de TSC en CPU2 </li><li>  ... </li><li>  Medici√≥n de TSC en CPUN </li><li>  Mida TSC nuevamente en CPU1 </li><li>  Verificamos que los valores medidos aumentan monot√≥nicamente del primero al √∫ltimo </li></ol><br>  Aqu√≠ es importante que el primer y el √∫ltimo valor se midan en la misma CPU.  Y aqu√≠ est√° el por qu√©.  Digamos que tenemos 3 CPU.  Suponga que el TSC en la CPU2 se desplaza por +100 ticks en relaci√≥n con el TSC en la CPU1.  Supongamos tambi√©n que el TSC en la CPU3 se desplaza por +100 ticks en relaci√≥n con el TSC en la CPU2.  Considere la siguiente cadena de eventos: <br><br><ul><li>  Lea el TSC en CPU1.  Deje que se obtenga un valor de 10 </li><li>  Pasaron 2 garrapatas </li><li>  Lea el TSC en la CPU2.  Debe ser 112 </li><li>  Pasaron 2 garrapatas </li><li>  Leer TSC en CPU3.  Debe ser 214 </li></ul><br>  Hasta ahora, el reloj parece sincronizado.  Pero volvamos a medir TSC en CPU1: <br><br><ul><li>  Pasaron 2 garrapatas </li><li>  Lea el TSC en CPU1.  Debe ser 16 </li></ul><br>  ¬°Uy!  La monoton√≠a est√° rota.  Resulta que medir los valores primero y √∫ltimo en la misma CPU le permite detectar cambios m√°s o menos grandes entre los relojes.  La siguiente pregunta, por supuesto: "¬øQu√© tan grandes son los turnos?"  La cantidad de cambio que se puede detectar depende del tiempo que transcurra entre sucesivas mediciones de TSC.  En el ejemplo dado, estos son solo 2 ticks.  Se detectar√°n turnos entre horas que excedan las 2 garrapatas.  En t√©rminos generales, no se detectar√°n los cambios que sean inferiores al tiempo transcurrido entre mediciones sucesivas.  Entonces, cuanto m√°s densas est√©n las mediciones en el tiempo, mejor.  La precisi√≥n de ambas estimaciones depende de esto.  Cuanto m√°s densas se hacen las mediciones: <br><br><ul><li>  cuanto menor sea la estimaci√≥n de turno m√°ximo </li><li>  mayor confianza en la evaluaci√≥n de la monoton√≠a </li></ul><br>  En la siguiente secci√≥n, hablaremos sobre c√≥mo tomar medidas ajustadas.  Agregar√© aqu√≠ que mientras calcula las estimaciones de confiabilidad del TSC, la biblioteca realiza muchas m√°s verificaciones simples de "piojos", por ejemplo: <br><br><ul><li>  verificaci√≥n limitada de que los TSC en diferentes CPU est√°n funcionando a la misma velocidad </li><li>  comprobar que los contadores realmente cambian con el tiempo y no solo muestran el mismo valor </li></ul><br><h3>  Dos m√©todos para recopilar valores de contador </h3><br>  En la biblioteca, implement√© dos m√©todos para recopilar valores de TSC: <br><br><ol><li>  <b>Cambiar entre CPU</b> .  En este m√©todo, todos los datos necesarios para evaluar la confiabilidad del TSC se recopilan mediante un solo subproceso que "salta" de una CPU a otra.  Ambos algoritmos descritos en la secci√≥n anterior son adecuados para este m√©todo y no lo son para el otro. <br>  "Cambiar entre la CPU" no tiene un uso pr√°ctico.  El m√©todo se implement√≥ por el simple hecho de "jugar".  El problema con el m√©todo es que el tiempo requerido para "arrastrar" un flujo de una CPU a otra es muy grande.  En consecuencia, pasa mucho tiempo entre sucesivas mediciones de TSC y la precisi√≥n de las estimaciones es muy baja.  Por ejemplo, se obtiene una estimaci√≥n t√≠pica para el cambio m√°ximo entre TSC en la regi√≥n de 23,000 ticks. <br><br>  Sin embargo, el m√©todo tiene un par de ventajas: <br><ul><li>  Es absolutamente determinista.  Si necesita medir TSC secuencialmente en CPU1, CPU2, CPU3, simplemente lo tomamos y lo hacemos: cambie a CPU1, lea TSC, cambie a CPU2, lea TSC y, finalmente, cambie a CPU3, lea TSC </li><li>  presumiblemente, si el n√∫mero de CPU en el sistema crece muy r√°pido, entonces el tiempo de cambio entre ellas deber√≠a crecer mucho m√°s lentamente.  Por lo tanto, en teor√≠a, aparentemente, puede existir un sistema, ¬°un sistema muy grande!  - en el que se justificar√° el uso del m√©todo.  Pero aun as√≠, esto es poco probable </li></ul><br></li><li>  <b>Mediciones ordenadas usando CAS</b> .  En este m√©todo, los datos se recopilan en paralelo mediante m√∫ltiples subprocesos.  Cada CPU disponible inicia un hilo.  Las medidas tomadas por diferentes subprocesos se organizan en una sola secuencia utilizando la operaci√≥n "comparar e intercambiar".  A continuaci√≥n se muestra un c√≥digo que muestra c√≥mo se hace esto. <br>  La idea del m√©todo est√° tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fio</a> , una herramienta popular para generar cargas de E / S. <br><br>  Las estimaciones de confiabilidad obtenidas con el poder de este m√©todo ya se ven bastante bien.  Por ejemplo, ya se obtiene una estimaci√≥n del cambio m√°ximo en el nivel de varios cientos de ticks.  Una comprobaci√≥n de la monoton√≠a le permite sincronizar el reloj en cientos de tics. <br><br>  Sin embargo, los algoritmos dados en la secci√≥n anterior no son adecuados para este m√©todo.  Para ellos es importante que los valores de TSC se midan en un orden predeterminado.  El m√©todo de "mediciones ordenadas por CAS" no lo permite.  En cambio, primero se recopila una secuencia larga de mediciones aleatorias, y luego los algoritmos (ya diferentes) intentan encontrar valores le√≠dos en CPU "adecuadas" en esta secuencia. <br><br>  No dar√© estos algoritmos aqu√≠, para no abusar de su atenci√≥n.  Puedes verlos en el c√≥digo.  Hay muchos comentarios  En teor√≠a, estos algoritmos son iguales.  Un punto fundamentalmente nuevo es la verificaci√≥n de c√≥mo las secuencias TSC escritas al azar son estad√≠sticamente "cualitativas".  Tambi√©n es posible establecer un nivel m√≠nimo aceptable de significancia estad√≠stica para las estimaciones de confiabilidad del TSC. <br><br>  Te√≥ricamente, en sistemas MUY grandes, el m√©todo "ordenado por CAS" puede dar malos resultados.  El m√©todo requiere que los procesadores compitan por el acceso a una ubicaci√≥n de memoria com√∫n.  Si hay muchos procesadores, la competencia puede llegar a ser muy intensa.  Como resultado, ser√° dif√≠cil crear una secuencia de medici√≥n con buenas propiedades estad√≠sticas.  Sin embargo, por el momento, esta situaci√≥n parece poco probable. <br></li></ol><br>  Promet√≠ un c√≥digo.  Esto es lo que parece construir mediciones en una sola cadena usando CAS. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  Este c√≥digo se ejecuta en cada CPU disponible.  Todos los hilos tienen acceso a la variable compartida <code>seq_counter</code> .  Antes de leer el TSC, la secuencia lee el valor de esta variable y la almacena en la variable <code>seq_num</code> .  Luego lee TSC.  Luego intenta aumentar at√≥micamente seq_counter en uno, pero solo si el valor de la variable no ha cambiado desde que se ley√≥.  Si la operaci√≥n es exitosa, esto significa que el hilo logr√≥ "replantear" el n√∫mero de secuencia almacenado en <code>seq_num</code> detr√°s del valor medido del TSC.  El pr√≥ximo n√∫mero de serie, que podr√° apostar (posiblemente ya en otro hilo) ser√° uno m√°s.  Para este n√∫mero se toma de la variable <code>seq_counter</code> , y cada llamada exitosa de <code>__atomic_compare_exchange_n()</code> aumenta esta variable en uno. <br><br><div class="spoiler">  <b class="spoiler_title">__at√≥mico con __sync ???</b> <div class="spoiler_text">  En aras del <code>__atomic</code> , debe tenerse en cuenta que el uso de las funciones integradas de la familia <code>__atomic</code> junto con una funci√≥n de la familia <code>__sync</code> heredada se ve feo.  <code>__sync_synchronize()</code> usa en el c√≥digo para evitar reordenar la operaci√≥n de lectura TSC con la operaci√≥n ascendente.  Esto requiere una barrera de memoria completa.  La familia <code>__atomic</code> formalmente no tiene una funci√≥n con las propiedades correspondientes.  Aunque de hecho hay: <code>__atomic_signal_fence()</code> .  Esta funci√≥n organiza c√°lculos de flujo con manejadores de se√±al que se ejecutan en el mismo flujo.  De hecho, esta es una barrera completa.  Sin embargo, esto no se establece expl√≠citamente.  Y prefiero el c√≥digo que no tiene sem√°ntica oculta.  Por <code>__sync_synchronize()</code> tanto, <code>__sync_synchronize()</code> es una barrera de memoria completa. <br></div></div><br>  Otro punto que vale la pena mencionar aqu√≠ es el cuidado de que todos los flujos involucrados en las mediciones comiencen m√°s o menos simult√°neamente.  Estamos interesados ‚Äã‚Äãen el hecho de que los valores de TSC le√≠dos en diferentes CPU est√°n tan mezclados como sea posible.  No estamos satisfechos con la situaci√≥n cuando, por ejemplo, un subproceso comienza primero, termina su trabajo y solo entonces comienzan todos los dem√°s.  La secuencia TSC resultante tendr√° propiedades in√∫tiles.  No se pueden extraer estimaciones de ella.  El inicio simult√°neo de todos los hilos es importante, y para ello, se han tomado medidas en la biblioteca. <br><br><h3>  Convierte ticks a nanosegundos sobre la marcha </h3><br>  Despu√©s de verificar la confiabilidad de TSC, el segundo prop√≥sito principal de la biblioteca es convertir las garrapatas a nanosegundos sobre la marcha.  Tom√© prestada la idea de esta conversi√≥n del ya mencionado fio.  Sin embargo, tuve que hacer algunas mejoras significativas porque, como lo mostr√≥ mi an√°lisis, en s√≠ mismo el procedimiento de conversi√≥n no funciona lo suficientemente bien.  Ah√≠ tienes baja precisi√≥n. <br><br>  Comenzar√© con un ejemplo. <br><br>  Idealmente, me gustar√≠a convertir los ticks a nanosegundos como este: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  Queremos que el tiempo dedicado a la conversi√≥n sea m√≠nimo.  Por lo tanto, nuestro objetivo es utilizar exclusivamente aritm√©tica de enteros.  Veamos c√≥mo esto puede amenazarnos. <br><br>  Si <code>tsc_per_ns = 3</code> , entonces una divisi√≥n entera simple, desde el punto de vista de la precisi√≥n, funciona bien: <code>ns_time = tsc_ticks / 3</code> . <br><br>  Pero, ¬øy si <code>tsc_per_ns = 3.333</code> ?  Si este n√∫mero se redondea a 3, la precisi√≥n de conversi√≥n ser√° muy baja.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para superar este problema de la siguiente manera: </font></font><br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el factor </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es lo suficientemente grande, entonces la precisi√≥n ser√° buena. Pero algo seguir√° siendo malo. A saber, gastos generales de conversi√≥n. La divisi√≥n de enteros es una operaci√≥n muy costosa. Por ejemplo, en x86 requiere m√°s de 10 ciclos de reloj. Adem√°s, las operaciones de divisi√≥n de enteros no siempre se canalizan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvemos a escribir nuestra f√≥rmula en forma equivalente </font></font><br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera divisi√≥n no es un problema. Podemos precalcular </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por adelantado. Pero la segunda divisi√≥n sigue siendo dolorosa. Para deshacernos de √©l, elija </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">igual a la potencia de dos. Despu√©s de eso, la segunda divisi√≥n puede ser reemplazada por un cambio de bit, una operaci√≥n simple y r√°pida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© tan grande puedes elegir?</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Desafortunadamente, </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no puede ser arbitrariamente grande. Est√° limitado por la condici√≥n de que la multiplicaci√≥n en el numerador no debe conducir a un desbordamiento del tipo de 64 bits. S√≠, queremos usar solo tipos "nativos". Nuevamente, para mantener los gastos generales de conversi√≥n al m√≠nimo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora veamos qu√© tan grande puede ser </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en nuestro ejemplo espec√≠fico. Supongamos que queremos trabajar con intervalos de tiempo de hasta un a√±o. Durante el a√±o, TSC tiknet los siguientes tiempos: </font></font><code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Divide un valor m√°ximo de n√∫mero de tipo de 64 bits es: </font></font><code>18446744073709551615 / 105109488000000000 ~ 175.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo tanto, la expresi√≥n </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no debe ser mayor que este valor. Entonces tenemos:</font></font><code>factor &lt;= 175.5 * 3.333 ~ 584.9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La potencia m√°s grande de dos que no excede este n√∫mero es 512. Por lo tanto, nuestra f√≥rmula de conversi√≥n toma la forma: </font></font><br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O </font></font><br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bien. Veamos ahora qu√© tiene esta f√≥rmula con precisi√≥n. Un a√±o contiene </font></font><code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nanosegundos. Nuestra f√≥rmula da: </font></font><code>105109488000000000 * 153 / 512 = 31409671218750000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La diferencia con el valor actual es 126328781250000 nanosegundos u </font></font><code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un gran error. Queremos una mejor precisi√≥n. ¬øQu√© pasa si medimos intervalos de tiempo de no m√°s de una hora? Omitir√© los c√°lculos. Son completamente id√©nticos a los que acabamos de hacer. La f√≥rmula final ser√°: </font></font><br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El error de conversi√≥n ser√° de solo 119,305 nanosegundos por 1 hora (que es menos de 0.2 milisegundos). Muy muy bien. Si el valor convertible m√°ximo es incluso menos de una hora, entonces la precisi√≥n ser√° a√∫n mejor. ¬øPero c√≥mo usamos esto? ¬øNo limite las mediciones de tiempo a una hora? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prestemos atenci√≥n al siguiente momento: </font></font><br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si calculamos </font></font><code>tsc_ticks_per_1_hour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos extraer </font></font><code>number_of_hours</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A continuaci√≥n, sabemos cu√°ntos nanosegundos hay en una hora. Por lo tanto, no ser√° dif√≠cil para nosotros traducir en nanosegundos esa parte </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que corresponde a un n√∫mero entero de horas. Para completar la conversi√≥n, necesitaremos traducir en nanosegundos</font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sin embargo, sabemos que este n√∫mero de garrapatas lleg√≥ en menos de una hora. Entonces, para convertirlo a nanosegundos, podemos usar la f√≥rmula (1).</font></font><br><br>  Listo<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal mecanismo de conversi√≥n nos conviene. Resumamos y optimicemos ahora. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, queremos tener un control flexible sobre los errores de conversi√≥n. No queremos vincular los par√°metros de conversi√≥n a un intervalo de tiempo de 1 hora. Sea un intervalo de tiempo arbitrario: una </font></font><br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez m√°s, recuerde c√≥mo convertir el resto a nanosegundos: </font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcule los par√°metros de conversi√≥n (lo sabemos </font></font><code>tsc_ticks_remainder &lt; modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">): en </font><font style="vertical-align: inherit;">aras de la tedio, debe tenerse en cuenta que la √∫ltima desigualdad no es equivalente a la primera en el marco de la aritm√©tica de enteros. Pero no me detendr√© en esto por mucho tiempo. Solo puedo decir que la √∫ltima desigualdad es m√°s severa que la primera y, por lo tanto, segura de usar. </font><font style="vertical-align: inherit;">Una vez obtenido de la √∫ltima desigualdad </font><font style="vertical-align: inherit;">, calculamos:</font></font><br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>shift</code><font style="vertical-align: inherit;"></font><br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y luego estos par√°metros se utilizan para convertir el resto a nanosegundos: </font><font style="vertical-align: inherit;">Entonces, descubrimos la conversi√≥n del resto. El siguiente problema que hay que resolver - es la eliminaci√≥n de </font><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">. Como siempre, queremos hacerlo r√°pido. Como siempre, no queremos usar la divisi√≥n. Por lo tanto, simplemente elegimos </font><font style="vertical-align: inherit;">igual a la potencia de dos: </font><font style="vertical-align: inherit;">Entonces:</font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br><font style="vertical-align: inherit;"></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"></font><code>number_of_moduli_periods</code><font style="vertical-align: inherit;"></font><code>tsc_ticks</code><font style="vertical-align: inherit;"></font><code>modulus</code><font style="vertical-align: inherit;"></font><br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br>  Genial<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora sabemos c√≥mo extraer de </font></font><code>tsc_ticks</code> <code>number_of_moduli_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Y sabemos c√≥mo convertir </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a nanosegundos. </font><font style="vertical-align: inherit;">Queda por comprender c√≥mo convertir esa parte de las garrapatas, que es un m√∫ltiplo, en nanosegundos </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero todo es simple: </font></font><br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede calcular por adelantado. </font><font style="vertical-align: inherit;">Adem√°s, de acuerdo con la misma f√≥rmula por la cual convertimos el resto. </font><font style="vertical-align: inherit;">Esta f√≥rmula se puede usar por per√≠odos de tiempo que no son m√°s largos </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√âl mismo </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por supuesto, no m√°s que </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br>  Eso es todo!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pudimos calcular todos los par√°metros necesarios para convertir las garrapatas a nanosegundos sobre la marcha. </font><font style="vertical-align: inherit;">Ahora resuma brevemente el procedimiento de conversi√≥n:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tenemos </font></font><code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este procedimiento, los par√°metros </font></font><code>remainder_bit_length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>modulus, ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avance c√°lculo previo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si todav√≠a est√°s leyendo esta publicaci√≥n, entonces eres genial o genial. </font><font style="vertical-align: inherit;">Incluso es posible que sea analista de rendimiento o desarrollador de software de alto rendimiento.</font></font><br><br>  Entonces aqu√≠.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resulta que todav√≠a no hemos terminado :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øRecuerdas c√≥mo calculamos el par√°metro </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Fue as√≠: </font></font><br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pregunta: ¬øde d√≥nde viene </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El n√∫mero de tics en un nanosegundo es un valor muy peque√±o. </font><font style="vertical-align: inherit;">De hecho, mi biblioteca se </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa en su </font><font style="vertical-align: inherit;">lugar </font></font><code>(tsc_per_sec / 1000000000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es decir: </font></font><br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y hay dos preguntas interesantes:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øD√≥nde conseguir estos </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con el primero. Fio ahora usa la cantidad de tics por milisegundo. Y hay problemas con eso. En la m√°quina, los par√°metros de los cuales me nombraron anteriormente </font></font><code>tsc_per_msec = 2599998</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mientras </font></font><code>tsc_per_sec = 2599998971</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si llevamos estos n√∫meros a una escala, su relaci√≥n ser√° muy cercana a la unidad: 0.999999626. Pero si usamos el primero, y no el segundo, entonces por cada segundo tendremos un error de 374 nanosegundos. Por lo tanto - </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s ... ¬øC√≥mo contar </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se realiza sobre la base de la medici√≥n directa: </font><font style="vertical-align: inherit;">"alg√∫n tiempo" es un par√°metro configurable. Puede ser m√°s grande, m√°s peque√±o o igual a un segundo. Digamos que es medio segundo. Supongamos adem√°s que la diferencia real entre </font><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">result√≥ ser 0.6 segundos. Entonces </font><font style="vertical-align: inherit;">.</font></font><br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br><font style="vertical-align: inherit;"></font><code>end_system_time</code><font style="vertical-align: inherit;"></font><code>start_system_time</code><font style="vertical-align: inherit;"></font><code>tsc_per_sec = (end_tsc ‚Äì start_tsc) / 0,6</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La biblioteca considera varios valores de esta manera </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Y luego, utilizando m√©todos est√°ndar, los "limpia" del ruido estad√≠stico y recibe un valor √∫nico en el </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se puede confiar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el diagrama de medici√≥n de tiempo anterior, el orden de las llamadas </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y es </font><font style="vertical-align: inherit;">importante </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es importante </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que transcurra el mismo tiempo entre dos llamadas que entre dos llamadas </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Entonces ser√° posible correlacionar f√°cilmente el tiempo del sistema con tics TSC. Y luego, la dispersi√≥n de valores </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede considerarse realmente aleatoria. Con este esquema de medici√≥n, los valores </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se desviar√°n del valor promedio en cualquier direcci√≥n con la misma probabilidad. Y ser√° posible aplicarles m√©todos de filtrado est√°ndar.</font></font><br><br><h3>  Conclusi√≥n </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiz√°s eso es todo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero el tema de la medici√≥n efectiva del tiempo no se limita a esto. </font><font style="vertical-align: inherit;">Hay muchos matices. </font><font style="vertical-align: inherit;">Para aquellos interesados, propongo trabajar de forma independiente en los siguientes temas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> almacenar par√°metros de conversi√≥n en cach√© o, mejor a√∫n, en registros </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øA qu√© l√≠mites se puede reducir </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(aumentando as√≠ la precisi√≥n de la conversi√≥n)?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como hemos visto, la precisi√≥n de la conversi√≥n se ve afectada no solo </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sino tambi√©n por el tama√±o del intervalo de tiempo, que se correlaciona con los ticks ( </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">¬øC√≥mo equilibrar la influencia de ambos factores?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSC en la m√°quina virtual. </font><font style="vertical-align: inherit;">¬øPuedo usarlo?</font></font></li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los m√©todos discutidos en este art√≠culo nos permiten medir la escala de tiempo de un segundo con una precisi√≥n del orden de varias decenas de nanosegundos. </font><font style="vertical-align: inherit;">Esta es la precisi√≥n que realmente observo cuando uso mi biblioteca. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, el fio, del cual tom√© prestados algunos m√©todos, pierde exactamente 700-900 nanosegundos en una segunda escala (y hay tres razones para esto). </font><font style="vertical-align: inherit;">Adem√°s, pierde velocidad de conversi√≥n debido al almacenamiento de tiempo en un formato est√°ndar de Linux. </font><font style="vertical-align: inherit;">Sin embargo, me apresuro a tranquilizar a los fan√°ticos del fio. </font><font style="vertical-align: inherit;">Envi√© a los desarrolladores una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descripci√≥n de todos los problemas de conversi√≥n que descubr√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La gente ya est√° trabajando, lo arreglar√°n pronto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Te deseo muchos nanosegundos agradables!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425237/">https://habr.com/ru/post/es425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425227/index.html">Los investigadores han encontrado una manera de detectar y omitir las claves Honeytoken en varios servicios de Amazon.</a></li>
<li><a href="../es425229/index.html">C√≥mo ayudamos a CDN MegaFon.TV a no llegar a la Copa Mundial 2018</a></li>
<li><a href="../es425231/index.html">Preguntas frecuentes sobre el trabajo de una azafata</a></li>
<li><a href="../es425233/index.html">Python 3 en Facebook</a></li>
<li><a href="../es425235/index.html">Un poco m√°s sobre gr√°ficos, o c√≥mo detectar dependencias entre sus aplicaciones</a></li>
<li><a href="../es425241/index.html">Desarrollador 20 a√±os despu√©s: Vasily Lebedev sobre ICRE, educaci√≥n, su libro y programaci√≥n.</a></li>
<li><a href="../es425243/index.html">El manual de john willis</a></li>
<li><a href="../es425245/index.html">Anuncio de RamblerFront & # 6</a></li>
<li><a href="../es425247/index.html">Crowdsourcing en pruebas</a></li>
<li><a href="../es425249/index.html">¬øC√≥mo es el conocimiento de LLP en la Universidad ITMO: el curso "Programaci√≥n de bajo nivel"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>