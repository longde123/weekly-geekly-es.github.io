<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìô ü§∑ üôà Betriebssysteme: Drei einfache Teile. Teil 4: Einf√ºhrung in den Scheduler (√úbersetzung) üôçüèæ üõÑ üôâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung in Betriebssysteme 
 Hallo Habr! Ich m√∂chte Sie auf eine Reihe von Artikel√ºbersetzungen einer meiner Meinung nach interessanten Literatur a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Betriebssysteme: Drei einfache Teile. Teil 4: Einf√ºhrung in den Scheduler (√úbersetzung)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449026/"><h1>  Einf√ºhrung in Betriebssysteme </h1><br>  Hallo Habr!  Ich m√∂chte Sie auf eine Reihe von Artikel√ºbersetzungen einer meiner Meinung nach interessanten Literatur aufmerksam machen - OSTEP.  Dieser Artikel beschreibt ziemlich ausf√ºhrlich die Arbeit von Unix-√§hnlichen Betriebssystemen, n√§mlich die Arbeit mit Prozessen, verschiedenen Schedulern, Speicher und anderen √§hnlichen Komponenten, aus denen das moderne Betriebssystem besteht.  Das Original aller Materialien k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen</a> .  Bitte beachten Sie, dass die √úbersetzung unprofessionell (ziemlich frei) durchgef√ºhrt wurde, aber ich hoffe, dass ich die allgemeine Bedeutung beibehalten habe. <br><br>  Laborarbeiten zu diesem Thema finden Sie hier: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine pers√∂nliche Anpassung</a> </li></ul><br>  Andere Teile: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Intro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Abstraktion: der Prozess</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Einf√ºhrung in die Prozess-API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Einf√ºhrung in den Scheduler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: MLFQ Scheduler</a> </li></ul><br>  Und du kannst meinen Kanal im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm</a> ansehen =) <br><a name="habracut"></a><br><h2>  Einf√ºhrung in den Scheduler </h2><br>  <u>Das Wesentliche des Problems: Wie man eine Planerpolitik entwickelt</u> <u><br></u>  <u>Wie sollten die grundlegenden Frameworks f√ºr Scheduler-Richtlinien entwickelt werden?</u>  <u>Was sollten die wichtigsten Annahmen sein?</u>  <u>Welche Metriken sind wichtig?</u>  <u>Welche grundlegenden Techniken wurden im fr√ºhen Computing verwendet?</u> <br><br><h3>  Annahmen zur Arbeitsbelastung </h3><br>  Bevor wir m√∂gliche Richtlinien diskutieren, werden wir zun√§chst einige vereinfachende Abweichungen von den im System ausgef√ºhrten Prozessen vornehmen, die zusammen als <b>Workload bezeichnet werden</b> .  Indem Sie eine Arbeitslast als wichtigen Bestandteil der Erstellung von Richtlinien definieren und je mehr Sie √ºber die Arbeitslast wissen, desto besser k√∂nnen Sie Richtlinien schreiben. <br><br>  Wir machen die folgenden Annahmen √ºber die im System laufenden Prozesse, manchmal auch <b>Jobs</b> (Tasks) genannt.  Fast alle diese Annahmen sind nicht realistisch, aber f√ºr die Entwicklung des Denkens notwendig. <br><br><ol><li>  Jede Aufgabe l√§uft gleich lange. </li><li>  Alle Aufgaben werden gleichzeitig eingestellt, </li><li>  Die Aufgabe bis zu ihrem Abschluss, </li><li>  Alle Aufgaben verwenden nur die CPU, </li><li>  Die Laufzeit jeder Aufgabe ist bekannt. </li></ol><br><h3>  Scheduler-Metriken </h3><br>  Zus√§tzlich zu einigen Annahmen zur Auslastung ben√∂tigen Sie ein weiteres Tool zum Vergleichen verschiedener Planungsrichtlinien: die Scheduler-Metriken.  Eine Metrik ist nur ein Ma√ü f√ºr etwas.  Es gibt eine Reihe von Metriken, mit denen Planer verglichen werden k√∂nnen. <br><br>  Zum Beispiel werden wir eine Metrik verwenden, die als Bearbeitungszeit bezeichnet wird.  Die Bearbeitungszeit einer Aufgabe ist definiert als die Differenz zwischen der Zeit, die zum Ausf√ºhren der Aufgabe ben√∂tigt wird, und der Zeit, zu der die Aufgabe in das System eingeht. <br><br>  <u>Tturnaround = Tcompletion - Tarrival</u> <br><br>  Da wir davon ausgegangen sind, dass alle Aufgaben gleichzeitig angekommen sind, ist Ta = 0 und damit Tt = Tc.  Dieser Wert wird sich nat√ºrlich √§ndern, wenn wir die obigen Annahmen √§ndern. <br><br>  Eine andere Metrik ist <b>Fairness</b> (Fairness, Ehrlichkeit).  Produktivit√§t und Ehrlichkeit sind oft gegens√§tzliche Merkmale in der Planung.  Beispielsweise kann ein Scheduler die Leistung optimieren, jedoch auf Kosten des Wartens auf die Ausf√ºhrung anderer Aufgaben, wodurch die Integrit√§t verringert wird. <br><br><h3>  FIRST IN FIRST OUT (FIFO) </h3><br>  Der grundlegendste Algorithmus, den wir implementieren k√∂nnen, hei√üt FIFO oder <b>First Come (In), First Served (Out)</b> .  Dieser Algorithmus hat mehrere Vorteile: Er ist sehr einfach zu implementieren und entspricht all unseren Annahmen. Er erledigt die Aufgabe ziemlich gut. <br><br>  Betrachten Sie ein einfaches Beispiel.  Angenommen, 3 Aufgaben wurden gleichzeitig festgelegt.  Angenommen, Aufgabe A kam etwas fr√ºher als alle anderen, sodass sie fr√ºher als die anderen auf der Ausf√ºhrungsliste steht, genau wie B in Bezug auf C. Angenommen, jeder von ihnen dauert 10 Sekunden.  Was ist die durchschnittliche Zeit, um diese Aufgaben zu erledigen? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a43/acd/1b4a43acd8a0f18c24bbdd831529bbda.jpg" alt="Bild"><br><br>  Wenn wir die Werte 10 + 20 + 30 z√§hlen und durch 3 teilen, erhalten wir eine durchschnittliche Ausf√ºhrungszeit des Programms von 20 Sekunden. <br><br>  Versuchen wir nun, unsere Annahmen zu √§ndern.  Insbesondere Annahme 1, und daher gehen wir nicht mehr davon aus, dass jede Aufgabe dieselbe Zeit ben√∂tigt.  Wie wird sich das FIFO diesmal zeigen? <br><br>  Wie sich herausstellt, wirken sich unterschiedliche Ausf√ºhrungszeiten von Aufgaben √§u√üerst negativ auf die Produktivit√§t des FIFO-Algorithmus aus.  Angenommen, Aufgabe A wird 100 Sekunden lang ausgef√ºhrt, w√§hrend B und C jeweils noch 10 sind. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/bee/3fe/a7abee3fefd7a0cf481d0322f40e732f.jpg" alt="Bild"><br><br>  Wie aus der Abbildung ersichtlich ist, betr√§gt die durchschnittliche Zeit f√ºr das System (100 + 110 + 120) / 3 = 110.  Dieser Effekt wird als <b>Konvoieffekt bezeichnet</b> , wenn einige kurzfristige Verbraucher einer Ressource nach einem starken Verbraucher in einer Linie stehen.  Es sieht aus wie ein Lebensmittelgesch√§ft, wenn ein Kunde mit einem vollen Wagen vor Ihnen steht.  Die beste L√∂sung f√ºr das Problem ist, zu versuchen, die Kassiererin zu wechseln oder sich zu entspannen und tief zu atmen. <br><br><h3>  K√ºrzester Job zuerst </h3><br>  Ist es m√∂glich, eine √§hnliche Situation mit schweren Prozessen zu l√∂sen?  Nat√ºrlich.  Eine andere Art der Planung wird als <b>Shortest Job First</b> (SJF) bezeichnet.  Sein Algorithmus ist auch ziemlich primitiv - wie der Name schon sagt, werden die k√ºrzesten Aufgaben zuerst nacheinander gestartet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/feb/207/778feb20723fa2d019620b97d27f2830.jpg" alt="Bild"><br><br>  In diesem Beispiel f√ºhrt das Starten derselben Prozesse zu einer Verbesserung der durchschnittlichen Durchlaufzeit der Programme und zu <b>50 statt 110</b> , was fast zweimal besser ist. <br><br>  Unter der gegebenen Annahme, dass alle Aufgaben zur gleichen Zeit eintreffen, scheint der SJF-Algorithmus der optimalste Algorithmus zu sein.  Unsere Annahmen erscheinen jedoch immer noch nicht realistisch.  Dieses Mal √§ndern wir die Annahme 2 und stellen uns diesmal vor, dass Aufgaben jederzeit und nicht alle gleichzeitig ausgef√ºhrt werden k√∂nnen.  Zu welchen Problemen kann dies f√ºhren? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/484/6df/332/4846df332de36b42bf891e167ef3f751.jpg" alt="Bild"><br><br>  Stellen Sie sich vor, dass Aufgabe A (100s) zuerst eintrifft und ausgef√ºhrt wird.  Zum Zeitpunkt t = 10 treffen die Aufgaben B, C ein, von denen jede 10 Sekunden dauert.  Die durchschnittliche Ausf√ºhrungszeit betr√§gt also (100+ (110-10) + (120-10)) \ 3 = 103. Was k√∂nnte der Planer tun, um die Situation zu verbessern? <br><br><h3>  K√ºrzeste Zeit bis zur Fertigstellung zuerst (STCF) </h3><br>  Um die Situation zu verbessern, lassen wir die Annahme 3 weg, dass das Programm bis zum Abschluss l√§uft.  Dar√ºber hinaus ben√∂tigen wir Hardware-Unterst√ºtzung, und wie Sie vielleicht vermutet haben, verwenden wir einen <b>Timer,</b> um eine Arbeitsaufgabe zu unterbrechen und den <b>Kontext zu wechseln</b> .  Somit kann der Scheduler zum Zeitpunkt des Eintreffens der Tasks B und C etwas tun - die Ausf√ºhrung von Task A stoppen und die Tasks B und C in die Verarbeitung einbeziehen und nach Abschluss den Prozess A fortsetzen. Dieser Scheduler wird als <b>STCF</b> oder <b>Preemptive Job First bezeichnet</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0eb/900/a1f/0eb900a1f8b96a0952061727037faf4f.jpg" alt="Bild"><br><br>  Das Ergebnis dieses Schedulers ist das folgende: ((120-0) + (20-10) + (30-10)) / 3 = 50.  Somit wird ein solcher Scheduler f√ºr unsere Aufgaben noch optimaler. <br><br><h3>  Metrische Antwortzeit </h3><br>  Wenn wir also die Laufzeit der Aufgaben kennen und wissen, dass diese Aufgaben nur die CPU verwenden, ist STCF die beste L√∂sung.  Und einmal in den fr√ºhen Tagen funktionierten diese Algorithmen und ziemlich gut.  Jetzt verbringt der Benutzer jedoch die meiste Zeit am Terminal und erwartet von ihm eine produktive interaktive Interaktion.  So wurde eine neue Metrik geboren - <b>Antwortzeit</b> (Antwort). <br><br>  Die Reaktionszeit wird wie folgt berechnet: <br><br>  <u>Tresponse = Tfirstrun - Tarrival</u> <br><br>  F√ºr das vorherige Beispiel ist die Antwortzeit also wie folgt: A = 0, B = 0, B = 10 (abg = 3,33). <br><br>  Und es stellt sich heraus, dass der STCF-Algorithmus in einer Situation, in der 3 Aufgaben gleichzeitig eintreffen, nicht so gut ist - er muss warten, bis die kleinen Aufgaben vollst√§ndig abgeschlossen sind.  Somit ist der Algorithmus gut f√ºr die Durchlaufzeitmetrik, aber schlecht f√ºr die Interaktivit√§tsmetrik.  Stellen Sie sich vor, Sie m√ºssten am Terminal sitzen und versuchen, Zeichen in den Editor einzugeben. Sie m√ºssten mehr als 10 Sekunden warten, da eine andere Aufgabe vom Prozessor belegt wird.  Das ist nicht sehr angenehm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="Bild"><br><br>  Wir stehen also vor einem anderen Problem: Wie k√∂nnen wir einen Scheduler erstellen, der empfindlich auf die Antwortzeit reagiert? <br><br><h3>  Round Robin </h3><br>  Um dieses Problem zu l√∂sen, wurde der <b>Round Robin</b> (RR) -Algorithmus entwickelt.  Die Grundidee ist ganz einfach: Anstatt Aufgaben bis zum Abschluss zu starten, starten wir die Aufgabe f√ºr einen bestimmten Zeitraum (als Zeitquant bezeichnet) und wechseln dann aus der Warteschlange zu einer anderen Aufgabe.  Der Algorithmus wiederholt seine Arbeit, bis alle Aufgaben abgeschlossen sind.  In diesem Fall muss die Programmlaufzeit ein Vielfaches der Zeit sein, nach der der Timer den Prozess unterbricht.  Wenn der Timer beispielsweise den Prozess alle x = 10 ms unterbricht, sollte die Gr√∂√üe des Prozessausf√ºhrungsfensters ein Vielfaches von 10 und 10,20 oder x * 10 sein. <br><br>  Schauen wir uns ein Beispiel an: Aufgaben von ABV kommen gleichzeitig im System an und jeder von ihnen m√∂chte 5 Sekunden lang arbeiten.  Der SJF-Algorithmus f√ºhrt jede Aufgabe bis zum Ende aus, bevor eine andere gestartet wird.  Im Gegensatz dazu durchl√§uft der RR-Algorithmus mit dem Startfenster = 1s die Aufgaben wie folgt (Abb. 4.3): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="Bild"><br>  <i>(SJF erneut (schlecht f√ºr die Reaktionszeit)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e40/351/12e/e4035112ea5d27958b0e099ed19a6c41.jpg" alt="Bild"><br>  <i>(Round Robin (gut f√ºr die Reaktionszeit)</i> <br><br>  Die durchschnittliche Antwortzeit f√ºr den Algorithmus betr√§gt RR (0 + 1 + 2) / 3 = 1, w√§hrend f√ºr SJF (0 + 5 + 10) / 3 = 5. <br><br>  Es ist logisch anzunehmen, dass das Zeitfenster ein sehr wichtiger Parameter f√ºr RR ist. Je kleiner es ist, desto h√∂her ist die Antwortzeit.  Sie k√∂nnen es jedoch nicht zu klein machen, da die Zeit zum Wechseln des Kontexts auch eine Rolle f√ºr die Gesamtleistung spielt.  Daher wird der Zeitpunkt des Ausf√ºhrungsfensters vom Betriebssystemarchitekten festgelegt und h√§ngt von den Aufgaben ab, deren Ausf√ºhrung darin geplant ist.  Das Wechseln des Kontexts ist nicht der einzige Dienstvorgang, der Zeit in Anspruch nimmt. Das laufende Programm arbeitet mit viel mehr, z. B. verschiedenen Caches, und jedes Mal muss diese Umgebung gespeichert und wiederhergestellt werden, was ebenfalls viel Zeit in Anspruch nehmen kann. <br><br>  RR ist ein gro√üartiger Planer, wenn es nur eine Antwortzeitmetrik war.  Aber wie verh√§lt sich die Metrik der Bearbeitungszeit der Aufgabe mit diesem Algorithmus?  Betrachten Sie das obige Beispiel, wenn die Betriebszeit A, B, C = 5s ist und zur gleichen Zeit ankommt.  Aufgabe A endet um 13 Uhr, B um 14 Uhr, C um 15 Uhr und die durchschnittliche Bearbeitungszeit betr√§gt 14 Sekunden.  Somit ist RR der schlechteste Algorithmus f√ºr Umsatzmetriken. <br><br>  Im Allgemeinen ist jeder Algorithmus wie RR ehrlich und teilt die f√ºr die CPU aufgewendete Zeit gleichm√§√üig auf alle Prozesse auf.  Und so stehen diese Metriken st√§ndig in Konflikt miteinander. <br><br>  Wir haben also mehrere entgegengesetzte Algorithmen und gleichzeitig bleiben einige Annahmen bestehen - dass die Taskzeit bekannt ist und dass die Task nur die CPU verwendet. <br><br><h3>  Mischen mit E / A. </h3><br>  Zun√§chst entfernen wir die Annahme 4, dass der Prozess nur die CPU verwendet, dies ist nat√ºrlich nicht der Fall, und die Prozesse k√∂nnen sich an andere Ger√§te wenden. <br><br>  Sobald ein Prozess eine E / A-Operation anfordert, wird der Prozess blockiert und wartet auf den Abschluss der E / A.  Wenn E / A an die Festplatte gesendet wird, kann ein solcher Vorgang bis zu mehreren ms oder l√§nger dauern, und der Prozessor ist in diesem Moment inaktiv.  Zu diesem Zeitpunkt kann der Scheduler den Prozessor durch einen anderen Prozess √ºbernehmen.  Die n√§chste Entscheidung, die der Scheduler treffen muss, ist, wenn der Prozess seine E / A abgeschlossen hat.  In diesem Fall tritt ein Interrupt auf und das Betriebssystem versetzt den E / A-Aufrufprozess in den Bereitschaftszustand. <br><br>  Betrachten Sie ein Beispiel f√ºr mehrere Aufgaben.  Jeder von ihnen ben√∂tigt 50 ms Prozessorzeit.  Der erste greift jedoch alle 10 ms auf E / A zu (was auch f√ºr 10 ms ausgef√ºhrt wird).  Und Prozess B verwendet einfach einen 50-ms-Prozessor ohne E / A. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50a/488/cae/50a488cae4476f65002df9ea966f9ef7.jpg" alt="Bild"><br><br>  In diesem Beispiel verwenden wir den STCF-Scheduler.  Wie verh√§lt sich der Scheduler, wenn Sie einen Prozess wie A darauf ausf√ºhren?  Er wird wie folgt vorgehen - zuerst A vollst√§ndig verarbeiten und dann B verarbeiten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/f5e/326/151f5e326437859d65d29541dbe0e94f.jpg" alt="Bild"><br><br>  Der traditionelle Ansatz zur L√∂sung dieses Problems besteht darin, jede 10-ms-Unteraufgabe von Prozess A als separate Aufgabe zu interpretieren.  Wenn mit dem STJF-Algorithmus begonnen wird, ist die Wahl zwischen einer 50-ms-Aufgabe und einer 10-ms-Aufgabe offensichtlich.  Wenn die Unteraufgabe A abgeschlossen ist, werden Prozess B und E / A gestartet.  Nach Abschluss der E / A ist es √ºblich, den 10-ms-Prozess A anstelle von Prozess B erneut zu starten. Somit ist es m√∂glich, eine √úberlappung zu realisieren, wenn die CPU von einem anderen Prozess verwendet wird, w√§hrend der erste auf E / A wartet.  Dadurch wird das System besser genutzt - in dem Moment, in dem interaktive Prozesse auf E / A warten, k√∂nnen andere Prozesse auf dem Prozessor ausgef√ºhrt werden. <br><br><h3>  Oracle ist nicht mehr </h3><br>  Versuchen wir nun, die Annahme loszuwerden, dass der Zeitpunkt der Aufgabe bekannt ist.  Dies ist im Allgemeinen die schlechteste und unrealistischste Annahme aus der gesamten Liste.  In durchschnittlichen Standardbetriebssystemen wei√ü das Betriebssystem selbst normalerweise nur sehr wenig √ºber die Zeit, die zum Ausf√ºhren von Aufgaben ben√∂tigt wird. Wie k√∂nnen Sie also einen Scheduler erstellen, ohne zu wissen, wie lange die Aufgabe dauern wird?  Vielleicht k√∂nnten wir einige der Prinzipien von RR verwenden, um dieses Problem zu l√∂sen? <br><br><h3>  Zusammenfassung </h3><br>  Wir haben die Grundideen der Aufgabenplanung untersucht und 2 Planerfamilien √ºberpr√ºft.  Die erste startet die k√ºrzeste Aufgabe am Anfang und erh√∂ht somit die Bearbeitungszeit, die zweite wird zwischen allen Aufgaben gleicherma√üen hin- und hergerissen, wodurch sich die Reaktionszeit erh√∂ht.  Beide Algorithmen sind schlecht, w√§hrend andere Familienalgorithmen gut sind.  Wir haben auch untersucht, wie die parallele Verwendung von CPU und E / A die Leistung verbessern kann, haben jedoch das Problem mit der Hellsichtigkeit des Betriebssystems nicht gel√∂st.  Und in der n√§chsten Lektion werden wir einen Planer betrachten, der in die nahe Vergangenheit schaut und versucht, die Zukunft vorherzusagen.  Und es wird als mehrstufige Feedback-Warteschlange bezeichnet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449026/">https://habr.com/ru/post/de449026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449012/index.html">Die Welt! Arbeit! iOS! Es lebe das Angebot f√ºr 1 Tag</a></li>
<li><a href="../de449014/index.html">Advance Ethereum DAPP</a></li>
<li><a href="../de449016/index.html">Steganographie im Dateisystem der optischen Scheibe</a></li>
<li><a href="../de449020/index.html">Analysieren des Codes der CUBA-Plattform mit PVS-Studio</a></li>
<li><a href="../de449022/index.html">CUBA Platform Code Analyse mit PVS-Studio</a></li>
<li><a href="../de449028/index.html">Wut, Verhandlungen und Depressionen bei der Arbeit mit InfluxDB</a></li>
<li><a href="../de449032/index.html">Wir entwickeln ein Sprinkler-Feuerl√∂schsystem</a></li>
<li><a href="../de449034/index.html">Citymobil - ein Handbuch zur Verbesserung der Verf√ºgbarkeit bei Unternehmenswachstum f√ºr Startups. Teil 1</a></li>
<li><a href="../de449036/index.html">Und wieder der Wolf im Schafspelz</a></li>
<li><a href="../de449040/index.html">Sicherheitswoche 17: Angriffe auf die Lieferkette</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>