<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏰 👩🏻‍⚕️ ⤴️ Kaspersky Mobile Talks # 1. Multimodularität ⛅️ 👩🏾‍🎓 💥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ende Februar haben wir ein neues Format für Meetings von Android-Entwicklern von Kaspersky Mobile Talks eingeführt . Der Hauptunterschied zu normalen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kaspersky Mobile Talks # 1. Multimodularität</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kaspersky/blog/446626/"><p>  Ende Februar haben wir ein neues Format für Meetings von Android-Entwicklern von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaspersky Mobile Talks eingeführt</a> .  Der Hauptunterschied zu normalen Besprechungen besteht darin, dass sich „erfahrene“ Entwickler anstelle von Hunderten von Zuhörern und schönen Präsentationen zu verschiedenen Themen versammelten, um nur ein Thema zu diskutieren: Wie sie Multimodularität in ihren Anwendungen implementieren, mit welchen Problemen sie konfrontiert sind und wie sie gelöst werden. </p><br><p><img src="https://habrastorage.org/webt/i5/da/5v/i5da5vzrshhino9ayx-a5e6ikkc.jpeg"></p><a name="habracut"></a><br><h2 id="soderzhanie">  Inhalt </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hintergrund</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mediatoren in HeadHunter.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Blinov</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tinkoff-Domain-Module</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vladimir Kokhanov, Alexander Zhukov</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wirkungsanalyse in Avito.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Evgeny Krivobokov, Mikhail Yudin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie in Tinkoff reduzierten sie die Montagezeit für PR von vierzig Minuten auf vier.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vladimir Kokhanov</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nützliche Links</a> </li></ol><br><a name="history"></a><br><p>  Bevor wir mit dem unmittelbaren Inhalt des Meetings im Büro von Kaspersky Lab fortfahren, erinnern wir uns, woher der Mod stammt, um die Anwendung in Module zu unterteilen (im Folgenden wird das Modul als Gradle-Modul und nicht als Dolch verstanden, sofern nicht anders angegeben). </p><br><p>  Das Thema Multimodularität beschäftigt die Android-Community seit Jahren.  Eine der Grundlagen kann als Bericht von Denis Neklyudov über den letztjährigen St. Petersburg "Mobius" angesehen werden.  Er schlug vor, die monolithische Anwendung, die lange Zeit kein Thin Client mehr war, in Module zu unterteilen, um die Erstellungsgeschwindigkeit zu erhöhen. <br>  Link zum Bericht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Präsentation</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> </p><br><p>  Dann gab es einen Bericht von Vladimir Tagakov von Yandex.Maps über das Verknüpfen von Modulen mit Dagger.  Somit lösen sie das Problem, eine einzelne Komponente von Karten für die Wiederverwendung in vielen anderen Yandex-Anwendungen zuzuweisen. <br>  Link zum Bericht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Präsentation</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> </p><br><p>  Auch Kaspersky Lab hat sich dem Trend nicht entzogen: Im September schrieb Evgeni Matsyuk einen Artikel darüber, wie man Module mit Dagger verbindet und gleichzeitig eine Architektur mit mehreren Modulen horizontal erstellt, ohne zu vergessen, die Prinzipien der sauberen Architektur vertikal zu befolgen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Artikel</a> </p><br><p>  Und im Winter Mobius gab es zwei Berichte gleichzeitig.  Zuerst sprach Alexander Blinov über die Multimodularität in der HeadHunter-Anwendung mit Toothpick als DI, und direkt nach ihm sprach Artem Zinnatulin über die Schmerzen von mehr als 800 Modulen in Lyft.  Sasha begann über Multimodularität zu sprechen, um die Architektur der Anwendung zu verbessern und nicht nur die Montage zu beschleunigen. <br>  Blinov-Bericht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Präsentation</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> <br>  Zinnatulin-Bericht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> </p><br><p> Warum habe ich den Artikel mit einer Retrospektive begonnen?  Erstens hilft es Ihnen, das Thema besser zu studieren, wenn Sie zum ersten Mal über Multimodularität lesen.  Und zweitens begann die erste Rede bei unserem Treffen mit einer Mini-Präsentation von Alexey Kalaida von der Firma Stream, die zeigte, wie sie ihre Anwendung auf der Grundlage von Zhenyas Artikel in Module aufteilten (und einige Punkte schienen mir Vladimirs Ansatz ähnlich zu sein). </p><br><p>  Das Hauptmerkmal dieses Ansatzes war die Bindung an die Benutzeroberfläche: Jedes Modul ist als separater Bildschirm verbunden - ein Fragment, auf das Abhängigkeiten vom Haupt-App-Modul einschließlich des FragmentManager übertragen werden.  Zunächst versuchten Kollegen, Multimodularität durch Proxy-Injektoren zu implementieren, was Zhenya in dem Artikel vorschlug.  Dieser Ansatz schien jedoch überwältigend: Es gab Probleme, wenn ein Feature von einem anderen abhing, was wiederum vom dritten abhing - wir mussten für jedes Feature-Modul einen Proxy-Injektor schreiben.  Der auf UI-Komponenten basierende Ansatz ermöglicht es Ihnen, keine Injektoren zu schreiben, wodurch Abhängigkeiten auf der Abhängigkeitsebene von Zielfragmenten zugelassen werden. </p><br><p>  Die Hauptbeschränkungen dieser Implementierung: Ein Feature muss ein Fragment (oder eine andere Ansicht) sein.  das Vorhandensein verschachtelter Fragmente, was zu einer großen Kesselplatte führt.  Wenn ein Feature andere Features implementiert, sollte es der Abhängigkeitskarte hinzugefügt werden, die Dagger beim Kompilieren überprüft.  Wenn es viele solcher Merkmale gibt, treten zum Zeitpunkt der Verknüpfung des Abhängigkeitsgraphen Schwierigkeiten auf. </p><br><a name="hh"></a><br><p>  Nach Alexeys Bericht ergriff Alexander Blinov das Wort.  Seiner Meinung nach wäre eine an die Benutzeroberfläche gebundene Implementierung für DI-Container in Flutter geeignet.  Dann wechselte die Diskussion zu einer Diskussion mit mehreren Modulen in HeadHunter.  Der Zweck ihrer Unterteilung in Module war die Möglichkeit der architektonischen Isolierung von Merkmalen und der Erhöhung der Montagegeschwindigkeit. </p><br><p>  Vor der Aufteilung in Module ist eine Vorbereitung wichtig.  Zunächst können Sie ein Abhängigkeitsdiagramm erstellen - beispielsweise mit einem solchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tool</a> .  Dies wird dazu beitragen, Komponenten mit einer minimalen Anzahl von Abhängigkeiten zu isolieren und unnötige zu entfernen (Chop).  Erst danach können die am wenigsten verbundenen Komponenten zu Modulen ausgewählt werden. </p><br><p>  Alexander erinnerte sich an die wichtigsten Punkte, über die er bei Mobius ausführlicher sprach.  Eine der komplexen Aufgaben, die die Architektur berücksichtigen muss, ist die Wiederverwendung eines Moduls an verschiedenen Stellen in der Anwendung.  In dem Beispiel mit der hh-Bewerbung handelt es sich um ein Lebenslaufmodul, auf das sowohl für das Stellenlistenmodul (VacanciesList), wenn der Benutzer zu dem für diese Stelle eingereichten Lebenslauf wechselt, als auch für das Negativantwortmodul (Negotiation) zugegriffen werden sollte.  Aus Gründen der Klarheit habe ich das Bild, das Sasha auf einem Flipchart dargestellt hat, neu gezeichnet. </p><br><p><img src="https://habrastorage.org/webt/e8/yv/jj/e8yvjjob9amuir_xu9693i2qisk.png"></p><br><p>  Jedes Modul enthält zwei Hauptentitäten: Abhängigkeiten - die Abhängigkeiten, die dieses Modul benötigt, und API - die Methoden, die das Modul anderen Modulen zur Verfügung stellt.  Die Kommunikation zwischen den Modulen erfolgt über Mediatoren, die im Haupt-App-Modul eine flache Struktur aufweisen.  Jedes Feature hat eine Auswahl.  Die Mediatoren selbst sind in einem bestimmten MediatorManager im Projekt-App-Modul enthalten.  Im Code sieht es ungefähr so ​​aus: </p><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> MediatorManager { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> chatMediator: ChatMediator <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { ChatMediator() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someMediator: ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TechSupportMediator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SuppportComponent { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deps = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : SuppportComponentDependencies { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> getInternalChat{ MediatorManager.rootMediator.api.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openInternalChat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuppportComponent</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: SupportComponentApi = ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { SupportDI.keeper.installComponent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuppportComponentDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { scopeHolder.destroyCoordinator &lt; -ref count } }</code> </pre> <br><p>  Alexander versprach, in Kürze ein Plug-In zum Erstellen von Modulen in Android Studio zu veröffentlichen, mit dem das Kopieren und Einfügen in seinem Unternehmen beseitigt wird, sowie ein Beispiel für ein Konsolenprojekt mit mehreren Modulen. </p><br><p>  Weitere Fakten zu den aktuellen Ergebnissen der Trennung von hh-Anwendungsmodulen: </p><br><ul><li>  ~ 83 Funktionsmodule. </li><li>  Um einen A / B-Test durchzuführen, können Features auf Mediatorebene vollständig durch das Feature-Modul ersetzt werden. </li><li>  Die Grafik von Gradle Scan zeigt, dass nach der parallelen Kompilierung der Module ein ziemlich langwieriger Prozess zum Dexen der Anwendung stattfindet (in diesem Fall zwei: für Arbeitssuchende und Arbeitgeber): <br><img src="https://habrastorage.org/webt/4a/wj/xz/4awjxzwf4ohdfdayj7xt591ekf0.png"></li></ul><br><a name="tinkoff"></a><br><p>  Folgendes haben Alexander und Vladimir von Tinkoff das Wort ergriffen: <br>  Das Schema ihrer Multi-Modul-Architektur sieht folgendermaßen aus: <br><img src="https://habrastorage.org/webt/4x/p-/t0/4xp-t0r5xgdc2rhssvrzv0zqaco.png"></p><br><p>  Module sind in zwei Kategorien unterteilt: Funktionsmodule und Domänenmodule. <br>  Funktionsmodule enthalten Geschäftslogik- und UI-Funktionen.  Sie hängen von Domänenmodulen ab, können jedoch nicht voneinander abhängen. </p><br><p>  Domänenmodule enthalten Code für die Arbeit mit Datenquellen, dh einige Modelle, DAO (für die Arbeit mit der Datenbank), API (für die Arbeit mit dem Netzwerk) und Repositorys (kombinieren Sie die Arbeit von API und DAO).  Domänenmodule können im Gegensatz zu Feature-Modulen voneinander abhängen. </p><br><p>  Die Verbindung zwischen Domänen- und Feature-Modulen erfolgt vollständig innerhalb von Feature-Modulen (dh in der Terminologie von hh werden Abhängigkeiten und API-Abhängigkeiten von Domain-Modulen in den Feature-Modulen, die sie verwenden, vollständig aufgelöst, ohne dass zusätzliche Entitäten wie Mediatoren verwendet werden müssen). </p><br><p>  Es folgte eine Reihe von Fragen, die ich hier im Format „Frage-Antwort“ fast unverändert stellen werde: </p><br><blockquote>  - Wie erfolgt die Autorisierung?  Wie zieht man es in Feature-Module? <br>  - Funktionen bei uns hängen nicht von der Autorisierung ab, da fast alle Aktionen der Anwendung in der autorisierten Zone ausgeführt werden. <br><br>  - Wie können nicht verwendete Komponenten verfolgt und gereinigt werden? <br>  - Wir haben eine Entität wie InjectorRefCount (implementiert über WeakHashMap), die beim Löschen der letzten Aktivität (oder des letzten Fragments) mit dieser Komponente diese löscht. <br><br>  - Wie misst man eine "saubere" Scan- und Erstellungszeit?  Wenn die Caches eingeschaltet sind, wird ein ziemlich schmutziger Scan erhalten. <br>  - Sie können den Gradle-Cache deaktivieren (org.gradle.caching in gradle.properties). <br><br>  - Wie werden Unit-Tests von allen Modulen im Debug-Modus ausgeführt?  Wenn Sie nur einen Gradle-Test ausführen, werden Tests aller Geschmacksrichtungen und BuildType abgerufen. <br>  (Diese Frage löste die Diskussion vieler Teilnehmer des Treffens aus.) <br>  - Sie können versuchen, testDebug auszuführen. <br>  - Dann werden Module, für die es keine Debug-Konfiguration gibt, nicht festgezogen.  Es beginnt entweder zu viel oder zu wenig. <br>  - Sie können eine Gradle-Aufgabe schreiben, die testDebug für solche Module überschreibt, oder eine gefälschte Debug-Konfiguration im Modul build.gradle vornehmen. <br>  - Sie können diesen Ansatz folgendermaßen implementieren: </blockquote><br><pre> <code class="plaintext hljs">withAndroidPlugin(project) { _, applicationExtension -&gt; applicationExtension.testVariants.all { testVariant -&gt; val testVariantSuffix = testVariant.testedVariant.name.capitalize() } } val task = project.tasks.register &lt; SomeTask &gt; ( "doSomeTask", SomeTask::class.java ) { task.dependsOn("${project.path}:taskName$testVariantSuffix") }</code> </pre> <br><p><img src="https://habrastorage.org/webt/oy/gc/68/oygc68_brbzgxgzfh_wztse_na8.jpeg"></p><br><a name="avito"></a><br><p>  Die nächste improvisierte Präsentation wurde von Evgeny Krivobokov und Mikhail Yudin aus Avito gemacht. <br>  Sie verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mindmap</a> , um ihre Geschichte zu visualisieren. </p><br><p>  Jetzt umfasst das Projekt des Unternehmens&gt; 300 Module, wobei 97% der Codebasis in Kotlin geschrieben sind.  Der Hauptzweck der Aufteilung in Module bestand darin, die Montage des Projekts zu beschleunigen.  Die Aufteilung in Module erfolgte schrittweise, wobei die am wenigsten abhängigen Teile des Codes den Modulen zugewiesen wurden.  Zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweck</a> wurde ein Tool zum Markieren der Abhängigkeiten von Quellcodes in der Grafik für die Auswirkungsanalyse entwickelt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht über die Auswirkungsanalyse in Avito</a> ). </p><br><p>  Mit diesem Tool können Sie ein Feature-Modul als endgültig markieren, sodass andere Module nicht davon abhängen können.  Diese Eigenschaft wird während der Auswirkungsanalyse überprüft und enthält eine Bezeichnung für explizite Abhängigkeiten und Vereinbarungen mit den Teams, die für das Modul verantwortlich sind.  Basierend auf dem erstellten Diagramm wird auch die Verteilung der Änderungen überprüft, um Komponententests für den betroffenen Code auszuführen. </p><br><p>  Das Unternehmen verwendet ein Mono-Repository, jedoch nur für Android-Quellen.  Der Code anderer Plattformen lebt separat. </p><br><p>  Gradle wird zum Erstellen des Projekts verwendet (obwohl Kollegen bereits an einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Builder</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buck</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bazel</a> denken, der für Projekte mit mehreren Modulen besser geeignet ist).  Sie haben bereits Kotlin DSL ausprobiert und sind dann in Gradle-Skripten zu Groovy zurückgekehrt, da es unpraktisch ist, verschiedene Versionen von Kotlin in Gradle und im Projekt zu unterstützen - die allgemeine Logik wird in Plugins integriert. </p><br><p>  Gradle kann Aufgaben parallelisieren, zwischenspeichern und binäre Abhängigkeiten nicht neu kompilieren, wenn sich ihr ABI nicht geändert hat, was eine schnellere Zusammenstellung eines Projekts mit mehreren Modulen gewährleistet.  Für ein effizienteres Caching werden Mainfraimer und mehrere selbstgeschriebene Lösungen verwendet: </p><br><ul><li>  Beim Wechsel von Zweig zu Zweig hinterlässt Git möglicherweise leere Ordner, die das Caching <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterbrechen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gradle-Problem Nr. 2463</a> ).  Daher werden sie manuell mit dem Git-Hook gelöscht. </li><li>  Wenn Sie die Umgebung auf den Computern der Entwickler nicht steuern, können verschiedene Versionen des Android SDK und andere Parameter das Caching beeinträchtigen.  Während der Erstellung des Projekts vergleicht das Skript die Umgebungsparameter mit den erwarteten: Wenn die falschen Versionen oder Parameter installiert sind, wird die Erstellung gelöscht. </li><li>  Analytics aktiviert / deaktiviert Parameter und die Umgebung.  Dies dient zur Überwachung und Unterstützung von Entwicklern. </li><li>  Build-Fehler werden auch an Analytics gesendet.  Bekannte und beliebte Probleme werden auf einer speziellen Seite mit einer Lösung eingetragen. </li></ul><br><p>  All dies trägt dazu bei, 15% Cache-Fehler bei CI und 60-80% lokal zu erzielen. </p><br><p>  Die folgenden Gradle-Tipps können auch nützlich sein, wenn in Ihrem Projekt eine große Anzahl von Modulen angezeigt wird: </p><br><ul><li>  Das Deaktivieren von Modulen über IDE-Flags ist unpraktisch. Diese Flags können zurückgesetzt werden.  Daher werden Module über settings.gradle deaktiviert. </li><li>  In Studio 3.3.1 gibt es ein Kontrollkästchen "Quellengenerierung bei Gradle-Synchronisierung überspringen, wenn ein Projekt mehr als 1 Module enthält".  Standardmäßig ist es ausgeschaltet, es ist besser, es einzuschalten. </li><li>  Abhängigkeiten werden in buildSrc registriert, um in allen Modulen wiederverwendet zu werden.  Eine andere Option ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugins DSL</a> , aber dann können Sie die Anwendung des Plugins nicht in einer separaten Datei ablegen. </li></ul><br><a name="pr4"></a><br><p>  Unser Treffen endete mit Vladimir von Tinkoff mit dem Clickbait-Titel des Berichts <strong>„Wie man die PR-</strong> Versammlung <strong>von 40 Minuten auf vier Minuten reduziert“.</strong>  Tatsächlich sprachen wir über die Verteilung der Starts von Gradle-Plugs: Apk-Builds, Tests und statische Analysatoren. </p><br><p>  Zunächst führten die Mitarbeiter bei jeder Pull-Anfrage eine statische Analyse durch, direkt die Montage und die Tests.  Dieser Vorgang dauerte 40 Minuten, von denen nur Lint und SonarQube 25 Minuten dauerten und nur 7% der Starts fielen. </p><br><p>  Daher wurde beschlossen, den Start in einen separaten Job zu verschieben, der alle zwei Stunden nach einem Zeitplan ausgeführt wird und im Fehlerfall eine Nachricht an Slack sendet. </p><br><p>  Die umgekehrte Situation war die Verwendung von Detect.  Es stürzte fast ständig ab, weshalb es einem vorläufigen Pre-Push-Check unterzogen wurde. </p><br><p>  Daher blieben nur die apk-Montage- und Komponententests bei der Überprüfung der Pull-Anforderung übrig.  Tests kompilieren die Quellen vor dem Ausführen, sammeln jedoch keine Ressourcen.  Da die Zusammenführung von Ressourcen fast immer erfolgreich war, wurde auch die apk-Versammlung selbst aufgegeben. </p><br><p>  Infolgedessen blieb nur der Start von Unit-Tests auf der Pull-Anfrage, wodurch wir die angegebenen 4 Minuten erreichen konnten.  Build apk wird mit Merger Pull Request in dev ausgeführt. </p><br><a name="end"></a><br><p>  Trotz der Tatsache, dass das Meeting fast 4 Stunden dauerte, konnten wir das brennende Problem der Organisation der Navigation in einem Projekt mit mehreren Modulen nicht diskutieren.  Vielleicht ist dies das Thema für die nächsten Kaspersky Mobile Talks.  Außerdem hat den Teilnehmern das Format sehr gut gefallen.  Sagen Sie uns, worüber Sie in der Umfrage oder in den Kommentaren sprechen möchten. </p><br><p>  Und schließlich nützliche Links aus demselben Chat: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monolith-Konnektivitätsdiagrammdefinition</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regeln zum Schreiben von Code in hh und Dienstprogramme zur Unterstützung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mirakle - Plugin zum Übertragen von Builds auf den Mainframe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umfrageergebnisse zur Modularisierung von Android-Anwendungen</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446626/">https://habr.com/ru/post/de446626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446614/index.html">Virtuelle Linux-Dateisysteme: Warum werden sie benötigt und wie funktionieren sie? Teil 1</a></li>
<li><a href="../de446616/index.html">Wie wir Cloud FaaS in Kubernetes gemacht und beim Tinkoff Hackathon gewonnen haben</a></li>
<li><a href="../de446620/index.html">DataGrip 2019.1: Unterstützung für neue Datenbanken, Initialisierungsskripte, neue Inspektionen und mehr</a></li>
<li><a href="../de446622/index.html">Nachrichten um 11</a></li>
<li><a href="../de446624/index.html">Indizes in PostgreSQL - 6 (SP-GiST)</a></li>
<li><a href="../de446628/index.html">Geben Sie mehr HighLoad ++: ab Montag in St. Petersburg</a></li>
<li><a href="../de446630/index.html">Wie man einen 3D-Drucker auswählt oder warum man einen Heiztisch und eine geschlossene Kamera benötigt</a></li>
<li><a href="../de446632/index.html">Vom Gesetz zur Big Data-Entwicklung</a></li>
<li><a href="../de446634/index.html">SDN Digest - Sechs Open Source Emulatoren</a></li>
<li><a href="../de446638/index.html">Cisco HyperFlex vs. Wettbewerber: Testleistung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>