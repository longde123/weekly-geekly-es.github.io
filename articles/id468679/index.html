<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§™ğŸ» ğŸ¦ ğŸ• ABC Keamanan di Kubernetes: Otentikasi, Otorisasi, Audit ğŸ§• ğŸ‘ŒğŸ¾ â¸ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cepat atau lambat, pengoperasian sistem apa pun menimbulkan pertanyaan tentang keamanan: memastikan otentikasi, pemisahan hak, audit, dan tugas lainny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ABC Keamanan di Kubernetes: Otentikasi, Otorisasi, Audit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/468679/"><img src="https://habrastorage.org/webt/ao/pp/ke/aoppkeeufk5-tv1rmtmtw9oce7a.png"><br><br>  Cepat atau lambat, pengoperasian sistem apa pun menimbulkan pertanyaan tentang keamanan: memastikan otentikasi, pemisahan hak, audit, dan tugas lainnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Banyak solusi yang</a> telah dibuat untuk Kubernetes yang dapat mencapai kepatuhan dengan standar bahkan dalam lingkungan yang sangat menuntut ... Materi yang sama dikhususkan untuk aspek keamanan dasar yang diimplementasikan dalam kerangka mekanisme built-in K8.  Pertama-tama, ini akan berguna bagi mereka yang mulai berkenalan dengan Kubernetes, sebagai titik awal untuk mempelajari masalah-masalah yang berkaitan dengan keamanan. <a name="habracut"></a><br><br><h2>  Otentikasi </h2><br>  Kubernetes memiliki dua jenis pengguna: <br><br><ul><li>  <i>Akun Layanan</i> - akun yang dikelola oleh Kubernetes API; </li><li>  <i>Pengguna</i> - <i>pengguna</i> "normal" yang dikendalikan oleh layanan eksternal dan independen. </li></ul><br>  Perbedaan utama antara jenis-jenis ini adalah bahwa untuk Akun Layanan ada objek khusus di API Kubernetes (mereka disebut <code>ServiceAccounts</code> ) yang terkait dengan namespace dan kumpulan data otorisasi yang disimpan dalam cluster di objek-objek tipe Rahasia.  Pengguna tersebut (Akun Layanan) dimaksudkan terutama untuk mengelola hak akses ke proses API Kubernetes yang berjalan di cluster Kubernetes. <br><br>  Pengguna Biasa tidak memiliki entri dalam Kubernetes API: mereka harus dikelola oleh mekanisme eksternal.  Mereka dimaksudkan untuk orang atau proses yang hidup di luar cluster. <br><br>  Setiap permintaan ke API terikat baik ke Akun Layanan, atau ke Pengguna, atau dianggap anonim. <br><br>  Data otentikasi pengguna meliputi: <br><br><ul><li>  <i>Nama pengguna</i> - nama pengguna (peka huruf besar kecil!); </li><li>  <i>UID</i> adalah string identifikasi pengguna yang dapat dibaca mesin yang "lebih konsisten dan unik daripada nama pengguna"; </li><li>  <i>Grup</i> - daftar grup yang menjadi milik pengguna; </li><li>  <i>Ekstra</i> - bidang tambahan yang dapat digunakan oleh mekanisme otorisasi. </li></ul><br>  Kubernetes dapat menggunakan sejumlah besar mekanisme otentikasi: sertifikat X509, Bearer token, proxy otentikasi, HTTP Basic Auth.  Dengan menggunakan mekanisme ini, sejumlah besar skema otorisasi dapat diimplementasikan: dari file statis dengan kata sandi ke OpenID OAuth2. <br><br>  Selain itu, beberapa skema otorisasi diizinkan pada saat bersamaan.  Secara default, kluster menggunakan: <br><br><ul><li>  token akun layanan - untuk Akun Layanan; </li><li>  X509 - untuk Pengguna. </li></ul><br>  Pertanyaan tentang pengelolaan ServiceAccount berada di luar cakupan artikel ini, tetapi saya sarankan mulai mempelajari lebih lanjut tentang masalah ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman dokumentasi resmi</a> .  Kami akan mempertimbangkan secara lebih rinci masalah pekerjaan sertifikat X509. <br><br><h3>  Sertifikat untuk pengguna (X.509) </h3><br>  Cara klasik untuk bekerja dengan sertifikat melibatkan: <br><br><ul><li>  generasi kunci: <br><br><pre> <code class="bash hljs">mkdir -p ~/mynewuser/.certs/ openssl genrsa -out ~/.certs/mynewuser.key 2048</code> </pre> </li><li>  pembuatan permintaan sertifikat: <br><br><pre> <code class="bash hljs">openssl req -new -key ~/.certs/mynewuser.key -out ~/.certs/mynewuser.csr -subj <span class="hljs-string"><span class="hljs-string">"/CN=mynewuser/O=company"</span></span></code> </pre> </li><li>  memproses permintaan sertifikat menggunakan kunci CA kluster Kubernetes, memperoleh sertifikat pengguna (untuk mendapatkan sertifikat, Anda perlu menggunakan akun yang memiliki akses ke kunci otoritas sertifikat klaster Kubernetes, yang terletak di <code>/etc/kubernetes/pki/ca.key</code> secara default): <br><br><pre> <code class="bash hljs">openssl x509 -req -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ~/.certs/mynewuser.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out ~/.certs/mynewuser.crt -days 500</code> </pre> </li><li>  membuat file konfigurasi: <br><ul><li>  deskripsi cluster (tentukan alamat dan lokasi file sertifikat CA dari instalasi cluster tertentu): <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-cluster kubernetes --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.100.200:6443</code> </pre> </li><li>  atau - jika <b>bukan</b> opsi yang disarankan - Anda dapat menghilangkan sertifikat root (maka kubectl tidak akan memeriksa kebenaran cluster api-server): <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-cluster kubernetes --insecure-skip-tls-verify=<span class="hljs-literal"><span class="hljs-literal">true</span></span> --server=https://192.168.100.200:6443</code> </pre> </li><li>  menambahkan pengguna ke file konfigurasi: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-credentials mynewuser --client-certificate=.certs/mynewuser.crt --client-key=.certs/mynewuser.key</code> </pre> </li><li>  menambahkan konteks: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-context mynewuser-context --cluster=kubernetes --namespace=target-namespace --user=mynewuser</code> </pre> </li><li>  penetapan konteks default: <br><br><pre> <code class="bash hljs">kubectl config use-context mynewuser-context</code> </pre> </li></ul></li></ul><br>  Setelah manipulasi di atas, konfigurasi bentuk akan dibuat dalam file <code>.kube/config</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: - cluster: certificate-authority: /etc/kubernetes/pki/ca.crt server: https://192.168.100.200:6443 name: kubernetes contexts: - context: cluster: kubernetes namespace: target-namespace user: mynewuser name: mynewuser-context current-context: mynewuser-context kind: Config preferences: {} users: - name: mynewuser user: client-certificate: /home/mynewuser/.certs/mynewuser.crt client-key: /home/mynewuser/.certs/mynewuser.key</code> </pre> <br>  Untuk memfasilitasi transfer konfigurasi antara akun dan server, penting untuk mengedit nilai-nilai kunci berikut: <br><br><ul><li> <code>certificate-authority</code> </li> <li> <code>client-certificate</code> </li> <li> <code>client-key</code> </li> </ul><br>  Untuk melakukan ini, Anda bisa menyandikan file yang ditunjukkan di dalamnya menggunakan base64 dan mendaftarkannya di konfigurasi dengan menambahkan akhiran <code>-data</code> ke nama kunci, mis.  mendapatkan <code>certificate-authority-data</code> , dll. <br><br><h3>  Sertifikat dengan kubeadm </h3><br>  Dengan rilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes 1.15,</a> bekerja dengan sertifikat menjadi lebih mudah berkat versi alfa dukungannya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utilitas kubeadm</a> .  Sebagai contoh, inilah tampilan generasi file konfigurasi dengan kunci pengguna sekarang: <br><br><pre> <code class="bash hljs">kubeadm alpha kubeconfig user --client-name=mynewuser --apiserver-advertise-address 192.168.100.200</code> </pre> <br>  <i><b>NB</b> : <i>Alamat iklan yang</i> diperlukan dapat dilihat di konfigurasi api-server, yang terletak di <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> secara default.</i> <br><br>  Konfigurasi yang dihasilkan akan menjadi output ke stdout.  Itu harus disimpan dalam <code>~/.kube/config</code> akun pengguna atau dalam file yang ditentukan dalam <code>KUBECONFIG</code> lingkungan <code>KUBECONFIG</code> . <br><br><h3>  Gali lebih dalam </h3><br>  Bagi mereka yang ingin sepenuhnya memahami masalah yang dijelaskan: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terpisah</a> tentang bekerja dengan sertifikat dalam dokumentasi Kubernet resmi; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel bagus dari Bitnami</a> , yang membahas masalah sertifikat dari sudut pandang praktis. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> otentikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">umum</a> di Kubernetes. </li></ul><br><h2>  Login </h2><br>  Akun terotentikasi tidak memiliki izin untuk bertindak dalam gugus secara default.  Kubernetes memiliki mekanisme otorisasi untuk memberikan izin. <br><br>  Sebelum versi 1.6, Kubernetes menggunakan tipe otentikasi yang disebut <b>ABAC</b> (Kontrol akses berbasis atribut).  Rincian tentang itu dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> .  Pendekatan ini saat ini dianggap sebagai warisan, tetapi Anda masih dapat menggunakannya bersamaan dengan jenis otorisasi lainnya. <br><br>  Cara aktual (dan lebih fleksibel) untuk membagi hak akses cluster disebut <b>RBAC</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Role-based access control</a> ).  Telah dinyatakan stabil sejak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes 1.8</a> .  RBAC mengimplementasikan model hak yang melarang apa pun yang tidak diizinkan secara eksplisit. <br>  <b>Untuk mengaktifkan RBAC</b> , Anda perlu menjalankan server api Kubernetes dengan opsi <code>--authorization-mode=RBAC</code> .  Parameter diatur dalam manifes dengan konfigurasi api-server, yang secara default terletak di path <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> , di bagian <code>command</code> .  Namun, RBAC sudah diaktifkan secara default, jadi Anda mungkin tidak perlu khawatir tentang ini: Anda dapat memverifikasi ini dengan nilai <code>authorization-mode</code> (dalam <code>kube-apiserver.yaml</code> telah disebutkan).  Ngomong-ngomong, di antara nilainya, mungkin ada jenis otorisasi lain ( <code>node</code> , <code>webhook</code> , <code>always allow</code> ), tetapi kami akan membiarkannya di luar ruang lingkup materi. <br><br>  Ngomong-ngomong, kami telah menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> dengan cerita yang cukup terperinci tentang prinsip dan fitur bekerja dengan RBAC, jadi saya akan membatasi diri pada daftar dasar dan contoh singkat. <br><br>  Entitas API berikut digunakan untuk mengontrol akses ke Kubernetes melalui RBAC: <br><br><ul><li>  <code>Role</code> dan <code>ClusterRole</code> adalah peran yang menggambarkan hak istimewa: </li><li>  <code>Role</code> memungkinkan Anda untuk mendeskripsikan hak dalam ruang nama; </li><li>  <code>ClusterRole</code> - di dalam cluster, termasuk objek khusus-cluster seperti node, url non-sumber daya (mis. Tidak terkait dengan sumber daya Kubernetes - misalnya, <code>/version</code> , <code>/logs</code> , <code>/api*</code> ); </li><li>  <code>RoleBinding</code> dan <code>ClusterRoleBinding</code> - berfungsi untuk mengikat <code>Role</code> dan <code>ClusterRole</code> ke pengguna, grup pengguna, atau ServiceAccount. </li></ul><br>  Peran Entitas dan RoleBinding dibatasi oleh namespace, mis.  harus berada dalam namespace yang sama.  Namun, RoleBinding dapat merujuk ke ClusterRole, yang memungkinkan Anda membuat seperangkat izin standar dan mengontrol akses menggunakannya. <br><br>  Peran menjelaskan hak menggunakan set aturan yang mengandung: <br><br><ul><li>  Grup API - lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> untuk apiGroups dan output dari <code>kubectl api-resources</code> ; </li><li>  sumber daya ( <i>sumber daya</i> : <code>pod</code> , <code>namespace</code> , <code>deployment</code> , dll.); </li><li>  kata kerja ( <i>kata kerja</i> : <code>set</code> , <code>update</code> , dll.) </li><li>  nama sumber daya ( <code>resourceNames</code> ) - untuk kasus ketika Anda perlu memberikan akses ke sumber daya tertentu, dan bukan untuk semua sumber daya jenis ini. </li></ul><br>  Diskusi yang lebih rinci tentang otorisasi di Kubernetes dapat ditemukan di halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> .  Sebaliknya (atau lebih tepatnya, selain ini) saya akan memberikan contoh yang menggambarkan pekerjaannya. <br><br><h3>  Contoh Entitas RBAC </h3><br>  <code>Role</code> sederhana yang memungkinkan Anda untuk mendapatkan daftar dan status pod dan memonitornya di <code>target-namespace</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: target-namespace name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "watch", "list"]</code> </pre> <br>  Contoh dari <code>ClusterRole</code> , yang memungkinkan Anda untuk mendapatkan daftar dan status pod dan memonitor mereka di seluruh cluster: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: #  "namespace" ,   ClusterRole    name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "watch", "list"]</code> </pre> <br>  Contoh <code>RoleBinding</code> , yang memungkinkan pengguna <code>mynewuser</code> "membaca" pod di <code>my-namespace</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-pods namespace: target-namespace subjects: - kind: User name: mynewuser #     ! apiGroup: rbac.authorization.k8s.io roleRef: kind: Role #    â€œRoleâ€  â€œClusterRoleâ€ name: pod-reader #  Role,      namespace, #   ClusterRole,   #    apiGroup: rbac.authorization.k8s.io</code> </pre> <br><h2>  Audit Acara </h2><br>  Secara skematis, arsitektur Kubernetes dapat direpresentasikan sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/617/793/499/6177934998b4bf1c5c8816c75beaef3f.png" alt="gambar"><br><br>  Komponen utama Kubernetes, yang bertanggung jawab untuk memproses permintaan, adalah <b>api-server</b> .  Semua operasi pada cluster melewatinya.  Baca lebih lanjut tentang mekanisme internal ini di artikel â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang terjadi di Kubernetes ketika menjalankan kubectl dimulai?</a>  ". <br><br>  Audit sistem adalah fitur yang menarik di Kubernetes, yang dinonaktifkan secara default.  Ini memungkinkan Anda untuk mencatat semua panggilan ke API Kubernetes.  Seperti yang dapat Anda tebak dengan mudah, melalui API ini semua tindakan yang terkait dengan pemantauan dan perubahan status cluster dilakukan.  Deskripsi yang baik tentang fitur-fiturnya dapat (seperti biasa) ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> K8s.  Selanjutnya, saya akan mencoba menyajikan topik dalam bahasa yang lebih sederhana. <br><br>  Jadi, <b>untuk mengaktifkan audit</b> , kita perlu memberikan tiga parameter yang diperlukan ke kontainer di server api, lebih lanjut tentang yang dijelaskan di bawah ini: <br><br><ul><li> <code>--audit-policy-file=/etc/kubernetes/policies/audit-policy.yaml</code> </li> <li> <code>--audit-log-path=/var/log/kube-audit/audit.log</code> </li> <li> <code>--audit-log-format=json</code> </li> </ul><br>  Selain tiga parameter yang diperlukan ini, ada banyak pengaturan tambahan yang terkait dengan audit: dari rotasi log ke deskripsi webhook.  Contoh parameter rotasi log: <br><br><ul><li> <code>--audit-log-maxbackup=10</code> </li> <li> <code>--audit-log-maxsize=100</code> </li> <li> <code>--audit-log-maxage=7</code> </li> </ul><br>  Tetapi kami tidak akan membahasnya lebih detail - Anda dapat menemukan semua detail dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi untuk apachever kube</a> . <br><br>  Seperti yang telah disebutkan, semua parameter diatur dalam manifes dengan konfigurasi api-server (secara default <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> ), di bagian <code>command</code> .  Mari kita kembali ke 3 parameter yang diperlukan dan menganalisisnya: <br><br><ol><li>  <code>audit-policy-file</code> - path ke file YAML dengan deskripsi kebijakan audit.  Kami akan kembali ke isinya, tetapi untuk saat ini saya perhatikan bahwa file tersebut harus dapat diakses untuk dibaca oleh proses server api.  Oleh karena itu, perlu untuk memasangnya di dalam wadah, di mana Anda dapat menambahkan kode berikut ke bagian konfigurasi yang sesuai: <br><br><pre> <code class="plaintext hljs"> volumeMounts: - mountPath: /etc/kubernetes/policies name: policies readOnly: true volumes: - hostPath: path: /etc/kubernetes/policies type: DirectoryOrCreate name: policies</code> </pre> </li><li>  <code>audit-log-path</code> - path ke file log.  Path juga harus dapat diakses ke proses server api, oleh karena itu, kami juga menjelaskan pemasangannya: <br><br><pre> <code class="plaintext hljs"> volumeMounts: - mountPath: /var/log/kube-audit name: logs readOnly: false volumes: - hostPath: path: /var/log/kube-audit type: DirectoryOrCreate name: logs</code> </pre> </li><li>  <code>audit-log-format</code> - format log audit.  Secara default, ini <code>json</code> , tetapi format teks lawas juga tersedia. </li></ol><br><h3>  Kebijakan audit </h3><br>  Sekarang tentang file yang disebutkan dengan deskripsi kebijakan logging.  Konsep pertama kebijakan audit adalah <code>level</code> , <b>level logging</b> .  Mereka adalah sebagai berikut: <br><br><ul><li>  <code>None</code> - jangan login; </li><li>  <code>Metadata</code> - log permintaan metadata: pengguna, waktu permintaan, sumber daya target (pod, namespace, dll.), Jenis tindakan (kata kerja), dll; </li><li>  <code>Request</code> - log metadata dan body permintaan; </li><li>  <code>RequestResponse</code> - <code>RequestResponse</code> metadata, badan permintaan dan badan respons. </li></ul><br>  Dua level terakhir ( <code>Request</code> dan <code>RequestResponse</code> ) tidak mencatat permintaan yang tidak mengakses sumber daya (panggilan ke apa yang disebut url non-sumber daya). <br><br>  Juga, semua permintaan melalui <b>beberapa tahap</b> : <br><br><ul><li>  <code>RequestReceived</code> - tahap ketika permintaan diterima oleh pawang dan belum dipindahkan lebih jauh di sepanjang rantai pawang; </li><li>  <code>ResponseStarted</code> - header respons dikirim, tetapi sebelum mengirim badan respons.  Dihasilkan untuk kueri panjang (mis. <code>watch</code> ); </li><li>  <code>ResponseComplete</code> - badan respons dikirim, lebih banyak informasi tidak akan dikirim; </li><li>  <code>Panic</code> - events dihasilkan ketika keadaan darurat terdeteksi. </li></ul><br>  Anda dapat menggunakan <code>omitStages</code> untuk melewati tahapan apa pun. <br><br>  Dalam file kebijakan, kami dapat menjelaskan beberapa bagian dengan tingkat pencatatan yang berbeda.  Aturan pencocokan pertama yang ditemukan dalam uraian kebijakan akan berlaku. <br><br>  Daemon kubelet memonitor perubahan manifes dengan konfigurasi api-server, dan jika ada yang terdeteksi, ia me-restart wadah dengan api-server.  Tetapi ada detail penting: <b>mereka akan mengabaikan perubahan pada file kebijakan</b> .  Setelah membuat perubahan pada file kebijakan, Anda perlu me-restart api-server secara manual.  Karena api-server berjalan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pod statis</a> , perintah <code>kubectl delete</code> tidak <code>kubectl delete</code> memulai ulang.  Anda harus secara manual membuat <code>docker stop</code> di kube-master di mana kebijakan audit telah diubah: <br><br><pre> <code class="bash hljs">docker stop $(docker ps | grep k8s_kube-apiserver | awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span>)</code> </pre> <br>  Saat Anda mengaktifkan audit, penting untuk diingat bahwa <b>kube-apiserver memiliki muatan yang lebih tinggi</b> .  Secara khusus, konsumsi memori untuk menyimpan konteks permintaan meningkat.  Logging dimulai hanya setelah mengirim header respons.  Selain itu, beban tergantung pada konfigurasi kebijakan audit. <br><br><h3>  Contoh Kebijakan </h3><br>  Mari kita menganalisis struktur file kebijakan menggunakan contoh. <br><br>  Berikut ini adalah file <code>policy</code> sederhana untuk mencatat segala sesuatu di tingkat <code>Metadata</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1 kind: Policy rules: - level: Metadata</code> </pre> <br>  Anda dapat menentukan daftar pengguna ( <code>Users</code> dan <code>ServiceAccounts</code> ) dan grup pengguna dalam kebijakan.  Sebagai contoh, ini adalah bagaimana kami akan mengabaikan pengguna sistem, tetapi mencatat segala sesuatu yang lain di tingkat <code>Request</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1 kind: Policy rules: - level: None userGroups: - "system:serviceaccounts" - "system:nodes" users: - "system:anonymous" - "system:apiserver" - "system:kube-controller-manager" - "system:kube-scheduler" - level: Request</code> </pre> <br>  Dimungkinkan juga untuk menggambarkan target: <br><br><ul><li>  <code>namespaces</code> </li><li>  kata kerja ( <i>kata kerja</i> : <code>get</code> , <code>update</code> , <code>delete</code> dan lainnya); </li><li>  sumber daya ( <i>sumber daya</i> , yaitu: <code>pod</code> , <code>configmaps</code> , dll.) dan grup sumber daya ( <code>apiGroups</code> ). </li></ul><br>  <b>Perhatikan!</b>  Sumber daya dan grup sumber daya (grup API, mis. ApiGroups), serta versinya yang dipasang di cluster, dapat diperoleh dengan menggunakan perintah: <br><br><pre> <code class="bash hljs">kubectl api-resources kubectl api-versions</code> </pre> <br>  Kebijakan audit berikut disediakan sebagai peragaan praktik terbaik dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi Cloud Alibaba</a> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1beta1 kind: Policy #    RequestReceived omitStages: - "RequestReceived" rules: #   ,     : - level: None users: ["system:kube-proxy"] verbs: ["watch"] resources: - group: "" #  api group   ,    #   Kubernetes,  â€œcoreâ€ resources: ["endpoints", "services"] - level: None users: ["system:unsecured"] namespaces: ["kube-system"] verbs: ["get"] resources: - group: "" # core resources: ["configmaps"] - level: None users: ["kubelet"] verbs: ["get"] resources: - group: "" # core resources: ["nodes"] - level: None userGroups: ["system:nodes"] verbs: ["get"] resources: - group: "" # core resources: ["nodes"] - level: None users: - system:kube-controller-manager - system:kube-scheduler - system:serviceaccount:kube-system:endpoint-controller verbs: ["get", "update"] namespaces: ["kube-system"] resources: - group: "" # core resources: ["endpoints"] - level: None users: ["system:apiserver"] verbs: ["get"] resources: - group: "" # core resources: ["namespaces"] #     read-only URLs: - level: None nonResourceURLs: - /healthz* - /version - /swagger* #   ,     â€œâ€: - level: None resources: - group: "" # core resources: ["events"] #   Secret, ConfigMap  TokenReview    , #         - level: Metadata resources: - group: "" # core resources: ["secrets", "configmaps"] - group: authentication.k8s.io resources: ["tokenreviews"] #   get, list  watch   ;    - level: Request verbs: ["get", "list", "watch"] resources: - group: "" # core - group: "admissionregistration.k8s.io" - group: "apps" - group: "authentication.k8s.io" - group: "authorization.k8s.io" - group: "autoscaling" - group: "batch" - group: "certificates.k8s.io" - group: "extensions" - group: "networking.k8s.io" - group: "policy" - group: "rbac.authorization.k8s.io" - group: "settings.k8s.io" - group: "storage.k8s.io" #        API - level: RequestResponse resources: - group: "" # core - group: "admissionregistration.k8s.io" - group: "apps" - group: "authentication.k8s.io" - group: "authorization.k8s.io" - group: "autoscaling" - group: "batch" - group: "certificates.k8s.io" - group: "extensions" - group: "networking.k8s.io" - group: "policy" - group: "rbac.authorization.k8s.io" - group: "settings.k8s.io" - group: "storage.k8s.io" #         - level: Metadata</code> </pre> <br><br>  Contoh kebijakan audit yang baik lainnya adalah <a href="">profil yang digunakan dalam GCE</a> . <br><br>  Untuk respons cepat terhadap peristiwa audit, dimungkinkan untuk <b>menggambarkan webhook</b> .  Masalah ini diungkapkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> , saya akan meninggalkannya di luar ruang lingkup artikel ini. <br><br><h2>  Ringkasan </h2><br>  Artikel ini memberikan ikhtisar mekanisme keamanan dasar di kluster Kubernetes yang memungkinkan Anda membuat akun pengguna yang dipersonalisasi, membagikan hak-hak mereka, dan mencatat tindakan mereka.  Saya harap ini berguna bagi mereka yang dihadapkan dengan pertanyaan-pertanyaan seperti itu dalam teori atau sudah dalam praktik.  Saya juga merekomendasikan agar Anda melihat daftar bahan-bahan lain tentang topik keamanan di Kubernetes, yang tercantum dalam "PS" - mungkin di antara mereka Anda akan menemukan rincian yang diperlukan tentang masalah yang relevan bagi Anda. <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">33+ Alat Keamanan Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Kebijakan Jaringan Kubernet untuk Profesional Keamanan</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami RBAC di Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9 Praktik Keamanan Terbaik di Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">11 Cara untuk (Tidak) Menjadi Korban Peretasan Kubernet</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468679/">https://habr.com/ru/post/id468679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468657/index.html">Tarian dengan dukungan: jenis dan bentuk dukungan. Sistem pendukung bekerja dalam pertempuran</a></li>
<li><a href="../id468663/index.html">Pendekatan End2 End dalam Tugas Pengenalan Ucapan Otomatis</a></li>
<li><a href="../id468665/index.html">Tetapi apakah sudah waktunya untuk membeli irigasi?</a></li>
<li><a href="../id468673/index.html">Lokakarya "Memastikan keamanan data pribadi" - 3 Oktober, St. Petersburg</a></li>
<li><a href="../id468677/index.html">Pengumuman smartphone Xiaomi Mi Mix Alpha</a></li>
<li><a href="../id468683/index.html">Teori dan praktik standardisasi layanan Docker</a></li>
<li><a href="../id468687/index.html">Kami menganalisis inisiatif baru Bank Sentral untuk mengatur pasar saham: 3 kelompok investor, pembatasan untuk pemula</a></li>
<li><a href="../id468689/index.html">Mendaftarkan bisnis TI Anda di Singapura: apa yang harus saya lakukan?</a></li>
<li><a href="../id468691/index.html">Driver pihak ketiga berbahaya pada sistem Anda atau LOLDrivers</a></li>
<li><a href="../id468693/index.html">Bagaimana otomasi menghancurkan karyawan Walmart</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>