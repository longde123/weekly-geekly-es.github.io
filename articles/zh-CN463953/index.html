<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💔 🤼 🧚🏽 在Unity中实现命令设计模式 🏴󠁧󠁢󠁥󠁮󠁧󠁿 🐕 🌶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您是否曾经想过在Super Meat Boy之类的游戏中如何实现重播功能？ 实现它的方法之一是以与播放器相同的方式执行输入，这又意味着需要以某种方式存储输入。 您可以为此使用Command模式等等。 

 命令模板对于在策略游戏中创建撤消和重做功能也很有用。 

 在本教程中，我们在C＃中实现Com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity中实现命令设计模式</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463953/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fef/cfb/edf/fefcfbedf0b2e0711f2e831b0d069ebf.gif" alt="图片"></div><br> 您是否曾经想过在<i>Super Meat Boy</i>之类的游戏中如何实现重播功能？ 实现它的方法之一是以与播放器相同的方式执行输入，这又意味着需要以某种方式存储输入。 您可以为此使用<em>Command模式</em>等等。 <br><br> 命令模板对于在策略游戏中创建撤消和重做功能也很有用。 <br><br> 在本教程中，我们在C＃中实现Command模板，并使用它来指导机器人角色穿越三维迷宫。 通过本教程，您将学到： <br><br><ul><li> 命令模式的基础。 </li><li> 如何实现命令模式 </li><li> 如何创建输入命令队列并延迟其执行。 </li></ul><a name="habracut"></a><br><blockquote>  <em>注意</em> ：假设您已经熟悉Unity并具有C＃的一般知识。 在本教程中，我们将使用<em>Unity 2019.1</em>和<em>C＃7</em> 。 </blockquote><br><h2> 开始工作 </h2><br> 首先，下载<a href="">项目资料</a> 。 解压缩文件并在Unity中打开<em>Starter</em>项目。 <br><br> 转到<em>RW /场景</em>并打开<em>主</em>场景。 该场景由一个机器人和一个迷宫以及一个显示指令的终端UI组成。 关卡设计以网格形式进行，当我们在视觉上将机器人穿过迷宫时，这很有用。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53b/ab9/660/53bab9660bdd0a5017b570d43a57b2d9.png"></div><br> 如果您点击<em>Play</em> ，我们将看到说明不起作用。 这是正常现象，因为我们会将此功能添加到教程中。 <br><br> 场景中最有趣的部分是GameObject <em>Bot</em> 。 通过单击它在“层次结构”窗口中将其选中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/187/35e/acf/18735eacfd1f8df8920749ea80a12b8f.png"></div><br> 在检查器中，您可以看到它具有<em>Bot</em>组件。 我们将通过发出输入命令来使用此组件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a5/2e3/2bc/2a52e32bc7feb6baafae6af958cc4910.png"></div><br><h2> 我们了解机器人的逻辑 </h2><br> 转到<em>RW /脚本，</em>然后在代码编辑器中打开<em>Bot</em>脚本。 您无需知道<em>Bot</em>脚本中正在发生的事情。 但是，请看一下两种方法： <code>Move</code>和<code>Shoot</code> 。 同样，您不需要了解这些方法中发生的事情，但是您需要了解如何使用它们。 <br><br> 注意， <code>Move</code>方法接收输入参数<code>CardinalDirection</code> 。  <code>CardinalDirection</code>是一个枚举。  <code>CardinalDirection</code>类型的枚举元素可以是<code>Up</code> ， <code>Down</code> ， <code>Right</code>或<code>Left</code> 。 根据所选的<code>CardinalDirection</code>机器人会沿着网格在相应方向上精确移动一个正方形。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/72e/8ca/02c72e8ca19f987e6e36774558242058.png"></div><br>  <code>Shoot</code>方法迫使机器人发射弹壳，摧毁<em>黄色的墙壁</em> ，但对其他墙壁无用。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/f18/2bb/b34f182bb9c0bb682606d0c5a1beb0fd.gif"></div><br> 最后，看一下<code>ResetToLastCheckpoint</code>方法； 要了解他在做什么，请看迷宫。 迷宫中有一些点称为<em>检查点</em> 。 为了通过迷宫，机器人需要到达<em>绿色</em>控制点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/d3b/fc9/e4cd3bfc9d59944e28d9a22206141888.png"></div><br> 当机器人踩到新的控制点时，它就成了他的<em>最后</em>选择。  <code>ResetToLastCheckpoint</code>重置机器人的位置，将其移动到最后一个控制点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/829/617/95a/82961795afe53c9b45f1f8037896783c.gif"></div><br> 尽管我们无法使用这些方法，但我们会尽快对其进行修复。 首先，您需要了解<em>Command</em>设计模式。 <br><br><h2> 什么是命令设计模式？ </h2><br> 命令模式是Erich Gamma，Richard Helm，Ralph Johnson和John Vlissides（ <em>GoF</em> ，四人帮）的四人帮编写的《 <i>设计模式：可重用的面向对象软件的元素》</i>一书中描述的23种设计模式之一。 <br><br> 作者报告说：“命令模式将请求封装为一个对象，从而使我们能够对具有不同请求，队列或日志请求的其他对象进行参数化，并支持可逆操作。” <br><br> 哇！ 怎么了 <br><br> 我知道这个定义不是很简单，所以让我们对其进行分析。 <br><br>  <em>封装</em>意味着可以将方法调用封装为对象。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/5c3/214/07d5c32142de4fd36bd2cd73c543856a.png" width="50%" height="50%"></div><br> 封装的方法可能会影响许多对象，具体取决于输入参数。 这称为其他对象的<em>参数化</em> 。 <br><br> 可以将生成的“命令”与其他团队一起保存，直到执行完毕。 这是请求<em>队列</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/035/637/264/0356372640076e0829d2a427cf3552f1.png" width="50%" height="50%"></div><br>  <i>团队队列</i> <br><br> 最后， <em>可逆性</em>意味着可以使用撤消功能来还原操作。 <br><br> 好的，但这在代码中如何体现？ <br><br>  <em>Command</em>类将具有<em>Execute</em>方法，该方法接收称为<em>Receiver</em>的对象（通过其执行命令）作为输入参数。 也就是说，实际上，Execute方法是由Command类<em>封装</em>的。 <br><br>  Command类的许多实例可以作为普通对象传递，也就是说，它们可以存储在诸如队列，堆栈等数据结构中。 <br><br> 要执行命令，必须调用其Execute方法。 开始执行的类称为<em>Invoker</em> 。 <br><br> 该项目当前包含一个名为<code>BotCommand</code>的空类。 在下一节中，我们将实现上述实现，以允许bot使用Command模板执行操作。 <br><br><h2> 移动机器人 </h2><br><h3> 命令模式实现 </h3><br> 在本节中，我们实现命令模式。 有很多方法可以实现它。 在本教程中，我们将介绍其中之一。 <br><br> 首先，转到<em>RW /脚本</em> ，然后在编辑器中打开<em>BotCommand</em>脚本。  <code>BotCommand</code>类仍然为空，但不会持续很长时间。 <br><br> 将以下代码插入到类中： <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private readonly string commandName; //2 public BotCommand(ExecuteCallback executeMethod, string name) { Execute = executeMethod; commandName = name; } //3 public delegate void ExecuteCallback(Bot bot); //4 public ExecuteCallback Execute { get; private set; } //5 public override string ToString() { return commandName; }</span></span></code> </pre> <br> 这是怎么回事 <br><br><ol><li>  <code>commandName</code>变量<code>commandName</code>用于存储人类可读的命令名称。 不需要在模板中使用它，但是在本教程的后面部分将需要它。 </li><li>  <code>BotCommand</code>的构造函数接收一个函数和一个字符串。 这将帮助我们设置Command对象的<code>Execute</code>方法及其<code>name</code> 。 </li><li>  <code>ExecuteCallback</code>委托定义封装方法的类型。 封装的方法将返回void并接受<code>Bot</code>类型的对象（组件<em>Bot</em> ）作为输入参数。 </li><li>  <code>Execute</code>属性将引用封装的方法。 我们将使用它来调用封装的方法。 </li><li> 重写<code>ToString</code>方法以返回字符串<code>commandName</code> 。 例如，这很方便在UI中使用。 </li></ol><br> 保存更改，仅此而已！ 我们已经成功实现了Command模式。 <br><br> 仍然可以使用它。 <br><br><h3> 团队建设 </h3><br> 在<em>RW /脚本</em>文件夹中打开<em>BotInputHandler</em> 。 <br><br> 在这里，我们将创建<code>BotCommand</code>五个实例。 这些实例将封装用于上下移动GameObject Bot以及进行射击的方法。 <br><br> 要实现此目的，请将以下内容插入此类： <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private static readonly BotCommand MoveUp = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Up); }, "moveUp"); //2 private static readonly BotCommand MoveDown = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Down); }, "moveDown"); //3 private static readonly BotCommand MoveLeft = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Left); }, "moveLeft"); //4 private static readonly BotCommand MoveRight = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Right); }, "moveRight"); //5 private static readonly BotCommand Shoot = new BotCommand(delegate (Bot bot) { bot.Shoot(); }, "shoot");</span></span></code> </pre> <br> 在每种情况下， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">匿名方法都</a>传递给构造函数。 此匿名方法将封装在相应的命令对象中。 如您所见，每个匿名方法的签名都符合<code>ExecuteCallback</code>委托指定的要求。 <br><br> 此外，构造函数的第二个参数是指示命令名称的字符串。 该名称将由命令实例的<code>ToString</code>方法返回。 稍后，我们将其应用于UI。 <br><br> 在前四个实例中，匿名方法调用<code>bot</code>对象上的<code>Move</code>方法。 但是，它们的输入参数不同。 <br><br>  <code>MoveUp</code> ， <code>MoveDown</code> ， <code>MoveLeft</code>和<code>MoveRight</code>传递<code>Move</code>参数<code>CardinalDirection.Up</code> ， <code>CardinalDirection.Down</code> ， <code>CardinalDirection.Left</code>和<code>CardinalDirection.Right</code> 。 如“ <i>什么是命令设计模式”</i>部分所述，它们指示GameObject Bot移动的不同方向。 <br><br> 在第五个实例中，匿名方法调用<code>bot</code>对象的<code>Shoot</code>方法。 因此，机器人将在命令执行期间触发外壳程序。 <br><br> 现在我们已经创建了命令，我们需要在用户输入时以某种方式访问​​它们。 <br><br> 为此，请在命令实例之后立即在<code>BotInputHandler</code>以下代码： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BotCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.W)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveUp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.S)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveDown; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.D)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveRight; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.A)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveLeft; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.F)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Shoot; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  <code>HandleInput</code>方法根据用户按下的键返回命令的一个实例。 在继续操作之前，请保存您的更改。 <br><br><h3> 应用命令 </h3><br> 太好了，现在该使用我们创建的团队了。 再次转到<em>RW /脚本</em> ，然后在编辑器中打开<em>SceneManager</em>脚本。 在此类中，您会注意到一个指向<code>UIManager</code>类型的<code>uiManager</code>变量的链接。 <br><br>  <code>UIManager</code>类为我们在此场景中使用的<em>终端UI</em>提供了有用的帮助程序方法。 如果使用<code>UIManager</code>的方法，则本教程将说明其功能，但通常出于我们的目的，无需了解其内部结构。 <br><br> 另外， <code>bot</code>变量是指附加到GameObject <em>Bot</em>的bot组件。 <br><br> 现在，将以下代码添加到<code>SceneManager</code>类中，将其替换为注释<code>//1</code> ： <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private List&lt;BotCommand&gt; botCommands = new List&lt;BotCommand&gt;(); private Coroutine executeRoutine; //2 private void Update() { if (Input.GetKeyDown(KeyCode.Return)) { ExecuteCommands(); } else { CheckForBotCommands(); } } //3 private void CheckForBotCommands() { var botCommand = BotInputHandler.HandleInput(); if (botCommand != null &amp;&amp; executeRoutine == null) { AddToCommands(botCommand); } } //4 private void AddToCommands(BotCommand botCommand) { botCommands.Add(botCommand); //5 uiManager.InsertNewText(botCommand.ToString()); } //6 private void ExecuteCommands() { if (executeRoutine != null) { return; } executeRoutine = StartCoroutine(ExecuteCommandsRoutine()); } private IEnumerator ExecuteCommandsRoutine() { Debug.Log("Executing..."); //7 uiManager.ResetScrollToTop(); //8 for (int i = 0, count = botCommands.Count; i &lt; count; i++) { var command = botCommands[i]; command.Execute(bot); //9 uiManager.RemoveFirstTextLine(); yield return new WaitForSeconds(CommandPauseTime); } //10 botCommands.Clear(); bot.ResetToLastCheckpoint(); executeRoutine = null; }</span></span></code> </pre> <br> 哇，多少代码！ 但是不用担心； 我们终于可以在游戏窗口中首次真正启动该项目了。 <br><br> 我将在稍后解释代码。 记住要保存更改。 <br><br><h3> 运行游戏以测试命令模板 </h3><br> 因此，现在是构建的时候了； 在Unity编辑器中单击<em>播放</em> 。 <br><br> 您应该能够使用<em>WASD键</em>输入移动命令。 要输入拍摄命令，请按<em>F</em>键。 要执行命令，请按<em>Enter</em> 。 <br><br><blockquote>  <em>注意</em> ：在执行过程完成之前，无法输入新命令。 </blockquote><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20b/ef8/483/20bef8483dd70829836bd9234178f5dd.gif"></div><br> 请注意，这些行已添加到终端UI。  UI中的团队由其名称指示。 这要归功于<code>commandName</code>变量。 <br><br> 另外，请注意，UI在执行之前如何向上滚动以及执行期间如何删除行。 <br><br><h3> 我们更仔细地研究团队 </h3><br> 是时候学习我们在“应用命令”部分中添加的代码了： <br><br><ol><li>  <code>botCommands</code>列表存储指向<code>BotCommand</code>实例的<code>BotCommand</code> 。 请记住，为了节省内存，我们只能创建五个命令实例，但是可能对一个命令有多个引用。 另外， <code>executeCoroutine</code>变量引用<code>ExecuteCommandsRoutine</code> ，它控制命令的执行。 </li><li>  <code>Update</code>检查用户是否已按Enter键； 如果是这样，它将调用<code>ExecuteCommands</code> ，否则将调用<code>CheckForBotCommands</code> 。 </li><li>  <code>CheckForBotCommands</code>使用<code>HandleInput</code>的静态<code>HandleInput</code>方法检查用户是否已完成输入，如果已完成，则<em>返回</em>命令。 返回的命令将传递到<code>AddToCommands</code> 。 但是，如果执行了命令，即 如果<code>executeRoutine</code>不为null，则它将返回而不将任何内容传递给<code>AddToCommands</code> 。 即，用户需要等待直到完成。 </li><li>  <code>AddToCommands</code>新链接添加到命令的<em>返回</em>实例。 </li><li>  <code>InsertNewText</code>类的<code>InsertNewText</code>方法向终端UI添加一行新文本。 文本字符串是作为输入参数传递的字符串。 在这种情况下，我们将commandName传递给<code>commandName</code> 。 </li><li>  <code>ExecuteCommands</code>方法启动<code>ExecuteCommandsRoutine</code> 。 </li><li>  <code>UIManager</code> <code>ResetScrollToTop</code>向上滚动终端UI。 这是在执行开始之前完成的。 </li><li>  <code>ExecuteCommandsRoutine</code>包含一个<code>for</code>循环，该循环遍历<code>botCommands</code>列表内的命令并<code>botCommands</code>执行，并将<code>bot</code>对象传递给<code>Execute</code>属性返回的方法。 每次执行后，将在<code>CommandPauseTime</code>秒内添加一个暂停。 </li><li>  <code>UIManager</code>的<code>RemoveFirstTextLine</code>方法删除终端UI中的第一行文本（如果存在）。 也就是说，执行命令时，其名称将从UI中删除。 </li><li> 完成所有命令<code>botCommands</code>将清除<code>botCommands</code>并使用<code>ResetToLastCheckpoint</code>将机器人重置为最后一个断点。 最后， <code>executeRoutine</code> <code>null</code> ，用户可以继续输入命令。 </li></ol><br><h2> 实施撤消和重做功能 </h2><br> 再次运行场景，然后尝试到达绿色控制点。 <br><br> 您会注意到，尽管我们无法取消输入的命令。 这意味着，如果您犯了一个错误，则必须先完成所有输入的命令，然后才能返回。 您可以通过添加<em>撤消</em>和<em>重做</em>功能来解决此问题。 <br><br> 返回<em>SceneManager.cs</em>并在<code>botCommands</code>的<i>List</i>声明之后立即添加以下变量声明： <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Stack&lt;BotCommand&gt; undoStack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;BotCommand&gt;();</code> </pre> <br>  <code>undoStack</code>变量是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">堆栈</a> （来自Collections系列），它将存储对可以撤消的命令的所有引用。 <br><br> 现在，我们添加两个方法<code>UndoCommandEntry</code>和<code>RedoCommandEntry</code> ，它们将执行Undo和Redo。 在<code>SceneManager</code>类中，在<code>ExecuteCommandsRoutine</code>之后<code>SceneManager</code>以下代码： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UndoCommandEntry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 if (executeRoutine != null || botCommands.Count == 0) { return; } undoStack.Push(botCommands[botCommands.Count - 1]); botCommands.RemoveAt(botCommands.Count - 1); //2 uiManager.RemoveLastTextLine(); } private void RedoCommandEntry() { //3 if (undoStack.Count == 0) { return; } var botCommand = undoStack.Pop(); AddToCommands(botCommand); }</span></span></code> </pre> <br> 让我们分析一下代码： <br><br><ol><li> 如果执行了命令或<code>botCommands</code>列表<code>botCommands</code>空，则<code>UndoCommandEntry</code>方法<code>UndoCommandEntry</code>任何操作。 否则，它将写入到在<code>undoStack</code>堆栈上输入的最后一个命令的链接。 这还将从<code>botCommands</code>列表中删除该命令的链接。 </li><li>  <code>UIManager</code>的<code>RemoveLastTextLine</code>方法从终端UI删除文本的最后一行，以使UI与<code>botCommands</code>的内容匹配。 </li><li> 如果<code>undoStack</code>堆栈<code>undoStack</code>空，则<code>RedoCommandEntry</code>不执行任何操作。 否则，它将从<code>undoStack</code>的顶部提取最后一个命令，并使用<code>AddToCommands</code>将其添加回<code>botCommands</code>列表中。 </li></ol><br> 现在，我们将添加键盘输入以使用这些功能。 在<code>SceneManager</code>类中<code>SceneManager</code>用以下代码替换<code>Update</code>方法的主体： <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Return)) { ExecuteCommands(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) <span class="hljs-comment"><span class="hljs-comment">//1 { UndoCommandEntry(); } else if (Input.GetKeyDown(KeyCode.R)) //2 { RedoCommandEntry(); } else { CheckForBotCommands(); }</span></span></code> </pre> <br><ol><li> 当您按<em>U</em>键时，将<code>UndoCommandEntry</code>方法。 </li><li> 当您按<em>R</em>键时，将<code>RedoCommandEntry</code>方法。 </li></ol><br><h3> 边缘案例处理 </h3><br> 太好了，我们快完成了！ 但是首先，我们需要执行以下操作： <br><br><ol><li> 输入新命令时，应清除<code>undoStack</code>堆栈。 </li><li> 在执行命令之前，必须清除<code>undoStack</code>堆栈。 </li></ol><br> 为了实现这一点，我们首先需要向<code>SceneManager</code>添加一个新方法。 在<code>CheckForBotCommands</code>之后插入以下方法： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BotCommand botCommand</span></span></span><span class="hljs-function">)</span></span> { undoStack.Clear(); AddToCommands(botCommand); }</code> </pre> <br> 该方法清除<code>undoStack</code> ，然后调用<code>AddToCommands</code>方法。 <br><br> 现在，使用以下代码替换对<code>CheckForBotCommands</code>对<code>AddToCommands</code>的调用： <br><br><pre> <code class="cs hljs"> AddNewCommand(botCommand);</code> </pre> <br> 然后，在执行<code>undoStack</code>命令之前清除<code>ExecuteCommands</code>方法内的<code>if</code>后插入以下行： <br><br><pre> <code class="cs hljs"> undoStack.Clear();</code> </pre> <br> 我们终于完成了！ <br><br> 保存您的工作。 生成项目，然后单击“ <em>播放”</em>编辑器。 像以前一样输入命令。 按<em>U</em>取消命令。 按<em>R</em>重复取消的命令。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fef/cfb/edf/fefcfbedf0b2e0711f2e831b0d069ebf.gif" width="1024" height="576"></div><br> 尝试到达绿色检查站。 <br><br><h2> 接下来要去哪里？ </h2><br> 要了解有关游戏编程中使用的设计模式的更多信息，建议您学习Robert Nystrom的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">游戏编程模式”</a> 。 <br><br> 要了解有关高级C＃技术的更多信息，请参加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">C＃Collections，Lambdas和LINQ</a>课程。 <br><br><h3> 工作任务 </h3><br> 作为一项任务，尝试到达迷宫尽头的绿色控制点。 我将解决方案之一隐藏在扰流板下。 <br><br><div class="spoiler">  <b class="spoiler_title">解决方案</b> <div class="spoiler_text"><ul><li>  move×2 </li><li>  moveRight×3 </li><li>  move×2 </li><li>  moveLeft </li><li> 射击 </li><li>  moveLeft×2 </li><li>  move×2 </li><li>  moveLeft×2 </li><li> 下移×5 </li><li>  moveLeft </li><li> 射击 </li><li>  moveLeft </li><li>  move×3 </li><li> 拍×2 </li><li> 上移×5 </li><li>  moveRight×3 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dab/f9e/05f/dabf9e05f3cb79ab20a6a663108295fe.png"></div></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463953/">https://habr.com/ru/post/zh-CN463953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463933/index.html">20行Python脚本，每天通过WhatsApp祝父母早安</a></li>
<li><a href="../zh-CN463937/index.html">我没什么好隐瞒的</a></li>
<li><a href="../zh-CN463939/index.html">SimbirSoft为保险公司发布了移动解决方案</a></li>
<li><a href="../zh-CN463943/index.html">黑色独角兽的不幸经历</a></li>
<li><a href="../zh-CN463951/index.html">c.tech：Cassandra聚会＃2</a></li>
<li><a href="../zh-CN463955/index.html">如何提出改变IP平台的构想？ 使用说明</a></li>
<li><a href="../zh-CN463957/index.html">如何部署单链接采访列表</a></li>
<li><a href="../zh-CN463961/index.html">自己的映射器或有关ExpressionTrees的一些知识</a></li>
<li><a href="../zh-CN463963/index.html">施工现场的人脸识别</a></li>
<li><a href="../zh-CN463965/index.html">LaTeX中的排版应用程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>