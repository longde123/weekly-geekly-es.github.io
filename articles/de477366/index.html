<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì• üë©üèø‚Äçüé§ üßëüèª‚Äçü§ù‚Äçüßëüèª F√ºnf Fragen zum Entwerfen von Programmiersprachen ü§úüèø üõÅ üòñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Leitmotiv 

 1. Programmiersprachen f√ºr Menschen 
 Unter Programmiersprachen versteht man das Sprechen mit Computern. Der Computer spricht gerne jede ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F√ºnf Fragen zum Entwerfen von Programmiersprachen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477366/"><img src="https://habrastorage.org/webt/4b/el/ov/4belovlzntlpqyfg1tqnamrivd8.jpeg"><br><br><h2>  Leitmotiv </h2><br><br><h3>  1. Programmiersprachen f√ºr Menschen </h3><br>  Unter Programmiersprachen versteht man das Sprechen mit Computern.  Der Computer spricht gerne jede Sprache, die nicht mehrdeutig ist.  Der Grund, warum wir Hochsprachen haben, ist, dass die Leute nicht mit Maschinensprache umgehen k√∂nnen.  Die Essenz von Programmiersprachen besteht darin, zu verhindern, dass unser armes, zerbrechliches menschliches Gehirn mit einer Vielzahl von Details √ºberladen wird. <br><a name="habracut"></a><br>  Architekten wissen, dass einige Designprobleme profaner sind als andere.  Eines der klarsten und abstraktesten Designprobleme ist das Br√ºckendesign.  In diesem Fall ist es Ihre Aufgabe, die erforderliche Strecke mit m√∂glichst wenig Material zur√ºckzulegen.  Am anderen Ende des Spektrums steht das Design von St√ºhlen.  Stuhldesigner sollten ihre Zeit damit verbringen, sich Gedanken √ºber menschliche Esel zu machen. <br><br>  Die Softwareentwicklung weist einen √§hnlichen Unterschied auf.  Das Entwerfen von Algorithmen zum Weiterleiten von Daten √ºber ein Netzwerk ist ein gutes abstraktes Problem, wie das Entwerfen von Br√ºcken.  W√§hrend das Entwerfen von Programmiersprachen dem Entwerfen von St√ºhlen gleicht, muss man mit menschlichen Schw√§chen fertig werden. <br><br>  Den meisten von uns f√§llt es schwer, dies zu realisieren.  Das Entwerfen eleganter mathematischer Systeme klingt f√ºr die meisten von uns viel attraktiver, als sich menschlichen Schw√§chen hinzugeben.  Die Rolle der mathematischen Eleganz besteht darin, dass ein gewisser Grad an Eleganz das Verst√§ndnis von Programmen erleichtert.  Aber alles ist nicht auf Eleganz beschr√§nkt. <br><br>  Und wenn ich sage, dass Sprachen so gestaltet sein sollten, dass menschliche Schw√§chen ber√ºcksichtigt werden, dann bedeutet das nicht, dass Sprachen f√ºr schlechte Programmierer konzipiert sein sollten.  In der Tat sollten Sie Software f√ºr die besten Programmierer entwerfen, aber auch die besten Programmierer haben ihre Grenzen.  Ich glaube nicht, dass jemand in einer Sprache programmieren m√∂chte, in der alle Variablen durch den Buchstaben "x" mit ganzzahligen Indizes gekennzeichnet sind. <br><br><h3>  2. Entwerfen Sie f√ºr sich und Ihre Freunde </h3><br>  Wenn Sie sich die Geschichte der Programmiersprachen ansehen, wurden die meisten der besten Sprachen f√ºr die Verwendung durch ihre eigenen Autoren entwickelt, und die meisten der schlechtesten wurden f√ºr andere Personen entwickelt. <br><br>  Wenn Sprachen f√ºr andere Menschen entworfen werden, handelt es sich immer um eine bestimmte Gruppe von Menschen: Die Menschen sind nicht so schlau wie die Sch√∂pfer der Sprache.  So erhalten Sie eine Sprache, die herablassend zu Ihnen spricht.  Cobol ist das deutlichste Beispiel, aber die meisten Sprachen sind von diesem Geist durchdrungen. <br><br>  Das hat nichts damit zu tun, wie gut die Sprache ist.  C ist ziemlich niedrig, aber es wurde f√ºr die Verwendung durch seine Autoren erstellt, weshalb Hacker es lieben. <br><br>  Das Argument f√ºr das Entwerfen von Sprachen f√ºr schlechte Programmierer ist, dass es mehr schlechte als gute Programmierer gibt.  Vielleicht ist das so.  Aber diese kleine Anzahl guter Programmierer schreibt unverh√§ltnism√§√üig mehr Software. <br><br>  Mich interessiert die Frage, wie man eine Sprache schafft, die den besten Hackern gef√§llt.  Es scheint mir, dass diese Frage mit der Frage, wie man eine gute Programmiersprache erstellt, identisch ist. Aber auch wenn dies nicht der Fall ist, ist es zumindest eine interessante Frage. <br><br><h3>  3. Geben Sie dem Programmierer so viel Kontrolle wie m√∂glich </h3><br>  Viele Sprachen (insbesondere solche, die f√ºr andere Personen erstellt wurden) verhalten sich wie Kinderm√§dchen: Sie versuchen, Sie vor Dingen zu warnen, die Ihrer Meinung nach f√ºr Sie nicht n√ºtzlich sind.  Ich bin der gegenteiligen Meinung: Geben Sie dem Programmierer so viel Kontrolle wie m√∂glich. <br><br>  Als ich Lisp zum ersten Mal studierte, mochte ich am meisten, dass wir zu gleichen Bedingungen sprachen.  In anderen Sprachen, die ich zu dieser Zeit studiert hatte, gab es eine Sprache, und es gab mein Programm in dieser Sprache, und sie existierten ziemlich getrennt.  Aber in Lisp waren die Funktionen und Makros, die ich geschrieben habe, dieselben, in denen die Sprache selbst geschrieben wurde.  Ich k√∂nnte die Sprache selbst umschreiben, wenn ich wollte.  Es hatte den gleichen Reiz wie Open-Source-Software. <br><br><h3>  4. K√ºrze - die Schwester des Talents </h3><br>  K√ºrze wird untersch√§tzt und sogar verachtet.  Aber wenn Sie in die Herzen der Hacker schauen, werden Sie feststellen, dass sie die K√ºrze wirklich lieben.  Wie oft haben Sie schon von Hackern geh√∂rt, die liebevoll sagen, dass sie in der APL erstaunliche Dinge mit nur wenigen Codezeilen tun k√∂nnen?  Ich glaube, dass wirklich kluge Leute dem wirklich gerne Aufmerksamkeit schenken. <br><br>  Ich glaube, dass fast alles, was Programme k√ºrzer macht, gut ist.  Es sollte viele Bibliotheksfunktionen geben, alles, was implizit sein kann - sollte so sein;  Die Syntax sollte pr√§gnanter sein.  gerade Entit√§tsnamen sollten kurz sein. <br><br>  Und nicht nur Programme sollten kurz sein.  Handb√ºcher sollten auch kurz sein.  Ein Gro√üteil der Handb√ºcher enth√§lt Erkl√§rungen, Haftungsausschl√ºsse, Warnungen und Sonderf√§lle.  Wenn Sie das Handbuch k√ºrzen m√ºssen, ist es am besten, die Sprache zu korrigieren, f√ºr die so viele Erkl√§rungen erforderlich sind. <br><br><h3>  5. Erkennen Sie, was Hacking ist. </h3><br>  Viele Leute m√∂chten, dass Hacken Mathematik ist oder zumindest etwas √Ñhnliches wie Naturwissenschaften.  Ich denke, Hacking ist eher wie Architektur.  Architektur ist mit Physik verbunden, in dem Sinne, dass der Architekt ein Geb√§ude entwerfen muss, das nicht fallen wird, aber das eigentliche Ziel des Architekten ist es, ein gro√üartiges Geb√§ude zu schaffen und keine Entdeckungen auf dem Gebiet der Statik zu machen. <br><br>  Was Hacker lieben, ist gro√üartige Programme zu erstellen.  Und ich denke, zumindest in unseren eigenen Gedanken sollten wir uns daran erinnern, dass das Schreiben wundervoller Programme wundervoll ist, auch wenn diese Arbeit nicht einfach in die gew√∂hnliche intellektuelle W√§hrung wissenschaftlicher Werke √ºbersetzt werden kann.  Aus intellektueller Sicht ist es ebenso wichtig, eine Sprache zu entwickeln, die Programmierer lieben werden, und eine schreckliche Sprache zu entwickeln, die die Idee verk√∂rpert, √ºber die Sie einen Artikel ver√∂ffentlichen k√∂nnen. <br><br><h2>  Offene Fragen </h2><br><h3>  1. Wie organisiere ich gro√üe Bibliotheken? </h3><br>  Bibliotheken werden zu einem wichtigen Bestandteil von Programmiersprachen.  Sie werden so gro√ü, dass es gef√§hrlich sein kann.  Wenn es l√§nger dauert, eine Funktion in der Bibliothek zu finden, die das tut, was Sie ben√∂tigen, als diese Funktion selbst zu schreiben, wird Ihr Handbuch durch den gesamten Code nur verdickt.  (Ein Beispiel hierf√ºr waren Handb√ºcher zu Symbolik.) Wir m√ºssen also das Problem der Organisation von Bibliotheken l√∂sen.  Entwerfen Sie sie idealerweise so, dass der Programmierer erraten kann, welche Bibliotheksfunktion geeignet ist. <br><br><h3>  2. Haben die Leute wirklich Angst vor der Pr√§fix-Syntax? </h3><br>  Dies ist ein offenes Problem in dem Sinne, dass ich √ºber mehrere Jahre nachgedacht habe und die Antwort immer noch nicht kenne.  Die Pr√§fix-Syntax erscheint mir v√∂llig nat√ºrlich, m√∂glicherweise auch in der Mathematik.  Aber es kann sein, dass der gr√∂√üte Teil von Lisps Unbeliebtheit einfach auf eine ungewohnte Syntax zur√ºckzuf√ºhren ist ... Hat das irgendetwas damit zu tun, wenn es wahr ist, ist dies eine andere Frage. <br><br><h3>  3. Was ben√∂tigen Sie f√ºr die Serversoftware? </h3><br>  Ich denke, dass die meisten Anwendungen, die in den n√§chsten zwanzig Jahren geschrieben werden, Webanwendungen sein werden, in dem Sinne, dass sich die Programme auf dem Server befinden und √ºber einen Webbrowser mit Ihnen kommunizieren werden.  Und um solche Anwendungen zu schreiben, brauchen wir neue Dinge. <br><br>  Eines dieser Dinge ist die Unterst√ºtzung einer neuen Methode zum Freigeben von Serveranwendungen.  Anstelle von ein oder zwei Hauptversionen pro Jahr, wie z. B. Desktop-Software, wird die Serversoftware in einer Reihe kleiner √Ñnderungen ver√∂ffentlicht.  Sie k√∂nnen f√ºnf oder zehn Ver√∂ffentlichungen pro Tag haben.  Und jeder wird immer die neueste Version haben. <br><br>  Wissen Sie, wie Sie Programme entwerfen, die unterst√ºtzt werden sollen?  Die Serversoftware muss anpassungsf√§hig sein.  Sie sollten es leicht √§ndern k√∂nnen oder zumindest wissen, was eine geringf√ºgige √Ñnderung bedeutet und was wichtig ist. <br><br>  Eine andere Sache, die in der Serversoftware n√ºtzlich sein kann, ist pl√∂tzlich die Kontinuit√§t der Lieferung.  In einer Webanwendung k√∂nnen Sie <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS verwenden</a> , um den Effekt von Routinen in der statusfreien Welt von <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Websitzungen</a> zu erzielen.  M√∂glicherweise lohnt sich eine kontinuierliche Lieferung, wenn diese Gelegenheit nicht zu teuer ist. <br><br><h3>  4. Welche neuen Abstraktionen m√ºssen noch ge√∂ffnet werden? </h3><br>  Ich bin mir nicht sicher, wie vern√ºnftig diese Hoffnung ist, aber ich pers√∂nlich w√ºrde wirklich gerne eine neue Abstraktion entdecken - etwas, das genauso wichtig sein k√∂nnte wie erstklassige Funktionen oder Rekursionen oder zumindest die Standardparameter.  Vielleicht ist das ein unm√∂glicher Traum.  Solche Dinge √∂ffnen sich oft nicht.  Aber ich verliere nicht die Hoffnung. <br><br><h2>  Wenig bekannte Geheimnisse </h2><br><h3>  1. Sie k√∂nnen jede gew√ºnschte Sprache verwenden </h3><br>  Bisher bedeutete die Erstellung von Anwendungen die Erstellung von Desktop-Software.  Und in der Desktop-Software gibt es eine gro√üe Tendenz, Anwendungen in derselben Sprache wie das Betriebssystem zu schreiben.  Vor zehn Jahren bedeutete das Schreiben von Software als Ganzes das Schreiben von Software in C. Am Ende hat sich die Tradition entwickelt: Anwendungen sollten nicht in ungew√∂hnlichen Sprachen geschrieben werden.  Und diese Tradition hat sich so lange entwickelt, dass auch Nicht-Techniker wie Manager und Risikokapitalgeber dies gelernt haben. <br><br>  Die Serversoftware zerst√∂rt dieses Modell vollst√§ndig.  Mit der Serversoftware k√∂nnen Sie jede gew√ºnschte Sprache verwenden.  Kaum jemand anderes versteht das (insbesondere Manager und Risikokapitalgeber).  Aber einige Hacker verstehen das, weshalb wir von Indy-Sprachen wie Perl und Python geh√∂rt haben.  Wir h√∂ren nichts √ºber Perl und Python, weil die Leute damit Windows-Anwendungen schreiben. <br><br>  Was bedeutet dies f√ºr uns Menschen, die an der Gestaltung von Programmiersprachen interessiert sind, dass es ein potentielles Publikum f√ºr unsere Arbeit gibt. <br><br><h3>  2. Geschwindigkeit kommt von Profilern </h3><br>  Sprachentwickler oder zumindest deren Implementierer lieben es, Compiler zu schreiben, die schnellen Code generieren.  Aber ich denke, das ist nicht das, was Sprachen f√ºr Benutzer schnell macht.  Knut ist schon lange aufgefallen, dass die Geschwindigkeit nur von wenigen Engp√§ssen abh√§ngt.  Und jeder, der versucht hat, das Programm zu beschleunigen, wei√ü, dass man den Engpass nicht erraten kann.  Der Profiler ist die Antwort. <br><br>  Sprachentwickler l√∂sen das falsche Problem.  Benutzer ben√∂tigen keine Benchmarks, um schnell arbeiten zu k√∂nnen.  Sie ben√∂tigen eine Sprache, die anzeigt, welche Teile ihres Programms neu geschrieben werden sollen.  An dieser Stelle ist in der Praxis Schnelligkeit gefragt.  Daher ist es m√∂glicherweise besser, wenn die Sprachimplementierer die H√§lfte der Zeit damit verbringen, den Compiler zu optimieren und einen guten Profiler zu schreiben. <br><br><h3>  3. Sie ben√∂tigen eine Anwendung, mit der sich Ihre Sprache entwickelt </h3><br>  Vielleicht ist dies nicht die ultimative Wahrheit, aber es scheint, dass die besten Sprachen zusammen mit den Anwendungen, in denen sie verwendet wurden, entwickelt wurden.  C wurde von Leuten geschrieben, die Systemprogrammierung ben√∂tigten.  Lisp war zum Teil auf symbolische Differenzierung ausgelegt, McCarthy war so begierig, dass er bereits im ersten Lisp-Dokument 1960 damit begann, Differenzierungsprogramme zu schreiben. <br><br>  Dies ist besonders gut, wenn Ihre Anwendung einige neue Probleme l√∂st.  Dies ermutigt Ihre Sprache, neue Funktionen zu haben, die Programmierer ben√∂tigen.  Pers√∂nlich bin ich daran interessiert, eine Sprache zu schreiben, die f√ºr Serveranwendungen geeignet ist. <br><br>  [W√§hrend der Diskussion √§u√üerte Guy Steele auch diese Idee und f√ºgte hinzu, dass die Anwendung nicht aus dem Schreiben eines Compilers f√ºr Ihre Sprache bestehen sollte, es sei denn, Ihre Sprache ist zum Schreiben von Compilern vorgesehen.] <br><br>  <b>4. Die Sprache sollte zum Schreiben von Einmalprogrammen geeignet sein.</b> <br><br>  Sie wissen, was ein einmaliges Programm bedeutet: Hier m√ºssen Sie schnell ein begrenztes Problem l√∂sen.  Ich glaube, wenn Sie sich umschauen, werden Sie viele ernsthafte Programme finden, die als einmalige begannen.  Es w√ºrde mich nicht wundern, wenn die meisten Programme einmalig starten w√ºrden.  Wenn Sie also eine Sprache erstellen m√∂chten, die zum Schreiben von Software im Allgemeinen geeignet ist, sollte sie zum Schreiben von Einmalprogrammen geeignet sein, da dies die Anfangsphase vieler Programme ist. <br><br><h3>  5. Syntax in Bezug auf Semantik </h3><br>  Es wird traditionell angenommen, dass Syntax und Semantik sehr unterschiedliche Dinge sind.  Es mag schockierend klingen, ist es aber nicht.  Ich denke, dass das, was Sie in Ihr Programm aufnehmen m√∂chten, damit zusammenh√§ngt, wie Sie es ausdr√ºcken. <br><br>  Ich habe vor kurzem mit Robert Morris gesprochen und festgestellt, dass das √úberladen von Operatoren ein gro√ües Plus beim Gewinnen von Sprachen mit Infix-Syntax ist.  In Sprachen mit Pr√§fixsyntax ist jede von Ihnen definierte Funktion ein Operator.  Wenn Sie den neu erstellten Zahlentyp addieren m√∂chten, k√∂nnen Sie einfach eine neue Funktion definieren, um sie hinzuzuf√ºgen.  Wenn Sie dies in einer Sprache mit Infix-Syntax tun, werden Sie feststellen, dass es einen gro√üen Unterschied zwischen der Verwendung eines √ºberladenen Operators und dem Aufrufen einer Funktion gibt. <br><br><h2>  Ideen, die mit der Zeit zur√ºckkommen </h2><br><h3>  1. Neue Programmiersprachen </h3><br>  In den 1970er Jahren war es Mode, neue Programmiersprachen zu entwickeln.  Nun ist das nicht so.  Aber ich glaube, dass Server-Software wieder die Mode f√ºr das Erstellen neuer Sprachen zur√ºckgeben wird.  Mit der Serversoftware k√∂nnen Sie jede gew√ºnschte Sprache verwenden. Wenn also jemand eine Sprache erstellt, die besser zu sein scheint als der Rest, gibt es Leute, die sich daf√ºr entscheiden, sie zu verwenden. <br><br><h3>  2. Timesharing </h3><br>  Richard Kelsey hat diese Idee vorgebracht, deren Zeit wieder gekommen ist, und ich unterst√ºtze sie voll und ganz.  Ich vermute (und Microsoft auch), dass viele Berechnungen vom Desktop auf Remote-Server verschoben werden.  Mit anderen Worten, die Zeitteilung ist zur√ºckgekehrt.  Ich denke, Sie brauchen Unterst√ºtzung auf Sprachniveau.  Zum Beispiel haben Richard und Jonathan Reeves viel Arbeit geleistet, um die Prozessplanung in Schema 48 umzusetzen. <br><br><h3>  3. Effizienz </h3><br>  In letzter Zeit schienen Computer bereits recht schnell zu sein.  Immer mehr h√∂ren wir von Bytecode, was zumindest f√ºr mich bedeutet, dass wir die Kraft auf Lager haben.  Aber ich denke, dass wir mit Server-Software nicht haben.  Jemand muss f√ºr die Server bezahlen, auf denen die Software ausgef√ºhrt wird, und die Anzahl der Benutzer, denen der Server pro Computer standhalten kann, ist ein Teil der Kapitalkosten. <br><br>  Ich denke, dass Effizienz eine Rolle spielen wird, zumindest bei den Engp√§ssen beim Computing.  Dies ist besonders wichtig f√ºr E / A-Vorg√§nge, da Serveranwendungen viele solcher Vorg√§nge ausf√ºhren. <br><br>  Am Ende k√∂nnte sich herausstellen, dass Bytecode keine Option ist.  Derzeit scheinen sich Sun und Microsoft im Bytecode-Feld gegen√ºberzustehen.  Aber sie tun dies, weil Bytecode ein bequemer Ort ist, um sich in den Prozess einzubetten, und nicht, weil Bytecode allein eine gute Idee ist.  Es kann sich herausstellen, dass diese ganze Schlacht unbemerkt bleiben wird.  Es w√§re lustig. <br><br><h2>  Fallen und Fallen </h2><br><h3>  1. Kunden </h3><br>  Dies ist nur eine Annahme, aber nur diejenigen Anwendungen, die vollst√§ndig serverseitig sind, werden davon profitieren.  Das Entwerfen von Software unter der Annahme, dass jeder Ihren Kunden hat, ist wie die Schaffung einer Gesellschaft unter der Annahme, dass jeder ehrlich ist.  Es w√§re auf jeden Fall praktisch, aber Sie m√ºssen davon ausgehen, dass es niemals passieren wird. <br><br>  Ich denke, es wird eine rasche Zunahme von Ger√§ten mit Zugang zum Web geben, und wir k√∂nnen davon ausgehen, dass sie grundlegende HTML- und Formularfunktionen unterst√ºtzen.  Haben Sie einen Browser auf Ihrem Handy?  Befindet sich in Ihrem PalmPilot ein Telefon?  Wird Ihr BlackBerry einen gr√∂√üeren Bildschirm haben?  Wirst du die M√∂glichkeit haben, von deinem Gameboy aus online zu gehen?  Von deiner Uhr?  Ich wei√ü nicht.  Und ich muss nicht herausfinden, ob ich darauf wette, dass sich alles auf dem Server befindet.  Es ist einfach viel zuverl√§ssiger, alle Gehirne auf dem Server zu haben.  . <br><br><h3>  2. Objektorientierte Programmierung </h3><br>  Ich verstehe, dass dies eine kontroverse Aussage ist, aber ich denke nicht, dass OOP etwas Wichtiges ist.  Ich denke, dies ist ein geeignetes Paradigma f√ºr bestimmte Anwendungen, die bestimmte Datenstrukturen ben√∂tigen, wie Fenstersysteme, Simulationen, CAD-Systeme.  Ich verstehe aber nicht, warum es f√ºr alle Programme geeignet sein soll. <br><br>  Ich denke, dass die Leute in gro√üen Unternehmen OOP lieben, zum Teil, weil es eine Menge von dem bietet, was nach Arbeit aussieht.  Was nat√ºrlich als eine Liste von ganzen Zahlen dargestellt werden kann, kann jetzt als eine Klasse mit allen Arten von Ger√ºsten, mit L√§rm und Hektik dargestellt werden. <br><br>  Ein weiteres attraktives Merkmal von OOP ist, dass Methoden Ihnen einen gewissen Effekt erstklassiger Funktionen verleihen.  Dies ist jedoch keine Neuigkeit f√ºr Lisp-Programmierer.  Wenn Sie echte Funktionen der ersten Klasse haben, k√∂nnen Sie sie einfach in einer der Aufgabe entsprechenden Weise verwenden, anstatt alles aus Klassen und Methoden in eine Vorlage zu verschieben. <br><br>  Ich denke, dies bedeutet f√ºr das Sprachdesign, dass Sie OOP nicht zu tief einbetten sollten.  Vielleicht besteht die Antwort darin, allgemeinere und grundlegendere Dinge anzubieten und es den Menschen zu erm√∂glichen, beliebige Objektsysteme in Form von Bibliotheken zu entwerfen. <br><br><h3>  3. Entwurf vom Ausschuss </h3><br>  Wenn Ihre Sprache von einem Komitee verfasst wird, dann sind Sie nicht nur aus Gr√ºnden gefangen, die jeder kennt.  Jeder wei√ü, dass Komitees dazu neigen, ein klumpiges, inkonsistentes Sprachdesign zu erstellen.  Aber ich denke, dass die gro√üe Gefahr darin besteht, dass sie kein Risiko eingehen.  Wenn eine Person an der Spitze steht, geht sie das Risiko ein, dass das Komitee niemals zustimmt. <br><br>  Soll ich Risiken eingehen, um eine gute Sprache zu schaffen?  Viele Menschen vermuten, dass man beim Entwerfen einer Sprache der traditionellen Weisheit ziemlich nahe kommen sollte.  Ich wette, das ist es nicht.  In allem anderen, was Menschen tun, ist die Belohnung proportional zum Risiko.  Warum sollte das Sprachdesign anders sein? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477366/">https://habr.com/ru/post/de477366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477356/index.html">Bruteforce-Angriffserkennung durch NTLM mit Varonis</a></li>
<li><a href="../de477358/index.html">Wir laden Sie am 5. Dezember zu DINS DevOps EVENING ein: Wir sprechen √ºber ein Ereignisverarbeitungssystem, das Erfahrungen mit Influx austauscht</a></li>
<li><a href="../de477360/index.html">Was ist neu in SOLIDWORKS Simulation 2020?</a></li>
<li><a href="../de477362/index.html">Mehr als nur Anti-Spam: So holen Sie das Beste aus Ihrem Security Email Gateway heraus</a></li>
<li><a href="../de477364/index.html">Wie werde ich Java-Entwickler? Oder vielleicht Python w√§hlen?</a></li>
<li><a href="../de477370/index.html">Serverless PHP</a></li>
<li><a href="../de477372/index.html">Amazon verliert den Krieg gegen F√§lschungen</a></li>
<li><a href="../de477374/index.html">Fuzzing Z-Maschinen</a></li>
<li><a href="../de477378/index.html">Mixed Agile - Waterfall-Ansatz bei der Implementierung von Gesch√§ftsanwendungen (auch bekannt als Agile-like)</a></li>
<li><a href="../de477382/index.html">Esport - Profit machen: Mercedes, Megaphon, Wetten und Branding f√ºr den Esport</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>