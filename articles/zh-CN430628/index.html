<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏽 👨🏻‍🏭 🤱 财富算法，实现细节 🐑 🎮 😘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在过去的几周中，我一直在努力用C ++实现Fortune的算法 。 该算法需要很多2D点，并根据它们构建Voronoi图 。 如果您不知道什么是Voronoi图，请看一下该图： 


 对于每个称为“站点”的入口点，我们需要找到比这个地方更近的地方。 这样的点集形成了上图所示的单元格。 

 在《财...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>财富算法，实现细节</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430628/">在过去的几周中，我一直在努力用C ++实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fortune的算法</a> 。 该算法需要很多2D点，并根据它们构建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Voronoi图</a> 。 如果您不知道什么是Voronoi图，请看一下该图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br> 对于每个称为“站点”的入口点，我们需要找到比这个地方更近的地方。 这样的点集形成了上图所示的单元格。 <br><br> 在《财富》算法中，他及时地建立了这样的图表是很了不起的 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>n</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.936ex" height="2.419ex" viewBox="0 -780.1 5139 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="1593" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6C" x="2443" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6F" x="2742" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-67" x="3227" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="3708" y="0"></use><g transform="translate(4308,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-1"> O（n \ log n）</script>  （这是比较算法的最佳选择），其中 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> n </script> 是个地方。 <br><br> 我写这篇文章是因为我认为该算法的实现非常困难。 目前，这是我必须实现的最复杂的算法。 因此，我想分享我遇到的问题以及如何解决它们。 <br><br> 像往常一样，代码被发布在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上</a> ，并且我使用的所有参考资料都列在本文的结尾。 <br><a name="habracut"></a><br><h1> 财富算法说明 </h1><br> 我不会解释该算法的工作原理，因为其他人已经做得很好。 我可以建议您学习这两篇文章： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">here</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">here</a> 。 第二个非常有趣-作者用Javascript编写了一个交互式演示，对于理解算法的操作很有用。 如果您需要所有证据都更正规的方法，建议阅读《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>计算几何》第3版</em></a>第7章。 <br><br> 此外，我更喜欢处理没有详细记录的实现细节。 正是他们使算法的实现变得如此复杂。 特别是，我将重点介绍所使用的数据结构。 <br><br> 我只是写了该算法的伪代码，以便您了解其全局结构： <br><br><blockquote><pre> 将地点事件添加到每个地点的事件队列中
直到事件队列为空
    检索顶级事件
    如果事件是地方事件
        在海岸线上插入新弧线
        检查新的圈子活动
    否则
        在图中创建一个顶点
        我们从海岸线上去除了拉紧的弧线
        删除无效事件
        检查新的圈子活动 </pre></blockquote><br><h1> 图表数据结构 </h1><br> 我遇到的第一个问题是选择存储Voronoi图的方式。 <br><br> 我决定使用一种广泛用于计算几何的数据结构，称为双连接边列表（DCEL）。 <br><br> 我的<code>VoronoiDiagram</code>类使用四个容器作为字段： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiDiagram</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... private: std::vector&lt;Site&gt; mSites; std::vector&lt;Face&gt; mFaces; std::list&lt;Vertex&gt; mVertices; std::list&lt;HalfEdge&gt; mHalfEdges; }</span></span></code> </pre> <br> 我将详细讨论它们中的每一个。 <br><br>  <code>Site</code>类描述了入口点。 每个位置都有一个索引，这对于将其放入队列，坐标和指向单元格（ <code>face</code> ）的指针很有用： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Site</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index; Vector2 point; Face* face; };</code> </pre> <br> 单元的<code>Vertex</code>由<code>Vertex</code>类表示，它们只有一个坐标字段： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> Vector2 point; };</code> </pre> <br> 这是半边的实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HalfEdge</span></span></span><span class="hljs-class"> {</span></span> Vertex* origin; Vertex* destination; HalfEdge* twin; Face* incidentFace; HalfEdge* prev; HalfEdge* next; };</code> </pre> <br> 您可能想知道，什么是半肋骨？  Voronoi图中的一条边对于两个相邻的单元是公用的。 在DCEL数据结构中，我们将这些边分成两个半边，每个边对应一个半边，并由<code>twin</code>指针链接。 而且，半边缘具有起点和终点。  <code>incidentFace</code>字段指示半边线所属的面。  DCEL中的单元被实现为半边的循环双向链接列表，其中相邻的半边连接在一起。 因此，上一个和<code>next</code>字段指示单元格中的上一个和下一个半边缘。 <br><br> 下图显示了红色半边的所有这些字段： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/459/a46/ac3/459a46ac330ea630a58cb69d083a2a61.svg"></div><br> 最后， <code>Face</code>类定义了单元格。 它仅包含一个指向其位置的指针，另一个指向其半肋的指针。 选择哪个半边都无所谓，因为该单元格是一个封闭的多边形。 因此，在遍历循环链表时，我们可以访问所有半边。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face</span></span></span><span class="hljs-class"> {</span></span> Site* site; HalfEdge* outerComponent; };</code> </pre> <br><h1> 事件队列 </h1><br> 实现事件队列的标准方法是使用优先级队列。 在处理地点和圈子事件的过程中，我们可能需要从队列中删除圈子事件，因为它们不再有效。 但是大多数标准优先级队列实现不允许您删除不在最前面的项目。 这尤其适用于<code>std::priority_queue</code> 。 <br><br> 有两种方法可以解决此问题。 第一个更简单的方法是向事件添加<code>valid</code>标志。  <code>valid</code>最初设置为<code>true</code> 。 然后，不必从队列中删除circle事件，我们只需将其标志设置为<code>false</code> 。 最后，在处理主循环中的所有事件时，我们检查事件的<code>valid</code>标志值是否为<code>false</code> ，如果是，则直接跳过该事件并处理下一个事件。 <br><br> 我应用的第二种方法是不使用<code>std::priority_queue</code> 。 相反，我实现了自己的优先级队列，该队列支持删除其中包含的任何元素。 这样的队列的实现非常简单。 我选择此方法是因为它使算法代码更整洁。 <br><br><h1> 海岸线 </h1><br> 海岸线数据结构是算法的复杂部分。 如果实现不正确，则不能保证算法将在 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>n</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.936ex" height="2.419ex" viewBox="0 -780.1 5139 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="1593" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6C" x="2443" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6F" x="2742" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-67" x="3227" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="3708" y="0"></use><g transform="translate(4308,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-3"> O（n \ log n）</script>  。 获得这种时间复杂性的关键是使用自平衡树。 但是说起来容易做起来难！ <br><br> 建议我研究的大多数资源（上文提到的两篇文章和《 <em>计算几何》</em>一书）将海岸线实现为一棵树，其中内部节点表示断点，叶子表示弧形。 但是他们没有说如何平衡一棵树。 我认为这样的模型不是最好的，原因如下： <br><br><ul><li> 其中包含冗余信息：我们知道两个相邻弧之间有一个断点，因此没有必要将这些点表示为节点 </li><li> 它不足以实现自我平衡：只有断点形成的子树才能达到平衡。 我们确实无法平衡整个树，因为否则弧会成为内部节点和断点的叶子。 编写仅平衡内部节点形成的子树的算法对我来说就像一场噩梦。 </li></ul><br> 因此，我决定以不同的方式呈现海岸线。 在我的实现中，海岸线也是一棵树，但是所有节点都是弧形的。 这样的模型没有任何列出的缺点。 <br><br> 这是我的实现中<code>Arc</code> arc的定义： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class">{</span></span>RED, BLACK}; <span class="hljs-comment"><span class="hljs-comment">// Hierarchy Arc* parent; Arc* left; Arc* right; // Diagram VoronoiDiagram::Site* site; VoronoiDiagram::HalfEdge* leftHalfEdge; VoronoiDiagram::HalfEdge* rightHalfEdge; Event* event; // Optimizations Arc* prev; Arc* next; // Only for balancing Color color; };</span></span></code> </pre> <br> 前三个字段用于构造树。  <code>leftHalfEdge</code>字段指示由弧的最左点绘制的半边。  <code>rightHalfEdge</code>位于最右点绘制的半边上。 两个指针<code>prev</code>和<code>next</code>用于直接访问海岸线的上一个弧线和下一个弧线。 此外，它们还允许您绕过海岸线，成为双向链接列表。 最后，每个弧线都有一种用于平衡海岸线的颜色。 <br><br> 为了平衡海岸线，我决定采用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">红黑方案</a> 。 编写代码时，我受到《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">算法简介</a> 》一书的启发。 第13章介绍了两种有趣的算法， <code>insertFixup</code>和<code>deleteFixup</code> ，它们在插入或删除后平衡树。 <br><br> 但是，我无法使用书中所示的<code>insert</code>方法，因为键用于查找节点的插入点。 财富算法中没有键，我们只知道我们需要在海岸线的另一弧之前或之后插入弧。 为了实现这一点，我创建了<code>insertBefore</code>和<code>insertAfter</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Beachline::insertBefore(Arc* x, Arc* y) { <span class="hljs-comment"><span class="hljs-comment">// Find the right place if (isNil(x-&gt;left)) { x-&gt;left = y; y-&gt;parent = x; } else { x-&gt;prev-&gt;right = y; y-&gt;parent = x-&gt;prev; } // Set the pointers y-&gt;prev = x-&gt;prev; if (!isNil(y-&gt;prev)) y-&gt;prev-&gt;next = y; y-&gt;next = x; x-&gt;prev = y; // Balance the tree insertFixup(y); }</span></span></code> </pre> <br> 通过三个步骤在<code>x</code>之前插入<code>y</code> ： <br><br><ol><li> 寻找一个插入新节点的地方。 为此，我使用了以下观察：左子项<code>x</code>或右子项<code>x-&gt;prev</code>是<code>Nil</code> ，而<code>Nil</code>的子项在<code>x</code>之前和<code>x-&gt;prev</code> 。 </li><li> 在海岸线内部，我们保持双向链表的结构，因此必须相应地更新元素<code>x-&gt;prev</code> ， <code>y</code>和<code>x</code>的<code>prev</code>和<code>next</code>指针。 </li><li> 最后，我们只需调用本书中介绍的<code>insertFixup</code>方法来平衡树。 </li></ol><br>  <code>insertAfter</code>的实现类似。 <br><br> 从书中删除的方法可以直接实施。 <br><br><h1> 图表限制 </h1><br> 这是上述财富算法的输出： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/c3f/443/ed5c3f4438b59de6c99e1645effe0be6.png"></div><br> 图像边界上的单元格的某些边缘存在一个小问题：由于它们是无限的，因此未绘制它们。 <br><br> 更糟糕的是，一个单元可能不是单个片段。 例如，如果我们在同一条线上取三个点，那么中点将具有两个没有连接在一起的无限半边。 这不太适合我们，因为我们将无法访问半边之一，因为该单元格是边的链接列表。 <br><br> 为了解决这些问题，我们将限制图表。 我的意思是，我们将限制图中的每个单元，以使它们不再具有无限的边缘，并且每个单元都是封闭的多边形。 <br><br> 幸运的是，Fortune的算法使我们能够快速找到无尽的边缘：在算法结束时，它们对应于仍在海岸线中的半边缘。 <br><br> 我的限制算法收到一个框作为输入，包括三个步骤： <br><br><ol><li> 它提供了图的每个顶点在矩形内的位置。 </li><li> 切掉每一个无限的边缘。 </li><li> 关闭单元格。 </li></ol><br> 第1阶段很简单-如果矩形不包含顶点，我​​们只需要对其进行扩展即可。 <br><br> 第2阶段也非常简单-它包括计算射线与矩形之间的交点。 <br><br> 第三阶段也不是很复杂，只需要注意即可。 我分两个阶段执行。 首先，我将矩形的角点添加到应位于其顶点处的单元格中。 然后，确保单元的所有顶点都通过半边连接。 <br><br> 我建议您研究代码并询问是否需要有关此部分的详细信息。 <br><br> 这是边界算法的输出图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/910/a79/33f910a79c155bd8a395fca1fd590a72.png"></div><br> 现在我们看到所有边缘都被绘制了。 如果缩小，则可以确保所有单元格都已关闭： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f08/402/6a6/f084026a6afbf57b142a60e5cbc49edc.png"></div><br><h1> 矩形相交 </h1><br> 太好了！ 但是从文章开始的第一张图片更好，对吧？ <br><br> 在许多应用中，使Voronoi图与矩形相交是很有用的，如第一幅图所示。 <br><br> 好消息是，在限制图表之后，这容易得多。 坏消息是，尽管算法不是很复杂，但我们仍需小心。 <br><br> 这个想法是这样的：我们绕过每个像元的半边并检查半边与矩形之间的交点。 可能有五种情况： <br><br><ol><li> 半肋完全位于矩形内部：我们保存了一个半肋 </li><li> 半肋完全位于矩形的外部：我们丢弃了这样一个半肋 </li><li> 半肋超出矩形的范围：我们截断半肋并将其保存为<em>最后出现的半肋</em> 。 </li><li> 半肋进入矩形内部：我们将半肋截断以将其与<em>最后一个出去</em>的半肋连接起来（在3或5的情况下将其保存） </li><li> 半肋穿过矩形两次：我们截断半肋，并添加一个半肋以使其与<em>最后</em>一个出的半肋关联，然后将其保存为新的<em>最后一个半肋</em> 。 </li></ol><br> 是的，有很多情况。 我创建了一张图片以显示所有图片： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/368/3f1/4123683f10d59989d879315f2f83ae17.svg"></div><br> 橙色多边形是原始单元格，红色是截断的单元格。 截断的半肋标记为红色。 添加了绿色肋骨，以连接进入矩形的半肋与半肋出来。 <br><br> 将此算法应用于有界图，我们可以得到预期的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br><h1> 结论 </h1><br> 原来这篇文章很长。 而且我敢肯定，您仍然不清楚很多方面。 但是，我希望它对您有用。 检查代码以获取详细信息。 <br><br> 总结并确保我们不会白白浪费时间，我在（便宜的）笔记本电脑上测量了计算不同地方的Voronoi图的时间： <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mn>1000</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.143ex" height="1.937ex" viewBox="0 -728.2 3936.6 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="1501" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>1000</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> n = 1000 </script>  ：2毫秒 </li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>$</mo></mrow><mn>10</mn><mo>,</mo><mn>00</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.339ex" height="2.539ex" viewBox="0 -832 4882.2 1093.4" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-2C" x="3436" y="0"></use><g transform="translate(3881,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mo>$</mo></mrow><mn>10</mn><mo>,</mo><mn>00</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> n = $ 10,00</script>  ：33毫秒 </li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>$</mo></mrow><mn>100</mn><mo>,</mo><mn>00</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.502ex" height="2.539ex" viewBox="0 -832 5382.7 1093.4" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-24" x="1934" y="0"></use><g transform="translate(2435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-2C" x="3936" y="0"></use><g transform="translate(4381,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mo>$</mo></mrow><mn>100</mn><mo>,</mo><mn>00</mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> n = $ 100,00</script>  ：450毫秒 </li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>$</mo></mrow><mn>1</mn><mo>,</mo><mn>000</mn><mo>,</mo><mn>00</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.698ex" height="2.539ex" viewBox="0 -832 6328.4 1093.4" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-24" x="1934" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-31" x="2435" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-2C" x="2935" y="0"></use><g transform="translate(3380,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-2C" x="4882" y="0"></use><g transform="translate(5327,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj5Z9NHAXril5DYWDAosl1lpeOM8g#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mo>$</mo></mrow><mn>1</mn><mo>,</mo><mn>000</mn><mo>,</mo><mn>00</mn></math></span></span><script type="math/tex" id="MathJax-Element-7"> n = $ 1,000,00</script>  ：6600毫秒 </li></ul><br> 我没有什么可与这些指标进行比较，但是看来它是如此之快！ <br><br><h1> 参考文献 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stephen Fortune的原始文章</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>计算几何，</em></a> Mark de Berg，Otfried Cheong，Marc van Kreveld和Mark Overmars的第三版 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">财富算法：</a> jacquesheunis.com上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的直观解释</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fortune的算法及其</a>在blog.ivank.net上的实现 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>算法入门，第三版</em></a> ，托马斯·H·科门，查尔斯·E·雷森，罗纳德·里维斯特和克利福德·斯坦 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430628/">https://habr.com/ru/post/zh-CN430628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430616/index.html">11月27日，莫斯科“测试与监视”研讨会</a></li>
<li><a href="../zh-CN430618/index.html">Vue.js SSR和Mobile Safari：过于智能的软件带来的明显问题</a></li>
<li><a href="../zh-CN430620/index.html">功能思维。 第4部分</a></li>
<li><a href="../zh-CN430622/index.html">功能思维。 第5部分</a></li>
<li><a href="../zh-CN430626/index.html">莫斯科GraphQL聚会的公告</a></li>
<li><a href="../zh-CN430630/index.html">60年代和2016年的两球运动鞋比较。 从鞋底到鞋带</a></li>
<li><a href="../zh-CN430632/index.html">商业服务：外国零售商如何在俄罗斯开设交钥匙商店</a></li>
<li><a href="../zh-CN430634/index.html">为XELTEK SuperPro 6100编程器创建软件模块</a></li>
<li><a href="../zh-CN430636/index.html">小脑和基底核而不是水晶球：大脑如何预测未来</a></li>
<li><a href="../zh-CN430640/index.html">红海：为什么苹果和其他科技公司的股票正在下跌</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>