<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—ï¸ ğŸ§— ğŸ’ Optimalisasi pengumpulan sampah di layanan .NET yang sangat dimuat ğŸ‘¨â€ğŸ”§ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ¾ ğŸ”</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap hari, puluhan ribu karyawan dari beberapa ribu organisasi di seluruh dunia bekerja di Pyrus. Kami menganggap responsif layanan (kecepatan permi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi pengumpulan sampah di layanan .NET yang sangat dimuat</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452298/">  Setiap hari, puluhan ribu karyawan dari beberapa ribu organisasi di seluruh dunia bekerja di Pyrus.  Kami menganggap responsif layanan (kecepatan permintaan pemrosesan) merupakan keunggulan kompetitif yang penting, karena secara langsung memengaruhi pengalaman pengguna.  Metrik utama bagi kami adalah "persentase permintaan lambat".  Mempelajari perilakunya, kami perhatikan bahwa sekali semenit pada server aplikasi ada jeda sekitar 1000 ms panjangnya.  Pada interval ini, server tidak merespons dan muncul beberapa lusin permintaan.  Pencarian untuk penyebab dan penghapusan hambatan yang disebabkan oleh pengumpulan sampah dalam aplikasi akan dibahas dalam artikel ini. <br><br><img src="https://habrastorage.org/webt/fu/1s/j9/fu1sj9ixpj4nc633ikhwblbhlfs.jpeg"><br><a name="habracut"></a><br>  Bahasa pemrograman modern dapat dibagi menjadi dua kelompok.  Dalam bahasa seperti C / C ++ atau Rust, manajemen memori manual digunakan, sehingga programmer menghabiskan lebih banyak waktu menulis kode, mengelola masa objek, dan kemudian debugging.  Pada saat yang sama, bug karena penggunaan memori yang tidak tepat adalah beberapa yang paling sulit untuk di-debug, sehingga sebagian besar pengembangan modern dilakukan dalam bahasa dengan manajemen memori otomatis.  Ini termasuk, misalnya, Java, C #, Python, Ruby, Go, PHP, JavaScript, dll.  Programmer menghemat waktu pengembangan, tetapi Anda harus membayar waktu eksekusi tambahan yang dihabiskan program secara teratur pada pengumpulan sampah - membebaskan memori yang ditempati oleh objek yang tidak ada tautan yang tersisa dalam program.  Dalam program kecil, waktu ini dapat diabaikan, tetapi karena jumlah objek meningkat dan intensitas pembuatannya, pengumpulan sampah mulai memberikan kontribusi nyata terhadap total waktu pelaksanaan program. <br><br>  Server web Pyrus berjalan pada platform .NET, yang menggunakan manajemen memori otomatis.  Sebagian besar pengumpulan sampah adalah 'hentikan dunia', mis.  pada saat pekerjaan mereka, mereka menghentikan semua utas aplikasi.  Rakitan non-pemblokiran (latar belakang) sebenarnya juga menghentikan semua utas, tetapi untuk periode yang sangat singkat.  Selama pemblokiran utas, server tidak memproses permintaan, permintaan yang ada membeku, yang baru ditambahkan ke antrian.  Akibatnya, permintaan yang diproses pada saat pengumpulan sampah langsung melambat, dan permintaan diproses lebih lambat segera setelah pengumpulan sampah selesai karena akumulasi antrian.  Ini memperparah metrik "persentase kueri lambat." <br><br>  Berbekal buku yang baru-baru ini diterbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konrad Kokosa: Pro .NET Memory Management</a> (tentang bagaimana kami membawa salinan pertamanya ke Rusia dalam 2 hari, Anda dapat menulis posting terpisah), sepenuhnya dikhususkan untuk topik manajemen memori di .NET, kami mulai mempelajari masalahnya. <br><br><h2>  Pengukuran </h2><br>  Untuk profil server web Pyrus, kami menggunakan utilitas PerfView ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/Microsoft/perfview</a> ), dipertajam untuk profil aplikasi NET.  Utilitas ini didasarkan pada mesin Event Tracing for Windows (ETW) dan memiliki dampak minimal pada kinerja aplikasi yang diprofilkan, yang memungkinkannya digunakan pada server tempur.  Selain itu, dampak pada kinerja tergantung pada jenis acara apa dan informasi apa yang kami kumpulkan.  Kami tidak mengumpulkan apa pun - aplikasi berfungsi seperti biasa.  Selain itu, PerfView tidak memerlukan kompilasi ulang atau memulai ulang aplikasi. <br><br>  Jalankan jejak PerfView dengan parameter / GCCollectOnly (lacak waktu 1,5 jam).  Dalam mode ini, ia hanya mengumpulkan acara pengumpulan sampah dan memiliki dampak minimal pada kinerja.  Mari kita lihat laporan jejak Memory Group / GCStats, dan di dalamnya ada ringkasan peristiwa pengumpul sampah: <br><br><img src="https://habrastorage.org/webt/v4/ia/cd/v4iacdyso10-0toycwyijfm0zbm.png"><br><br>  Di sini kita melihat beberapa indikator menarik sekaligus: <br><ul><li>  Waktu jeda build rata-rata pada generasi ke-2 adalah 700 milidetik, dan jeda maksimum adalah sekitar satu detik.  Gambar ini menunjukkan waktu di mana semua utas dalam aplikasi .NET berhenti, khususnya, jeda ini akan ditambahkan ke semua permintaan yang diproses. <br></li><li>  Jumlah majelis dari generasi ke-2 sebanding dengan generasi ke-1 dan sedikit lebih sedikit dari jumlah majelis dari generasi ke-0. <br></li><li>  Kolom yang diinduksi mencantumkan 53 majelis di generasi ke-2.  Perakitan terinduksi adalah hasil dari panggilan eksplisit ke GC.Collect ().  Dalam kode kami, kami tidak menemukan satu panggilan pun ke metode ini, yang berarti bahwa beberapa perpustakaan yang digunakan oleh aplikasi kami yang harus disalahkan. <br></li></ul><br>  Mari kita jelaskan pengamatan tentang jumlah pengumpulan sampah.  Gagasan untuk membagi objek berdasarkan umurnya didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hipotesis generasi</a> : sebagian besar objek yang dibuat mati dengan cepat, dan sebagian besar sisanya berumur panjang (dengan kata lain, beberapa objek yang memiliki masa hidup "rata-rata").  Dalam mode ini pengumpul sampah .NET dipenjara, dan dalam mode ini majelis generasi kedua harus jauh lebih kecil daripada generasi ke-0.  Yaitu, untuk operasi optimal pengumpul sampah, kita harus menyesuaikan pekerjaan aplikasi kita dengan hipotesis generasi.  Mari kita merumuskan aturan sebagai berikut: objek harus mati dengan cepat, tanpa selamat ke generasi yang lebih tua, atau hidup untuk itu dan hidup di sana selamanya.  Aturan ini juga berlaku untuk platform lain yang menggunakan manajemen memori otomatis dengan pemisahan generasi, seperti Java. <br><br>  Data yang menarik bagi kami dapat diekstraksi dari tabel lain dalam laporan GCStats: <br><br><img src="https://habrastorage.org/webt/m5/7y/je/m57yjedgbkwfpbiwmjkvnbhgl4o.png"><br><br>  Berikut adalah beberapa kasus di mana aplikasi mencoba membuat objek besar (dalam .NET Framework objek dengan ukuran&gt; 85.000 byte dibuat di LOH - Large Object Heap), dan harus menunggu penyelesaian perakitan generasi ke-2, yang terjadi secara paralel di latar belakang.  Jeda pengalokasi ini tidak sepenting jeda pengumpul sampah, karena hanya memengaruhi satu utas.  Sebelum itu, kami menggunakan .NET Framework versi 4.6.1, dan dalam versi 4.7.1 Microsoft menyelesaikan pengumpul sampah, sekarang ini memungkinkan Anda untuk mengalokasikan memori di Tumpukan Objek Besar selama generasi latar belakang generasi ke-2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.microsoft.com / ru-ru / dotnet / framework / whats-new / # common-language-runtime-clr</a> <br>  Karena itu, kami meningkatkan ke versi terbaru 4.7.2 pada saat itu. <br><br><h2>  Build Generasi ke-2 </h2><br>  Mengapa kita memiliki banyak bangunan generasi yang lebih tua?  Asumsi pertama adalah bahwa kita memiliki kebocoran memori.  Untuk menguji hipotesis ini, mari kita lihat ukuran generasi kedua (kami menyiapkan pemantauan penghitung kinerja yang sesuai di Zabbix).  Dari grafik ukuran generasi ke-2 untuk 2 server Pyrus, dapat dilihat bahwa ukurannya pertama kali tumbuh (terutama karena pengisian cache), tetapi kemudian stabil (kegagalan besar pada grafik - restart rutin layanan web untuk memperbarui versi): <br><br><img src="https://habrastorage.org/webt/gg/lc/ce/gglcce4tssnhzgcjfhesec9rcja.png"><br><br>  Ini berarti bahwa tidak ada kebocoran memori yang nyata, yaitu, sejumlah besar rakitan generasi ke-2 terjadi karena alasan lain.  Hipotesis berikutnya adalah bahwa ada banyak lalu lintas memori, yaitu, banyak objek jatuh ke generasi ke-2, dan banyak objek mati di sana.  PerfView memiliki mode / GCOnly untuk menemukan objek tersebut.  Dari laporan jejak, mari kita perhatikan 'Gen 2 Object Deaths (Coarse Sampling) Stacks', yang berisi pilihan objek yang mati pada generasi ke-2, bersama dengan tumpukan panggilan dari tempat-tempat di mana objek-objek ini dibuat.  Di sini kita melihat hasil berikut: <br><br><img src="https://habrastorage.org/webt/h7/r2/d0/h7r2d0htyxsnaqrr_ekn_ybilti.png"><br><br>  Setelah membuka baris, di dalam kita melihat tumpukan panggilan tempat-tempat dalam kode yang membuat objek yang hidup hingga generasi ke-2.  Diantaranya adalah: <br><ul><li>  System.Byte [] Jika Anda melihat ke dalam, kita akan melihat bahwa lebih dari setengahnya adalah buffer untuk serialisasi di JSON: <br></li></ul><br><img src="https://habrastorage.org/webt/la/up/6v/laup6v0mho5e1tbwjfkfmsgdhog.png"><br><br><ul><li>  Slot [System.Int32] [] (ini adalah bagian dari implementasi HashSet), System.Int32 [], dll.  Ini adalah kode kami yang menghitung cache klien - direktori, formulir, daftar, teman, dll yang dilihat pengguna ini dan yang di-cache di browser atau aplikasi selulernya: <br></li></ul><br><img src="https://habrastorage.org/webt/dx/et/jy/dxetjyvj2ande72qrod6leza6i8.png"><br><br><img src="https://habrastorage.org/webt/v6/k6/r-/v6k6r-wq0qeof0edb6h5jvct-he.png"><br><br>  Menariknya, buffer untuk JSON dan untuk menghitung cache klien adalah semua objek sementara yang hidup berdasarkan permintaan yang sama.  Mengapa mereka hidup sampai generasi ke-2?  Perhatikan bahwa semua objek ini adalah array dengan ukuran yang agak besar.  Dan pada ukuran&gt; 85000 byte, memori untuk mereka dialokasikan di Large Object Heap, yang hanya dikumpulkan bersama dengan generasi ke-2. <br><br>  Untuk memeriksa, buka bagian 'GC Heap Alloc Ignore Free (Coarse Sampling) tumpukan' di perfview / hasil GCOnly.  Di sana kita melihat garis LargeObject, di mana PerfView mengelompokkan pembuatan objek besar, dan di dalamnya kita melihat semua array yang sama yang kita lihat dalam analisis sebelumnya.  Kami mengakui penyebab utama masalah dengan pengumpul sampah: kami membuat banyak objek besar sementara. <br><br><img src="https://habrastorage.org/webt/sy/kr/lk/sykrlkgbmvl9jyny5hl1_ftg4ee.png"><br><br><img src="https://habrastorage.org/webt/f9/6q/mp/f96qmplnj4devma1buedg6fpo8q.png"><br><br><h2>  Perubahan dalam sistem Pyrus </h2><br>  Berdasarkan hasil pengukuran, kami mengidentifikasi bidang utama pekerjaan lebih lanjut: perjuangan melawan objek besar saat menghitung cache klien dan serialisasi di JSON.  Ada beberapa solusi untuk masalah ini: <br><ul><li>  Hal paling sederhana adalah tidak membuat objek besar.  Misalnya, jika buffer B besar digunakan dalam transformasi data sekuensial A-&gt; B-&gt; C, maka kadang-kadang transformasi ini dapat digabungkan dengan mengubahnya menjadi A-&gt; C, dan menyingkirkan membuat objek B. Opsi ini tidak selalu berlaku, tetapi yang paling sederhana dan paling efektif. <br></li><li>  Kolam objek.  Daripada terus-menerus membuat objek baru dan membuangnya, memuat pengumpul sampah, kita dapat menyimpan koleksi objek gratis.  Dalam kasus paling sederhana, ketika kita membutuhkan objek baru, kita mengambilnya dari kolam, atau membuat yang baru jika kolam itu kosong.  Ketika kita tidak lagi membutuhkan objek, kita mengembalikannya ke kolam.  Contoh yang baik adalah ArrayPool dalam .NET Core, yang juga tersedia dalam .NET Framework sebagai bagian dari paket System.Buffers Nuget. <br></li><li>  Gunakan benda kecil, bukan yang besar. <br></li></ul><br>  Mari kita pertimbangkan secara terpisah kedua kasus objek besar - komputasi cache klien dan serialisasi di JSON. <br><br><h2>  Perhitungan Cache Klien </h2><br>  Klien web dan aplikasi seluler Pyrus melakukan cache data yang tersedia bagi pengguna (proyek, formulir, pengguna, dll.) Caching digunakan untuk mempercepat pekerjaan, juga diperlukan untuk bekerja dalam mode offline.  Tembolok dihitung pada server dan ditransfer ke klien.  Mereka bersifat individual untuk setiap pengguna, karena mereka bergantung pada hak akses mereka, dan sering diperbarui, misalnya, ketika mengubah direktori yang ia akses. <br><br>  Dengan demikian, banyak perhitungan cache klien secara teratur dilakukan di server, dan banyak objek sementara berumur pendek dibuat.  Jika pengguna adalah organisasi besar, maka ia bisa mendapatkan akses ke banyak objek, masing-masing, cache klien untuknya akan besar.  Itulah sebabnya kami melihat alokasi memori untuk array sementara besar di Tumpukan Objek Besar. <br><br>  Mari kita menganalisis opsi yang diusulkan untuk menghilangkan penciptaan objek besar: <br><ul><li>  Pembuangan lengkap benda besar.  Pendekatan ini tidak berlaku, karena algoritma persiapan data menggunakan, antara lain, penyortiran dan penyatuan set, dan mereka membutuhkan buffer sementara. <br></li><li>  Menggunakan kumpulan benda.  Pendekatan ini mengalami kesulitan: <br><ul><li>  Variasi koleksi yang digunakan dan jenis elemen di dalamnya: HashSet, List dan Array digunakan (2 yang terakhir dapat dikombinasikan).  Int32, Int64, serta semua jenis kelas data disimpan dalam koleksi.  Untuk setiap jenis yang digunakan, Anda akan membutuhkan kolam Anda sendiri, yang juga akan menyimpan koleksi ukuran yang berbeda. <br></li><li>  Koleksi waktu hidup yang sulit.  Untuk mendapatkan manfaat dari kolam, benda di dalamnya harus dikembalikan setelah digunakan.  Ini dapat dilakukan jika objek digunakan dalam satu metode.  Tetapi dalam kasus kami situasinya lebih rumit, karena banyak objek besar bergerak di antara metode, dimasukkan ke dalam struktur data, dipindahkan ke struktur lain, dll. <br></li><li>  Implementasi.  Ada ArrayPool dari Microsoft, tetapi kami masih membutuhkan List dan HashSet.  Kami tidak menemukan perpustakaan yang cocok, jadi kami harus mengimplementasikan kelas sendiri. </li></ul></li><li>  Gunakan benda kecil.  Array besar dapat dibagi menjadi beberapa bagian kecil, yang saya tidak akan memuat Heap Obyek Besar, tetapi akan dibuat pada generasi 0, dan kemudian pergi di sepanjang jalur standar di 1 dan 2.  Kami berharap bahwa mereka tidak akan hidup sampai ke-2, tetapi akan dikumpulkan oleh pemulung di tanggal 0, atau dalam kasus-kasus ekstrem di generasi 1.  Keuntungan dari pendekatan ini adalah bahwa perubahan kode yang ada minimal.  Kesulitan: <br><ul><li>  Implementasi.  Kami tidak menemukan perpustakaan yang cocok, jadi kami harus menulis sendiri kelasnya.  Kurangnya perpustakaan dapat dipahami, karena skenario "koleksi yang tidak memuat Tumpukan Objek Besar" adalah ruang lingkup yang sangat sempit. </li></ul></li></ul><br>  Kami memutuskan untuk pergi di jalan ke-3 dan <strike>menciptakan sepeda kami</strike> untuk menulis Daftar dan HashSet, tidak memuat Heap Objek Besar. <br><br><h2>  Daftar bagian </h2><br>  ChunkedList &lt;T&gt; kami mengimplementasikan antarmuka standar, termasuk IList &lt;T&gt;, yang memerlukan perubahan minimal pada kode yang ada.  Ya, dan pustaka Newtonsoft.Json yang kami gunakan secara otomatis dapat membuat cerita bersambung, karena mengimplementasikan IEnumerable &lt;T&gt;: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ChunkedList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">ICollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>, <span class="hljs-title"><span class="hljs-title">IList</span></span>, <span class="hljs-title"><span class="hljs-title">ICollection</span></span>, <span class="hljs-title"><span class="hljs-title">IReadOnlyList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IReadOnlyCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; {</code> </pre> <br>  Daftar standar &lt;T&gt; memiliki bidang-bidang berikut: array untuk elemen dan jumlah elemen yang diisi.  Di ChunkedList &lt;T&gt; ada array array elemen, jumlah array yang terisi penuh, jumlah elemen dalam array terakhir.  Masing-masing array elemen dengan kurang dari 85.000 byte: <br><br><img src="https://habrastorage.org/webt/72/zj/js/72zjjs9q6lcfud-l7nq8cy5prdi.png"><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T[][] chunks; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentChunk; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentChunkSize;</code> </pre> <br>  Karena ChunkedList &lt;T&gt; agak rumit, kami menulis tes terperinci.  Setiap operasi harus diuji dalam setidaknya 2 mode: dalam "kecil" ketika seluruh daftar cocok dalam satu potong hingga 85.000 byte dalam ukuran, dan "besar" ketika terdiri dari lebih dari satu bagian.  Selain itu, untuk metode yang mengubah ukuran (misalnya, Tambah), skenarionya bahkan lebih besar: "kecil" -&gt; "kecil", "kecil" -&gt; "besar", "besar" -&gt; "besar", "besar" -&gt; " kecil. "  Di sini ada beberapa kasus batas yang membingungkan yang dilakukan dengan baik oleh unit test. <br><br>  Situasi ini disederhanakan oleh fakta bahwa beberapa metode dari antarmuka IList tidak digunakan, dan mereka dapat dihilangkan (seperti Sisipkan, Hapus).  Implementasi dan pengujian mereka akan sangat mahal.  Selain itu, tes unit penulisan disederhanakan oleh fakta bahwa kita tidak perlu membuat fungsionalitas baru, ChunkedList &lt;T&gt; harus berperilaku sama dengan List &lt;T&gt;.  Artinya, semua tes disusun sebagai berikut: buat Daftar &lt;T&gt; dan ChunkedList &lt;T&gt;, jalankan operasi yang sama dengannya dan bandingkan hasilnya. <br><br>  Kami mengukur kinerja menggunakan perpustakaan BenchmarkDotNet untuk memastikan bahwa kami tidak memperlambat banyak kode kami ketika beralih dari Daftar &lt;T&gt; ke ChunkedList &lt;T&gt;.  Mari kita coba, misalnya, menambahkan item ke daftar: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ChunkedList&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChunkedList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChunkedList&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) list.Add(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> <br>  Dan tes yang sama menggunakan Daftar &lt;T&gt; untuk perbandingan.  Hasil saat menambahkan 500 elemen (semuanya cocok dalam satu array): <br><div class="scrollable-table"><table><tbody><tr><td>  Metode </td><td>  Berarti </td><td>  Kesalahan </td><td>  Stddev </td><td>  Kejadian 0 / 1k Op </td><td>  Kej 1 / 1k Op </td><td>  Kej 2 / 1k Op </td><td>  Memori yang dialokasikan / Op </td></tr><tr><td>  Daftar standar </td><td>  1.415 kami </td><td>  0,0149 kami </td><td>  0,0140 kami </td><td>  0,6847 </td><td>  0,0095 </td><td>  - </td><td>  4,21 KB </td></tr><tr><td>  Daftar chunked </td><td>  3.728 kami </td><td>  0,0238 kami </td><td>  0,0222 us </td><td>  0,6943 </td><td>  0,0076 </td><td>  - </td><td>  4,28 KB </td></tr></tbody></table></div><br>  Hasil saat menambahkan 50.000 elemen (dibagi menjadi beberapa array): <br><div class="scrollable-table"><table><tbody><tr><td>  Metode </td><td>  Berarti </td><td>  Kesalahan </td><td>  Stddev </td><td>  Kejadian 0 / 1k Op </td><td>  Kej 1 / 1k Op </td><td>  Kej 2 / 1k Op </td><td>  Memori yang dialokasikan / Op </td></tr><tr><td>  Daftar standar </td><td>  146.273 kami </td><td>  3.1466 kami </td><td>  4.8053 kami </td><td>  124.7559 </td><td>  124.7559 </td><td>  124.7559 </td><td>  513.23 KB </td></tr><tr><td>  Daftar chunked </td><td>  287.687 kami </td><td>  1.4630 kami </td><td>  1.2969 kami </td><td>  41.5039 </td><td>  20.5078 </td><td>  - </td><td>  256.75 KB </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">Penjelasan rinci tentang kolom dalam hasil</b> <div class="spoiler_text"><pre> <code class="cs hljs">BenchmarkDotNet=v0<span class="hljs-number"><span class="hljs-number">.11</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>, OS=Windows <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.17763</span></span><span class="hljs-number"><span class="hljs-number">.379</span></span> (<span class="hljs-number"><span class="hljs-number">1809</span></span>/October2018Update/Redstone5) Intel Core i7<span class="hljs-number"><span class="hljs-number">-8700</span></span>K CPU <span class="hljs-number"><span class="hljs-number">3.70</span></span>GHz (Coffee Lake), <span class="hljs-number"><span class="hljs-number">1</span></span> CPU, <span class="hljs-number"><span class="hljs-number">12</span></span> logical and <span class="hljs-number"><span class="hljs-number">6</span></span> physical cores [Host] : .NET Framework <span class="hljs-number"><span class="hljs-number">4.7</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> (CLR <span class="hljs-number"><span class="hljs-number">4.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span><span class="hljs-number"><span class="hljs-number">.42000</span></span>), <span class="hljs-number"><span class="hljs-number">64b</span></span>it RyuJIT-v4<span class="hljs-number"><span class="hljs-number">.7</span></span><span class="hljs-number"><span class="hljs-number">.3324</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> DefaultJob : .NET Framework <span class="hljs-number"><span class="hljs-number">4.7</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> (CLR <span class="hljs-number"><span class="hljs-number">4.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span><span class="hljs-number"><span class="hljs-number">.42000</span></span>), <span class="hljs-number"><span class="hljs-number">64b</span></span>it RyuJIT-v4<span class="hljs-number"><span class="hljs-number">.7</span></span><span class="hljs-number"><span class="hljs-number">.3324</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-comment"><span class="hljs-comment">// * Hints * Outliers ListAdd.StandardList: Default -&gt; 2 outliers were removed ListAdd.ChunkedList: Default -&gt; 1 outlier was removed // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Gen 0/1k Op : GC Generation 0 collects per 1k Operations Gen 1/1k Op : GC Generation 1 collects per 1k Operations Gen 2/1k Op : GC Generation 2 collects per 1k Operations Allocated Memory/Op : Allocated memory per single operation (managed only, inclusive, 1KB = 1024B) 1 us : 1 Microsecond (0.000001 sec)</span></span></code> </pre> <br></div></div><br>  Jika Anda melihat kolom 'Mean', yang menampilkan waktu pelaksanaan pengujian rata-rata, Anda dapat melihat bahwa implementasi kami hanya 2-2,5 kali lebih lambat dari standar.  Mempertimbangkan bahwa dalam kode sebenarnya, operasi dengan daftar hanya sebagian kecil dari semua tindakan yang dilakukan, perbedaan ini menjadi tidak signifikan.  Tetapi kolom 'Gen 2 / 1k op' (jumlah rakitan generasi ke-2 per 1000 uji coba) menunjukkan bahwa kami telah mencapai tujuannya: dengan sejumlah besar elemen, ChunkedList tidak membuat sampah di generasi ke-2, yang merupakan tugas kami. <br><br><h2>  Sepotong set </h2><br>  Demikian pula, ChunkedHashSet &lt;T&gt; mengimplementasikan antarmuka ISet &lt;T&gt;.  Saat menulis ChunkedHashSet &lt;T&gt;, kami menggunakan kembali logika chunked kecil yang sudah diterapkan di ChunkedList.  Untuk melakukan ini, kami mengambil implementasi yang sudah jadi dari HashSet &lt;T&gt; dari .NET Reference Source, tersedia di bawah lisensi MIT, dan mengganti array dengan ChunkedLists di dalamnya. <br><br>  Dalam pengujian unit, kami juga menggunakan trik yang sama dengan daftar: kami akan membandingkan perilaku ChunkedHashSet &lt;T&gt; dengan referensi HashSet &lt;T&gt;. <br><br>  Akhirnya, tes kinerja.  Operasi utama yang kami gunakan adalah gabungan set, itulah sebabnya kami mengujinya: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ChunkedHashSet&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChunkedHashSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] source</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChunkedHashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> source) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.UnionWith(arr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Dan tes yang sama persis untuk HashSet standar.  Tes pertama untuk set kecil: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] { Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>).ToArray(), Enumerable.Range(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>).ToArray(), Enumerable.Range(<span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).ToArray(), }</code> </pre> <br><div class="scrollable-table"><table><tbody><tr><td>  Metode </td><td>  Berarti </td><td>  Kesalahan </td><td>  Stddev </td><td>  Kejadian 0 / 1k Op </td><td>  Kej 1 / 1k Op </td><td>  Kej 2 / 1k Op </td><td>  Memori yang dialokasikan / Op </td></tr><tr><td>  StandardHashSet </td><td>  30.16 kita </td><td>  0.1046 kami </td><td>  0,0979 kami </td><td>  9.3079 </td><td>  1.6785 </td><td>  - </td><td>  57,41 KB </td></tr><tr><td>  ChunkedHashSet </td><td>  73,54 kami </td><td>  0,5919 kita </td><td>  0,5247 kita </td><td>  9.5215 </td><td>  1.5869 </td><td>  - </td><td>  58,84 KB </td></tr></tbody></table></div><br>  Tes kedua untuk set besar yang menyebabkan masalah dengan banyak objek besar: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] { Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">30000</span></span>).ToArray(), Enumerable.Range(<span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">60000</span></span>).ToArray(), Enumerable.Range(<span class="hljs-number"><span class="hljs-number">30000</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>).ToArray(), }</code> </pre> <br><div class="scrollable-table"><table><tbody><tr><td>  Metode </td><td>  Berarti </td><td>  Kesalahan </td><td>  Stddev </td><td>  Kejadian 0 / 1k Op </td><td>  Kej 1 / 1k Op </td><td>  Kej 2 / 1k Op </td><td>  Memori yang dialokasikan / Op </td></tr><tr><td>  StandardHashSet </td><td>  3,031.30 kami </td><td>  32.0797 kami </td><td>  28.4378 kami </td><td>  699.2188 </td><td>  667.9688 </td><td>  664.0625 </td><td>  4718.23 KB </td></tr><tr><td>  ChunkedHashSet </td><td>  7.189,66 kita </td><td>  25.6319 kami </td><td>  23.9761 kami </td><td>  539.0625 </td><td>  265.6250 </td><td>  7.8125 </td><td>  3280,71 KB </td></tr></tbody></table></div><br>  Hasilnya mirip dengan daftar.  ChunkedHashSet lebih lambat 2-2,5 kali, tetapi pada saat yang sama pada set besar itu memuat 2 generasi ke 2 pesanan kurang besar. <br><br><h2>  Serialisasi di JSON </h2><br>  Server web Pyrus menyediakan beberapa API yang menggunakan serialisasi berbeda.  Kami menemukan pembuatan objek besar di API yang digunakan oleh bot dan utilitas sinkronisasi (selanjutnya disebut sebagai API Publik).  Perhatikan bahwa pada dasarnya API menggunakan serialisasi sendiri, yang tidak terpengaruh oleh masalah ini.  Kami menulis tentang ini di artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/en/post/227595/</a> , di bagian "2.  Anda tidak tahu di mana hambatan aplikasi Anda. "  Artinya, API utama sudah berfungsi dengan baik, dan masalah muncul di API Publik saat jumlah permintaan dan jumlah data dalam tanggapan bertambah. <br><br>  Mari mengoptimalkan API Publik.  Menggunakan contoh API utama, kami tahu bahwa Anda dapat mengembalikan respons kepada pengguna dalam mode streaming.  Artinya, Anda tidak perlu membuat buffer perantara yang berisi seluruh respons, tetapi tulis respons segera ke stream. <br><br>  Setelah diperiksa lebih dekat, kami menemukan bahwa dalam proses serialisasi respons, kami membuat buffer sementara untuk hasil antara ('konten' adalah array byte yang berisi JSON dalam pengkodean UTF-8): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serializer = Newtonsoft.Json.JsonSerializer.Create(...); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] content; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamWriter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UTF8Encoding(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Newtonsoft.Json.JsonTextWriter(sw)) { serializer.Serialize(writer, result); writer.Flush(); content = ms.ToArray(); }</code> </pre> <br>  Mari kita lihat di mana konten digunakan.  Untuk alasan historis, API Publik didasarkan pada WCF, yang XML adalah format permintaan dan respons standar.  Dalam kasus kami, respons XML memiliki elemen 'Biner' tunggal, yang di dalamnya JSON dikodekan dalam Base64 ditulis: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RawBodyWriter</span></span> : <span class="hljs-title"><span class="hljs-title">BodyWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] _content; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RawBodyWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] content</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { _content = content; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWriteBodyContents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">XmlDictionaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.WriteStartElement(<span class="hljs-string"><span class="hljs-string">"Binary"</span></span>); writer.WriteBase64(_content, <span class="hljs-number"><span class="hljs-number">0</span></span>, _content.Length); writer.WriteEndElement(); } }</code> </pre> <br>  Perhatikan bahwa penyangga sementara tidak diperlukan di sini.  JSON dapat ditulis langsung ke buffer XmlWriter yang disediakan WCF kepada kami, dengan menyandikannya di Base64 dengan cepat.  Jadi, kita akan pergi dengan cara pertama, menyingkirkan alokasi memori: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWriteBodyContents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">XmlDictionaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serializer = Newtonsoft.Json.JsonSerializer.Create(...); writer.WriteStartElement(<span class="hljs-string"><span class="hljs-string">"Binary"</span></span>); Stream stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Base64Writer(writer); Var sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamWriter(stream, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UTF8Encoding(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Newtonsoft.Json.JsonTextWriter(sw)) { serializer.Serialize(jsonWriter, _result); jsonWriter.Flush(); } writer.WriteEndElement(); }</code> </pre> <br>  Di sini Base64Writer adalah pembungkus sederhana di atas XmlWriter yang mengimplementasikan antarmuka Stream, yang menulis ke XmlWriter sebagai Base64.  Pada saat yang sama, dari seluruh antarmuka, cukup untuk mengimplementasikan hanya satu metode Write, yang disebut dalam StreamWriter: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base64Writer</span></span> : <span class="hljs-title"><span class="hljs-title">Stream</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> XmlWriter _writer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Base64Writer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">XmlWriter writer</span></span></span><span class="hljs-function">)</span></span> { _writer = writer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { _writer.WriteBase64(buffer, offset, count); } &lt;...&gt; }</code> </pre> <br><h2>  Diinduksi gc </h2><br>  Mari kita coba berurusan dengan pengumpulan sampah misterius yang diinduksi.  Kami memeriksa ulang kode kami 10 kali untuk panggilan GC.Collect, tetapi ini gagal.  Saya berhasil menangkap peristiwa ini di PerfView, tetapi tumpukan panggilan tidak terlalu indikatif (acara DotNETRuntime / GC / Triggered): <br><br><img src="https://habrastorage.org/webt/ye/j0/qg/yej0qglbieyx_tg05hdgutajhmc.png"><br><br>  Ada petunjuk kecil - memanggil RecycleLimitMonitor.RaiseRecycleLimitEvent sebelum pengumpulan sampah yang diinduksi.  Mari kita telusuri tumpukan panggilan ke metode RaiseRecycleLimitEvent: <br><br><pre> <code class="cs hljs">RecycleLimitMonitor.RaiseRecycleLimitEvent(...) RecycleLimitMonitor.RecycleLimitMonitorSingleton.AlertProxyMonitors(...) RecycleLimitMonitor.RecycleLimitMonitorSingleton.CollectInfrequently(...) RecycleLimitMonitor.RecycleLimitMonitorSingleton.PBytesMonitorThread(...)</code> </pre> <br>  Nama-nama metode ini konsisten dengan fungsinya: <br><ul><li>  Dalam konstruktor dari RecycleLimitMonitor.RecycleLimitMonitorSingleton, timer dibuat yang memanggil PBytesMonitorThread pada interval tertentu. <br></li><li>  PBytesMonitorThread mengumpulkan statistik tentang penggunaan memori dan, dalam beberapa kondisi, panggilan CollectInfrequently. <br></li><li>  CollectInfrequently memanggil AlertProxyMonitors, mendapat bool sebagai hasilnya, dan panggilan GC.Collect () jika itu benar.  Dia juga memantau waktu yang berlalu sejak panggilan terakhir ke pemulung, dan tidak terlalu sering memanggilnya. <br></li><li>  AlertProxyMonitors menelusuri daftar menjalankan aplikasi web IIS, untuk masing-masing memunculkan objek RecycleLimitMonitor yang sesuai, dan memanggil RaiseRecycleLimitEvent. <br></li><li>  RaiseRecycleLimitEvent memunculkan daftar IObserver &lt;RecycleLimitInfo&gt;.  Penangan menerima sebagai parameter RecycleLimitInfo, di mana mereka dapat mengatur flag RequestGC, yang kembali ke CollectInfrequently, menyebabkan pengumpulan sampah yang diinduksi. <br></li></ul><br><br>  Investigasi lebih lanjut mengungkapkan bahwa penangan IObserver &lt;RecycleLimitInfo&gt; ditambahkan dalam metode RecycleLimitMonitor.Subscribe (), yang disebut dalam metode AspNetMemoryMonitor.Subscribe ().  Juga, penangan IObserver &lt;RecycleLimitInfo&gt; default (kelas RecycleLimitObserver) digantung di kelas AspNetMemoryMonitor, yang membersihkan cache ASP.NET dan kadang-kadang meminta pengumpulan sampah. <br><br>  Teka-teki dari GC yang Diinduksi hampir terpecahkan.  Masih mencari tahu mengapa pengumpulan sampah ini disebut.  RecycleLimitMonitor memonitor penggunaan memori IIS (lebih tepatnya, jumlah byte pribadi), dan ketika penggunaannya mendekati batas tertentu, itu dimulai dengan algoritma yang agak membingungkan untuk meningkatkan event RaiseRecycleLimitEvent.  Nilai AspNetMemoryMonitor.ProcessPrivateBytesLimit digunakan sebagai batas memori, dan pada gilirannya itu berisi logika berikut: <br><ul><li>  Jika Application Pool di IIS diatur ke 'Private Memory Limit (KB)', maka nilai dalam kilobyte diambil dari sana <br></li><li>  Kalau tidak, untuk sistem 64-bit, 60% dari memori fisik diambil (untuk sistem 32-bit, logika lebih rumit). <br></li></ul><br>  Kesimpulan dari investigasi adalah ini: ASP.NET mendekati batas ingatannya dan mulai secara teratur memanggil pengumpulan sampah.  'Private Memory Limit (KB)' tidak disetel, sehingga ASP.NET dibatasi hingga 60% dari memori fisik.  Masalahnya ditutupi oleh fakta bahwa pada server Task Manager itu menunjukkan banyak memori bebas dan sepertinya itu hilang.  Kami telah meningkatkan nilai 'Batas Memori Pribadi (KB)' di pengaturan Application Pool di IIS hingga 80% dari memori fisik.  Ini mendorong ASP.NET untuk menggunakan lebih banyak memori yang tersedia.  Kami juga menambahkan pemantauan penghitung kinerja '.NET CLR Memory / # Induced GC' agar tidak ketinggalan saat berikutnya ASP.NET memutuskan bahwa ia mendekati batas penggunaan memori. <br><br><h2>  Pengukuran berulang </h2><br>  Mari kita lihat apa yang terjadi dengan pengumpulan sampah setelah semua perubahan ini.  Mari kita mulai dengan perfview / GCCollectOnly (lacak waktu - 1 jam), laporan GCStats: <br><br><img src="https://habrastorage.org/webt/8b/l3/fn/8bl3fnxpuymka28coyzbo0r5ak4.png"><br><br>  Dapat dilihat bahwa majelis dari generasi ke-2 sekarang 2 urutan besarnya lebih kecil dari ke-0 dan ke-1.  Juga, waktu majelis ini menurun.  Majelis yang diinduksi tidak lagi diamati.  Mari kita lihat daftar majelis dari generasi ke-2: <br><br><img src="https://habrastorage.org/webt/mx/oy/tv/mxoytvprkypunnhwtao6o6fboai.png"><br><br>  Kolom Gen menunjukkan bahwa semua majelis dari generasi ke-2 telah menjadi latar belakang ('2B' berarti generasi ke-2, Latar Belakang).  Artinya, sebagian besar pekerjaan dilakukan secara paralel dengan eksekusi aplikasi, dan semua utas diblokir untuk waktu yang singkat (kolom 'Jeda MSec').  Mari kita lihat jeda saat membuat objek besar: <br><br><img src="https://habrastorage.org/webt/qp/04/hp/qp04hpcq35buinfnfjn5uuudnyg.png"><br><br>  Dapat dilihat bahwa jumlah jeda tersebut saat membuat objek besar turun secara signifikan. <br><br><h2>  Ringkasan </h2><br>  Berkat perubahan yang dijelaskan dalam artikel, itu mungkin untuk secara signifikan mengurangi jumlah dan durasi majelis dari generasi ke-2.  Saya berhasil menemukan penyebab majelis yang diinduksi dan menyingkirkan mereka.  Jumlah majelis dari generasi 0 dan 1 meningkat, tetapi durasi rata-rata mereka menurun (dari ~ 200 ms hingga ~ 60 ms).  Durasi perakitan maksimum generasi 0 dan 1 telah menurun, tetapi tidak begitu terasa.  Majelis generasi ke-2 menjadi lebih cepat, jeda yang panjang hingga 1000 ms benar-benar hilang. <br><br>  Adapun metrik kunci - "persentase permintaan lambat", itu menurun sebesar 40% setelah semua perubahan. <br><br>  Berkat kerja kami, kami menyadari penghitung kinerja apa yang diperlukan untuk menilai situasi dengan memori dan pengumpulan sampah, menambahkannya ke Zabbix untuk pemantauan berkelanjutan.  Berikut adalah daftar yang paling penting yang kami perhatikan dan cari tahu alasannya (misalnya, peningkatan aliran permintaan, sejumlah besar data yang dikirimkan, bug dalam aplikasi): <br><div class="scrollable-table"><table><tbody><tr><td>  Penghitung kinerja </td><td>  Deskripsi </td><td>  Kapan harus memperhatikan </td></tr><tr><td>  \ Proses (*) \ Bytes Pribadi </td><td>  Jumlah memori yang dialokasikan untuk aplikasi </td><td rowspan="3">  Nilai jauh melebihi ambang batas.  Sebagai ambang, Anda dapat mengambil median selama 2 minggu dari nilai harian maksimum. </td></tr><tr><td>  \ .NET CLR Memory (*) \ # Gen 2 Koleksi </td><td>  Jumlah memori pada generasi yang lebih tua </td></tr><tr><td>  \ .NET CLR Memory (*) \ Ukuran Heap Objek Besar </td><td>  Jumlah memori untuk objek besar </td></tr><tr><td>  \ .NET CLR Memory (*) \% Waktu dalam GC </td><td>  Persentase waktu yang dihabiskan untuk mengumpulkan sampah </td><td>  Nilainya lebih dari 5%. </td></tr><tr><td>  \ .NET CLR Memory (*) \ # Induced GC </td><td>  Jumlah majelis terinduksi </td><td>  Nilai lebih besar dari 0. </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452298/">https://habr.com/ru/post/id452298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452284/index.html">Klasifikasi tutupan lahan menggunakan eo-learning. Bagian 1</a></li>
<li><a href="../id452288/index.html">Situasi: operator seluler AS dituduh melakukan perdagangan ilegal di geodata pelanggan</a></li>
<li><a href="../id452290/index.html">Apa yang dirindukan peretas saat merusak bank di hari PHD</a></li>
<li><a href="../id452294/index.html">Webinar "Karyawan - backdoor: teknik modern rekayasa sosial"</a></li>
<li><a href="../id452296/index.html">Positive Hack Days 9: Kontes Kompetitif Kompetitif 18 Mei</a></li>
<li><a href="../id452302/index.html">Program pendahuluan PyConRu-2019: dua Python Core Developers, pembicara dari Anaconda, Intel, JetBrains, Yandex</a></li>
<li><a href="../id452304/index.html">OpenAI AI Belajar Menulis Puisi, Artikel, dan Berita</a></li>
<li><a href="../id452306/index.html">Ke mana fintech pergi, bagaimana cara menghitung unit ekonomi dan mengapa mengembangkan kewirausahaan domestik. Mitap Yandex.Money</a></li>
<li><a href="../id452310/index.html">Menyiapkan saluran penjualan jaringan untuk gadget DO-RA</a></li>
<li><a href="../id452312/index.html">Telekomunikasi Inggris akan membayar kompensasi pelanggan untuk pemutusan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>