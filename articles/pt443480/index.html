<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêó üì• üèîÔ∏è Tokens criptogr√°ficos PKCS # 11: visualizando e exportando certificados, verificando sua validade üßîüèº üåú üíú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos coment√°rios ao artigo ‚ÄúUm utilit√°rio de plataforma cruzada em ingl√™s para exibi√ß√£o de certificados x509 qualificados russos‚Äù, havia um desejo de u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tokens criptogr√°ficos PKCS # 11: visualizando e exportando certificados, verificando sua validade</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443480/"><img src="https://habrastorage.org/webt/jg/xr/s2/jgxrs2y4nfsgsn6ljt8l0wpevgy.png" align="left" alt="imagem">  Nos coment√°rios ao artigo ‚ÄúUm utilit√°rio de plataforma cruzada em ingl√™s para exibi√ß√£o de certificados x509 qualificados russos‚Äù, havia um desejo de um usu√°rio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Pas</a> de ter n√£o apenas ‚Äúan√°lise de certificado‚Äù, mas tamb√©m receber ‚Äúcadeias de certificados raiz e realizar valida√ß√£o de PKI, pelo menos para certificados com tokens com uma chave extra√≠vel "  A obten√ß√£o de uma cadeia de certificados foi descrita em um dos artigos anteriores.  √â verdade que se tratava de certificados armazenados em arquivos, mas prometemos adicionar mecanismos para trabalhar com certificados armazenados nos tokens PKCS # 11.  E foi o que aconteceu no final. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/cg/vd/fw/cgvdfwfqdxc1tbvkkpcec_vzye8.png"><br><br>  O utilit√°rio de an√°lise e visualiza√ß√£o √© escrito em Tcl / Tk, e para adicionar tokens / smartcards PKCS # 11 a ele, visualizando certificados e verificando a validade dos certificados, foi necess√°rio resolver v√°rios problemas: <br><br><ul><li>  determinar o mecanismo para obter certificados do token / cart√£o inteligente; </li><li>  verifique o certificado em rela√ß√£o √† lista de certificados revogados CRL; </li><li>  verifique o certificado de validade pelo mecanismo OCSP. </li></ul><br><h3>  <font color="#0000ff">Acesso ao token PKCS # 11</font> </h3><br>  Para acessar o token e os certificados armazenados nele, usaremos o pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TclPKCS11</a> .  O pacote √© distribu√≠do em bin√°rios e em c√≥digos-fonte.  Os c√≥digos-fonte ser√£o √∫teis mais tarde, quando adicionarmos o suporte ao token com criptografia russa no pacote.  H√° duas maneiras de baixar o pacote TclPKCS11 ou use o comando tcl do formul√°rio: <br><br><pre><code class="plaintext hljs">load &lt; tclpkcs11&gt; Tclpkcs11</code> </pre> <br>  Ou fa√ßa o download simplesmente como o pacote pki :: pkcs11, depois de colocar a biblioteca tclpkcs11 e o arquivo pkgIndex.tcl em um diret√≥rio conveniente para voc√™ (no nosso caso, este √© o subdiret√≥rio pkcs11 do diret√≥rio atual) e adicion√°-lo ao caminho auto_path: <br><br><pre> <code class="plaintext hljs">#lappend auto_path [file dirname [info scrypt]] lappend auto_path pkcs11 package require pki package require pki::pkcs11</code> </pre> <br>  Como estamos interessados ‚Äã‚Äãem tokens principalmente com suporte para criptografia russa, a partir do pacote TclPKCS11, usaremos as seguintes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√µes</a> : <br><blockquote><pre> <code class="plaintext hljs">::pki::pkcs11::loadmodule &lt;filename&gt; -&gt; handle ::pki::pkcs11::unloadmodule &lt;handle&gt; -&gt; true/false ::pki::pkcs11::listslots &lt;handle&gt; -&gt; list: slotId label flags ::pki::pkcs11::listcerts &lt;handle&gt; &lt;slotId&gt; -&gt; list: keylist ::pki::pkcs11::login &lt;handle&gt; &lt;slotId&gt; &lt;password&gt; -&gt; true/false ::pki::pkcs11::logout &lt;handle&gt; &lt;slotId&gt; -&gt; true/false</code> </pre> </blockquote>  Fa√ßa imediatamente uma reserva de que as fun√ß√µes de login e logout n√£o ser√£o consideradas aqui.  Isso ocorre porque, neste artigo, trataremos apenas de certificados, e eles s√£o objetos p√∫blicos de token.  Para acessar objetos p√∫blicos, n√£o √© necess√°rio fazer login atrav√©s do c√≥digo PIN no token. <br><br>  A primeira fun√ß√£o :: pki :: pkcs11 :: loadmodule √© carregar a biblioteca PKCS # 11, que suporta o token / cart√£o inteligente no qual os certificados est√£o localizados.  Uma biblioteca pode ser obtida comprando um token, ou baixada da Internet, ou foi pr√©-instalada em um computador.  De qualquer forma, voc√™ precisa saber qual biblioteca suporta seu token.  A fun√ß√£o loadmodule retorna um identificador para a biblioteca carregada: <br><br><pre> <code class="plaintext hljs">set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" set handle [::pki::pkcs11::loadmodule $filelib]</code> </pre> <br>  Por conseguinte, existe uma fun√ß√£o para descarregar uma biblioteca carregada: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::unloadmodule $handle</code> </pre> <br>  Depois que a biblioteca for carregada e tivermos seu identificador, voc√™ poder√° obter uma lista de slots suportados por esta biblioteca: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::listslots $handle {0 {ruToken ECP } {TOKEN_PRESENT RNG LOGIN_REQUIRED USER_PIN_INITIALIZED TOKEN_INITIALIZED REMOVABLE_DEVICE HW_SLOT}} {1 { } {REMOVABLE_DEVICE HW_SLOT}} . . . {14 { } {REMOVABLE_D EVICE HW_SLOT}}</code> </pre> <br>  Neste exemplo, a lista cont√©m 15 (quinze de 0 a 14) elementos.  √â esse o n√∫mero de slots que a fam√≠lia de tokens RuToken pode suportar.  Por sua vez, cada elemento da lista em si √© uma lista de tr√™s elementos: <br><br><pre> <code class="plaintext hljs">{{ } { } {   }}</code> </pre> <br>  O primeiro elemento da lista √© o n√∫mero do slot.  O segundo elemento da lista √© o r√≥tulo localizado no slot de token (32 bytes).  Se o slot estiver vazio, o segundo elemento conter√° 32 espa√ßos.  E o √∫ltimo, terceiro elemento da lista cont√©m sinalizadores.  N√£o consideraremos todo o conjunto de sinalizadores.  O que nos interessa nesses sinalizadores √© a presen√ßa do sinalizador TOKEN_PRESENT.  √â esse sinalizador que indica que o token est√° no slot e os certificados de interesse para n√≥s podem estar no token.  Os sinalizadores s√£o uma coisa muito √∫til, descrevem o estado do token, o status dos c√≥digos PIN, etc.  Com base no valor dos sinalizadores, os tokens PKCS # 11 s√£o gerenciados: <br><br><img src="https://habrastorage.org/webt/yq/7x/n1/yq7xn1qbusjtjirrudo1ebhjzhc.png"><br><br>  Agora, nada impede que voc√™ escreva o procedimento slots_with_token, que retornar√° uma lista de slots com os r√≥tulos dos tokens: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path pkcs11 package require pki package require pki::pkcs11 #    proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] } set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" if {[catch {set handle [::pki::pkcs11::loadmodule $filelib]} res]} { puts "Cannot load library $filelib : $res" exit } #   set listslots {} set listslots [::slots_with_token $handle] #        while {[llength $listslots] == 0} { puts " " after 3000 set listslots [::slots_with_token $handle] } #        foreach {slotid labeltok} $listslots { puts "Number slot: $slotid" puts "Label token: $labeltok" }</code> </pre> <br>  Se voc√™ executar esse script, depois de salv√°-lo no arquivo slots_with_token.tcl, como resultado, obteremos: <br><br><pre> <code class="bash hljs">$ ./slots_with_token.tcl listtok(0) = ruToken ECP listtok(1) = RuTokenECP20 Number slot: 0 Label token: RuTokenECP20 Number slot: 1 Label token: ruToken ECP $</code> </pre> <br>  Dos 15 slots dispon√≠veis para esta biblioteca, apenas dois est√£o envolvidos, zero e o primeiro. <br>  Agora nada impede a obten√ß√£o de uma lista de certificados localizados em um token espec√≠fico: <br><br><pre> <code class="plaintext hljs">set listcerts [::pki::pkcs11::listcerts $handle $slotid]</code> </pre> <br>  Cada item da lista cont√©m informa√ß√µes sobre um certificado.  Para obter informa√ß√µes do certificado, a fun√ß√£o :: pki :: pkcs11 :: listcerts usa a fun√ß√£o :: pki :: x509 :: parse_cert do pacote pki.  Mas a fun√ß√£o :: pki :: pkcs11 :: listcerts complementa essa lista com dados inerentes ao protocolo PKCS # 11, a saber: <br><br><ul><li>  elemento de etiqueta pkcs11_ (na terminologia do atributo CKA_LABEL do PKCS # 11); </li><li>  elemento pkcs11_id (na terminologia do atributo CKA_ID do PKCS # 11); </li><li>  elemento pkcs11_handle que cont√©m uma indica√ß√£o da biblioteca PKCS # 11 carregada; </li><li>  elemento pkcs11_slotid que cont√©m o n√∫mero do slot com o token no qual este certificado est√° localizado; </li><li>  um elemento de tipo que cont√©m o valor pkcs11 para o certificado que est√° no token. </li></ul><br>  Lembre-se de que os elementos restantes s√£o determinados principalmente pela fun√ß√£o pki :: parse_cert. <br>  Abaixo est√° o procedimento para obter uma lista de r√≥tulos (listCert) de certificados (CKA_LABEL, pkcs11_label) e uma matriz de identificadores analisados ‚Äã‚Äã(:: certs_p11).  A chave para acessar o elemento da matriz de certificados √© o r√≥tulo do certificado (CKA_LABEL, pkcs11_label): <br><br><pre> <code class="plaintext hljs">#  proc listcerttok {handle token_slotlabel token_slotid} { #     set listCer {} #   array set ::arrayCer [] set ::certs_p11 [pki::pkcs11::listcerts $handle $token_slotid] if {[llength $::certs_p11] == 0} { puts {Certificates are not on the token:$tokenslotlabel} return $listCer } foreach certinfo_list $::certs_p11 { unset -nocomplain certinfo array set certinfo $certinfo_list set certinfo(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $certinfo(cert)] set ::arrayCer($certinfo(pkcs11_label)) $certinfo(cert) lappend listCer $certinfo(pkcs11_label) } return $listCer }</code> </pre> <br>  E agora que analisamos os certificados, exibimos silenciosamente uma lista de seus r√≥tulos na caixa de combina√ß√£o: <br><br><img src="https://habrastorage.org/webt/wd/7_/si/wd7_siithrzlh1gfwa5tm78rpbg.png"><br><br>  Como analisar chaves p√∫blicas GOST que consideramos no artigo anterior. <br><br>  Duas palavras sobre exporta√ß√£o de certificados.  Os certificados s√£o exportados tanto na codifica√ß√£o PEM quanto na codifica√ß√£o DER (bot√µes DER, formato PEM).  O pacote pki tem uma fun√ß√£o conveniente pki :: _ encode_pem para converter para o formato PEM: <br><br><pre> <code class="plaintext hljs">set bufpem [::pki::_encode_pem &lt;der-buffer&gt; &lt;Headline&gt; &lt;Lastline&gt;]</code> </pre> <br>  por exemplo: <br><br><pre> <code class="plaintext hljs">set certpem [::pki::encode_pen $cert_der "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]</code> </pre> <br>  Ao selecionar o r√≥tulo do certificado s√©ptico na caixa de combina√ß√£o, obtemos acesso ao corpo do certificado: <br><br><pre> <code class="plaintext hljs">#    set nick [.saveCert.labExp.listCert get] #        foreach certinfo_list $::certs_p11 { unset -nocomplain cert_parse array set cert_parse $certinfo_list if {$cert_parse(pkcs11_label) == $nick} { #   set cert_parse(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $cert_parse(cert)] break } } #   file|pkcs11 set ::tekcert "pkcs11"</code> </pre> <br>  Um outro mecanismo para analisar o certificado e exibi-lo foi discutido anteriormente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h3>  <font color="#0000ff">Valida√ß√£o de certificado</font> </h3><br>  Ao analisar o certificado, as vari√°veis ‚Äã‚Äã:: notbefore e :: notafter armazenam a data a partir da qual o certificado pode ser usado em opera√ß√µes criptogr√°ficas (assinar, criptografar etc.) e a data de validade do certificado.  O procedimento para verificar a validade de um certificado tem a forma: <br><br><pre> <code class="plaintext hljs">proc cert_valid_date {} { #       #    set startdate $::notbefore #    set enddate $::notafter #      set now [clock seconds] set isvalid 1 set reason "Certificate is valid" if {$startdate &gt; $now} { set isvalid 0 #      set reason "Certificate is not yet valid" } elseif {$now &gt; $enddate} { set isvalid 0 #    set reason "Certificate has expired" } return [list $isvalid $reason] }</code> </pre> <br>  A lista retornada cont√©m dois itens.  O primeiro elemento pode conter 0 (zero) ou 1 (um).  Um valor de "1" indica que o certificado √© v√°lido e 0 indica que o certificado n√£o √© v√°lido.  O motivo pelo qual o certificado n√£o √© v√°lido √© divulgado no segundo elemento.  Este elemento pode conter um dos tr√™s valores: <br><br><ul><li>  certificado v√°lido (o primeiro elemento da lista √© 1): </li><li>  certificado ainda n√£o √© v√°lido (o certificado ainda n√£o expirou) </li><li>  certificado expirou. </li></ul><br>  A validade do certificado √© determinada n√£o apenas pelo seu per√≠odo de validade.  O certificado pode ser suspenso ou rescindido pelo centro de certifica√ß√£o, por sua pr√≥pria iniciativa e a pedido do titular do certificado, por exemplo, em caso de perda da m√≠dia com a chave privada.  Nesse caso, o certificado √© inclu√≠do pela autoridade de certifica√ß√£o na lista de certificados COS / CRL revogados que s√£o distribu√≠dos pela CA.  Normalmente, o ponto de distribui√ß√£o da CRL est√° inclu√≠do no certificado.  √â da lista de certificados revogados que a validade do certificado √© verificada. <br><br><h3>  <font color="#0000ff">Valida√ß√£o da validade do certificado por SOS / CRL</font> </h3><br>  O primeiro passo √© obter o SOS, analis√°-lo e verificar o certificado. <br>  A lista de pontos de emiss√£o COC / CRL est√° na extens√£o de certificado com oid 2.5.29.31 (id-ce-cRLDistributionPoints): <br><br><pre> <code class="plaintext hljs">array set extcert $cert_parse(extensions) set ::crlfile "" if {[info exists extcert(2.5.29.31)]} { set ::crlfile [crlpoints [lindex $extcert(2.5.29.31) 1]] } else { puts "cannot load CRL" }</code> </pre> <br>  Na verdade, o carregamento do arquivo com SOS / CRL √© o seguinte: <br><br><pre> <code class="plaintext hljs">set filecrl "" set pointcrl "" foreach pointcrl $::crlfile { set filecrl [readca $pointcrl $dir] if {$filecrl != ""} { set f [file join $dir [file tail $pointcrl]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $filecrl close $fd set filecrl $f break } # CRL  .     CRL } if {$filecrl == ""} { puts "Cannot load CRL" }</code> </pre> <br>  Na verdade, o procedimento readca √© usado para carregar o COC / CRL: <br><br><pre> <code class="plaintext hljs">proc readca {url dir} { set cer "" #   if { "https://" == [string range $url 0 7]} { #    tls http::register https 443 ::tls::socket } #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer }</code> </pre><br>  A vari√°vel dir armazena o caminho para o diret√≥rio no qual a COS / CRL ser√° salva e a vari√°vel url cont√©m a lista recebida anteriormente de pontos de distribui√ß√£o da CRL. <br><br>  Ao receber o SOS / CRL, repentinamente tive que enfrentar o fato de que para alguns certificados essa lista tinha que ser recebida pelo protocolo https (tls) no modo an√¥nimo.  Honestamente, isso √© surpreendente: a lista da CRL √© um documento p√∫blico e sua integridade √© protegida por uma assinatura eletr√¥nica e, na minha opini√£o, tenho acesso a ele por https an√¥nimo.  Mas n√£o h√° nada a fazer, voc√™ precisa conectar o pacote tls - o pacote exige tls. <br><br>  Se n√£o foi poss√≠vel fazer o download do SOS / CRL, o certificado n√£o poder√° ser verificado se o ponto de acesso com o servi√ßo OCSP n√£o estiver especificado no certificado.  Mas isso ser√° discutido em um dos seguintes artigos. <br><br>  Portanto, existe um certificado para verifica√ß√£o, existe uma lista de SOS / CRL, resta verificar o certificado.  Infelizmente, n√£o h√° fun√ß√µes correspondentes no pacote pki.  Portanto, tive que escrever um procedimento para verificar a validade do certificado (sua n√£o revoga√ß√£o) na lista de certificados revogados <br><br><div class="spoiler">  <b class="spoiler_title">validaty_cert_from_crl:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">proc validaty_cert_from_crl {crl sernum issuer} { array set ret [list] if { [string range $crl 0 9 ] == "-----BEGIN" } { array set parsed_crl [::pki::_parse_pem $crl "-----BEGIN X509 CRL-----" "-----END X509 CRL-----"] set crl $parsed_crl(data) } ::asn::asnGetSequence crl crl_seq ::asn::asnGetSequence crl_seq crl_base ::asn::asnPeekByte crl_base peek_tag if {$peek_tag == 0x02} { #   .CRL ::asn::asnGetInteger crl_base ret(version) incr ret(version) } else { set ret(version) 1 } ::asn::asnGetSequence crl_base crl_full ::asn::asnGetObjectIdentifier crl_full ret(signtype) ::::asn::asnGetSequence crl_base crl_issue set ret(issue) [::pki::x509::_dn_to_string $crl_issue] #     /CRL if {$ret(issue) != $issuer } { #/CRL    set ret(error) "Bad Issuer" return [array get ret] } binary scan $crl_issue H* ret(issue_hex) #  ::asn::asnGetUTCTime crl_base ret(publishDate) #   ::asn::asnGetUTCTime crl_base ret(nextDate) #   ::asn::asnPeekByte crl_base peek_tag if {$peek_tag != 0x30} { #    return [array get ret] } ::asn::asnGetSequence crl_base lcert # binary scan $lcert H* ret(lcert) while {$lcert != ""} { ::asn::asnGetSequence lcert lcerti #    ::asn::asnGetBigInteger lcerti ret(sernumrev) set ret(sernumrev) [::math::bignum::tostr $ret(sernumrev)] #      CRL if {$ret(sernumrev) != $sernum} { continue } # .    ::asn::asnGetUTCTime lcerti ret(revokeDate) if {$lcerti != ""} { #   ::asn::asnGetSequence lcerti lcertir ::asn::asnGetSequence lcertir reasone ::asn::asnGetObjectIdentifier reasone ret(reasone) ::asn::asnGetOctetString reasone reasone2 ::asn::asnGetEnumeration reasone2 ret(reasoneData) } break; } return [array get ret] }</code> </pre></div></div><br>  Os par√¢metros para esta fun√ß√£o s√£o a lista de revoga√ß√£o de certificado (crl), o n√∫mero de s√©rie do certificado que est√° sendo verificado (sernum) e seu editor (emissor). <br><br>  A lista de revoga√ß√£o de certificado (crl) √© carregada da seguinte maneira: <br><br><pre> <code class="plaintext hljs">set f [open $filecrl r] chan configure $f -translation binary set crl [read $f] close $f</code> </pre> <br>  O n√∫mero de s√©rie do certificado verificado (sernum) e seu editor (emissor) s√£o obtidos do certificado analisado e armazenados nas vari√°veis ‚Äã‚Äã:: sncert e :: issuercert. <br><br>  Todos os procedimentos podem ser encontrados no c√≥digo fonte.  O c√≥digo fonte do utilit√°rio e suas distribui√ß√µes para Linux, OS X (macOS) e MS Windows podem ser encontrados aqui. <br><br><div class="spoiler">  <b class="spoiler_title">aqui</b> <div class="spoiler_text"><ul><li>  <a href="">c√≥digo fonte</a> </li><li>  <a href="">Linux32</a> </li><li>  <a href="">Linux64</a> </li><li>  <a href="">OS X</a> </li><li>  <a href="">WIN32</a> </li><li>  <a href="">WIN64</a> </li></ul><br></div></div><br>  O utilit√°rio tamb√©m mant√©m a capacidade de visualizar e verificar certificados armazenados em um arquivo: <br><br><img src="https://habrastorage.org/webt/ja/tv/nl/jatvnlolqcsggytw3nn8x51zpls.png"><br><br>  A prop√≥sito, os certificados visualizados dos arquivos tamb√©m podem ser exportados, bem como os armazenados no token.  Isso facilita a convers√£o de arquivos de certificado do formato DER para PEM e vice-versa. <br><br>  Agora, temos um visualizador √∫nico para certificados armazenados em arquivos e em tokens / smartcards PKCS # 11. <br><br>  Sim, eu perdi o ponto: para verificar a validade do certificado, clique no bot√£o ‚ÄúAdicionalmente‚Äù e selecione o item de menu ‚ÄúValida√ß√£o por CRL‚Äù ou pressione o bot√£o direito do mouse e quando o cursor estiver nas informa√ß√µes principais campo e tamb√©m selecione o item de menu ‚ÄúValidaty by CRL‚Äù: <br><br><img src="https://habrastorage.org/webt/ig/ph/rm/igphrmcbunw9b8jtkdiepfjaqpm.png"><br><br>  Esta captura de tela mostra a navega√ß√£o e a valida√ß√£o de certificados em um token na nuvem. <br><br>  Em conclus√£o, observamos o seguinte.  Em seus coment√°rios ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> , o usu√°rio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Pas</a> observou muito corretamente sobre os tokens do PKCS # 11 que "eles mesmos podem contar tudo".  Sim, os tokens s√£o realmente computadores criptogr√°ficos.  Nos artigos a seguir, falaremos n√£o apenas sobre como os certificados s√£o verificados usando o protocolo OCSP, mas tamb√©m sobre como usar mecanismos criptogr√°ficos (estamos falando, √© claro, da criptografia GOST) de tokens / smarts para calcular o hash (GOST R 34-10- 94/2012), a forma√ß√£o e verifica√ß√£o de assinaturas, etc. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443480/">https://habr.com/ru/post/pt443480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443468/index.html">Quais ferramentas de monitoramento de rede se tornaram l√≠deres na vers√£o do Gartner</a></li>
<li><a href="../pt443470/index.html">A hist√≥ria da digita√ß√£o no exemplo de um grande projeto</a></li>
<li><a href="../pt443472/index.html">Tem algum problema para ir para a nuvem? 7 dicas sobre como n√£o estragar</a></li>
<li><a href="../pt443476/index.html">Como o SimCity inspirou uma gera√ß√£o inteira de planejadores urbanos</a></li>
<li><a href="../pt443478/index.html">Dados de teste sint√©ticos x reais: pr√≥s, contras, armadilhas</a></li>
<li><a href="../pt443482/index.html">AIOps na pr√°tica - o que o Huawei FabricInsight pode</a></li>
<li><a href="../pt443484/index.html">6 homens inesperados de Julia</a></li>
<li><a href="../pt443486/index.html">ReLEx SMILE: Como n√£o cometer erros nas previs√µes</a></li>
<li><a href="../pt443488/index.html">Componentes funcionais com ganchos de rea√ß√£o. Por que eles s√£o melhores?</a></li>
<li><a href="../pt443490/index.html">Por que estou restringindo meu trabalho no Debian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>