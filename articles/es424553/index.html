<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌊 👜 🐺 Guía de Node.js, Parte 6: Bucle de eventos, Pila de llamadas, Temporizadores 🌅 👨🏽‍🚀 💅🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, en la sexta parte de la traducción del manual Node.js, hablaremos sobre el bucle de eventos, la pila de llamadas, la función process.nextTick() y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guía de Node.js, Parte 6: Bucle de eventos, Pila de llamadas, Temporizadores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424553/"> Hoy, en la sexta parte de la traducción del manual Node.js, hablaremos sobre el bucle de eventos, la pila de llamadas, la función <code>process.nextTick()</code> y los temporizadores.  Comprender estos y otros mecanismos de Node.js es una de las piedras angulares del desarrollo exitoso de aplicaciones para esta plataforma. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Le aconsejamos que lea] Otras partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Información general y primeros pasos</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript, V8, algunos trucos de desarrollo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hosting, REPL, trabajar con la consola, módulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos npm, package.json y package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">npm y npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bucle de eventos, pila de llamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programación asincrónica</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía de Node.js, Parte 8: Protocolos HTTP y WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía de Node.js, parte 9: trabajar con el sistema de archivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía de Node.js, Parte 10: Módulos estándar, flujos, bases de datos, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PDF completo de la guía Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Bucle de eventos</font> </h2><br>  Si desea comprender cómo se ejecuta el código JavaScript, el bucle de eventos es uno de los conceptos más importantes que debe comprender.  Aquí hablaremos sobre cómo funciona JavaScript en modo de subproceso único y cómo se manejan las funciones asincrónicas. <br><br>  He estado desarrollando JavaScript durante muchos años, pero no puedo decir que entendí completamente cómo funciona todo, por así decirlo, "bajo el capó".  El programador puede no ser consciente de las complejidades del dispositivo de los subsistemas internos del entorno en el que trabaja.  Pero generalmente es útil tener al menos una idea general de tales cosas. <br><br>  El código JavaScript que escribe se ejecuta en modo de subproceso único.  En cierto momento, solo se realiza una acción.  Esta limitación, de hecho, es muy útil.  Esto simplifica enormemente la forma en que funcionan los programas, eliminando la necesidad de que los programadores resuelvan problemas específicos de entornos de subprocesos múltiples. <br><br>  De hecho, un programador de JS solo debe prestar atención a las acciones exactas que realiza su código e intentar evitar situaciones que causen el bloqueo del hilo principal.  Por ejemplo, hacer llamadas de red en modo síncrono y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ciclos</a> interminables. <br><br>  Por lo general, los navegadores, en cada pestaña abierta, tienen su propio bucle de eventos.  Esto le permite ejecutar el código de cada página en un entorno aislado y evitar situaciones en las que una página determinada, en cuyo código hay un bucle infinito o se realizan cálculos pesados, puede "suspender" todo el navegador.  El navegador admite el trabajo de muchos bucles de eventos existentes simultáneamente, que se utilizan, por ejemplo, para procesar llamadas a varias API.  Además, se utiliza un bucle de eventos patentado para apoyar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los trabajadores web</a> . <br><br>  Lo más importante que un programador de JavaScript debe recordar constantemente es que su código usa su propio bucle de eventos, por lo que el código debe escribirse para que este bucle de eventos no esté bloqueado. <br><br><h2>  <font color="#3AC1EF">Evento Loop Lock</font> </h2><br>  Cualquier código de JavaScript que tarde demasiado tiempo en ejecutarse, es decir, el código que no tome el control del bucle de eventos durante demasiado tiempo, bloquea la ejecución de cualquier otro código de página.  Esto incluso lleva a bloquear el procesamiento de los eventos de la interfaz de usuario, lo que se refleja en el hecho de que el usuario no puede interactuar con los elementos de la página y trabajar normalmente con ellos, por ejemplo, el desplazamiento. <br><br>  Casi todos los mecanismos básicos de E / S de JavaScript son sin bloqueo.  Esto se aplica tanto al navegador como a Node.js.  Entre tales mecanismos, por ejemplo, podemos mencionar las herramientas para realizar solicitudes de red utilizadas en entornos de cliente y servidor, y herramientas para trabajar con archivos Node.js.  Existen métodos sincrónicos para realizar tales operaciones, pero se usan solo en casos especiales.  Es por eso que las devoluciones de llamada tradicionales y los mecanismos más nuevos, las promesas y la construcción asíncrona / espera, son de gran importancia en JavaScript. <br><br><h2>  <font color="#3AC1EF">Pila de llamadas</font> </h2><br>  La pila de llamadas de JavaScript se basa en el principio LIFO (última entrada, primera salida - última entrada, primera salida).  El bucle de eventos comprueba constantemente la pila de llamadas para ver si tiene una función que deba ejecutarse.  Si, al ejecutar el código, se llama a una función, se agrega información sobre el mismo a la pila de llamadas y se ejecuta esta función. <br><br>  Si incluso antes no estaba interesado en el concepto de una "pila de llamadas", entonces si ha encontrado mensajes de error que incluyen un seguimiento de la pila, ya se imagina cómo se ve.  Aquí, por ejemplo, se ve así en un navegador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">Mensaje de error del navegador</font></i> <br><br>  El navegador, cuando se produce un error, informa sobre la secuencia de llamadas a funciones, información sobre la cual se almacena en la pila de llamadas, lo que le permite encontrar la fuente del error y comprender qué llamadas a qué funciones condujeron a la situación. <br><br>  Ahora que hemos hablado sobre el bucle de eventos y la pila de llamadas en términos generales, considere un ejemplo que ilustra la ejecución de un fragmento de código y cómo se ve este proceso en términos del bucle de eventos y la pila de llamadas. <br><br><h2>  <font color="#3AC1EF">Bucle de eventos y pila de llamadas</font> </h2><br>  Aquí está el código con el que experimentaremos: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br>  Si se ejecuta este código, lo siguiente llegará a la consola: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br>  Tal resultado es bastante esperado.  Es decir, cuando se ejecuta este código, primero se llama a la función <code>foo()</code> .  Dentro de esta función, primero llamamos a la función <code>bar()</code> , y luego a la función <code>baz()</code> .  Al mismo tiempo, la pila de llamadas durante la ejecución de este código sufre los cambios que se muestran en la siguiente figura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">Cambiar el estado de la pila de llamadas al ejecutar el código bajo investigación</font></i> <br><br>  El bucle de eventos, en cada iteración, verifica si hay algo en la pila de llamadas y, de ser así, lo hace hasta que la pila de llamadas esté vacía. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Iteraciones de bucle de eventos</font></i> <br><br><h2>  <font color="#3AC1EF">Poner en cola una función</font> </h2><br>  El ejemplo anterior parece bastante ordinario, no tiene nada de especial: JavaScript encuentra el código que debe ejecutarse y lo ejecuta en orden.  Hablaremos sobre cómo diferir la ejecución de la función hasta que se borre la pila de llamadas.  Para hacer esto, se utiliza la siguiente construcción: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Le permite ejecutar la función pasada a la función <code>setTimeout()</code> después de ejecutar todas las demás funciones llamadas en el código del programa. <br><br>  Considere un ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br>  Lo que imprime este código puede parecer inesperado: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br>  Cuando ejecutamos este ejemplo, la función <code>foo()</code> se llama primero.  En él, llamamos a <code>setTimeout()</code> , pasando esta función, como primer argumento, <code>bar</code> .  Al pasarlo como segundo argumento, informamos al sistema que esta función debe realizarse lo antes posible.  Luego llamamos a la función <code>baz()</code> . <br><br>  Así es como se verá la pila de llamadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">Cambiar el estado de la pila de llamadas al ejecutar el código</font></i> <br><br>  Aquí está el orden en que se ejecutarán las funciones en nuestro programa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Iteraciones de bucle de eventos</font></i> <br><br>  ¿Por qué sucede esto de esta manera? <br><br><h2>  <font color="#3AC1EF">Cola de eventos</font> </h2><br>  Cuando se llama a la función <code>setTimeout()</code> , el navegador o la plataforma Node.js inicia un temporizador.  Después de que el temporizador funciona (en nuestro caso, esto sucede inmediatamente, ya que lo configuramos en 0), la función de devolución de llamada pasada a <code>setTimeout()</code> a la Cola de eventos. <br><br>  La cola de eventos, cuando se trata del navegador, incluye eventos iniciados por el usuario: eventos causados ​​por clics del mouse en elementos de la página, eventos que se activan cuando se ingresan datos desde el teclado.  Los controladores de <code>onload</code> DOM como <code>onload</code> , funciones llamadas cuando se reciben respuestas a solicitudes asíncronas para cargar datos, están inmediatamente allí.  Aquí están esperando su turno para procesar. <br><br>  El bucle de eventos da prioridad a lo que hay en la pila de llamadas.  Primero, hace todo lo que logra encontrar en la pila, y después de que la pila está vacía, procesa lo que está en la cola de eventos. <br><br>  No necesitamos esperar hasta que una función como <code>setTimeout()</code> termine de funcionar, ya que el navegador proporciona funciones similares y utilizan sus propias transmisiones.  Entonces, por ejemplo, al configurar el temporizador durante 2 segundos usando la función <code>setTimeout()</code> , no debe, después de haber detenido la ejecución de otro código, esperar estos 2 segundos, ya que el temporizador funciona fuera de su código. <br><br><h2>  <font color="#3AC1EF">ES6 Job Queue</font> </h2><br>  ECMAScript 2015 (ES6) introdujo el concepto de Job Queue, que es utilizado por promesas (también aparecieron en ES6).  Gracias a la cola de trabajos, el resultado de ejecutar la función asincrónica se puede utilizar lo más rápido posible, sin la necesidad de esperar a que se elimine la pila de llamadas. <br><br>  Si se resuelve una promesa antes del final de la función actual, el código correspondiente se ejecutará inmediatamente después de que se complete la función actual. <br><br>  Encontré una analogía interesante de lo que estamos hablando.  Esto se puede comparar con una montaña rusa en un parque de diversiones.  Después de montar la colina y volver a hacerlo, coges un boleto y te pones en la cola.  Así es como funciona la cola de eventos.  Pero la cola de trabajo se ve diferente.  Este concepto es similar a un boleto de descuento, que le otorga el derecho de hacer el próximo viaje inmediatamente después de haber terminado el anterior. <br><br>  Considere el siguiente ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br>  Esto es lo que se generará después de su ejecución: <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br>  Lo que puede ver aquí demuestra una gran diferencia entre las promesas (y la construcción asíncrona / en espera, que se basa en ellas) y las funciones asincrónicas tradicionales, cuya ejecución se organiza utilizando <code>setTimeout()</code> u otras API de la plataforma utilizada. <br><br><h2>  <font color="#3AC1EF">process.nextTick ()</font> </h2><br>  El método <code>process.nextTick()</code> interactúa con el bucle de eventos de una manera especial.  Una marca es un solo ciclo completo de eventos.  Al pasar la función al método <code>process.nextTick()</code> , informamos al sistema que esta función debe llamarse después de que se complete la iteración actual del bucle de eventos, antes de que comience la siguiente.  El uso de este método se ve así: <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br>  Supongamos que un bucle de eventos está ocupado ejecutando código para la función actual.  Cuando se complete esta operación, el motor de JavaScript ejecutará todas las funciones pasadas a <code>process.nextTick()</code> durante la operación anterior.  Con este mecanismo, nos esforzamos por garantizar que una determinada función se ejecute de forma asincrónica (después de la función actual), pero lo antes posible, sin colocarla en la cola. <br><br>  Por ejemplo, si usa la <code>setTimeout(() =&gt; {}, 0)</code> , la función se ejecutará en la próxima iteración del bucle de eventos, es decir, mucho más tarde que cuando se usa <code>process.nextTick()</code> en la misma situación.  Este método debe usarse cuando sea necesario para garantizar la ejecución de algún código al comienzo de la próxima iteración del bucle de eventos. <br><br><h2>  <font color="#3AC1EF">setImmediate ()</font> </h2><br>  Otra función proporcionada por Node.js para la ejecución de código asíncrono es <code>setImmediate()</code> .  Aquí se explica cómo usarlo: <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  La función de devolución de llamada pasada a <code>setImmediate()</code> se ejecutará en la próxima iteración del bucle de eventos. <br><br>  ¿En qué se diferencia <code>setImmediate()</code> de <code>setTimeout(() =&gt; {}, 0)</code> (es decir, de un temporizador que debería funcionar lo antes posible) y de <code>process.nextTick()</code> ? <br><br>  La función pasada a <code>process.nextTick()</code> se ejecutará después de que se haya completado la iteración actual del bucle de eventos.  Es decir, dicha función siempre se ejecutará antes de la función cuya ejecución se programa utilizando <code>setTimeout()</code> o <code>setImmediate()</code> . <br><br>  Llamar a la función <code>setTimeout()</code> con un retraso establecido de 0 ms es muy similar a llamar a <code>setImmediate()</code> .  El orden de ejecución de las funciones que se les transfieren depende de varios factores, pero en ambos casos las devoluciones de llamada se llamarán en la próxima iteración del bucle de eventos. <br><br><h2>  <font color="#3AC1EF">Temporizadores</font> </h2><br>  Ya hemos hablado sobre la función <code>setTimeout()</code> , que le permite programar llamadas a las devoluciones de llamada que se le pasaron.  Tomemos un tiempo para describir con más detalle sus características y considerar otra función, <code>setInterval()</code> , similar a ella.  En Node.js, las funciones para trabajar con temporizadores están incluidas en el módulo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">temporizador</a> , pero puede usarlas sin conectar este módulo en el código, ya que son globales. <br><br><h3>  <font color="#3AC1EF">▍ función setTimeout ()</font> </h3><br>  Recuerde que cuando llama a la función <code>setTimeout()</code> , recibe una devolución de llamada y el tiempo, en milisegundos, después del cual se llamará la devolución de llamada.  Considere un ejemplo: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Aquí pasamos <code>setTimeout()</code> nueva función que se describe inmediatamente, pero aquí podemos usar la función existente pasando <code>setTimeout()</code> su nombre y un conjunto de parámetros para ejecutarla.  Se ve así: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  La función <code>setTimeout()</code> devuelve un identificador de temporizador.  Por lo general, no se usa, pero puede guardarlo y, si es necesario, eliminar el temporizador si ya no se necesita la devolución de llamada programada: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Cero retraso</font> </h3><br>  En las secciones anteriores, usamos <code>setTimeout()</code> , pasándolo, como el tiempo después del cual es necesario llamar a la devolución de llamada, <code>0</code> .  Esto significaba que la devolución de llamada se llamaría lo antes posible, pero después de completar la función actual: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br>  Dicho código generará lo siguiente: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br>  Esta técnica es especialmente útil en situaciones en las que, al realizar tareas computacionales pesadas, no quisiera bloquear el hilo principal, permitiendo que se ejecuten otras funciones, dividiendo estas tareas en varias etapas, ejecutadas como llamadas <code>setTimeout()</code> . <br><br>  Si recordamos la función <code>setImmediate()</code> , entonces es estándar en Node.js, lo que no se puede decir sobre los navegadores (se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementa</a> en IE y Edge, pero no en otros). <br><br><h3>  <font color="#3AC1EF">▍ función setInterval ()</font> </h3><br>  La función <code>setInterval()</code> es similar a <code>setTimeout()</code> , pero hay diferencias entre ellas.  En lugar de ejecutar la devolución de llamada que se le pasó una vez, <code>setInterval()</code> periódicamente, con el intervalo especificado, llamará a esta devolución de llamada.  Esto continuará, idealmente, hasta el momento en que el programador detenga explícitamente este proceso.  Aquí se explica cómo usar esta función: <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  Una devolución de llamada pasada a la función que se muestra arriba se llamará cada 2 segundos.  Para proporcionar la posibilidad de detener este proceso, debe obtener el identificador del temporizador devuelto por <code>setInterval()</code> y usar el <code>clearInterval()</code> : <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br>  Una técnica común es llamar a <code>clearInterval()</code> dentro de la devolución de llamada pasada a <code>setInterval()</code> cuando se cumple una determinada condición.  Por ejemplo, el siguiente código se ejecutará periódicamente hasta que la propiedad <code>App.somethingIWait</code> esté <code>App.somethingIWait</code> para <code>arrived</code> : <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Configuración recursiva setTimeout ()</font> </h3><br>  La función <code>setInterval()</code> llamará a la devolución de llamada que se le pasa cada <code>n</code> milisegundos, sin preocuparse de si esta devolución de llamada se ha completado después de su llamada anterior. <br><br>  Si cada llamada a esta devolución de llamada siempre requiere el mismo tiempo menor que <code>n</code> , entonces no surgen problemas aquí. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">Llamada periódica de devolución de llamada, cada sesión de ejecución de las cuales lleva el mismo tiempo, dentro del intervalo entre llamadas</font></i> <br><br>  Quizás se necesita un tiempo diferente para completar una devolución de llamada, que aún es menor que <code>n</code> .  Si, por ejemplo, estamos hablando de realizar ciertas operaciones de red, entonces esta situación es bastante esperada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">Llamada periódica de devolución de llamada, cada sesión de ejecución de las cuales toma un tiempo diferente, cayendo entre las llamadas</font></i> <br><br>  Cuando se usa <code>setInterval()</code> , puede surgir una situación cuando la devolución de llamada toma más de <code>n</code> , lo que lleva a que se complete la siguiente llamada antes de que se complete la anterior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">Llamada periódica llamada, cada sesión toma un tiempo diferente, que a veces no cabe en el intervalo entre llamadas</font></i> <br><br>  Para evitar esta situación, puede usar la técnica de configuración del temporizador recursivo usando <code>setTimeout()</code> .  El punto es que la próxima llamada de devolución de llamada se planifica después de la finalización de su llamada anterior: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br>  Con este enfoque, se puede implementar el siguiente escenario: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">Una llamada recursiva a setTimeout () para programar la ejecución de devolución de llamada</font></i> <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos sobre los mecanismos internos de Node.js, como el bucle de eventos, la pila de llamadas y discutimos el trabajo con temporizadores que le permiten programar la ejecución del código.  La próxima vez profundizaremos en el tema de la programación asincrónica. <br><br>  <b>Estimados lectores!</b>  ¿Ha encontrado situaciones en las que tuvo que usar process.nextTick ()? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424553/">https://habr.com/ru/post/es424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424537/index.html">Sberbank lanzó su propio operador SberMobile</a></li>
<li><a href="../es424539/index.html">Java 11: nuevo en String</a></li>
<li><a href="../es424541/index.html">Historia del fiasco de UGJ 2018: cómo hacer un juego que a nadie le guste (¡no lo hagas!)</a></li>
<li><a href="../es424543/index.html">Java 11 / JDK 11: Disponibilidad general</a></li>
<li><a href="../es424551/index.html">Warm and tube: cinco balalaikas sobre tecnología de audio magnético</a></li>
<li><a href="../es424555/index.html">Manual de Node.js, Parte 7: Programación asincrónica</a></li>
<li><a href="../es424557/index.html">Guía de Node.js, Parte 8: Protocolos HTTP y WebSocket</a></li>
<li><a href="../es424559/index.html">Big Data resistencia 1 o el esquivo Joe. Anonimato de Internet, anti-detección, anti-seguimiento para anti-usted y anti-nosotros.</a></li>
<li><a href="../es424563/index.html">Beeline envía detalles de conversaciones a extraños</a></li>
<li><a href="../es424565/index.html">Descripción general: escaneo 3D de locales inmobiliarios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>