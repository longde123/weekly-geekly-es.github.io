<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåä üëú üê∫ Gu√≠a de Node.js, Parte 6: Bucle de eventos, Pila de llamadas, Temporizadores üåÖ üë®üèΩ‚ÄçüöÄ üíÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, en la sexta parte de la traducci√≥n del manual Node.js, hablaremos sobre el bucle de eventos, la pila de llamadas, la funci√≥n process.nextTick() y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de Node.js, Parte 6: Bucle de eventos, Pila de llamadas, Temporizadores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424553/"> Hoy, en la sexta parte de la traducci√≥n del manual Node.js, hablaremos sobre el bucle de eventos, la pila de llamadas, la funci√≥n <code>process.nextTick()</code> y los temporizadores.  Comprender estos y otros mecanismos de Node.js es una de las piedras angulares del desarrollo exitoso de aplicaciones para esta plataforma. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Le aconsejamos que lea] Otras partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n general y primeros pasos</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript, V8, algunos trucos de desarrollo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hosting, REPL, trabajar con la consola, m√≥dulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos npm, package.json y package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">npm y npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bucle de eventos, pila de llamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programaci√≥n asincr√≥nica</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, Parte 8: Protocolos HTTP y WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, parte 9: trabajar con el sistema de archivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, Parte 10: M√≥dulos est√°ndar, flujos, bases de datos, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PDF completo de la gu√≠a Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Bucle de eventos</font> </h2><br>  Si desea comprender c√≥mo se ejecuta el c√≥digo JavaScript, el bucle de eventos es uno de los conceptos m√°s importantes que debe comprender.  Aqu√≠ hablaremos sobre c√≥mo funciona JavaScript en modo de subproceso √∫nico y c√≥mo se manejan las funciones asincr√≥nicas. <br><br>  He estado desarrollando JavaScript durante muchos a√±os, pero no puedo decir que entend√≠ completamente c√≥mo funciona todo, por as√≠ decirlo, "bajo el cap√≥".  El programador puede no ser consciente de las complejidades del dispositivo de los subsistemas internos del entorno en el que trabaja.  Pero generalmente es √∫til tener al menos una idea general de tales cosas. <br><br>  El c√≥digo JavaScript que escribe se ejecuta en modo de subproceso √∫nico.  En cierto momento, solo se realiza una acci√≥n.  Esta limitaci√≥n, de hecho, es muy √∫til.  Esto simplifica enormemente la forma en que funcionan los programas, eliminando la necesidad de que los programadores resuelvan problemas espec√≠ficos de entornos de subprocesos m√∫ltiples. <br><br>  De hecho, un programador de JS solo debe prestar atenci√≥n a las acciones exactas que realiza su c√≥digo e intentar evitar situaciones que causen el bloqueo del hilo principal.  Por ejemplo, hacer llamadas de red en modo s√≠ncrono y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ciclos</a> interminables. <br><br>  Por lo general, los navegadores, en cada pesta√±a abierta, tienen su propio bucle de eventos.  Esto le permite ejecutar el c√≥digo de cada p√°gina en un entorno aislado y evitar situaciones en las que una p√°gina determinada, en cuyo c√≥digo hay un bucle infinito o se realizan c√°lculos pesados, puede "suspender" todo el navegador.  El navegador admite el trabajo de muchos bucles de eventos existentes simult√°neamente, que se utilizan, por ejemplo, para procesar llamadas a varias API.  Adem√°s, se utiliza un bucle de eventos patentado para apoyar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los trabajadores web</a> . <br><br>  Lo m√°s importante que un programador de JavaScript debe recordar constantemente es que su c√≥digo usa su propio bucle de eventos, por lo que el c√≥digo debe escribirse para que este bucle de eventos no est√© bloqueado. <br><br><h2>  <font color="#3AC1EF">Evento Loop Lock</font> </h2><br>  Cualquier c√≥digo de JavaScript que tarde demasiado tiempo en ejecutarse, es decir, el c√≥digo que no tome el control del bucle de eventos durante demasiado tiempo, bloquea la ejecuci√≥n de cualquier otro c√≥digo de p√°gina.  Esto incluso lleva a bloquear el procesamiento de los eventos de la interfaz de usuario, lo que se refleja en el hecho de que el usuario no puede interactuar con los elementos de la p√°gina y trabajar normalmente con ellos, por ejemplo, el desplazamiento. <br><br>  Casi todos los mecanismos b√°sicos de E / S de JavaScript son sin bloqueo.  Esto se aplica tanto al navegador como a Node.js.  Entre tales mecanismos, por ejemplo, podemos mencionar las herramientas para realizar solicitudes de red utilizadas en entornos de cliente y servidor, y herramientas para trabajar con archivos Node.js.  Existen m√©todos sincr√≥nicos para realizar tales operaciones, pero se usan solo en casos especiales.  Es por eso que las devoluciones de llamada tradicionales y los mecanismos m√°s nuevos, las promesas y la construcci√≥n as√≠ncrona / espera, son de gran importancia en JavaScript. <br><br><h2>  <font color="#3AC1EF">Pila de llamadas</font> </h2><br>  La pila de llamadas de JavaScript se basa en el principio LIFO (√∫ltima entrada, primera salida - √∫ltima entrada, primera salida).  El bucle de eventos comprueba constantemente la pila de llamadas para ver si tiene una funci√≥n que deba ejecutarse.  Si, al ejecutar el c√≥digo, se llama a una funci√≥n, se agrega informaci√≥n sobre el mismo a la pila de llamadas y se ejecuta esta funci√≥n. <br><br>  Si incluso antes no estaba interesado en el concepto de una "pila de llamadas", entonces si ha encontrado mensajes de error que incluyen un seguimiento de la pila, ya se imagina c√≥mo se ve.  Aqu√≠, por ejemplo, se ve as√≠ en un navegador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">Mensaje de error del navegador</font></i> <br><br>  El navegador, cuando se produce un error, informa sobre la secuencia de llamadas a funciones, informaci√≥n sobre la cual se almacena en la pila de llamadas, lo que le permite encontrar la fuente del error y comprender qu√© llamadas a qu√© funciones condujeron a la situaci√≥n. <br><br>  Ahora que hemos hablado sobre el bucle de eventos y la pila de llamadas en t√©rminos generales, considere un ejemplo que ilustra la ejecuci√≥n de un fragmento de c√≥digo y c√≥mo se ve este proceso en t√©rminos del bucle de eventos y la pila de llamadas. <br><br><h2>  <font color="#3AC1EF">Bucle de eventos y pila de llamadas</font> </h2><br>  Aqu√≠ est√° el c√≥digo con el que experimentaremos: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br>  Si se ejecuta este c√≥digo, lo siguiente llegar√° a la consola: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br>  Tal resultado es bastante esperado.  Es decir, cuando se ejecuta este c√≥digo, primero se llama a la funci√≥n <code>foo()</code> .  Dentro de esta funci√≥n, primero llamamos a la funci√≥n <code>bar()</code> , y luego a la funci√≥n <code>baz()</code> .  Al mismo tiempo, la pila de llamadas durante la ejecuci√≥n de este c√≥digo sufre los cambios que se muestran en la siguiente figura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">Cambiar el estado de la pila de llamadas al ejecutar el c√≥digo bajo investigaci√≥n</font></i> <br><br>  El bucle de eventos, en cada iteraci√≥n, verifica si hay algo en la pila de llamadas y, de ser as√≠, lo hace hasta que la pila de llamadas est√© vac√≠a. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Iteraciones de bucle de eventos</font></i> <br><br><h2>  <font color="#3AC1EF">Poner en cola una funci√≥n</font> </h2><br>  El ejemplo anterior parece bastante ordinario, no tiene nada de especial: JavaScript encuentra el c√≥digo que debe ejecutarse y lo ejecuta en orden.  Hablaremos sobre c√≥mo diferir la ejecuci√≥n de la funci√≥n hasta que se borre la pila de llamadas.  Para hacer esto, se utiliza la siguiente construcci√≥n: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Le permite ejecutar la funci√≥n pasada a la funci√≥n <code>setTimeout()</code> despu√©s de ejecutar todas las dem√°s funciones llamadas en el c√≥digo del programa. <br><br>  Considere un ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br>  Lo que imprime este c√≥digo puede parecer inesperado: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br>  Cuando ejecutamos este ejemplo, la funci√≥n <code>foo()</code> se llama primero.  En √©l, llamamos a <code>setTimeout()</code> , pasando esta funci√≥n, como primer argumento, <code>bar</code> .  Al pasarlo como segundo argumento, informamos al sistema que esta funci√≥n debe realizarse lo antes posible.  Luego llamamos a la funci√≥n <code>baz()</code> . <br><br>  As√≠ es como se ver√° la pila de llamadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">Cambiar el estado de la pila de llamadas al ejecutar el c√≥digo</font></i> <br><br>  Aqu√≠ est√° el orden en que se ejecutar√°n las funciones en nuestro programa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Iteraciones de bucle de eventos</font></i> <br><br>  ¬øPor qu√© sucede esto de esta manera? <br><br><h2>  <font color="#3AC1EF">Cola de eventos</font> </h2><br>  Cuando se llama a la funci√≥n <code>setTimeout()</code> , el navegador o la plataforma Node.js inicia un temporizador.  Despu√©s de que el temporizador funciona (en nuestro caso, esto sucede inmediatamente, ya que lo configuramos en 0), la funci√≥n de devoluci√≥n de llamada pasada a <code>setTimeout()</code> a la Cola de eventos. <br><br>  La cola de eventos, cuando se trata del navegador, incluye eventos iniciados por el usuario: eventos causados ‚Äã‚Äãpor clics del mouse en elementos de la p√°gina, eventos que se activan cuando se ingresan datos desde el teclado.  Los controladores de <code>onload</code> DOM como <code>onload</code> , funciones llamadas cuando se reciben respuestas a solicitudes as√≠ncronas para cargar datos, est√°n inmediatamente all√≠.  Aqu√≠ est√°n esperando su turno para procesar. <br><br>  El bucle de eventos da prioridad a lo que hay en la pila de llamadas.  Primero, hace todo lo que logra encontrar en la pila, y despu√©s de que la pila est√° vac√≠a, procesa lo que est√° en la cola de eventos. <br><br>  No necesitamos esperar hasta que una funci√≥n como <code>setTimeout()</code> termine de funcionar, ya que el navegador proporciona funciones similares y utilizan sus propias transmisiones.  Entonces, por ejemplo, al configurar el temporizador durante 2 segundos usando la funci√≥n <code>setTimeout()</code> , no debe, despu√©s de haber detenido la ejecuci√≥n de otro c√≥digo, esperar estos 2 segundos, ya que el temporizador funciona fuera de su c√≥digo. <br><br><h2>  <font color="#3AC1EF">ES6 Job Queue</font> </h2><br>  ECMAScript 2015 (ES6) introdujo el concepto de Job Queue, que es utilizado por promesas (tambi√©n aparecieron en ES6).  Gracias a la cola de trabajos, el resultado de ejecutar la funci√≥n asincr√≥nica se puede utilizar lo m√°s r√°pido posible, sin la necesidad de esperar a que se elimine la pila de llamadas. <br><br>  Si se resuelve una promesa antes del final de la funci√≥n actual, el c√≥digo correspondiente se ejecutar√° inmediatamente despu√©s de que se complete la funci√≥n actual. <br><br>  Encontr√© una analog√≠a interesante de lo que estamos hablando.  Esto se puede comparar con una monta√±a rusa en un parque de diversiones.  Despu√©s de montar la colina y volver a hacerlo, coges un boleto y te pones en la cola.  As√≠ es como funciona la cola de eventos.  Pero la cola de trabajo se ve diferente.  Este concepto es similar a un boleto de descuento, que le otorga el derecho de hacer el pr√≥ximo viaje inmediatamente despu√©s de haber terminado el anterior. <br><br>  Considere el siguiente ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br>  Esto es lo que se generar√° despu√©s de su ejecuci√≥n: <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br>  Lo que puede ver aqu√≠ demuestra una gran diferencia entre las promesas (y la construcci√≥n as√≠ncrona / en espera, que se basa en ellas) y las funciones asincr√≥nicas tradicionales, cuya ejecuci√≥n se organiza utilizando <code>setTimeout()</code> u otras API de la plataforma utilizada. <br><br><h2>  <font color="#3AC1EF">process.nextTick ()</font> </h2><br>  El m√©todo <code>process.nextTick()</code> interact√∫a con el bucle de eventos de una manera especial.  Una marca es un solo ciclo completo de eventos.  Al pasar la funci√≥n al m√©todo <code>process.nextTick()</code> , informamos al sistema que esta funci√≥n debe llamarse despu√©s de que se complete la iteraci√≥n actual del bucle de eventos, antes de que comience la siguiente.  El uso de este m√©todo se ve as√≠: <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br>  Supongamos que un bucle de eventos est√° ocupado ejecutando c√≥digo para la funci√≥n actual.  Cuando se complete esta operaci√≥n, el motor de JavaScript ejecutar√° todas las funciones pasadas a <code>process.nextTick()</code> durante la operaci√≥n anterior.  Con este mecanismo, nos esforzamos por garantizar que una determinada funci√≥n se ejecute de forma asincr√≥nica (despu√©s de la funci√≥n actual), pero lo antes posible, sin colocarla en la cola. <br><br>  Por ejemplo, si usa la <code>setTimeout(() =&gt; {}, 0)</code> , la funci√≥n se ejecutar√° en la pr√≥xima iteraci√≥n del bucle de eventos, es decir, mucho m√°s tarde que cuando se usa <code>process.nextTick()</code> en la misma situaci√≥n.  Este m√©todo debe usarse cuando sea necesario para garantizar la ejecuci√≥n de alg√∫n c√≥digo al comienzo de la pr√≥xima iteraci√≥n del bucle de eventos. <br><br><h2>  <font color="#3AC1EF">setImmediate ()</font> </h2><br>  Otra funci√≥n proporcionada por Node.js para la ejecuci√≥n de c√≥digo as√≠ncrono es <code>setImmediate()</code> .  Aqu√≠ se explica c√≥mo usarlo: <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  La funci√≥n de devoluci√≥n de llamada pasada a <code>setImmediate()</code> se ejecutar√° en la pr√≥xima iteraci√≥n del bucle de eventos. <br><br>  ¬øEn qu√© se diferencia <code>setImmediate()</code> de <code>setTimeout(() =&gt; {}, 0)</code> (es decir, de un temporizador que deber√≠a funcionar lo antes posible) y de <code>process.nextTick()</code> ? <br><br>  La funci√≥n pasada a <code>process.nextTick()</code> se ejecutar√° despu√©s de que se haya completado la iteraci√≥n actual del bucle de eventos.  Es decir, dicha funci√≥n siempre se ejecutar√° antes de la funci√≥n cuya ejecuci√≥n se programa utilizando <code>setTimeout()</code> o <code>setImmediate()</code> . <br><br>  Llamar a la funci√≥n <code>setTimeout()</code> con un retraso establecido de 0 ms es muy similar a llamar a <code>setImmediate()</code> .  El orden de ejecuci√≥n de las funciones que se les transfieren depende de varios factores, pero en ambos casos las devoluciones de llamada se llamar√°n en la pr√≥xima iteraci√≥n del bucle de eventos. <br><br><h2>  <font color="#3AC1EF">Temporizadores</font> </h2><br>  Ya hemos hablado sobre la funci√≥n <code>setTimeout()</code> , que le permite programar llamadas a las devoluciones de llamada que se le pasaron.  Tomemos un tiempo para describir con m√°s detalle sus caracter√≠sticas y considerar otra funci√≥n, <code>setInterval()</code> , similar a ella.  En Node.js, las funciones para trabajar con temporizadores est√°n incluidas en el m√≥dulo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">temporizador</a> , pero puede usarlas sin conectar este m√≥dulo en el c√≥digo, ya que son globales. <br><br><h3>  <font color="#3AC1EF">‚ñç funci√≥n setTimeout ()</font> </h3><br>  Recuerde que cuando llama a la funci√≥n <code>setTimeout()</code> , recibe una devoluci√≥n de llamada y el tiempo, en milisegundos, despu√©s del cual se llamar√° la devoluci√≥n de llamada.  Considere un ejemplo: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Aqu√≠ pasamos <code>setTimeout()</code> nueva funci√≥n que se describe inmediatamente, pero aqu√≠ podemos usar la funci√≥n existente pasando <code>setTimeout()</code> su nombre y un conjunto de par√°metros para ejecutarla.  Se ve as√≠: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  La funci√≥n <code>setTimeout()</code> devuelve un identificador de temporizador.  Por lo general, no se usa, pero puede guardarlo y, si es necesario, eliminar el temporizador si ya no se necesita la devoluci√≥n de llamada programada: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Cero retraso</font> </h3><br>  En las secciones anteriores, usamos <code>setTimeout()</code> , pas√°ndolo, como el tiempo despu√©s del cual es necesario llamar a la devoluci√≥n de llamada, <code>0</code> .  Esto significaba que la devoluci√≥n de llamada se llamar√≠a lo antes posible, pero despu√©s de completar la funci√≥n actual: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br>  Dicho c√≥digo generar√° lo siguiente: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br>  Esta t√©cnica es especialmente √∫til en situaciones en las que, al realizar tareas computacionales pesadas, no quisiera bloquear el hilo principal, permitiendo que se ejecuten otras funciones, dividiendo estas tareas en varias etapas, ejecutadas como llamadas <code>setTimeout()</code> . <br><br>  Si recordamos la funci√≥n <code>setImmediate()</code> , entonces es est√°ndar en Node.js, lo que no se puede decir sobre los navegadores (se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementa</a> en IE y Edge, pero no en otros). <br><br><h3>  <font color="#3AC1EF">‚ñç funci√≥n setInterval ()</font> </h3><br>  La funci√≥n <code>setInterval()</code> es similar a <code>setTimeout()</code> , pero hay diferencias entre ellas.  En lugar de ejecutar la devoluci√≥n de llamada que se le pas√≥ una vez, <code>setInterval()</code> peri√≥dicamente, con el intervalo especificado, llamar√° a esta devoluci√≥n de llamada.  Esto continuar√°, idealmente, hasta el momento en que el programador detenga expl√≠citamente este proceso.  Aqu√≠ se explica c√≥mo usar esta funci√≥n: <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  Una devoluci√≥n de llamada pasada a la funci√≥n que se muestra arriba se llamar√° cada 2 segundos.  Para proporcionar la posibilidad de detener este proceso, debe obtener el identificador del temporizador devuelto por <code>setInterval()</code> y usar el <code>clearInterval()</code> : <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br>  Una t√©cnica com√∫n es llamar a <code>clearInterval()</code> dentro de la devoluci√≥n de llamada pasada a <code>setInterval()</code> cuando se cumple una determinada condici√≥n.  Por ejemplo, el siguiente c√≥digo se ejecutar√° peri√≥dicamente hasta que la propiedad <code>App.somethingIWait</code> est√© <code>App.somethingIWait</code> para <code>arrived</code> : <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Configuraci√≥n recursiva setTimeout ()</font> </h3><br>  La funci√≥n <code>setInterval()</code> llamar√° a la devoluci√≥n de llamada que se le pasa cada <code>n</code> milisegundos, sin preocuparse de si esta devoluci√≥n de llamada se ha completado despu√©s de su llamada anterior. <br><br>  Si cada llamada a esta devoluci√≥n de llamada siempre requiere el mismo tiempo menor que <code>n</code> , entonces no surgen problemas aqu√≠. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">Llamada peri√≥dica de devoluci√≥n de llamada, cada sesi√≥n de ejecuci√≥n de las cuales lleva el mismo tiempo, dentro del intervalo entre llamadas</font></i> <br><br>  Quiz√°s se necesita un tiempo diferente para completar una devoluci√≥n de llamada, que a√∫n es menor que <code>n</code> .  Si, por ejemplo, estamos hablando de realizar ciertas operaciones de red, entonces esta situaci√≥n es bastante esperada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">Llamada peri√≥dica de devoluci√≥n de llamada, cada sesi√≥n de ejecuci√≥n de las cuales toma un tiempo diferente, cayendo entre las llamadas</font></i> <br><br>  Cuando se usa <code>setInterval()</code> , puede surgir una situaci√≥n cuando la devoluci√≥n de llamada toma m√°s de <code>n</code> , lo que lleva a que se complete la siguiente llamada antes de que se complete la anterior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">Llamada peri√≥dica llamada, cada sesi√≥n toma un tiempo diferente, que a veces no cabe en el intervalo entre llamadas</font></i> <br><br>  Para evitar esta situaci√≥n, puede usar la t√©cnica de configuraci√≥n del temporizador recursivo usando <code>setTimeout()</code> .  El punto es que la pr√≥xima llamada de devoluci√≥n de llamada se planifica despu√©s de la finalizaci√≥n de su llamada anterior: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br>  Con este enfoque, se puede implementar el siguiente escenario: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">Una llamada recursiva a setTimeout () para programar la ejecuci√≥n de devoluci√≥n de llamada</font></i> <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos sobre los mecanismos internos de Node.js, como el bucle de eventos, la pila de llamadas y discutimos el trabajo con temporizadores que le permiten programar la ejecuci√≥n del c√≥digo.  La pr√≥xima vez profundizaremos en el tema de la programaci√≥n asincr√≥nica. <br><br>  <b>Estimados lectores!</b>  ¬øHa encontrado situaciones en las que tuvo que usar process.nextTick ()? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424553/">https://habr.com/ru/post/es424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424537/index.html">Sberbank lanz√≥ su propio operador SberMobile</a></li>
<li><a href="../es424539/index.html">Java 11: nuevo en String</a></li>
<li><a href="../es424541/index.html">Historia del fiasco de UGJ 2018: c√≥mo hacer un juego que a nadie le guste (¬°no lo hagas!)</a></li>
<li><a href="../es424543/index.html">Java 11 / JDK 11: Disponibilidad general</a></li>
<li><a href="../es424551/index.html">Warm and tube: cinco balalaikas sobre tecnolog√≠a de audio magn√©tico</a></li>
<li><a href="../es424555/index.html">Manual de Node.js, Parte 7: Programaci√≥n asincr√≥nica</a></li>
<li><a href="../es424557/index.html">Gu√≠a de Node.js, Parte 8: Protocolos HTTP y WebSocket</a></li>
<li><a href="../es424559/index.html">Big Data resistencia 1 o el esquivo Joe. Anonimato de Internet, anti-detecci√≥n, anti-seguimiento para anti-usted y anti-nosotros.</a></li>
<li><a href="../es424563/index.html">Beeline env√≠a detalles de conversaciones a extra√±os</a></li>
<li><a href="../es424565/index.html">Descripci√≥n general: escaneo 3D de locales inmobiliarios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>