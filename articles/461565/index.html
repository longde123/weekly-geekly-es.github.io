<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦏 👰🏼 🥩 Los 5 mandamientos del desarrollador de TypeScript 💆🏽 👏🏾 👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cada vez más proyectos y equipos están utilizando TypeScript. Sin embargo, solo aplicar TypeScript y exprimirlo al máximo es algo muy diferente. 


 L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los 5 mandamientos del desarrollador de TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461565/"><p><img src="https://habrastorage.org/webt/mx/7h/yr/mx7hyrh8ms-5uuolkemexd9jkvo.jpeg" alt="imagen"></p><br><p>  Cada vez más proyectos y equipos están utilizando TypeScript.  Sin embargo, solo aplicar TypeScript y exprimirlo al máximo es algo muy diferente. </p><br><p>  Le presento una lista de las mejores prácticas de alto nivel para usar TypeScript que lo ayudarán a aprovechar al máximo este lenguaje. </p><a name="habracut"></a><br><h2 id="ne-lgite">  No mientas </h2><br><p>  <strong>Tipos es un contrato.</strong>  ¿Qué significa esto?  Cuando implementa una función, su tipo se convierte en una promesa para otros desarrolladores (¡o para usted mismo en el futuro!) Que, cuando se llama, esta función devolverá un cierto tipo de valor. </p><br><p> En el siguiente ejemplo, el tipo de la función <code>getUser</code> asegura que devuelve un objeto que <strong>siempre</strong> tiene dos propiedades: <code>name</code> y <code>age</code> . </p><br><pre> <code class="javascript hljs">interface User { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  TypeScript es un lenguaje muy flexible.  Tiene muchos compromisos diseñados para facilitar la introducción del lenguaje.  Por ejemplo, le permite implementar la función <code>getUser</code> esta manera: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> User; }</code> </pre> <br><p>  ¡No hagas eso!  Esto es falso.  Al crear dicho código, Mientes a otros desarrolladores (que usarán tu función en sus funciones).  Esperan que el objeto devuelto por <code>getUser</code> siempre tenga algún tipo de campo de <code>name</code> .  ¡Pero él no está allí!  Además, ¿qué sucede cuando su colega escribe <code>getUser(1).name.toString()</code> ?  Sabes muy bien que ... </p><br><p>  Aquí, por supuesto, la mentira parece obvia.  Sin embargo, al trabajar con una base de código grande, a menudo se encontrará en situaciones en las que el valor que desea devolver (o pasar) <em>casi</em> coincide con el tipo esperado.  <strong>Se necesita tiempo y esfuerzo para encontrar la causa de la falta de coincidencia de tipos</strong> , y tiene prisa ... por lo que decide utilizar la conversión de tipos. </p><br><p>  Sin embargo, al hacer esto, estás <strong>rompiendo el contrato sagrado</strong> .  SIEMPRE es mejor asignar tiempo y comprender por qué los tipos no coinciden que utilizar la conversión de tipos.  Es muy probable que algún error de tiempo de ejecución se esconda debajo de la superficie. </p><br><p>  <strong>No mientas</strong>  <strong>Obedece tus contratos.</strong> </p><br><h2 id="budte-tochny">  Se preciso </h2><br><p>  <strong>Los tipos son documentación.</strong>  Al documentar una función, ¿no desea transmitir tanta información como sea posible? </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function getUser(id) { /* ... */ } //     : name  age function getUser(id) { /* ... */ } //  id       id , //     : name  age. //     undefined. function getUser(id) { /* ... */ }</span></span></code> </pre> <br><p>  ¿Qué comentario para la función <code>getUser</code> gustaría más?  Cuanto más sepa que regresa una función, mejor.  Por ejemplo, sabiendo que puede regresar <code>undefined</code> , puede escribir un bloque <code>if</code> para verificar si el objeto que devolvió la función está definido antes de solicitar las propiedades de este objeto. </p><br><p>  Exactamente lo mismo con los tipos: cuanto más exactamente se describe un tipo, más información transmite. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standard</span></span></span><span class="hljs-function">' | '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">premium</span></span></span><span class="hljs-function">' | '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">admin</span></span></span><span class="hljs-function">' </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  La segunda versión de la función <code>getUserType</code> mucho más informativa y, por lo tanto, la persona que llama se encuentra en una situación mucho más conveniente.  Es más fácil procesar el valor si <strong>probablemente</strong> sabe (contratos, ¿recuerda?) Que será una de las tres líneas dadas, y no cualquier línea.  Para comenzar con lo que sabe con certeza: un valor no puede ser una cadena vacía. </p><br><p>  Consideremos un ejemplo más real.  El tipo de <code>State</code> describe el estado del componente que solicita algunos datos del backend.  ¿Es este tipo exacto? </p><br><pre> <code class="javascript hljs">interface State { <span class="hljs-attr"><span class="hljs-attr">isLoading</span></span>: boolean; data?: string[]; errorMessage?: string; }</code> </pre> <br><p>  Un cliente que usa este tipo debe manejar una combinación poco probable de valores de propiedades estatales.  Por ejemplo, una situación es imposible cuando las propiedades <code>data</code> y <code>errorMessage</code> se definen simultáneamente: una solicitud de datos puede tener éxito o fallar. </p><br><p>  Podemos hacer que el tipo sea mucho más preciso con la ayuda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos de unión discriminados</a> : </p><br><pre> <code class="javascript hljs">type State = | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'loading'</span></span> } | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'successful'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: string[] } | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'failed'</span></span>, <span class="hljs-attr"><span class="hljs-attr">errorMessage</span></span>: string };</code> </pre> <br><p>  Ahora el cliente que usa este tipo tiene mucha más información: ya no necesita procesar combinaciones incorrectas de propiedades. </p><br><p>  <strong>Se preciso.</strong>  <strong>Pase tanta información como sea posible sobre sus tipos.</strong> </p><br><h2 id="nachinayte-snbsptipov">  Comience con tipos </h2><br><p>  Dado que los tipos son tanto un contrato como una documentación, son excelentes para <strong>diseñar</strong> sus funciones (o métodos). </p><br><p>  Hay muchos artículos en Internet que aconsejan a los programadores <strong>que piensen antes de escribir el código</strong> .  Comparto completamente este enfoque.  La tentación de saltar directamente al código es genial, pero esto a menudo conduce a malas decisiones.  Pasar un poco de tiempo pensando en la implementación siempre vale la pena. </p><br><p>  Los tipos son extremadamente útiles en este proceso.  <em>Pensar</em> lleva a la creación de firmas de tipos de funciones relacionadas con la resolución de su problema.  Y eso es genial, porque te enfocas en lo que hacen tus funciones, en lugar de pensar en <em>cómo</em> lo hacen. </p><br><p>  React JS tiene el concepto de componentes de orden superior (HOC).  Estas son funciones que extienden el componente dado de alguna manera.  Por ejemplo, puede crear un componente de orden superior <code>withLoadingIndicator</code> que agrega un indicador de carga a un componente existente. </p><br><p>  Escribamos una firma de tipo para esta función.  La función acepta una entrada de componente y también devuelve un componente.  Para representar un componente, podemos usar el tipo React <code>ComponentType</code> . </p><br><p>  <code>ComponentType</code> es un tipo genérico que se parametriza por el tipo de propiedades del componente.  <code>withLoadingIndicator</code> acepta un componente y devuelve un nuevo componente que muestra el componente original o el indicador de carga.  La decisión sobre qué mostrar se basa en el valor de la nueva propiedad lógica: <code>isLoading</code> .  Por lo tanto, el componente devuelto necesita las mismas propiedades que el original, solo se agrega la nueva propiedad <code>isLoading</code> . </p><br><p>  Finalizaremos el tipo.  <code>withLoadingIndicator</code> acepta un componente de tipo <code>ComponentType&lt;P&gt;</code> , donde <code>P</code> denota el tipo de propiedad.  <code>withLoadingIndicator</code> devuelve un componente con propiedades avanzadas de tipo <code>P &amp; { isLoading: boolean }</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withLoadingIndicator = &lt;P&gt;(Component: ComponentType&lt;P&gt;) : ComponentType&lt;P &amp; { isLoading: boolean }&gt; =&gt; ({ isLoading, ...props }) =&gt; { /* ... */ }</code> </pre> <br><p>  Al tratar los tipos de funciones, nos vimos obligados a pensar en lo que estará en su entrada y en la salida.  En otras palabras, tuvimos que <em>diseñar una función</em> .  Escribir su implementación ahora es fácil. </p><br><p>  <strong>Comience con los tipos.</strong>  <strong>Deje que los tipos lo obliguen a diseñar primero, y solo luego escriba la implementación.</strong> </p><br><h2 id="primite-strogost">  Toma rigor </h2><br><p>  Los primeros tres mandamientos requieren que prestes especial atención a los tipos.  Afortunadamente, al resolver este problema, no tiene que hacer todo usted mismo; a menudo, el compilador TypeScript le informará cuándo sus tipos están mintiendo o cuando no son lo suficientemente precisos. </p><br><p>  Puede ayudar al compilador a hacerlo aún mejor si incluye el indicador <code>--strict</code> .  Este es un meta indicador que <code>--noImplicitAny</code> todas las opciones estrictas de verificación de tipos: <code>--noImplicitAny</code> , <code>--noImplicitThis</code> , <code>--alwaysStrict</code> , <code>--strictBindCallApply</code> , <code>--strictNullChecks</code> , <code>--strictFunctionTypes</code> y <code>--strictPropertyInitialization</code> . </p><br><p>  ¿Qué hacen las banderas?  En términos generales, su inclusión conduce a un aumento en el número de errores de compilación de TypeScript.  Y esto es bueno!  Más errores de compilación: más ayuda del compilador. </p><br><p>  Veamos cómo activar el indicador <code>--strictNullChecks</code> ayuda a detectar un falso en el código. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'John'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; } }</code> </pre> <br><p>  El tipo <code>getUser</code> asegura que la función siempre devuelve un objeto de tipo <code>User</code> .  Sin embargo, observe la implementación: ¡una función también puede volver <code>undefined</code> ! </p><br><p>  Afortunadamente, habilitar el indicador <code>--strictNullChecks</code> produce un error de compilación: </p><br><pre> <code class="plaintext hljs">Type 'undefined' is not assignable to type 'User'.</code> </pre> <br><p>  El compilador TypeScript detecta falsedades.  Para deshacerse de este error, honestamente diga toda la verdad: </p><br><pre> <code class="plaintext hljs">function getUser(id: number): User | undefined { /* ... */ }</code> </pre> <br><p>  <strong>Acepte el rigor de la verificación de tipos.</strong>  <strong>Deje que el compilador lo proteja de los errores.</strong> </p><br><h2 id="budte-v-kurse">  Mantenerse al día </h2><br><p>  TypeScript se está desarrollando a un ritmo muy rápido.  Se lanza un nuevo lanzamiento cada dos meses.  Cada versión trae mejoras significativas en el lenguaje y nuevas características. </p><br><p>  A menudo sucede que las nuevas características del lenguaje le permiten definir tipos con mayor precisión y verificarlos más estrictamente. </p><br><p>  Por ejemplo, en la versión 2.0 se introdujeron los Tipos de Unión Discriminada (los mencioné en el mandamiento <em>Sea preciso</em> ). </p><br><p>  La versión 3.2 introdujo el indicador del compilador <code>--strictBindCallApply</code> , que incluye la escritura correcta para las funciones de <code>--strictBindCallApply</code> , <code>call</code> y <code>apply</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La versión 3.4 mejoró la inferencia de tipos en funciones de orden superior</a> , lo que facilitó el uso de tipos exactos al escribir código en un estilo funcional. </p><br><p>  Mi posición es que conocer las características del lenguaje introducidas en las versiones recientes de TypeScript realmente vale la pena.  A menudo, esto puede ayudarlo a seguir los otros cuatro mandamientos de la lista. </p><br><p>  Un buen punto de partida es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja de ruta oficial de TypeScript</a> .  También será bueno revisar regularmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la sección TypeScript en Microsoft Devblog</a> , ya que todos los anuncios de lanzamiento van allí. </p><br><p>  <strong>Manténgase actualizado con las nuevas características del lenguaje y deje que este conocimiento trabaje para usted.</strong> </p><br><h2 id="rezyume">  Resumen </h2><br><p>  Espero que encuentre útil la lista.  Como siempre y en todo, uno no debe seguir ciegamente estos mandamientos.  Pero creo firmemente que estas reglas te harán un mejor desarrollador de TypeScript. </p><br><p>  Estaré encantado de ver tus pensamientos sobre este tema en los comentarios. </p><br><h2 id="bonus">  Bono </h2><br><p>  ¿Te ha gustado este artículo sobre TypeScript?  Estoy seguro de que también le gustará este PDF gratuito: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">10 errores de desarrollo de TypeScript que hacen que su código sea inseguro.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461565/">https://habr.com/ru/post/461565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461547/index.html">Sistema de información médica (MIS) como producto</a></li>
<li><a href="../461553/index.html">Experiencia en la automatización de pruebas visuales de regresión en Java + Selenium Webdriver + aShot</a></li>
<li><a href="../461555/index.html">Visualizaciones de hojas de cálculo de Google</a></li>
<li><a href="../461561/index.html">Temporizador Arduino</a></li>
<li><a href="../461563/index.html">Sable láser de vapor de cobre casero - Parte 3 Final</a></li>
<li><a href="../461567/index.html">SQL Rompecabezas entretenidos</a></li>
<li><a href="../461569/index.html">Nota para el front-end: qué verificar antes de probar</a></li>
<li><a href="../461571/index.html">SVG en la vida real. Informe Yandex</a></li>
<li><a href="../461575/index.html">Creación de una PBX basada en la nube 3CX en cualquier alojamiento compatible con Openstack</a></li>
<li><a href="../461577/index.html">Parte 5/2 Edif. 1: Crossroads of RocketChip Avenue y pista de instrumentación resbaladiza</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>