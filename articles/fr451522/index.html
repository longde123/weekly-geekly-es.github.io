<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛷️ 🖕🏼 🎑 Nous déployons l'automatisation en quelques heures: TypeScript, Protractor, Jasmine 👩🏾‍🎓 👩🏿‍🤝‍👨🏾 📴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Je m'appelle Vitaliy Kotov, je fais beaucoup de tests d'automatisation et j'aime ça. J'ai récemment participé à un projet de configu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous déployons l'automatisation en quelques heures: TypeScript, Protractor, Jasmine</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451522/"> Bonjour, Habr! <br><br>  Je m'appelle Vitaliy Kotov, je fais beaucoup de tests d'automatisation et j'aime ça.  J'ai récemment participé à un projet de configuration de l'automatisation à partir de zéro sur la pile TypeScript + Protractor + Jasmine.  Pour moi, cette pile était nouvelle et j'ai cherché les informations nécessaires sur Internet. <br><br>  J'ai réussi à trouver les manuels les plus utiles et les plus sensés uniquement en anglais.  J'ai décidé qu'en russe, je devais également le faire.  Je vais seulement vous dire les bases: pourquoi une telle pile, ce que vous devez configurer et à quoi ressemble le test le plus simple. <br><br>  Je dois dire tout de suite que je travaille rarement avec NodeJS, npm et avec JavaScript côté serveur en général (en particulier avec TypeScript).  Si vous trouvez une erreur dans la terminologie quelque part ou si certaines de mes décisions peuvent être améliorées, je serai heureux de le savoir dans les commentaires de gars plus expérimentés. <br><br>  Au fait, j'avais déjà un article similaire: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Nous déployons l'automatisation en quelques heures: PHPUnit, Selenium, Composer»</a> . <br><br><img src="https://habrastorage.org/webt/mn/rc/5t/mnrc5tzbyn3hmecryv5sj-1nuae.png"><br><a name="habracut"></a><br><h3>  Défi </h3><br>  Tout d'abord, voyons quel problème nous résolvons.  Nous avons une application web écrite en utilisant AngularJS.  Il s'agit d'un framework JavaScript basé sur lequel les projets Web sont souvent écrits. <br><br>  Dans cet article, nous ne considérerons pas les avantages et les inconvénients des projets AngularJS.  Quelques mots sur les caractéristiques de ces projets en termes de rédaction de tests e2e pour eux. <br><br>  Un aspect assez important du test de l'automatisation est de travailler avec des éléments de page, ce qui se produit à l'aide de localisateurs.  Un localisateur est une ligne composée selon certaines règles et identifiant un élément d'interface utilisateur: un ou plusieurs. <br><br>  Pour le Web, CSS et Xpath sont les plus couramment utilisés.  Parfois, s'il y a un élément avec un ID unique sur la page, vous pouvez le rechercher.  Cependant, il me semble que WebDriver transforme toujours cet ID en un localisateur CSS à la fin et travaille déjà avec lui. <br><br>  Si nous regardons le code HTML d'un projet AngularJS, nous verrons que les éléments ont beaucoup d'attributs qui ne sont pas en HTML classique: <br><br><img src="https://habrastorage.org/webt/zg/r3/et/zgr3etoo6q7qeycuobh1tl9g1f4.png"><br><br>  Le code est extrait de la page de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démonstration</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapporteur</a> . <br><br>  Tous les attributs commençant par ng- * sont utilisés par AngularJS pour travailler avec l'interface utilisateur.  Une situation assez typique est lorsque les éléments n'ont pas d'autres attributs que ces attributs de contrôle, ce qui complique quelque peu le processus de compilation des localisateurs de qualité. <br><br>  Ceux qui ont fait beaucoup d'automatisation connaissent la valeur de telles interfaces utilisateur pour lesquelles les localisateurs peuvent être facilement construits.  Après tout, cela est rare pour les grands projets.  :) <br><br>  En fait, pour un tel projet, nous devons également configurer l'automatisation des tests.  C'est parti! <br><br><h3>  C'est quoi </h3><br>  Tout d'abord, découvrons pourquoi chaque composant de notre pile est nécessaire. <br><br>  <b>Protractor</b> est un framework de test basé sur WebDriverJS.  Ce sera lui qui lancera nos navigateurs, leur fera ouvrir les pages nécessaires et interagira avec les éléments nécessaires. <br><br>  Ce cadre est spécialement conçu pour les projets AngularJS.  Il fournit des moyens supplémentaires pour spécifier les localisateurs: <br><br><pre><code class="javascript hljs">element(by.model(<span class="hljs-string"><span class="hljs-string">'first'</span></span>)); element(by.binding(<span class="hljs-string"><span class="hljs-string">'latest'</span></span>)); element(by.repeater(<span class="hljs-string"><span class="hljs-string">'some'</span></span>));</code> </pre> <br>  Une liste complète se trouve sur la page de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel</a> . <br><br>  Ces méthodes simplifient la création et la prise en charge de localisateurs sur un projet.  Cependant, vous devez comprendre que "sous le capot" tout cela est en tout cas converti en css.  Le fait est que le protocole W3C, sur la base duquel l'interaction dans WebDriver a lieu, ne peut fonctionner qu'avec un ensemble fini de localisateurs.  Cette liste peut être consultée sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">w3.org</a> . <br><br>  <b>TypeScript</b> est un langage de programmation créé par Microsoft.  TypeScript diffère de JavaScript par sa capacité à taper des variables, la prise en charge de l'utilisation de classes à part entière et la possibilité de connecter des modules. <br><br>  Écrit en code TS pour fonctionner avec le moteur V8 est traduit en code JS, qui est déjà en cours d'exécution.  Lors de cette transformation, la conformité du code est vérifiée.  Par exemple, il ne «compile» pas si, au lieu de int, une chaîne est explicitement passée quelque part à la fonction. <br><br>  <b>Jasmine</b> est un framework pour tester le code JavaScript.  En fait, c'est grâce à lui que notre code JS se transforme en ce que nous appelions un test.  Il gère ces tests. <br><br>  Ci-dessous, nous examinons ses capacités. <br><br><h3>  Montage et configuration du projet </h3><br>  Eh bien, nous avons décidé d'un ensemble de cadres, maintenant, mettons tout cela ensemble. <br><br>  Pour travailler avec le code, j'ai choisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio Code</a> de Microsoft.  Bien que beaucoup écrivent dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebStorm</a> ou même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intellij Idea</a> de JetBrains. <br><br>  J'ai déjà installé NodeJS (v11.6.0) et NPM (6.9.0).  Si vous ne l'avez pas, ce n'est pas un problème, leur installation n'est pas difficile.  Tout est décrit suffisamment en détail sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site officiel</a> . <br><br>  Le fil peut être utilisé à la place du NPM, bien que cela ne soit pas important pour un petit projet. <br><br>  Dans notre IDE, nous créons un nouveau projet.  Nous créons package.json à la racine du projet - c'est là que nous décrirons tous les packages dont nous avons besoin pour le projet. <br><br>  Vous pouvez le créer à l'aide de la commande <i>npm init</i> .  Ou vous pouvez simplement copier le contenu dans un fichier. <br><br>  Initialement, <b>package.json</b> ressemble à ceci: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@types/node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^10.5.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@types/jasmine"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.3.12"</span></span>, <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>: <span class="hljs-string"><span class="hljs-string">"^5.4.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"typescript"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.4.1"</span></span> } }</code> </pre><br>  Après cela, nous <i>exécutons la</i> commande <i>npm install</i> pour installer tous les modules nécessaires et leurs dépendances (enfin, vous vous souvenez de l'image même de quelque chose de plus lourd qu'un trou noir ...) <br><br>  En conséquence, nous devrions avoir un répertoire node_modules.  Si elle est apparue, alors tout se passe comme prévu.  Sinon, il vaut la peine d'examiner le résultat de l'exécution de la commande, généralement tout y est décrit en détail. <br><br><h3>  TypeScript et sa configuration </h3><br>  Pour installer TypeScript, nous avons besoin de npm: <br><br><pre> <code class="plaintext hljs">npm install -g typescript</code> </pre><br>  Assurez-vous qu'il est installé: <br><br><pre> <code class="plaintext hljs">$ tsc -v Version 3.4.1</code> </pre><br>  Tout semble être en ordre. <br><br>  Maintenant, nous devons créer une configuration pour travailler avec TS.  Il doit également être à la racine du projet et s'appeler <b>tsconfig.json</b> <br><br>  Son contenu sera comme ceci: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [<span class="hljs-string"><span class="hljs-string">"es6"</span></span>], <span class="hljs-string"><span class="hljs-string">"strict"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"outDir"</span></span> : <span class="hljs-string"><span class="hljs-string">"output_js"</span></span>, <span class="hljs-string"><span class="hljs-string">"types"</span></span> : [<span class="hljs-string"><span class="hljs-string">"jasmine"</span></span>, <span class="hljs-string"><span class="hljs-string">"node"</span></span>] }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"node_modules/*"</span></span> ] }</code> </pre><br>  En bref, nous avons spécifié ce qui suit dans cette configuration: <br><br><ul><li>  Dans quel répertoire placer le code JS final (dans notre cas, c'est output_js) </li><li>  Activer le mode strict </li><li>  Indiqué avec quels cadres nous travaillons </li><li>  Exclusion de node_modules de la compilation </li></ul><br>  TS a une grande variété de paramètres.  C'est suffisant pour notre projet.  Vous pouvez en savoir plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur typescriptlang.org</a> . <br><br>  Voyons maintenant comment fonctionne la commande <i>tsc</i> , qui transformera notre code TS en code JS.  Pour ce faire, créez un simple fichier check_tsc.ts avec le contenu suivant: <br><br><pre> <code class="javascript hljs">saySomething(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saySomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message); }</code> </pre><br>  Ensuite, exécutez la commande <i>tsc</i> (pour cela, vous devez être dans le répertoire du projet). <br><br>  Nous verrons que nous avons le répertoire output_js et un fichier js similaire avec le contenu suivant est apparu à l'intérieur: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; saySomething(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saySomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message); }</code> </pre><br>  Ce fichier peut déjà être lancé à l'aide de la commande node: <br><br><pre> <code class="plaintext hljs">$ node output_js/check_tsc.js Hello, world!</code> </pre><br>  Nous avons donc écrit notre premier programme TypeScipt, félicitations.  Écrivons des tests maintenant.  :) <br><br><h3>  Configuration du rapporteur </h3><br>  Pour Protractor, nous avons également besoin d'une configuration.  Mais ce ne sera plus sous forme de json, mais sous forme de fichier ts.  Appelons-le config.ts et écrivons-y le code suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Config } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config: Config = { <span class="hljs-attr"><span class="hljs-attr">seleniumAddress</span></span>: <span class="hljs-string"><span class="hljs-string">"http://127.0.0.1:4444/wd/hub"</span></span>, <span class="hljs-attr"><span class="hljs-attr">SELENIUM_PROMISE_MANAGER</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">capabilities</span></span>: { <span class="hljs-attr"><span class="hljs-attr">browserName</span></span>: <span class="hljs-string"><span class="hljs-string">"chrome"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*chromeOptions: { args: [ "--headless", "--window-size=800,600" ] }*/</span></span> }, <span class="hljs-attr"><span class="hljs-attr">specs</span></span>: [ <span class="hljs-string"><span class="hljs-string">"Tests/*Test.js"</span></span>, ] };</code> </pre><br>  Dans ce fichier, nous avons spécifié les éléments suivants: <br><br>  Tout d'abord, le chemin d'accès au serveur Selenium en cours d'exécution.  Il est assez simple à exécuter, il vous suffit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télécharger le fichier jar du serveur autonome</a> et les pilotes nécessaires (par exemple, le pilote chrome <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour le navigateur Chrome</a> ).  Ensuite, écrivez la commande suivante: <br><br><pre> <code class="plaintext hljs">java -jar -Dwebdriver.chrome.driver=/path/to/chromedriver /path/to/selenium-server-standalone.jar</code> </pre><br>  En conséquence, nous devrions voir la conclusion suivante: <br><br><pre> <code class="plaintext hljs">23:52:41.691 INFO [GridLauncherV3.launch] - Selenium build info: version: '3.11.0', revision: 'e59cfb3' 23:52:41.693 INFO [GridLauncherV3$1.launch] - Launching a standalone Selenium Server on port 4444 2019-05-02 23:52:41.860:INFO::main: Logging initialized @555ms to org.seleniumhq.jetty9.util.log.StdErrLog 23:52:42.149 INFO [SeleniumServer.boot] - Welcome to Selenium for Workgroups.... 23:52:42.149 INFO [SeleniumServer.boot] - Selenium Server is up and running on port 4444</code> </pre><br>  Le port 4444 est par défaut.  Il peut être défini à l'aide du paramètre -port ou via le paramètre de configuration "seleniumArgs" =&gt; "-port". <br><br>  Si vous voulez plus simple et plus rapide: vous pouvez télécharger le package npm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webdriver-manager</a> . <br><br>  Ensuite, gérez le serveur à l'aide des commandes de démarrage, d'arrêt, etc.  Il n'y a pas beaucoup de différence, c'est juste que je suis plus habitué à travailler avec un fichier jar.  :) <br><br>  <b>Deuxièmement</b> , nous avons indiqué que nous ne voulions pas utiliser le gestionnaire Promise.  Plus d'informations à ce sujet plus tard. <br><br>  <b>Troisièmement</b> , nous avons spécifié des capacités pour notre navigateur.  J'ai commenté une partie, par exemple, que nous pouvons assez facilement lancer le navigateur en mode sans tête.  C'est une fonctionnalité intéressante, mais elle ne vous permettra pas d'observer visuellement nos tests.  En attendant, nous apprenons juste - je voudrais.  :) <br><br>  <b>Quatrièmement</b> , nous avons spécifié un masque pour les spécifications (tests).  Tout ce qui se trouve dans le dossier Tests et se termine par Test.js.  Pourquoi sur js, pas ts?  En effet, en fin de compte, Node fonctionnera spécifiquement avec les fichiers JS et non avec les fichiers TS.  Il est important de ne pas se confondre, surtout au début du travail. <br><br>  Créez maintenant le dossier Tests et écrivez le premier test.  Il fera ce qui suit: <br><br><ul><li>  Désactive la vérification qu'il s'agit d'une page angulaire.  Sans cela, nous obtenons ce message d'erreur: Erreur lors de l'exécution de testForAngular.  Bien sûr, pour les pages angulaires, cette vérification n'est pas nécessaire pour désactiver. </li><li>  Accède à la page Google. </li><li>  Vérifiez qu'il existe un champ de saisie de texte. </li><li>  Entrez le texte «rapporteur». </li><li>  Cliquez sur le bouton soumettre (il a un localisateur assez compliqué, car il y a deux boutons et le premier est invisible). </li><li>  On s'attendra à ce que l'URL contienne le mot «rapporteur» - cela signifie que nous avons tout fait correctement et que la recherche a commencé. </li></ul><br>  Voici le code que j'ai obtenu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { browser, by, element, protractor } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'Search'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'Open google and find a text'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-comment"><span class="hljs-comment">//       let EC = protractor.ExpectedConditions; //    AngularJS await browser.waitForAngularEnabled(false); //   Google await browser.get('https://www.google.com/'); //    css = input[role='combobox'] let input_button = element(by.css("input[role='combobox']")); //     ( presenceOf) await browser.wait(EC.presenceOf(input_button), 5000); //     “protractor” await input_button.sendKeys("protractor"); //      css let submit_button = element(by.css(".FPdoLc input[type='submit'][name='btnK']")); //      ( ,     input-,   ) await browser.wait(EC.presenceOf(submit_button), 5000); //     await submit_button.click(); // ,  URL    'protractor' await browser.wait(EC.urlContains('protractor'), 5000); }); });</span></span></code> </pre><br>  Dans le code, nous voyons que tout commence par la fonction describe ().  Elle nous est venue du framework Jasmine.  Ceci est un wrapper pour notre script.  À l'intérieur, il peut y avoir des fonctions beforeAll () et beforeEach () pour effectuer des manipulations avant tous les tests et avant chaque test.  Autant de fonctions qu'il () sont, en fait, nos tests.  En fin de compte, s'ils sont définis, afterAll () et afterEach () seront exécutés pour les manipulations après chaque test et tous les tests. <br><br>  Je ne parlerai pas de toutes les fonctionnalités de Jasmine, vous pouvez les lire sur le site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jasmine.github.io</a> <br><br>  Pour exécuter notre test, vous devez d'abord transformer le code TS en code JS, puis l'exécuter: <br><br><pre> <code class="plaintext hljs">$ tsc $ protractor output_js/config.js</code> </pre><br>  Notre test a commencé - nous sommes super.  :) <br><br><img src="https://habrastorage.org/webt/0f/vu/wc/0fvuwcmgrgf-pspd7vngaweq2dy.png"><br><br>  Si le test n'a pas commencé, il convient de vérifier: <br><br><ul><li>  Que le code est écrit correctement.  En général, s'il y a des erreurs critiques dans le code, nous les rattraperons lors de la commande tsc. </li><li>  Ce serveur Selenium est en cours d'exécution.  Pour ce faire, vous pouvez ouvrir l'URL http: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">//127.0.0.1-00-00444/wd/hub</a> - il devrait y avoir une interface pour les sessions Selenium. </li><li>  Que Chrome démarre normalement avec la version téléchargée de chrome-driver.  Pour ce faire, sur la page wd / hub /, cliquez sur Créer une session et sélectionnez Chrome.  S'il ne démarre pas, vous devez soit mettre à jour Chrome, soit télécharger une autre version de chrome-driver. </li><li>  Si tout cela échoue, vous pouvez vérifier que la commande npm install s'est terminée avec succès. </li><li>  Si tout est écrit correctement, mais que rien ne démarre toujours - essayez de rechercher l'erreur sur google.  Cela aide le plus souvent.  :) </li></ul><br><h3>  Scripts NPM </h3><br>  Pour vous simplifier la vie, vous pouvez créer une partie des commandes npm alias.  Par exemple, je voudrais supprimer le répertoire avec les fichiers JS précédents et le recréer avec de nouveaux avant chaque test. <br><br>  Pour ce faire, ajoutez l'élément de scripts à package.json: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"rm -rf output_js/; tsc; protractor output_js/config.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@types/node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^10.5.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@types/jasmine"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.3.12"</span></span>, <span class="hljs-string"><span class="hljs-string">"protractor"</span></span>: <span class="hljs-string"><span class="hljs-string">"^5.4.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"typescript"</span></span>: <span class="hljs-string"><span class="hljs-string">"^3.4.1"</span></span> } }</code> </pre><br>  Maintenant, en entrant la commande de <i>test npm,</i> les événements suivants se produiront: le répertoire output_js avec l'ancien code sera supprimé, il sera recréé et un nouveau code JS y sera écrit.  Après quoi, les tests commenceront immédiatement. <br><br>  Au lieu de cet ensemble de commandes, vous pouvez spécifier toute autre dont vous avez personnellement besoin pour travailler.  Par exemple, vous pouvez démarrer et éteindre un serveur au sélénium entre les tests.  Bien que cela, bien sûr, est plus facile à contrôler à l'intérieur du code de test lui-même. <br><br><h3>  Un peu sur Promise </h3><br>  Au final, je vais parler un peu de Promise, async / wait et en quoi l’écriture des tests dans NodeJS diffère du même Java ou Python. <br><br>  JavaScript est un langage asynchrone.  Cela signifie que le code n'est pas toujours exécuté dans l'ordre dans lequel il est écrit.  Cela inclut les requêtes HTTP, et nous nous souvenons que le code communique avec Selenium Server via HTTP. <br><br>  Promise (généralement appelé «promesses») fournit un moyen pratique d'organiser le code asynchrone.  Vous pouvez en savoir plus à leur sujet sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">learn.javascript.ru</a> . <br><br>  En fait, ce sont des objets qui rendent un code dépendant de l'exécution d'un autre, garantissant ainsi un certain ordre.  Le rapporteur travaille très activement avec ces objets. <br><br>  Regardons un exemple.  Supposons que nous exécutons le code suivant: <br><br><pre> <code class="java hljs">driver.findElement().getText();</code> </pre><br>  En Java, nous nous attendons à ce que nous renvoyions un objet de type String.  Dans Protractor, ce n'est pas tout à fait le cas, nous retournerons un objet Promise.  Et juste comme ça, l'imprimer avec un objectif de débogage ne fonctionnera pas. <br><br>  Habituellement, nous n'avons pas besoin d'imprimer la valeur résultante.  Nous devons le passer à une autre méthode qui fonctionnera déjà avec cette valeur.  Par exemple, il vérifiera la conformité du texte avec l'attendu. <br><br>  Des méthodes similaires dans Protractor acceptent également les objets Promise en entrée, il n'y a donc aucun problème.  Mais, si vous voulez toujours voir la valeur, () vous sera utile. <br><br>  C'est ainsi que nous pouvons imprimer le texte du bouton sur une page Google (notez que puisqu'il s'agit d'un bouton, le texte est à l'intérieur de l'attribut value): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let submit_button = element(by.css(".FPdoLc input[type='submit'][name='btnK']")); //    await browser.wait(EC.presenceOf(submit_button), 5000); //   then()   await submit_button.getAttribute("value").then((text) =&gt; { console.log(text); });</span></span></code> </pre><br>  En ce qui concerne les mots clés asynchrones / attendent, il s'agit d'une approche légèrement plus récente pour travailler avec du code asynchrone.  Il vous permet d'éviter l'enfer des promesses, qui était auparavant formé dans le code en raison du grand nombre d'imbrication.  Néanmoins, vous ne pourrez pas vous débarrasser complètement de Promise et vous devez pouvoir travailler avec eux.  Ceci est compréhensible et détaillé peut être trouvé dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conception asynchrone / attendre en JavaScript: forces, pièges et caractéristiques d'utilisation</a> . <br><br><h3>  Devoirs </h3><br>  En guise de devoirs, je suggère d'écrire des tests pour une page écrite en AngularJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">protractor-demo</a> . <br><br>  N'oubliez pas de supprimer la ligne du code concernant la désactivation de la vérification des pages sur AngularJS.  Et assurez-vous de travailler avec des localisateurs spécialement conçus pour AngularJS.  Il n'y a pas de magie particulière à cela, mais c'est assez pratique. <br><br><h3>  Résumé </h3><br>  Faisons le point.  Nous avons réussi à écrire des tests qui fonctionnent sur un tas de TypeScript + Protractor + Jasmine.  Nous avons appris à construire un tel projet, à créer les configurations nécessaires et à écrire le premier test. <br><br>  En cours de route, nous avons discuté un peu de l'utilisation des tests automatiques JavaScript.  Cela semble bon pour quelques heures.  :) <br><br><h3>  Que lire, où chercher </h3><br>  <b>Protractor</b> a un très bon manuel avec des exemples JavaScript: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.protractortest.org/#/tutorial</a> <br>  <b>Jasmine</b> a un manuel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jasmine.github.io/pages/docs_home.html</a> <br>  <b>TypeScipt</b> a un bon début: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html</a> <br><br>  Sur le support, il y a un bon article en anglais sur TypeScript + Protractor + Cucumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://medium.com/@igniteram/e2e-testing-with-protractor-cucumber-using-typescript-564575814e4a</a> <br><br>  Et dans mon référentiel, j'ai publié le code final de ce dont nous avons discuté dans cet article: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/KotovVitaliy/HarbProtractorJasmineJasmine</a> . <br><br>  Sur Internet, vous pouvez trouver des exemples de projets plus complexes et plus importants sur cette pile. <br><br>  Merci de votre attention!  :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451522/">https://habr.com/ru/post/fr451522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451512/index.html">Comment analyser le protocole réseau MMORPG mobile</a></li>
<li><a href="../fr451514/index.html">Nouvelles des sous-grilles CSS</a></li>
<li><a href="../fr451516/index.html">Modèles de conception utilisés dans le framework Spring</a></li>
<li><a href="../fr451518/index.html">Nos sites Web mobiles dépouillés</a></li>
<li><a href="../fr451520/index.html">VDI: pas cher et gai</a></li>
<li><a href="../fr451524/index.html">L'histoire de la rupture de la bouilloire Autoplay Media Studio 8.5.3.0</a></li>
<li><a href="../fr451528/index.html">«Et c'est ainsi»: que les fournisseurs de cloud ne s'entendent pas sur les données personnelles</a></li>
<li><a href="../fr451532/index.html">Nouvelles du monde d'OpenStreetMap n ° 459 (30/04/2019 - 06/05/2019)</a></li>
<li><a href="../fr451534/index.html">12 principes d'animation dans le développement de jeux vidéo</a></li>
<li><a href="../fr451538/index.html">Guide de mise à l'échelle parallèle d'Amazon Redshift et résultats des tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>