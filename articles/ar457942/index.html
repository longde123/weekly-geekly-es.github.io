<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘 🚕 🚾 ما تعلمته عن التحسين في بيثون 👵🏾 🈴 🧜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا بالجميع. نود اليوم أن نشارك ترجمة أخرى تم إعدادها عشية إطلاق دورة مطور بايثون . دعنا نذهب! 



 لقد استخدمت بايثون أكثر من أي لغة برمجة أخرى في ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ما تعلمته عن التحسين في بيثون</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457942/" style=";text-align:right;direction:rtl">  مرحبا بالجميع.  نود اليوم أن نشارك ترجمة أخرى تم إعدادها عشية إطلاق دورة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مطور بايثون</a> .  دعنا نذهب! <br><br><img src="https://habrastorage.org/webt/0-/xf/qt/0-xfqtj4sbazxamoeq0lzuaeor4.png"><br><br>  لقد استخدمت بايثون أكثر من أي لغة برمجة أخرى في آخر 4-5 سنوات.  Python هي اللغة السائدة للإنشاءات تحت Firefox والاختبار وأداة CI.  زئبقي هو أيضا مكتوب في الغالب في بيثون.  كتبت أيضًا الكثير من مشاريع الأطراف الثالثة الخاصة بي. <br><br>  خلال عملي ، اكتسبت القليل من المعرفة حول أداء Python وأدوات التحسين الخاصة به.  في هذه المقالة ، أود أن أشارك هذه المعرفة. <br><br>  ترتبط تجربتي مع Python بشكل رئيسي بمترجم CPython ، خاصة CPython 2.7.  ليست كل ملاحظاتي عالمية لجميع توزيعات Python ، أو تلك التي لها نفس الخصائص في إصدارات مماثلة من Python.  سأحاول أن أذكر هذا خلال السرد.  ضع في اعتبارك أن هذه المقالة ليست نظرة عامة مفصلة عن أداء بيثون.  سأتحدث فقط عما صادفته بمفردي. <a name="habracut"></a><br><br><h2 style=";text-align:right;direction:rtl">  الحمل بسبب خصوصيات بدء واستيراد الوحدات النمطية </h2><br>  يعد بدء تشغيل مترجم Python واستيراد الوحدات عملية طويلة إلى حد ما عندما يتعلق الأمر بالميلي ثانية. <br><br>  إذا كنت بحاجة إلى بدء المئات أو الآلاف من عمليات Python في أي من مشاريعك ، فإن هذا التأخير بالميلي ثانية سوف يتحول إلى تأخير يصل إلى عدة ثوانٍ. <br><br>  إذا كنت تستخدم Python لتوفير أدوات CLI ، فقد يتسبب الحمل العام في تجميد ملحوظ للمستخدم.  إذا كنت بحاجة إلى أدوات CLI على الفور ، فإن تشغيل مترجم Python مع كل مكالمة سيجعل من الصعب الحصول على هذه الأداة المعقدة. <br><br>  لقد كتبت بالفعل عن هذه المشكلة.  تتحدث بعض ملاحظاتي السابقة عن هذا ، على سبيل المثال ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في عام 2014</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في مايو 2018</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وأكتوبر 2018</a> . <br><br>  لا توجد أشياء كثيرة يمكنك القيام بها لتقليل تأخير بدء التشغيل: يشير إصلاح هذه الحالة إلى معالجة مترجم Python ، لأنه هو الذي يتحكم في تنفيذ التعليمات البرمجية التي تستغرق الكثير من الوقت.  أفضل شيء يمكنك القيام به هو تعطيل استيراد وحدة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الموقع</a> في المكالمات لتجنب تنفيذ شفرة Python الإضافية عند بدء التشغيل.  من ناحية أخرى ، تستخدم العديد من التطبيقات وظيفة وحدة site.py ، بحيث يمكنك استخدامها على مسؤوليتك الخاصة. <br><br>  يجب أن نفكر أيضًا في مشكلة استيراد الوحدات النمطية.  ما الفائدة من مترجم بايثون إذا لم يعالج أي كود؟  الحقيقة هي أن الشفرة متاحة للمترجم الفوري في كثير من الأحيان من خلال استخدام الوحدات النمطية. <br><br>  لاستيراد الوحدات ، تحتاج إلى اتخاذ عدة خطوات.  وفي كل منها يوجد مصدر محتمل للأحمال والتأخير. <br><br>  يحدث تأخير معين بسبب البحث عن الوحدات النمطية وقراءة بياناتها.  كما <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أوضحت</a> مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PyOxidizer</a> ، استبدال بحث وحدة نمطية وتحميلها من نظام ملفات بحل أبسط معمارياً ، والذي يتكون من قراءة بيانات الوحدة النمطية من بنية بيانات في الذاكرة ، يمكنك استيراد مكتبة Python القياسية لمدة 70-80٪ من وقت الحل الأولي لهذه المهمة.  إن وجود وحدة واحدة لكل ملف نظام ملف يزيد من الحمل على نظام الملفات ويمكن أن يبطئ تطبيق Python خلال المللي ثانية الأولى من التنفيذ.  يمكن أن تساعد حلول مثل PyOxidizer في تجنب هذا.  آمل أن يرى مجتمع Python تكاليف النهج الحالي ويفكر في الانتقال إلى آليات توزيع الوحدات ، والتي لا تعتمد كثيرًا على الملفات الفردية في الوحدة النمطية. <br><br>  مصدر آخر لتكاليف الاستيراد الإضافية لوحدة نمطية هو تنفيذ التعليمات البرمجية في تلك الوحدة أثناء الاستيراد.  تحتوي بعض الوحدات على أجزاء من الكود في منطقة خارج وظائف وفئات الوحدة ، والتي يتم تنفيذها عند استيراد الوحدة.  تنفيذ هذا الرمز يزيد من تكلفة الاستيراد.  الحل البديل: لا تنفذ كل التعليمات البرمجية في وقت الاستيراد ، ولكن فقط قم بتنفيذها إذا لزم الأمر.  يدعم Python 3.7 الوحدة النمطية <code>__getattr__</code> ، والتي سيتم استدعاؤها إذا لم يتم العثور على سمة الوحدة النمطية.  يمكن استخدام هذا لملء سمات الوحدة النمطية بتكاسل عند الوصول الأول. <br><br>  هناك طريقة أخرى للتخلص من تباطؤ الاستيراد وهي استيراد الوحدة النمطية بتكاسل.  بدلاً من تحميل الوحدة النمطية مباشرةً أثناء الاستيراد ، تقوم بتسجيل وحدة استيراد مخصصة تقوم بإرجاع كعب روتين بدلاً من ذلك.  عند الوصول لأول مرة إلى هذا العنصر ، سيتم تحميل الوحدة النمطية الفعلية و "تغيير" لتصبح هذه الوحدة. <br><br>  يمكنك حفظ عشرات الميلي ثانية مع التطبيقات التي تستورد عدة عشرات من الوحدات النمطية إذا تجاوزت نظام الملفات وتجنب تشغيل الأجزاء غير الضرورية من الوحدة النمطية (عادة ما يتم استيراد الوحدات النمطية على المستوى العالمي ، ولكن يتم استخدام وظائف معينة فقط من الوحدات). <br><br>  استيراد كسول من الوحدات هو شيء هش.  تحتوي العديد من الوحدات النمطية على قوالب تحتوي على الأشياء التالية: <code>try: import foo</code> ؛  <code>except ImportError:</code>  قد لا يقوم مستورد الوحدة البطيئة مطلقًا باستيراد ImportError ، لأنه إذا فعل ذلك ، فسيتعين عليه البحث في نظام الملفات عن وحدة نمطية لمعرفة ما إذا كان موجودًا من حيث المبدأ.  سيضيف هذا حمولة إضافية ويزيد من الوقت المستغرق ، لذلك المستوردون البطيئون لا يقومون بهذا من حيث المبدأ!  هذه المشكلة مزعجة جدا.  مستورد الوحدات النمطية الكسولة تقوم Mercurial بمعالجة قائمة الوحدات النمطية التي لا يمكن استيرادها بشكل كسول ، ويجب تجاوزها.  هناك مشكلة أخرى هي بناء الجملة <code>from foo import x, y</code> ، والذي يقاطع أيضًا استيراد الوحدة النمطية البطيئة ، في الحالات التي تكون فيها foo عبارة عن وحدة نمطية (على عكس الحزمة) ، حيث لا يزال يجب استيراد الوحدة النمطية لإرجاع مرجع إلى x و y. <br><br>  يحتوي PyOxidizer على مجموعة ثابتة من الوحدات السلكية في الملف الثنائي ، بحيث يمكن أن تكون فعالة في رفع ImportError.  توفر الوحدة __getattr__ من Python 3.7 مرونة إضافية للمستوردين من كسول الوحدة.  أتمنى دمج مستورد موثوق به كسول في PyOxidizer لأتمتة بعض العمليات. <br><br>  أفضل حل لتجنب بدء المترجم الفوري والتسبب في تأخير الوقت هو بدء عملية الخلفية في بيثون.  إذا بدأت عملية Python كعملية خفية ، لنقل عن خادم ويب ، فيمكنك القيام بذلك.  الحل الذي يقدمه Mercurial هو بدء عملية خلفية توفر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بروتوكول خادم أمر</a> .  hg هو الملف القابل للتنفيذ C (أو الآن Rust) ، والذي يتصل بعملية الخلفية هذه ويرسل أمرًا.  لإيجاد نهج لخادم الأوامر ، تحتاج إلى القيام بالكثير من العمل ، إنه غير مستقر للغاية ولديه مشاكل أمنية.  أنا أفكر في فكرة تقديم خادم أوامر باستخدام PyOxidizer حتى يتمتع الملف القابل للتنفيذ بمزاياه ، وتم حل مشكلة تكلفة حل البرنامج نفسه عن طريق إنشاء مشروع PyOxidizer. <br><br><h2 style=";text-align:right;direction:rtl">  وظيفة الدعوة تأخير </h2><br>  استدعاء وظائف في بيثون هي عملية بطيئة نسبيا.  (هذه الملاحظة أقل انطباقًا على PyPy ، والتي يمكنها تنفيذ كود JIT.) <br><br>  رأيت العشرات من التصحيحات لبرنامج Mercurial ، والتي مكنت من محاذاة الكود ودمجه بطريقة تتجنب التحميل غير الضروري عند استدعاء الوظائف.  في دورة التطوير الحالية ، تم بذل بعض الجهود لتقليل عدد الوظائف المدعوة عند تحديث شريط التقدم.  (نحن نستخدم أشرطة التقدم لأية عمليات قد تستغرق بعض الوقت ، حتى يدرك المستخدم ما يحدث).  يؤدي الحصول على نتائج استدعاء <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الوظائف</a> وتجنب البحث البسيط بين <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الوظائف إلى</a> توفير عشرات مئات الميلي ثانية عند تنفيذها ، عندما نتحدث عن مليون عملية إعدام ، على سبيل المثال. <br><br>  إذا كانت لديك حلقات ضيقة أو وظائف متكررة في Python حيث يمكن أن تحدث مئات الآلاف أو أكثر من مكالمات الوظائف ، فيجب أن تكون على دراية بالحمل الزائد للاتصال بوظيفة فردية ، لأن هذا له أهمية كبيرة.  ضع في اعتبارك الوظائف المدمجة البسيطة والقدرة على الجمع بين الوظائف لتجنب الحمل. <br><br><h2 style=";text-align:right;direction:rtl">  سمة البحث الحمل </h2><br>  تشبه هذه المشكلة الحمل الزائد بسبب استدعاء دالة ، لأن المعنى هو نفسه تقريبًا! <br><br>  يمكن أن يكون العثور على حل السمات في Python بطيئًا.  (ومرة أخرى ، في PyPy ، هذا أسرع).  ومع ذلك ، فإن معالجة هذه المشكلة هو ما نفعله غالبًا في Mercurial. <br><br>  لنفترض أن لديك الكود التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(obj.member): total += obj.member[i]</code> </pre> <br>  لقد أغفلنا وجود طرق أكثر فاعلية لكتابة هذا المثال (على سبيل المثال ، <code>total = sum(obj.member)</code> ) ، ولاحظ أن الحلقة تحتاج إلى تحديد obj.member في كل تكرار.  بيثون لديه آلية متطورة نسبيا لتحديد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">السمات</a> .  لأنواع بسيطة ، يمكن أن يكون بسرعة كافية.  ولكن بالنسبة للأنواع المعقدة ، يمكن لهذا الوصول إلى السمة الاتصال تلقائيًا بـ <code>__getattr__</code> ، <code>__getattribute__</code> ، وطرق <code>dunder</code> المختلفة <code>dunder</code> وحتى الوظائف التي يحددها المستخدم <code>@property</code> .  يشبه هذا البحث السريع عن سمة يمكنها إجراء العديد من استدعاءات الوظائف ، مما سيؤدي إلى تحميل إضافي.  ويمكن أن يتفاقم هذا الحمل إذا كنت تستخدم أشياء مثل <code>obj.member1.member2.member3</code> ، إلخ. <br><br>  يؤدي كل تعريف للسمة إلى تحميل إضافي.  ونظرًا لأن كل شيء تقريبًا في Python عبارة عن قاموس ، فيمكننا القول أن كل عملية بحث عن السمات هي بحث في القاموس.  من المفاهيم العامة حول بنيات البيانات الأساسية ، نعلم أن بحث القاموس ليس بالسرعة ، على سبيل المثال ، البحث في الفهرس.  نعم ، بالطبع هناك بعض الحيل في CPython التي يمكنها التخلص من النفقات العامة بسبب عمليات البحث في القاموس.  ولكن الموضوع الرئيسي الذي أريد أن أتطرق إليه هو أن أي بحث في السمة هو تسرب محتمل للأداء. <br><br>  بالنسبة للحلقات الضيقة ، وخاصة تلك التي يحتمل أن تتجاوز مئات الآلاف من التكرارات ، يمكنك تجنب هذه النفقات العامة القابلة للقياس للعثور على سمات عن طريق تعيين قيمة لمتغير محلي.  لنلقِ نظرة على المثال التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> member = obj.member <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(member): total += member[i]</code> </pre> <br>  بالطبع ، لا يمكن القيام بذلك إلا بأمان إذا لم يتم استبداله في دورة.  إذا حدث هذا ، فسوف يحتفظ التكرار بالرابط الخاص بالعنصر القديم وقد ينفجر كل شيء. <br>  يمكن تنفيذ نفس الخدعة عند استدعاء طريقة الكائن.  عوضا عن <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">obj = MyObject() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>): obj.process(i)</code> </pre><br>  يمكنك القيام بما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">obj = MyObject() fn = obj.process <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>:) fn(i)</code> </pre> <br>  تجدر الإشارة أيضًا إلى أنه في الحالة التي يحتاج فيها البحث عن السمة إلى استدعاء طريقة (كما في المثال السابق) ، يكون Python 3.7 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أسرع</a> نسبيًا من الإصدارات السابقة.  لكنني متأكد من أن الحمل الزائد هنا متصل ، أولاً وقبل كل شيء ، باستدعاء الوظيفة ، وليس بالتحميل على البحث عن السمة.  لذلك ، سيعمل كل شيء بشكل أسرع إذا تخلت عن البحث الإضافي عن السمات. <br><br>  أخيرًا ، نظرًا لأن بحث السمة يستدعي وظيفة لهذا ، يمكن القول أن البحث عن السمة يمثل عمومًا مشكلة أقل من التحميل بسبب استدعاء دالة.  عادة ، لإشعار تغييرات كبيرة في السرعة ، ستحتاج إلى القضاء على الكثير من عمليات البحث عن السمات.  في هذه الحالة ، بمجرد إتاحة الوصول إلى جميع السمات الموجودة داخل الحلقة ، يمكنك التحدث عن 10 أو 20 سمة فقط في الحلقة قبل استدعاء الوظيفة.  ويمكن للحلقات التي تضم أقل من آلاف أو أقل من عشرات الآلاف من التكرار توفير مئات الآلاف أو ملايين من عمليات البحث عن السمات.  لذا كن حذرا! <br><br><h2 style=";text-align:right;direction:rtl">  تحميل الكائن </h2><br>  من وجهة نظر مترجم Python ، كل القيم هي كائنات.  في CPython ، كل عنصر عبارة عن بنية PyObject.  كل كائن يتحكم فيه المترجم يكون على الكومة وله ذاكرته الخاصة التي تحتوي على عدد المرجع ونوع الكائن والمعلمات الأخرى.  يتم التخلص من كل كائن بواسطة جامع البيانات المهملة.  هذا يعني أن كل كائن جديد يضيف حمولة بسبب حساب المرجع ، وجمع القمامة ، وما إلى ذلك.  (ومرة أخرى ، يمكن لـ PyPy تجنب هذا العبء غير الضروري ، لأنه أكثر "حذراً" بشأن عمر القيم قصيرة الأجل.) <br><br>  بشكل عام ، كلما كانت القيم الفريدة والكائنات Python التي تقوم بإنشائها ، تعمل الأشياء الأبطأ من أجلك. <br><br>  لنفترض أنك تتكرر على مجموعة من مليون كائن.  يمكنك استدعاء دالة لجمع هذا الكائن في tuple: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> my_collection: a, b, c, d, e, f, g, h = process(x)</code> </pre> <br>  في هذا المثال ، ستُرجع <code>process()</code> tuple 8 tuple.  لا يهم إذا قمنا بتدمير قيمة الإرجاع أم لا: تتطلب هذه المجموعة إنشاء 9 قيم على الأقل في Python: 1 للتوليف نفسه و 8 لأعضاءه الداخليين.  حسنًا ، في الحياة الواقعية قد يكون هناك عدد أقل من القيم إذا أعادت <code>process()</code> إشارة إلى كائن موجود.  أو ، على العكس من ذلك ، قد يكون هناك المزيد إذا كانت أنواعها ليست بسيطة وتتطلب العديد من PyObjects لتمثيلها.  أريد فقط أن أقول أنه تحت غطاء المترجم الشفهي ، هناك شعوذة حقيقية من الأشياء للعرض الكامل لبعض المنشآت. <br><br>  من تجربتي الخاصة أستطيع أن أقول إن هذه النفقات العامة ذات صلة فقط بالعمليات التي توفر مكاسب السرعة عند تنفيذها بلغة أصلية مثل C أو Rust.  المشكلة هي أن مترجم CPython غير قادر ببساطة على تنفيذ كود البايت بسرعة كبيرة لدرجة أن الحمل الزائد بسبب عدد الأشياء مهم.  بدلاً من ذلك ، من الأرجح أن تقوم بتقليل الأداء عن طريق استدعاء وظيفة ، أو من خلال حسابات مرهقة ، إلخ.  قبل أن تلاحظ الحمل الزائد بسبب الأشياء.  هناك بالطبع بعض الاستثناءات ، وهي بناء التلاميذ أو قواميس متعددة القيم. <br><br>  كمثال ملموس على الحمل ، يمكنك ذكر Mercurial باستخدام رمز C الذي يقوم بتوزيع بنيات البيانات منخفضة المستوى.  للحصول على مزيد من السرعة في التحليل ، يعمل رمز C بترتيب حجم أسرع من CPython.  ولكن بمجرد قيام رمز C بإنشاء PyObject لتمثيل النتيجة ، تنخفض السرعة عدة مرات.  بمعنى آخر ، يتضمن التحميل إنشاء عناصر Python وإدارتها بحيث يمكن استخدامها في التعليمات البرمجية. <br><br>  هناك طريقة لحل هذه المشكلة وهي إنتاج عناصر أقل في بيثون.  إذا كنت بحاجة إلى الرجوع إلى عنصر واحد ، فقم ببدء الوظيفة وإعادتها ، وليس تلميحًا أو قاموسًا لعناصر N.  ومع ذلك ، لا تتوقف عن مراقبة الحمل المحتمل بسبب استدعاءات الوظائف! <br><br>  إذا كان لديك الكثير من التعليمات البرمجية التي تعمل بسرعة كافية باستخدام CPython C API ، والعناصر التي تحتاج إلى توزيع بين وحدات نمطية مختلفة ، فيمكنك الاستغناء عن أنواع Python التي تمثل بيانات مختلفة مثل بنيات C ولديها بالفعل تعليمات برمجية برمجية للوصول إلى هذه الهياكل بدلا من الذهاب من خلال CPython C API.  عن طريق تجنب CPython C API للوصول إلى البيانات ، سوف تتخلص من الكثير من الحمل الزائد. <br><br>  إن التعامل مع العناصر كبيانات (بدلاً من وجود وظائف للوصول إلى كل شيء على التوالي) سيكون أفضل طريقة لبيثون.  حل آخر لرمز المترجمة بالفعل هو إنشاء كسول PyObject.  إذا قمت بإنشاء نوع مخصص في Python (PyTypeObject) لتمثيل العناصر المعقدة ، فإنك تحتاج إلى تحديد <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">حقول tp_members</a></i> أو <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">tp_getset</a></i> لإنشاء وظائف C مخصصة للبحث عن قيمة السمة.  إذا قمت ، على سبيل المثال ، بكتابة محلل ومعرفة أن العملاء لن يتمكنوا من الوصول إلا إلى مجموعة فرعية من الحقول التي تم تحليلها ، يمكنك إنشاء نوع يحتوي على بيانات أولية بسرعة وإرجاع هذا النوع واستدعاء دالة C للبحث عن سمات Python التي تعالج PyObject.  يمكنك حتى تأخير التحليل حتى يتم استدعاء الوظيفة لحفظ الموارد إذا لم تكن هناك حاجة إلى التحليل!  هذه التقنية نادرة جدًا ، لأنها تتطلب كتابة شفرة غير تافهة ، ولكنها تعطي نتيجة إيجابية. <br><br><h2 style=";text-align:right;direction:rtl">  تحديد حجم المجموعة الأولي </h2><br>  هذا ينطبق على CPython C API. <br><br>  عند إنشاء مجموعات ، مثل القوائم أو القواميس ، استخدم <code>PyList_New()</code> + <code>PyList_SET_ITEM()</code> لتعبئة مجموعة جديدة إذا كان حجمها محددًا بالفعل وقت الإنشاء.  سيؤدي هذا إلى تحديد حجم المجموعة مسبقًا ليتمكن من الاحتفاظ بعدد محدود من العناصر فيه.  هذا يساعد على تخطي التحقق من حجم مجموعة كافية عند إدراج العناصر.  عند إنشاء مجموعة من آلاف العناصر ، سيوفر لك ذلك بعض الموارد! <br><br><h2 style=";text-align:right;direction:rtl">  باستخدام الصفر نسخة في C API </h2><br>  يحب Python C API حقًا إنشاء نسخ من الكائنات بدلاً من إرجاع المراجع إليها.  على سبيل المثال ، <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ينسخ PyBytes_FromStringAndSize ()</a></i> <code>char*</code> في الذاكرة المحجوزة بواسطة Python.  إذا قمت بذلك لعدد كبير من القيم أو البيانات الكبيرة ، فيمكننا الحديث عن غيغابايت من الذاكرة I / O والتحميل المقترن على المخصص. <br><br>  إذا كنت بحاجة إلى كتابة <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تعليمات</a></i> برمجية عالية الأداء بدون واجهة برمجة تطبيقات C ، فيجب عليك التعرف على <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بروتوكول التخزين المؤقت</a></i> والأنواع ذات الصلة ، مثل <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">memoryview</a> .</i> <br><br>  <code>Buffer protocol</code> مضمّن في أنواع Python ويسمح للمترجمين الفوريين بإلقاء الكتابة من / إلى البايتات.  كما يسمح لمترجم الشفرة C باستلام واصف <code>void*</code> فارغ بحجم معين.  هذا يسمح لك بربط أي عنوان في الذاكرة مع PyObject.  تقبل العديد من الوظائف التي تعمل مع البيانات الثنائية بشفافية أي كائن يقوم بتنفيذ <code>buffer protocol</code> .  وإذا كنت تريد قبول أي كائن يمكن اعتباره بايتًا ، فأنت بحاجة إلى استخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وحدات من تنسيق</a> <code>s*</code> أو <code>y*</code> أو <code>w*</code> عند تلقي وسيطات دالة. <br><br>  باستخدام <code>buffer protocol</code> ، فإنك تعطي المترجم أفضل فرصة متاحة لاستخدام عمليات <code>zero-copy</code> وترفض نسخ وحدات البايت الإضافية إلى الذاكرة. <br><br>  باستخدام الأنواع الموجودة في Python من <code>memoryview</code> النموذج ، ستسمح أيضًا لـ Python بالوصول إلى مستويات الذاكرة حسب المرجع ، بدلاً من عمل نُسخ. <br><br>  إذا كان لديك غيغا بايت من التعليمات البرمجية التي تمر عبر برنامج Python ، فإن الاستخدام الثاقب لأنواع Python التي تدعم النسخة الصفرية سيوفر لك من اختلافات الأداء.  لقد لاحظت ذات مرة أن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">python-zstandard</a> تبين أنها أسرع من أي ارتباطات لبيثون LZ4 (على الرغم من أنه ينبغي أن يكون العكس) ، لأنني كنت أستخدم <code>buffer protocol</code> كثيرًا وتجنب الذاكرة المفرطة I / O في <code>python-zstandard</code> ! <br><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br>  في هذا المقال ، سعيت للحديث عن بعض الأشياء التي تعلمتها أثناء تحسين برامج بيثون الخاصة بي لعدة سنوات.  أكرر وأقول إنها ليست نظرة شاملة على طرق تحسين أداء بايثون.  أعترف أنني ربما أستخدم Python أكثر طلبًا من غيرها ، ولا يمكن تطبيق توصياتي على جميع البرامج.  <b>يجب ألا تصحح رمز Python الخاص بك على نطاق واسع وأن تزيل ، على سبيل المثال ، البحث عن السمات بعد قراءة هذه المقالة</b> .  كما هو الحال دائمًا ، عندما يتعلق الأمر بتحسين الأداء ، قم أولاً بإصلاح حيث يكون الرمز بطيئًا بشكل خاص.    <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">py-spy</a></i>     Python.   ,     ,      Python,       .  ,        ,         ,     ! <br><br> ,          Python    . ,       ,  Python           -  .     Python   –     PyPy,        .  Python      .    ,     Python  ,     .      ,          «  ».   ,   ,     ,    Python,   ,    ,      . <br><br>       ;-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar457942/">https://habr.com/ru/post/ar457942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar457928/index.html">الترتيب العميق لمقارنة صورتين</a></li>
<li><a href="../ar457930/index.html">ثابت ديناميكي كتابة à la بيثون</a></li>
<li><a href="../ar457932/index.html">تحليل مسابقة IDS Bypass في الايجابية Hack Days 9</a></li>
<li><a href="../ar457936/index.html">نحن ندعوك لحضور مؤتمر Zabbix الأول في روسيا</a></li>
<li><a href="../ar457940/index.html">كيفية النظير في الطرف المقابل</a></li>
<li><a href="../ar457946/index.html">أفضل 10 مكتبات JavaScript لتصور البيانات على الرسوم البيانية والمخططات</a></li>
<li><a href="../ar457948/index.html">ألعاب الطاولة التي عليك تحطيم رأسك بها</a></li>
<li><a href="../ar457952/index.html">كيف يتم تصميم وتصنيع المعالجات: تصنيع الرقاقات</a></li>
<li><a href="../ar457954/index.html">لماذا سويفت يمكن أن تصبح حدث كبير في التعلم العميق</a></li>
<li><a href="../ar457956/index.html">كيفية اختيار التخزين دون اطلاق النار على نفسك في القدم</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>