<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏻 ✅ 🆑 Bagaimana mesin berkomunikasi - protokol MQTT 👨🏼‍🎓 👂🏻 🐦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, kami melihat protokol Modbus , yang merupakan standar industri de facto untuk interaksi M2M . Dikembangkan kembali pada tahu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana mesin berkomunikasi - protokol MQTT</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/advantech/blog/452904/"><div style="text-align:center;"><img width="400" src="https://habrastorage.org/webt/nb/fv/om/nbfvom_zwqoyqg4e4bcxwl1ax7a.png"></div><br>  Dalam artikel sebelumnya, kami melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol Modbus</a> , yang merupakan standar industri de facto untuk interaksi <abbr title="Mesin ke mesin">M2M</abbr> .  Dikembangkan kembali pada tahun 1979, ia memiliki sejumlah kelemahan signifikan yang diselesaikan MQTT. <br><br>  Protokol MQTT cukup muda (hanya standar pada tahun 2016), tetapi telah berhasil digunakan secara luas di industri dan IoT.  Itu dirancang khusus untuk menjadi sekompak mungkin, untuk saluran internet yang tidak stabil dan perangkat berdaya rendah, dan memungkinkan Anda untuk menjamin pengiriman pesan jika terjadi kehilangan dan terputusnya paket. <br><br>  Fitur Utama dari Protokol MQTT: <br><br><ul><li>  <b>Ringkas dan ringan</b> - overhead transfer data minimal untuk menghemat lalu lintas. </li><li>  <b>Resistansi terhadap kerugian</b> - pengiriman yang terjamin dalam kondisi koneksi jaringan yang tidak stabil. </li><li>  <b>Asynchronous</b> - memungkinkan Anda untuk melayani sejumlah besar perangkat, dan tidak bergantung pada penundaan jaringan. </li><li>  <b>Dukungan QoS</b> - kemampuan untuk mengontrol prioritas pesan dan menjamin pengiriman pesan kepada penerima. </li><li>  <b>Konfigurasi dinamis</b> - tidak memerlukan koordinasi bidang dan format data sebelumnya, dapat dikonfigurasi dengan cepat. </li><li>  <b>Bekerja untuk NAT</b> - klien dapat berada di belakang NAT, hanya server (broker) yang harus memiliki IP asli.  Memungkinkan Anda melakukannya tanpa VPN dan penerusan porta. </li><li>  <b>Pengalamatan nyaman</b> - bidang data memiliki nama teks yang dapat dimengerti oleh manusia.  Tidak perlu mengingat alamat digital dan bit offset. </li></ul><a name="habracut"></a><br>  Dalam artikel ini, kita akan membandingkan MQTT dan Modbus, menganalisis struktur protokol, konsep dasar, dan mencoba menggunakan broker cloud MQTT sebagai contoh dalam koneksi Internet yang tidak stabil. <br><br><h2>  Sejarah Protokol MQTT </h2><br>  MQTT dikembangkan oleh IBM pada tahun 1999, dan pada awalnya digunakan secara internal untuk solusinya. <br><br>  Pada bulan November 2011, IBM dan Eurotech mengumumkan partisipasi mereka dalam kelompok kerja Eclipse M2M dan transfer kode MQTT ke proyek Eclipse Paho. <br><br>  Pada 2013, konsorsium <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OASIS</a> (Organisasi untuk Peningkatan Standar Informasi Terstruktur) memulai proses standarisasi protokol MQTT.  Hingga saat ini, spesifikasi protokol telah diterbitkan di bawah lisensi gratis, dan perusahaan seperti Eurotech (sebelumnya dikenal sebagai Arcom) sudah menggunakan protokol dalam produk mereka. <br><br>  Pada Oktober 2014, OASIS menerbitkan standar protokol MQTT resmi pertama. <br><br>  Pada 2016, protokol ini distandarisasi oleh Organisasi Internasional untuk Standardisasi ISO dan menerima nomor ISO / IEC 20922. <br><br>  Sejak 2014, minat pada protokol mulai tumbuh pesat dan, dilihat dari jadwal Google Trends, hari ini melebihi minat di Modbus. <br><br><img src="https://habrastorage.org/webt/ia/6q/cw/ia6qcwyvn9p6yi_10xrdgkwbcqu.png"><br>  <font color="999999">Benchmark Google Trends</font> <br><br><h2>  Konsep dasar </h2><br>  MQTT memiliki arsitektur client-server.  Pesan berlangsung melalui server pusat yang disebut broker.  Dalam kondisi normal, klien tidak dapat berkomunikasi secara langsung satu sama lain, dan semua pertukaran data terjadi melalui broker. <br><br>  Klien dapat bertindak sebagai penyedia data (Penerbit) dan sebagai penerima data (Pelanggan).  Dalam terjemahan Rusia, istilah-istilah ini sering diterjemahkan sebagai penerbit dan pelanggan, tetapi untuk menghindari kebingungan, kami hanya akan menggunakan terminologi aslinya. <br><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/webt/ex/ri/7r/exri7rw8067vln4jiqq5ma9dine.png"></div><br>  <font color="999999">Dalam protokol MQTT, klien berkomunikasi satu sama lain melalui simpul pusat</font> <br><br>  Pada tingkat aplikasi, protokol berjalan di atas TCP / IP dan dapat dengan mudah menghubungkan objek jarak jauh langsung melalui Internet, tanpa perlu terowongan VPN.  Cukup bagi broker untuk memiliki alamat IP asli dan semua klien dapat terhubung dengannya.  Dalam hal ini, klien dapat ditempatkan di belakang NAT.  Karena klien memulai koneksi dalam protokol MQTT, port forwarding tidak diperlukan untuk membuat koneksi, sedangkan di Modbus / TCP server memulai koneksi (master), yang memerlukan akses jaringan langsung. <br><br>  Port broker MQTT standar untuk koneksi TCP yang masuk adalah <b>1883</b> .  Saat menggunakan koneksi SSL aman, port <b>8883 digunakan</b> . <br><br><h4>  Pialang </h4><br>  Pialang adalah pusat MQTT pusat untuk interaksi pelanggan.  Pertukaran data antar klien hanya terjadi melalui broker.  Broker dapat berupa perangkat lunak server atau pengontrol.  Tugasnya termasuk menerima data dari pelanggan, memproses dan menyimpan data, mengirimkan data ke pelanggan, dan memantau pengiriman pesan. <br><br><h4>  Penerbit / Pelanggan </h4><br>  Untuk memahami perbedaan antara Penerbit dan Pelanggan, mari kita ambil contoh sederhana: sensor kelembaban mengukur kelembaban di suatu ruangan, dan jika turun di bawah tingkat tertentu, humidifier menyala. <br><br>  Dalam hal ini, sensor kelembaban bertindak sebagai <b>Penerbit</b> : tugasnya adalah hanya mempublikasikan data ke broker.  Humidifier bertindak sebagai <b>Pelanggan</b> : berlangganan pembaruan data kelembaban dan menerima data saat ini dari broker, sementara humidifier dapat memutuskan pada titik mana untuk mengaktifkan pelembapan. <br><br>  Dalam skema ini, klien MQTT, yaitu sensor dan pelembab udara, tidak mengetahui keberadaan satu sama lain, dan tidak berinteraksi secara langsung.  Pialang dapat menerima data dari berbagai sumber, memanipulasi mereka, misalnya, menghitung nilai rata-rata dari beberapa sensor, dan mengembalikan data yang diproses ke pelanggan. <br><br><img src="https://habrastorage.org/webt/xc/pb/t8/xcpbt8th_jxzdzfglqwxt4wnpwo.png"><br>  <font color="9999999">Penerbit mengirimkan data ke broker, Pelanggan berlangganan pembaruan data ini</font> <br><br>  Pada saat yang sama, protokol sinkronisasi MQTT menyatakan bahwa sensor dan pelembab dapat online pada waktu yang berbeda, kehilangan paket, dan tidak dapat diakses.  Broker akan mengurus penyimpanan data terakhir yang diterima dari sensor dalam memori dan memastikan pengirimannya ke humidifier. <br><br><h4>  Topik </h4><br>  MQTT menggunakan topik untuk mengidentifikasi entitas, dalam terjemahan Rusia mereka juga disebut saluran.  Topik terdiri dari karakter UTF8, dan memiliki struktur struktur pohon yang mirip dengan sistem file UNIX.  Ini adalah mekanisme yang mudah untuk penamaan entitas dalam bentuk yang dapat dibaca manusia. <br><br>  Contoh topik di MQTT <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#     home/kitchen/temperature #     home/sleeping-room/temperature #     home/outdoor/light</span></span></code> </pre> <br>  Pendekatan ini memungkinkan Anda untuk melihat secara visual data apa yang dikirimkan, dan akan lebih mudah untuk mengembangkan dan men-debug kode tanpa harus mengingat alamat digital dari penempatan data, seperti yang dilakukan di Modbus. <br><br>  Topik juga menyertakan sintaksis wildcard, yang biasa bagi mereka yang telah bekerja dengan sistem file UNIX.  Wildcard dapat berupa level tunggal dan multi level. <br><br>  Wildcard satu tingkat ditandai dengan tanda <b>+</b> . <br><br>  Misalnya, untuk menerima data dari sensor suhu di semua kamar di rumah, pelanggan harus berlangganan ke topik seperti itu: <br><br><pre> <code class="plaintext hljs">home/+/temperature</code> </pre><br>  Akibatnya, ia akan berlangganan untuk menerima data dari sensor tersebut: <br><br><pre> <code class="plaintext hljs">home/kitchen/temperature home/sleeping-room/temperature home/living-room/temperature home/outdoor/temperature</code> </pre><br>  Wildcard multi-level ditandai dengan simbol " <b>#</b> ". <br>  Contoh memperoleh data dari semua sensor di semua kamar di rumah: <br><br><pre> <code class="plaintext hljs">home/#</code> </pre><br>  Berlangganan topik semacam itu akan memungkinkan Anda menerima data dari sensor tersebut: <br><br><pre> <code class="plaintext hljs">home/kitchen/temperature home/kitchen/humidity home/kitchen/light home/sleeping-room/temperature home/sleeping-room/humidity home/sleeping-room/light ....</code> </pre><br><h3>  Identifikasi pelanggan </h3><br>  Untuk kontrol akses, MQTT menyediakan otentikasi klien, tidak seperti protokol Modbus, yang tidak memiliki fungsi seperti itu.  Bidang-bidang berikut digunakan untuk kontrol akses: <br><br>  <b>ClientId</b> - (bidang wajib diisi) pengidentifikasi unik klien.  Harus unik untuk setiap pelanggan.  Versi MQTT 3.1.1 standar saat ini memungkinkan Anda untuk menggunakan bidang ClientId kosong jika Anda tidak perlu menyimpan status koneksi. <br><br>  <b>Nama pengguna</b> - login (bidang opsional) untuk otentikasi, dalam format UTF-8.  Mungkin tidak unik.  Misalnya, sekelompok klien dapat masuk dengan nama pengguna / kata sandi yang sama. <br><br>  <b>Kata sandi</b> - (bidang opsional) hanya dapat dikirim bersama dengan bidang Nama Pengguna, sementara Nama Pengguna dapat dikirim tanpa bidang Kata Sandi.  Maksimal 65535 byte.  Penting untuk mengetahui bahwa nama dan kata sandi ditransmisikan secara jelas, oleh karena itu, jika data ditransmisikan melalui jaringan publik, Anda harus menggunakan SSL untuk mengenkripsi koneksi. <br><br><h3>  Struktur paket </h3><br>  Seperti disebutkan di atas, dalam protokol MQTT, klien selalu melakukan koneksi, terlepas dari apakah mereka penerima (Pelanggan) atau pemasok (Penerbit) data.  Kami akan menganalisis paket dengan koneksi yang disadap menggunakan program Wireshark. <br><br><img src="https://habrastorage.org/webt/ep/0t/hv/ep0thv6e3zsvyzgizw89gpxgytg.png"><br>  <font color="999999">Paket MQTT ditransmisikan melalui saluran yang tidak dienkripsi</font> <br><br>  Header TCP menunjukkan bahwa paket itu dikirim pada port 1883, yaitu, enkripsi tidak digunakan, yang berarti bahwa semua data tersedia dalam bentuk yang jelas, termasuk login dan kata sandi. <br><br><h4>  Berita utama </h4><br>  <b>Jenis pesan</b> adalah Connect (perintah 0x0001), membuat koneksi dengan broker.  Tim utama: Hubungkan, Putuskan Koneksi, Publikasikan, Berlangganan, Berhenti Berlangganan.  Ada juga perintah pengakuan, tetap hidup, dll. <br><br>  <b>Tandai DUP</b> - berarti pesan dikirim ulang, hanya digunakan dalam jenis pesan PUBLISH, SUBSCRIBE, UNSUBSCRIBE, PUBREL, untuk kasus-kasus ketika pialang tidak menerima konfirmasi tanda terima pesan sebelumnya. <br>  <b>Level QoS</b> - bendera Kualitas Layanan.  Kami akan membahas topik ini lebih terinci nanti. <br>  <b>Retain</b> - data yang diterbitkan dengan bendera retain disimpan di broker.  Setelah berlangganan ke topik ini, broker akan segera mengirim pesan dengan bendera ini.  Hanya digunakan dalam pesan tipe Publikasikan. <br><br><h2>  Penggunaan praktis </h2><br><img width="100" src="https://habrastorage.org/webt/v9/m9/2k/v9m92kvqrkibu8zt9pfsdjkngg8.png"><br><br>  Sekarang, setelah memahami teori ini, mari kita coba bekerja sama dengan MQTT dalam praktiknya.  Untuk ini, kami akan menggunakan program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mosquitto</a> terbuka, yang dapat bekerja baik dalam mode klien dan dalam mode server (broker).  Ini bekerja pada Windows, macOS, Linux.  Program ini sangat nyaman untuk debugging dan mempelajari protokol MQTT, sementara itu juga banyak digunakan dalam operasi industri.  Kami akan menggunakannya sebagai klien untuk mengirim dan menerima data dari broker cloud jarak jauh. <br><br>  Banyak penyedia cloud menyediakan layanan broker MQTT, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Azure IoT Hub</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amazon AWS IoT</a> , dan lainnya.  Dalam contoh ini, kami akan menggunakan layanan Cloudmqtt.com, karena ia memiliki pendaftaran paling sederhana, dan tarif gratis sudah cukup untuk pelatihan. <br><br>  Setelah pendaftaran, detail untuk menghubungkan ke broker tersedia di akun Anda.  Karena kami terhubung ke server melalui jaringan Internet publik, masuk akal untuk menggunakan port SSL untuk mengenkripsi lalu lintas. <br><br><img src="https://habrastorage.org/webt/gh/rq/t5/ghrqt5ady8x8twccmfrtngm-htu.png"><br>  <font color="999999">Rincian akses pialang MQTT di akun pribadi penyedia cloud</font> <br><br>  Fleksibilitas protokol MQTT memungkinkan klien untuk mentransfer data yang sebelumnya tidak ditentukan pada broker.  Artinya, tidak perlu membuat pra-topik yang diperlukan di mana Penerbit dapat menulis data.  Dengan menggunakan data yang diterima dari akun pribadi Anda, kami akan mencoba menyusun permintaan untuk menerbitkan data secara manual ke topik <i>habr / test / acak</i> dan membaca darinya. <br><br>  <b>mosquitto_sub</b> - utilitas klien pelanggan <br>  <b>mosquitto_pub</b> - utilitas klien penerbit <br><br>  Pertama, terhubung ke broker sebagai pelanggan, dan berlangganan untuk menerima data dari topik <br>  <i>habr / test / acak</i> . <br><br><pre> <code class="plaintext hljs">mosquitto_sub -d --capath /etc/ssl/certs/ --url mqtts://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random Client mosq/zEPZz0glUiR4aEipZA sending CONNECT Client mosq/zEPZz0glUiR4aEipZA received CONNACK (0) Client mosq/zEPZz0glUiR4aEipZA sending SUBSCRIBE (Mid: 1, Topic: habr/test/random, QoS: 0, Options: 0x00) Client mosq/zEPZz0glUiR4aEipZA received SUBACK</code> </pre><br>  Dapat dilihat bahwa koneksi berhasil, dan kami berlangganan ke <b>topik habr / test / random</b> , dan sekarang kami sedang menunggu data dalam topik ini dari broker. <br><blockquote>  Karena koneksi SSL digunakan, untuk memverifikasi sertifikat, Anda harus menentukan jalur di mana program akan mencari sertifikat enkripsi root.  Karena layanan dalam contoh kami menggunakan sertifikat yang dikeluarkan oleh otoritas sertifikasi tepercaya, kami menunjukkan jalur ke penyimpanan sistem untuk sertifikat root: <i><b>--capath / etc / ssl / certs /</b></i> <br><br>  Dalam hal sertifikat yang ditandatangani sendiri, Anda harus menentukan jalur ke CA yang diinginkan.  Penting juga untuk mempertimbangkan perbedaan dalam format URI untuk koneksi SSL - mqtt <b>s</b> : //, dan koneksi non-terenkripsi - mqtt: //.  Jika terjadi kesalahan verifikasi sertifikat, program berakhir tanpa pesan kesalahan.  Untuk keluaran yang lebih terperinci, Anda dapat menggunakan sakelar --debug </blockquote>  Sekarang mari kita coba mempublikasikan data dalam topik tanpa mengganggu program pertama. <br><br><pre> <code class="plaintext hljs">mosquitto_pub -d --capath /etc/ssl/certs/ --url mqtt://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random -m " !" Client mosq/sWjh9gf8DRASrRZjk6 sending CONNECT Client mosq/sWjh9gf8DRASrRZjk6 received CONNACK (0) Client mosq/sWjh9gf8DRASrRZjk6 sending PUBLISH (d0, q0, r0, m1, 'habr/test/random', ... (22 bytes)) Client mosq/sWjh9gf8DRASrRZjk6 sending DISCONNECT</code> </pre><br>  Dapat dilihat bahwa data berhasil diterima oleh server dan dipublikasikan dalam topik yang diinginkan.  Pada saat yang sama, di jendela pertama di mana program mosquitto_sub berjalan, kita melihat bagaimana pesan itu diterima, bahkan Unicode berfungsi, pesannya dalam bahasa Rusia. <br><br><pre> <code class="plaintext hljs">Client mosq/zEPZz0glUiR4aEipZA received PUBLISH (d0, q0, r0, m0, 'habr/test/random', ... (22 bytes))  !</code> </pre><br><h2>  QoS dan jaminan pengiriman </h2><br>  Namun, mengirim pesan secara real time tidak akan mengejutkan siapa pun, karena hal yang sama dapat dilakukan bahkan dengan utilitas dangkal <b>nc</b> .  Oleh karena itu, kami akan mencoba mensimulasikan koneksi yang tidak stabil antara pelanggan dan pengirim.  Bayangkan kedua klien bekerja melalui GPRS, dengan paket yang sangat besar, dan bahkan koneksi TCP yang sukses jarang terjadi, dan Anda perlu memastikan bahwa pelanggan dijamin untuk menerima pesan pengirim.  Dalam hal ini, opsi QoS datang untuk menyelamatkan. <br><br>  Secara default, bendera <b>QoS</b> diatur <b>ke 0</b> untuk pesan, yang berarti “Api dan lupakan”: Penerbit mempublikasikan pesan pada broker, tetapi tidak mengharuskan pesan tersebut dijamin untuk dikirim ke pelanggan.  Ini cocok untuk data yang kehilangannya tidak kritis, misalnya, untuk pengukuran kelembaban atau suhu secara teratur. <br><br>  <b>QoS 1: Setidaknya sekali - setidaknya satu</b> .  Bendera ini berarti bahwa sampai Penerbit menerima konfirmasi pengiriman kepada pelanggan, publikasi ini akan dikirim ke broker, dan kemudian ke pelanggan.  Dengan demikian, pelanggan harus menerima pesan ini setidaknya sekali. <br><br>  <b>QoS 2: Persis sekali - dijamin</b> .  Bendera QoS, yang memberikan jaminan tertinggi pengiriman pesan melalui penggunaan prosedur tambahan untuk konfirmasi dan penyelesaian publikasi (PUBREC, PUBREL, PUBCOMP).  Berlaku untuk situasi di mana perlu untuk mengecualikan kehilangan dan duplikasi data dari sensor.  Misalnya, ketika alarm dipicu dari pesan yang diterima, panggilan darurat dilakukan. <br><br>  Untuk mensimulasikan komunikasi yang buruk, matikan kedua klien dan cobalah untuk mengirim pesan dengan prioritas QoS tertinggi, dan juga tambahkan opsi Retain sehingga pesan yang terkirim disimpan di broker. <br><br><pre> <code class="plaintext hljs">mosquitto_pub --retain --qos 2 -d --capath /etc/ssl/certs/ --url mqtt://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random -m "  !" Client mosq/Xwhua3GAyyY9mMd05V sending CONNECT Client mosq/Xwhua3GAyyY9mMd05V received CONNACK (0) Client mosq/Xwhua3GAyyY9mMd05V sending PUBLISH (d0, q2, r1, m1, 'habr/test/random', ... (37 bytes)) Client mosq/Xwhua3GAyyY9mMd05V received PUBREC (Mid: 1) Client mosq/Xwhua3GAyyY9mMd05V sending PUBREL (m1) Client mosq/Xwhua3GAyyY9mMd05V received PUBCOMP (Mid: 1, RC:0) Client mosq/Xwhua3GAyyY9mMd05V sending DISCONNECT</code> </pre><br>  Sekarang, setelah beberapa waktu, penerima kami akhirnya dapat membuat koneksi ke Internet dan terhubung ke broker: <br><br><pre> <code class="plaintext hljs">mosquitto_sub -d --capath /etc/ssl/certs/ -d --url mqtts://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random Client mosq/VAzcLVMB1MiWhYxoJS sending CONNECT Client mosq/VAzcLVMB1MiWhYxoJS received CONNACK (0) Client mosq/VAzcLVMB1MiWhYxoJS sending SUBSCRIBE (Mid: 1, Topic: habr/test/random, QoS: 0, Options: 0x00) Client mosq/VAzcLVMB1MiWhYxoJS received SUBACK Subscribed (mid: 1): 0 Client mosq/r6UwPnDvx8aNInpPF6 received PUBLISH (d0, q0, r1, m0, 'habr/test/random', ... (37 bytes))   !</code> </pre><br><h2>  Kesimpulan </h2><br>  MQTT adalah protokol modern dan canggih, tanpa banyak kelemahan dari pendahulunya.  Fleksibilitasnya memungkinkan Anda untuk menambah perangkat klien tanpa membuat broker, yang secara signifikan menghemat waktu.  Ambang entri untuk memahami dan mengkonfigurasi protokol sangat rendah, dan keberadaan perpustakaan untuk banyak bahasa pemrograman memungkinkan Anda memilih tumpukan teknologi untuk pengembangan.  Jaminan pengiriman pesan secara signifikan membedakan MQTT dari pendahulunya, dan memungkinkan Anda untuk tidak membuang waktu mengembangkan mekanisme kontrol integritas Anda sendiri di tingkat jaringan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452904/">https://habr.com/ru/post/id452904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452890/index.html">23 Mei 18:30 - siaran langsung QIWI Kitchen</a></li>
<li><a href="../id452892/index.html">Bagaimana cara non-programmer pindah ke AS: petunjuk langkah demi langkah</a></li>
<li><a href="../id452894/index.html">Face Anti-Spoofing atau secara teknis mengenali penipu dari seribu wajah</a></li>
<li><a href="../id452900/index.html">Indeks dalam PostgreSQL - 9 (BRIN)</a></li>
<li><a href="../id452902/index.html">Menyelesaikan pelatihan 4 tahun sebagai programmer, saya mengerti bahwa saya jauh dari seorang programmer</a></li>
<li><a href="../id452906/index.html">Mesin JavaScript: bagaimana cara kerjanya? Dari tumpukan panggilan ke janji-janji, (hampir) semua yang perlu Anda ketahui</a></li>
<li><a href="../id452908/index.html">Selenium WebDriver - Metrik uji waktu-nyata menggunakan Grafana dan InfluxDB</a></li>
<li><a href="../id452910/index.html">Halo, Habr! Halo Tercon</a></li>
<li><a href="../id452914/index.html">ML di Scala dengan senyum, untuk mereka yang tidak takut bereksperimen</a></li>
<li><a href="../id452916/index.html">Bangun dan pergi. Operasi tulang belakang: kapan harus melakukan, apa yang berbahaya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>