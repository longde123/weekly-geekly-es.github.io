<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🌾 👨🏾‍🚒 🤽🏿 Tes atau tipe 🙋 🦏 🤰🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, Habr. Suatu hari saya sedang mencari cara melakukan sesuatu di Idris, dan menemukan posting yang bagus, terjemahan gratis yang sepertinya cukup s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes atau tipe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467677/"><p>  <em>Hai, Habr.</em>  <em>Suatu hari saya sedang mencari cara melakukan sesuatu di Idris, dan menemukan posting yang bagus, terjemahan gratis yang sepertinya cukup sesuai.</em>  <em>Kebebasan dan lelucon jika perlu, saya akan tunjukkan "di sini oleh coretan seperti di awal dan di akhir".</em> </p><br><p>  Kapan menggunakan tes, dan kapan - mengetik?  Informasi apa dan jaminan apa yang kami terima sebagai imbalan atas upaya kami untuk menuliskannya? </p><br><p>  Kita akan melihat contoh sederhana dan sedikit dibuat-buat diekspresikan dalam Python, C, Haskell, dan Idris.  Kami juga akan melihat apa yang bisa dikatakan tentang implementasi tanpa pengetahuan tambahan tentang hal itu, dalam setiap kasus. </p><br><p> Kami tidak akan mempertimbangkan berbagai pintu belakang yang memungkinkan kami untuk secara eksplisit melanggar jaminan bahasa (misalnya, ekstensi C, <code>unsafePerformIO</code> di Haskell, konversi jenis tidak aman), jika tidak, tidak mungkin untuk menarik kesimpulan sama sekali, dan posting ini akan cukup singkat.  ⟦Selain itu, Haskell yang sama memiliki subset Safe Haskell yang secara eksplisit dan transitif melarang penggunaannya dan sejumlah trik lain yang dapat melanggar integritas bahasa.⟧ </p><a name="habracut"></a><br><h2>  Spesifikasi </h2><br><blockquote>  Biarkan daftar dan beberapa makna diberikan.  Diperlukan untuk mengembalikan indeks nilai ini dalam daftar atau menunjukkan bahwa nilai ini tidak ada dalam daftar. </blockquote><p>  Implementasi spesifikasi ini sepele, jadi wajar untuk bertanya, dan di sini umumnya tes atau tipe.  Namun, sifat dan metode penalaran tersebut, yang akan kita bicarakan hari ini, dapat diterapkan pada kode yang jauh lebih kompleks.  Biarkan implementasinya mengambil sepuluh ribu baris kode spaghetti yang tidak dapat dibaca, jika itu membantu untuk melihat kegunaannya. </p><br><h2>  Python </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y, z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 10000   </span></span></code> </pre> <br><p>  Kami segera mencatat bahwa kami tidak tertarik pada ⟦dan semantik yang tidak dicentang - tidak memengaruhi properti program seperti penamaan variabel dan dokumentasi teks, jadi saya sengaja tidak menulis kode yang membantu persepsi.  Kami hanya tertarik pada kenyataan bahwa, setelah lulus tes dan mengetik cek, <em>itu tidak bisa salah</em> . </p><br><p>  Dalam kode di atas, praktis tidak ada informasi berguna selain fakta bahwa kita memiliki fungsi yang mengambil dua argumen.  Fungsi ini sama-sama dapat menemukan indeks nilai dalam daftar, atau dapat mengirim surat penghinaan kepada nenek Anda. </p><br><p>  <strong>Analisis</strong> </p><br><p>  Kita tidak hanya mendapatkan kode yang rapuh tanpa tes dan jenis, tetapi satu-satunya cara kita untuk memahami apa fungsi yang dilakukan adalah dokumentasi.  Dan karena dokumentasi diperiksa oleh orang-orang, bukan oleh mesin, dapat dengan mudah berubah menjadi usang atau "awalnya tidak benar". </p><br><ul><li>  <strong>Dokumentasi</strong> <br><ul><li>  ✗ Kita tahu perilaku yang diharapkan <br>  Kami tidak memiliki apa pun untuk memberi tahu kami tentang perilaku fungsi ini.  Kamu membenci nenekmu.  Kamu adalah monster. </li></ul></li><li>  <strong>Garansi</strong> <br><ul><li>  ✓ Keamanan Memori <br>  Python adalah bahasa pengumpulan sampah yang menghilangkan masalah ini dari kami.  ⟦Namun, sejauh yang saya tahu, tidak ada yang mencegah Anda menarik perpustakaan yang tidak aman atau C FFI di dalam fungsi ini.⟧ </li></ul></li></ul><br><h2>  Python dengan tes </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_happy_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_missing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Sekarang kita tahu bahwa fungsi kita berfungsi, dan jika elemennya hilang, hasilnya adalah <code>None</code> ? </p><br><p>  Ya ... tidak.  Ini hanya satu contoh.  Sayangnya, ruang lingkup fungsi kami tidak terbatas, dan tidak ada jumlah contoh yang dapat membuktikan operasi fungsi kami yang benar.  Lebih banyak tes - lebih percaya diri, tetapi tidak ada jumlah tes yang akan menyelesaikan semua keraguan. </p><br><p>  Kemungkinan bahwa fungsi ini akan mengembalikan <code>None</code> untuk <code>4</code> , tetapi tidak untuk <code>5</code> , kedengarannya agak delusi, dan dalam kasus khusus ini kemungkinan besar adalah omong kosong.  Kita dapat puas dengan tingkat iman kita dan memikirkan sejumlah contoh tertentu.  Tetapi sekali lagi, maka posting akan pendek, jadi mari kita bayangkan bahwa implementasinya tidak begitu jelas. </p><br><p>  Karena tes tidak dapat membuktikan sesuatu dalam kasus umum, tetapi hanya menunjukkan perilaku dengan contoh spesifik, tes <em>tidak dapat</em> menunjukkan <em>tidak</em> adanya kesalahan.  Misalnya, tidak ada tes yang akan menunjukkan bahwa fungsi kita tidak pernah melempar pengecualian atau tidak pernah memasuki siklus abadi, atau tidak mengandung tautan yang tidak valid.  Ini hanya bisa menjadi analisis statis. </p><br><p>  Namun, bahkan jika contoh-contohnya tidak terlalu bagus dalam peran bukti, mereka setidaknya merupakan dokumentasi yang baik.  Dari dua contoh ini kita dapat memperoleh spesifikasi lengkap ⟦di bawah beberapa asumsi a priori tambahan - dua contoh tersebut juga memenuhi, misalnya, "counterspec" "menemukan elemen dalam array dan mengembalikan yang sebelumnya, jika ada", yang membutuhkan waktu sepuluh detik untuk saya ciptakan . </p><br><p>  <strong>Analisis</strong> </p><br><p>  Meskipun pengujian dapat menunjukkan cara menggunakan fungsi kami, dan juga memberikan sedikit kepercayaan diri bahwa fungsi ini bekerja dengan benar dengan setidaknya beberapa contoh, mereka tidak dapat <em>membuktikan</em> apa pun tentang kode kami dalam kasus umum.  Sayangnya, ini berarti bahwa pengujian hanya membantu sebagian untuk menghindari kesalahan. </p><br><ul><li>  <strong>Dokumentasi</strong> <br><ul><li>  ✓ <strong>Kami memiliki contoh penggunaan</strong> </li><li>  ✓ <strong>Kami tahu beberapa kelas nilai yang akan diproses dengan benar</strong> </li><li>  ✗ Kami tahu semua jenis nilai yang akan diproses dengan benar <br>  Kami tidak memiliki batasan pada jenis argumen, jadi meskipun ada contoh dari apa fungsi dapat menangani, kami tidak tahu jenis mana yang belum diuji. </li><li>  ✗ Kita tahu perilaku yang diharapkan <br>  ⟦Penulis artikel asli dicentang di sini, saya akan membiarkan diri saya membuat tanda salib, memberikan komentar di atas⟧ </li></ul></li><li>  <strong>Spesifikasi</strong> <br><ul><li>  ✓ <strong>Bekerja di setidaknya satu kasing</strong> </li><li>  ✗ Indeks yang dikembalikan selalu merupakan indeks yang valid </li><li>  ✗ Indeks yang dikembalikan selalu menunjukkan nilai yang sesuai </li><li>  ✗ Barang yang hilang selalu kembali <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Kesalahan umum</strong> <br><ul><li>  ✗ Tidak ada kesalahan ketik atau nama yang salah <br>  Analisis statis dapat membantu, tetapi karena Python adalah bahasa yang dinamis dengan kemampuan untuk menimpa berbagai hal saat runtime, kami tidak pernah dapat membuktikan bahwa tidak ada kesalahan. <br>  Secara khusus, bisa sangat sulit atau tidak mungkin untuk menentukan apakah nama metode sudah benar, karena validitas pemanggilan metode tergantung pada tipe runtime dari objek tempat pemanggilan dilakukan. </li><li>  ✗ Tidak ada <code>null</code> tidak terduga </li><li>  ✗ Kasing kesalahan selalu ditangani <br>  Dalam pengalaman saya, ini adalah salah satu sumber kesalahan yang paling umum: dalam contoh kami, fungsi mengembalikan <code>None</code> dalam kasus elemen yang hilang, tetapi kode yang menggunakan fungsi ini dapat mengasumsikan, misalnya, bahwa ia akan selalu mengembalikan angka.  Selain itu, ini juga dapat menyebabkan pengecualian yang tidak tertangani. </li></ul></li><li>  <strong>Garansi</strong> <br><ul><li>  ✓ Keamanan Memori </li><li>  ✗ Fungsi tidak dapat dipanggil dengan jenis yang salah </li><li>  ✗ Tidak ada efek samping </li><li>  ✗ Tidak ada pengecualian </li><li>  ✗ Tidak ada kesalahan </li><li>  ✗ Tidak ada siklus abadi </li></ul></li></ul><br><h2>  Haskell </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">xyz</span></span> = <span class="hljs-comment"><span class="hljs-comment">-- 10000  </span></span></code> </pre> <br><p>  Jika Anda tidak terbiasa dengan sintaks: ini adalah definisi fungsi <code>x</code> dengan parameter <code>y</code> dan <code>z</code> .  Di Haskell, Anda dapat menghilangkan tipe, karena mereka akan disimpulkan dari implementasi ⟦kecuali, tentu saja, berbagai fitur canggih dari ekstensi modern dari sistem tipe digunakan . </p><br><p>  Tampaknya ini tidak jauh berbeda dari versi Python, tetapi hanya berkat fakta bahwa kami menulis fungsi kami di Haskell dan itu adalah ubin, kami sudah dapat berbicara tentang beberapa properti yang menarik. </p><br><p>  <strong>Analisis</strong> </p><br><p>  Jelas, kita tidak bisa menarik begitu banyak kesimpulan di sini, tetapi berikut adalah beberapa hal yang perlu diperhatikan: </p><br><ul><li>  <strong>Dokumentasi</strong> <br><ul><li>  ✗ Kita tahu perilaku yang diharapkan </li></ul></li><li>  <strong>Kesalahan umum</strong> <br><ul><li>  ✓ <strong>Tidak ada kesalahan ketik atau nama yang salah</strong> <br>  Karena Haskell adalah bahasa yang dikompilasi, semua nama harus diselesaikan pada waktu kompilasi.  Program tidak akan mengkompilasi jika ada kesalahan ini. </li><li>  ✓ <strong>Tidak ada <code>null</code> tidak terduga</strong> <br>  Haskell tidak memiliki <code>null</code> .  Masalahnya terpecahkan! </li></ul></li><li>  <strong>Garansi</strong> <br><ul><li>  ✓ Keamanan Memori </li><li>  ✓ <strong>Fungsi tidak dapat dipanggil dengan jenis yang salah</strong> </li><li>  ✓ <strong>Tidak ada efek samping yang <em>tidak terduga</em></strong> <br>  ⟦Penulis artikel asli tidak menunjukkan item ini, tetapi saya akan membiarkan diri saya untuk mencatat bahwa jika ada efek samping, jenis fungsi yang disimpulkan akan menunjukkan keberadaan mereka, sehingga kode panggilan akan mengetahui tentang kemampuan mereka. </li></ul></li></ul><br><h2>  Jenis Haskell menentukan </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> :: <span class="hljs-type"><span class="hljs-type">Eq</span></span> a =&gt; [a] -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> xyz = <span class="hljs-comment"><span class="hljs-comment">-- ...</span></span></code> </pre> <br><p>  Sebelumnya, kami berbicara tentang sikap agak licik terhadap keselamatan nenek: jelas dari tes bahwa fungsi tidak akan membahayakan siapa pun, tetapi <em>apakah</em> nenek <em>benar</em> - <em>benar</em> aman?  Apakah fungsi ini secara akurat tidak mengirim surat sumpah? </p><br><p>  Haskell dikenal sebagai bahasa fungsional murni.  Ini tidak berarti bahwa kode tidak dapat memiliki efek samping, tetapi semua efek samping harus ada dalam jenisnya.  Kami tahu jenis fungsi ini, kami melihat bahwa fungsinya bersih, jadi kami yakin bahwa fungsi ini tidak mengubah keadaan eksternal apa pun. </p><br><p>  Ini adalah properti yang sangat menarik karena alasan lain: karena kita tahu bahwa tidak ada efek samping, kita dapat memahami apa fungsi ini, hanya berdasarkan tanda tangannya!  Cukup cari tanda tangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hoogle</a> ini dan lihat hasil pertama.  Tentu saja, ini bukan satu-satunya fungsi yang mungkin memiliki tipe seperti itu, tetapi tipe tersebut memberi kita kepercayaan diri yang cukup untuk keperluan dokumentasi. </p><br><p>  <strong>Analisis</strong> </p><br><ul><li>  <strong>Dokumentasi</strong> <br><ul><li>  ✓ <strong>Kita tahu perilaku yang diharapkan</strong> </li><li>  ✗ Kami memiliki contoh penggunaan </li><li>  ✓ Kami tahu beberapa kelas nilai yang akan diproses dengan benar </li><li>  ✓ <strong>Kami tahu semua jenis nilai yang akan diproses dengan benar</strong> </li></ul></li><li>  <strong>Spesifikasi</strong> <br><ul><li>  ✗ Bekerja dalam setidaknya satu kasing. <br>  Dengan tes atau bukti yang hilang, kami tidak tahu apakah fungsi kami berfungsi sama sekali seperti yang kami harapkan! </li><li>  ✗ Indeks yang dikembalikan selalu merupakan indeks yang valid. </li><li>  ✗ Indeks yang dikembalikan selalu menunjukkan nilai yang sesuai. </li><li>  ✗ Barang yang hilang selalu kembali <code>None</code> / <code>Nothing</code> . </li></ul></li><li>  <strong>Kesalahan umum</strong> <br><ul><li>  ✓ Tidak ada kesalahan ketik atau nama yang salah </li><li>  ✓ Tidak ada <code>null</code> tidak terduga </li><li>  ✓ Kasing <strong>kesalahan selalu ditangani</strong> <br>  Jika fungsi kami mengembalikan <code>Nothing</code> , maka sistem jenis memastikan bahwa kasus ini ditangani dengan benar oleh kode panggilan.  Tentu saja, kasus ini dapat diabaikan, tetapi ini harus dilakukan secara eksplisit. </li></ul></li><li>  <strong>Garansi</strong> <br><ul><li>  ✓ Keamanan Memori </li><li>  ✓ Fungsi tidak dapat dipanggil dengan jenis yang salah </li><li>  ✓ <strong>Tidak ada efek samping</strong> </li><li>  ✗ Tidak ada pengecualian <br>  Saya berbagi pengecualian dan kesalahan, percaya bahwa setelah pengecualian dimungkinkan untuk pulih, dan setelah kesalahan (misalnya, fungsi yang didefinisikan sebagian) - tidak. <br>  Sebagian besar, pengecualian dijelaskan dalam tipe (misalnya, dalam monad IO).  Dalam cara yang baik, kita harus tahu bahwa suatu fungsi tidak akan membuang pengecualian, hanya berdasarkan jenisnya.  Namun, Haskell mematahkan ekspektasi ini dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membiarkan pengecualian dilemparkan dari kode murni</a> . <br>  "Selain itu, perlu dicatat bahwa di Haskell, kesalahan seperti salah memanggil fungsi yang didefinisikan sebagian juga disajikan sebagai pengecualian yang dapat ditangkap dan diproses, sehingga perbedaan antara kedua kategori sedikit kurang jelas." </li><li>  ✗ Tidak ada kesalahan <br>  Kita masih dapat menggunakan fungsi yang didefinisikan sebagian, misalnya, pembagian dengan nol. </li><li>  ✗ Tidak ada siklus abadi </li></ul></li></ul><br><h2>  Haskell dengan tes </h2><br><p>  Ingat, saya katakan sebelumnya bahwa tes tidak dapat membuktikan tidak adanya kesalahan?  Aku berbohong  Ketika bintang-bintang bertemu dengan benar, dan jika tes dikombinasikan dengan jenis, maka itu menjadi mungkin!  Bintang pertama adalah keterbatasan fungsi domain kita.  Yang kedua - domain definisi seharusnya tidak hanya terbatas, tetapi juga tidak terlalu besar, jika tidak tes semacam itu akan sulit untuk dipraktikkan. </p><br><p>  Sebagai contoh: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">not</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> not x = ...</code> </pre> <br><p>  Input dapat berupa <code>True</code> atau <code>False</code> .  Sudah cukup untuk menguji dua opsi ini, dan ini dia, Holy Grail!  Tidak ada pengecualian, siklus berulang, hasil salah, tidak ada kesalahan.  ⟦Namun, untuk fungsi yang sedikit lebih kompleks, mungkin tidak jelas berapa banyak waktu yang dihabiskan untuk tes: jika mereka membutuhkan waktu lama untuk menyelesaikannya, apakah kita berakhir dalam siklus kekal, atau hanya berat?  Masalah menghentikannya .⟧ </p><br><p>  Sebenarnya, ini juga tidak sepenuhnya benar dalam kasus Haskell: di setiap jenis Haskell ada juga nilai ⊥ (yang dapat diperoleh sebagai <code>undefined</code> , <code>error</code> atau dalam arti tertentu sebagai pengulangan tak terbatas), tetapi kaum Haskell secara tradisional menutup mata mereka dan percaya bahwa itu tidak ada. </p><br><p>  Bacaan Ekstrakurikuler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hanya Ada Empat Miliar Mengapung - Jadi Tes Semua Mereka!</a> </p><br><p>  Dalam kasus apa pun, dalam contoh asli kami, cakupannya tidak terbatas, jadi pengujian hanya dapat menunjukkan bahwa kode kami berfungsi untuk sekumpulan contoh terbatas. </p><br><p>  <strong>Analisis</strong> <br>  Dalam hal ini, pengujian melengkapi jenis dan memasukkan beberapa lubang di sistem jenis Haskell.  Kami memiliki kepercayaan diri yang lebih besar pada kode kami dibandingkan dengan hanya menggunakan tes atau tipe. </p><br><h2>  C </h2><br><pre> <code class="plaintext hljs">/* C    ,    int */ int x(int *y, size_t n, int z) { /* 10000    */ }</code> </pre> <br><p>  Kami menganggap C tidak tertarik pada sistem tipe lama.  Dalam C, khususnya, jenis-jenis yang paling mungkin dibutuhkan bukan oleh programmer, tetapi oleh kompiler untuk membantunya menghasilkan kode lebih cepat. </p><br><p>  Dalam contoh kita, kita tidak tahu fungsi apa yang akan kembali jika elemen tidak ditemukan.  Kami harus mengandalkan tradisi atau dokumentasi (misalnya, dalam hal ini mungkin <code>-1</code> ). </p><br><p>  Kita juga bisa menggunakan argumen: dengan cara ini kita bisa mengembalikan kesalahan dan menyimpan nilai kembali ke argumen keluar ini.  Ini adalah opsi yang sedikit lebih ekspresif, tetapi kita masih harus bergantung pada dokumentasi untuk memahami parameter mana yang dibaca dan mana yang ditulis.  Dalam kedua kasus, sulit untuk memahami perilaku dengan melihat tipe. </p><br><pre> <code class="plaintext hljs">/*   ,   out- */ error_t x(int *y, size_t n, int z, size_t *w) { /* 10000    */ }</code> </pre> <br><p>  <strong>Analisis</strong> <br>  Sistem tipe itu sendiri tidak memberi kami begitu banyak jaminan.  Tentu saja, kami mendapatkan beberapa informasi dari tipe-tipe ini, tetapi bandingkan saja dengan case Haskell. </p><br><h2>  Idris </h2><br><pre> <code class="plaintext hljs">x : Eq x =&gt; List x -&gt; x -&gt; Maybe Int xyz = ...</code> </pre> <br><p>  Fungsi ini dari jenis yang sama seperti dalam kasus Haskell.  Namun, dengan sistem tipe yang lebih ekspresif, kita dapat mencapai lebih banyak.  Pilihan jenis dapat berbicara tentang implementasi. </p><br><pre> <code class="plaintext hljs">%default total x : Eq x =&gt; Vect nx -&gt; x -&gt; Maybe (Fin n) xyz = ...</code> </pre> <br><p>  Jenis ini dapat dibaca sebagai "beri saya daftar ukuran <code>n</code> dan beberapa nilai, dan saya akan mengembalikan nomor yang kurang dari <code>n</code> atau <code>Nothing</code> ."  Ini memastikan bahwa fungsi mengembalikan indeks yang jelas tidak melampaui batas. </p><br><p>  Selain itu, fungsi ini total, yaitu, timer telah memeriksa bahwa ia selalu berakhir.  Ini menghilangkan siklus dan kesalahan abadi. </p><br><p>  <strong>Analisis</strong> </p><br><ul><li>  <strong>Spesifikasi</strong> <br><ul><li>  ✗ Bekerja dalam setidaknya satu kasing. </li><li>  ✓ <strong>Indeks yang dikembalikan selalu merupakan indeks yang benar</strong> </li><li>  ✗ Indeks yang dikembalikan selalu menunjukkan nilai yang sesuai </li><li>  ✗ Barang yang hilang selalu kembali <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Garansi</strong> <br><ul><li>  ✓ Keamanan Memori </li><li>  ✓ Fungsi tidak dapat dipanggil dengan jenis yang salah </li><li>  ✓ Tidak ada efek samping </li><li>  ✗ Tidak ada pengecualian </li><li>  ✓ <strong>Tidak ada kesalahan</strong> </li><li>  ✓ <strong>Tidak ada siklus abadi</strong> </li></ul></li></ul><br><h2>  Idris dengan tes </h2><br><p>  Karena jenis bahasa Idris sama ekspresifnya dengan bahasa istilahnya ⟦(atau lebih tepatnya, bagian totalnya yang terbukti)⟧, perbedaan antara tes dan jenisnya kabur: </p><br><pre> <code class="plaintext hljs">ex : x [1, 2, 3] 2 = Just 1 ex = Refl</code> </pre> <br><p>  Fungsi ini memiliki tipe <code>x [1, 2, 3] 2 = Just 1</code> agak aneh <code>x [1, 2, 3] 2 = Just 1</code> .  Tipe ini berarti bahwa untuk pemeriksaan tipe yang berhasil, typer harus membuktikan bahwa <code>x [1, 2, 3] 2</code> struktural sama dengan <code>Just 1</code> .  ⟦Dalam hal ini, buktinya sepele, karena cukup bagi tipper untuk menormalkan istilah di kedua sisi dari tanda yang sama, yang akan dilakukan dalam waktu terbatas karena totalitas semua fungsi yang digunakan, dan yang akan mengarah pada hasil unik karena Church-Rosser.  Setelah itu, seseorang dapat menggunakan refleksivitas kesetaraan, yang merupakan <code>Refl</code> .⟧ </p><br><p>  Bahkan, kami menulis tes level type. </p><br><h2>  Idris dengan bukti </h2><br><p>  Untuk kelengkapan analisis, kita dapat menggunakan kekuatan penuh dari tipe dependen dan <em>membuktikan</em> implementasi kita (karena tipe dependen di Idris setara dengan sistem logis yang menyertakan logika first-order yang konstruktif). </p><br><p>  Secara khusus, kami dapat membuktikan properti yang sebelumnya tidak dapat dijangkau oleh kami: </p><br><pre> <code class="plaintext hljs">--      Eq  DecEq x : DecEq a =&gt; Vect na -&gt; (y : a) -&gt; Maybe (Fin n) xyz = ... --    ,       `x` findIndexOk : DecEq a =&gt; (y : Vect na) -&gt; (z : a) -&gt; case xyz of Just i =&gt; index iy = z Nothing =&gt; Not (Elem zy) findIndexOk yz = ...</code> </pre> <br><p>  Ketik <code>findIndexOk</code> dapat dibaca sebagai “untuk semua tipe <code>a</code> sehingga memiliki perbandingan yang dapat ditentukan secara algoritmik ( <code>DecEq</code> ) untuknya, untuk vektor <code>y</code> elemen apa pun dari tipe <code>a</code> dengan panjang <code>n</code> apa pun dan nilai <code>z</code> tipe <code>a</code> : jika <code>xyz</code> mengembalikan indeks <code>i</code> , maka indeks ini terletak <code>z</code> , tetapi jika <code>xyz</code> mengembalikan <code>Nothing</code> , maka tidak ada elemen seperti itu di vektor sama sekali. " </p><br><p>  ⟦Sangat menarik bahwa penulis artikel asli memberikan jenis yang sedikit lebih lemah daripada yang diberikan di atas.⟧ </p><br><p>  Sekarang kita sudah menangkap semuanya!  Apa kerugiannya?  Nah, menulis semua bukti ini bisa sangat sulit. </p><br><h2>  Perbandingan </h2><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Python </th><th>  Python <br>  tes </th><th>  Haskell </th><th>  Haskell <br>  jenis </th><th>  Haskell <br>  jenis <br>  tes </th><th>  Idris </th><th>  Idris <br>  tes </th><th>  Idris <br>  bukti </th></tr><tr><th>  Dokumentasi </th></tr><tr><td>  Kami tahu perilaku yang diharapkan </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Ada contoh penggunaannya </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Kami tahu beberapa jenis nilai yang sesuai. </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Kami tahu semua jenis nilai yang sesuai. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><th>  Spesifikasi </th></tr><tr><td>  Bekerja dalam setidaknya satu kasing </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Indeks yang dikembalikan selalu valid. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Indeks yang dikembalikan selalu valid. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td></tr><tr><td>  Elemen yang hilang menghasilkan `Tidak Ada` /` Tidak ada` </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td></tr><tr><th>  Kesalahan umum </th></tr><tr><td>  Tidak ada kesalahan ketik atau nama yang salah </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Tidak ada `null` yang tiba-tiba </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Kasing kesalahan selalu ditangani. </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><th>  Garansi </th></tr><tr><td>  Keamanan memori </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Tidak dapat dipanggil dengan tipe yang salah. </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Tidak ada efek samping </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Tidak ada pengecualian </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Tidak ada kesalahan </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Tidak ada siklus abadi </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr></tbody></table></div><br><h2>  Opini </h2><br><p>  Menurut pendapat saya, penggunaan sistem tipe modern itu sendiri paling efektif dalam hal hubungan informasi yang diterima dan jaminan untuk upaya yang dikeluarkan.  Jika Anda ingin menulis kode yang cukup andal, maka jenisnya dapat dibumbui dengan tes.  Idealnya - dengan gaya QuickCheck. </p><br><p>  Dengan tipe dependen, garis antara tes dan tipe menjadi kurang jelas.  Jika Anda menulis perangkat lunak untuk Boeing atau untuk alat pacu jantung, mungkin berguna untuk menulis bukti. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467677/">https://habr.com/ru/post/id467677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467667/index.html">Perencanaan Proyek Organisasi (Bagian 4)</a></li>
<li><a href="../id467669/index.html">Tonton saya secara penuh: peras video langsung paling banyak di platform seluler</a></li>
<li><a href="../id467671/index.html">Komputer NLX Retro</a></li>
<li><a href="../id467673/index.html">Fitur Go bawaan</a></li>
<li><a href="../id467675/index.html">Pemodelan status aplikasi menggunakan objek Store di SwiftUI</a></li>
<li><a href="../id467679/index.html">PyCrunch - Eksekusi uji cerdas dan cakupan kode visual dalam IDE</a></li>
<li><a href="../id467681/index.html">Routing SOAP Memutar Kerentanan</a></li>
<li><a href="../id467683/index.html">Mencoba menyusun skema docking yang tidak dapat dikomposisikan</a></li>
<li><a href="../id467689/index.html">Gambaran kecil tentang SIMD di .NET / C #</a></li>
<li><a href="../id467691/index.html">Intel Nervana NNP-T dan NNP-I - chip khusus untuk AI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>