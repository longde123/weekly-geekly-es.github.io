<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📐 ♏️ ✍🏽 无法安装的Windows更新列表 🤽🏿 🦓 🌤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您是否想知道为什么会生成已安装的Windows更新列表？ 并通过哪个API获取呢？ 我将在我的小型研究中尝试回答这些问题以及其他新出现的问题。 



 背景或一切的开始。 
 每年我们公司都会召开一次年轻专家会议，每个参与者都可以解决一个部门的问题（预先提出主题列表）。 SPAS的部门（软件和硬件...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>无法安装的Windows更新列表</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467445/"> 您是否想知道为什么会生成已安装的Windows更新列表？ 并通过哪个API获取呢？ 我将在我的小型研究中尝试回答这些问题以及其他新出现的问题。 <br><br><img src="https://habrastorage.org/webt/bb/rl/zc/bbrlzcws8p-tumczrzauuvx2l7w.jpeg"><br><a name="habracut"></a><br><h2> 背景或一切的开始。 </h2><br> 每年<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们公司</a>都会召开一次年轻专家会议，每个参与者都可以解决一个部门的问题（预先提出主题列表）。  SPAS的部门（软件和硬件的维护）具有以下任务，这使我感兴趣，此外，它使再次返回编程成为可能（不幸的是，此刻，我在这家公司工作时只是一个NPPS的简单运营商）。 <br><br> 以前，在WSUS的帮助下，对于每个“ TO”，所有发布的更新都被提取并分发到所有计算机。  TSB（技术服务公告）也定期出现，这表明需要以隔离软件包的形式安装必要的更新。 结果，我们累积了无法在WSUS中跟踪的更新，而这些更新只能通过“已安装的更新”部分中的控制面板看到。 <br><br><br><br><img src="https://habrastorage.org/webt/v6/9f/kb/v69fkb557stfaokhfjpoccmnuma.png" alt="视觉更新方案"><br><br> 在某些情况下，工作站或服务器“崩溃”，您必须从前一段时间创建的映像中还原它。 从映像恢复时，我们可能会丢失在计算机崩溃之前安装的所需更新（以隔离软件包的形式出现）。 尽可能详细地解释，因为澄清已经是商业秘密。 <br><br> 这就是为什么这个想法出现的原因是创建一个程序，该程序可以提取此更新列表（最好是<b>通过</b>本地网络<b>远程</b> ），写入文件/数据库，将当前列表与特定模板进行比较并通过SNMP，OPC等协议之一将消息发送到SCADA系统。 <br><br> 正如您可能从文章标题中猜到的那样，选择列表检索方法已经是一项艰巨的任务。 像往常一样，我决定在搜索引擎中搜索正确的一个，在专用资源上提出问题（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两个</a> ，出于某种原因，英语的stackoverflow不喜欢我的问题，因此必须删除），但是所有答案都没有得到理想的结果。 因此，我必须自己弄清楚，稍后将进行讨论。 <br><br><h2> 控制台命令 </h2><br> 让我们从一个简单的例子开始，充分利用Windows提供的功能，而无需使用第三方工具。 可以使用以下命令完成此操作： <br><br><ul><li>  WMIC QFE清单 </li><li> 系统信息 </li><li>  Dism /在线/获取软件包 </li><li> 通过PowerShell： <br><br><ul><li>  <b>获取修补程序</b> </li><li>  <b>Get-SilWindowsUpdate</b> （仅在服务器版本中可用） </li><li>  <b>Get-WmiObject-类win32_quickfixengineering-</b>通过访问WMI类win32_quickfixengineering（稍后再介绍WMI） </li></ul><br></li></ul><br><br> 您可以通过控制面板“添加/删除程序”的标准项通过图形界面获得列表，但我们无法从此处复制任何内容。 每个控制面板工具由Windows \ System文件夹中的.cpl文件表示。 控制面板启动时，Windows系统文件夹中的.Cpl文件将自动下载。  Appwiz.cpl文件负责“程序”项。 他的分析没有得出任何结果。 <br><br> 可以将console命令的输出重定向到一个文件，然后可以对其进行解析，但这是错误的，再加上一个程序调用（根据安全理事会的规定将不起作用），而且毫无疑问可以远程接收该列表。 因此，我建议您只需调用命令，通过控制面板将每个列表中的更新数量与列表进行比较，然后继续我们的调查。 <br><br> 正式地，获取更新列表的所有方法可以分为两组：本地和网络。 <br><br><img src="https://habrastorage.org/webt/jw/jt/nf/jwjtnfe3m0dqr_cc9q9xybhf1ka.png" alt="本地和网络获取信息的方法"><br><br> 所有方法都在带有集成更新的干净系统映像（Windows 7、8，Server 2012 R2）上进行了测试，在从官方Microsoft服务器通过更新中心进行的每次更新之后，都进行了附加检查。 让我们更详细地介绍它们。 <br><br><h2> 用水户协会 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WUApi</a> （Windows Update代理API）-使用Windows Update代理API。 最明显的选择，其名称说明一切。 我们将为此使用Wuapi.dll库。 <br><blockquote> 注意：以下，为方便起见，我将所有结果嵌入到列表中。 这可能不是合理的，但是对我而言，这似乎是个好主意。 </blockquote><div class="spoiler">  <b class="spoiler_title">实施实例</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WUApiLib; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listUpdateHistory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//WUApi List&lt;string&gt; result = new List&lt;string&gt;(200); try { UpdateSession uSession = new UpdateSession(); IUpdateSearcher uSearcher = uSession.CreateUpdateSearcher(); uSearcher.Online = false; ISearchResult sResult = uSearcher.Search("IsInstalled=1 And IsHidden=0"); string sw = "   WUApi: " + sResult.Updates.Count; result.Add(sw); foreach (WUApiLib.IUpdate update in sResult.Updates) { result.Add(update.Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre> <br></div></div><br> 此方法的第二种变化是： <b>更新会话</b> -通过连接到Windows Update代理更新会话来接收信息（在这种情况下，我们不直接与该库一起使用）。 <br><br><div class="spoiler">  <b class="spoiler_title">实施实例</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sessionlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pc</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    object sess = null; object search = null; object coll = null; try { sess = Activator.CreateInstance(Type.GetTypeFromProgID("Microsoft.Update.Session", pc)); search = (sess as dynamic).CreateUpdateSearcher(); int n = (search as dynamic).GetTotalHistoryCount(); int kol = 0; //coll = (search as dynamic).QueryHistory(1, n); coll = (search as dynamic).QueryHistory(0, n); result.Add("  Update.Session: " + n); foreach (dynamic item in coll as dynamic) { if (item.Operation == 1) result.Add(item.Title); kol++; //Console.WriteLine(": " + kol); } result.Add("  : " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } finally { if (sess != null) Marshal.ReleaseComObject(sess); if (search != null) Marshal.ReleaseComObject(search); if (coll != null) Marshal.ReleaseComObject(coll); } return result; }</span></span></code> </pre><br></div></div><br> 微软建议远程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用该API</a> 。 <br><br> 这两种方法的主要缺点是它们不允许查找未通过Windows Update分发的KB修补程序。 您只能看到更新代理本身经历了什么，也就是说，此选项不适合我们。 <br><br><h2>  DISM </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部署映像服务和管理</a>是一个命令行工具，可用于服务Windows映像或准备Windows预安装环境（Windows PE）的映像。 它替代了程序包管理器（Pkgmgr.exe），PEimg和Intlcfg。 <br><br> 该实用程序用于将更新，Service Pack集成到系统映像中。  Windows更新是单独的模块，可以通过几种方式呈现： <br><br><ul><li>  .cab文件（内阁）-存档。 设计用于以自动模式使用Windows Update模块进行分发和安装； </li><li>  .msu文件（Microsoft Update独立软件包）-可执行文件。 专为用户自己通过Microsoft更新目录以手动模式分发和安装而设计。 实际上，它们是由.cab-、. xml和.txt文件组成的打包集。 </li></ul><br> 前面提到的<b>dism / online / get-packages</b>命令显示有关wim映像/当前系统中所有软件包的基本信息。  Microsoft已经照顾了我们，并提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NuGet软件包</a>以方便使用API​​。 <br><br><div class="spoiler">  <b class="spoiler_title">实施实例</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Dism; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DISMlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">220</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DismApi.Initialize(DismLogLevel.LogErrors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dismsession = DismApi.OpenOnlineSession(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listupdate = DismApi.GetPackages(dismsession); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ab = listupdate.Count; <span class="hljs-comment"><span class="hljs-comment">//Console.WriteLine("   DISM: " + ab); string sw = "   DISM: " + ab; result.Add(sw); foreach (DismPackage feature in listupdate) { result.Add(feature.PackageName); //result.Add($"[ ] {feature.PackageName}"); //result.Add($"[ ] {feature.InstallTime}"); //result.Add($"[ ] {feature.ReleaseType}"); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br> 更新数量与“控制面板”列表中的数量一致，直到通过控制中心进行的第一次更新-之后，更新数量变少了（它是214，变成了209），尽管从逻辑上讲应该增加。 输出示例<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更新前，更新</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">后</a> 。 <br><br> 这是什么原因，我只能推测-也许某些更新替代了以前的更新，因此数量减少了。 <br><br> 过了一会儿，我遇到了中文<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DISM ++</a>的实用程序，该实用程序不基于DISM API或DISM Core API，但是它的库没有我需要打开的方法，因此我放弃了这个想法并继续进行进一步的搜索。 <br><br><h2> 华硕 </h2><br>  Windows Server Update Services（ <a href="">WSUS</a> ）是用于更新操作系统和Mi​​crosoft产品的服务器。 更新服务器与Microsoft网站同步，下载可以在公司LAN内分发的更新。 同样，一个专门用于更新的专用工具。 <br><br> 仅在Windows的服务器版本上分发，因此部署了以下支架： <br><br><ul><li> 主系统是Windows Server 2016; </li><li> 通过Hyper-V虚拟化系统，部署了两个客户端操作系统： <br><ul><li>  Windows 8.1 </li><li>  Windows 7 </li></ul><br></li></ul><br> 所有系统都连接到单个虚拟局域网，但<u>不能访问Internet</u> 。 <br><br><div class="spoiler">  <b class="spoiler_title">一些技巧</b> <div class="spoiler_text"> 为了不为新系统分配硬盘分区，我使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WinNTSetup</a>并将系统安装在VHD磁盘中-从Windows 7（专业版/旗舰版）开始的引导加载程序在从磁盘映像引导方面做得很好。 这样获得的磁盘可以在Hyper-V中安全使用-您一次用一块石头杀死了两只鸟。 请记住，只需通过<b>bcdedit / export e：\ bcd_backup.bcd命令</b>预先复制BCD存储库。 <br><br> 我不想配置用于分发更新的AD，因此我只是在组策略中注册了WSUS服务器的路径： <br><br><img src="https://habrastorage.org/webt/j6/7f/v0/j67fv0mdw8mr8l0m73fowtmm238.png" alt="设定值"><br><br> 由于输入错误（8350而不是8530），请务必注意端口，尽管一切都已正确完成，但我无法在客户端计算机上收到更新。 此外，Windows 7和Windows 8上的组策略中项目的名称也不同。 <br><br> 要使用WSUS接收报告，您必须另外安装软件包-系统将通知您。 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">现在有一点代码</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      using Microsoft.UpdateServices.Administration; public static List&lt;string&gt; GetWSUSlist(params string[] list) { List&lt;string&gt; result = new List&lt;string&gt;(200); //    string namehost = list[0]; // ,     string = "example1"; string servername = list[1]; //  string = "WIN-E1U41FA6E55"; string Username = list[2]; string Password = list[3]; try { ComputerTargetScope scope = new ComputerTargetScope(); IUpdateServer server = AdminProxy.GetUpdateServer(servername, false, 8530); ComputerTargetCollection targets = server.GetComputerTargets(scope); // Search targets = server.SearchComputerTargets(namehost); // To get only on server FindTarget method IComputerTarget target = FindTarget(targets, namehost); result.Add(" : " + target.FullDomainName); IUpdateSummary summary = target.GetUpdateInstallationSummary(); UpdateScope _updateScope = new UpdateScope(); // See in UpdateInstallationStates all other properties criteria //_updateScope.IncludedInstallationStates = UpdateInstallationStates.Downloaded; UpdateInstallationInfoCollection updatesInfo = target.GetUpdateInstallationInfoPerUpdate(_updateScope); int updateCount = updatesInfo.Count; result.Add(" -   - " + updateCount); foreach (IUpdateInstallationInfo updateInfo in updatesInfo) { result.Add(updateInfo.GetUpdate().Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; } public static IComputerTarget FindTarget(ComputerTargetCollection coll, string computername) { foreach (IComputerTarget target in coll) { if (target.FullDomainName.Contains(computername.ToLower())) return target; } return null; }</span></span></code> </pre><br></div></div><br> 由于没有互联网，因此出现更新情况，如以下屏幕截图所示： <br><br><img src="https://habrastorage.org/webt/az/gc/le/azgclepy6kznsibmilm1psoewa8.png"><br><br> 行为与WUApi类似-如果更新未通过更新，则他们不知道。 因此，此方法不再起作用。 <br><br><h2>  Wmi </h2><br> 直译的Windows Management Instrumentation（ <b>WMI</b> ）是Windows管理工具箱。 <br><br>  WMI是Microsoft实施的标准，用于<u>通过Internet</u>管理企业<u>，</u>以集中管理和监视运行Windows平台的计算机基础结构的各个部分。  WMI是访问接口的开放统一系统，可以访问其中运行的操作系统，设备和应用程序的任何参数。 <br><br> 此方法使您既可以从本地计算机接收数据，也可以从本地网络远程接收数据。 要访问WMI对象，使用特定的WMI查询语言（WQL），它是SQL的一种。 我们将通过WMI类<b>win32_quickfixengineering</b>接收列表。 <br><br><div class="spoiler">  <b class="spoiler_title">实施实例</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Management; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWMIlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] list</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ManagementScope Scope; string ComputerName = list[0]; string Username = list[1]; string Password = list[2]; int kol = 0; if (!ComputerName.Equals("localhost", StringComparison.OrdinalIgnoreCase)) { //    ,      //  . ConnectionOptions Conn = new ConnectionOptions(); Conn.Username = Username; Conn.Password = Password; //      «NTLMDOMAIN:»  NTLM  ,       NTLM. Conn.Authority = "ntlmdomain:DOMAIN"; Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), Conn); } else Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), null); try { Scope.Connect(); ObjectQuery Query = new ObjectQuery("SELECT * FROM Win32_QuickFixEngineering"); ManagementObjectSearcher Searcher = new ManagementObjectSearcher(Scope, Query); foreach (ManagementObject WmiObject in Searcher.Get()) { result.Add(WmiObject["HotFixID"].ToString()); //Console.WriteLine("{0,-35} {1,-40}", "HotFixID", WmiObject["HotFixID"]);// String //result.Add(); /*result.Add("{0,-17} {1}", " : ", WmiObject["Description"]); result.Add("{0,-17} {1}", ": ", WmiObject["Caption"]); result.Add("{0,-17} {1}", " : ", WmiObject["InstalledOn"]);*/ kol++; } result.Add("  " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br> 从数量上讲，所有内容都是重合的（即使在更新后也是如此），因此决定使用此方法。 对于以编程方式创建WMI请求，我建议您使用以下实用程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-WMI Delphi Code Creator</a> 。 多亏了她，我对我的代码有所不同，并决定使用此程序中的空白。 <br><br><h2>  XML格式 </h2><br> 通过WMI方法获得的数据并没有阻止我，因此我决定进行“表面逆向工程”。 我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sysinternals Suite</a>软件集中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Process Monitor</a>实用程序来识别在调用上面列出的控制台命令并通过“控制面板”访问“已安装的更新”项时使用的文件和注册表分支。 <br><br> 我的注意力吸引到位于C：\ Windows \ serviceic \ Packages \文件夹中的wuindex.xml文件。 为了对其进行分析，编写了以下程序： <br><br><div class="spoiler">  <b class="spoiler_title">控制台应用程序示例</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">XMLviewer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> writePath = AppDomain.CurrentDomain.BaseDirectory + <span class="hljs-string"><span class="hljs-string">"XML  "</span></span> + Environment.MachineName + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(writePath)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  txt "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" XML .txt ,   "</span></span>); File.Delete(writePath); } <span class="hljs-comment"><span class="hljs-comment">//      KB Regex regex = new Regex(@"KB[0-9]{6,7}"); //Regex(@"(\w{2}\d{6,7}) ?"); //SortedSet    ,     ""     SortedSet&lt;string&gt; spisok = new SortedSet&lt;string&gt;(); XmlDocument xDoc = new XmlDocument(); string path = "C:\\Windows\\servicing\\Packages\\wuindex.xml"; //   xml xDoc.Load(path); int kol = 0; //-  int total = 0; //-    xml int total2 = 0; //-   XmlNodeList name = xDoc.GetElementsByTagName("Mappings"); foreach (XmlNode xnode in name) { //Console.WriteLine(xnode.Name); kol++; XmlNode attr = xnode.Attributes.GetNamedItem("UpdateId"); //Console.WriteLine(attr.Value); foreach (XmlNode childnode in xnode.ChildNodes) { XmlNode childattr = childnode.Attributes.GetNamedItem("Package"); total++; //Console.WriteLine(childattr.Value); MatchCollection matches = regex.Matches(childattr.Value); if (matches.Count &gt; 0) { foreach (Match match in matches) //Console.WriteLine(match.Value); spisok.Add(match.Value); } else { //Console.WriteLine("  "); } } } try { StreamWriter sw = new StreamWriter(writePath); foreach (string element in spisok) { //Console.WriteLine(element); sw.WriteLine(element); total2++; } sw.Close(); } catch (Exception ex) { Console.WriteLine(": " + ex.Message); } //Console.WriteLine("\n"); Console.WriteLine(" : " +kol); Console.WriteLine("    xml: " + total); Console.WriteLine(" KB : " + total2); Console.WriteLine("    ."); Console.Read(); } } }</span></span></code> </pre><br></div></div><br> 不幸的是，该文件并非在所有系统上都可以找到，其生成和更新的原理仍然是我的一个谜。 因此，这种方法也不适合我们。 <br><br><h2> 立方英尺 </h2><br> 在这里，我们来探讨所有这些方法的关联。 继续分析Process Monitor日志，我确定了以下文件夹和文件。 <br><br> 位于<b>C：\ Windows \ SoftwareDistribution \ DataStore文件夹中的DataStore.edb文件</b> 。 这是一个数据库，其中包含Windows安装版本的所有更新的历史记录，包括仅排队的更新。 <br><br>  ESEDatabaseView程序用于分析DataStore.edb文件。 数据库中有一个tbUpdates表，其内容难以解释。 <br><br><img src="https://habrastorage.org/webt/n4/1v/b0/n41vb0kmc5axymvp2gd3qax5bek.png" alt="ESEDatabaseView中的TbUpdates表"><br><br> 引起我注意<b>TiWorker.exe</b>进程后，每次我在“控制面板”中打开一个项目时都会调用该进程。 他“浏览”了许多文件夹，其中之一使我走上了正轨。 <br><br>  <b>C：\ Windows \ SoftwareDistribution</b>是Windows Update用于将更新下载到计算机并安装它们的文件夹，它还存储有关所有以前安装的更新的信息。 <br><br> 位于<b>C：\ Windows \ winsxs的</b> WinSxS文件夹。 这是Windows操作系统的服务文件夹，用于存储以前安装的系统组件版本。 由于存在更新，因此如有必要，可以回滚到更新的旧版本。 <br><br>  <b>C：\ Windows \ serviceic-</b>整个系统的主要组件，名称为<b>基于组件的服务（CBS）</b> 。 <br><br>  CBS是Windows的一部分，是基于组件的服务，并且与Windows Update服务集成在一起。 与<b>基于文件的服务（FBS）服务</b> （适用于Windows Vista之前的操作系统）不同，在文件服务中直接在系统目录中更新文件，而CBS则引入了整个目录层次结构以及模块/服务库的整个系列（堆栈）。 <br><br>  <b>CbsApi.dll</b>是主要的CBS技术支持库。 它没有开放的方法，所以我不能直接使用它。  Microsoft使用TrustedInstaller.exe和TiWorker.exe访问该库的方法，并通过这些过程显示我们需要的数据。 记录保存在<b>C：\ Windows \ Logs \ CBS \ CBS.log中</b> 。 <br><br> 在创建该程序的原型时（您可以在屏幕截图中看到2019年5月），没有关于CBS的俄语信息，但是在8月底，有一个非常不错的博客文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-http://datadump.ru/component-based-servicing</a> 。 一篇非常有趣的文章证实了我的经验并收集了必要的信息。 有关该主题的更多信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//www.outsidethebox.ms/17988/</a> <br><br><h2> 结论 </h2><br>  Microsoft太复杂了获取更新列表的琐碎任务，并使此过程不十分明显。 所有这些都是为了安全起见，而不是为了易于使用。 我同意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>的作者-在接收更新时开始缺乏可预测性和透明度。 <br><br> 作为研究的结果，编写了以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">程序</a> ，可以在此视频中看到其演示： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SNxReaN4EKY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 计划添加： <br><br><ol><li> 将必要更新列表与接收到的更新进行比较； </li><li> 通过SNMP / OPC发送结果（如果有经验，请在评论中分享）； </li><li> 从指定的文件夹组织丢失的“脱机”更新的安装。 </li></ol><br> 如果您知道更多不仅可以获取更新列表，而且还可以获取其他组件（Adobe Flash，Acrobat Reader等）列表的方法，或者您还有其他有趣的建议，请在评论或私人消息中写上它-我将很高兴收到任何反馈。 并参与本文的调查-因此，我将知道我对Habrahabr受众的经历是否会很有趣。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467445/">https://habr.com/ru/post/zh-CN467445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467429/index.html">Habrastatistics：浏览网站上访问量最高和访问量最少的部分</a></li>
<li><a href="../zh-CN467435/index.html">我们通过电子邮件或电报发送Veeam代理Linux的报告</a></li>
<li><a href="../zh-CN467437/index.html">PostgreSQL-1中的MVCC。 隔离度</a></li>
<li><a href="../zh-CN467439/index.html">为什么黑胶唱片会回来，流媒体服务与此相关？</a></li>
<li><a href="../zh-CN467443/index.html">多媒体中心“ Kodi”和Yocto项目</a></li>
<li><a href="../zh-CN467449/index.html">具有内置保护的漏洞检测和对智能卡和加密处理器的黑客攻击的抵抗性评估</a></li>
<li><a href="../zh-CN467453/index.html">使用行星超级计算机解决42号问题</a></li>
<li><a href="../zh-CN467455/index.html">使用Milander控制器示例在QtCreator中对微控制器进行编程的QBS模板</a></li>
<li><a href="../zh-CN467457/index.html">从手术到游戏开发者的方式或Unity上的移动开发的首次体验</a></li>
<li><a href="../zh-CN467459/index.html">微控制器如何以1.6 Gbps读取数据</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>