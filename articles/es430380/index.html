<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèîÔ∏è üéÖüèΩ üì¥ Gu√≠a de JavaScript, parte 5: matrices y bucles üë©üèΩ‚Äçüç≥ üèµÔ∏è ü§º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, en la quinta parte de la traducci√≥n del curso de JavaScript, hablaremos sobre matrices y bucles. Las matrices se utilizan para resolver muchos pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de JavaScript, parte 5: matrices y bucles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430380/">  Hoy, en la quinta parte de la traducci√≥n del curso de JavaScript, hablaremos sobre matrices y bucles.  Las matrices se utilizan para resolver muchos problemas.  A menudo trabaja con matrices usando bucles. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: primer programa, caracter√≠sticas del lenguaje, est√°ndares</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2: estilo de c√≥digo y estructura del programa</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: variables, tipos de datos, expresiones, objetos.</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: funciones</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5: matrices y bucles</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 6: excepciones, punto y coma, literales comod√≠n</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 7: modo estricto, esta palabra clave, eventos, m√≥dulos, c√°lculos matem√°ticos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 8: Descripci√≥n general de las caracter√≠sticas de ES6</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 9: Descripci√≥n general de los est√°ndares ES7, ES8 y ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Matrices</font> </h2><br>  Las matrices, objetos de tipo <code>Array</code> , evolucionan junto con otros mecanismos del lenguaje.  Son listas de valores numerados. <br><br>  El primer elemento de la matriz tiene un √≠ndice (clave) de 0; este enfoque se utiliza en muchos lenguajes de programaci√≥n. <br><br>  En esta secci√≥n consideraremos m√©todos modernos para trabajar con matrices. <br><br><h3>  <font color="#3AC1EF">‚ñçInicializaci√≥n de matrices</font> </h3><br>  Aqu√≠ hay algunas formas de inicializar matrices. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>).fill(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,   6 ,  1</span></span></code> </pre> <br>  Para acceder a un elemento individual de la matriz, utilice una construcci√≥n que consta de corchetes que contengan el √≠ndice del elemento de la matriz.  Los elementos de la matriz pueden leerse o escribirse. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 3 ] const first = a[0] console.log(first) //1 a[0] = 4 console.log(a) //[ 4, 2, 3 ]</span></span></code> </pre> <br>  No se recomienda el constructor de matrices para declarar matrices. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>() <span class="hljs-comment"><span class="hljs-comment">//  const a = new Array(1, 2, 3) // </span></span></code> </pre> <br>  Este m√©todo solo se debe utilizar al declarar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">matrices escritas</a> . <br><br><h3>  <font color="#3AC1EF">‚ñç Obtener la longitud de la matriz</font> </h3><br>  Para averiguar la longitud de una matriz, debe hacer referencia a su propiedad de <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> l = a.length</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçVerificaci√≥n de una matriz utilizando el m√©todo every ()</font> </h3><br>  El m√©todo de matriz <code>every()</code> se puede utilizar para organizar la verificaci√≥n de todos sus elementos utilizando una determinada condici√≥n.  Si todos los elementos de la matriz cumplen la condici√≥n, la funci√≥n devolver√° <code>true</code> , de lo contrario, devolver√° <code>false</code> . <br><br>  A este m√©todo se le pasa una funci√≥n que toma los argumentos <code>currentValue</code> (elemento de matriz actual), <code>index</code> (√≠ndice del elemento de matriz actual) y <code>array</code> (la matriz misma).  Tambi√©n puede tomar un valor opcional, usado como <code>this</code> cuando se ejecuta la funci√≥n que se le pasa. <br>  Por ejemplo, verifique si los valores de todos los elementos de la matriz son mayores que 10. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.every(test)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(b.every(test)) //false</span></span></code> </pre> <br>  Aqu√≠, en la funci√≥n <code>test()</code> , solo estamos interesados ‚Äã‚Äãen el primer argumento que se le pasa, por lo que lo declaramos, especificando solo <code>el</code> par√°metro el, en el que caer√° el valor correspondiente. <br><br><h3>  <font color="#3AC1EF">‚ñçVerificaci√≥n de una matriz utilizando el m√©todo some ()</font> </h3><br>  Este m√©todo es muy similar al m√©todo <code>every()</code> , pero devuelve <code>true</code> si al menos uno de los elementos de la matriz cumple la condici√≥n especificada por la funci√≥n que se le pasa. <br><br><h3>  <font color="#3AC1EF">‚ñçCree una matriz basada en una matriz existente usando el m√©todo map ()</font> </h3><br>  El m√©todo <code>map()</code> de matrices le permite iterar sobre matrices, aplicando una funci√≥n que convierte el elemento en cada elemento pasado a este m√©todo y crea nuevas matrices a partir de los valores recibidos.  Aqu√≠, por ejemplo, es c√≥mo obtener una nueva matriz que es el resultado de multiplicar todos los elementos de la matriz original por 2. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> double = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doubleA = a.map(double) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 3 ] console.log(doubleA) //[ 2, 4, 6 ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Filtrar una matriz usando el m√©todo filter ()</font> </h3><br>  El m√©todo <code>filter()</code> es similar al m√©todo <code>map()</code> , pero le permite crear nuevas matrices que contienen solo aquellos elementos de las matrices originales que satisfacen la condici√≥n especificada por el m√©todo <code>filter()</code> pasado a la funci√≥n. <br><br><h3>  <font color="#3AC1EF">‚ñç m√©todo reduce ()</font> </h3><br>  El m√©todo <code>reduce()</code> permite aplicar una funci√≥n determinada al acumulador y a cada valor de la matriz, reduciendo la matriz a un solo valor (este valor puede tener un tipo primitivo o un objeto).  Este m√©todo toma una funci√≥n de conversi√≥n y un valor de bater√≠a inicial opcional.  Considera un ejemplo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accumulator, currentValue, currentIndex, array</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulator * currentValue }, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//24 // 1: 1 * 1 = 1 // 2: 1 * 2 = 2 // 3: 2 * 3 = 6 // 4: 6 * 4 = 24</span></span></code> </pre> <br>  Aqu√≠ estamos buscando el producto de todos los elementos de la matriz descritos usando un literal, estableciendo el valor inicial del acumulador 1. <br><br><h3>  <font color="#3AC1EF">‚ñç Enumerar una matriz usando el m√©todo forEach ()</font> </h3><br>  El m√©todo <code>forEach()</code> de las matrices se puede utilizar para iterar sobre los valores de las matrices y realizar ciertas acciones en ellas, especificadas por la funci√≥n que se pasa al m√©todo.  Por ejemplo, mostramos, uno a la vez, los elementos de la matriz en la consola. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] a.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el)) <span class="hljs-comment"><span class="hljs-comment">//1 //2 //3</span></span></code> </pre> <br>  Si necesita detener o interrumpir el ciclo al iterar sobre una matriz, cuando use <code>forEach()</code> tendr√° que lanzar una excepci√≥n.  Por lo tanto, si en el curso de la resoluci√≥n de un determinado problema puede ser necesario interrumpir el ciclo, es mejor elegir otra forma de iterar sobre los elementos de la matriz. <br><br><h3>  <font color="#3AC1EF">‚ñçSeleccionar una matriz usando el operador for ... of</font> </h3><br>  El <code>for...of</code> operador apareci√≥ en el est√°ndar ES6.  Le permite iterar sobre objetos iterables (incluidas las matrices).  Aqu√≠ se explica c√≥mo usarlo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(v) } <span class="hljs-comment"><span class="hljs-comment">//1 //2 //3</span></span></code> </pre> <br>  En cada iteraci√≥n del bucle, el siguiente elemento de la matriz <code>a</code> ingresa a la variable <code>v</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Enumerar una matriz usando la instrucci√≥n for</font> </h3><br>  La instrucci√≥n <code>for</code> permite organizar bucles, que, en particular, tambi√©n se pueden usar para iterar sobre (o inicializar) matrices accediendo a sus elementos por √≠ndice.  T√≠picamente, el √≠ndice del siguiente elemento se obtiene usando un contador de bucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a[i]) } <span class="hljs-comment"><span class="hljs-comment">//1 //2 //3</span></span></code> </pre> <br>  Si, durante la ejecuci√≥n del bucle, necesita omitir su iteraci√≥n, puede usar el comando <code>continue</code> .  Para finalizar prematuramente el ciclo, puede usar el comando <code>break</code> .  Si usa el comando <code>return</code> en un bucle, por ejemplo, ubicado en una determinada funci√≥n, el bucle y la funci√≥n finalizar√°n, y el valor devuelto con <code>return</code> ir√° a donde se llam√≥ la funci√≥n. <br><br><h3>  <font color="#3AC1EF">‚ñç M√©todo @@ iterator</font> </h3><br>  Este m√©todo apareci√≥ en el est√°ndar ES6.  Le permite obtener el llamado "iterador de un objeto", un objeto que en este caso le permite organizar una iteraci√≥n de elementos de la matriz.  Se puede obtener un iterador de matriz utilizando el s√≠mbolo (tales s√≠mbolos se denominan "s√≠mbolos conocidos") <code>Symbol.iterator</code> .  Despu√©s de recibir el iterador, puede acceder a su m√©todo <code>next()</code> , que, con cada llamada, devuelve una estructura de datos que contiene el siguiente elemento de la matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> it = a[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(it.next().value) //2 console.log(it.next().value) //3</span></span></code> </pre> <br>  Si llama al m√©todo <code>next()</code> despu√©s de alcanzar el √∫ltimo elemento de la matriz, devolver√°, como el valor del elemento, <code>undefined</code> .  El objeto devuelto por el m√©todo <code>next()</code> contiene el <code>value</code> y las propiedades <code>done</code> .  La propiedad <code>done</code> eval√∫a como <code>false</code> hasta que se alcanza el √∫ltimo elemento de la matriz.  En nuestro caso, si lo llamamos.next <code>it.next()</code> por cuarta vez, devolver√° el objeto <code>{ value: undefined, done: true }</code> , mientras que en las tres llamadas anteriores este objeto se ver√≠a como <code>{ value: , done: false }</code> . <br><br>  El m√©todo de matriz de <code>entries()</code> devuelve un iterador que le permite iterar sobre los pares clave-valor de la matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> it = a.entries() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value) <span class="hljs-comment"><span class="hljs-comment">//[0, 1] console.log(it.next().value) //[1, 2] console.log(it.next().value) //[2, 3]</span></span></code> </pre> <br>  El m√©todo <code>keys()</code> permite iterar sobre las claves de una matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> it = a.keys() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value) <span class="hljs-comment"><span class="hljs-comment">//0 console.log(it.next().value) //1 console.log(it.next().value) //2</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçAdici√≥n de elementos al final de una matriz</font> </h3><br>  Para agregar elementos al final de la matriz, use el m√©todo <code>push()</code> . <br><br><pre> <code class="javascript hljs">a.push(<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçAgregar elementos al comienzo de la matriz</font> </h3><br>  Para agregar elementos al comienzo de la matriz, use el m√©todo <code>unshift()</code> . <br><br><pre> <code class="javascript hljs">a.unshift(<span class="hljs-number"><span class="hljs-number">0</span></span>) a.unshift(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçEliminar elementos de la matriz</font> </h3><br>  Puede eliminar un elemento del final de la matriz mientras devuelve este elemento utilizando el m√©todo <code>pop()</code> . <br><br><pre> <code class="javascript hljs">a.pop()</code> </pre> <br>  Del mismo modo, utilizando el m√©todo <code>shift()</code> , puede eliminar un elemento desde el principio de la matriz. <br><br><pre> <code class="javascript hljs">a.shift()</code> </pre> <br>  Lo mismo, pero ya indicando la posici√≥n de la eliminaci√≥n de elementos y su n√∫mero, se realiza utilizando el m√©todo <code>splice()</code> . <br><br><pre> <code class="javascript hljs">a.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    2     a.splice(3, 2) //    2 ,    3</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçEliminar elementos de matriz e insertar otros elementos en su lugar</font> </h3><br>  Para utilizar alguna operaci√≥n para eliminar algunos elementos de la matriz e insertar otros elementos, se utiliza el m√©todo familiar <code>splice()</code> . <br><br>  Por ejemplo, aqu√≠ eliminamos 3 elementos de la matriz comenzando en el √≠ndice 2, despu√©s de lo cual agregamos otros dos elementos al mismo lugar: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] a.splice(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 'a', 'b', 6 ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçCombinar m√∫ltiples matrices</font> </h3><br>  Para combinar varias matrices, puede usar el m√©todo <code>concat()</code> , que devuelve una nueva matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a.concat(b) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(c) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 3, 4 ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçEncontrar elementos en una matriz</font> </h3><br>  En el est√°ndar ES5, ha aparecido el m√©todo <code>indexOf()</code> , que devuelve el √≠ndice de la primera aparici√≥n del elemento de matriz deseado.  Si el elemento no se puede encontrar en la matriz, se devuelve <code>-1</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.indexOf(<span class="hljs-number"><span class="hljs-number">5</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//4 console.log(a.indexOf(23)) //-1</span></span></code> </pre> <br>  El m√©todo <code>lastIndexOf()</code> devuelve el √≠ndice de la √∫ltima aparici√≥n del elemento en la matriz, o <code>-1</code> si no se encuentra el elemento. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.lastIndexOf(<span class="hljs-number"><span class="hljs-number">5</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//7 console.log(a.lastIndexOf(23)) //-1</span></span></code> </pre> <br>  En ES6, apareci√≥ el m√©todo <code>find()</code> de matrices, que realiza una b√∫squeda de matrices utilizando la funci√≥n que se le pasa.  Si la funci√≥n devuelve <code>true</code> , el m√©todo devuelve el valor del primer elemento encontrado.  Si no se puede encontrar el elemento, la funci√≥n volver√° <code>undefined</code> . <br><br>  Su uso puede verse de la siguiente manera. <br><br><pre> <code class="javascript hljs">a.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.id === my_id)</code> </pre> <br>  Aqu√≠, en una matriz que contiene objetos, se busca un elemento cuya propiedad de <code>id</code> igual a la especificada. <br><br>  El m√©todo <code>findIndex()</code> es similar a <code>find()</code> , pero devuelve el √≠ndice del elemento encontrado o <code>undefined</code> . <br><br>  En ES7, apareci√≥ el m√©todo <code>includes()</code> , que le permite verificar la presencia de cierto elemento en la matriz.  Devuelve <code>true</code> o <code>false</code> , encontrando o no encontrando un elemento de inter√©s para el programador. <br><br><pre> <code class="javascript hljs">a.includes(value)</code> </pre> <br>  Con este m√©todo, es posible verificar la presencia de alg√∫n elemento, no toda la matriz, sino solo una parte, comenzando con el √≠ndice especificado cuando se llam√≥ a este m√©todo.  El √≠ndice se especifica utilizando el segundo par√°metro opcional de este m√©todo. <br><br><pre> <code class="javascript hljs">a.includes(value, i)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Obtener un fragmento de una matriz</font> </h3><br>  Para obtener una copia de alg√∫n fragmento de la matriz como una nueva matriz, puede usar el m√©todo <code>slice()</code> .  Si se llama a este m√©todo sin argumentos, la matriz devuelta ser√° una copia completa del original.  Se necesitan dos par√°metros opcionales.  El primero establece el √≠ndice inicial del fragmento, el segundo establece el final.  Si no se especifica el √≠ndice final, la matriz se copia desde el √≠ndice inicial especificado hasta el final. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.slice(<span class="hljs-number"><span class="hljs-number">4</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//[ 5, 6, 7, 8, 9 ] console.log(a.slice(3,7)) //[ 4, 5, 6, 7 ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçOrdenador de clasificaci√≥n</font> </h3><br>  Para organizar la ordenaci√≥n de los elementos de la matriz en orden alfab√©tico ( <code>0-9A-Za-z</code> ), se utiliza el m√©todo <code>sort()</code> sin pasarle argumentos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] a.sort() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 10, 11, 2, 3 ] const b = [1, 'a', 'Z', 3, 2, 11] b.sort() console.log(b) //[ 1, 11, 2, 3, 'Z', 'a' ]</span></span></code> </pre> <br>  Puede pasar una funci√≥n a este m√©todo que establece el orden de clasificaci√≥n.  La funci√≥n acepta, para la comparaci√≥n de dos elementos, los par√°metros <code>a</code> y <code>b</code> .  Devuelve un n√∫mero negativo si <code>a</code> menor que <code>b</code> seg√∫n alg√∫n criterio, 0 si son iguales y un n√∫mero positivo si <code>a</code> mayor que <code>b</code> .  Al escribir una funci√≥n similar para ordenar matrices num√©ricas, puede devolver el resultado de restar <code>b</code> .  Por lo tanto, devolver el resultado de evaluar la expresi√≥n <code>a - b</code> significa ordenar la matriz en orden ascendente, devolviendo el resultado de evaluar la expresi√≥n <code>b - a</code> ordenar√° la matriz en orden descendente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b)) <span class="hljs-comment"><span class="hljs-comment">//[ 1, 2, 3, 10, 11 ] console.log(a.sort((a, b) =&gt; b - a)) //[ 11, 10, 3, 2, 1 ]</span></span></code> </pre> <br>  Para invertir la secuencia de elementos de la matriz, puede usar el m√©todo <code>reverse()</code> .  Al igual que <code>sort()</code> , modifica la matriz para la que se llama. <br><br><h3>  <font color="#3AC1EF">‚ñçObtener una representaci√≥n de cadena de una matriz</font> </h3><br>  Para obtener una representaci√≥n de cadena de una matriz, puede usar su m√©todo <code>toString()</code> . <br><br><pre> <code class="javascript hljs">a.toString()</code> </pre> <br>  El m√©todo <code>join()</code> da un resultado similar, llamado sin argumentos. <br><br><pre> <code class="javascript hljs">a.join()</code> </pre> <br>  Para ello, como argumento, puede pasar los elementos separadores. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.toString()) <span class="hljs-comment"><span class="hljs-comment">//1,10,3,2,11 console.log(a.join()) //1,10,3,2,11 console.log(a.join(', ')) //1, 10, 3, 2, 11</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçCreando copias de matrices</font> </h3><br>  Para crear una copia de la matriz copiando los valores de la matriz original en la nueva matriz, puede usar el m√©todo <code>Array.from()</code> .  Tambi√©n es adecuado para crear matrices a partir de objetos similares a matrices (a partir de cadenas, por ejemplo). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-string"><span class="hljs-string">'a string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(a) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(b) <span class="hljs-comment"><span class="hljs-comment">//[ 'a', ' ', 's', 't', 'r', 'i', 'n', 'g' ]</span></span></code> </pre> <br>  El m√©todo <code>Array.of()</code> tambi√©n se puede utilizar para copiar matrices, as√≠ como para "ensamblar" matrices de varios elementos.  Por ejemplo, para copiar los elementos de una matriz a otra, puede usar la siguiente construcci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.of(...a) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(b) <span class="hljs-comment"><span class="hljs-comment">// [ 1, 10, 3, 2, 11 ]</span></span></code> </pre> <br>  El m√©todo <code>copyWithin()</code> se usa para copiar los elementos de la matriz en un lugar determinado de esta matriz.  Su primer argumento especifica el √≠ndice inicial de la posici√≥n de destino, el segundo el √≠ndice inicial de la posici√≥n de la fuente del elemento, y el tercer par√°metro, opcional, indica el √≠ndice final de la posici√≥n de la fuente del elemento.  Si no lo especifica, todo se copiar√° en la ubicaci√≥n especificada de la matriz, comenzando desde el √≠ndice inicial de la posici√≥n de origen hasta el final de la matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] a.copyWithin(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a) <span class="hljs-comment"><span class="hljs-comment">//[ 3, 4, 5, 4, 5 ]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Ciclos</font> </h2><br>  Hablando de las matrices anteriores, ya hemos encontrado algunas formas de organizar bucles.  Sin embargo, los bucles en JavaScript se usan no solo para trabajar con matrices, y hemos considerado lejos de todos sus tipos.  Por lo tanto, ahora dedicaremos algo de tiempo a discutir diferentes formas de organizar bucles en JavaScript y hablar sobre sus caracter√≠sticas. <br><br><h3>  <font color="#3AC1EF">‚ñç para bucle</font> </h3><br>  Considere un ejemplo de aplicaci√≥n de este ciclo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.length; i++) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(list[i]) <span class="hljs-comment"><span class="hljs-comment">//,     console.log(i) // }</span></span></code> </pre> <br>  Como ya se mencion√≥, puede interrumpir la ejecuci√≥n de dicho ciclo usando el comando <code>break</code> , y puede omitir la iteraci√≥n actual e ir directamente a la siguiente usando el comando <code>continue</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç para cada ciclo</font> </h3><br>  Tambi√©n discutimos este ciclo.  Aqu√≠ hay un ejemplo de iterar sobre una matriz us√°ndolo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item, index</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(item) <span class="hljs-comment"><span class="hljs-comment">// console.log(index) // }) //     ,      list.forEach(item =&gt; console.log(item))</span></span></code> </pre> <br>  Recuerde que para interrumpir dicho ciclo, es necesario lanzar una excepci√≥n, es decir, si necesita interrumpirlo cuando usa un ciclo, es mejor elegir otro ciclo. <br><br><h3>  <font color="#3AC1EF">‚ñç Hacer ... mientras bucle</font> </h3><br>  Este es el llamado "ciclo posterior a la condici√≥n".  Dicho ciclo se ejecutar√° al menos una vez antes de verificar la condici√≥n para finalizar el ciclo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(list[i]) <span class="hljs-comment"><span class="hljs-comment">// console.log(i) // i = i + 1 } while (i &lt; list.length)</span></span></code> </pre> <br>  Se puede interrumpir usando el comando <code>break</code> , puede continuar con su pr√≥xima iteraci√≥n con el comando <code>continue</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç while loop</font> </h3><br>  Este es el llamado "ciclo preacondicionado".  Si, a la entrada del ciclo, la condici√≥n para continuar el ciclo es falsa, no se ejecutar√° ni una sola vez. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; list.length) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(list[i]) <span class="hljs-comment"><span class="hljs-comment">// console.log(i) // i = i + 1 }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç para ... en bucle</font> </h3><br>  Este bucle le permite iterar sobre todas las propiedades enumeradas de un objeto por sus nombres. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'three'</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(property) <span class="hljs-comment"><span class="hljs-comment">//  console.log(object[property]) //  }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Ciclo para ... de</font> </h3><br>  El ciclo <code>for...of</code> combina la conveniencia del ciclo <code>forEach</code> y la capacidad de interrumpir su funcionamiento utilizando herramientas regulares. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  for (const value of ['a', 'b', 'c']) { console.log(value) // } //       `entries()` for (const [index, value] of ['a', 'b', 'c'].entries()) { console.log(index) // console.log(value) // }</span></span></code> </pre> <br>  Tenga en cuenta que aqu√≠, en el encabezado del bucle, se usa la palabra clave <code>const</code> y no, como es de esperar, <code>let</code> .  Si no es necesario reasignar las variables dentro del bloque de bucle, entonces <code>const</code> es muy adecuado para nosotros. <br>  Si comparamos los <code>for...in</code> y <code>for...of</code> bucles, resulta que <code>for...in</code> itera sobre los nombres de las propiedades y <code>for...of</code> - valores de las propiedades. <br><br><h2>  <font color="#3AC1EF">Bucles y alcances</font> </h2><br>  Con bucles y √°mbitos variables, hay una caracter√≠stica de JavaScript que puede causarle problemas al desarrollador.  Para tratar estos problemas, <code>let</code> bucles, los √°mbitos y las palabras clave <code>var</code> y <code>let</code> . <br><br>  Considera un ejemplo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operations = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { operations.push(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) }) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operations) { operation() }</code> </pre> <br>  El bucle realiza 5 iteraciones, en cada una de las cuales se agrega una nueva funci√≥n a la matriz de <code>operations</code> .  Esta funci√≥n muestra en la consola el valor del contador de bucle - <code>i</code> .  Despu√©s de agregar las funciones a la matriz, iteramos sobre esta matriz y llamamos a las funciones que son sus elementos. <br><br>  Al ejecutar dicho c√≥digo, puede esperar el resultado que se muestra a continuaci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Pero, de hecho, infiere lo siguiente. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  ¬øPor qu√© es esto as√≠?  La cuesti√≥n es que, como contador de bucle, usamos una variable declarada con la palabra clave <code>var</code> . <br><br>  Como las declaraciones de tales variables van al principio del alcance, el c√≥digo anterior es similar al siguiente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operations = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { operations.push(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) }) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operations) { operation() }</code> </pre> <br>  Como resultado, resulta que en el ciclo <code>for...of</code> , en el que iteramos sobre la matriz, la variable <code>i</code> todav√≠a es visible, es 5, como resultado, haciendo referencia a <code>i</code> en todas las funciones, imprimimos el n√∫mero 5. <br><br>  ¬øC√≥mo cambiar el comportamiento del programa para que haga lo que se espera de √©l? <br><br>  La soluci√≥n m√°s simple a este problema es usar la palabra clave <code>let</code> .  Como ya dijimos, apareci√≥ en ES6, su uso le permite deshacerse de algunas rarezas caracter√≠sticas de la <code>var</code> . <br><br>  En particular, en el ejemplo anterior, es suficiente cambiar <code>var</code> para <code>let</code> todo funcione como deber√≠a. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operations = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { operations.push(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) }) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operations) { operation() }</code> </pre> <br>  Ahora, en cada iteraci√≥n del ciclo, cada funci√≥n agregada a la matriz de <code>operations</code> obtiene su propia copia de <code>i</code> .  Recuerde que en esta situaci√≥n no puede usar la palabra clave <code>const</code> , ya que el valor de <code>i</code> en el bucle cambia. <br><br>  Otra forma de resolver este problema, que a menudo se usaba antes del est√°ndar ES6, cuando la palabra clave <code>let</code> no estaba all√≠, era usar IIFE. <br><br>  Con este enfoque, el valor de <code>i</code> almacena en el cierre, y la funci√≥n devuelta por IIFE y que tiene acceso al cierre entra en la matriz.  Esta funci√≥n se puede realizar cuando sea necesario.  As√≠ es como se ve. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operations = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { operations.push(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(j</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(j) })(i)) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> operations) { operation() }</code> </pre> <br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos de matrices y bucles en JavaScript.  El tema de nuestro pr√≥ximo art√≠culo es el manejo de excepciones, los patrones de uso de punto y coma y los literales de plantilla. <br><br>  <b>Estimados lectores!</b>  ¬øQu√© m√©todos para trabajar con matrices en JavaScript utiliza con m√°s frecuencia? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430380/">https://habr.com/ru/post/es430380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430366/index.html">Cocina VR: lo que no se ve en el casco</a></li>
<li><a href="../es430372/index.html">Coche de hidr√≥geno. ¬øEs hora de decir adi√≥s a la gasolina?</a></li>
<li><a href="../es430374/index.html">Ingenier√≠a de datos y m√°s: graba videos y diapositivas de la reuni√≥n</a></li>
<li><a href="../es430376/index.html">Gu√≠a de JavaScript Parte 6: Excepciones, punto y coma, plantillas literales</a></li>
<li><a href="../es430378/index.html">J2CL - Mejor tarde que nunca</a></li>
<li><a href="../es430382/index.html">Gu√≠a de JavaScript Parte 4: Caracter√≠sticas</a></li>
<li><a href="../es430384/index.html">Crear mapas a partir de caracter√≠sticas de ruido</a></li>
<li><a href="../es430386/index.html">Planta de energ√≠a de almacenamiento de estado s√≥lido que se construir√° en India</a></li>
<li><a href="../es430388/index.html">Desconferencia de cumbre web</a></li>
<li><a href="../es430392/index.html">C√≥mo desarrollo y pruebo las API con mi "bicicleta" PieceofScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>