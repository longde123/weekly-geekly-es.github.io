<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗂️ 🌗 🔙 视觉回归测试。 重新开机 👨‍🚀 👼🏻 🛁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在我的上一篇文章中，我谈到了使用Gemini引擎开发视觉测试或视觉回归测试的经验。 这样的测试通过将当前屏幕截图与以前固定的参考屏幕截图进行比较，来检查下一次更改后UI中是否有“移动”的内容。 从那时起，我们编写视觉测试的方法发生了很大变化，包括所使用的引擎。 现在我们使用Hermione ，但是在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>视觉回归测试。 重新开机</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/"> 在我的上<a href="https://habr.com/ru/post/454464/">一篇文章中，</a>我谈到了使用<a href="https://github.com/gemini-testing/gemini">Gemini</a>引擎开发视觉测试或视觉回归测试的经验。 这样的测试通过将当前屏幕截图与以前固定的参考屏幕截图进行比较，来检查下一次更改后UI中是否有“移动”的内容。 从那时起，我们编写视觉测试的方法发生了很大变化，包括所使用的引擎。 现在我们使用<a href="https://github.com/gemini-testing/hermione">Hermione</a> ，但是在本文中，我不仅要讲述Hermione，而且要讲述的是自那时以来积累的问题以及如何解决这些问题，其中包括导致向新引擎过渡的问题。 <br><a name="habracut"></a><br> 首先，尽管测试有效且非常成功，但我们对测试涵盖的内容和未涵盖的内容并不清楚。 当然，对覆盖程度有一些了解，但我们没有对其进行定量测量。 其次，测试的组成随着时间的推移而增加，并且不同的测试经常测试同一件事，因为 在不同的屏幕截图中，某些部分与同一部分重合，但是在不同的屏幕截图中。 结果，即使CSS的微小更改也可能一次淹没许多测试，并且需要更新大量标准。 第三，我们的产品中出现了深色主题，为了以某种方式覆盖测试，某些测试被选择性地切换为使用深色主题，这也没有为确定覆盖程度增加问题的清晰度。 <br><br><h2> 性能优化 </h2><br> 奇怪的是，我们从优化性能开始。 我将解释原因。 我们的视觉测试基于<a href="https://github.com/storybooks/storybook">故事书</a> 。 故事书中的每个故事都不是单个组件，而是一个完整的“块”（例如，带有实体列表，实体卡，对话甚至整个应用程序的网格）。 要显示此块，有必要使用数据“泵送”故事，不仅是向用户显示的数据，还包括数据块内使用的组件的状态。 此信息与源代码一起以json文件的形式存储，其中包含应用程序状态（redux存储）状态的序列化表示。 是的，从某种程度上来说，这些数据是多余的，但是它极大地简化了测试的创建。 要创建新测试，我们只需在应用程序中打开所需的卡，列表或对话框，对应用程序的当前状态进行快照并将其序列化为文件。 然后，我们添加一个新故事，并进行测试以获取该故事的屏幕截图（全部在几行代码中）。 <br><br> 这种方法不可避免地增加了捆束的尺寸。 数据中的重复程度只是“翻转”。 运行测试时，双子星引擎会在单独的浏览器会话中执行每个测试套件。 每个会话都会重新加载捆绑软件，并且这种方案中捆绑软件的大小与最后一个值相差甚远。 <br><br> 为了减少测试运行时间，我们通过增加测试套件的数量来减少测试套件的数量。 因此，一个测试套件可能会同时影响多个故事。 在此方案中，由于Gemini允许您仅针对整个测试套件设置屏幕截图区域（实际上API允许您在每个屏幕截图之前执行此操作，但实际上它不起作用），我们实际上失去了仅对屏幕的特定区域进行``屏幕显示''的能力。 <br><br> 在测试中无法限制屏幕截图的面积导致参考图像中的视觉信息重复。 尽管没有太多测试，但是这个问题似乎并不重要。 是的，UI不会经常更改。 但这不可能永远持续下去-即将出现的重新设计。 <br><br> 展望未来，我会说在Hermione中可以为每个镜头设置一个屏幕截图区域，乍一看，切换到新引擎将解决所有问题。 但是我们仍然必须“粉碎”大型测试套件。 事实是视觉测试本质上是不稳定的（这可能是由于各种原因，例如网络滞后，使用动画或“火星上的天气”），而且没有自动重试很难做到。  Gemini和Hermione都对整个测试套件执行重试，并且测试套件的“厚度”越大，重试期间成功完成的可能性就越小，因为 在下一次运行中，先前成功完成的测试可能会失败。 对于较厚的测试套件，我们必须实现Gemini引擎中内置的替代重试方案，并且确实不希望在切换到新引擎时再次这样做。 <br><br> 因此，为了加快测试套件的加载，我们将整体捆绑包分成几部分，将应用程序状态的每个快照分配为单独的“片段”，并为每个案例分别“按需”加载。 现在，故事创建代码如下所示： <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br> 要创建故事，将使用StoryProvider组件（下面将给出其代码）。 使用<a href="https://webpack.js.org/guides/code-splitting/">动态导入</a>功能加载快照。 不同的故事彼此之间仅在状态图片上有所不同。 对于深色主题，将使用与浅色主题相同的快照生成自己的故事。 在故事书的上下文中，它看起来像这样： <br><br><div class="spoiler">  <b class="spoiler_title">默认主题故事</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">黑暗主题故事</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  StoryProvider组件接受一个回调以加载在其中调用import（）函数的快照。  import（）函数是异步工作的，因此您无法在加载故事后立即截屏-我们冒着删除空白的风险。 为了赶上下载结束的时刻，提供程序呈现标记DOM元素，该元素在下载的整个过程中向测试引擎发出信号，应将其与屏幕截图一起延迟： <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br> 另外，要减小包的大小，请禁用向包添加源映射的操作。 但是为了不失去调试故事的能力（您永远不知道是什么），我们在以下条件下执行此操作： <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  <b>npm run build-storybook脚本</b>将不带源映射的静态故事<b>书</b>编译到storybook-static文件夹中。 在执行测试时使用。  <b>npm run故事书脚本</b>用于开发和调试测试故事。 <br><br><h2> 消除视觉信息重复 </h2><br> 如上所述，Gemini允许您为整个测试套件设置屏幕截图区域选择器，这意味着要完全解决在屏幕截图中复制视觉信息的问题，我们必须为每个屏幕截图制作自己的测试套件。 即使考虑到加载故事的优化，它在速度方面也不是太乐观，因此我们考虑更改测试引擎。 <br><br> 其实，为什么是赫敏？ 目前，Gemini存储库已被标记为已弃用，迟早我们不得不“移动”到某个地方。  Hermione配置文件的结构与Gemini配置文件的结构相同，我们能够重用此配置。  Gemini和Hermione插件也很常见。 另外，我们能够重用测试基础架构-虚拟机和已部署的硒网格。 <br><br> 与Gemini不同，Hermione并非仅作为布局回归测试的工具。 它的浏览器操作功能更加广泛，仅受<a href="http://v4.webdriver.io/">Webdriver IO</a>功能的<a href="http://v4.webdriver.io/">限制</a> 。 与<a href="https://github.com/mochajs/mocha">mocha</a>结合使用时<a href="https://github.com/mochajs/mocha">，</a>此引擎比布局测试更方便用于功能测试（模拟用户操作）。 对于布局的回归测试，Hermione仅提供assertView（）方法，该方法将浏览器页面的屏幕截图与参考进行比较。 屏幕截图可以限制为使用CSS选择器指定的区域。 <br><br> 在我们的案例中，每个故事的测试如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br> 如果将第二个参数设置为true，则waitForVisible（）方法（尽管其名称）使您不仅可以期望外观，而且还可以期待元素的隐藏。 在这里，我们使用它来等待标记元素被隐藏，以指示尚未加载数据快照，并且故事还没有准备好截图。 <br><br> 如果您尝试在Hermione文档中找到waitForVisible（）方法，将找不到任何内容。 事实是，waitForVisible（） <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">方法是Webdriver IO API方法</a> 。 分别使用url（）方法。 在url（）方法中，我们传递特定故事而不是整个故事书的框架地址。 首先，这是必要的，这样故事列表就不会显示在浏览器窗口中-我们不需要对其进行测试。 其次，如有必要，我们可以访问框架内的DOM元素（webdriverIO方法允许您在浏览器上下文中执行JavaScript代码）。 <br><br> 为了简化测试的编写，我们对mocha-tests进行了包装。 事实是，在详细描述用于回归测试的测试用例时没有特别的意义。 所有测试用例都相同-“应等于标准具”。 好吧，我也不想在每个测试中重复代码以等待数据加载。 因此，所有“猴子”测试的相同工作都委派给包装函数，并且测试本身以声明性方式编写（好了，差不多）。 这是此函数的文本： <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br> 描述测试套件的对象将传递到函数的输入。 每个测试套件都是根据以下情况构建的：我们对主要布局进行截图（例如，实体卡的区域或实体列表的区域），然后以编程方式按下可以导致其他元素出现的按钮（例如，弹出面板或上下文菜单），然后“对截图进行截图” »每个这样的元素分别。 因此，我们模拟了浏览器中的用户操作，但并不是为了测试业务场景，而是为了“捕获”尽可能多的可视组件。 此外，屏幕快照中的视觉信息重复非常少，因为 屏幕截图是使用选择器“按点”拍摄的。 测试套件示例： <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2> 确定承保范围 </h2><br> 因此，我们确定了速度和冗余度，仍然需要弄清测试的有效性，即确定测试覆盖代码的程度（这里的代码是指CSS样式表）。 <br><br> 对于测试故事，我们根据经验选择了最复杂的卡片，列表和其他元素，以便用一个屏幕截图涵盖尽可能多的样式。 例如，为了测试实体卡，选择了具有大量不同类型的控件（文本，数字，传输，日期，网格等）的卡。 不同类型实体的卡具有其自身的详细信息，例如，可以从文档卡中显示带有文档版本列表的面板，并且在任务卡中显示与此任务的对应关系。 因此，对于每种类型的实体，创建了自己的故事以及针对该类型的一组测试等。 最后，我们认为测试似乎涵盖了所有内容，但我们要比“喜欢”多一点信心。 <br><br> 要评估Chrome DevTools中的coverage，有一种名为Coverage的工具非常适合这种情况： <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  Coverage允许您确定使用浏览器页面时使用的样式或js代码。 关于绿色条纹使用情况的报告指示已使用的代码，红色-未使用。 如果我们使用“ hello，world”级别的应用程序，一切都会很好，但是当我们有成千上万行代码时该怎么办？  Coverage开发人员很好地理解了这一点，并提供了将报告导出到可以通过编程方式处理的文件的功能。 <br><br> 我必须马上说，到目前为止，我们还没有找到一种自动收集覆盖程度的方法。 从理论上讲，这可以使用pupeteer无头浏览器来完成，但是pupeteer在硒的控制下不起作用，这意味着我们将无法重用测试代码。 因此，现在，让我们跳过这个非常有趣的主题，并使用笔。 <br><br> 在手动模式下运行测试后，我们会得到一份覆盖率报告，它是一个json文件。 在每个CSS，JS，TS等的报告中。 该文件指示其文本（在一行中）以及该文本中使用的代码的间隔（以该行的字符索引的形式）。 以下是一份报告： <br><br><div class="spoiler">  <b class="spoiler_title">coverage.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br> 乍一看，找到未使用的CSS选择器并不困难。 但是，如何处理此信息？ 确实，在最终分析中，我们不需要找到特定的选择器，而是找到我们忘记涵盖测试的组件。 一个组件的样式可以由十几个选择器设置。 结果，根据报告的分析结果，我们得到了数百个未使用的选择器，如果处理每个选择器，您可能会浪费很多时间。 <br><br> 在这里，正则表达式可以帮助我们。 当然，它们仅在满足css类的命名约定时才起作用（在我们的代码中，css类是根据BEM方法论来命名的-block_name_name_name_modifier）。 使用正则表达式，我们可以计算块名称的唯一值，这些值不再难于与组件关联。 当然，我们也对元素和修饰符感兴趣，但首先不是，首先我们需要处理更大的“鱼”。 以下是用于处理覆盖率报告的脚本 <br><br><div class="spoiler">  <b class="spoiler_title">coverage.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br> 我们通过首先放置从Chrome DevTools导出的coverage.json文件并将废品写入.csv文件来执行脚本： <br><br>  <b>节点coverage.js&gt; coverage.csv</b> <br><br> 您可以使用excel打开此文件并分析数据，包括确定测试覆盖的代码百分比。 <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2> 代替简历 </h2><br> 使用故事书作为进行视觉测试的基础已经充分证明了自己的理由-我们以较少的故事数量和最少的创建新成本的方式充分覆盖了CSS代码。 <br><br> 向新引擎的过渡使我们能够消除屏幕快照中的可视信息重复，从而大大简化了对现有测试的支持。 <br><br>  CSS代码的覆盖程度是可衡量的，并且会不时受到监控。 当然，存在一个大问题-如何不忘记此控件的必要性，以及在收集有关覆盖范围信息的过程中如何不遗漏某些东西。 理想情况下，我想在每次测试运行时自动测量覆盖程度，以便在达到指定的阈值时，测试会出错。 我们将为此工作，如果有消息，我一定会告诉您。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN479040/">https://habr.com/ru/post/zh-CN479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN479022/index.html">三星，LG，Vizio和TCL的智能电视每秒获取屏幕的“指纹”并发送到服务器</a></li>
<li><a href="../zh-CN479026/index.html">互联网通道的真实汇总-OpenMPTCPRouter</a></li>
<li><a href="../zh-CN479034/index.html">如何使用openconnect和vpn-slice连接到Linux中的公司VPN</a></li>
<li><a href="../zh-CN479036/index.html">英特尔无法满足对处理器的需求。 惠普和戴尔因此而受苦</a></li>
<li><a href="../zh-CN479038/index.html">数字转换Leroy Merlin：设计用于处理客户呼叫的接口</a></li>
<li><a href="../zh-CN479042/index.html">Y方法是构建魔方的一种非常简单的方法</a></li>
<li><a href="../zh-CN479044/index.html">我在NOR Flash中实现环形缓冲区</a></li>
<li><a href="../zh-CN479048/index.html">用于假人的Node.js流或如何使用流</a></li>
<li><a href="../zh-CN479050/index.html">IT领域的专利研究。 年轻战士的历程。 第二部分 专利研究的信息来源</a></li>
<li><a href="../zh-CN479052/index.html">[Supercomputing 2019]。 多云存储作为新金士顿DC1000M驱动器的应用程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>