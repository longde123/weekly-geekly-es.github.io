<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏾 🙁 👩🏾‍🤝‍👩🏻 Microfronts: apa yang kita bicarakan? 🥐 🔂 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama ini, Anda, pengembang frontend, telah menulis monolith, meskipun Anda memahami bahwa ini adalah kebiasaan buruk. Anda membagi kode Anda menjadi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microfronts: apa yang kita bicarakan?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/459540/"> Selama ini, Anda, pengembang frontend, telah menulis monolith, meskipun Anda memahami bahwa ini adalah kebiasaan buruk.  Anda membagi kode Anda menjadi komponen, menggunakan <code>require</code> atau <code>import</code> dan mendefinisikan paket npm di package.json atau membuat repositori git di proyek Anda, tetapi Anda tetap menulis monolith. <br>  Saatnya mengubah posisi. <br><a name="habracut"></a><br><h3>  <b>Mengapa kode Anda dapat dianggap sebagai monolit?</b> </h3><br>  Secara alami, semua aplikasi frontend bersifat monolitik - kecuali untuk aplikasi yang menerapkan antarmuka mikro.  Alasannya adalah bahwa Anda mengembangkan menggunakan perpustakaan Bereaksi, dan dua tim melakukan pekerjaan.  Keduanya harus menggunakan versi Bereaksi yang sama dan tetap memperbarui informasi, yang berarti bahwa mereka akan selalu menyelesaikan konflik dengan penggabungan kode.  Mereka tidak sepenuhnya independen satu sama lain dalam basis kode.  Mereka semua mungkin menggunakan repositori yang sama dan satu sistem build.  Layanan Microsoft dapat menghemat dari aplikasi monolitik!  Tapi bagaimana caranya?  Bagaimanapun, mereka adalah untuk backend!  * Kejutan luar biasa * <br><br><h3>  <b>Apa itu layanan microser?</b> </h3><br>  Dalam istilah sederhana, layanan-layanan microser adalah teknik pengembangan yang memungkinkan pengembang untuk membuat pengiriman fungsionalitas (rilis) independen untuk berbagai bagian platform, dan pada saat yang sama rilis tidak saling menghancurkan.  Pasokan independen memungkinkan mereka mengumpulkan layanan yang terisolasi atau longgar.  Ada beberapa aturan yang membuat arsitektur ini lebih kuat.  Secara singkat, mereka dapat didefinisikan sebagai berikut: setiap layanan harus kecil dan hanya melakukan satu tugas.  Karena itu, tim yang mengerjakannya juga harus kecil.  Seberapa besar proyek dan tim bisa, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jelaskan</a> James Lewis dan Martin Fowler: <br><br><blockquote>  Pengembang yang berinteraksi dengan nama layanan microser ukuran yang berbeda.  Yang terbesar dari mereka memenuhi strategi <i>tim dua pizza</i> Amazon - tidak lebih dari 10-12 orang.  Kutub terbalik - tim beranggotakan 5-6 orang, di mana masing-masing mendukung satu layanan. </blockquote><br>  Berikut adalah diagram yang menjelaskan perbedaan antara monolit dan layanan mikro: <br><br><img src="https://habrastorage.org/webt/jb/wa/hd/jbwahdgqhcgufovvsbd9yc_8wj0.jpeg"><br><br>  Dapat dilihat dari diagram bahwa setiap layanan dalam sistem layanan-mikro adalah aplikasi yang terpisah, kecuali untuk UI - tetap satu keseluruhan!  Ketika semua layanan didukung oleh satu tim, risikonya besar bahwa, seiring pertumbuhan perusahaan, tim frontend tidak akan lagi mengikuti UI.  Ini adalah kerentanan arsitektur ini. <br><br><img src="https://habrastorage.org/webt/sz/zs/to/szzsto67t102i-tdnrukvfcdx5w.jpeg"><br><br>  Arsitektur dapat membawa masalah organisasi.  Misalkan perusahaan telah tumbuh dan mengadopsi metodologi pengembangan yang fleksibel (saya berbicara tentang Agile).  Mereka membutuhkan tim lintas fungsi kecil.  Tentu saja, dalam contoh abstrak kami, manajer akan mulai memisahkan tugas-tugas frontend dan backend, dan tim lintas-fungsi tidak akan benar-benar lintas fungsional.  Dan semua upaya akan sia-sia: tim mungkin terlihat fleksibel, tetapi pada kenyataannya itu akan sangat terpecah.  Mengelola tim semacam itu bukan untuk menjadi lemah hati.  Pada setiap pertemuan akan ada pertanyaan: apakah ada cukup tugas frontend, apakah ada cukup tugas backend di sprint?  Untuk mengatasi ini dan banyak masalah lainnya, beberapa tahun yang lalu muncul ide microfront, yang dengan cepat mendapatkan popularitas. <br><br><h3>  <b>Solusi untuk masalah ini: microfronts</b> </h3><br>  Solusinya terlihat cukup jelas, karena prinsip-prinsip serupa telah lama berhasil diterapkan dalam pekerjaan pada layanan backend: untuk membagi antarmuka monolitik menjadi fragmen UI kecil.  Namun, UI tidak begitu mirip dengan layanan - itu adalah antarmuka antara pengguna akhir dan produk, itu harus bijaksana dan sistematis.  Apalagi, di era aplikasi satu halaman, seluruh aplikasi diluncurkan melalui browser di sisi klien.  Ini bukan lagi file HTML sederhana, mereka adalah komponen kompleks yang dapat berisi berbagai UI dan logika bisnis.  Sekarang, mungkin, perlu untuk mendefinisikan mikrofront. <br><br><blockquote>  Prinsip microfronts: penyajian situs web atau aplikasi web sebagai <b>serangkaian fungsi</b> yang menjadi tanggung jawab tim independen.  Setiap tim memiliki misinya sendiri, bidang kerjanya sendiri yang menjadi spesialisasi mereka.  Tim ini lintas fungsi dan berkembang <br>  <b>seluruh siklus</b> - dari basis data ke antarmuka pengguna ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">micro-fontend.org</a> ). </blockquote><br>  Pengalaman saya saat ini menunjukkan bahwa bagi banyak perusahaan mungkin sulit untuk menerima arsitektur yang diusulkan di atas.  Bagi yang lain, beban kode lama tidak memungkinkan transisi ke arsitektur baru.  Karena itu, diperlukan cara migrasi yang lebih lancar, lebih mudah, dan lebih andal.  Setelah memeriksa arsitektur secara lebih rinci, saya akan mencoba menawarkan visi saya untuk menyelesaikan masalah.  Sebelum mempelajari detailnya, berkenalanlah dengan terminologi. <br><br>  <b>Struktur umum dan beberapa terminologi lagi</b> <br><br>  Bayangkan kita membagi struktur aplikasi monolitik secara vertikal, berdasarkan fungsi bisnis.  Kami akan mendapatkan beberapa aplikasi yang lebih kecil dengan struktur yang sama dengan aplikasi monolitik.  Tetapi jika kita menambahkan aplikasi khusus di atas aplikasi monolitik kecil ini, maka pengguna akan berinteraksi dengannya.  Ini, pada gilirannya, akan mengintegrasikan UI dari aplikasi kecil itu.  Kami menyebut level ini tautan, karena mengambil elemen UI dari setiap layanan mikro dan menggabungkannya ke dalam satu antarmuka - ini adalah implementasi paling langsung dari mikrofront.  * kekaguman yang tulus * <br><br><img src="https://habrastorage.org/webt/_z/uj/un/_zujun_sxd6nv5clohckbo5pgny.jpeg"><br><br>  Untuk membuatnya lebih jelas, di bawah ini saya akan menyebut setiap aplikasi monolitik kecil sebagai aplikasi <b>mikro</b> , karena ini bukan hanya layanan <b>mikro</b> , tetapi aplikasi yang berdiri sendiri - masing-masing memiliki elemen UI dan masing-masing mewakili fungsi bisnis yang lengkap.  Seperti yang Anda tahu, ekosistem ujung depan saat ini sangat beragam dan bisa sangat kompleks.  Dan solusi yang sederhana dan jelas seperti itu mungkin tidak sesuai dalam proses implementasi produk. <br><br><h3>  <b>Masalah yang harus dipecahkan</b> </h3><br>  Ketika ide artikel ini lahir, saya memulai topik tentang Reddit untuk membahasnya.  Terima kasih kepada anggota komunitas dan umpan balik mereka, saya dapat membuat daftar masalah yang perlu ditangani. <br><br>  <b>Masalah nomor 1:</b> mencapai perilaku yang konsisten dan konsisten dari UI ketika kami memiliki beberapa aplikasi mikro yang sepenuhnya otonom <br><br>  Tidak ada obat mujarab, tetapi ada ide untuk membuat perpustakaan-UI umum, yang juga akan menjadi aplikasi mikro independen.  Dalam hal ini, semua aplikasi mikro lainnya harus bergantung pada pustaka UI ini.  Dan itu membunuh kemerdekaan mereka. <br><br>  Pilihan lain adalah membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">variabel CSS</a> umum di tingkat root.  Keuntungan dari solusi ini adalah kami mendapatkan tema khusus global untuk semua aplikasi. <br><br>  Atau kita dapat membuat variabel SASS dan ketidakmurnian yang umum untuk semua tim.  Di antara kelemahan dari pendekatan ini adalah implementasi berulang elemen UI dan kebutuhan untuk verifikasi konstan dari desain elemen serupa di semua aplikasi mikro. <br><br>  <b>Masalah nomor 2:</b> pastikan bahwa satu tim tidak menulis ulang CSS dari tim lain <br><br>  Pertama, Anda dapat membatasi ruang lingkup CSS menggunakan penyeleksi yang dibentuk dengan nama aplikasi mikro.  Dengan menempatkan batasan ini pada tingkat menengah, Anda dapat mengurangi waktu pengembangan secara keseluruhan, tetapi pada saat yang sama, tanggung jawab tingkat menengah akan meningkat. <br><br>  Kedua, Anda dapat membuat setiap aplikasi mikro menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen web kustom</a> .  Keuntungan dari pendekatan ini adalah bahwa browser berurusan dengan pembatasan.  Namun, semuanya memiliki harga: dengan Shadow DOM, hampir tidak mungkin untuk merender di sisi server.  Selain itu, elemen khusus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak</a> 100% <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">didukung oleh browser</a> - terutama jika Anda memerlukan dukungan IE. <br><br>  <b>Masalah nomor 3:</b> membuat informasi global umum untuk berbagai aplikasi mikro <br><br>  Masalah ini adalah salah satu yang paling umum, tetapi diselesaikan dengan cukup mudah.  HTML5 memiliki fungsionalitas yang cukup kuat, hampir tidak dijelajahi oleh sebagian besar pengembang front-end. <br>  Salah satu fitur ini adalah acara khusus yang memungkinkan Anda membuat informasi umum untuk aplikasi-mikro. <br><br>  Implementasi pub-sub atau T39 juga dapat membantu.  Jika Anda memerlukan penangan keadaan global yang lebih halus, Anda dapat menerapkan Redux umum kecil - ini memberikan arsitektur yang lebih responsif. <br><br>  <b>Masalah nomor 4:</b> jika semua aplikasi mikro otonom, bagaimana melakukan perutean di sisi klien? <br><br>  Solusi untuk masalah ini tergantung pada implementasinya.  Semua kerangka kerja modern besar memiliki mekanisme perutean sisi klien yang kuat menggunakan status riwayat browser.  Masalahnya adalah aplikasi mana yang bertanggung jawab untuk rute saat ini dan kapan tepatnya. <br><br>  Pendekatan pragmatis saya adalah membuat router klien umum, yang hanya bertanggung jawab untuk rute tingkat atas, dan sisanya bergantung pada aplikasi mikro yang sesuai.  Misalkan kita memiliki definisi rute <code>/content/:id.</code>  Router umum akan menyelesaikan bagian c <code>/content</code> , dan rute yang diselesaikan akan diteruskan ke ContentMicroApp.  ContentMicroApp adalah server mandiri yang hanya akan dipanggil dengan <code>/:id</code> . <br><br>  <b>Masalah nomor 5:</b> apakah kita benar-benar membutuhkan SSR (rendering sisi-server), apakah mungkin saat menggunakan mikrofront? <br><br>  Render sisi server tidak mudah.  Jika Anda ingin bundel aplikasi mikro menggunakan iframe, lupakan tentang rendering sisi server.  Demikian pula, komponen web untuk pengikatan tidak lebih kuat dari iframe.  Namun, jika masing-masing aplikasi mikro mampu membuat konten sisi server, maka lapisan penghubung hanya akan bertanggung jawab untuk menggabungkan fragmen HTML di sisi server. <br><br>  <b>Masalah 6:</b> “Integrasi dengan lingkungan yang ada diperlukan seperti udara!  Bagaimana cara membuatnya? " <br><br>  Untuk integrasi dengan sistem yang ada, saya ingin menggambarkan visi saya, yang saya sebut " <i>implementasi bertahap</i> ". <br><br>  Pertama-tama, kita harus mengimplementasikan layer middleware sehingga memiliki fungsi server proxy yang transparan.  Setelah itu, kita dapat mendefinisikan sistem yang ada sebagai aplikasi <i>mikro</i> ( <i>LegacyMicroApp</i> ) dengan mendeklarasikan rute khusus untuk itu.  Semua lalu lintas yang mencapai tingkat penghubung akan diproksikan secara transparan ke sistem yang ada, karena kita belum memiliki aplikasi mikro lainnya. <br><br>  Langkah selanjutnya adalah implementasi bertahap.  Kami akan mengambil sebagian kecil dari <i>LegacyMicroApp</i> , menghapus navigasi utama, menggantinya dengan dependensi.  Ketergantungan ini adalah aplikasi mikro yang diimplementasikan menggunakan teknologi baru yang brilian, NavigationMicroApp. <br><br>  Sekarang <i>LegacyMicroApp</i> akan mencegat semua rute melalui dependensi NavigationMicroApp dan memprosesnya secara internal. <br><br>  Kemudian, dengan cara yang sama, kami akan membuat ulang footer. <br><br>  Jadi kami akan terus menggigit sepotong <i>LegacyMicroApp</i> sampai tidak ada yang tersisa darinya. <br><br>  <b>Masalah nomor 7:</b> mengatur sisi klien sehingga Anda tidak perlu memuat ulang halaman setiap saat <br><br>  Lapisan middleware memecahkan masalah di sisi klien, tetapi tidak di sisi server.  Di sisi klien, dengan mengunduh satu HTML, kami tidak dapat memuat setiap bagian ketika mengubah URL.  Oleh karena itu, kita memerlukan mekanisme yang memuat fragmen secara asinkron.  Masalahnya adalah bahwa fragmen ini dapat memiliki dependensi, dan dependensi ini harus dapat diselesaikan di sisi klien.  Ini berarti bahwa solusi microfrontend harus menawarkan mekanisme untuk memuat aplikasi mikro dan mengimplementasikan injeksi ketergantungan. <br><br>  Masalah yang tercantum di atas dapat digabungkan ke dalam topik berikut: <br><br>  <b>Sisi klien</b> <br><br><ul><li>  Orkestrasi </li><li>  Routing </li><li>  Isolasi Mikro </li><li>  Interaksi aplikasi </li><li>  Unity UI Micro-Applications </li></ul><br>  <b>Sisi server</b> <br><br><ul><li>  Render server </li><li>  Routing </li><li>  Manajemen ketergantungan </li></ul><br><h3>  <b>Arsitektur fleksibel dan kuat tetapi sederhana</b> </h3><br>  Demi ini, layak untuk bertahan di awal artikel!  Elemen-elemen utama dan persyaratan arsitektur mikrofrontend akhirnya mulai muncul;) <br><br>  Dipandu oleh persyaratan dan kekhawatiran, saya mulai mengembangkan solusi yang disebut <b>microfe</b> .  * mengantisipasi umpan balik * <br>  Di sini saya akan menguraikan arsitektur proyek, menjelaskan secara singkat komponen-komponen utamanya. <br><br>  Cara termudah untuk memulai adalah dari sisi klien, yang memiliki tiga struktur utama yang terpisah: <i>AppsManager, Loader, Router</i> , serta satu tambahan, <i>MicroAppStore</i> . <br><br><img src="https://habrastorage.org/webt/av/xb/wm/avxbwmyjvlrs8zqwgf5jpbfpido.jpeg"><br><br>  <b>Manajer Aplikasi</b> <br>  AppsManager adalah inti dari orkestrasi aplikasi mikro sisi klien.  Tujuan utama AppsManager adalah membuat pohon ketergantungan.  Setelah semua dependensi diselesaikan, AppsManager meluncurkan aplikasi mikro. <br><br>  <b>Loader</b> <br>  Bagian penting lain dari orkestrasi sisi klien adalah Loader.  Ia bertanggung jawab mengunduh aplikasi untuk sisi klien. <br><br>  <b>Router</b> <br>  Untuk melakukan perutean sisi klien, saya mengimplementasikan Router dalam mikrofe.  Tidak seperti router sisi klien konvensional, router mikrofe memiliki fungsi terbatas.  Itu tidak memproses halaman, tetapi aplikasi mikro.  Katakanlah kita memiliki URL <code>/content/detail/13</code> dan ContentMicroApp.  Dalam hal ini, router mikrofe akan memproses URL ke <code>/content/*</code> dan memanggil bagian ContentMicroApp <code>/detail/13</code> . <br><br>  <b>Microapppore</b> <br>  Untuk mengatasi interaksi klien antara aplikasi-mikro, saya mengimplementasikan MicroAppStore dalam mikrofe.  Ini memiliki fungsi yang sama dengan perpustakaan Redux, tetapi dengan satu peringatan: itu lebih fleksibel sehubungan dengan modifikasi data asinkron dan deklarasi reducer. <br><br><h3>  <b>***</b> </h3><br>  Sisi server mungkin sedikit lebih rumit untuk diterapkan, tetapi memiliki struktur yang lebih sederhana.  Ini terdiri dari dua bagian utama - StitchingServer dan MicroAppServer. <br><br><h3>  <b>Microappserver</b> </h3><br><img src="https://habrastorage.org/webt/ux/nl/wn/uxnlwnbgtmo0xr4-uryt6-tq2sq.jpeg"><br><br>  Fungsionalitas MicroAppServer sekecil mungkin dapat dinyatakan sebagai: init dan sajikan. <br>  Ketika MicroAppServer melakukan booting, hal pertama yang harus dilakukan adalah memanggil SticthingServer dan mendaftarkan titik akhir dengan aplikasi mikro yang diumumkan.  Ini mendefinisikan dependensi, jenis dan URL skema MicroAppServer Saya pikir berbicara tentang servis tidak perlu - tidak ada yang menarik di sini. <br><br><h3>  <b>Server jahitan</b> </h3><br><img src="https://habrastorage.org/webt/i1/o6/n0/i1o6n0ititazoneaj1lcebo_syw.jpeg"><br><br>  StitchingServer memungkinkan Anda untuk mendaftarkan titik akhir dengan MicroAppServers.  Ketika MicroAppServer mendaftar dengan StichingServer, StichingServer mencatat deklarasi MicroAppServer. <br><br>  Kemudian, StitchingServer menggunakan iklan untuk menyelesaikan MicroAppServices dari URL yang diminta. <br><br>  Setelah mengizinkan MicroAppServer dan semua dependensinya, URL publik yang sesuai akan muncul dalam nama semua jalur yang sesuai di CSS, JS dan HTML.  Langkah tambahan adalah menambahkan awalan MicroAppServer unik ke pemilih CSS untuk mencegah konflik antara aplikasi mikro di sisi klien. <br><br>  Kemudian tugas utama StitchingServer memasuki adegan: tata letak semua bagian yang diterima dan kembalinya seluruh halaman HTML. <br><br><h3>  <b>Beberapa kata tentang implementasi lainnya</b> </h3><br>  Bahkan sebelum istilah microfrontend muncul pada tahun 2016, banyak perusahaan besar mencoba untuk memecahkan masalah serupa - misalnya, Facebook dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BigPipe</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nya</a> . <br>  Sekarang idenya mendapatkan momentum.  Perusahaan dari semua ukuran tertarik pada topik ini, menginvestasikan waktu dan uang di dalamnya.  Misalnya, Zalando menyediakan kode sumber terbuka untuk solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Project Mosaic-nya</a> .  Saya dapat mengatakan bahwa microfe dan Project Mosaic mengikuti pendekatan yang serupa, tetapi dengan beberapa perbedaan utama.  Jika mikrofe menggunakan perutean yang sepenuhnya terdesentralisasi untuk membuat setiap aplikasi mikro lebih mandiri, Project Mosaic lebih memilih perutean terpusat dan definisi pola untuk setiap rute.  Omong-omong, Project Mosaic membuatnya mudah untuk melakukan pengujian AB dan pembuatan template dinamis dengan cepat. <br><br>  Ada pendekatan lain, khususnya, menggunakan iframs sebagai lapisan penghubung - jelas, bukan di sisi server, tetapi di sisi klien.  Ini adalah solusi yang sangat sederhana yang tidak memerlukan struktur server khusus dan keterlibatan DevOps.  Ini dapat diimplementasikan oleh tim front-end secara independen, yang berarti bahwa itu menciptakan lebih sedikit masalah organisasi untuk perusahaan dan biaya lebih sedikit. <br><br>  Masih ada kerangka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spa tunggal</a> .  Proyek ini bergantung pada konvensi penamaan untuk setiap aplikasi untuk mengizinkan dan mengunduh aplikasi mikro.  Mudah untuk memahami ide dan mengikuti pola.  Jadi kerangka kerja ini dapat bermanfaat untuk mengenal dan bereksperimen dengan sistem di lingkungan lokal Anda.  Kelemahan dari proyek ini adalah Anda harus membangun setiap aplikasi mikro dengan cara yang ditentukan secara ketat - jika tidak, kerangka kerja mungkin tidak menerimanya. <br><br><h3>  <b>Kesimpulan (dan tautan)</b> </h3><br>  Saya pikir dari waktu ke waktu topik microfronts akan dipertimbangkan secara lebih rinci.  Jika mulai menarik perhatian semakin banyak perusahaan, maka konsep ini akan menjadi metode pengembangan standar dalam tim besar.  Ini akan berguna bagi setiap pengembang front-end untuk berkenalan dengan arsitektur ini dalam waktu dekat dan mendapatkan pengalaman berharga bekerja dengannya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server pendaftaran aplikasi mikro fe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">infrastruktur ujung depan mikro</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459540/">https://habr.com/ru/post/id459540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459528/index.html">Bagaimana cara kami mengajar ekologi Prancis dan mengumpulkan botol</a></li>
<li><a href="../id459530/index.html">Mikrobiota. Sejarah studi dan metode penelitian</a></li>
<li><a href="../id459532/index.html">Cara memilih nomor acak dari 1 hingga 10</a></li>
<li><a href="../id459536/index.html">Kembangkan plugin untuk produk JetBrains dan jual di JetBrains Marketplace</a></li>
<li><a href="../id459538/index.html"># 18 Mosdroid Argon di Lamoda - pengumuman</a></li>
<li><a href="../id459542/index.html">Mekanika Gamifikasi: Skill Tree</a></li>
<li><a href="../id459544/index.html">Mengapa seri Chernobyl menggambarkan energi nuklir sangat buruk</a></li>
<li><a href="../id459550/index.html">Cadangan, Bagian 5: Menguji Bacula dan Cadangan Veeam untuk Linux</a></li>
<li><a href="../id459552/index.html">Cara kehilangan akses ke sistem langsung dengan hanya meraba-raba kode sumber</a></li>
<li><a href="../id459554/index.html">Pantau perubahan file menggunakan Alerting OpenDistro untuk Elasticsearch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>