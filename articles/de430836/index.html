<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌄 🙌🏼 👲🏼 Kotlin: Statik, die es nicht gibt 👴 😩 👲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird die Verwendung von Statik in Kotlin beschrieben. 
 Fangen wir an. 
 Kotlin hat keine statische Aufladung! 

 Dies ist in der of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: Statik, die es nicht gibt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/430836/"><img src="https://habrastorage.org/webt/a4/lt/ih/a4ltihdnjfobccfvjc3sx3j3bm0.png"><br>  In diesem Artikel wird die Verwendung von Statik in Kotlin beschrieben. <br>  Fangen wir an. <br>  Kotlin hat keine statische Aufladung! <br><br>  Dies ist in der offiziellen Dokumentation angegeben. <br><br>  Und es scheint, dass dies den Artikel beenden könnte.  Aber lassen Sie mich, wie so?  Wenn Sie in Android Studio Java-Code in eine Kotlin-Datei einfügen, wird der Smart Converter die Magie ausführen, alles in Code in der richtigen Sprache umwandeln und es wird funktionieren!  Aber was ist mit der vollständigen Kompatibilität mit Java? <br><br>  Zu diesem Zeitpunkt wird jeder Entwickler, der etwas über das Fehlen von Statik in Kotlin erfährt, in die Dokumentation und in die Foren gehen, um dieses Problem zu beheben.  Lassen Sie uns nachdenklich und sorgfältig zusammenkommen.  Ich werde versuchen, bis zum Ende dieses Artikels so wenig Fragen wie möglich zu beantworten. <a name="habracut"></a><br><br>  Was ist die Statik in Java?  Es gibt: <br><ul><li>  Klasse statische Felder </li><li>  statische Klassenmethoden </li><li>  statisch verschachtelte Klassen </li></ul><br><br>  Lassen Sie uns ein Experiment durchführen (dies ist das erste, was mir in den Sinn kommt). <br><br>  Erstellen Sie eine einfache Java-Klasse: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassJava1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String value)</span></span></span></span>{ staticField = value; } }</code> </pre> <br>  Hier ist alles einfach: In der Klasse erstellen wir ein statisches Feld und eine statische Methode.  Wir machen alles öffentlich für Experimente mit Zugang von außen.  Wir verbinden das Feld und die Methode logisch. <br><br>  Erstellen Sie nun eine leere Kotlin-Klasse und versuchen Sie, den gesamten Inhalt der SimpleClassJava1-Klasse in diese zu kopieren.  Wir beantworten die resultierende Frage zur Konvertierung mit „Ja“ und sehen, was passiert ist: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: String)</span></span></span><span class="hljs-function"> </span></span>{ staticField = value } }</code> </pre><br>  Es scheint, dass dies nicht genau das ist, was wir brauchen ... Um dies sicherzustellen, werden wir den Bytecode dieser Klasse in Java-Code konvertieren und sehen, was passiert ist: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(value, <span class="hljs-string"><span class="hljs-string">"value"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = value; } }</code> </pre><br>  Ja  Alles ist genau so, wie es schien.  Hier riecht es nicht nach Statik.  Der Konverter hat den statischen Modifikator in der Signatur einfach abgeschnitten, als wäre er nicht vorhanden.  Für alle Fälle werden wir sofort eine Schlussfolgerung ziehen: Vertraue dem Konverter nicht blind, manchmal kann es unangenehme Überraschungen bringen. <br><br>  Übrigens hätte die Konvertierung desselben Java-Codes in Kotlin vor etwa sechs Monaten zu einem etwas anderen Ergebnis geführt.  Also nochmal: Vorsicht bei der automatischen Konvertierung! <br><br>  Wir experimentieren weiter. <br><br>  Wir gehen zu jeder Klasse auf Kotlin und versuchen, die statischen Elemente der Java-Klasse darin aufzurufen: <br><pre> <code class="java hljs">SimpleClassJava1.setStaticValue(<span class="hljs-string"><span class="hljs-string">"hi!"</span></span>) SimpleClassJava1.staticField = <span class="hljs-string"><span class="hljs-string">"hello!!!"</span></span></code> </pre><br>  So!  Alles ist perfekt aufgerufen, selbst die automatische Vervollständigung des Codes sagt uns alles!  Ziemlich neugierig. <br><br>  Kommen wir nun zum wesentlicheren Teil.  In der Tat haben die Schöpfer von Kotlin beschlossen, sich von der Statik in der Form zu entfernen, in der wir sie gewohnt sind.  Warum wir genau das getan haben und nicht anders diskutieren - es gibt viele Streitigkeiten und Meinungen zu diesem Thema im Netzwerk.  Wir werden nur herausfinden, wie wir damit leben sollen.  Natürlich wurden wir nicht nur der Statik beraubt.  Kotlin gibt uns eine Reihe von Werkzeugen, mit denen wir den Verlust kompensieren können.  Sie sind für den Innenbereich geeignet.  Und die versprochene volle Kompatibilität mit Java-Code.  Lass uns gehen! <br><br>  Das schnellste und einfachste, was Sie realisieren und verwenden können, ist die Alternative, die wir anstelle statischer Methoden anbieten - Funktionen auf Paketebene.  Was ist das?  Dies ist eine Funktion, die keiner Klasse angehört.  Das heißt, diese Art von Logik befindet sich irgendwo im Paketraum in einem Vakuum.  Wir können es in jeder Datei innerhalb des Pakets beschreiben, die uns interessiert.  Benennen Sie diese Datei beispielsweise JustFun.kt und platzieren Sie sie im Paket <code>com.example.mytestapplication</code> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.<span class="hljs-function"><span class="hljs-function">mytestapplication fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br><br>  Konvertieren Sie den Bytecode dieser Datei in Java und schauen Sie hinein: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JustFunKt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } }</span></span></code> </pre><br>  Wir sehen, dass in Java eine Klasse erstellt wird, deren Name den Namen der Datei berücksichtigt, in der die Funktion beschrieben wird, und die Funktion selbst wird zu einer statischen Methode. <br><br>  Wenn wir nun die <code>testFun</code> Funktion in Kotlin von einer Klasse (oder derselben Funktion) aus aufrufen möchten, die sich im <code>package com.example.mytestapplication</code> ( <code>package com.example.mytestapplication</code> dasselbe Paket wie die Funktion), können wir einfach ohne zusätzliche Tricks darauf zugreifen.  Wenn wir es aus einem anderen Paket aufrufen, müssen wir importieren, was uns vertraut ist und normalerweise für Klassen gilt: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.pavka.mytestapplication.testFun</code> </pre> <br>  Wenn wir über das Aufrufen der Funktion t <code>estFun</code> aus Java-Code sprechen, müssen wir die Funktion immer importieren, unabhängig davon, von welchem ​​Paket wir sie aufrufen: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> com.example.pavka.mytestapplication.ForFunKt.testFun;</code> </pre> <br>  In der Dokumentation heißt es, dass in den meisten Fällen anstelle statischer Methoden die Verwendung von Funktionen auf Paketebene ausreicht.  Meiner persönlichen Meinung nach (die nicht mit der Meinung aller anderen übereinstimmen muss) ist diese Methode zur Implementierung der Statik jedoch nur für kleine Projekte geeignet. <br>  Es stellt sich heraus, dass diese Funktionen keiner Klasse explizit angehören.  Visuell sieht ihr Aufruf wie ein Aufruf der Klassenmethode (oder ihres übergeordneten Elements) aus, in der wir uns befinden, was manchmal verwirrend sein kann.  Nun und die Hauptsache - es kann nur eine Funktion mit diesem Namen im Paket geben.  Selbst wenn wir versuchen, die gleichnamige Funktion in einer anderen Datei zu erstellen, gibt das System einen Fehler aus.  Wenn wir über große Projekte sprechen, haben wir zum Beispiel ziemlich oft verschiedene Fabriken mit statischen Methoden mit demselben Namen. <br><br>  Schauen wir uns andere Alternativen zur Implementierung statischer Methoden und Felder an. <br><br>  Erinnern Sie sich an das statische Feld einer Klasse.  Dies ist ein Klassenfeld, das zu der Klasse gehört, in der es deklariert ist, aber nicht zu einer bestimmten Instanz der Klasse gehört, dh es wird in einer einzelnen Instanz für die gesamte Klasse erstellt. <br><br>  Kotlin bietet uns für diese Zwecke an, eine zusätzliche Entität zu verwenden, die auch in einer einzigen Kopie vorhanden ist.  Mit anderen Worten, Singleton. <br><br>  Kotlin hat ein Objektschlüsselwort, um Singletones zu deklarieren. <br><br><pre> <code class="java hljs">object MySingltoneClass { <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre> <br><br>  Solche Objekte werden träge initialisiert, dh zum Zeitpunkt des ersten Aufrufs. <br><br>  Ok, es gibt auch Singletones in Java. Wo sind die Statistiken? <br><br>  Für jede Klasse in Kotlin können wir einen Begleiter oder ein Begleitobjekt erstellen.  Ein Singleton, der an eine bestimmte Klasse gebunden ist.  Dies kann mit zwei <code>companion  object</code> zusammen erfolgen: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } } }</span></span></code> </pre><br><br>  Hier haben wir die <code>SimpleClassKotlin1</code> Klasse, in der wir einen Singleton mit dem Objektschlüsselwort deklarieren und an das Objekt binden, in dem er mit dem Companion-Schlüsselwort deklariert ist.  Hier können Sie darauf achten, dass im Gegensatz zur vorherigen Singleton-Deklaration (MySingltoneClass) der Name der Singleton-Klasse nicht angegeben wird.  Wenn das Objekt als Begleiter deklariert ist, darf es seinen Namen nicht angeben.  Dann wird es automatisch <code>Companion</code> .  Bei Bedarf können wir eine Instanz der Companion-Klasse folgendermaßen abrufen: <br><pre> <code class="java hljs">val companionInstance = SimpleClassKotlin1.Companion</code> </pre> <br>  Ein Aufruf der Eigenschaften und Methoden einer Begleitklasse kann jedoch direkt über einen Aufruf der Klasse erfolgen, an die sie angehängt ist: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionField SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>)</code> </pre><br>  Es sieht schon so aus, als würde man statische Felder und Klassen aufrufen, oder? <br><br>  Bei Bedarf können wir der Begleitklasse einen Namen geben, in der Praxis wird dies jedoch sehr selten durchgeführt.  Von den interessanten Merkmalen der zugehörigen Klassen kann festgestellt werden, dass sie wie jede gewöhnliche Klasse Schnittstellen implementieren kann, was uns manchmal helfen kann, dem Code etwas mehr Ordnung zu verleihen: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactoryInterface</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: T } class SimpleClassKotlin1 </span></span>{ companion object : FactoryInterface&lt;MyClass&gt; { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: MyClass </span></span>= MyClass() } }</code> </pre> <br><br>  Eine Begleitklasse kann nur eine Klasse haben.  Niemand verbietet uns jedoch, eine beliebige Anzahl von Singleton-Objekten innerhalb der Klasse zu deklarieren. In diesem Fall müssen wir jedoch den Namen dieser Klasse explizit angeben und diesen Namen entsprechend angeben, wenn wir auf die Felder und Methoden dieser Klasse verweisen. <br><br>  Wenn wir von den als Objekt deklarierten Klassen sprechen, können wir sagen, dass wir auch verschachtelte Objekte in ihnen deklarieren können, aber wir können kein Begleitobjekt in ihnen deklarieren. <br><br>  Es ist Zeit, "unter die Haube" zu schauen.  Nehmen Sie an unserer einfachen Klasse teil: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } } object OneMoreObject { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ } }</code> </pre><br><br>  Dekompilieren Sie nun den Bytecode in Java: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneMoreObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.OneMoreObject INSTANCE; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ value = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { SimpleClassKotlin1.OneMoreObject var0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.OneMoreObject(); INSTANCE = var0; value = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SimpleClassKotlin1.companionField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); SimpleClassKotlin1.companionField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String vaue)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(vaue, <span class="hljs-string"><span class="hljs-string">"vaue"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre><br>  Wir schauen, was passiert ist. <br><br>  Die Eigenschaft des Begleitobjekts wird als statisches Feld unserer Klasse dargestellt: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>;</code> </pre> <br><br>  Dies scheint genau das zu sein, was wir wollten.  Dieses Feld ist jedoch privat und wird über den Getter und Setter unserer Companion-Klasse aufgerufen, die hier als <code>public static final class</code> , und ihre Instanz wird als Konstante dargestellt: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br><br>  Die CompanionFun-Funktion wurde nicht zur statischen Methode unserer Klasse (wahrscheinlich sollte dies nicht der Fall sein).  Es blieb die Funktion eines Singletons, der in der SimpleClassKotlin1-Klasse initialisiert wurde.  Wenn Sie jedoch darüber nachdenken, ist dies logischerweise ungefähr dasselbe. <br><br>  Bei der <code>OneMoreObject</code> Klasse <code>OneMoreObject</code> Situation sehr ähnlich.  Es ist nur erwähnenswert, dass hier im Gegensatz zum Begleiter das Feld der <code>SimpleClassKotlin1</code> nicht in die <code>SimpleClassKotlin1</code> Klasse <code>SimpleClassKotlin1</code> , sondern in <code>OneMoreObject</code> blieb, sondern auch statisch wurde und den generierten Getter und Setter erhielt. <br><br>  Versuchen wir, all das zu verstehen. <br>  Wenn wir statische Felder oder Klassenmethoden in Kotlin implementieren möchten, sollten wir dazu das in dieser Klasse deklarierte Companion-Objekt verwenden. <br>  Das Aufrufen dieser Felder und Funktionen von Kotlin aus sieht genauso aus wie das Aufrufen der Statik in Java.  Was aber, wenn wir versuchen, diese Felder und Funktionen in Java aufzurufen? <br><br>  Die automatische Vervollständigung teilt uns mit, dass die folgenden Anrufe verfügbar sind: <br><pre> <code class="java hljs">SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.setCompanionField(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.getCompanionField();</code> </pre><br>  Das heißt, hier gehen wir nicht davon aus, den Namen des Begleiters direkt anzugeben.  Dementsprechend wird hier der Name verwendet, der dem Standard-Begleitobjekt zugewiesen wurde.  Nicht sehr praktisch, oder? <br><br>  Trotzdem haben die Entwickler von Kotlin es möglich gemacht, es in Java bekannter zu machen.  Dafür gibt es mehrere Möglichkeiten. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span></code> </pre> <br>  Wenn wir diese Annotation auf das <code>companionField</code> Feld unseres <code>companionField</code> Objekts anwenden, sehen wir beim Konvertieren von Bytecode in Java, dass das statische Feld <code>companionField</code> SimpleClassKotlin1 nicht mehr privat, sondern öffentlich ist und der Getter und Setter für CompanionField in der statischen <code>Companion</code> Klasse verschwunden sind.  Jetzt können wir auf übliche Weise über Java-Code auf <code>companionField</code> zugreifen. <br><br>  Die zweite Möglichkeit besteht darin, einen <code>lateinit</code> Modifikator für die Eigenschaften des Begleitobjekts anzugeben, Eigenschaften mit später Initialisierung.  Vergessen Sie nicht, dass dies nur für var-Eigenschaften gilt und sein Typ nicht null und nicht primitiv sein sollte.  Vergessen Sie nicht die Regeln für den Umgang mit solchen Eigenschaften. <br><br><pre> <code class="java hljs">lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lateinitField: String</code> </pre> <br>  Und noch eine Möglichkeit: Wir können die Eigenschaft des Begleitobjekts als Konstante deklarieren, indem wir den Modifikator const angeben.  Es ist leicht zu erraten, dass dies eine Val-Eigenschaft sein sollte. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val myConstant = <span class="hljs-string"><span class="hljs-string">"CONSTANT"</span></span></code> </pre> <br>  In jedem dieser Fälle enthält der generierte Java-Code das übliche öffentliche statische Feld. Im Fall von const ist dieses Feld ebenfalls endgültig.  Natürlich lohnt es sich zu verstehen, dass jeder dieser drei Fälle seinen eigenen logischen Zweck hat und nur der erste speziell für die einfache Verwendung mit Java entwickelt wurde. Der Rest erhält dieses „Brötchen“ wie in einer Last. <br><br>  Es sollte separat beachtet werden, dass der const-Modifikator für Eigenschaften von Objekten, Begleitobjekten und für Eigenschaften der Paketebene verwendet werden kann.  Im letzteren Fall erhalten wir dasselbe wie bei Verwendung der Funktionen auf Paketebene und mit denselben Einschränkungen.  Java-Code wird mit einem statischen öffentlichen Feld in der Klasse generiert, dessen Name den Namen der Datei berücksichtigt, in der wir die Konstante beschrieben haben.  Ein Paket kann nur eine Konstante mit dem angegebenen Namen haben. <br><br>  Wenn die Funktion des Begleitobjekts beim Generieren von Java-Code auch in eine statische Methode konvertiert werden soll, müssen wir dazu die Annotation <code>@JvmStatic</code> auf diese Funktion anwenden. <br>  Es ist auch zulässig, die Annotation <code>@JvmStatic</code> auf die Eigenschaften von Begleitobjekten (und nur auf Singleton-Objekte) anzuwenden.  In diesem Fall wird die Eigenschaft nicht zu einem statischen Feld, sondern es wird ein statischer Getter und Setter für diese Eigenschaft generiert.  Schauen Sie sich zum besseren Verständnis diese Kotlin-Klasse an: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre><br><br>  In diesem Fall sind die folgenden Aufrufe von Java aus gültig: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); x = SimpleClassKotlin1.getStaticField(); SimpleClassKotlin1.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>); SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); x = SimpleClassKotlin1.Companion.getStaticField(); SimpleClassKotlin1.Companion.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br><br>  Die folgenden Aufrufe sind von Kotlin gültig: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.staticField SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.Companion.staticField</code> </pre> <br><br>  Es ist klar, dass Sie für Java die ersten 3 und für Kotlin die ersten 2 verwenden sollten. Der Rest der Aufrufe ist nur gültig. <br><br>  Nun bleibt letzteres zu klären.  Was ist mit statisch verschachtelten Klassen?  Hier ist alles einfach - das Analogon einer solchen Klasse in Kotlin ist eine regulär verschachtelte Klasse ohne Modifikatoren: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre><br><br>  Nach der Konvertierung des Bytecodes in Java sehen wir: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br><br>  Das brauchen wir in der Tat.  Wenn wir nicht möchten, dass die Klasse endgültig ist, geben wir im Kotlin-Code den offenen Modifikator dafür an.  Ich erinnerte mich nur für den Fall daran. <br><br>  Ich denke, Sie können zusammenfassen.  In Kotlin selbst gibt es, wie gesagt, keine Statik in der Form, in der wir es gewohnt sind, sie zu sehen.  Mit den vorgeschlagenen Tools können wir jedoch alle Arten von Statiken im generierten Java-Code implementieren.  Volle Kompatibilität mit Java wird ebenfalls bereitgestellt, und wir können statische Felder und Methoden von Java-Klassen direkt von Kotlin aus aufrufen. <br>  In den meisten Fällen erfordert die Implementierung einer Statistik in Kotlin einige weitere Codezeilen.  Vielleicht ist dies einer der wenigen oder vielleicht der einzige Fall, in dem Sie mehr in Kotlin schreiben müssen.  Man gewöhnt sich jedoch schnell daran. <br>  Ich denke, dass Sie in Projekten, in denen Kotlin- und Java-Code gemeinsam genutzt werden, flexibel an die Wahl der verwendeten Sprache herangehen können.  Zum Beispiel scheint mir Java besser zum Speichern von Konstanten geeignet zu sein.  Aber auch hier lohnt es sich, wie in vielen anderen Dingen, sich vom gesunden Menschenverstand und den Regeln für das Schreiben von Code im Projekt leiten zu lassen. <br><br>  Und am Ende des Artikels finden Sie solche Informationen.  Vielleicht wird Kotlin auch in Zukunft noch einen statischen Modifikator haben, der viele Probleme beseitigt und das Leben der Entwickler erleichtert, und der Code ist kürzer.  Ich habe diese Annahme getroffen, indem ich den entsprechenden Text in Absatz 17 der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kotlin-Funktionsbeschreibungen gefunden habe</a> . <br>  Dieses Dokument stammt zwar aus dem Mai 2017 und ist auf dem Hof ​​bereits Ende 2018. <br><br>  Das ist alles für mich.  Ich denke, dass das Thema detailliert aussortiert wurde.  Fragen schreiben Sie in den Kommentaren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430836/">https://habr.com/ru/post/de430836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430826/index.html">Wie man einen Entwicklungsmanager entwickelt</a></li>
<li><a href="../de430828/index.html">Erfahrung in der Verwendung von LCD-Displays auf Basis von MELT-Produkten</a></li>
<li><a href="../de430830/index.html">Schwarzer Freitag, Traditionen und englische Redewendungen zum Einkaufen</a></li>
<li><a href="../de430832/index.html">Human Black Friday Preis</a></li>
<li><a href="../de430834/index.html">10 Todsünden des Sprechers</a></li>
<li><a href="../de430838/index.html">Die Wunder des Crowd-Marketings oder wie man ein Unternehmen mit Bewertungen fördert</a></li>
<li><a href="../de430840/index.html">Welche Beweise können Mathematiker überzeugen, wenn es keine strengen Beweise gibt?</a></li>
<li><a href="../de430842/index.html">Wir verwenden Blockchain, um Korruption und Cybermobbing zu bekämpfen</a></li>
<li><a href="../de430844/index.html">So wählen Sie eine Batterie für die USV</a></li>
<li><a href="../de430846/index.html">Was ist neu: Details zur Implementierung der neuen Zen 2-Architektur wurden bekannt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>