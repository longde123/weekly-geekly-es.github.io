<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÑ üôåüèº üë≤üèº Kotlin: Statik, die es nicht gibt üë¥ üò© üë≤üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird die Verwendung von Statik in Kotlin beschrieben. 
 Fangen wir an. 
 Kotlin hat keine statische Aufladung! 

 Dies ist in der of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: Statik, die es nicht gibt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/430836/"><img src="https://habrastorage.org/webt/a4/lt/ih/a4ltihdnjfobccfvjc3sx3j3bm0.png"><br>  In diesem Artikel wird die Verwendung von Statik in Kotlin beschrieben. <br>  Fangen wir an. <br>  Kotlin hat keine statische Aufladung! <br><br>  Dies ist in der offiziellen Dokumentation angegeben. <br><br>  Und es scheint, dass dies den Artikel beenden k√∂nnte.  Aber lassen Sie mich, wie so?  Wenn Sie in Android Studio Java-Code in eine Kotlin-Datei einf√ºgen, wird der Smart Converter die Magie ausf√ºhren, alles in Code in der richtigen Sprache umwandeln und es wird funktionieren!  Aber was ist mit der vollst√§ndigen Kompatibilit√§t mit Java? <br><br>  Zu diesem Zeitpunkt wird jeder Entwickler, der etwas √ºber das Fehlen von Statik in Kotlin erf√§hrt, in die Dokumentation und in die Foren gehen, um dieses Problem zu beheben.  Lassen Sie uns nachdenklich und sorgf√§ltig zusammenkommen.  Ich werde versuchen, bis zum Ende dieses Artikels so wenig Fragen wie m√∂glich zu beantworten. <a name="habracut"></a><br><br>  Was ist die Statik in Java?  Es gibt: <br><ul><li>  Klasse statische Felder </li><li>  statische Klassenmethoden </li><li>  statisch verschachtelte Klassen </li></ul><br><br>  Lassen Sie uns ein Experiment durchf√ºhren (dies ist das erste, was mir in den Sinn kommt). <br><br>  Erstellen Sie eine einfache Java-Klasse: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassJava1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String value)</span></span></span></span>{ staticField = value; } }</code> </pre> <br>  Hier ist alles einfach: In der Klasse erstellen wir ein statisches Feld und eine statische Methode.  Wir machen alles √∂ffentlich f√ºr Experimente mit Zugang von au√üen.  Wir verbinden das Feld und die Methode logisch. <br><br>  Erstellen Sie nun eine leere Kotlin-Klasse und versuchen Sie, den gesamten Inhalt der SimpleClassJava1-Klasse in diese zu kopieren.  Wir beantworten die resultierende Frage zur Konvertierung mit ‚ÄûJa‚Äú und sehen, was passiert ist: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: String)</span></span></span><span class="hljs-function"> </span></span>{ staticField = value } }</code> </pre><br>  Es scheint, dass dies nicht genau das ist, was wir brauchen ... Um dies sicherzustellen, werden wir den Bytecode dieser Klasse in Java-Code konvertieren und sehen, was passiert ist: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(value, <span class="hljs-string"><span class="hljs-string">"value"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = value; } }</code> </pre><br>  Ja  Alles ist genau so, wie es schien.  Hier riecht es nicht nach Statik.  Der Konverter hat den statischen Modifikator in der Signatur einfach abgeschnitten, als w√§re er nicht vorhanden.  F√ºr alle F√§lle werden wir sofort eine Schlussfolgerung ziehen: Vertraue dem Konverter nicht blind, manchmal kann es unangenehme √úberraschungen bringen. <br><br>  √úbrigens h√§tte die Konvertierung desselben Java-Codes in Kotlin vor etwa sechs Monaten zu einem etwas anderen Ergebnis gef√ºhrt.  Also nochmal: Vorsicht bei der automatischen Konvertierung! <br><br>  Wir experimentieren weiter. <br><br>  Wir gehen zu jeder Klasse auf Kotlin und versuchen, die statischen Elemente der Java-Klasse darin aufzurufen: <br><pre> <code class="java hljs">SimpleClassJava1.setStaticValue(<span class="hljs-string"><span class="hljs-string">"hi!"</span></span>) SimpleClassJava1.staticField = <span class="hljs-string"><span class="hljs-string">"hello!!!"</span></span></code> </pre><br>  So!  Alles ist perfekt aufgerufen, selbst die automatische Vervollst√§ndigung des Codes sagt uns alles!  Ziemlich neugierig. <br><br>  Kommen wir nun zum wesentlicheren Teil.  In der Tat haben die Sch√∂pfer von Kotlin beschlossen, sich von der Statik in der Form zu entfernen, in der wir sie gewohnt sind.  Warum wir genau das getan haben und nicht anders diskutieren - es gibt viele Streitigkeiten und Meinungen zu diesem Thema im Netzwerk.  Wir werden nur herausfinden, wie wir damit leben sollen.  Nat√ºrlich wurden wir nicht nur der Statik beraubt.  Kotlin gibt uns eine Reihe von Werkzeugen, mit denen wir den Verlust kompensieren k√∂nnen.  Sie sind f√ºr den Innenbereich geeignet.  Und die versprochene volle Kompatibilit√§t mit Java-Code.  Lass uns gehen! <br><br>  Das schnellste und einfachste, was Sie realisieren und verwenden k√∂nnen, ist die Alternative, die wir anstelle statischer Methoden anbieten - Funktionen auf Paketebene.  Was ist das?  Dies ist eine Funktion, die keiner Klasse angeh√∂rt.  Das hei√üt, diese Art von Logik befindet sich irgendwo im Paketraum in einem Vakuum.  Wir k√∂nnen es in jeder Datei innerhalb des Pakets beschreiben, die uns interessiert.  Benennen Sie diese Datei beispielsweise JustFun.kt und platzieren Sie sie im Paket <code>com.example.mytestapplication</code> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.<span class="hljs-function"><span class="hljs-function">mytestapplication fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br><br>  Konvertieren Sie den Bytecode dieser Datei in Java und schauen Sie hinein: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JustFunKt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } }</span></span></code> </pre><br>  Wir sehen, dass in Java eine Klasse erstellt wird, deren Name den Namen der Datei ber√ºcksichtigt, in der die Funktion beschrieben wird, und die Funktion selbst wird zu einer statischen Methode. <br><br>  Wenn wir nun die <code>testFun</code> Funktion in Kotlin von einer Klasse (oder derselben Funktion) aus aufrufen m√∂chten, die sich im <code>package com.example.mytestapplication</code> ( <code>package com.example.mytestapplication</code> dasselbe Paket wie die Funktion), k√∂nnen wir einfach ohne zus√§tzliche Tricks darauf zugreifen.  Wenn wir es aus einem anderen Paket aufrufen, m√ºssen wir importieren, was uns vertraut ist und normalerweise f√ºr Klassen gilt: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.pavka.mytestapplication.testFun</code> </pre> <br>  Wenn wir √ºber das Aufrufen der Funktion t <code>estFun</code> aus Java-Code sprechen, m√ºssen wir die Funktion immer importieren, unabh√§ngig davon, von welchem ‚Äã‚ÄãPaket wir sie aufrufen: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> com.example.pavka.mytestapplication.ForFunKt.testFun;</code> </pre> <br>  In der Dokumentation hei√üt es, dass in den meisten F√§llen anstelle statischer Methoden die Verwendung von Funktionen auf Paketebene ausreicht.  Meiner pers√∂nlichen Meinung nach (die nicht mit der Meinung aller anderen √ºbereinstimmen muss) ist diese Methode zur Implementierung der Statik jedoch nur f√ºr kleine Projekte geeignet. <br>  Es stellt sich heraus, dass diese Funktionen keiner Klasse explizit angeh√∂ren.  Visuell sieht ihr Aufruf wie ein Aufruf der Klassenmethode (oder ihres √ºbergeordneten Elements) aus, in der wir uns befinden, was manchmal verwirrend sein kann.  Nun und die Hauptsache - es kann nur eine Funktion mit diesem Namen im Paket geben.  Selbst wenn wir versuchen, die gleichnamige Funktion in einer anderen Datei zu erstellen, gibt das System einen Fehler aus.  Wenn wir √ºber gro√üe Projekte sprechen, haben wir zum Beispiel ziemlich oft verschiedene Fabriken mit statischen Methoden mit demselben Namen. <br><br>  Schauen wir uns andere Alternativen zur Implementierung statischer Methoden und Felder an. <br><br>  Erinnern Sie sich an das statische Feld einer Klasse.  Dies ist ein Klassenfeld, das zu der Klasse geh√∂rt, in der es deklariert ist, aber nicht zu einer bestimmten Instanz der Klasse geh√∂rt, dh es wird in einer einzelnen Instanz f√ºr die gesamte Klasse erstellt. <br><br>  Kotlin bietet uns f√ºr diese Zwecke an, eine zus√§tzliche Entit√§t zu verwenden, die auch in einer einzigen Kopie vorhanden ist.  Mit anderen Worten, Singleton. <br><br>  Kotlin hat ein Objektschl√ºsselwort, um Singletones zu deklarieren. <br><br><pre> <code class="java hljs">object MySingltoneClass { <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre> <br><br>  Solche Objekte werden tr√§ge initialisiert, dh zum Zeitpunkt des ersten Aufrufs. <br><br>  Ok, es gibt auch Singletones in Java. Wo sind die Statistiken? <br><br>  F√ºr jede Klasse in Kotlin k√∂nnen wir einen Begleiter oder ein Begleitobjekt erstellen.  Ein Singleton, der an eine bestimmte Klasse gebunden ist.  Dies kann mit zwei <code>companion  object</code> zusammen erfolgen: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } } }</span></span></code> </pre><br><br>  Hier haben wir die <code>SimpleClassKotlin1</code> Klasse, in der wir einen Singleton mit dem Objektschl√ºsselwort deklarieren und an das Objekt binden, in dem er mit dem Companion-Schl√ºsselwort deklariert ist.  Hier k√∂nnen Sie darauf achten, dass im Gegensatz zur vorherigen Singleton-Deklaration (MySingltoneClass) der Name der Singleton-Klasse nicht angegeben wird.  Wenn das Objekt als Begleiter deklariert ist, darf es seinen Namen nicht angeben.  Dann wird es automatisch <code>Companion</code> .  Bei Bedarf k√∂nnen wir eine Instanz der Companion-Klasse folgenderma√üen abrufen: <br><pre> <code class="java hljs">val companionInstance = SimpleClassKotlin1.Companion</code> </pre> <br>  Ein Aufruf der Eigenschaften und Methoden einer Begleitklasse kann jedoch direkt √ºber einen Aufruf der Klasse erfolgen, an die sie angeh√§ngt ist: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionField SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>)</code> </pre><br>  Es sieht schon so aus, als w√ºrde man statische Felder und Klassen aufrufen, oder? <br><br>  Bei Bedarf k√∂nnen wir der Begleitklasse einen Namen geben, in der Praxis wird dies jedoch sehr selten durchgef√ºhrt.  Von den interessanten Merkmalen der zugeh√∂rigen Klassen kann festgestellt werden, dass sie wie jede gew√∂hnliche Klasse Schnittstellen implementieren kann, was uns manchmal helfen kann, dem Code etwas mehr Ordnung zu verleihen: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactoryInterface</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: T } class SimpleClassKotlin1 </span></span>{ companion object : FactoryInterface&lt;MyClass&gt; { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: MyClass </span></span>= MyClass() } }</code> </pre> <br><br>  Eine Begleitklasse kann nur eine Klasse haben.  Niemand verbietet uns jedoch, eine beliebige Anzahl von Singleton-Objekten innerhalb der Klasse zu deklarieren. In diesem Fall m√ºssen wir jedoch den Namen dieser Klasse explizit angeben und diesen Namen entsprechend angeben, wenn wir auf die Felder und Methoden dieser Klasse verweisen. <br><br>  Wenn wir von den als Objekt deklarierten Klassen sprechen, k√∂nnen wir sagen, dass wir auch verschachtelte Objekte in ihnen deklarieren k√∂nnen, aber wir k√∂nnen kein Begleitobjekt in ihnen deklarieren. <br><br>  Es ist Zeit, "unter die Haube" zu schauen.  Nehmen Sie an unserer einfachen Klasse teil: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } } object OneMoreObject { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ } }</code> </pre><br><br>  Dekompilieren Sie nun den Bytecode in Java: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneMoreObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.OneMoreObject INSTANCE; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ value = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { SimpleClassKotlin1.OneMoreObject var0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.OneMoreObject(); INSTANCE = var0; value = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SimpleClassKotlin1.companionField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); SimpleClassKotlin1.companionField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String vaue)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(vaue, <span class="hljs-string"><span class="hljs-string">"vaue"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre><br>  Wir schauen, was passiert ist. <br><br>  Die Eigenschaft des Begleitobjekts wird als statisches Feld unserer Klasse dargestellt: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>;</code> </pre> <br><br>  Dies scheint genau das zu sein, was wir wollten.  Dieses Feld ist jedoch privat und wird √ºber den Getter und Setter unserer Companion-Klasse aufgerufen, die hier als <code>public static final class</code> , und ihre Instanz wird als Konstante dargestellt: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br><br>  Die CompanionFun-Funktion wurde nicht zur statischen Methode unserer Klasse (wahrscheinlich sollte dies nicht der Fall sein).  Es blieb die Funktion eines Singletons, der in der SimpleClassKotlin1-Klasse initialisiert wurde.  Wenn Sie jedoch dar√ºber nachdenken, ist dies logischerweise ungef√§hr dasselbe. <br><br>  Bei der <code>OneMoreObject</code> Klasse <code>OneMoreObject</code> Situation sehr √§hnlich.  Es ist nur erw√§hnenswert, dass hier im Gegensatz zum Begleiter das Feld der <code>SimpleClassKotlin1</code> nicht in die <code>SimpleClassKotlin1</code> Klasse <code>SimpleClassKotlin1</code> , sondern in <code>OneMoreObject</code> blieb, sondern auch statisch wurde und den generierten Getter und Setter erhielt. <br><br>  Versuchen wir, all das zu verstehen. <br>  Wenn wir statische Felder oder Klassenmethoden in Kotlin implementieren m√∂chten, sollten wir dazu das in dieser Klasse deklarierte Companion-Objekt verwenden. <br>  Das Aufrufen dieser Felder und Funktionen von Kotlin aus sieht genauso aus wie das Aufrufen der Statik in Java.  Was aber, wenn wir versuchen, diese Felder und Funktionen in Java aufzurufen? <br><br>  Die automatische Vervollst√§ndigung teilt uns mit, dass die folgenden Anrufe verf√ºgbar sind: <br><pre> <code class="java hljs">SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.setCompanionField(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.getCompanionField();</code> </pre><br>  Das hei√üt, hier gehen wir nicht davon aus, den Namen des Begleiters direkt anzugeben.  Dementsprechend wird hier der Name verwendet, der dem Standard-Begleitobjekt zugewiesen wurde.  Nicht sehr praktisch, oder? <br><br>  Trotzdem haben die Entwickler von Kotlin es m√∂glich gemacht, es in Java bekannter zu machen.  Daf√ºr gibt es mehrere M√∂glichkeiten. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span></code> </pre> <br>  Wenn wir diese Annotation auf das <code>companionField</code> Feld unseres <code>companionField</code> Objekts anwenden, sehen wir beim Konvertieren von Bytecode in Java, dass das statische Feld <code>companionField</code> SimpleClassKotlin1 nicht mehr privat, sondern √∂ffentlich ist und der Getter und Setter f√ºr CompanionField in der statischen <code>Companion</code> Klasse verschwunden sind.  Jetzt k√∂nnen wir auf √ºbliche Weise √ºber Java-Code auf <code>companionField</code> zugreifen. <br><br>  Die zweite M√∂glichkeit besteht darin, einen <code>lateinit</code> Modifikator f√ºr die Eigenschaften des Begleitobjekts anzugeben, Eigenschaften mit sp√§ter Initialisierung.  Vergessen Sie nicht, dass dies nur f√ºr var-Eigenschaften gilt und sein Typ nicht null und nicht primitiv sein sollte.  Vergessen Sie nicht die Regeln f√ºr den Umgang mit solchen Eigenschaften. <br><br><pre> <code class="java hljs">lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lateinitField: String</code> </pre> <br>  Und noch eine M√∂glichkeit: Wir k√∂nnen die Eigenschaft des Begleitobjekts als Konstante deklarieren, indem wir den Modifikator const angeben.  Es ist leicht zu erraten, dass dies eine Val-Eigenschaft sein sollte. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val myConstant = <span class="hljs-string"><span class="hljs-string">"CONSTANT"</span></span></code> </pre> <br>  In jedem dieser F√§lle enth√§lt der generierte Java-Code das √ºbliche √∂ffentliche statische Feld. Im Fall von const ist dieses Feld ebenfalls endg√ºltig.  Nat√ºrlich lohnt es sich zu verstehen, dass jeder dieser drei F√§lle seinen eigenen logischen Zweck hat und nur der erste speziell f√ºr die einfache Verwendung mit Java entwickelt wurde. Der Rest erh√§lt dieses ‚ÄûBr√∂tchen‚Äú wie in einer Last. <br><br>  Es sollte separat beachtet werden, dass der const-Modifikator f√ºr Eigenschaften von Objekten, Begleitobjekten und f√ºr Eigenschaften der Paketebene verwendet werden kann.  Im letzteren Fall erhalten wir dasselbe wie bei Verwendung der Funktionen auf Paketebene und mit denselben Einschr√§nkungen.  Java-Code wird mit einem statischen √∂ffentlichen Feld in der Klasse generiert, dessen Name den Namen der Datei ber√ºcksichtigt, in der wir die Konstante beschrieben haben.  Ein Paket kann nur eine Konstante mit dem angegebenen Namen haben. <br><br>  Wenn die Funktion des Begleitobjekts beim Generieren von Java-Code auch in eine statische Methode konvertiert werden soll, m√ºssen wir dazu die Annotation <code>@JvmStatic</code> auf diese Funktion anwenden. <br>  Es ist auch zul√§ssig, die Annotation <code>@JvmStatic</code> auf die Eigenschaften von Begleitobjekten (und nur auf Singleton-Objekte) anzuwenden.  In diesem Fall wird die Eigenschaft nicht zu einem statischen Feld, sondern es wird ein statischer Getter und Setter f√ºr diese Eigenschaft generiert.  Schauen Sie sich zum besseren Verst√§ndnis diese Kotlin-Klasse an: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre><br><br>  In diesem Fall sind die folgenden Aufrufe von Java aus g√ºltig: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); x = SimpleClassKotlin1.getStaticField(); SimpleClassKotlin1.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>); SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); x = SimpleClassKotlin1.Companion.getStaticField(); SimpleClassKotlin1.Companion.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br><br>  Die folgenden Aufrufe sind von Kotlin g√ºltig: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.staticField SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.Companion.staticField</code> </pre> <br><br>  Es ist klar, dass Sie f√ºr Java die ersten 3 und f√ºr Kotlin die ersten 2 verwenden sollten. Der Rest der Aufrufe ist nur g√ºltig. <br><br>  Nun bleibt letzteres zu kl√§ren.  Was ist mit statisch verschachtelten Klassen?  Hier ist alles einfach - das Analogon einer solchen Klasse in Kotlin ist eine regul√§r verschachtelte Klasse ohne Modifikatoren: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre><br><br>  Nach der Konvertierung des Bytecodes in Java sehen wir: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br><br>  Das brauchen wir in der Tat.  Wenn wir nicht m√∂chten, dass die Klasse endg√ºltig ist, geben wir im Kotlin-Code den offenen Modifikator daf√ºr an.  Ich erinnerte mich nur f√ºr den Fall daran. <br><br>  Ich denke, Sie k√∂nnen zusammenfassen.  In Kotlin selbst gibt es, wie gesagt, keine Statik in der Form, in der wir es gewohnt sind, sie zu sehen.  Mit den vorgeschlagenen Tools k√∂nnen wir jedoch alle Arten von Statiken im generierten Java-Code implementieren.  Volle Kompatibilit√§t mit Java wird ebenfalls bereitgestellt, und wir k√∂nnen statische Felder und Methoden von Java-Klassen direkt von Kotlin aus aufrufen. <br>  In den meisten F√§llen erfordert die Implementierung einer Statistik in Kotlin einige weitere Codezeilen.  Vielleicht ist dies einer der wenigen oder vielleicht der einzige Fall, in dem Sie mehr in Kotlin schreiben m√ºssen.  Man gew√∂hnt sich jedoch schnell daran. <br>  Ich denke, dass Sie in Projekten, in denen Kotlin- und Java-Code gemeinsam genutzt werden, flexibel an die Wahl der verwendeten Sprache herangehen k√∂nnen.  Zum Beispiel scheint mir Java besser zum Speichern von Konstanten geeignet zu sein.  Aber auch hier lohnt es sich, wie in vielen anderen Dingen, sich vom gesunden Menschenverstand und den Regeln f√ºr das Schreiben von Code im Projekt leiten zu lassen. <br><br>  Und am Ende des Artikels finden Sie solche Informationen.  Vielleicht wird Kotlin auch in Zukunft noch einen statischen Modifikator haben, der viele Probleme beseitigt und das Leben der Entwickler erleichtert, und der Code ist k√ºrzer.  Ich habe diese Annahme getroffen, indem ich den entsprechenden Text in Absatz 17 der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kotlin-Funktionsbeschreibungen gefunden habe</a> . <br>  Dieses Dokument stammt zwar aus dem Mai 2017 und ist auf dem Hof ‚Äã‚Äãbereits Ende 2018. <br><br>  Das ist alles f√ºr mich.  Ich denke, dass das Thema detailliert aussortiert wurde.  Fragen schreiben Sie in den Kommentaren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430836/">https://habr.com/ru/post/de430836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430826/index.html">Wie man einen Entwicklungsmanager entwickelt</a></li>
<li><a href="../de430828/index.html">Erfahrung in der Verwendung von LCD-Displays auf Basis von MELT-Produkten</a></li>
<li><a href="../de430830/index.html">Schwarzer Freitag, Traditionen und englische Redewendungen zum Einkaufen</a></li>
<li><a href="../de430832/index.html">Human Black Friday Preis</a></li>
<li><a href="../de430834/index.html">10 Tods√ºnden des Sprechers</a></li>
<li><a href="../de430838/index.html">Die Wunder des Crowd-Marketings oder wie man ein Unternehmen mit Bewertungen f√∂rdert</a></li>
<li><a href="../de430840/index.html">Welche Beweise k√∂nnen Mathematiker √ºberzeugen, wenn es keine strengen Beweise gibt?</a></li>
<li><a href="../de430842/index.html">Wir verwenden Blockchain, um Korruption und Cybermobbing zu bek√§mpfen</a></li>
<li><a href="../de430844/index.html">So w√§hlen Sie eine Batterie f√ºr die USV</a></li>
<li><a href="../de430846/index.html">Was ist neu: Details zur Implementierung der neuen Zen 2-Architektur wurden bekannt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>