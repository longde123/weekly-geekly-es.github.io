<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍💻 👐🏿 🔈 Memindai kode Orchard CMS for Bugs 🐝 🦎 😳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini mengulas hasil pemeriksaan kedua proyek Orchard dengan analisa statis PVS-Studio. Orchard adalah sistem pengelola konten sumber terbuka ya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memindai kode Orchard CMS for Bugs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/472360/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/c02/394/ef5c023947badf157fb4c97b6562ab91.png" alt="Gambar 6"></div><br>  Artikel ini mengulas hasil pemeriksaan kedua proyek Orchard dengan analisa statis PVS-Studio.  Orchard adalah sistem pengelola konten sumber terbuka yang dikirimkan sebagai bagian dari Galeri Open Source ASP.NET di bawah Yayasan Outercurve nirlaba.  Pemeriksaan hari ini sangat menarik karena baik proyek maupun penganalisa telah berjalan jauh sejak pemeriksaan pertama, dan kali ini kita akan melihat pesan diagnostik baru dan beberapa bug yang bagus. <br><a name="habracut"></a><br>  <b>Tentang Orchard CMS</b> <br><br>  Kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memeriksa</a> Orchard tiga tahun lalu.  Alat analisis C # PVS-Studio telah sangat berkembang sejak saat itu: kami telah meningkatkan analisis aliran data, menambahkan analisis antar-prosedur dan diagnostik baru, dan memperbaiki sejumlah kesalahan positif.  Lebih dari itu, cek kedua mengungkapkan bahwa pengembang Orchard telah memperbaiki semua bug yang dilaporkan dalam artikel pertama, yang berarti kami telah mencapai tujuan kami, yaitu membuat mereka membuat kode mereka lebih baik. <br><br>  Saya berharap mereka akan memperhatikan artikel ini juga dan melakukan perbaikan yang diperlukan atau, lebih baik, mengadopsi PVS-Studio untuk digunakan secara teratur.  Sebagai pengingat, kami menyediakan pengembang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open-source</a> dengan lisensi gratis.  Ngomong-ngomong, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi</a> lain yang bisa dinikmati proyek berpemilik juga. <br><br>  Kode sumber Orchard tersedia untuk diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Deskripsi proyek lengkap ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Jika Anda belum memiliki salinan PVS-Studio, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh</a> versi uji coba.  Saya menggunakan PVS-Studio 7.05 Beta dan akan menyertakan beberapa peringatannya di artikel ini.  Saya harap ulasan ini akan meyakinkan Anda bahwa PVS-Studio adalah alat yang berguna.  Perlu diingat bahwa ini dimaksudkan untuk digunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara teratur</a> . <br><br>  <b>Hasil analisis</b> <br><br>  Berikut adalah beberapa angka dari cek pertama Orchard sehingga Anda tidak perlu beralih di antara dua artikel untuk perbandingan. <br><br>  Selama pemeriksaan sebelumnya, "kami melakukan analisis terhadap semua file kode sumber (3739 item) dengan ekstensi .cs.  Secara total ada 214.564 baris kode.  Hasil cek itu 137 peringatan.  Untuk lebih tepatnya, ada 39 peringatan tingkat pertama (tinggi).  Ada juga peringatan tingkat 60 (menengah) kedua. " <br><br>  Versi Orchard saat ini terdiri dari 2.767 file .cs, yaitu sekitar seribu file lebih kecil.  Perampingan dan penggantian nama repositori menunjukkan bahwa pengembang telah mengisolasi inti proyek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">commit 966</a> ), yang merupakan 108.287 LOC.  Penganalisa mengeluarkan 153 peringatan: 33 tingkat pertama dan 70 tingkat kedua.  Kami biasanya tidak memasukkan peringatan tingkat ketiga, dan saya akan tetap berpegang pada tradisi. <br><br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3110</a> Kemungkinan rekursi tak terbatas di dalam metode 'TryValidateModel'.  PrefixedModuleUpdater.cs 48 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TryValidateModel(model, Prefix(prefix)); }</code> </pre> <br>  Mari kita mulai dengan bug rekursi yang tak terbatas, seperti yang kita lakukan di artikel pertama.  Kali ini niat pasti pengembang tidak jelas, tetapi saya perhatikan bahwa metode <i>TryValidateModel</i> memiliki versi kelebihan beban dengan satu parameter: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _updateModel.TryValidateModel(model); }</code> </pre> <br>  Saya pikir, seperti halnya pada versi overload, pengembang bermaksud memanggil metode tersebut melalui <i>_updateModel.</i>  Kompiler tidak memperhatikan kesalahan;  <i>_updateModel</i> bertipe <i>IUpdateModel</i> , dan kelas saat ini juga mengimplementasikan antarmuka ini.  Karena metode ini tidak menyertakan pemeriksaan terhadap <i>StackOverflowException</i> , itu mungkin tidak pernah dipanggil, meskipun saya tidak akan mengandalkan itu.  Jika asumsi saya benar, versi tetap akan terlihat seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _updateModel.TryValidateModel(model, Prefix(prefix)); }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3008 Variabel</a> 'konten' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 197, 190. DynamicCacheTagHelper.cs 197 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... IHtmlContent content; .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> output.GetChildContentAsync(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _cacheScopeManager.ExitScope(); } content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ProcessContentAsync(output, cacheContext); .... }</code> </pre> <br>  Penganalisa mendeteksi dua tugas untuk <i>konten</i> variabel lokal <i>.</i>  <i>GetChildContentAsync</i> adalah metode pustaka yang terlalu jarang digunakan bagi kami untuk mengambil kesulitan untuk memeriksa dan membubuhi keterangan.  Jadi, saya khawatir, baik kita maupun analis tidak tahu apa-apa tentang objek pengembalian metode dan efek sampingnya.  Tapi kami tahu pasti bahwa menetapkan nilai kembali ke <i>konten</i> tidak masuk akal jika tidak digunakan lebih lanjut dalam kode.  Mungkin itu hanya operasi yang berlebihan daripada kesalahan.  Saya tidak bisa mengatakan bagaimana tepatnya ini harus diperbaiki, jadi saya serahkan kepada pengembang. <br><br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'itemTag'.  CoreShapes.cs 92 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IHtmlContent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ItemTag....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> itemTagName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ItemTag != <span class="hljs-string"><span class="hljs-string">"-"</span></span>) { itemTagName = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(ItemTag) ? <span class="hljs-string"><span class="hljs-string">"li"</span></span> : ItemTag; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemTag = String.IsNullOrEmpty(itemTagName) ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : ....; .... itemTag.InnerHtml.AppendHtml(itemContent); listTag.InnerHtml.AppendHtml(itemTag); ++index; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listTag; }</code> </pre> <br>  Alat analisis mendeteksi dereferensi <i>itemTag yang</i> tidak aman.  Cuplikan ini adalah contoh yang baik tentang bagaimana alat analisis statis berbeda dari pengembang manusia yang melakukan tinjauan kode.  Metode ini memiliki parameter bernama <i>ItemTag</i> dan variabel lokal bernama <i>itemTag</i> .  Tidak perlu memberi tahu Anda itu membuat perbedaan besar ke kompiler!  Ini adalah dua variabel yang berbeda, meskipun terkait.  Cara mereka terkait adalah melalui variabel ketiga, <i>itemTagName.</i>  Berikut urutan langkah menuju kemungkinan pengecualian: jika argumen <i>ItemTag</i> sama dengan "-", tidak ada nilai yang akan ditetapkan ke <i>itemTagName</i> , jadi itu akan tetap menjadi referensi nol, dan jika itu adalah referensi nol, maka variabel lokal <i>itemTag</i> akan berubah menjadi referensi nol juga.  Menurut pendapat saya, lebih baik untuk memiliki pengecualian yang dilemparkan mengikuti cek string. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IHtmlContent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ItemTag....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> itemTagName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ItemTag != <span class="hljs-string"><span class="hljs-string">"-"</span></span>) { itemTagName = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(ItemTag) ? <span class="hljs-string"><span class="hljs-string">"li"</span></span> : ItemTag; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemTag = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(String.IsNullOrEmpty(itemTag)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> .... .... itemTag.InnerHtml.AppendHtml(itemContent); listTag.InnerHtml.AppendHtml(itemTag); ++index; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listTag; }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3095 Objek</a> 'remoteClient' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 49, 51. ImportRemoteInstanceController.cs 49 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Import</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImportViewModel model</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> remoteClient = remoteClientList.RemoteClients.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> apiKey = Encoding.UTF8.GetString(....(remoteClient.ProtectedApiKey)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remoteClient == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || ....) { .... } .... }</code> </pre> <br>  Penganalisa mendeteksi dereference dari <i>remoteClient</i> diikuti oleh pemeriksaan nol beberapa baris kemudian.  Ini memang potensi <i>NullReferenceException</i> karena metode <i>FirstOrDefault</i> dapat mengembalikan nilai default (yang <i>nol</i> untuk tipe referensi).  Saya kira cuplikan ini dapat diperbaiki dengan hanya memindahkan pemeriksaan sehingga yang mendahului operasi dereference: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Import</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImportViewModel model</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> remoteClient = remoteClientList.RemoteClients.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remoteClient != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> apiKey = UTF8.GetString(....remoteClient.ProtectedApiKey); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } .... }</code> </pre> <br>  Atau mungkin itu harus diperbaiki dengan mengganti <i>FirstOrDefault</i> dengan <i>First</i> dan menghapus cek sama sekali. <br><br>  <b>Peringatan oleh PVS-Studio 7.05 Beta:</b> <br><br>  Sekarang, kami telah memberi anotasi pada semua metode <i>orDefault</i> <i>LINQ</i> .  Informasi ini akan digunakan oleh diagnostik baru yang sedang kami kerjakan: mendeteksi kasus-kasus di mana nilai-nilai yang dikembalikan oleh metode-metode ini direferensikan tanpa pemeriksaan sebelumnya.  Setiap metode <i>orDefault</i> memiliki rekanan yang melempar pengecualian jika tidak ada elemen yang cocok yang ditemukan.  Pengecualian ini akan lebih membantu dalam melacak masalah daripada <i>NullReferenceException</i> abstrak. <br><br>  Saya tidak bisa tidak membagikan hasil yang saya dapatkan dari diagnostik ini pada proyek Orchard.  Ada 27 tempat yang berpotensi berbahaya.  Inilah beberapa di antaranya: <br><br>  ContentTypesAdminNodeNavigationBuilder.cs 71: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> treeBuilder = treeNodeBuilders.Where(....).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> treeBuilder.BuildNavigationAsync(childNode, builder, treeNodeBuilders);</code> </pre> <br>  ListPartDisplayDriver.cs 217: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentTypePartDefinition = ....Parts.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentTypePartDefinition.Settings....;</code> </pre> <br>  ContentTypesAdminNodeNavigationBuilder.cs 113: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeEntry = node.ContentTypes.Where(....).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AddPrefixToClasses(typeEntry.IconClass);</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan null dereference nilai pengembalian metode.  Pertimbangkan untuk memeriksa: CreateScope ().  SetupService.cs 136 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupInternalAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SetupContext context</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shellContext = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ....) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> shellContext.CreateScope().UsingAsync(....); } .... }</code> </pre> <br>  Penganalisa menyebutkan dereferensi nilai yang dikembalikan oleh metode <i>CreateScope</i> .  <i>CreateScope</i> adalah metode kecil, jadi inilah implementasinya yang lengkap: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ShellScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_placeHolder) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ShellScope(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A new scope can be only used on a non released shell. if (!released) { return scope; } scope.Dispose(); return null; }</span></span></code> </pre> <br>  Seperti yang Anda lihat, ada dua kasus di mana ia dapat mengembalikan <i>nol</i> .  Analisator tidak tahu cabang mana dari aliran eksekusi yang akan mengikuti, jadi ia bermain aman dan melaporkan kode sebagai mencurigakan.  Jika saya menulis kode seperti itu, saya akan segera menulis cek nol. <br><br>  Mungkin pendapat saya bias, tetapi saya percaya bahwa setiap metode asinkron harus dilindungi dari <i>NullReferenceException</i> sebanyak mungkin karena debugging hal-hal seperti itu jauh dari menyenangkan. <br><br>  Dalam kasus khusus ini, metode <i>CreateScope</i> disebut empat kali: dua panggilan itu disertai dengan pemeriksaan dan dua lainnya tidak.  Dua panggilan terakhir (tanpa pemeriksaan) tampaknya merupakan klon copy-tempel (kelas yang sama, metode yang sama, cara yang sama untuk mendereferensi hasil yang dipanggil dengan MenggunakanAsync)  Yang pertama dari dua panggilan itu ditunjukkan di atas, dan Anda mungkin yakin yang kedua memicu peringatan yang sama: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan nol dereferensi nilai pengembalian metode.  Pertimbangkan untuk memeriksa: CreateScope ().  SetupService.cs 192 <br><br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3127</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'AccessTokenSecret' harus digunakan sebagai ganti 'ConsumerSecret' TwitterClientMessageHandler.cs 52 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureOAuthAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage request</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.ConsumerSecret = protrector.Unprotect(settings.ConsumerSecret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.AccessTokenSecret = protrector.Unprotect(settings.AccessTokenSecret); .... }</code> </pre> <br>  Itu kesalahan salin-tempel yang klasik.  <i>ConsumerSecret</i> diperiksa dua kali, sementara <i>AccessTokenSecret</i> tidak diperiksa sama sekali.  Jelas, ini diperbaiki sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureOAuthAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage request</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.ConsumerSecret = protrector.Unprotect(settings.ConsumerSecret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.AccessTokenSecret)) settings.AccessTokenSecret = protrector.Unprotect(settings.AccessTokenSecret); .... }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3139</a> Dua atau lebih cabang kasus melakukan tindakan yang sama.  SerialDocumentExecuter.cs 23 <br><br>  Bug salin-tempel lainnya.  Untuk kejelasan, inilah implementasi kelas yang lengkap (ini kecil). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerialDocumentExecuter</span></span> : <span class="hljs-title"><span class="hljs-title">DocumentExecuter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy ParallelExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParallelExecutionStrategy(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy SerialExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerialExecutionStrategy(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy SubscriptionExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubscriptionExecutionStrategy(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IExecutionStrategy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectExecutionStrategy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; } } }</code> </pre> <br>  Alat analisis tidak menyukai dua cabang <i>kasus yang</i> identik.  Memang, kelas memiliki tiga entitas, sedangkan pernyataan switch hanya mengembalikan dua dari mereka.  Jika perilaku ini dimaksudkan dan entitas ketiga sebenarnya tidak dimaksudkan untuk digunakan, kode dapat ditingkatkan dengan menghapus cabang ketiga setelah menggabungkan keduanya sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  Jika ini adalah bug salin-tempel, bidang pengembalian duplikat pertama harus diperbaiki sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParallelExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  Atau harus cabang kasus kedua.  Saya tidak tahu detail proyek dan karena itu tidak dapat menentukan korelasi antara nama-nama jenis operasi dan strategi. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParallelExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'permintaan'.  GraphQLMiddleware.cs 148 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context....</span></span></span><span class="hljs-function">)</span></span> { .... GraphQLRequest request = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HttpMethods.IsPost(context.Request.Method)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HttpMethods.IsGet(context.Request.Method)) { .... request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLRequest(); .... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queryToExecute = request.Query; .... }</code> </pre> <br>  Variabel <i>permintaan</i> diberikan nilai yang berbeda dari <i>nol</i> beberapa kali di blok <i>if</i> pertama, tetapi setiap kali dengan kondisi bersarang.  Termasuk semua kondisi itu akan membuat contoh terlalu lama, jadi kita hanya akan pergi dengan yang pertama, yang memeriksa jenis metode http <i>IsGet</i> atau <i>IsPost</i> .  Kelas <i>Microsoft.AspNetCore.Http.HttpMethods</i> memiliki sembilan metode statis untuk memeriksa jenis kueri.  Oleh karena itu, meneruskan, misalnya, <i>Hapus</i> atau <i>Set</i> kueri ke metode <i>ExecuteAsync</i> akan mengarah pada peningkatan <i>NullReferenceException</i> .  Sekalipun metode seperti itu saat ini tidak didukung sama sekali, akan lebih bijak jika menambahkan cek pelempar pengecualian.  Bagaimanapun, persyaratan sistem dapat berubah.  Berikut ini contoh cek semacam itu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queryToExecute = request.Query; .... }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan null dereference nilai pengembalian metode.  Pertimbangkan untuk memeriksa: Dapatkan &lt;ContentPart&gt; (...).  ContentPartHandlerCoordinator.cs 190 <br><br>  Sebagian besar peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> lebih nyaman untuk dilihat dalam lingkungan pengembangan karena Anda memerlukan navigasi metode, penyorotan jenis, dan suasana IDE yang ramah.  Saya mencoba mengurangi teks contoh sebanyak mungkin agar tetap dapat dibaca.  Tetapi jika saya tidak melakukannya dengan benar atau jika Anda ingin menguji kemampuan pemrograman Anda dan mencari tahu sendiri, saya sarankan memeriksa hasil diagnostik ini pada proyek open-source atau hanya kode Anda sendiri. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LoadContentContext context</span></span></span><span class="hljs-function">)</span></span> { .... context.ContentItem.Get&lt;ContentPart&gt;(typePartDefinition.Name) .Weld(fieldName, fieldActivator.CreateInstance()); .... }</code> </pre> <br>  Penganalisa melaporkan baris ini.  Mari kita lihat metode <i>Get</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TElement Get&lt;TElement&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ContentElement contentElement....) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TElement : ContentElement { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TElement)contentElement.Get(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TElement), name); }</code> </pre> <br>  Itu menyebut versi kelebihannya.  Mari kita periksa juga: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ContentElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ContentElement contentElement....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementData = contentElement.Data[name] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> JObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementData == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } .... }</code> </pre> <br>  Ternyata jika kita mendapatkan entitas tipe yang tidak kompatibel dengan <i>JObject</i> dari <i>Data</i> menggunakan pengindeks <i>nama</i> , metode <i>Get</i> akan mengembalikan <i>nol</i> .  Saya tidak tahu pasti seberapa mungkin itu karena jenis-jenis ini dari perpustakaan <i>Newtonsoft.Json</i> , yang saya belum banyak bekerja.  Tetapi pembuat kode curiga bahwa elemen yang dicari mungkin tidak ada, jadi kita harus mengingatnya ketika mengakses hasil operasi baca juga.  Secara pribadi, saya akan memiliki pengecualian yang dilemparkan di <i>Dapatkan</i> pertama jika kami percaya simpul harus ada, atau tambahkan cek sebelum dereferensi jika ketidakhadiran simpul tidak mengubah logika keseluruhan (misalnya, kami mendapatkan nilai default). <br><br>  Solusi 1: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ContentElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ContentElement contentElement....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementData = contentElement.Data[name] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> JObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementData == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>.... } .... }</code> </pre> <br>  Solusi 2: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LoadContentContext context</span></span></span><span class="hljs-function">)</span></span> { .... context.ContentItem.Get&lt;ContentPart&gt;(typePartDefinition.Name) ?.Weld(fieldName, fieldActivator.CreateInstance()); .... }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'hasil'.  ContentQueryOrchardRazorHelperExtensions.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;IEnumerable&lt;ContentItem&gt;&gt; ContentQueryAsync(....) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> orchardHelper.QueryAsync(queryName, parameters); .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results) { .... } .... }</code> </pre> <br>  Ini adalah contoh yang cukup sederhana dibandingkan dengan yang sebelumnya.  Analisator curiga bahwa metode <i>QueryAsync</i> mungkin mengembalikan referensi nol.  Inilah implementasi metode ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IEnumerable&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> queryManager.GetQueryAsync(queryName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } .... }</code> </pre> <br>  Karena <i>GetQueryAsync</i> adalah metode antarmuka, Anda tidak dapat memastikan setiap implementasi, terutama jika kami menganggap bahwa proyek ini juga menyertakan versi berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Query&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> document = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetDocumentAsync(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(document.Queries.TryGetValue(name, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Beberapa panggilan ke fungsi eksternal dan akses cache membuat analisis <i>GetDocumentAsync</i> sulit, jadi anggap saja pemeriksaan diperlukan - terlebih lagi karena metode ini merupakan metode yang tidak sinkron. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;IEnumerable&lt;ContentItem&gt;&gt; ContentQueryAsync(....) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> orchardHelper.QueryAsync(queryName, parameters); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(results == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results) { .... } .... }</code> </pre> <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41f/fb1/e08/41ffb1e086795cd7ba94b22ed53ce33c.png" alt="Gambar 14"></div><br><br>  <b>Kesimpulan</b> <br><br>  Saya tidak bisa tidak menyebutkan kualitas kode Orchard yang tinggi!  Benar, ada beberapa cacat lain, yang tidak saya diskusikan di sini, tetapi saya menunjukkan semua bug yang paling parah.  Tentu saja, ini bukan untuk mengatakan bahwa memeriksa kode sumber Anda sekali dalam tiga tahun sudah cukup.  Anda akan mendapatkan hasil maksimal dari analisis statis jika Anda menggunakannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara teratur</a> karena ini adalah cara Anda dijamin untuk menangkap dan memperbaiki bug pada tahap pengembangan paling awal, di mana perbaikan bug termurah dan termudah. <br><br>  Meskipun pemeriksaan satu kali tidak banyak membantu, saya tetap mendorong Anda untuk mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> dan mencobanya di proyek Anda: siapa tahu, mungkin Anda akan menemukan beberapa bug yang menarik juga. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472360/">https://habr.com/ru/post/id472360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472350/index.html">Bagaimana Methodius menjadi Anna: pengalaman mengembangkan dan meluncurkan pengklasifikasi pesan suara. Bagian 1</a></li>
<li><a href="../id472352/index.html">TechnoText, episode II. Kami memberi tahu bagaimana penulis Habr hidup dan mengerjakan artikel</a></li>
<li><a href="../id472354/index.html">Antara kursi dan monitor duduk kerentanan utama dalam sistem: orang-VAP</a></li>
<li><a href="../id472356/index.html">Microsoft vs IBM: perubahan besar dalam dukungan Java</a></li>
<li><a href="../id472358/index.html">30 Oktober pukul 17:00 webinar "Menyebarkan kluster Kubernetes dalam sejam di CROC Cloud"</a></li>
<li><a href="../id472362/index.html">Kami mencari dan menganalisis kesalahan dalam kode CMS Orchard</a></li>
<li><a href="../id472364/index.html">PostgreSQL dan catat pengaturan konsistensi untuk setiap koneksi tertentu</a></li>
<li><a href="../id472366/index.html">Algoritma Path Finder Baru di Factorio</a></li>
<li><a href="../id472368/index.html">Pidato memancing: kami menganalisis metode serangan dan metode perlindungan terhadap mereka</a></li>
<li><a href="../id472372/index.html">Otomatisasi Android Panduan super mudah untuk membuat tes Espresso pertama Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>