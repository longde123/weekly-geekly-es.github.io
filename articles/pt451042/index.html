<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úä üßñüèª üíÜ No√ß√µes b√°sicas de design de banco de dados - compara√ß√£o do PostgreSQL, Cassandra e MongoDB üöá üôÑ üìÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° amigos. Antes de partir para a segunda parte dos feriados de maio, compartilhamos com voc√™ o material que traduzimos √†s v√©speras do lan√ßamento de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No√ß√µes b√°sicas de design de banco de dados - compara√ß√£o do PostgreSQL, Cassandra e MongoDB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/451042/">  Ol√° amigos.  Antes de partir para a segunda parte dos feriados de maio, compartilhamos com voc√™ o material que traduzimos √†s v√©speras do lan√ßamento de um novo fluxo √† taxa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Relational DBMS"</a> . <br><br><img src="https://habrastorage.org/webt/tg/jk/pk/tgjkpk23xr333l_ee0lddnylafa.png"><br><br>  Os desenvolvedores de aplicativos gastam muito tempo comparando v√°rios bancos de dados operacionais para escolher o que funciona melhor para a carga de trabalho pretendida.  As necessidades podem incluir modelagem de dados simplificada, garantias transacionais, desempenho de leitura / grava√ß√£o, dimensionamento horizontal e toler√¢ncia a falhas.  Por tradi√ß√£o, a escolha come√ßa com uma categoria de banco de dados, SQL ou NoSQL, pois cada categoria fornece um conjunto claro de compensa√ß√µes.  Alto desempenho em termos de baixa lat√™ncia e alto rendimento √© geralmente visto como um requisito de troca e, portanto, √© necess√°rio para qualquer banco de dados da amostra. <a name="habracut"></a><br><br>  O objetivo deste artigo √© ajudar os desenvolvedores de aplicativos a fazer a escolha certa entre SQL e NoSQL no contexto da modelagem de dados de aplicativos.  Examinaremos um banco de dados SQL, o PostgreSQL e dois NoSQL - Cassandra e MongoDB, para falar sobre o b√°sico do design de banco de dados, como criar tabelas, preench√™-las, ler dados da tabela e exclu√≠-los.  No pr√≥ximo artigo, veremos definitivamente √≠ndices, transa√ß√µes, JOINs, diretivas TTL e design de banco de dados baseado em JSON. <br><br>  <b>Qual √© a diferen√ßa entre SQL e NoSQL?</b> <br><br><blockquote>  Os bancos de dados SQL aumentam a flexibilidade do aplicativo com garantias transacionais do ACID, bem como sua capacidade de consultar dados usando JOINs de maneiras inesperadas sobre os modelos de banco de dados relacional normalizados existentes. </blockquote><br>  Dada sua arquitetura monol√≠tica / de n√≥ √∫nico e o uso de um modelo de replica√ß√£o mestre-escravo para redund√¢ncia, os bancos de dados SQL tradicionais n√£o possuem dois recursos importantes: escalabilidade linear do registro (ou seja, divis√£o autom√°tica em v√°rios n√≥s) e perda de dados autom√°tica / zero.  Isso significa que a quantidade de dados recebidos n√£o pode exceder a taxa de transfer√™ncia m√°xima de grava√ß√£o de um n√≥.  Al√©m disso, alguma perda tempor√°ria de dados deve ser levada em considera√ß√£o durante a toler√¢ncia a falhas (em uma arquitetura sem compartilhamento de recursos).  Aqui voc√™ deve ter em mente que confirma√ß√µes recentes ainda n√£o foram refletidas na c√≥pia do escravo.  Atualiza√ß√µes sem tempo de inatividade tamb√©m s√£o dif√≠ceis de obter nos bancos de dados SQL. <br><br>  Os bancos de dados NoSQL s√£o normalmente distribu√≠dos por natureza, ou seja,  neles, os dados s√£o divididos em se√ß√µes e distribu√≠dos por v√°rios n√≥s.  Eles exigem desnormaliza√ß√£o.  Isso significa que os dados inseridos tamb√©m devem ser copiados v√°rias vezes para responder a solicita√ß√µes espec√≠ficas que voc√™ envia.  O objetivo geral √© obter alto desempenho, reduzindo o n√∫mero de fragmentos dispon√≠veis durante a leitura.  Segue a declara√ß√£o de que o NoSQL exige que voc√™ modele suas consultas, enquanto o SQL exige que voc√™ modele seus dados. <br><br><blockquote>  O NoSQL se concentra em obter alto desempenho em um cluster distribu√≠do, e essa √© a principal justificativa para muitas trocas de design de banco de dados que incluem ACIDs de perda de transa√ß√£o, JOINs e √≠ndices secund√°rios globais consistentes. </blockquote><br>  Acredita-se que, embora os bancos de dados NoSQL forne√ßam escalabilidade de grava√ß√£o linear e alta toler√¢ncia a falhas, a perda de garantias transacionais os torna inadequados para dados essenciais. <br><br>  A tabela a seguir mostra como a modelagem de dados no NoSQL difere do SQL. <br><br><img src="https://habrastorage.org/webt/sv/6k/or/sv6kor2fwminli9ywljf1hf5h34.png"><br><br>  <b>SQL e NoSQL: Por que ambos s√£o necess√°rios?</b> <br><br>  Aplicativos do mundo real com um grande n√∫mero de usu√°rios, como Amazon.com, Netflix, Uber e Airbnb, realizam tarefas complexas e com v√°rias classifica√ß√µes.  Por exemplo, um aplicativo de com√©rcio eletr√¥nico como o Amazon.com precisa armazenar dados leves e altamente cr√≠ticos, como informa√ß√µes sobre usu√°rios, produtos, pedidos, faturas, al√©m de dados pesados, mas menos sens√≠veis, como an√°lises de produtos, mensagens de suporte , atividade do usu√°rio, revis√µes e recomenda√ß√µes do usu√°rio.  Naturalmente, esses aplicativos contam com pelo menos um banco de dados SQL junto com pelo menos um banco de dados NoSQL.  Nos sistemas inter-regionais e globais, o banco de dados NoSQL funciona como um cache distribu√≠do geograficamente para dados armazenados em um banco de dados SQL de origem confi√°vel, trabalhando em qualquer regi√£o. <br><br>  <b>Como o YugaByte DB combina SQL e NoSQL?</b> <br><br>  Constru√≠do em um mecanismo de armazenamento misto orientado a log, sharding autom√°tico, replica√ß√£o de consenso de sharding distribu√≠do e transa√ß√µes distribu√≠das ACID (inspiradas no Google Spanner), o YugaByte DB √© o primeiro banco de dados de c√≥digo aberto do mundo a ser simultaneamente compat√≠vel com o NoSQL (Cassandra &amp; Redis ) e SQL (PostgreSQL).  Conforme mostrado na tabela abaixo, o YSQL, a API YugaByte DB compat√≠vel com Cassandra, adiciona os conceitos de transa√ß√µes ACID √∫nicas e com v√°rias chaves e √≠ndices secund√°rios globais √†s APIs NoSQL, abrindo assim a era dos bancos de dados transacionais NoSQL.  Al√©m disso, o YSQL, uma API YugaByte DB compat√≠vel com PostgreSQL, adiciona a no√ß√£o de escala linear de registros e toler√¢ncia autom√°tica a falhas √† API SQL, introduzindo bancos de dados SQL distribu√≠dos no mundo.  Como o banco de dados YugaByte DB √© essencialmente transacional, a API NoSQL agora pode ser usada no contexto de dados cr√≠ticos. <br><br><img src="https://habrastorage.org/webt/ln/1a/_9/ln1a_9ouduu15ccxhvud1nssmme.png"><br><br>  Como afirmado anteriormente no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúIntrodu√ß√£o ao YSQL: uma API SQL distribu√≠da compat√≠vel com PostgreSQL para o YugaByte DB‚Äù</a> , a escolha entre SQL ou NoSQL no YugaByte DB depende inteiramente das caracter√≠sticas da carga de trabalho principal: <br><br><ul><li>  Se a carga de trabalho principal for opera√ß√µes com v√°rias chaves com JOINs, ao escolher YSQL, entenda que suas chaves podem ser distribu√≠das por v√°rios n√≥s, o que levar√° a um atraso maior e / ou taxa de transfer√™ncia menor do que no NoSQL. </li><li>  Caso contr√°rio, selecione uma das duas APIs NoSQL, tendo em mente que voc√™ obter√° melhor desempenho como resultado de consultas serem atendidas a partir de um n√≥ por vez.  O YugaByte DB pode servir como um √∫nico banco de dados operacional para aplicativos complexos reais, nos quais voc√™ precisa gerenciar v√°rias cargas de trabalho ao mesmo tempo. </li></ul><br>  O laborat√≥rio de modelagem de dados da pr√≥xima se√ß√£o √© baseado nos bancos de dados YugaByte DB compat√≠veis com a PostgreSQL e a API Cassandra, diferentemente dos bancos de dados de origem.  Essa abordagem enfatiza a facilidade de intera√ß√£o com duas APIs diferentes (em duas portas diferentes) do mesmo cluster de banco de dados, em vez de usar clusters completamente independentes de dois bancos de dados diferentes. <br><br>  Nas se√ß√µes a seguir, conheceremos o laborat√≥rio de modelagem de dados para ilustrar as diferen√ßas e alguns recursos comuns dos bancos de dados em quest√£o. <br><br>  <b>Laborat√≥rio de Modelagem de Dados</b> <br><br>  <b>Instala√ß√£o de banco de dados</b> <br><br>  Dada a √™nfase no design de um modelo de dados (em vez de arquiteturas de implanta√ß√£o complexas), instalaremos os bancos de dados nos cont√™ineres do Docker no computador local e, em seguida, interagiremos com eles usando os respectivos shells da linha de comando. <br><br>  <b>Compat√≠vel com PostgreSQL e Cassandra, banco de dados YugaByte DB</b> <br><br><pre><code class="sql hljs">mkdir ~/yugabyte &amp;&amp; cd ~/yugabyte wget https://downloads.yugabyte.com/yb-docker-ctl &amp;&amp; chmod +x yb-docker-ctl docker pull yugabytedb/yugabyte ./yb-docker-ctl <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-comment"><span class="hljs-comment">--enable_postgres</span></span></code> </pre> <br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs">docker run <span class="hljs-comment"><span class="hljs-comment">--name my-mongo -d mongo:latest</span></span></code> </pre> <br>  <b>Acesso √† linha de comando</b> <br><br>  Vamos nos conectar aos bancos de dados usando o shell da linha de comando para as APIs correspondentes. <br><br>  <b>PostgreSQL</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O psql</a> √© um shell de linha de comando para interagir com o PostgreSQL.  Para facilitar o uso, o YugaByte DB vem com o psql diretamente na pasta bin. <br><br><pre> <code class="sql hljs">docker exec -it yb-postgres-n1 /home/yugabyte/postgres/bin/psql -p 5433 -U postgres</code> </pre> <br>  <b>Cassandra</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cqlsh</a> √© um shell de linha de comando para interagir com o Cassandra e seus bancos de dados compat√≠veis via CQL (linguagem de consulta do Cassandra).  Para facilitar o uso, o YugaByte DB vem com o <code>cqlsh</code> no <code>bin</code> . <br><br>  Observe que o CQL foi inspirado no SQL e possui conceitos semelhantes √†s tabelas, linhas, colunas e √≠ndices.  No entanto, como uma linguagem NoSQL, ela adiciona um certo conjunto de restri√ß√µes, a maioria das quais tamb√©m abordaremos em outros artigos. <br><br><pre> <code class="sql hljs">docker exec -it yb-tserver-n1 /home/yugabyte/bin/cqlsh</code> </pre> <br>  <b>Mongodb</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O mongo</a> √© um shell de linha de comando para interagir com o MongoDB.  Ele pode ser encontrado no diret√≥rio bin da instala√ß√£o do MongoDB. <br><br><pre> <code class="sql hljs">docker exec -it my-mongo bash cd bin mongo</code> </pre> <br>  <b>Cria√ß√£o de tabela</b> <br><br>  Agora podemos interagir com o banco de dados para executar v√°rias opera√ß√µes usando a linha de comando.  Vamos come√ßar criando uma tabela que armazena informa√ß√µes sobre m√∫sicas escritas por diferentes artistas.  Essas m√∫sicas podem fazer parte de um √°lbum.  Tamb√©m atributos opcionais para a m√∫sica - ano de lan√ßamento, pre√ßo, g√™nero e classifica√ß√£o.  Precisamos considerar atributos adicionais que possam ser necess√°rios no futuro atrav√©s do campo "tags".  Ele pode armazenar dados semiestruturados como pares de valores-chave. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">25</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>), CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Criar uma tabela no Cassandra √© muito semelhante ao PostgreSQL.  <b>Uma das principais diferen√ßas √© a falta de restri√ß√µes de integridade (por exemplo, NOT NULL), mas essa √© a responsabilidade do aplicativo, n√£o do banco de dados NoSQL</b> .  A chave prim√°ria consiste em uma chave de se√ß√£o (coluna Artista no exemplo abaixo) e um conjunto de colunas de cluster (coluna SongTitle no exemplo abaixo).  A chave da parti√ß√£o determina em qual parti√ß√£o / shard colocar a linha e as colunas de cluster indicam como os dados devem ser organizados dentro do shard atual. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> KEYSPACE myapp; <span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> myapp; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Mongodb</b> <br><br>  O MongoDB organiza os dados em bancos de dados (Banco de Dados) (semelhante ao Keyspace no Cassandra), onde existem cole√ß√µes (Cole√ß√µes) (semelhantes √†s tabelas), que cont√™m documentos (Documentos) (semelhantes √†s linhas de uma tabela).  O MongoDB basicamente n√£o requer a defini√ß√£o do esquema original.  O comando <i>"usar banco de dados"</i> mostrado abaixo cria uma inst√¢ncia do banco de dados na primeira chamada e altera o contexto do banco de dados rec√©m-criado.  Mesmo as cole√ß√µes n√£o precisam ser criadas explicitamente, elas s√£o criadas automaticamente, simplesmente quando voc√™ adiciona o primeiro documento a uma nova cole√ß√£o.  Observe que o MongoDB usa o banco de dados de teste por padr√£o; portanto, qualquer opera√ß√£o em n√≠vel de cole√ß√£o sem especificar um banco de dados espec√≠fico ser√° executada nele por padr√£o. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase;</code> </pre> <br>  <b>Recuperando informa√ß√µes da tabela do PostgreSQL</b> <br><br><pre> <code class="sql hljs">\d Music Table "public.music" Column | Type | Collation | Nullable | Default <span class="hljs-comment"><span class="hljs-comment">--------------+-----------------------+-----------+----------+-------- artist | character varying(20) | | not null | songtitle | character varying(30) | | not null | albumtitle | character varying(25) | | | year | integer | | | price | double precision | | | genre | character varying(10) | | | criticrating | double precision | | | tags | text | | | Indexes: "music_pkey" PRIMARY KEY, btree (artist, songtitle)</span></span></code> </pre> <br>  <b>Cassandra</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DESCRIBE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> MUSIC; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> myapp.music ( artist <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, songtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, albumtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, price <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>, genre <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, tags <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (artist, songtitle) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLUSTERING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> (songtitle <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> default_time_to_live = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> transactions = {<span class="hljs-string"><span class="hljs-string">'enabled'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>};</code> </pre> <br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> collections;</code> </pre> <br>  <b>Publicando dados em uma tabela do PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span>, Price, Genre, CriticRating, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'Somewhat Famous'</span></span>, <span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">2.14</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">7.8</span></span>, <span class="hljs-string"><span class="hljs-string">'{"Composers": ["Smith", "Jones", "Davis"],"LengthInSeconds": 214}'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, CriticRating) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hey Now'</span></span>, <span class="hljs-number"><span class="hljs-number">1.98</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">8.4</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">2.47</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-string"><span class="hljs-string">'{"radioStationsPlaying": ["KHCR", "KBQX", "WTNR", "WJJH"], "tourDates": { "Seattle": "20150625", "Cleveland": "20150630"}, "rotation": Heavy}'</span></span> );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Em geral, a express√£o <code>INSERT</code> no Cassandra √© muito semelhante √† do PostgreSQL.  No entanto, h√° uma grande diferen√ßa na sem√¢ntica.  No Cassandra, <code>INSERT</code> na verdade uma opera√ß√£o <code>UPSERT</code> em que os √∫ltimos valores s√£o adicionados √† string, caso ela j√° exista. <br><blockquote>  A entrada de dados √© semelhante ao PostgreSQL <code>INSERT</code> acima </blockquote><br>  <b>Mongodb</b> <br><br>  Embora o MongoDB seja um banco de dados NoSQL, como o Cassandra, sua opera√ß√£o de inser√ß√£o n√£o tem nada a ver com o comportamento sem√¢ntico no Cassandra.  No MongoDB, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">insert ()</a> n√£o possui recursos <code>UPSERT</code> , o que faz com que pare√ßa com o PostgreSQL.  Adicionar dados padr√£o sem <code>_idspecified</code> adicionar√° um novo documento √† cole√ß√£o. <br><br> <code>db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "Call Me Today", <br> albumTitle: "Somewhat Famous", <br> year: 2015, <br> price: 2.14, <br> genre: "Country", <br> tags: { <br> Composers: ["Smith", "Jones", "Davis"], <br> LengthInSeconds: 214 <br> } <br> } <br> ); <br> db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "My Dog Spot", <br> albumTitle: "Hey Now", <br> price: 1.98, <br> genre: "Country", <br> criticRating: 8.4 <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Look Out, World", <br> albumTitle:"The Buck Starts Here", <br> price: 0.99, <br> genre: "Rock" <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Still In Love", <br> albumTitle:"The Buck Starts Here", <br> price: 2.47, <br> genre: "Rock", <br> tags: { <br> radioStationsPlaying:["KHCR", "KBQX", "WTNR", "WJJH"], <br> tourDates: { <br> Seattle: "20150625", <br> Cleveland: "20150630" <br> }, <br> rotation: "Heavy" <br> } <br> } <br> );</code> <br> <br>  <b>Consulta de tabela</b> <br><br>  Talvez a diferen√ßa mais significativa entre SQL e NoSQL em termos de design de consulta seja o uso das instru√ß√µes <code>FROM</code> e <code>WHERE</code> .  O SQL permite selecionar v√°rias tabelas ap√≥s uma <code>FROM</code> , e uma <code>WHERE</code> pode ser de qualquer complexidade (incluindo opera√ß√µes <code>JOIN</code> entre tabelas).  No entanto, o NoSQL tende a impor uma restri√ß√£o estrita a <code>FROM</code> e trabalha com apenas uma tabela especificada e, em <code>WHERE</code> , a chave prim√°ria sempre deve ser especificada.  Isso se deve ao desejo de melhorar o desempenho do NoSQL, sobre o qual falamos anteriormente.  Esse desejo leva a toda redu√ß√£o poss√≠vel em qualquer intera√ß√£o entre tabelas e chaves.  Isso pode levar a um grande atraso na comunica√ß√£o intermodal ao responder a uma solicita√ß√£o e, portanto, √© melhor evitar isso em princ√≠pio.  Por exemplo, o Cassandra exige que as consultas sejam limitadas a determinados operadores (somente <code>=, IN, &lt;, &gt;, =&gt;, &lt;=</code> s√£o permitidas) nas chaves de parti√ß√£o, exceto quando solicitar um √≠ndice secund√°rio (somente o operador = √© permitido aqui). <br><br>  <b>PostgreSQL</b> <br><br>  Tr√™s exemplos de consultas que podem ser facilmente executadas por um banco de dados SQL ser√£o apresentados abaixo. <br><br><ul><li>  Imprima todas as m√∫sicas do artista; </li><li>  Imprima todas as m√∫sicas do artista que correspondem √† primeira parte do nome; </li><li>  Liste todas as m√∫sicas do artista que possuem uma palavra espec√≠fica no t√≠tulo e t√™m um pre√ßo menor que 1,00. </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'Call%'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%Today%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Das consultas do PostgreSQL acima, apenas a primeira funcionar√° no Cassandra inalterada, pois a instru√ß√£o <code>LIKE</code> n√£o pode ser aplicada a agrupamentos de colunas como o <code>SongTitle</code> .  Nesse caso, apenas operadores <code>=</code> e <code>IN</code> s√£o permitidos. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Mongodb</b> <br><br>  Como mostrado nos exemplos anteriores, o m√©todo principal para criar consultas no MongoDB √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">db.collection.find ()</a> .  Este m√©todo cont√©m explicitamente o nome da cole√ß√£o ( <code>music</code> no exemplo abaixo), portanto, a solicita√ß√£o de v√°rias cole√ß√µes √© proibida. <br><br><pre> <code class="sql hljs">db.music.find( { artist: "No One You Know" } ); db.music.find( { artist: "No One You Know", songTitle: /<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>/ } );</code> </pre> <br>  <b>Leia todas as linhas da tabela</b> <br><br>  A leitura de todas as linhas √© apenas um caso especial do modelo de consulta que examinamos anteriormente. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music;</code> </pre> <br><br>  <b>Cassandra</b> <br><br><blockquote>  Semelhante ao exemplo no PostgreSQL acima. </blockquote><br><br>  Mongodb <br><br><pre> <code class="sql hljs">db.music.find( {} );</code> </pre> <br>  <b>Editando dados em uma tabela</b> <br><br>  <b>PostgreSQL</b> <br><br>  O PostgreSQL fornece uma <code>UPDATE</code> para modificar os dados.  Ele n√£o possui recursos <code>UPSERT</code> ; portanto, a execu√ß√£o desta instru√ß√£o falhar√° se a linha n√£o estiver mais no banco de dados. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Genre = <span class="hljs-string"><span class="hljs-string">'Disco'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Cassandra tem uma <code>UPDATE</code> semelhante ao PostgreSQL.  <code>UPDATE</code> possui a mesma sem√¢ntica <code>UPSERT</code> <code>INSERT</code> . <br><br><blockquote>  Semelhante ao exemplo no PostgreSQL acima. </blockquote><br>  <b>Mongodb</b> <br>  A opera√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">update ()</a> no MongoDB pode atualizar completamente um documento existente ou atualizar apenas determinados campos.  Por padr√£o, ele atualiza apenas um documento com a sem√¢ntica do <code>UPSERT</code> .  A atualiza√ß√£o de v√°rios documentos e o comportamento semelhante ao <code>UPSERT</code> pode ser aplicada definindo sinalizadores adicionais para a opera√ß√£o.  Por exemplo, no exemplo abaixo, o g√™nero de um determinado artista √© atualizado por sua m√∫sica. <br><br><pre> <code class="sql hljs">db.music.update( {"artist": "The Acme Band"}, { $<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: { <span class="hljs-string"><span class="hljs-string">"genre"</span></span>: <span class="hljs-string"><span class="hljs-string">"Disco"</span></span> } }, {<span class="hljs-string"><span class="hljs-string">"multi"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"upsert"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} );</code> </pre> <br>  <b>Removendo dados de uma tabela</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  Semelhante ao exemplo no PostgreSQL acima. </blockquote><br>  <b>Mongodb</b> <br><br>  O MongoDB possui dois tipos de opera√ß√µes para excluir documentos - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deleteOne ()</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">/ deleteMany ()</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">remove ()</a> .  Ambos os tipos excluem documentos, mas retornam resultados diferentes. <br><br><pre> <code class="sql hljs">db.music.deleteMany( { artist: "The Acme Band" } );</code> </pre><br>  <b>Excluir tabela</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  Semelhante ao exemplo no PostgreSQL acima. </blockquote><br>  <b>Mongodb</b> <br><br><pre> <code class="sql hljs">db.music.drop();</code> </pre> <br>  <b>Conclus√£o</b> <br><br>  O debate sobre a escolha entre SQL e NoSQL est√° em andamento h√° mais de 10 anos.  Existem dois aspectos principais desse debate: a arquitetura do mecanismo de banco de dados (SQL monol√≠tico e transacional versus NoSQL n√£o transacional e distribu√≠do) e a abordagem do design do banco de dados (modelagem de dados no SQL versus modelagem de suas consultas no NoSQL). <br><br>  Com um banco de dados transacional distribu√≠do como o YugaByte DB, o debate sobre a arquitetura do banco de dados pode ser facilmente dissipado.  √Ä medida que os volumes de dados se tornam maiores do que o que pode ser gravado em um √∫nico n√≥, torna-se necess√°ria uma arquitetura totalmente distribu√≠da que suporta escalabilidade linear de grava√ß√µes com fragmenta√ß√£o / reequil√≠brio autom√°tico. <br><br>  Al√©m de ser dito em um artigo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Cloud</a> , as arquiteturas transacionais e estritamente consistentes agora s√£o mais amplamente usadas para fornecer melhor flexibilidade de desenvolvimento do que as arquiteturas n√£o transacionais e, em √∫ltima an√°lise, consistentes. <br><br>  Voltando √† discuss√£o sobre design de banco de dados, √© justo dizer que as duas abordagens de design (SQL e NoSQL) s√£o necess√°rias para qualquer aplicativo real complexo.  A abordagem SQL "modelagem de dados" permite que os desenvolvedores atendam mais facilmente os requisitos de neg√≥cios em mudan√ßa, enquanto a abordagem NoSQL "modelagem de dados" permite que os mesmos desenvolvedores tratem grandes quantidades de dados com baixa lat√™ncia e alta taxa de transfer√™ncia.  √â por esse motivo que o YugaByte DB fornece APIs SQL e NoSQL em um kernel comum, em vez de promover uma das abordagens.  Al√©m disso, ao garantir a compatibilidade com linguagens populares de banco de dados, incluindo PostgreSQL e Cassandra, o YugaByte DB garante que os desenvolvedores n√£o precisem aprender outro idioma para trabalhar com um mecanismo de banco de dados estritamente consistente e distribu√≠do. <br><br>  Neste artigo, descobrimos como os fundamentos do design de banco de dados diferem no PostgreSQL, Cassandra e MongoDB.  Nos artigos a seguir, abordaremos conceitos avan√ßados de design, como √≠ndices, transa√ß√µes, JOINs, diretivas TTL e documentos JSON. <br><br>  Desejamos a voc√™ uma estadia maravilhosa no restante do fim de semana e convidamos voc√™ para um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webinar gratuito</a> , que ser√° realizado no dia 14 de maio. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451042/">https://habr.com/ru/post/pt451042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451026/index.html">Por que resta t√£o pouco da internet inicial?</a></li>
<li><a href="../pt451028/index.html">Guia: tipos de ensaios em ingl√™s e dicas para escrev√™-los</a></li>
<li><a href="../pt451032/index.html">Escrevendo cliente e servidor HTTP / 1.1 e HTTP / 2 em Golang</a></li>
<li><a href="../pt451034/index.html">Consultas fantasma SQL</a></li>
<li><a href="../pt451040/index.html">Divers√£o descontrolada em maio ou Aproxima√ß√£o por impasse</a></li>
<li><a href="../pt451044/index.html">IMaskjs - 3 anos em c√≥digo aberto</a></li>
<li><a href="../pt451050/index.html">Ember.js: (novamente) hora de tentar</a></li>
<li><a href="../pt451054/index.html">DO-RA: Prepara√ß√£o para produ√ß√£o industrial</a></li>
<li><a href="../pt451056/index.html">Introdu√ß√£o ao MS Dynamics CRM</a></li>
<li><a href="../pt451058/index.html">Workshop corporativo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>