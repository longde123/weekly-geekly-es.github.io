<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîü üïç üèª Sicherheit von mobilem OAuth 2.0 ‚õ∫Ô∏è ‚è≥ ‚ô•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Popularit√§t mobiler Anwendungen nimmt weiter zu. Dies gilt auch f√ºr das OAuth 2.0-Protokoll f√ºr mobile Apps. Es reicht nicht aus, Standard zu impl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sicherheit von mobilem OAuth 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/456702/"><img src="https://habrastorage.org/getpro/habr/post_images/def/8b1/158/def8b1158655952902bf05be9fb7f308.jpg" alt="Bild"><br><br>  Die Popularit√§t mobiler Anwendungen nimmt weiter zu.  Dies gilt auch f√ºr das OAuth 2.0-Protokoll f√ºr mobile Apps.  Es reicht nicht aus, Standard zu implementieren, um das OAuth 2.0-Protokoll dort sicher zu machen.  Man muss die Besonderheiten mobiler Anwendungen ber√ºcksichtigen und einige zus√§tzliche Sicherheitsmechanismen anwenden. <br><br>  In diesem Artikel m√∂chte ich die Konzepte mobiler OAuth 2.0-Angriffe und Sicherheitsmechanismen zur Verhinderung solcher Probleme erl√§utern.  Beschriebene Konzepte sind nicht neu, aber es fehlen strukturierte Informationen zu diesem Thema.  Das Hauptziel des Artikels ist es, diese L√ºcke zu schlie√üen. <br><a name="habracut"></a><br><h1>  OAuth 2.0 Art und Zweck </h1><br>  OAuth 2.0 ist ein <i>Autorisierungsprotokoll</i> , das eine M√∂glichkeit f√ºr einen Clientdienst beschreibt, einen sicheren Zugriff auf die Ressourcen des Benutzers bei einem Dienstanbieter zu erhalten.  Dank OAuth 2.0 muss der Benutzer sein Passwort nicht au√üerhalb des Dienstanbieters eingeben: Der gesamte Vorgang beschr√§nkt sich auf das Klicken auf die Schaltfl√§che "Ich stimme zu, Zugriff auf ... zu gew√§hren". <br><br>  Ein Anbieter ist ein Dienst, dem die Benutzerdaten geh√∂ren und der mit Erlaubnis des Benutzers Diensten (Clients) von Drittanbietern einen sicheren Zugriff auf diese Daten bietet.  Ein Client ist eine Anwendung, die die vom Anbieter gespeicherten Benutzerdaten abrufen m√∂chte. <br><br>  Kurz nach der Ver√∂ffentlichung des OAuth 2.0-Protokolls wurde es f√ºr die <i>Authentifizierung</i> angepasst, obwohl es nicht daf√ºr gedacht war.  Durch die Verwendung von OAuth 2.0 zur Authentifizierung wird ein Angriffsvektor von den beim Dienstanbieter gespeicherten Daten auf die Benutzerkonten des Clientdienstes verschoben. <br><br>  Die Authentifizierung war jedoch nur ein Anfang.  In Zeiten mobiler Apps und der Verherrlichung von Conversions klang der Zugriff auf eine App mit nur einer Taste gut.  Entwickler haben OAuth 2.0 f√ºr den mobilen Einsatz angepasst.  Nat√ºrlich machten sich nicht viele Sorgen um die Sicherheit und die Besonderheiten mobiler Apps: zap und in die Produktion gingen sie!  Andererseits funktioniert OAuth 2.0 au√üerhalb von Webanwendungen nicht gut: Sowohl bei mobilen als auch bei Desktop-Apps treten dieselben Probleme auf. <br><br>  Lassen Sie uns also herausfinden, wie Sie Mobile OAuth 2.0 sicher machen k√∂nnen. <br><br><h1>  Wie funktioniert es </h1><br>  Es gibt zwei Hauptprobleme bei der mobilen OAuth 2.0-Sicherheit: <br><br><ol><li>  Nicht vertrauensw√ºrdiger Kunde.  Einige mobile Anwendungen haben kein Backend f√ºr OAuth 2.0, sodass der Client-Teil des Protokollflusses auf dem mobilen Ger√§t ausgef√ºhrt wird. <br></li><li>  Die Umleitungen von einem Browser zu einer mobilen App verhalten sich je nach Systemeinstellungen, Reihenfolge der Installation der Anwendungen und anderer Magie unterschiedlich. <br></li></ol><br>  Schauen wir uns diese Themen genauer an. <br><br><h4>  Mobile Anwendung ist ein √∂ffentlicher Client </h4><br>  Um die Wurzeln und Konsequenzen des ersten Problems zu verstehen, sehen wir uns an, wie OAuth 2.0 bei Server-zu-Server-Interaktion funktioniert, und vergleichen es dann mit OAuth 2.0 bei Client-zu-Server-Interaktion. <br><br>  In beiden F√§llen beginnt alles mit den Client-Service-Registern im Provider-Service und empf√§ngt <code>client_id</code> und in einigen F√§llen <code>, client_secret. client_id</code>  <code>, client_secret. client_id</code> ist ein √∂ffentlicher Wert, der f√ºr die Identifizierung des <code>client_secret</code> erforderlich ist, im Gegensatz zum Wert <code>client_secret</code> , der privat ist.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> zum Registrierungsprozess finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 7591</a> . <br><br>  Das folgende Schema zeigt die Funktionsweise von OAuth 2.0 bei Server-zu-Server-Interaktionen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/689/61f/9a668961fd270118492bec6134a1aca9.png"><br>  <i>Bildursprung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Das OAuth 2.0-Protokoll kann in drei Hauptschritte unterteilt werden: <br><br><ol><li>  [Schritte AC] Erhalten Sie einen <code>authorization_code</code> (im Folgenden <code>code</code> ). <br></li><li>  [Schritte DE] Tauschen Sie den <code>code</code> in <code>access_token</code> . <br></li><li>  Ressource √ºber <code>access_token</code> . </li></ol><br><br>  Lassen Sie uns den Prozess zum Abrufen des <code>code</code> n√§her erl√§utern: <br><br><ol><li>  [Schritt A] Der Client leitet den Benutzer an den Dienstanbieter weiter. <br></li><li>  [Schritt B] Der Dienstanbieter fordert vom Benutzer die Erlaubnis an, dem Client die Daten bereitzustellen (Pfeil B nach oben).  Der Benutzer bietet Datenzugriff (Pfeil B nach rechts). <br></li><li>  [Schritt C] Der Dienstanbieter gibt <code>code</code> an den Benutzerbrowser zur√ºck, der den <code>code</code> an den Client weiterleitet. <br></li></ol><br>  Lassen Sie uns mehr √ºber den Prozess des <code>access_token</code> von <code>access_token</code> : <br><br><ol><li>  [Schritt D] Der Client-Server sendet eine Anforderung f√ºr <code>access_token</code> .  <code>Code</code> , <code>client_secret</code> und <code>redirect_uri</code> sind in der Anfrage enthalten. <br></li><li>  [Schritt E] Bei g√ºltigem <code>code</code> , <code>client_secret</code> und <code>redirect_uri</code> , wird <code>access_token</code> bereitgestellt. <br></li></ol><br>  Die Anforderung von <code>access_token</code> erfolgt gem√§√ü dem Server-zu-Server-Schema. Daher muss der Angreifer im Allgemeinen den Client-Service-Server oder den Service-Provider-Server hacken, um <code>access_token</code> zu stehlen. <br><br>  Betrachten wir nun das mobile OAuth 2.0-Schema ohne Backend (Client-Server-Interaktion). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Bildursprung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Das Hauptschema ist in die gleichen Hauptschritte unterteilt: <br><br><ol><li>  [Schritte 1-4 im Bild] <code>code</code> abrufen. </li><li>  [Schritte 5-6 im Bild] Tauschen Sie den <code>code</code> in <code>access_token</code> </li><li>  <code>access_token</code> Ressourcenzugriff √ºber <code>access_token</code> </li></ol><br>  In diesem Fall verf√ºgt die mobile App jedoch auch √ºber die Serverfunktionen.  Daher w√ºrde <code>client_secret</code> in die Anwendung eingebettet.  Daher kann <code>client_secret</code> auf mobilen Ger√§ten nicht vor Angreifern verborgen <code>client_secret</code> .  Eingebettetes <code>client_secret</code> kann auf zwei Arten extrahiert werden: durch Analyse des Anwendungs-Server-Verkehrs oder durch Reverse Engineering.  Beides kann einfach implementiert werden, weshalb <code>client_secret</code> auf Mobilger√§ten unbrauchbar ist. <br><br>  Sie k√∂nnten fragen: "Warum bekommen wir nicht sofort <code>access_token</code> ?"  Sie k√∂nnten denken, dass dieser zus√§tzliche Schritt unn√∂tig ist.  Dar√ºber hinaus gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implizites Grant-</a> Schema, mit dem ein Client <code>access_token</code> sofort empfangen <code>access_token</code> .  Obwohl es in einigen F√§llen verwendet werden kann, funktioniert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implicit Grant</a> nicht f√ºr sicheres mobiles OAuth 2.0. <br><br><h4>  Umleitung auf mobilen Ger√§ten </h4><br>  Im Allgemeinen werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierte URI-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schema-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppLink-</a> Mechanismen f√ºr die Umleitung von Browser zu App verwendet.  Keiner dieser Mechanismen kann so sicher sein wie Browser-Weiterleitungen f√ºr sich. <br><br>  <i>Das benutzerdefinierte URI-Schema</i> (oder Deep Link) wird folgenderma√üen verwendet: Ein Entwickler bestimmt vor der Bereitstellung ein Anwendungsschema.  Das Schema kann ein beliebiges sein, und ein Ger√§t kann mehrere Anwendungen mit demselben Schema haben. <br><br>  Dies erleichtert die Arbeit, wenn jedes Schema auf einem Ger√§t einer Anwendung entspricht.  Was aber, wenn zwei Anwendungen dasselbe Schema auf einem Ger√§t registrieren?  Wie entscheidet das Betriebssystem, welche App ge√∂ffnet werden soll, wenn es √ºber das benutzerdefinierte URI-Schema kontaktiert wird?  Android zeigt ein Fenster mit einer Auswahl an Apps und einem Link, dem Sie folgen k√∂nnen.  iOS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat hierf√ºr kein Verfahren</a> und daher kann jede Anwendung ge√∂ffnet werden.  Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jeden Fall</a> hat der Angreifer die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">M√∂glichkeit, Code oder access_token abzufangen</a> . <br><br>  Im Gegensatz zum benutzerdefinierten URI-Schema garantiert <i>AppLink</i> , dass die richtige Anwendung ge√∂ffnet wird. Dieser Mechanismus weist jedoch mehrere M√§ngel auf: <br><br><ol><li>  Jeder Service-Client muss sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem √úberpr√ºfungsverfahren unterziehen</a> . <br></li><li>  Android-Benutzer k√∂nnen AppLink f√ºr eine bestimmte App in den Einstellungen deaktivieren. <br></li><li>  Android-Versionen √§lter als 6.0 und iOS-Versionen √§lter als 9.0 unterst√ºtzen AppLink nicht. <br></li></ol><br>  All diese AppLink-Fehler verl√§ngern die Lernkurve f√ºr potenzielle Service-Clients und k√∂nnen unter bestimmten Umst√§nden zu einem OAuth 2.0-Fehler des Benutzers f√ºhren.  Aus diesem Grund w√§hlen viele Entwickler den AppLink-Mechanismus nicht als Ersatz f√ºr die Browserumleitung im OAuth 2.0-Protokoll. <br><br><h1>  OK, was gibt es zum Angriff? </h1><br>  Mobile OAuth 2.0-Probleme haben einige spezifische Angriffe verursacht.  Mal sehen, was sie sind und wie sie funktionieren. <br><br><a name="1"></a><h4>  Abfangangriff auf Autorisierungscode </h4><br>  Betrachten wir die Situation, in der das Benutzerger√§t eine legitime Anwendung (OAuth 2.0-Client) und eine b√∂sartige Anwendung hat, die dasselbe Schema wie die legitime registriert hat.  Das Bild unten zeigt das Angriffsschema. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d79/b98/46e/d79b9846e18e85a546b32a5927cdd627.png"><br>  <i>Bildursprung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Hier ist das Problem: Im vierten Schritt gibt der Browser den <code>code</code> in der Anwendung √ºber das benutzerdefinierte URI-Schema zur√ºck. Daher kann der <code>code</code> von einer b√∂swilligen App abgefangen werden (da er dasselbe Schema wie eine legitime App registriert hat).  Anschlie√üend √§ndert die b√∂swillige App den <code>code</code> in <code>access_token</code> und erh√§lt Zugriff auf die Benutzerdaten. <br><br>  Was ist der Schutz?  In einigen F√§llen k√∂nnen Sie die Kommunikation zwischen Prozessen verwenden.  Wir werden sp√§ter dar√ºber sprechen.  Im Allgemeinen ben√∂tigen Sie ein Schema namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Proof Key f√ºr Code Exchange</a> .  Es ist im folgenden Schema beschrieben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac2/289/967/ac2289967122b9d5f458e35ab2a0d902.png"><br>  <i>Bildursprung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  Die <code>code_verifier</code> verf√ºgt √ºber mehrere zus√§tzliche Parameter: <code>code_verifier</code> , <code>code_challenge</code> (im Schema <code>t(code_verifier)</code> ) und <code>code_challenge_method</code> (im Schema <code>t_m</code> ). <br><br>  <code>Code_verifier</code> - ist eine Zufallszahl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit einer Mindestl√§nge von 256 Bit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die nur einmal verwendet wird</a> .  Ein Client muss <code>code_verifier</code> f√ºr jede <code>code_verifier</code> einen neuen <code>code_verifier</code> <code>code</code> . <br><br>  <code>Code_challenge_method</code> - Dies ist ein Name einer Konvertierungsfunktion, meistens SHA-256. <br><br>  <code>Code_challenge</code> - ist der <code>code_verifier</code> auf den die Konvertierung von <code>code_challenge_method</code> angewendet wurde und der in URL Safe Base64 codiert wurde. <br><br>  Die Konvertierung von <code>code_verifier</code> in <code>code_challenge</code> ist erforderlich, um die Angriffsvektoren basierend auf <code>code_verifier</code> Abfangen von <code>code_verifier</code> (z. B. aus den Ger√§tesystemprotokollen) beim Anfordern von <code>code</code> <code>code_verifier</code> . <br><br>  Wenn ein Benutzerger√§t SHA-256 <b>nicht unterst√ºtzt</b> , kann ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>client is allowed to use plain conversion of code_verifier</code></a> .  In allen anderen F√§llen muss SHA-256 verwendet werden. <br><br>  So funktioniert dieses Schema: <br><br><ol><li>  Der Client generiert <code>code_verifier</code> und speichert ihn. <br></li><li>  Der Client w√§hlt <code>code_challenge_method</code> und empf√§ngt <code>code_challenge</code> von <code>code_verifier</code> . <br></li><li>  [Schritt A] Der Client fordert <code>code</code> , wobei der Anforderung <code>code_challenge</code> und <code>code_challenge_method</code> hinzugef√ºgt werden. <br></li><li>  [Schritt B] Der Anbieter speichert <code>code_challenge</code> und <code>code_challenge_method</code> auf dem Server und gibt <code>code</code> an einen Client zur√ºck. <br></li><li>  [Schritt C] Der Client fordert <code>access_token</code> und <code>code_verifier</code> hinzu. <br></li><li>  Der Anbieter empf√§ngt <code>code_challenge</code> vom eingehenden <code>code_verifier</code> und vergleicht ihn <code>code_challenge</code> mit dem von ihm gespeicherten <code>code_challenge</code> . <br></li><li>  [Schritt D] Wenn die Werte √ºbereinstimmen, gibt der Anbieter dem Client <code>access_token</code> . <br></li></ol><br>  Um zu verstehen, warum <code>code_challenge</code> Abfangen von Code <code>code_challenge</code> , sehen wir uns an, wie der Protokollfluss aus der Sicht des Angreifers aussieht. <br><br><ol><li>  Zun√§chst legitimer App-Anforderungscode ( <code>code_challenge</code> und <code>code_challenge_method</code> werden zusammen mit der <b>Anforderung</b> gesendet). <br></li><li>  Sch√§dliche App f√§ngt <code>code</code> (aber nicht <code>code_challenge</code> , da <code>_challenge</code> nicht in der Antwort enthalten ist). <br></li><li>  Sch√§dliche App fordert <code>access_token</code> (mit g√ºltigem <code>code</code> , aber <b>ohne</b> g√ºltigen <code>code_verifier</code> ). <br></li><li>  Der Server stellt eine <code>code_challenge</code> von <code>code_challenge</code> und gibt eine Fehlermeldung aus. <br></li></ol><br>  Beachten Sie, dass der Angreifer <code>code_verifier</code> (zuf√§lliger 256-Bit-Wert!) Nicht erraten oder irgendwo in den Protokollen finden kann (da die erste Anforderung tats√§chlich <code>code_challenge</code> √ºbertragen <code>code_challenge</code> ). <br><br>  <code>code_challenge</code> beantwortet also die Frage des Dienstanbieters: "Wird <code>access_token</code> von demselben App-Client angefordert, der <code>code</code> angefordert hat <code>code</code> oder von einem anderen?". <br><br><h4>  OAuth 2.0 CSRF </h4><br>  OAuth 2.0 CSRF ist relativ harmlos, wenn OAuth 2.0 f√ºr die Autorisierung verwendet wird.  Ganz anders sieht es aus, wenn OAuth 2.0 zur Authentifizierung verwendet wird.  In diesem Fall f√ºhrt OAuth 2.0 CSRF h√§ufig zu einer Konto√ºbernahme. <br><br>  Lassen Sie uns am Beispiel des Taxi-App-Clients und des Anbieters von provider.com mehr √ºber den CSRF-Angriff gem√§√ü OAuth 2.0 sprechen.  Zun√§chst meldet sich ein Angreifer auf seinem eigenen Ger√§t bei attacker@provider.com an und erh√§lt den <code>code</code> f√ºr das Taxi.  Dann unterbricht er den OAuth 2.0-Prozess und generiert einen Link: <br><br><pre> <code class="plaintext hljs">com.taxi.app://oauth? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4</code> </pre> <br>  Dann sendet der Angreifer diesen Link an sein Opfer, beispielsweise in Form einer Mail oder einer Textnachricht von Taxis.  Das Opfer klickt auf den Link, die Taxi-App wird ge√∂ffnet und erh√§lt <code>access_token</code> .  Infolgedessen befinden sie sich auf dem <b>Taxikonto</b> des <b>Angreifers</b> .  Das Opfer ist sich dessen nicht bewusst und verwendet dieses Konto: Reisen, pers√∂nliche Daten eingeben usw. <br><br>  Jetzt kann sich der Angreifer jederzeit in das Taxikonto des Opfers einloggen, da es mit <a href=""><code>attacker@provider.com</code></a> verkn√ºpft ist.  Durch einen CSRF-Anmeldeangriff konnte der √úbertreter ein Konto stehlen. <br><br>  CSRF-Angriffe werden normalerweise mit einem CSRF-Token (auch als <code>state</code> ) zur√ºckgewiesen, und OAuth 2.0 ist keine Ausnahme.  So verwenden Sie das CSRF-Token: <br><br><ol><li>  Die Clientanwendung generiert und speichert CSRF-Token auf dem mobilen Ger√§t eines Clients. <br></li><li>  Die Clientanwendung enth√§lt das CSRF-Token in der Codezugriffsanforderung. <br></li><li>  Der Server gibt dasselbe CSRF-Token mit <code>code</code> in seiner Antwort zur√ºck. <br></li><li>  Die Clientanwendung vergleicht die eingehenden und gespeicherten CSRF-Token.  Wenn ihre Werte √ºbereinstimmen, wird der Prozess fortgesetzt. <br></li></ol><br>  CSRF-Token-Anforderungen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nonce</a> muss mindestens 256 Bit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√ü</a> sein und von einer guten Quelle pseudozuf√§lliger Sequenzen empfangen werden. <br><br>  <code>access_token</code> gesagt, mit dem CSRF-Token kann ein Anwendungsclient die folgende Frage beantworten: "War das ich, der die Anforderung <code>access_token</code> initiiert <code>access_token</code> oder versucht jemand, mich <code>access_token</code> ?". <br><br><h4>  Hardcodiertes Kundengeheimnis </h4><br>  Mobile Anwendungen ohne Backend speichern manchmal <code>client_id</code> <code>client_secret</code> Werte f√ºr <code>client_id</code> und <code>client_secret</code> .  Nat√ºrlich k√∂nnen sie einfach per Reverse Engineering App extrahiert werden. <br><br>  Die Auswirkung der Offenlegung von <code>client_id</code> und <code>client_secret</code> h√§ngt stark davon ab, wie viel Vertrauensdienstanbieter auf das bestimmte Paar <code>client_id</code> , <code>client_secret</code> legt.  Man verwendet sie nur, um einen Client von einem anderen zu unterscheiden, w√§hrend andere versteckte API-Endpunkte √∂ffnen oder f√ºr einige Clients niedrigere Ratenbeschr√§nkungen festlegen. <br><br>  In dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum OAuth-API-Schl√ºssel und -Sekrete in mobilen Apps nicht sicher sind, wird</a> dieses Thema ausf√ºhrlicher behandelt. <br><br><h4>  Sch√§dliche App als legitimer Client </h4><br>  Einige b√∂swillige Apps k√∂nnen die legitimen Apps imitieren und in ihrem Namen einen Zustimmungsbildschirm anzeigen (ein Zustimmungsbildschirm ist ein Bildschirm, auf dem ein Benutzer Folgendes sieht: "Ich bin damit einverstanden, Zugriff auf ... zu gew√§hren").  Der Benutzer kann auf "Zulassen" klicken und der b√∂sartigen App seine Daten zur Verf√ºgung stellen. <br><br>  Android und iOS bieten die Mechanismen f√ºr die Gegenpr√ºfung von Anwendungen.  Ein Anwendungsanbieter kann sicherstellen, dass eine Clientanwendung legitim ist und umgekehrt. <br><br>  Wenn der OAuth 2.0-Mechanismus einen Thread √ºber einen Browser verwendet, ist es leider unm√∂glich, sich gegen diesen Angriff zu verteidigen. <br><br><h4>  Andere Angriffe </h4><br>  Wir haben uns die Angriffe genauer angesehen, die nur f√ºr mobile OAuth 2.0 gelten.  Vergessen wir jedoch nicht die urspr√ºngliche OAuth 2.0: Ersetzung von <code>redirect_uri</code> , Abfangen des Datenverkehrs √ºber eine unsichere Verbindung usw.  Hier k√∂nnen Sie mehr dar√ºber lesen. <br><br><h1>  Wie geht das sicher? </h1><br>  Wir haben erfahren, wie das OAuth 2.0-Protokoll funktioniert und welche Schwachstellen es auf Mobilger√§ten aufweist.  Lassen Sie uns nun die einzelnen Teile zusammenf√ºgen, um ein sicheres mobiles OAuth 2.0-Schema zu erhalten. <br><br><h4>  Gute, schlechte OAuth 2.0 </h4><br>  Beginnen wir mit der richtigen Verwendung des Einwilligungsbildschirms.  Mobile Ger√§te haben zwei M√∂glichkeiten, eine Webseite in einer mobilen Anwendung zu √∂ffnen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/d1e/75a/740d1e75aedec07de286cf9d7fc49292.png"><br><br>  Der erste Weg f√ºhrt √ºber die benutzerdefinierte Registerkarte "Browser" (links im Bild).  <b>Hinweis</b> : Die benutzerdefinierte Registerkarte "Browser" f√ºr Android hei√üt "Chrome Custom Tab" und f√ºr iOS - SafariViewController.  Es ist nur eine Browser-Registerkarte, die in der App angezeigt wird: Es gibt keinen visuellen Wechsel zwischen den Anwendungen. <br><br>  Der zweite Weg f√ºhrt √ºber WebView (rechts im Bild) und ich halte es f√ºr schlecht in Bezug auf das mobile OAuth 2.0. <br><br>  WebView ist ein eingebetteter Browser f√ºr eine mobile App. <br><br>  " <i>Eingebetteter Browser</i> " bedeutet, dass der Zugriff auf Cookies, Speicher, Cache, Verlauf und andere Safari- und Chrome-Daten f√ºr WebView verboten ist.  Das Gegenteil ist auch richtig: Safari und Chrome k√∂nnen nicht auf WebView-Daten zugreifen. <br><br>  " <i>Browser f√ºr</i> mobile Apps" bedeutet, dass eine mobile App, auf der WebView ausgef√ºhrt wird, <b>vollen</b> Zugriff auf Cookies, Speicher, Cache, Verlauf und andere WebView-Daten hat. <br><br>  Stellen Sie sich nun vor: Ein Benutzer klickt auf "Enter with ..." und ein WebView einer b√∂sartigen App fordert seinen Login und sein Passwort vom Dienstanbieter an. <br><br>  Epischer Fehler: <br><br><ol><li>  Der Benutzer gibt sein Login und Passwort f√ºr das Konto des Dienstanbieters in die App ein, mit dem diese Daten leicht gestohlen werden k√∂nnen. <br></li><li>  OAuth 2.0 wurde urspr√ºnglich entwickelt, <i>um die Anmeldung und das Kennwort des Dienstanbieters nicht einzugeben.</i> <i><br></i> <br>  Der Benutzer gew√∂hnt sich daran, sein Login und Passwort √ºberall einzugeben, was die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angelm√∂glichkeiten</a> erh√∂ht. <br></li></ol><br>  In Anbetracht aller Nachteile von WebView bietet sich eine offensichtliche Schlussfolgerung an: Verwenden Sie die benutzerdefinierte Registerkarte Browser f√ºr den Zustimmungsbildschirm. <br><br>  Wenn jemand Argumente f√ºr WebView anstelle von Browser Custom Tab hat, w√ºrde ich mich freuen, wenn Sie dar√ºber in den Kommentaren schreiben. <br><br><h4>  Sicheres mobiles OAuth 2.0-Schema </h4><br>  Wir werden das Authorization Code Grant-Schema verwenden, da es uns erm√∂glicht, <code>code_challenge</code> hinzuzuf√ºgen sowie einen Code-Interception-Angriff und OAuth 2.0 CSRF <code>code_challenge</code> und zu verteidigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Bildursprung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Die Codezugriffsanforderung (Schritte 1-2) sieht wie folgt aus: <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> 3D% 3D &amp; <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  In Schritt 3 erh√§lt der Browser eine Antwort mit Umleitung: <br><br><pre> <code class="plaintext hljs">com.mail.cloud.app://outh? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> </pre> <br>  In Schritt 4 √∂ffnet der Browser das benutzerdefinierte URI-Schema und √ºbergibt das CSRF-Token an eine Client-App. <br>  <code>access_token</code> Anforderung (Schritt 5): <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/token? code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  Der letzte Schritt bringt eine Antwort mit <code>access_token</code> . <br><br>  Dieses Schema ist im Allgemeinen sicher, aber es gibt einige Sonderf√§lle, in denen OAuth 2.0 einfacher und sicherer sein kann. <br><br><h4>  Android IPC </h4><br>  Android verf√ºgt √ºber einen Mechanismus zur bidirektionalen Datenkommunikation zwischen Prozessen: IPC (Inter-Process Communication).  IPC ist aus zwei Gr√ºnden besser als das benutzerdefinierte URI-Schema: <br><br><ol><li>  Eine App, die den IPC-Kanal √∂ffnet, kann die Authentizit√§t einer App, die sie √∂ffnet, anhand ihres Zertifikats best√§tigen.  Das Gegenteil ist auch der Fall: Die ge√∂ffnete App kann die Authentizit√§t der App best√§tigen, die sie ge√∂ffnet hat. <br></li><li>  Wenn ein Absender eine Anfrage √ºber den IPC-Kanal sendet, kann er eine Antwort √ºber denselben Kanal empfangen.  Zusammen mit der Gegenpr√ºfung (Punkt 1) bedeutet dies, dass kein fremder Prozess <code>access_token</code> abfangen <code>access_token</code> . <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/dac/d7c/1a9/dacd7c1a98a6d1c7227b7e8e5e24757f.png"><br><br>  Daher k√∂nnen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implicit Grant verwenden</a> , um das mobile OAuth 2.0-Schema zu vereinfachen.  Keine <code>code_challenge</code> und kein <code>code_challenge</code> bedeuten auch weniger Angriffsfl√§che.  Wir k√∂nnen auch das Risiko verringern, dass sich b√∂swillige Apps wie legitime Kunden verhalten, die versuchen, die Benutzerkonten zu stehlen. <br><br><h4>  SDK f√ºr Kunden </h4><br>  Neben der Implementierung dieses sicheren mobilen OAuth 2.0-Schemas sollte ein Anbieter ein SDK f√ºr seine Kunden entwickeln.  Dies vereinfacht die Implementierung von OAuth 2.0 auf Clientseite und reduziert gleichzeitig die Anzahl der Fehler und Schwachstellen. <br><br><h1>  Schlussfolgerungen </h1><br>  Lassen Sie es mich f√ºr Sie zusammenfassen.  Hier ist die (grundlegende) <i>Checkliste f√ºr sicheres OAuth 2.0</i> f√ºr OAuth 2.0-Anbieter: <br><br><ol><li>  Ein starkes Fundament ist entscheidend.  Im Fall von mobilem OAuth 2.0 ist die Grundlage ein Schema oder ein Protokoll, das f√ºr die Implementierung ausgew√§hlt wurde.  Es ist leicht, Fehler zu machen, w√§hrend Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihr eigenes OAuth 2.0-Schema implementieren</a> .  Andere haben bereits geklopft und ihre Lektion gelernt;  Es ist nichts Falsches daran, aus ihren Fehlern zu lernen und eine sichere Implementierung auf einmal durchzuf√ºhren.  Das sicherste mobile OAuth 2.0-Schema wird unter <i>Wie wird es sicher durchgef√ºhrt</i> ? Beschrieben. <br></li><li>  <code>Access_token</code> und andere vertrauliche Daten m√ºssen in Keychain f√ºr iOS und in Internal Storage f√ºr Android gespeichert werden.  Diese Speicher wurden speziell daf√ºr entwickelt.  Der Inhaltsanbieter kann in Android verwendet werden, muss jedoch sicher konfiguriert sein. <br></li><li>  <code>Client_secret</code> ist <b>nutzlos</b> , es sei denn, es wird im Backend gespeichert.  Geben Sie es nicht an √∂ffentliche Kunden weiter. <br></li><li>  Verwenden Sie WebView nicht f√ºr den Zustimmungsbildschirm.  Verwenden Sie die benutzerdefinierte Registerkarte des Browsers. <br></li><li>  Verwenden Sie <code>code_challenge</code> um sich gegen Code-Interception-Angriffe zu verteidigen. <br></li><li>  Verwenden Sie <code>state</code> um sich gegen OAuth 2.0 CSRF zu verteidigen. <br></li><li>  Verwenden Sie HTTPS <b>√ºberall</b> , wobei ein Downgrade auf HTTP verboten ist.  Hier ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3-min√ºtige Demo, die</a> erkl√§rt, warum (mit einem Beispiel aus einer Bug Bounty). <br></li><li>  Befolgen Sie die Kryptografiestandards (Auswahl des Algorithmus, L√§nge der Token usw.).  Sie k√∂nnen die Daten kopieren und herausfinden, warum dies so gemacht wird, aber keine eigene Krypto rollen. <br></li><li>  <code>Code</code> darf nur einmal verwendet werden, mit einer kurzen Lebensdauer. <br></li><li>  √úberpr√ºfen Sie auf der Seite eines App-Clients, was Sie f√ºr OAuth 2.0 √∂ffnen.  √úberpr√ºfen Sie auf der Seite eines App-Anbieters, wer Sie f√ºr OAuth 2.0 √∂ffnet. <br></li><li>  Beachten Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allgemeinen OAuth 2.0-Schwachstellen</a> .  Mobile OAuth 2.0 vergr√∂√üert und vervollst√§ndigt das Original. Daher ist <code>redirect_uri</code> √úberpr√ºfung von <code>redirect_uri</code> auf eine genaue √úbereinstimmung und andere Empfehlungen f√ºr das Original OAuth 2.0 noch in Kraft. <br></li><li>  Sie sollten Ihren Kunden das SDK zur Verf√ºgung stellen.  Sie haben weniger Fehler und Schwachstellen und es wird f√ºr sie einfacher sein, OAuth 2.0 zu implementieren. <br></li></ol><br><h1>  Weiterf√ºhrende Literatur </h1><br><ol><li>  "Sicherheitsl√ºcken von Mobile OAuth 2.0" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch?v=vjCF_O6aZIg</a> <br></li><li>  OAuth 2.0 Race Condition Research <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://hackerone.com/reports/55140</a> <br></li><li>  Fast alles √ºber OAuth 2.0 an einem Ort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://oauth.net/2/</a> <br></li><li>  Warum OAuth-API-Schl√ºssel und -Sekrete in mobilen Apps nicht sicher sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developer.okta.com/blog/2019/01/22/oauth-api-keys-arent-safe-in-mobile-apps</a> <br></li><li>  [RFC] OAuth 2.0 f√ºr native Apps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc8252</a> <br></li><li>  [RFC] Proof-Schl√ºssel f√ºr den Code-Austausch durch √∂ffentliche OAuth-Clients <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7636</a> <br></li><li>  [RFC] √úberlegungen zum OAuth 2.0-Bedrohungsmodell und zur Sicherheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc6819</a> <br></li><li>  [RFC] OAuth 2.0 Dynamic Client Registration Protocol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7591</a> <br></li><li>  Google OAuth 2.0 f√ºr mobile und Desktop-Apps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> <br></li></ol><br><h1>  Credits </h1><br>  Vielen Dank an alle, die mir geholfen haben, diesen Artikel zu schreiben.  Insbesondere an Sergei Belov, Andrei Sumin, Andrey Labunets f√ºr das Feedback zu technischen Details, an Pavel Kruglov f√ºr die englische √úbersetzung und an Daria Yakovleva f√ºr die Hilfe bei der Ver√∂ffentlichung der russischen Version dieses Artikels. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456702/">https://habr.com/ru/post/de456702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456686/index.html">Die Feinheiten von Interviews bei der Einstellung von Udalenka</a></li>
<li><a href="../de456690/index.html">Alltagskopfh√∂rer von Case Guru - CGPods Sport</a></li>
<li><a href="../de456692/index.html">Der Aufstieg und Fall von Visual Basic</a></li>
<li><a href="../de456696/index.html">Wie fallen Darlehenszinsen an und wie werden sie angewendet?</a></li>
<li><a href="../de456700/index.html">GeekUniversity er√∂ffnet Rekrutierung an der Fakult√§t f√ºr Produktmanagement</a></li>
<li><a href="../de456704/index.html">Sechs M√∂glichkeiten, wie Tester profitieren k√∂nnen (neben Funktionstests)</a></li>
<li><a href="../de456710/index.html">Was ist eine Low-Code / No-Code-Plattform und CRM, CRM +, ERP</a></li>
<li><a href="../de456712/index.html">Selektive Verkehrsprotokollierung f√ºr SOAP-Dienste</a></li>
<li><a href="../de456714/index.html">Gleitkommazahlen verstehen (Teil 0)</a></li>
<li><a href="../de456716/index.html">Nicht sehr gro√üe Datenmengen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>