<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∞ ü§∞üèø üë¥üèæ Geod√§tische Kuppel. √úber das Ger√§t und meine Erfahrungen mit Berechnungen ‚úçüèø ü§∞üèº ‚ô¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vielleicht ist es schwierig, die geod√§tischen Kuppeln als ungew√∂hnlich oder neu zu bezeichnen. In diesem Artikel werde ich ein wenig √ºber diese Entw√ºr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geod√§tische Kuppel. √úber das Ger√§t und meine Erfahrungen mit Berechnungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481616/">  Vielleicht ist es schwierig, die geod√§tischen Kuppeln als ungew√∂hnlich oder neu zu bezeichnen.  In diesem Artikel werde ich ein wenig √ºber diese Entw√ºrfe im Allgemeinen und √ºber ihre Struktur sprechen und als Beispiel zeigen, wie ich etwas zu diesem Thema betrachtet habe.  Der Code wird auch sein. <br><br><img src="https://habrastorage.org/webt/g_/4f/g_/g_4fg_nupzjmqyhxh1gqh_hzfiw.jpeg"><a name="habracut"></a><br><br>  Ich werde Wikipedia nicht zitieren.  Warum habe ich die Kuppel als mein Zuhause gew√§hlt? <br><br><ul><li>  Bei gleichem Volumen ist die Oberfl√§che der Kugel kleiner als bei jeder anderen Form.  Dies wirkt sich sowohl auf den Materialverbrauch als auch auf den Energieverbrauch w√§hrend des Betriebs positiv aus. </li><li>  Mir gef√§llt, wie die Kugel aussieht. </li><li>  Dies ist in gewisser Hinsicht ein interessantes Ingenieurprojekt, sogar eine Herausforderung.  Es ist schwierig, schwierig und macht deshalb Spa√ü! <br></li></ul><br>  Wie sind diese geod√§tischen Bereiche im Allgemeinen angeordnet?  Auf den ersten Blick scheint dies eine Art Verwebung von Kanten zu sein, und es ist schwierig, das System zu erfassen.  Wir werden versuchen, das herauszufinden. <br><br>  Die Basis solcher Strukturen ist das Ikosaeder oder Oktaeder.  In der Regel ein regul√§res Polyeder. <br>  In meinem Fall war es genau das Ikosaeder und wird h√§ufiger verwendet.  Als n√§chstes nehmen wir eine Fl√§che und ersetzen sie durch mehrere Dreiecke, deren Eckpunkte auf einer Kugel liegen, deren Zentrum mit dem Zentrum des Ikosaeders zusammenf√§llt.  Das h√∂rt sich nicht gut an.  Lassen Sie uns abschweifen. <br><br>  Es gibt einen wunderbaren Rechner <a href="http://www.acidome.ru/" rel="nofollow">www.acidome.ru</a> , mit dem Sie den Vermesser in Echtzeit drehen k√∂nnen.  Nehmen Sie Ikosaeder als Basis, setzen Sie die Frequenz auf 1, Teil der Kugel 1/1. <br><br><img src="https://habrastorage.org/webt/0t/af/hi/0tafhisjd7bdalic5mdbhjqhvv8.png"><br><br>  Dies ist unser Hauptikosaeder.  Frequenz ist, wie viele Teile wir jede Kante des Ikosaeders brechen werden.  Wir setzen 3.4, 5 und nichts wird klar.  Wechseln Sie in den Dachmodus und suchen Sie nach F√ºnfecken.  An den Stellen, an denen wir die Spitze des Ikosaeders haben, wird es ein F√ºnfeck geben.  Zwischen den drei F√ºnfecken befindet sich das Gesicht des Ikosaeders. <br><br><img src="https://habrastorage.org/webt/s8/ll/is/s8llisbf4pp0qys0ssqtxlwusxs.png"><br><br>  Wenn Sie sich die Geod√§sie genau ansehen und wissen, wonach Sie suchen m√ºssen (normalerweise ein F√ºnfeck), wird die Regelm√§√üigkeit der Struktur sichtbar.  Auf der Biosph√§re in Montreal k√∂nnen Sie mit der gebotenen Sorgfalt Pentagone finden und die H√§ufigkeit berechnen.  Unsere Frequenz ist gleich der Anzahl der Kanten zwischen zwei F√ºnfecken. <br><br>  Die ‚Äûgro√üen‚Äú Dreiecke selbst, mit Eckpunkten auf den Spitzen des Ikosaeders, haben ebenfalls eine Struktur.  Auf Acidome-D√§chern ist dies farblich sichtbar.  Dreiecke sind symmetrisch zur Mitte des ‚Äûgro√üen‚Äú Dreiecks angeordnet.  Die Anzahl ihrer Typen ist geringer als die Gesamtzahl der Dreiecke.  Bei einer H√§ufigkeit von 5 eindeutigen Dreiecken 9. <br><br><img src="https://habrastorage.org/webt/iv/ky/ve/ivkyvedvegtwxidkcjgdrqvruxc.png"><br><br>  Beim Entwerfen eines Hauses stand ich vor der Aufgabe, in Dynamo eine Kugel zu bauen.  Mit diesem Tool k√∂nnen Sie Autodesk Revit das Arbeiten mit komplexen Formularen beibringen.  Eine solche visuelle Programmierumgebung. <br>  Beim Googeln habe ich sogar eine Skizze gefunden, die in Dynamo eine geod√§tische Kugel erzeugt hat.  Er baute die Kugel, aber nicht diese. <br><br>  Hier ist das Ding.  Wenn wir eine Kante des Ikosaeders nehmen und in kleine Dreiecke teilen, kann dies auf verschiedene Arten geschehen.  In acidome ist daf√ºr der Schalter ‚ÄûSplitting Method‚Äú zust√§ndig. <br><br>  Die gefundene Skizze baute die Kugel mit der Gleichakkordmethode.  Was bedeutet das?  Wir nehmen ein gro√ües Dreieck des Ikosaeders, teilen jede seiner Kanten in die Anzahl der ben√∂tigten Teile auf, verbinden die Punkte an den Kanten miteinander und erhalten ein flaches Dreiecksgitter.  Dann projizieren wir dieses Gitter auf die Kugel.  Alles w√§re in Ordnung, aber diese Dreiecke selbst haben eine ganz andere Gr√∂√üe.  Vor allem zentral.  Es ist verst√§ndlich, dass der Mittelpunkt des ‚Äûgro√üen‚Äú Dreiecks maximal von der Kugel entfernt ist.  Dies ist schlecht, da es in diesem Fall schwieriger ist, den Materialverbrauch zu optimieren.  Es wird mehr Abfall geben. <br><br>  Eine andere Methode zum Teilen (mit gleichen B√∂gen) setzt voraus, dass wir auf dem ‚Äûgro√üen‚Äú Dreieck des Bogens aufbauen und diese bereits in gleiche Teile teilen.  Der Ansatz ist anders, eine einfache Projektion geht nicht. <br><br>  Die Skizze passte nicht.  Ich habe versucht, das Problem zu beheben, und am Ende musste ich mit meinem Kopf in dieses Gesch√§ft eintauchen. <br><br>  Wie sich herausstellte, hat Dynamo neben der visuellen Umgebung auch Python eingebaut.  Ich bin dieser Sprache noch nicht begegnet, aber wo ist unsere Sprache nicht verschwunden?  Am Ende ist es nur ein Werkzeug. <br><br>  Dann wird es Teile des Codes geben, bitte beachten Sie, dass dies meine Hallo-Welt in Python ist und das Ziel nicht darin bestand, die effektivste und effizienteste L√∂sung zu erstellen, sondern die richtige Sph√§re. <br><br><h3>  Die Methode der gleichen B√∂gen. </h3><br>  Wir nehmen eine der Seiten des Ikosaeders und bilden B√∂gen aus den Ecken dieses Dreiecks. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, edge <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(curves): <span class="hljs-comment"><span class="hljs-comment">#   arc = Arc.ByCenterPointStartPointEndPoint(sphere_center, edge.EndPoint, edge.StartPoint) #   ,    result_points.append(edge.EndPoint) result_points.append(edge.StartPoint) #    "",       if arc.SweepAngle &gt; 90: arc = Arc.ByCenterPointStartPointEndPoint(center_point, edge.StartPoint, edge.EndPoint) #      arc_points = Arc.PointsAtEqualSegmentLength(arc, n) else: arc_points = list(reversed(Arc.PointsAtEqualSegmentLength(arc, n))) #     for p in arc_points: result_points.append(p)</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/6n/mw/ff/6nmwfffgaym7bbmdnhmysua2hpk.png"><br><br>  Dann teilen wir die B√∂gen in gleiche Teile und verbinden die Punkte auf den B√∂gen mit neuen B√∂gen.  Alle B√∂gen haben ein Zentrum - das Zentrum der Kugel.  Punkte sind nicht alle mit allen verbunden, sondern gleichnamig.  Auf dem Bild sieht es einfacher aus als im Code. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> edge_index, point_list <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(points): edge_arcs = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point_index, point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(point_list): next_edge_index = edge_index + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(points) == next_edge_index: next_edge_index = <span class="hljs-number"><span class="hljs-number">0</span></span> end_point_index = n - point_index - <span class="hljs-number"><span class="hljs-number">2</span></span> arc = Arc.ByCenterPointStartPointEndPoint(center_point, points[next_edge_index][end_point_index], point) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> arc.SweepAngle &gt; <span class="hljs-number"><span class="hljs-number">90</span></span>: arc = Arc.ByCenterPointStartPointEndPoint(center_point, point, points[next_edge_index][end_point_index]) arc_points_count = n - point_index - <span class="hljs-number"><span class="hljs-number">1</span></span>; pp = Arc.PointsAtEqualSegmentLength(arc, arc_points_count) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> po <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pp: on_arc_points.append(po) edge_arcs.append(arc) edges_arcs.append(edge_arcs)</code> </pre> <br><img src="https://habrastorage.org/webt/dk/ts/uq/dktsuqxgjr3q3c_irgi653rd4di.png"><br><br>  Ups, und die B√∂gen kreuzen sich nicht!  Das nicht allzu flie√üende Googeln brachte mich zu einem Buch, das meine Vermutungen best√§tigte, dass es notwendig ist, das Zentrum eines Dreiecks, das durch die √úberschneidung von B√∂gen gebildet wird, als oberste Kante der Geod√§sie zu verwenden.  Ich habe auch die Acidomquellen geraucht, kann mich aber nicht erinnern, ob ich dort eine Best√§tigung gefunden habe.  Ich erinnere mich, dass es interessant war. <br>  Die Zentren m√ºssen irgendwie gefunden werden.  Dies ist das Zentrum des Dreiecks und es ist nicht schwierig, aber es war notwendig zu verstehen, wo sich diese Dreiecke auf dem Haufen von Punkten befinden.  Es schien mir die einfachste M√∂glichkeit zu sein, die Punkte, die am n√§chsten beieinander liegen, miteinander zu verbinden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> on_arc_points: distance = [] <span class="hljs-comment"><span class="hljs-comment">#       . for p2 in on_arc_points: distance.append(point.DistanceTo(p2)) distance.sort() #    three_points = [] for p2 in on_arc_points: if point.DistanceTo(p2) &lt;= distance[2]: three_points.append(p2); #   poly = Polygon.ByPoints(three_points) #   .     ,    result_points.append(poly.Center())</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/dv/wv/ab/dvwvabq-w9itkw7gppatlmspr90.png"><br><br>  Nun m√ºssen wir die Punkte, die in verschiedenen Stadien gesammelt wurden, miteinander verbinden. Dies sind die Eckpunkte der R√§nder der geod√§tischen Kugel.  Auf dem Bild sind diese Punkte deutlich sichtbar, aber wenn sie sich im Array befinden, ist alles komplizierter.  Es gab mehrere Optionen, aber da die Aufgabe darin bestand, mit geringstem Aufwand ein funktionierendes Skript zu erstellen, ergab sich Folgendes: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  -           ,    points = dict() for i, point in enumerate(projected): points[i] = dict() points[i]['point'] = point points[i]['id'] = i points[i]['distance'] = dict() for c, p2 in enumerate(projected): points[i]['distance'][c] = point.DistanceTo(p2) max_dist = 0 i = 0 for i, point in points.items(): max_distance = max(point['distance'].values()) if max_distance &gt; max_dist: root_point = i max_dist = max_distance row = dict() row[root_point] = points[root_point] del points[root_point] surfaces = [] while len(row): #for x in range(0, 2): next_row = dict() for id, item in row.items(): point = closest_point(points, id) if point is not None: tmp = points[point] del points[point] point2 = closest_point(points, id) points[point] = tmp if point2 is not None: surfaces.append(Surface.ByPerimeterPoints([item['point'], points[point]['point'], points[point2]['point']])) next_row[point] = points[point] next_row[point2] = points[point2] for id, item in next_row.items(): point = closest_point(row, id) if point is not None: tmp = row[point] del row[point] point2 = closest_point(row, id) row[point] = tmp if point2 is not None: surfaces.append(Surface.ByPerimeterPoints([row[point]['point'], row[point2]['point'], item['point']])) row.clear() for id, po in next_row.items(): if po['id'] in points: del points[po['id']] if po['id'] not in row: row[po['id']] = po face_triangles = surfaces</span></span></code> </pre> <br>  Das Segment ist fertig.  Es gibt wahrscheinlich einen richtigen Weg, um dieses Problem zu l√∂sen, aber ich habe meinen eigenen gepflastert. <br><br><img src="https://habrastorage.org/webt/bo/sb/jj/bosbjjyr1fbo1ce3tl2igljadpa.png"><br><br>  Dann entfaltet sich das Segment, es wird mehrmals kopiert und es wird eine vollst√§ndige Kugel erhalten.  Hier ist eine der Wendungen: <br><br><pre> <code class="python hljs">v = Vector.ByTwoPoints(sphere_center, curves[<span class="hljs-number"><span class="hljs-number">0</span></span>].StartPoint) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> face_triangle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> face_triangles: geodesic_sphere.append(Geometry.Rotate(face_triangle, sphere_center, v, <span class="hljs-number"><span class="hljs-number">72</span></span>))</code> </pre> <br>  Das Skript ist h√§sslich geworden, ich habe es ein paar Mal kopiert, weil beim Exportieren nach Revit Probleme aufgetreten sind.  Dachte, es gab Probleme mit der Konstruktion.  Infolgedessen forderte der Inder den Ukrainer auf dem Dynamo-Forum auf und alles war erfolgreich! <br><br>  Jetzt k√∂nnen Sie eine Kugel mit jeder Frequenz und jedem Durchmesser bauen.  Ein Vergleich der Gr√∂√üen mit den Acidom-Ergebnissen zeigte, dass alles mit hoher Genauigkeit konvergiert.  Wiederholbarkeit ist gut. <br><br><img src="https://habrastorage.org/webt/7g/h4/4c/7gh44c4aj3t-tcztm81q2foipq4.png"><br><br>  Ich habe auch begonnen, Gr√∂√üen zu optimieren, um die Ernte zu minimieren.  Da alle Gr√∂√üen in meinen H√§nden waren, war es nicht so schwierig.  Infolgedessen ergab sich ein Radius der Kugel von 5,65 Metern bei einer Frequenz von 5. Mit diesen Abmessungen kann ich Materialien mit einer Breite von 125 cm sehr effektiv verwenden. Solche Breiten sind OSB-Platten, Bleche, Isolierungen und Trockenbau.  Bei guter Optimierung ist die Anzahl der Ausschnitte minimal.  Die besten Ergebnisse erzielen Sie, wenn Sie die Layouts der Dreiecke auf dem Material berechnen. Dies habe ich jedoch nicht getan. <br><br>  Weiterhin war es einfacher, da Revit eine komplexe Form a√ü und es erm√∂glichte, mit ungef√§hr dem gleichen Erfolg wie mit Quadrat-Parallel zu arbeiten. <br><br>  Nat√ºrlich haben die Schwierigkeiten nicht aufgeh√∂rt, aber das ist eine ganz andere Geschichte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481616/">https://habr.com/ru/post/de481616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481600/index.html">Bonsai Family Wiki Engine: 2019 Ergebnisse</a></li>
<li><a href="../de481604/index.html">Wie hart Tscheljabinsk Entwickler Spiele f√ºr Google Play und soziale Netzwerke machen</a></li>
<li><a href="../de481606/index.html">Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers</a></li>
<li><a href="../de481610/index.html">PostgreSQL Antipatterns: Aktualisierung einer gro√üen Tabelle unter Last</a></li>
<li><a href="../de481612/index.html">Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfl√§che f√ºr weniger Plattformen</a></li>
<li><a href="../de481618/index.html">MVP in Unity oder wie man das Leben vereinfacht</a></li>
<li><a href="../de481620/index.html">Juniper SRX und Cisco ASA: N√§chste Serie</a></li>
<li><a href="../de481624/index.html">Schreiben einer Anwendung auf Flutter in Verbindung mit Redux</a></li>
<li><a href="../de481626/index.html">Komplexe Anzeigesammlungen in iOS: Probleme und L√∂sungen am Beispiel des VKontakte-Feeds</a></li>
<li><a href="../de481628/index.html">Regeln f√ºr das Schreiben vorbereitender Schritte in Testf√§llen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>