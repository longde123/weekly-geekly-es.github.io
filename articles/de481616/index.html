<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📰 🤰🏿 👴🏾 Geodätische Kuppel. Über das Gerät und meine Erfahrungen mit Berechnungen ✍🏿 🤰🏼 ♦️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vielleicht ist es schwierig, die geodätischen Kuppeln als ungewöhnlich oder neu zu bezeichnen. In diesem Artikel werde ich ein wenig über diese Entwür...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geodätische Kuppel. Über das Gerät und meine Erfahrungen mit Berechnungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481616/">  Vielleicht ist es schwierig, die geodätischen Kuppeln als ungewöhnlich oder neu zu bezeichnen.  In diesem Artikel werde ich ein wenig über diese Entwürfe im Allgemeinen und über ihre Struktur sprechen und als Beispiel zeigen, wie ich etwas zu diesem Thema betrachtet habe.  Der Code wird auch sein. <br><br><img src="https://habrastorage.org/webt/g_/4f/g_/g_4fg_nupzjmqyhxh1gqh_hzfiw.jpeg"><a name="habracut"></a><br><br>  Ich werde Wikipedia nicht zitieren.  Warum habe ich die Kuppel als mein Zuhause gewählt? <br><br><ul><li>  Bei gleichem Volumen ist die Oberfläche der Kugel kleiner als bei jeder anderen Form.  Dies wirkt sich sowohl auf den Materialverbrauch als auch auf den Energieverbrauch während des Betriebs positiv aus. </li><li>  Mir gefällt, wie die Kugel aussieht. </li><li>  Dies ist in gewisser Hinsicht ein interessantes Ingenieurprojekt, sogar eine Herausforderung.  Es ist schwierig, schwierig und macht deshalb Spaß! <br></li></ul><br>  Wie sind diese geodätischen Bereiche im Allgemeinen angeordnet?  Auf den ersten Blick scheint dies eine Art Verwebung von Kanten zu sein, und es ist schwierig, das System zu erfassen.  Wir werden versuchen, das herauszufinden. <br><br>  Die Basis solcher Strukturen ist das Ikosaeder oder Oktaeder.  In der Regel ein reguläres Polyeder. <br>  In meinem Fall war es genau das Ikosaeder und wird häufiger verwendet.  Als nächstes nehmen wir eine Fläche und ersetzen sie durch mehrere Dreiecke, deren Eckpunkte auf einer Kugel liegen, deren Zentrum mit dem Zentrum des Ikosaeders zusammenfällt.  Das hört sich nicht gut an.  Lassen Sie uns abschweifen. <br><br>  Es gibt einen wunderbaren Rechner <a href="http://www.acidome.ru/" rel="nofollow">www.acidome.ru</a> , mit dem Sie den Vermesser in Echtzeit drehen können.  Nehmen Sie Ikosaeder als Basis, setzen Sie die Frequenz auf 1, Teil der Kugel 1/1. <br><br><img src="https://habrastorage.org/webt/0t/af/hi/0tafhisjd7bdalic5mdbhjqhvv8.png"><br><br>  Dies ist unser Hauptikosaeder.  Frequenz ist, wie viele Teile wir jede Kante des Ikosaeders brechen werden.  Wir setzen 3.4, 5 und nichts wird klar.  Wechseln Sie in den Dachmodus und suchen Sie nach Fünfecken.  An den Stellen, an denen wir die Spitze des Ikosaeders haben, wird es ein Fünfeck geben.  Zwischen den drei Fünfecken befindet sich das Gesicht des Ikosaeders. <br><br><img src="https://habrastorage.org/webt/s8/ll/is/s8llisbf4pp0qys0ssqtxlwusxs.png"><br><br>  Wenn Sie sich die Geodäsie genau ansehen und wissen, wonach Sie suchen müssen (normalerweise ein Fünfeck), wird die Regelmäßigkeit der Struktur sichtbar.  Auf der Biosphäre in Montreal können Sie mit der gebotenen Sorgfalt Pentagone finden und die Häufigkeit berechnen.  Unsere Frequenz ist gleich der Anzahl der Kanten zwischen zwei Fünfecken. <br><br>  Die „großen“ Dreiecke selbst, mit Eckpunkten auf den Spitzen des Ikosaeders, haben ebenfalls eine Struktur.  Auf Acidome-Dächern ist dies farblich sichtbar.  Dreiecke sind symmetrisch zur Mitte des „großen“ Dreiecks angeordnet.  Die Anzahl ihrer Typen ist geringer als die Gesamtzahl der Dreiecke.  Bei einer Häufigkeit von 5 eindeutigen Dreiecken 9. <br><br><img src="https://habrastorage.org/webt/iv/ky/ve/ivkyvedvegtwxidkcjgdrqvruxc.png"><br><br>  Beim Entwerfen eines Hauses stand ich vor der Aufgabe, in Dynamo eine Kugel zu bauen.  Mit diesem Tool können Sie Autodesk Revit das Arbeiten mit komplexen Formularen beibringen.  Eine solche visuelle Programmierumgebung. <br>  Beim Googeln habe ich sogar eine Skizze gefunden, die in Dynamo eine geodätische Kugel erzeugt hat.  Er baute die Kugel, aber nicht diese. <br><br>  Hier ist das Ding.  Wenn wir eine Kante des Ikosaeders nehmen und in kleine Dreiecke teilen, kann dies auf verschiedene Arten geschehen.  In acidome ist dafür der Schalter „Splitting Method“ zuständig. <br><br>  Die gefundene Skizze baute die Kugel mit der Gleichakkordmethode.  Was bedeutet das?  Wir nehmen ein großes Dreieck des Ikosaeders, teilen jede seiner Kanten in die Anzahl der benötigten Teile auf, verbinden die Punkte an den Kanten miteinander und erhalten ein flaches Dreiecksgitter.  Dann projizieren wir dieses Gitter auf die Kugel.  Alles wäre in Ordnung, aber diese Dreiecke selbst haben eine ganz andere Größe.  Vor allem zentral.  Es ist verständlich, dass der Mittelpunkt des „großen“ Dreiecks maximal von der Kugel entfernt ist.  Dies ist schlecht, da es in diesem Fall schwieriger ist, den Materialverbrauch zu optimieren.  Es wird mehr Abfall geben. <br><br>  Eine andere Methode zum Teilen (mit gleichen Bögen) setzt voraus, dass wir auf dem „großen“ Dreieck des Bogens aufbauen und diese bereits in gleiche Teile teilen.  Der Ansatz ist anders, eine einfache Projektion geht nicht. <br><br>  Die Skizze passte nicht.  Ich habe versucht, das Problem zu beheben, und am Ende musste ich mit meinem Kopf in dieses Geschäft eintauchen. <br><br>  Wie sich herausstellte, hat Dynamo neben der visuellen Umgebung auch Python eingebaut.  Ich bin dieser Sprache noch nicht begegnet, aber wo ist unsere Sprache nicht verschwunden?  Am Ende ist es nur ein Werkzeug. <br><br>  Dann wird es Teile des Codes geben, bitte beachten Sie, dass dies meine Hallo-Welt in Python ist und das Ziel nicht darin bestand, die effektivste und effizienteste Lösung zu erstellen, sondern die richtige Sphäre. <br><br><h3>  Die Methode der gleichen Bögen. </h3><br>  Wir nehmen eine der Seiten des Ikosaeders und bilden Bögen aus den Ecken dieses Dreiecks. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, edge <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(curves): <span class="hljs-comment"><span class="hljs-comment">#   arc = Arc.ByCenterPointStartPointEndPoint(sphere_center, edge.EndPoint, edge.StartPoint) #   ,    result_points.append(edge.EndPoint) result_points.append(edge.StartPoint) #    "",       if arc.SweepAngle &gt; 90: arc = Arc.ByCenterPointStartPointEndPoint(center_point, edge.StartPoint, edge.EndPoint) #      arc_points = Arc.PointsAtEqualSegmentLength(arc, n) else: arc_points = list(reversed(Arc.PointsAtEqualSegmentLength(arc, n))) #     for p in arc_points: result_points.append(p)</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/6n/mw/ff/6nmwfffgaym7bbmdnhmysua2hpk.png"><br><br>  Dann teilen wir die Bögen in gleiche Teile und verbinden die Punkte auf den Bögen mit neuen Bögen.  Alle Bögen haben ein Zentrum - das Zentrum der Kugel.  Punkte sind nicht alle mit allen verbunden, sondern gleichnamig.  Auf dem Bild sieht es einfacher aus als im Code. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> edge_index, point_list <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(points): edge_arcs = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point_index, point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(point_list): next_edge_index = edge_index + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(points) == next_edge_index: next_edge_index = <span class="hljs-number"><span class="hljs-number">0</span></span> end_point_index = n - point_index - <span class="hljs-number"><span class="hljs-number">2</span></span> arc = Arc.ByCenterPointStartPointEndPoint(center_point, points[next_edge_index][end_point_index], point) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> arc.SweepAngle &gt; <span class="hljs-number"><span class="hljs-number">90</span></span>: arc = Arc.ByCenterPointStartPointEndPoint(center_point, point, points[next_edge_index][end_point_index]) arc_points_count = n - point_index - <span class="hljs-number"><span class="hljs-number">1</span></span>; pp = Arc.PointsAtEqualSegmentLength(arc, arc_points_count) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> po <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pp: on_arc_points.append(po) edge_arcs.append(arc) edges_arcs.append(edge_arcs)</code> </pre> <br><img src="https://habrastorage.org/webt/dk/ts/uq/dktsuqxgjr3q3c_irgi653rd4di.png"><br><br>  Ups, und die Bögen kreuzen sich nicht!  Das nicht allzu fließende Googeln brachte mich zu einem Buch, das meine Vermutungen bestätigte, dass es notwendig ist, das Zentrum eines Dreiecks, das durch die Überschneidung von Bögen gebildet wird, als oberste Kante der Geodäsie zu verwenden.  Ich habe auch die Acidomquellen geraucht, kann mich aber nicht erinnern, ob ich dort eine Bestätigung gefunden habe.  Ich erinnere mich, dass es interessant war. <br>  Die Zentren müssen irgendwie gefunden werden.  Dies ist das Zentrum des Dreiecks und es ist nicht schwierig, aber es war notwendig zu verstehen, wo sich diese Dreiecke auf dem Haufen von Punkten befinden.  Es schien mir die einfachste Möglichkeit zu sein, die Punkte, die am nächsten beieinander liegen, miteinander zu verbinden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> on_arc_points: distance = [] <span class="hljs-comment"><span class="hljs-comment">#       . for p2 in on_arc_points: distance.append(point.DistanceTo(p2)) distance.sort() #    three_points = [] for p2 in on_arc_points: if point.DistanceTo(p2) &lt;= distance[2]: three_points.append(p2); #   poly = Polygon.ByPoints(three_points) #   .     ,    result_points.append(poly.Center())</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/dv/wv/ab/dvwvabq-w9itkw7gppatlmspr90.png"><br><br>  Nun müssen wir die Punkte, die in verschiedenen Stadien gesammelt wurden, miteinander verbinden. Dies sind die Eckpunkte der Ränder der geodätischen Kugel.  Auf dem Bild sind diese Punkte deutlich sichtbar, aber wenn sie sich im Array befinden, ist alles komplizierter.  Es gab mehrere Optionen, aber da die Aufgabe darin bestand, mit geringstem Aufwand ein funktionierendes Skript zu erstellen, ergab sich Folgendes: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  -           ,    points = dict() for i, point in enumerate(projected): points[i] = dict() points[i]['point'] = point points[i]['id'] = i points[i]['distance'] = dict() for c, p2 in enumerate(projected): points[i]['distance'][c] = point.DistanceTo(p2) max_dist = 0 i = 0 for i, point in points.items(): max_distance = max(point['distance'].values()) if max_distance &gt; max_dist: root_point = i max_dist = max_distance row = dict() row[root_point] = points[root_point] del points[root_point] surfaces = [] while len(row): #for x in range(0, 2): next_row = dict() for id, item in row.items(): point = closest_point(points, id) if point is not None: tmp = points[point] del points[point] point2 = closest_point(points, id) points[point] = tmp if point2 is not None: surfaces.append(Surface.ByPerimeterPoints([item['point'], points[point]['point'], points[point2]['point']])) next_row[point] = points[point] next_row[point2] = points[point2] for id, item in next_row.items(): point = closest_point(row, id) if point is not None: tmp = row[point] del row[point] point2 = closest_point(row, id) row[point] = tmp if point2 is not None: surfaces.append(Surface.ByPerimeterPoints([row[point]['point'], row[point2]['point'], item['point']])) row.clear() for id, po in next_row.items(): if po['id'] in points: del points[po['id']] if po['id'] not in row: row[po['id']] = po face_triangles = surfaces</span></span></code> </pre> <br>  Das Segment ist fertig.  Es gibt wahrscheinlich einen richtigen Weg, um dieses Problem zu lösen, aber ich habe meinen eigenen gepflastert. <br><br><img src="https://habrastorage.org/webt/bo/sb/jj/bosbjjyr1fbo1ce3tl2igljadpa.png"><br><br>  Dann entfaltet sich das Segment, es wird mehrmals kopiert und es wird eine vollständige Kugel erhalten.  Hier ist eine der Wendungen: <br><br><pre> <code class="python hljs">v = Vector.ByTwoPoints(sphere_center, curves[<span class="hljs-number"><span class="hljs-number">0</span></span>].StartPoint) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> face_triangle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> face_triangles: geodesic_sphere.append(Geometry.Rotate(face_triangle, sphere_center, v, <span class="hljs-number"><span class="hljs-number">72</span></span>))</code> </pre> <br>  Das Skript ist hässlich geworden, ich habe es ein paar Mal kopiert, weil beim Exportieren nach Revit Probleme aufgetreten sind.  Dachte, es gab Probleme mit der Konstruktion.  Infolgedessen forderte der Inder den Ukrainer auf dem Dynamo-Forum auf und alles war erfolgreich! <br><br>  Jetzt können Sie eine Kugel mit jeder Frequenz und jedem Durchmesser bauen.  Ein Vergleich der Größen mit den Acidom-Ergebnissen zeigte, dass alles mit hoher Genauigkeit konvergiert.  Wiederholbarkeit ist gut. <br><br><img src="https://habrastorage.org/webt/7g/h4/4c/7gh44c4aj3t-tcztm81q2foipq4.png"><br><br>  Ich habe auch begonnen, Größen zu optimieren, um die Ernte zu minimieren.  Da alle Größen in meinen Händen waren, war es nicht so schwierig.  Infolgedessen ergab sich ein Radius der Kugel von 5,65 Metern bei einer Frequenz von 5. Mit diesen Abmessungen kann ich Materialien mit einer Breite von 125 cm sehr effektiv verwenden. Solche Breiten sind OSB-Platten, Bleche, Isolierungen und Trockenbau.  Bei guter Optimierung ist die Anzahl der Ausschnitte minimal.  Die besten Ergebnisse erzielen Sie, wenn Sie die Layouts der Dreiecke auf dem Material berechnen. Dies habe ich jedoch nicht getan. <br><br>  Weiterhin war es einfacher, da Revit eine komplexe Form aß und es ermöglichte, mit ungefähr dem gleichen Erfolg wie mit Quadrat-Parallel zu arbeiten. <br><br>  Natürlich haben die Schwierigkeiten nicht aufgehört, aber das ist eine ganz andere Geschichte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481616/">https://habr.com/ru/post/de481616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481600/index.html">Bonsai Family Wiki Engine: 2019 Ergebnisse</a></li>
<li><a href="../de481604/index.html">Wie hart Tscheljabinsk Entwickler Spiele für Google Play und soziale Netzwerke machen</a></li>
<li><a href="../de481606/index.html">Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers</a></li>
<li><a href="../de481610/index.html">PostgreSQL Antipatterns: Aktualisierung einer großen Tabelle unter Last</a></li>
<li><a href="../de481612/index.html">Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfläche für weniger Plattformen</a></li>
<li><a href="../de481618/index.html">MVP in Unity oder wie man das Leben vereinfacht</a></li>
<li><a href="../de481620/index.html">Juniper SRX und Cisco ASA: Nächste Serie</a></li>
<li><a href="../de481624/index.html">Schreiben einer Anwendung auf Flutter in Verbindung mit Redux</a></li>
<li><a href="../de481626/index.html">Komplexe Anzeigesammlungen in iOS: Probleme und Lösungen am Beispiel des VKontakte-Feeds</a></li>
<li><a href="../de481628/index.html">Regeln für das Schreiben vorbereitender Schritte in Testfällen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>