<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐭 🍡 👩🏿‍🌾 Entwicklung von Schnittstellenklassen in C ++ 💐 🍱 👨‍👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schnittstellenklassen werden in C ++ - Programmen sehr häufig verwendet. Leider werden bei der Implementierung von Lösungen, die auf Schnittstellenkla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung von Schnittstellenklassen in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427281/"><hr><p>  <i>Schnittstellenklassen werden in C ++ - Programmen sehr häufig verwendet.</i>  <i>Leider werden bei der Implementierung von Lösungen, die auf Schnittstellenklassen basieren, häufig Fehler gemacht.</i>  <i>Der Artikel beschreibt das korrekte Entwerfen von Schnittstellenklassen. Dabei werden verschiedene Optionen berücksichtigt.</i>  <i>Die Verwendung von intelligenten Zeigern wird ausführlich beschrieben.</i>  <i>Es wird ein Beispiel für die Implementierung einer Ausnahmeklasse und einer Sammlungsklassenvorlage basierend auf Schnittstellenklassen gegeben.</i> </p><hr><br><a name="habracut"></a><br><h1>  Inhaltsverzeichnis </h1><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Spezielle Elementfunktionen zum Erstellen und Löschen von Objekten</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezielle Mitgliederfunktionen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objekte erstellen und löschen - grundlegende Details</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Destruktorzugriffsebene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In einem Modul erstellen und löschen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polymorphe Deletion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Löschen, wenn die Klassendeklaration unvollständig ist</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Rein virtuelle Funktionen und abstrakte Klassen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reine virtuelle Funktionen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abstrakte Klassen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reiner virtueller Destruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Schnittstellenklassen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objekterstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objekt löschen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden des Löschoperators</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung einer speziellen virtuellen Funktion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung einer externen Funktion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automatisches Löschen mit Smart Pointer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere Optionen zum Verwalten der Lebensdauer einer Instanz einer Implementierungsklasse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semantik kopieren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellenklassenkonstruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bidirektionale Interaktion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intelligente Zeiger</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konstante Elementfunktionen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">COM-Schnittstellen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellenklassen und Bibliotheken</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Ein Beispiel für eine Schnittstellenklasse und ihre Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellenklasse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierungsklasse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard Smart Pointer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client-seitige Erstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierungsseitige Erstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alternative Basisklassenimplementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Ausnahmen und Sammlungen, die mithilfe von Schnittstellenklassen implementiert wurden</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.1 Ausnahmen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.2 Sammlungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Schnittstellenklassen und Wrapperklassen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Zusammenfassung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzliste</a> <br></div></div><br><a name="id-introdaction"></a><br><h1>  Einführung </h1><br><p>  Eine Schnittstellenklasse ist eine Klasse, die keine Daten enthält und hauptsächlich aus rein virtuellen Funktionen besteht.  Mit dieser Lösung können Sie die Implementierung vollständig von der Schnittstelle trennen - der Client verwendet die Schnittstellenklasse - und an einer anderen Stelle wird eine abgeleitete Klasse erstellt, in der rein virtuelle Funktionen neu definiert und die Factory-Funktion definiert werden.  Implementierungsdetails sind dem Client vollständig verborgen.  Auf diese Weise wird eine echte Kapselung implementiert, was mit der üblichen Klasse unmöglich ist.  Sie können über Schnittstellenklassen von Scott Meyers [Meyers2] lesen.  Schnittstellenklassen werden auch als Protokollklassen bezeichnet. </p><br><p>  Durch die Verwendung von Schnittstellenklassen können Sie die Abhängigkeiten zwischen verschiedenen Teilen des Projekts schwächen, was die Teamentwicklung vereinfacht und die Kompilierungs- / Montagezeit verkürzt.  Schnittstellenklassen erleichtern die Implementierung flexibler, dynamischer Lösungen, wenn Module zur Laufzeit selektiv geladen werden.  Die Verwendung der Schnittstellenklassen als Schnittstellenbibliothek (API) (SDK) vereinfacht die Lösung von Binärkompatibilitätsproblemen. </p><br><p>  Schnittstellenklassen sind weit verbreitet und implementieren mit ihrer Hilfe die Schnittstelle (API) von Bibliotheken (SDK), die Schnittstelle von Plug-Ins (Plugins) und vieles mehr.  Viele Gang of Four [GoF] -Muster werden natürlich mithilfe von Schnittstellenklassen implementiert.  Schnittstellenklassen umfassen COM-Schnittstellen.  Leider werden bei der Implementierung von Lösungen, die auf Schnittstellenklassen basieren, häufig Fehler gemacht.  Versuchen wir, dieses Problem zu klären. </p><br><a name="id-1"></a><br><h1>  1. Spezielle Elementfunktionen zum Erstellen und Löschen von Objekten </h1><br><p>  In diesem Abschnitt werden einige C ++ - Funktionen kurz beschrieben, die Sie kennen müssen, um die für Schnittstellenklassen angebotenen Lösungen vollständig zu verstehen. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Spezielle Mitgliederfunktionen </h2><br><p>  Wenn der Programmierer die Elementfunktionen der Klasse aus der folgenden Liste nicht definiert hat - Standardkonstruktor, Kopierkonstruktor, Kopierzuweisungsoperator, Destruktor -, kann der Compiler dies für ihn tun.  C ++ 11 hat dieser Liste einen Verschiebungskonstruktor und einen Verschiebungszuweisungsoperator hinzugefügt.  Diese Elementfunktionen werden als spezielle Elementfunktionen bezeichnet.  Sie werden nur generiert, wenn sie verwendet werden, und zusätzliche Bedingungen, die für jede Funktion spezifisch sind, sind erfüllt.  Wir machen darauf aufmerksam, dass sich diese Verwendung als ziemlich versteckt herausstellen kann (zum Beispiel bei der Implementierung der Vererbung).  Wenn die erforderliche Funktion nicht generiert werden kann, wird ein Fehler generiert.  (Mit Ausnahme von Verschiebungsvorgängen werden sie durch Kopiervorgänge ersetzt.) Die vom Compiler generierten Elementfunktionen sind öffentlich und können eingebettet werden. </p><br><p>  Spezielle Elementfunktionen werden nicht vererbt. Wenn in der abgeleiteten Klasse eine spezielle Elementfunktion erforderlich ist, versucht der Compiler immer, diese zu generieren. Das Vorhandensein der entsprechenden Elementfunktion, die vom Programmierer in der Basisklasse definiert wurde, hat keinen Einfluss darauf. </p><br><p> Der Programmierer kann die Generierung spezieller Elementfunktionen verbieten. In C ++ 11 muss beim Deklarieren das Konstrukt <code>"=delete"</code> verwendet werden. In C ++ 98 muss die entsprechende Elementfunktion als privat deklariert und nicht definiert werden.  Bei der Klassenvererbung gilt das Verbot, eine spezielle Elementfunktion in der Basisklasse zu generieren, für alle abgeleiteten Klassen. </p><br><p>  Wenn der Programmierer mit den vom Compiler generierten Elementfunktionen vertraut ist, kann er dies in C ++ 11 explizit angeben und nicht nur die Deklaration löschen.  Dazu müssen Sie beim Deklarieren das Konstrukt <code>"=default"</code> verwenden, während der Code besser gelesen wird und zusätzliche Funktionen im Zusammenhang mit der Verwaltung der Zugriffsebene <code>"=default"</code> werden. </p><br><p>  Details zu speziellen Mitgliedsfunktionen finden Sie in [Meyers3]. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Objekte erstellen und löschen - grundlegende Details </h2><br><p>  Das Erstellen und Löschen von Objekten mit den Operatoren <code>new/delete</code> ist eine typische Zwei-in-Eins-Operation.  Beim Aufruf von <code>new</code> wird zuerst Speicher für das Objekt zugewiesen.  Wenn die Auswahl erfolgreich ist, wird der Konstruktor aufgerufen.  Wenn der Konstruktor eine Ausnahme auslöst, wird der zugewiesene Speicher freigegeben.  Wenn der <code>delete</code> aufgerufen wird, geschieht alles in umgekehrter Reihenfolge: Zuerst wird der Destruktor aufgerufen, dann wird Speicher freigegeben.  Der Destruktor sollte keine Ausnahmen auslösen. </p><br><p>  Wenn der <code>new</code> Operator zum Erstellen eines Array von Objekten verwendet wird, wird zunächst Speicher für das gesamte Array zugewiesen.  Wenn die Auswahl erfolgreich ist, wird der Standardkonstruktor für jedes Element des Arrays ab Null aufgerufen.  Wenn ein Konstruktor eine Ausnahme auslöst, wird für alle erstellten Elemente des Arrays der Destruktor in der umgekehrten Reihenfolge des Konstruktoraufrufs aufgerufen, und der zugewiesene Speicher wird freigegeben.  Um ein Array zu löschen, müssen Sie den Operator <code>delete[]</code> (als <code>delete</code> für Arrays bezeichnet) aufrufen. Für alle Elemente des Arrays wird der Destruktor in umgekehrter Reihenfolge wie der Konstruktoraufruf aufgerufen. Anschließend wird der zugewiesene Speicher freigegeben. </p><br><p>  Achtung!  Sie müssen die richtige Form des <code>delete</code> aufrufen, je nachdem, ob ein einzelnes Objekt oder Array gelöscht wird.  Diese Regel muss strikt eingehalten werden, sonst kann es zu undefiniertem Verhalten kommen, dh es kann alles passieren: Speicherlecks, Absturz usw.  Siehe [Meyers2] für Details. </p><br><p>  Standardspeicherzuweisungsfunktionen erfüllen die Anforderung nicht und <code>std::bad_alloc</code> eine Ausnahme vom Typ <code>std::bad_alloc</code> . </p><br><p>  Es ist sicher, eine beliebige Form des <code>delete</code> auf einen Nullzeiger anzuwenden. </p><br><p>  In der obigen Beschreibung ist eine Klarstellung erforderlich.  Für die sogenannten trivialen Typen (eingebaute Typen, Strukturen im C-Stil) darf der Konstruktor nicht aufgerufen werden, und der Destruktor tut auf keinen Fall etwas.  Siehe auch Abschnitt 1.6. </p><br><a name="id-1-3"></a><br><h2>  1.3.  Destruktorzugriffsebene </h2><br><p>  Wenn der <code>delete</code> auf einen Zeiger auf eine Klasse angewendet wird, muss der Destruktor dieser Klasse am <code>delete</code> verfügbar sein.  (Es gibt eine Ausnahme von dieser Regel, die in Abschnitt 1.6 erläutert wird.) Indem der Destruktor sicher oder geschlossen wird, verbietet der Programmierer die Verwendung des <code>delete</code> , wenn der Destruktor nicht verfügbar ist.  Denken Sie daran, dass der Compiler dies selbst tut, wenn in der Klasse kein Destruktor definiert ist, und dieser Destruktor geöffnet ist (siehe Abschnitt 1.1). </p><br><a name="id-1-4"></a><br><h2>  1.4.  In einem Modul erstellen und löschen </h2><br><p>  Wenn der <code>new</code> Operator ein Objekt erstellt hat, muss sich der <code>delete</code> im selben Modul befinden, <code>delete</code> es zu <code>delete</code> .  Im übertragenen Sinne: "Platziere es dort, wo du es genommen hast."  Diese Regel ist bekannt, siehe zum Beispiel [Sutter / Alexandrescu].  Wenn diese Regel verletzt wird, kann es zu einer „Nichtübereinstimmung“ der Funktionen zum Zuweisen und Freigeben von Speicher kommen, was in der Regel zum Absturz des Programms führt. </p><br><a name="id-1-5"></a><br><h2>  1.5.  Polymorphe Deletion </h2><br><p>  Wenn Sie eine polymorphe Hierarchie von Klassen entwerfen, deren Instanzen mit dem <code>delete</code> gelöscht werden, muss in der Basisklasse ein offener virtueller Destruktor vorhanden sein. Dadurch wird sichergestellt, dass der Destruktor des tatsächlichen Objekttyps aufgerufen wird, wenn der <code>delete</code> auf den Zeiger auf die Basisklasse angewendet wird.  Wenn diese Regel verletzt wird, kann ein Aufruf des Basisklassen-Destruktors erfolgen, der zu einem Ressourcenleck führen kann. </p><br><a name="id-1-6"></a><br><h2>  1.6.  Löschen, wenn die Klassendeklaration unvollständig ist </h2><br><p>  Die Allesfresserhaftigkeit des <code>delete</code> kann bestimmte Probleme verursachen, sie kann auf einen Zeiger vom Typ <code>void*</code> oder auf einen Zeiger auf eine Klasse angewendet werden, die eine unvollständige (präemptive) Deklaration aufweist.  In diesem Fall tritt kein Fehler auf, nur der Aufruf des Destruktors wird übersprungen, nur die Funktion zum Freigeben des Speichers wird aufgerufen.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><p>  Dieser Code wird auch dann kompiliert, wenn beim <code>delete</code> Dial Peer keine vollständige <code>X</code> Klassendeklaration verfügbar ist.  Richtig, beim Kompilieren (Visual Studio) wird eine Warnung ausgegeben: </p><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> </p> <br><p>  Wenn es eine Implementierung von <code>X</code> und <code>CreateX()</code> , wird der Code <code>CreateX()</code> . Wenn <code>CreateX()</code> einen Zeiger auf das vom <code>new</code> Operator erstellte Objekt zurückgibt, wird der Aufruf <code>Foo()</code> erfolgreich ausgeführt, der Destruktor wird nicht aufgerufen.  Es ist klar, dass dies zu einem Ressourcenverbrauch führen kann, also noch einmal über die Notwendigkeit, vorsichtig mit Warnungen umzugehen. </p><br><p>  Diese Situation ist nicht weit hergeholt, sie kann leicht auftreten, wenn Klassen wie Smart Pointer oder Deskriptorklassen verwendet werden.  Scott Meyers befasst sich mit diesem Thema in [Meyers3]. </p><br><a name="id-2"></a><br><h1>  2. Rein virtuelle Funktionen und abstrakte Klassen </h1><br><p>  Das Konzept der Schnittstellenklassen basiert auf C ++ - Konzepten wie reinen virtuellen Funktionen und abstrakten Klassen. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Reine virtuelle Funktionen </h2><br><p>  Eine mit dem Konstrukt <code>"=0"</code> deklarierte virtuelle Funktion wird als rein virtuell bezeichnet. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    virtual void Foo() = 0; };</span></span></code> </pre> <br><p>  Im Gegensatz zu einer regulären virtuellen Funktion kann eine rein virtuelle Funktion nicht definiert werden (mit Ausnahme des Destruktors, siehe Abschnitt 2.3), sondern muss in einer der abgeleiteten Klassen neu definiert werden. </p><br><p>  Es können rein virtuelle Funktionen definiert werden.  Emblem Sutter bietet verschiedene nützliche Anwendungen für diese Funktion [Shutter]. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Abstrakte Klassen </h2><br><p>  Eine abstrakte Klasse ist eine Klasse, die mindestens eine rein virtuelle Funktion hat.  Eine Klasse, die von einer abstrakten Klasse abgeleitet ist und mindestens eine rein virtuelle Funktion nicht überschreibt, ist ebenfalls abstrakt.  Der C ++ - Standard verbietet das Erstellen von Instanzen einer abstrakten Klasse. Sie können nur Instanzen von Ableitungen nicht abstrakter Klassen erstellen.  Somit wird eine abstrakte Klasse erstellt, die als Basisklasse verwendet werden soll.  Wenn ein Konstruktor in einer abstrakten Klasse definiert ist, ist es dementsprechend nicht sinnvoll, ihn zu öffnen, sondern muss geschützt werden. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Reiner virtueller Destruktor </h2><br><p>  In einigen Fällen ist es ratsam, einen reinen virtuellen Destruktor zu erstellen.  Diese Lösung hat jedoch zwei Funktionen. </p><br><ol><li>  Ein rein virtueller Destruktor muss definiert werden.  (Die Standarddefinition wird normalerweise verwendet, dh mit dem Konstrukt <code>"=default"</code> .) Der abgeleitete Klassendestruktor ruft Basisklassendestruktoren entlang der gesamten Vererbungskette auf, und daher erreicht die Warteschlange garantiert den Stamm - einen rein virtuellen Destruktor. </li><li>  Wenn der Programmierer keinen reinen virtuellen Destruktor in der abgeleiteten Klasse neu definiert hat, erledigt der Compiler dies für ihn (siehe Abschnitt 1.1).  Somit kann eine Klasse, die von einer abstrakten Klasse mit einem rein virtuellen Destruktor abgeleitet ist, ihre Abstraktheit verlieren, ohne den Destruktor explizit zu überschreiben. </li></ol><br><p>  Ein Beispiel für die Verwendung eines reinen virtuellen Destruktors finden Sie in Abschnitt 4.4. </p><br><a name="id-3"></a><br><h1>  3. Schnittstellenklassen </h1><br><p>  Eine Schnittstellenklasse ist eine abstrakte Klasse, die keine Daten enthält und hauptsächlich aus rein virtuellen Funktionen besteht.  Eine solche Klasse kann gewöhnliche virtuelle Funktionen (nicht rein virtuell) haben, beispielsweise einen Destruktor.  Es können auch statische Elementfunktionen vorhanden sein, z. B. Werksfunktionen. </p><br><a name="id-3-1"></a><br><h2>  3.1.  Implementierungen </h2><br><p>  Eine Implementierung einer Schnittstellenklasse wird als abgeleitete Klasse bezeichnet, in der rein virtuelle Funktionen neu definiert werden.  Es können mehrere Implementierungen derselben Schnittstellenklasse vorhanden sein, und zwei Schemata sind möglich: horizontal, wenn mehrere verschiedene Klassen dieselbe Schnittstellenklasse erben, und vertikal, wenn die Schnittstellenklasse die Wurzel der polymorphen Hierarchie ist.  Natürlich kann es Hybriden geben. </p><br><p>  Der Kernpunkt des Konzepts der Schnittstellenklassen ist die vollständige Trennung der Schnittstelle von der Implementierung - der Client arbeitet nur mit der Schnittstellenklasse, die Implementierung steht ihr nicht zur Verfügung. </p><br><a name="id-3-2"></a><br><h2>  3.2.  Objekterstellung </h2><br><p>  Die Unzugänglichkeit der Implementierungsklasse verursacht bestimmte Probleme beim Erstellen von Objekten.  Der Client muss eine Instanz der Implementierungsklasse erstellen und einen Zeiger auf die Schnittstellenklasse erhalten, über die auf das Objekt zugegriffen wird.  Da die Implementierungsklasse nicht verfügbar ist, können Sie den Konstruktor nicht verwenden. Daher wird die Factory-Funktion verwendet, die auf der Implementierungsseite definiert ist.  Diese Funktion erstellt normalerweise ein Objekt mit dem <code>new</code> Operator und gibt einen Zeiger auf das erstellte Objekt zurück, der in einen Zeiger auf eine Schnittstellenklasse umgewandelt wird.  Eine Factory-Funktion kann ein statisches Mitglied einer Schnittstellenklasse sein, ist jedoch nicht erforderlich. Sie kann beispielsweise Mitglied einer speziellen Factory-Klasse (die wiederum selbst eine Schnittstellenklasse sein kann) oder eine freie Funktion sein.  Eine Factory-Funktion kann keinen Rohzeiger auf eine Schnittstellenklasse zurückgeben, sondern einen intelligenten.  Diese Option wird in den Abschnitten 3.3.4 und 4.3.2 erläutert. </p><br><a name="id-3-3"></a><br><h2>  3.3.  Objekt löschen </h2><br><p>  Das Entfernen eines Objekts ist ein äußerst kritischer Vorgang.  Ein Fehler führt entweder zu einem Speicherverlust oder zu einem doppelten Löschen, was normalerweise zu einem Programmabsturz führt.  Im Folgenden wird dieses Problem als so detailliert wie möglich betrachtet, wobei der Vermeidung fehlerhafter Kundenaktionen große Aufmerksamkeit gewidmet wird. </p><br><p>  Es gibt vier Hauptoptionen: </p><br><ol><li>  Verwenden des <code>delete</code> . </li><li>  Verwendung einer speziellen virtuellen Funktion. </li><li>  Verwendung einer externen Funktion. </li><li>  Automatisches Löschen mit Smart Pointer. </li></ol><br><a name="id-3-3-1"></a><br><h3>  3.3.1.  Verwenden des <code>delete</code> <br></h3><br><p>  Dazu müssen Sie einen offenen virtuellen Destruktor in der Schnittstellenklasse haben.  In diesem Fall ruft der <code>delete</code> , der auf der Clientseite einen Zeiger auf eine Schnittstellenklasse aufruft, den Destruktor der Implementierungsklasse auf.  Diese Option funktioniert möglicherweise, ist jedoch schwer als erfolgreich zu erkennen.  Wir erhalten Aufrufe der <code>new</code> und <code>delete</code> auf verschiedenen Seiten der "Barriere", <code>new</code> auf der Implementierungsseite, <code>delete</code> auf der Clientseite.  Und wenn die Implementierung der Schnittstellenklasse in einem separaten Modul erfolgt (was durchaus üblich ist), erhalten wir einen Verstoß gegen die Regel aus Abschnitt 1.4. </p><br><a name="id-3-3-2"></a><br><h3>  3.3.2.  Verwendung einer speziellen virtuellen Funktion </h3><br><p>  Progressiver ist eine weitere Option: Die Schnittstellenklasse muss über eine spezielle virtuelle Funktion verfügen, mit der das Objekt entfernt wird.  Eine solche Funktion läuft letztendlich darauf hinaus, <code>delete this</code> aufzurufen, aber dies geschieht bereits auf der Implementierungsseite.  Eine solche Funktion kann auf verschiedene Arten aufgerufen werden, z. B. <code>Delete()</code> , es werden jedoch auch andere Optionen verwendet: <code>Release()</code> , <code>Destroy()</code> , <code>Dispose()</code> , <code>Free()</code> , <code>Close()</code> usw.  Neben der Befolgung der Regel in Abschnitt 1.4 bietet diese Option mehrere zusätzliche Vorteile. </p><br><ol><li>  Ermöglicht die Verwendung benutzerdefinierter Speicherzuweisungs- / Freigabefunktionen für die Implementierungsklasse. </li><li>  Ermöglicht die Implementierung eines komplexeren Schemas zur Steuerung der Lebensdauer des Implementierungsobjekts, z. B. mithilfe eines Referenzzählers. </li></ol><br><p>  In dieser Ausführungsform kann ein Versuch, ein Objekt unter Verwendung des <code>delete</code> zu löschen, kompiliert und sogar ausgeführt werden, dies ist jedoch ein Fehler.  Um dies in der Schnittstellenklasse zu verhindern, reicht ein leerer oder rein virtuell geschützter Destruktor aus (siehe Abschnitt 1.3).  Beachten Sie, dass die Verwendung des <code>delete</code> sehr maskiert sein kann. Beispielsweise verwenden standardmäßige intelligente Zeiger den <code>delete</code> , um ein Objekt standardmäßig zu löschen, und der entsprechende Code ist tief in ihrer Implementierung vergraben.  Mit einem geschützten Destruktor können Sie alle derartigen Versuche in der Kompilierungsphase erkennen. </p><br><a name="id-3-3-3"></a><br><h3>  3.3.3.  Verwendung einer externen Funktion </h3><br><p>  Diese Option kann eine gewisse Symmetrie von Prozeduren zum Erstellen und Löschen eines Objekts aufweisen, hat jedoch in Wirklichkeit keine Vorteile gegenüber der vorherigen Version, es gibt jedoch viele zusätzliche Probleme.  Diese Option wird nicht empfohlen und wird in Zukunft nicht mehr berücksichtigt. </p><br><a name="id-3-3-4"></a><br><h3>  3.3.4.  Automatisches Löschen mit Smart Pointer </h3><br><p>  In diesem Fall gibt die Factory-Funktion keinen Rohzeiger auf eine Schnittstellenklasse zurück, sondern einen entsprechenden Smart-Zeiger.  Dieser intelligente Zeiger wird auf der Implementierungsseite erstellt und kapselt das Löschobjekt, das das Implementierungsobjekt automatisch löscht, wenn der intelligente Zeiger (oder seine letzte Kopie) auf der Clientseite den Gültigkeitsbereich verlässt.  In diesem Fall ist möglicherweise keine spezielle virtuelle Funktion zum Löschen des Implementierungsobjekts erforderlich, es wird jedoch weiterhin ein geschützter Destruktor benötigt. Es ist erforderlich, die fehlerhafte Verwendung des <code>delete</code> zu verhindern.  (Es ist zu beachten, dass die Wahrscheinlichkeit eines solchen Fehlers merklich verringert ist.) Diese Option wird in Abschnitt 4.3.2 ausführlicher erläutert. </p><br><a name="id-3-4"></a><br><h2>  3.4.  Andere Optionen zum Verwalten der Lebensdauer einer Instanz einer Implementierungsklasse </h2><br><p>  In einigen Fällen erhält der Client möglicherweise einen Zeiger auf die Schnittstellenklasse, besitzt diesen jedoch nicht.  Die Verwaltung der Lebensdauer des Implementierungsobjekts erfolgt vollständig auf der Implementierungsseite.  Ein Objekt kann beispielsweise ein statisches Singleton-Objekt sein (diese Lösung ist typisch für Fabriken).  Ein weiteres Beispiel bezieht sich auf die bidirektionale Interaktion, siehe Abschnitt 3.7.  Der Client sollte ein solches Objekt nicht löschen, es wird jedoch ein geschützter Destruktor für eine solche Schnittstellenklasse benötigt. Es ist erforderlich, die fehlerhafte Verwendung des <code>delete</code> zu verhindern. </p><br><a name="id-3-5"></a><br><h2>  3.5.  Semantik kopieren </h2><br><p>  Für eine Schnittstellenklasse ist das Erstellen einer Kopie des Implementierungsobjekts mit dem Kopierkonstruktor nicht möglich. Wenn also ein Kopieren erforderlich ist, muss die Klasse über eine virtuelle Funktion verfügen, die eine Kopie des Implementierungsobjekts erstellt und einen Zeiger auf die Schnittstellenklasse zurückgibt.  Eine solche Funktion wird oft als virtueller Konstruktor bezeichnet und heißt traditionell <code>Clone()</code> oder <code>Duplicate()</code> . </p><br><p>  Die Verwendung des Kopierzuweisungsoperators ist nicht verboten, kann jedoch nicht als gute Idee angesehen werden.  Der Kopierzuweisungsoperator ist immer gepaart und muss mit dem Kopierkonstruktor gekoppelt werden.  Der vom Standard-Compiler generierte Operator ist bedeutungslos und führt nichts aus.  Es ist theoretisch möglich, einen Zuweisungsoperator mit anschließender Neudefinition als rein virtuell zu deklarieren. Eine virtuelle Zuweisung wird jedoch nicht empfohlen. Details finden Sie in [Meyers1].  Darüber hinaus sieht die Zuweisung sehr unnatürlich aus: Der Zugriff auf die Objekte der Implementierungsklasse erfolgt normalerweise über einen Zeiger auf die Schnittstellenklasse, sodass die Zuweisung folgendermaßen aussieht: </p><br><pre> <code class="cpp hljs">* = *;</code> </pre> <br><p>  Der Zuweisungsoperator ist am besten verboten, und falls erforderlich, hat eine solche Semantik in der Schnittstellenklasse die entsprechende virtuelle Funktion. </p><br><p>  Es gibt zwei Möglichkeiten, die Zuweisung zu verbieten. </p><br><ol><li>  Deklarieren Sie den Zuweisungsoperator als gelöscht ( <code>=delete</code> ).  Wenn die Schnittstellenklassen eine Hierarchie bilden, reicht dies in der Basisklasse aus.  Der Nachteil dieser Methode ist, dass sie die Implementierungsklasse betrifft, das Verbot gilt auch für sie. </li><li>  Deklarieren Sie eine geschützte Zuweisungsanweisung mit einer Standarddefinition ( <code>=default</code> ).  Dies wirkt sich nicht auf die Implementierungsklasse aus, aber im Fall einer Hierarchie von Schnittstellenklassen muss eine solche Ankündigung in jeder Klasse erfolgen. </li></ol><br><a name="id-3-6"></a><br><h2>  3.6.  Schnittstellenklassenkonstruktor </h2><br><p>  Oft wird der Konstruktor einer Schnittstellenklasse nicht deklariert.  In diesem Fall generiert der Compiler den Standardkonstruktor, der zum Implementieren der Vererbung erforderlich ist (siehe Abschnitt 1.1).  Dieser Konstruktor ist offen, aber ausreichend, um sicher zu sein.  Wenn in der Schnittstellenklasse der kopierende Konstruktor als gelöscht deklariert wird ( <code>=delete</code> ), wird die Generierung des Konstruktors durch den Compiler standardmäßig unterdrückt, und ein solcher Konstruktor muss explizit deklariert werden.  Es ist natürlich, es mit einer Standarddefinition ( <code>=default</code> ) sicher zu machen.  Grundsätzlich kann die Deklaration eines solchen geschützten Konstruktors immer erfolgen.  Ein Beispiel finden Sie in Abschnitt 4.4. </p><br><a name="id-3-7"></a><br><h2>  3.7.  Bidirektionale Interaktion </h2><br><p>  Schnittstellenklassen sind praktisch für die Verwendung der bidirektionalen Kommunikation.  Wenn auf ein Modul über Schnittstellenklassen zugegriffen werden kann, kann der Client auch Implementierungen einiger Schnittstellenklassen erstellen und Zeiger im Modul an diese übergeben.  Über diese Zeiger kann das Modul Dienste vom Client empfangen und auch Daten oder Benachrichtigungen an den Client senden. </p><br><a name="id-3-8"></a><br><h2>  3.8.  Intelligente Zeiger </h2><br><p>  Da der Zugriff auf Objekte der Implementierungsklasse normalerweise über einen Zeiger erfolgt, ist es selbstverständlich, intelligente Zeiger zu verwenden, um deren Lebensdauer zu steuern.  Es ist jedoch zu beachten, dass bei Verwendung der zweiten Option zum Löschen von Objekten mit dem Standard-Smart-Zeiger ein Benutzerlöscher (Typ) oder eine Instanz dieses Typs übertragen werden muss.  Wenn dies nicht getan wird, verwendet der Smart Pointer den <code>delete</code> , um das Objekt zu löschen, und der Code wird einfach nicht kompiliert (dank des geschützten Destruktors).  Standard-Smart-Pointer (einschließlich der Verwendung von benutzerdefinierten Entfernern) werden in [Josuttis], [Meyers3] ausführlich erläutert.  Ein Beispiel für die Verwendung eines benutzerdefinierten Entferners finden Sie in Abschnitt 4.3.1. </p><br><p>      ,       ,      ,    . </p><br><a name="id-3-9"></a><br><h2> 3.9.  - </h2><br><p>     -    const.              ,  ,    -,       . </p><br><a name="id-3-10"></a><br><h2> 3.10. COM- </h2><br><p> COM-    ,     ,  COM —      ,  COM-     ,   C,    ,   .  COM-  C++      ,   COM. </p><br><a name="id-3-11"></a><br><h2> 3.11.     </h2><br><p>         (API)    (SDK).       .    -,      -,           .     ,     (Windows DLL),     :  -.          .        ,  ,       .     <code>LoadLibrary()</code>      ,    -,       . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>       ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Delete() = 0; //      IBase&amp; operator=(const IBase&amp;) = delete; //   };</span></span></code> </pre> <br><p>    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActivatable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~IActivatable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Activate(bool activate) = 0;    static IActivatable* CreateInstance(); // - };</span></span></code> </pre> <br><p> ,         ,     .     ,           <code>IBase</code> .     ,            (.  1.3).       ,       . </p><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IActivatable { <span class="hljs-comment"><span class="hljs-comment">// ... private:    Activator(); protected:    ~Activator(); public:    void Delete() override;    void Activate(bool activate) override;    friend IActivatable* IActivatable::CreateInstance(); }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Delete() { delete this; } void Activator::Activate(bool activate) {/* ... */} IActivatable* IActivatable::CreateInstance() {    return static_cast&lt;IActivatable*&gt;(new Activator()); }</span></span></code> </pre> <br><p>      , ,        ,  -  ,         . </p><br><a name="id-4-3"></a><br><h2> 4.3.    </h2><br><a name="id-4-3-1"></a><br><h3> 4.3.1.     </h3><br><p>           . -   (     <code>IBase</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDeleter</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IBase* p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;Delete(); } };</code> </pre> <br><p>  <code>std::unique_ptr&lt;&gt;</code> -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;I, BaseDeleter&gt;;</code> </pre> <br><p> ,   ,  -   ,  <code>UniquePtr</code>    . </p><br><p>   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(I::CreateInstance()); }</code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToPtr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(p); }</code> </pre> <br><p>  <code>std::shared_ptr&lt;&gt;</code>    <code>std::unique_ptr&lt;&gt;</code> ,   ,  <code>std::shared_ptr&lt;&gt;</code>   .      <code>Activator</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un1 = CreateInstance&lt;IActivatable&gt;(); un1-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un2 = ToPtr(IActivatable::CreateInstance()); un2-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh = CreateInstance&lt;IActivatable&gt;(); sh-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><p>          (     — -): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh2(IActivatable::CreateInstance());</code> </pre> <br><p>     <code>std::make_shared&lt;&gt;()</code> ,      (    ). </p><br><p>    :          ,     .     :     ,  - .     4.4. </p><br><a name="id-4-3-2"></a><br><h3>  4.3.2.     </h3><br><p>       .           -.   <code>std::shared_ptr&lt;&gt;</code>         ,    ,      (         ).     <code>std::shared_ptr&lt;&gt;</code> (  )  -  ,           <code>delete</code>     .  <code>std::shared_ptr&lt;&gt;</code> -       (   )   -      .        . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class IActivatable; using ActPtr = std::shared_ptr&lt;IActivatable&gt;; //   class IActivatable { protected:    virtual ~IActivatable() = default; //      IActivatable&amp; operator=(const IActivatable&amp;) = default; //   public:    virtual void Activate(bool activate) = 0;    static ActPtr CreateInstance(); // - }; //   class Activator : public IActivatable { // ... public:    Activator();  //      ~Activator(); //      void Activate(bool activate) override; }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Activate(bool activate) {/* ... */} ActPtr IActivatable::CreateInstance() {    return ActPtr(new Activator()); }</span></span></span></span></code> </pre> <br><p>  -        <code>std::make_shared&lt;&gt;()</code> : </p><br><pre> <code class="cpp hljs">ActPtr IActivatable::CreateInstance() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Activator&gt;(); }</code> </pre> <br><p>      <code>std::unique_ptr&lt;&gt;</code> ,        , -   ,        . </p><br><a name="id-4-4"></a><br><h2> 4.4.     </h2><br><p>    C#  Java  C++    «»,       .        .      <code>IBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       virtual void Delete(); //   public:    IBase(const IBase&amp;) = delete;            //      IBase&amp; operator=(const IBase&amp;) = delete; //      struct Deleter        // -    {        void operator()(IBase* p) const { p-&gt;Delete(); }    };    friend struct IBase::Deleter; };</span></span></code> </pre> <br><p>     , <code>Delete()</code>    ,     . </p><br><pre> <code class="cpp hljs">IBase::~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IBase::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>      <code>IBase</code> .         <code>Delete()</code> ,              . -      <code>IBase</code> . <code>Delete()</code>  , - .     <code>Delete()</code>         ,    .       ,    4.3.1. </p><br><a name="id-5"></a><br><h1> 5.   ,      </h1><br><a name="id-5-1"></a><br><h2> 5.1  </h2><br><p>  ,    ,   ,      ,        . </p><br><p>   ,  ,    <code>IException</code>    <code>Exception</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IException</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IException() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    IException&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IException&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>    IException* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_Ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; src) : m_Ptr(src.m_Ptr-&gt;Clone()) {}    ~Exception() { m_Ptr-&gt;Delete(); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Ptr; } };</code> </pre> <br><p>         <code>Exception</code> ,            <code>IException</code> .       ,    <code>throw</code> ,   .    <code>Exception</code>      ,      .  -      ,   . </p><br><p>  <code>Exception</code> , ,  . </p><br><p>   <code>IException</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExcImpl</span></span></span><span class="hljs-class"> :</span></span> IException {    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_What;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Code;    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExcImpl&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-function"><span class="hljs-function">IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~ExcImpl() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; ExcImpl::ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_What(what), m_Code(code) {} IException* ExcImpl::Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExcImpl::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ExcImpl::What() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_What.c_str(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExcImpl::Code() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Code; }</code> </pre> <br><p>   <code>Exception</code> : </p><br><pre> <code class="cpp hljs">Exception::Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_Ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(what, code)) {}</code> </pre> <br><p>    ,       — .NET —  , —          ,     C++/CLI.  ,        ,     ,   C++/CLI. </p><br><a name="id-5-2"></a><br><h2> 5.2  </h2><br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ICollect() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ICollect&lt;T&gt;* Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    ICollect&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ICollect&lt;T&gt;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>        ,             -,        . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contain</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ICollect&lt;T&gt; CollType;    CollType* m_Coll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type;    Contain(CollType* coll);    ~Contain(); <span class="hljs-comment"><span class="hljs-comment">//     Contain(const Contain&amp; src);    Contain&amp; operator=(const Contain&amp; src); //     Contain(Contain&amp;&amp; src);    Contain&amp; operator=(Contain&amp;&amp; src);    bool mpty() const;    int size() const;    T&amp; operator[](int ind);    const T&amp; operator[](int ind) const;    Iterator&lt;T&gt; begin();    Iterator&lt;T&gt; end(); };</span></span></code> </pre> <br><p>      .   ,       . ,      ,    ,     ,    - <code>begin()</code>  <code>end()</code> ,   .           (. [Josuttis]),         <code>for</code>   .                .            , ,      . </p><br><a name="id-6"></a><br><h1> 6.    - </h1><br><p>       .         -,      .          .   ,         ++.              ,   .NET, Java  Pyton.              .      ,  ,         .   .NET Framework     C++/CLI          C++.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p>      -,         . </p><br><p>         . </p><br><ol><li>   <code>delete</code> . </li><li>    . </li><li>      . </li></ol><br><p>          . </p><br><p>         ,       <code>delete</code> .                ,      . </p><br><p>    -   ,           .             ,    ,      <code>delete</code> . </p><br><p>             . </p><br><p>      ,          ,     ,  ,       . </p><br><br><a name="id-refs"></a><br><h1>   </h1><br><div class="spoiler">  <b class="spoiler_title">Liste</b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[GoF] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamma E., Helm R., Johnson R., Vlissides J. Methoden des objektorientierten Entwurfs. </font><font style="vertical-align: inherit;">Entwurfsmuster .: Per. </font><font style="vertical-align: inherit;">aus dem Englischen </font><font style="vertical-align: inherit;">- St. Petersburg: Peter, 2001.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Josuttis] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis, Nikolai M. C ++ - Standardbibliothek: Referenzhandbuch, 2. Ausgabe: Per. </font><font style="vertical-align: inherit;">aus dem Englischen </font><font style="vertical-align: inherit;">- M.: LLC “I.D. </font><font style="vertical-align: inherit;">Williams, 2014.</font></font></p><br><p> [Dewhurst] <br> ,  .   C++.         .: .  . — .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  . — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  . — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C++14.: .  . — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  . — .:  «.. », 2015. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427281/">https://habr.com/ru/post/de427281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427271/index.html">Geschichte und Erfahrung mit maschineller Übersetzung. Yandex Vortrag</a></li>
<li><a href="../de427273/index.html">Kann künstliche Intelligenz Buchmacher ohne Arbeit lassen?</a></li>
<li><a href="../de427275/index.html">Internetinformationsarchitektur Teil 3</a></li>
<li><a href="../de427277/index.html">Ein Beugungsmuster findet sich in der Verteilung von Primzahlen, ähnlich der von Quasikristallen</a></li>
<li><a href="../de427279/index.html">Zusammenarbeit: Android Night #Apple</a></li>
<li><a href="../de427283/index.html">Wie hoch die Verfügbarkeit bei Kubernetes ist gewährleistet</a></li>
<li><a href="../de427285/index.html">Schule über die Grundlagen digitaler Schaltkreise: Nowosibirsk - Ok, Krasnojarsk - machen Sie sich bereit</a></li>
<li><a href="../de427289/index.html">Geologische 3D-Modellierung, Protokollierung und Technologie von Aramco Innovations</a></li>
<li><a href="../de427291/index.html">Minimieren Sie den Datenverkehr in ASP.NET Web Forms, anklickbare Div- und regelmäßige Serverabfragen</a></li>
<li><a href="../de427293/index.html">JavaScript-Entwurfsmuster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>