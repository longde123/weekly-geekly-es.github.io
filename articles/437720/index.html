<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçΩÔ∏è üíÖüèª ‚õÖÔ∏è La lucha por soluciones de calidad en Erlang / Elixir üíñ üë®‚Äçüë©‚Äçüëß‚Äçüëß üåÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="@jcutrer 


 Hoy hablaremos sobre registros de eventos, m√©tricas cuantitativas y monitoreo de todo esto para aumentar la tasa de respuesta del equipo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La lucha por soluciones de calidad en Erlang / Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437720/"><p><img src="https://habrastorage.org/webt/s8/mq/lh/s8mqlhd99fmiu32vwgxnk4x-8yu.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@jcutrer</a> </p><br><p>  Hoy hablaremos sobre registros de eventos, m√©tricas cuantitativas y monitoreo de todo esto para aumentar la tasa de respuesta del equipo a los incidentes y reducir el tiempo de inactividad del sistema objetivo. </p><br><p> Erlang / OTP como marco y la ideolog√≠a de construir sistemas distribuidos nos brinda enfoques regulados para el desarrollo, herramientas e implementaci√≥n de componentes est√°ndar.  Digamos que usamos el potencial de OTP y pasamos del prototipo a la producci√≥n.  Nuestro proyecto Erlang se siente genial en los servidores de batalla, la base del c√≥digo est√° en constante evoluci√≥n, aparecen nuevos requisitos y funcionalidades, nuevas personas llegan al equipo y todo parece estar bien.  Pero a veces algo sale mal y los problemas t√©cnicos, multiplicados por el factor humano, pueden provocar un accidente. </p><br><p>  Dado que es imposible colocar pajillas para absolutamente todos los casos posibles de fallas y problemas, o no es econ√≥micamente factible, es necesario reducir el tiempo de inactividad del sistema en caso de fallas de la administraci√≥n y las soluciones de software. </p><a name="habracut"></a><br><p>  En los sistemas de informaci√≥n siempre habr√° una probabilidad de ocurrencia de fallas de diversa naturaleza: </p><br><ul><li>  Fallas de hardware y fallas de energ√≠a </li><li>  Fallos de red: errores de configuraci√≥n, curvas de firmware </li><li>  Errores l√≥gicos: desde errores de codificaci√≥n de algoritmos hasta problemas arquitect√≥nicos que surgen en los l√≠mites de subsistemas y sistemas. </li><li>  Problemas de seguridad y ataques y ataques relacionados, incluido el fraude interno. </li></ul><br><p>  Inmediatamente distinguimos la responsabilidad: el monitoreo de la infraestructura, por ejemplo, organizado por zabbix, ser√° responsable de la operaci√≥n de los equipos inform√°ticos y las redes de transmisi√≥n de datos.  Se ha escrito mucho sobre la instalaci√≥n y configuraci√≥n de dicho monitoreo, no lo repetiremos. </p><br><p>  Desde el punto de vista del desarrollador, el problema de accesibilidad y calidad radica en el plano de la detecci√≥n temprana de errores y problemas de rendimiento y la r√°pida respuesta a los mismos.  Esto requiere enfoques y medios de evaluaci√≥n.  Entonces, tratemos de obtener m√©tricas cuantitativas, analizando qu√© en diferentes etapas del desarrollo y operaci√≥n del proyecto, podemos mejorar significativamente la calidad. </p><br><h3 id="sistemy-sborki">  Sistemas de montaje </h3><br><p>  Perm√≠tame recordarle una vez m√°s la importancia del enfoque de ingenier√≠a y las pruebas en el desarrollo de software.  Erlang / OTP ofrece dos marcos de prueba a la vez: eunit y prueba com√∫n. </p><br><p>  Como m√©trica para la evaluaci√≥n inicial del estado de la base del c√≥digo y su din√°mica, puede usar la cantidad de pruebas exitosas y problem√°ticas, su tiempo de ejecuci√≥n y el porcentaje de cobertura del c√≥digo con las pruebas.  Ambos marcos permiten guardar los resultados de las pruebas en formato Junit. <br>  Por ejemplo, para rebar3 y ct, agregue las siguientes l√≠neas a rebar.config: </p><br><pre><code class="erlang hljs">{cover_enabled, true}. {cover_export_enabled, true}. {ct_opts,[ {ct_hooks, [{cth_surefire, [{path, <span class="hljs-string"><span class="hljs-string">"report.xml"</span></span>}]}]} ]}.</code> </pre> <br><p>  La cantidad de pruebas exitosas y no exitosas le permitir√° construir un gr√°fico de tendencias: <br><img src="https://habrastorage.org/webt/mw/lc/mw/mwlcmw24mj6f9wz5ctxshc4baf4.png"><br>  observando qu√©, puede evaluar la din√°mica del equipo y la regresi√≥n de las pruebas.  Por ejemplo, en Jenkins, este gr√°fico se puede obtener utilizando el complemento Test Results Analyzer. </p><br><p>  Si las pruebas se vuelven rojas o comienzan a ejecutarse durante mucho tiempo, las m√©tricas permitir√°n que se finalice el lanzamiento incluso en la etapa de ensamblaje y prueba autom√°tica. </p><br><h3 id="metriki-prilozheniy">  M√©tricas de aplicaci√≥n </h3><br><p>  Adem√°s de las m√©tricas del sistema operativo, el monitoreo debe incluir m√©tricas de la aplicaci√≥n, como la cantidad de vistas por segundo, la cantidad de pagos y otros indicadores cr√≠ticos. </p><br><p>  En mis proyectos, uso una plantilla como <code>${application}.${metrics_type}.${name}</code> para nombrar las m√©tricas.  Este nombre le permite obtener listas de m√©tricas </p><br><pre> <code class="bash hljs">messaging.systime_subs.messages.delivered = 1654 messaging.systime_subs.messages.proxied = 0 messaging.systime_subs.messages.published = 1655 messaging.systime_subs.messages.skipped = 3</code> </pre> <br><p>  Quiz√°s, cuanto m√°s m√©tricas, m√°s f√°cil es comprender lo que sucede en un sistema complejo. </p><br><h3 id="metriki-erlang-vm">  Erlang VM Metrics </h3><br><p>  Se debe prestar especial atenci√≥n al monitoreo de Erlang VM.  La ideolog√≠a de dejar que se bloquee es hermosa, y el uso adecuado de OTP ciertamente ayudar√° a levantar las partes ca√≠das de la aplicaci√≥n dentro de Erlang VM.  Pero no te olvides de Erlang VM, porque es dif√≠cil dejarlo, pero es posible.  Todas las opciones se basan en el agotamiento de los recursos.  Enumeramos los principales: </p><br><ul><li><p>  Atom table overflow. <br>  Los √°tomos son identificadores cuyo prop√≥sito principal es mejorar la legibilidad del c√≥digo.  Los √°tomos creados una vez permanecen para siempre en la memoria de la instancia de Erlang VM, ya que el recolector de basura no los borra.  ¬øPor qu√© est√° pasando esto?  El recolector de basura funciona por separado en cada proceso con datos de este proceso, mientras que los √°tomos se pueden distribuir a trav√©s de las estructuras de datos de muchos procesos. <br>  Por defecto, se pueden crear 1.048.576 √°tomos.  En los art√≠culos sobre matar a Erlang VM, generalmente puedes encontrar algo como esto. </p><br><pre> <code class="erlang hljs">[list_to_atom(integer_to_list(I)) || I &lt;- lists:seq(erlang:system_info(atom_count), erlang:system_info(atom_limit))]</code> </pre> <br><p>  como una ilustraci√≥n de este efecto.  Parece que un problema artificial es inalcanzable en sistemas reales, pero hay casos ... Por ejemplo, en el controlador de API externo, cuando se analizan solicitudes, <code>binary_to_atom/2</code> <code>binary_to_existing_atom/2</code> lugar de <code>binary_to_existing_atom/2</code> o <code>list_to_atom/1</code> lugar de <code>list_to_existing_atom/1</code> . <br>  Los siguientes par√°metros deben usarse para monitorear el estado de los √°tomos: </p><br><ol><li>  <code>erlang:memory(atom_used)</code> - cantidad de memoria utilizada para √°tomos </li><li>  <code>erlang:system_info(atom_count)</code> : el n√∫mero de √°tomos creados en el sistema.  Junto con <code>erlang:system_info(atom_limit)</code> , se puede calcular la utilizaci√≥n del √°tomo. </li></ol><br></li><li><p>  Proceso de fugas. <br>  Me gustar√≠a decir de inmediato que cuando se alcanza process_limit (+ P, el argumento erl) erlang vm no cae, pero entra en un estado de emergencia, por ejemplo, lo m√°s probable es que sea imposible conectarse a √©l.  Finalmente, quedarse sin memoria disponible cuando se asigna a procesos filtrados har√° que erlang vm se bloquee. </p><br><ol><li>  <code>erlang:system_info(process_count)</code> : la cantidad de procesos activos en este momento.  Junto con <code>erlang:system_info(process_limit)</code> , se puede calcular la utilizaci√≥n del proceso. </li><li>  <code>erlang:memory(processes)</code> - memoria asignada para procesos </li><li>  <code>erlang:memory(processes_used)</code> : memoria utilizada para procesos. </li></ol><br></li><li><p>  Desbordamiento del proceso de buz√≥n. <br>  Un ejemplo t√≠pico de tal problema es que el proceso del remitente env√≠a mensajes al proceso del destinatario sin esperar la confirmaci√≥n, mientras que <code>receive</code> en el proceso del receptor ignora todos estos mensajes debido a un patr√≥n faltante o incorrecto.  Como resultado, los mensajes se acumulan en el buz√≥n.  Aunque erlang tiene un mecanismo para ralentizar al remitente en caso de que el controlador no pueda manejar el procesamiento, de todos modos, despu√©s del agotamiento de la memoria disponible, vm se bloquea. <br>  Para comprender si hay problemas con el desbordamiento del buz√≥n, etop lo ayudar√°. </p><br><pre> <code class="bash hljs">$ erl -name etop@host -hidden -s etop -s erlang halt -output text -node dest@host -setcookie some_cookie -tracing off -sort msg_q -interval 1 -lines 25</code> </pre> <br><p><img src="https://habrastorage.org/webt/k3/rc/xu/k3rcxuudnptazhjl0pxql1vmfji.png"><br>  Como medida para la supervisi√≥n continua, puede tomar la cantidad de procesos problem√°ticos.  Para identificarlos, puede usar la siguiente funci√≥n: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top_msq_q</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">-&gt;</span></span> [{P, RN, L, IC, ST} || P &lt;- processes(), { _, L } &lt;- [ process_info(P, message_queue_len) ], L &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>, [{_, RN}, {_, IC}, {_, ST}] &lt;- [process_info(P, [registered_name, initial_call, current_stacktrace]) ] ].</code> </pre> <br><p>  Adem√°s, esta lista se puede registrar, luego, al recibir notificaciones de monitoreo, se simplifica el an√°lisis del problema. </p><br></li><li><p>  Binarios con fugas. <br>  La memoria para binarios grandes (m√°s de 64 bytes) se asigna en el mont√≥n general.  El bloque asignado tiene un contador de referencia que muestra la cantidad de procesos que tienen acceso a √©l.  Despu√©s de reiniciar el contador, se realiza la limpieza.  El sistema m√°s simple, pero, como dicen, hay matices.  En principio, existe la posibilidad de que un proceso genere tanta basura en el mont√≥n que el sistema no tenga suficiente memoria para realizar la limpieza. <br>  <code>erlang:memory(binary)</code> act√∫a como una m√©trica para el monitoreo, mostrando la memoria asignada para binarios. </p><br></li></ul><br><p>  Por lo tanto, los casos que conducen a la ca√≠da de vm se resuelven, sin embargo, adem√°s de ellos, es bueno monitorear par√°metros no menos importantes que afectan directa o indirectamente el funcionamiento correcto de sus aplicaciones: </p><br><ul><li>  La memoria utilizada por las <code>erlang:memory(ets)</code> ETS: <code>erlang:memory(ets)</code> . </li><li>  Memoria para m√≥dulos compilados: <code>erlang:memory(code)</code> . <br>  Si sus soluciones no utilizan la compilaci√≥n de c√≥digo din√°mico, entonces esta opci√≥n puede excluirse. <br>  Tambi√©n me gustar√≠a mencionar erlydtl.  Si compila plantillas din√°micamente, la compilaci√≥n crea una viga que se carga en la memoria vm.  Tambi√©n puede causar p√©rdidas de memoria. </li><li>  Memoria del sistema: <code>erlang:memory(system)</code> .  Muestra el consumo de memoria de tiempo de ejecuci√≥n erlang. </li><li>  Memoria total consumida: <code>erlang:memory(total)</code> .  Esta es la cantidad de memoria consumida por los procesos y el tiempo de ejecuci√≥n. </li><li>  Informaci√≥n sobre reducciones: <code>erlang:statistics(reductions)</code> . </li><li>  N√∫mero de procesos y puertos listos para la ejecuci√≥n: <code>erlang:statistics(run_queue)</code> . </li><li>  El tiempo de actividad de la <code>erlang:statistics(runtime)</code> vm: <code>erlang:statistics(runtime)</code> permite comprender si hubo un reinicio sin an√°lisis de registro. </li><li>  Actividad de red: <code>erlang:statistics(io)</code> . </li></ul><br><h3 id="otpravka-metrik-v-zabbix">  Enviar m√©tricas a zabbix </h3><br><p>  Crearemos un archivo que contenga las m√©tricas de la aplicaci√≥n y las m√©tricas de erlang vm, que actualizaremos cada N segundos.  Para cada nodo erlang, el archivo de m√©tricas debe contener las m√©tricas de las aplicaciones que se ejecutan en √©l y las m√©tricas de la instancia de erlang vm.  El resultado deber√≠a ser algo como esto: </p><br><pre> <code class="bash hljs">messaging.systime_subs.messages.delivered = 1654 messaging.systime_subs.messages.proxied = 0 messaging.systime_subs.messages.published = 1655 messaging.systime_subs.messages.skipped = 3 ‚Ä¶. erlang.io.input = 2205723664 erlang.io.output = 1665529234 erlang.memory.binary = 1911136 erlang.memory.ets = 1642416 erlang.memory.processes = 23596432 erlang.memory.processes_used = 23598864 erlang.memory.system = 50883752 erlang.memory.total = 74446048 erlang.processes.count = 402 erlang.processes.run_queue = 0 erlang.reductions = 148412771 ....</code> </pre> <br><p>  Usando <code>zabbix_sender</code> enviaremos este archivo a zabbix, donde ya estar√° disponible una representaci√≥n gr√°fica y la capacidad de crear disparadores de automatizaci√≥n y notificaci√≥n. </p><br><p>  Ahora que tenemos m√©tricas en el sistema de monitoreo y disparadores de automatizaci√≥n y eventos de notificaci√≥n creados sobre su base, tenemos la oportunidad de evitar accidentes al reaccionar con anticipaci√≥n a todas las desviaciones peligrosas de un estado completamente funcional. </p><br><h3 id="centralnyy-sbor-logov">  Recolecci√≥n central de troncos </h3><br><p>  Cuando hay 1-2 servidores en un proyecto, es probable que a√∫n pueda vivir sin una recopilaci√≥n central de registros, pero tan pronto como aparece un sistema distribuido con muchos servidores, cl√∫steres y entornos, se hace necesario resolver el problema de recopilaci√≥n y visualizaci√≥n conveniente de registros. </p><br><p>  Para escribir registros en mis proyectos, uso lager.  A menudo, en el camino desde el prototipo hasta la producci√≥n, los proyectos pasan por las siguientes etapas de recopilaci√≥n de registros: </p><br><ul><li>  Registro m√°s simple con salida a un archivo local o incluso a stdout (lager_file_backend) </li><li>  Recopilaci√≥n centralizada de registros mediante, por ejemplo, syslogd y env√≠o autom√°tico de registros al recopilador.  Para tal esquema, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lager_syslog</a> es adecuado. <br>  La principal desventaja del esquema es que debe ir al servidor de recopilaci√≥n de registros, encontrar el archivo con los registros necesarios y de alguna manera filtrar los eventos en busca de los necesarios para la depuraci√≥n. </li><li>  Colecci√≥n centralizada de registros con almacenamiento en el repositorio con la capacidad de filtrar y buscar por registros. </li></ul><br><p>  Sobre los inconvenientes, las ventajas y las m√©tricas cuantitativas que se pueden aplicar con este √∫ltimo, y hablaremos en el prisma de una implementaci√≥n espec√≠fica: <code>lager_clickhouse</code> , que utilizo en la mayor√≠a de los proyectos en desarrollo.  Algunas palabras sobre <code>lager_clickhouse</code> .  Este es el back-end lager para guardar eventos en clickhouse.  Por el momento, este es un proyecto interno, pero hay planes para hacerlo abierto.  Al desarrollar lager_clickhouse, tuve que omitir algunas caracter√≠sticas de clickhouse, por ejemplo, usar el almacenamiento en b√∫fer de eventos para evitar hacer solicitudes frecuentes en clickhouse.  El esfuerzo invertido vali√≥ la pena con un funcionamiento estable y un buen rendimiento. </p><br><p>  El principal inconveniente del enfoque para guardar en el repositorio es una entidad adicional: clickhouse y la necesidad de desarrollar c√≥digo para guardar eventos en √©l y la interfaz de usuario para analizar y buscar eventos.  Adem√°s, para algunos proyectos, puede ser cr√≠tico usar tcp para enviar registros. </p><br><p>  Pero los profesionales, me parece, superan todas las desventajas posibles. </p><br><ul><li><p>  B√∫squeda de eventos f√°cil y r√°pida: </p><br><ul><li>  Filtrar por fecha sin tener que buscar un archivo / archivos en un servidor central que contenga una variedad de eventos. </li><li>  Filtrado por entorno.  Los registros de diferentes subsistemas y, a menudo, de diferentes grupos se escriben en un repositorio.  Por el momento, la separaci√≥n se produce de acuerdo con las etiquetas que se establecen en cada nodo del cl√∫ster. </li><li>  Filtrar por nombre de host </li><li>  Filtrar por el nombre del m√≥dulo que envi√≥ el evento </li><li>  Filtrado de eventos </li><li>  B√∫squeda de texto </li></ul><br><p>  En la captura de pantalla se muestra una vista de ejemplo de la interfaz de visualizaci√≥n de registros: <br><img src="https://habrastorage.org/webt/tz/6s/qy/tz6sqy5ofprtonxlxkhywfr7gmy.png"></p><br></li><li><p>  Capacidad de automatizaci√≥n. <br>  Con la introducci√≥n del almacenamiento de registros, fue posible recibir en tiempo real informaci√≥n sobre la cantidad de errores, la ocurrencia de fallas cr√≠ticas y la actividad del sistema.  Al introducir ciertos l√≠mites, podemos generar eventos de emergencia cuando el sistema sale del estado funcional, cuyos manejadores realizar√°n acciones de automatizaci√≥n para eliminar este estado y enviar notificaciones a los miembros del equipo responsables de la funcionalidad: </p><br><ul><li>  Cuando ocurre un error cr√≠tico. </li><li>  En el caso de errores en masa (la derivada del tiempo aumenta m√°s r√°pido que un cierto l√≠mite). </li><li>  Una m√©trica separada es la tasa de generaci√≥n de eventos, es decir, cu√°ntos eventos nuevos aparecen en el registro de eventos.  Casi siempre puede saber la cantidad aproximada de registros generados por un proyecto por unidad de tiempo.  Si se supera varias veces, lo m√°s probable es que algo salga mal. </li></ul><br></li></ul><br><p>  El desarrollo ulterior del tema de la automatizaci√≥n del manejo de eventos de emergencia fue el uso de scripts lua.  Cualquier desarrollador o administrador puede escribir un script para procesar registros y m√©tricas.  Los scripts brindan flexibilidad y le permiten crear scripts y notificaciones de automatizaci√≥n personalizados. </p><br><h3 id="itogi">  Resumen </h3><br><p>  Para comprender los procesos que ocurren en el sistema e investigar incidentes, es vital tener indicadores cuantitativos y registros de eventos, as√≠ como herramientas convenientes para analizarlos.  Cuanta m√°s informaci√≥n recopilemos sobre el sistema, m√°s f√°cil ser√° analizar su comportamiento y corregir los problemas incluso en la etapa de su ocurrencia.  En caso de que nuestras medidas no funcionen, siempre tenemos a nuestra disposici√≥n horarios y registros detallados del incidente. </p><br><p>  ¬øY c√≥mo opera soluciones en Erlang / Elixir y qu√© casos interesantes encontr√≥ en la producci√≥n? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437720/">https://habr.com/ru/post/437720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437706/index.html">A√±o con Tesla</a></li>
<li><a href="../437710/index.html">Limitar al m√≠nimo los derechos de usuario local en Linux</a></li>
<li><a href="../437712/index.html">Estaci√≥n espacial Roskomnadzor</a></li>
<li><a href="../437714/index.html">Dibujamos una explosi√≥n de dibujos animados para 180 l√≠neas de C ++ desnudo</a></li>
<li><a href="../437716/index.html">Tres formas relativamente honestas de crear un proyecto Flutter</a></li>
<li><a href="../437722/index.html">Consecuencias C√≥smicas de American Shatdown</a></li>
<li><a href="../437724/index.html">OpenSceneGraph: animaci√≥n procesal de geometr√≠a y atributos de estado</a></li>
<li><a href="../437726/index.html">Serializaci√≥n de Kotlin con Kotlinx.</a></li>
<li><a href="../437730/index.html">C√≥mo resolvimos el problema de memoria en PostgreSQL sin agregar un byte</a></li>
<li><a href="../437732/index.html">Descripci√≥n general de la impresora DLP MakeX M-One Pro 70</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>