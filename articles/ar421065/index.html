<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏽 🎲 ⏬ كيف علمت منظمة العفو الدولية لعب Tetris لـ NES. الجزء 2: AI ☎️ ☕️ 🐇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="الجزء الأول (تحليل الكود) هنا: https://habr.com/post/420725/ . 

 خوارزمية 
 الوصف 
 تقوم الخوارزمية باستمرار بالخطوات التالية: 



1. ينتظر حتى يتم إ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيف علمت منظمة العفو الدولية لعب Tetris لـ NES. الجزء 2: AI</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421065/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/cfd/2c5/a7e/cfd2c5a7e44131bfc188c3eea6ad5139.png" alt="الصورة"></div><br>  الجزء الأول (تحليل الكود) هنا: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://habr.com/post/420725/</a> . <br><br><h2 style=";text-align:right;direction:rtl">  خوارزمية </h2><br><h3 style=";text-align:right;direction:rtl">  الوصف </h3><br>  تقوم الخوارزمية باستمرار بالخطوات التالية: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ينتظر حتى يتم إنشاء tetrimino جديد. </li><li style=";text-align:right;direction:rtl">  للتحقق من نوع tetrimino الذي تم إنشاؤه حديثًا ، ونوع tetrimino التالي (الشكل في حقل المعاينة) ومحتويات الملعب. </li><li style=";text-align:right;direction:rtl">  يستكشف كل الطرق الممكنة لإضافة اثنين من tetriminos إلى الملعب ويقيم كل احتمال. </li><li style=";text-align:right;direction:rtl">  تحريك tetrimino الذي تم إنشاؤه حديثًا بحيث يتطابق مع موقع أفضل الاحتمال المكتشف. </li></ol><br>  يتم وصف كل من هذه الخطوات بالتفصيل أدناه. <br><br><h3 style=";text-align:right;direction:rtl">  قفل البحث </h3><br>  ضع في اعتبارك إصدارًا مبسطًا من Tetris ، حيث لا تقع الأشكال تلقائيًا.  الطريقة الوحيدة لإسقاط الرقم هي خفضه برفق.  بعد إزالة التوقيتات من اللعبة ، يمكننا وصف حالة tetrimino النشطة بشكل كامل من خلال موقعها واتجاهها.  يحتوي الشكل على مكان معروف للإنشاء الأولي ، ويتم استخدام العمليات التالية للتحويل من حالة إلى أخرى: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  خطوة واحدة للأسفل </li><li style=";text-align:right;direction:rtl">  تركت خطوة واحدة </li><li style=";text-align:right;direction:rtl">  انقل خطوة واحدة إلى اليمين </li><li style=";text-align:right;direction:rtl">  أدر خطوة واحدة عكس اتجاه عقارب الساعة </li><li style=";text-align:right;direction:rtl">  دوران في اتجاه عقارب الساعة </li></ul><a name="habracut"></a><br>  هذه العمليات قابلة للتطبيق فقط عندما تتوافق مربعات tetrimino الناتجة مع الخلايا الفارغة في الملعب.  عندما يكون من المستحيل التحرك خطوة واحدة إلى أسفل ، تعتبر الدولة محظورة.  ومع ذلك ، نظرًا لأننا قمنا بتبسيط Tetris وانتظار القفل بشكل أساسي لا نهائي ، يمكن تحويل الحالة المقفلة بشكل أكبر من خلال عمليات أخرى عن طريق الانزلاق والتمرير. <br><br>  يمكن العثور على العديد من الحالات المحظورة مع الحد الأدنى من العمليات التي تنشئها باستخدام البحث الأول (BFS).  كما هو موضح أدناه ، فإنه يستخدم قائمة انتظار لتخزين النتائج الوسيطة. <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ننتظر الدولة عند الخلق. </li><li style=";text-align:right;direction:rtl">  نستنتج شرط من قائمة الانتظار. </li><li style=";text-align:right;direction:rtl">  نحصل على الحالات التالية باستخدام عملية التحويل. </li><li style=";text-align:right;direction:rtl">  إذا لم تكن هناك حركة هبوطية بينهما ، فسيتم حظر الحالة التي تمت إزالتها من قائمة الانتظار. </li><li style=";text-align:right;direction:rtl">  نضع في قائمة انتظار الحالات اللاحقة التي لم نقم بزيارتها بعد. </li><li style=";text-align:right;direction:rtl">  إذا لم تكن قائمة الانتظار فارغة ، كرر من الخطوة 2. </li></ol><br>  يمثل البرنامج كل حالة ككائن مع الحقول التالية: <br><br> <code>{ x, y, rotation, visited, predecessor }</code> <br> <br>  في عملية التحضير ، ينشئ البرنامج مجموعة ثلاثية الأبعاد من كائنات الحالة (20 صفًا × 10 أعمدة × 4 أدوار) ، وتهيئة <code>x</code> و <code>y</code> <code>rotation</code> وفقًا لذلك. <br><br>  يتم تمييز الحقل الذي <code>visited</code> عند وضع الدولة في قائمة الانتظار.  في BFS ، يكون هذا صحيحًا لأن كل حالة لاحقة تزيد من إجمالي طول المسار بمقدار 1. وهذا يعني أنه من خلال زيادة طول المسار ، من المستحيل إنشاء حالة لاحقة تحتاج إلى إدراجها في مكان آخر غير نهاية قائمة الانتظار للحفاظ على النظام. <br><br>  يشير الحقل <code>predecessor</code> إلى كائن الحالة الذي اشتقت منه الحالة الحالية.  يتم تعيينه عندما يتم وضع الدولة في قائمة الانتظار.  دولة الخلق ليس لها حالات سابقة. <br><br>  يتم تحديد مجموعة الحالات المحظورة التي تم اكتشافها أثناء البحث من خلال نوع tetrimino والكتل المعبأة في الملعب.  يمكن توضيح تسلسل التحركات التي تم إنشاؤها (بالترتيب العكسي) باتباع الروابط <code>predecessor</code> إلى حالة الإنشاء.  عندما يتم تعيين <code>PLAY_FAST</code> الثابت على <code>true</code> في بداية البرنامج ، فإنه يتخطى الحالات السابقة تمامًا عن طريق وضع tetrimino مباشرة في الحقل وحظره. <br><br>  يتم تجميع مجموعة ثلاثية الأبعاد من كائنات الحالة وقائمة انتظار و BFS في فئة.  لديه طريقة بحث تستقبل الملعب (صفيف ثنائي الأبعاد) ، ونوع tetrimino والمستمع.  في كل مرة يتم الكشف عن حالة قفل ، يتم تحديث الملعب عن طريق إضافة tetrimino إلى الموقع المناسب.  بعد ذلك ، يتم نقل الملعب المتغير مع معلومات حول التغييرات إلى المستمع للمعالجة.  بعد انتهاء المستمع من العودة ، يتم استعادة الملعب. <br><br>  يستخدم المستمع لدمج العديد من عمليات البحث في سلسلة ، مما يجعل من الممكن العثور على جميع الطرق الممكنة لإضافة اثنين (أو أكثر) من tetriminos إلى الملعب.  يقوم محرك البحث الأول في السلسلة بتنفيذ BFS مرة واحدة فقط.  ومع ذلك ، يقوم محرك البحث الثاني بتنفيذ BFS في كل مرة يكتشف فيها البحث الأول حالة قفل.  وهكذا ، إذا كانت هناك محركات بحث أخرى في السلسلة. <br><br>  يقوم مستمع محرك البحث الأخير بتقييم الملعب المتغير.  عندما يجد مجال اللعب أفضل مما تم التحقيق فيه سابقًا ، يكتب الكائن المستخدم للحالة المقفلة ، والذي يستخدم في الوقت الحالي أول محرك بحث في السلسلة.  نظرًا لأن محرك البحث الأول ينفذ BFS مرة واحدة فقط ، تظل الحقول <code>predecessor</code> لكائنات حالته صالحة حتى الانتهاء من عملية البحث بأكملها.  أي أن المستمع الأخير يسجل بشكل أساسي المسار الذي يجب أن يسلكه tetrimino الأول للوصول إلى أفضل تكوين في الملعب نتيجة لذلك. <br><br><h3 style=";text-align:right;direction:rtl">  دالة التقييم </h3><br>  تقوم وظيفة التسجيل بتعيين قيمة لمجال اللعب المتغير - وهو مجموع مرجح لمعلمات التأثير المختلفة.  تعتمد وظيفة التقييم المستخدمة في هذه الحالة على الوظيفة التي طورها <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إسلام العشي</a> .  يستخدم المعلمات التالية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <b>العدد الإجمالي للصفوف التي تم مسحها</b> : هذا هو العدد الإجمالي للصفوف التي سيتم مسحها بإضافة اثنين من tetriminos. </li><li style=";text-align:right;direction:rtl">  <b>إجمالي ارتفاع الحجب</b> : <b>ارتفاع الحجب</b> هو الارتفاع فوق أرضية الملعب حيث يتم قفل الشكل.  هذه هي المسافة العمودية التي قد يسقطها الرقم المقفل إذا قمت بإزالة جميع المربعات المشغولة الأخرى من ملعب اللعب والحفاظ على اتجاه الشكل.  إجمالي ارتفاع الحجب هو مجموع ارتفاعات الحجب لل tetriminos. </li><li style=";text-align:right;direction:rtl">  <b>العدد الإجمالي لخلايا "البئر"</b> : خلية البئر هي خلية فارغة تقع فوق كل الخلايا المشغولة في عمود بحيث يكون جيرانها الأيمن والأيسر خلايا مشغولة ؛  عند تحديد الآبار ، تعتبر جدران الملعب خلايا مشغولة.  الفكرة هي أن البئر عبارة عن هيكل مفتوح في الأعلى ، مغلق في الأسفل ومحاطة بجدران على كلا الجانبين.  يعني احتمال وجود فجوات متقطعة في جدران البئر أن خلايا البئر لا تحدث بالضرورة في كومة مستمرة داخل العمود. </li><li style=";text-align:right;direction:rtl">  <b>العدد الإجمالي للثقوب في الأعمدة</b> : الثقب في العمود عبارة عن خلية فارغة تقع مباشرة أسفل الخلية المشغولة.  لا يتم مقارنة جنس الملعب مع الخلية الموجودة فوقه.  لا توجد ثقوب في الأعمدة الفارغة. </li><li style=";text-align:right;direction:rtl">  <b>إجمالي عدد الانتقالات في الأعمدة</b> : الانتقال في الأعمدة هو خلية فارغة مجاورة لخلية مشغولة (أو العكس) داخل عمود واحد.  لا يعتبر توليف كتلة العمود المشغولة بأعلى مع مساحة فارغة فوقها انتقالًا.  وبالمثل ، لا يتم أيضًا مقارنة أرضية الملعب بالخلية الموجودة فوقه.  لذلك ، لا توجد انتقالات في عمود فارغ تمامًا. </li><li style=";text-align:right;direction:rtl">  <b>إجمالي عدد الانتقالات في الصفوف</b> : الانتقال في الصفوف هو خلية فارغة مجاورة لخلية مشغولة (أو العكس) داخل الصف نفسه.  تعتبر الخلايا الفارغة بالقرب من جدران الملعب مرحلة انتقالية.  يتم احتساب المبلغ الإجمالي لجميع خطوط الملعب.  ومع ذلك ، لا يتم أخذ الأسطر الفارغة تمامًا في الاعتبار في إجمالي عدد الانتقالات. </li></ul><br>  اقترح العشي أنه يمكن العثور على أوزان مفيدة باستخدام خوارزمية تحسين سرب الجسيمات (PSO) ، والتي تعمل بشكل متكرر على تحسين مجموعة الحلول عن طريق محاكاة سلوك السرب الملاحظ في الطبيعة.  في حالتنا ، كل حل هو ناقل الوزن ، ويتم تحديد ملاءمة الخيار من خلال اللعبة في Tetris ؛  هذا هو العدد الإجمالي ل tetriminos التي نجا خلالها حتى نهاية اللعبة. <br><br>  يتم تطبيق هذه الأفكار في إصدار Java الموضح أدناه ؛  يتم تشغيلها خارج FCEUX ويمكن تكوينها للعبة غير رسومات في الذاكرة تعمل بسرعة أعلى بكثير.  بعد إعداد PSO ، فوجئت برؤية أن الخوارزمية لا تتحرك أكثر بعد التكرار الأولي.  بعد هذا التكرار ، لعبت العديد من متغيرات الحلول التي تم إنشاؤها عشوائيًا بالفعل بشكل جيد.  لعدة أيام ، انخفض حجم هذه المجموعة حتى بقي خيار واحد فقط.  فيما يلي قيم هذا الحل: <br><br><table style=";text-align:right;direction:rtl"><tbody><tr><th>  معلمة </th><th>  الوزن </th></tr><tr><td>  تم مسح إجمالي عدد الصفوف </td><td> <code>1.000000000000000</code> </td> </tr><tr><td>  إجمالي ارتفاع الحجب </td><td> <code>12.885008263218383</code> </td> </tr><tr><td>  العدد الإجمالي لخلايا البئر </td><td> <code>15.842707182438396</code> </td> </tr><tr><td>  العدد الإجمالي للثقوب في الأعمدة </td><td> <code>26.894496507795950</code> </td> </tr><tr><td>  العدد الإجمالي للتحولات في الأعمدة </td><td> <code>27.616914062397015</code> </td> </tr><tr><td>  إجمالي يقفز الخط </td><td> <code>30.185110719279040</code> </td> </tr></tbody></table><br>  تم تقدير الملعب من خلال ضرب المعلمات في أوزان كل منها وإضافة النتائج.  كلما انخفضت القيمة ، كان الحل أفضل.  نظرًا لأن جميع المعلمات والأوزان لها قيم إيجابية ، فإن جميع المعلمات تضر بالتقييم الشامل ؛  يجب التقليل من كل واحد منهم.  وهذا يعني أيضًا أن أفضل نتيجة هي 0. <br><br>  نظرًا لاختيار هذه الأوزان عشوائيًا ، يمكن أن يكون نطاق القيم المناسبة واسعًا جدًا.  هذه المجموعة المحددة من الأرقام والأهمية النسبية المقدرة لكل معلمة قد لا تكون ذات صلة.  ومع ذلك ، سيكون من المثير للاهتمام مشاهدتها عن كثب. <br><br>  المعلمة الأقل ضررًا هي إجمالي عدد الصفوف التي تم محوها.  حقيقة أن هذا الخيار ضار هو غير بديهي.  لكن الهدف الرئيسي للذكاء الاصطناعي هو البقاء.  إنه لا يسعى للحصول على أكبر عدد من النقاط.  بدلاً من ذلك ، يلعب بشكل متحفظ ، وعادة ما يزيل الرتب في كل مرة.  للحصول على Double أو Triple أو Tetris ، يجب أن تنمو مجموعة تتعارض مع الهدف طويل المدى. <br><br>  التالي في القائمة هو إجمالي ارتفاع الحجب.  يمكن تقليله عن طريق خفض tetrimino بالقرب من الأرض قدر الإمكان.  هذه إستراتيجية بسيطة تساهم على المدى الطويل في البقاء ، وعلى المدى القصير في تغليف القطع بجودة عالية. <br><br>  يبدو الوزن المعين للعدد الإجمالي لخلايا البئر مفاجئًا بعض الشيء ، لأن اللاعبين ذوي الخبرة عادة ما يبنون عمدًا آبارًا عميقة لجمع عدة Tetris (تركيبات من أربعة أسطر) على التوالي.  ولكن كما ذكرنا أعلاه ، فهذه لعبة محفوفة بالمخاطر ، على عكس الهدف الرئيسي - البقاء.  بالإضافة إلى ذلك ، يعد عدد الآبار مؤشرًا على "خشونة" الوبر.  يكون مستوى معين من التفاوت مفيدًا عند وضع أرقام أو مجموعات معينة من الأشكال.  لكن الخشونة العالية تتسبب في تلف العبوة الضيقة. <br><br>  العدد الإجمالي للثقوب في الأعمدة هو تقريبًا نصف العدد الإجمالي للتحولات في الأعمدة.  يمكن دمج هذه المعلمات وطيها في معلمة مشتركة ذات صلة ، للحصول على معلمة أكثر شمولاً وأكثرها ضررًا: إجمالي عدد الانتقالات. <br><br>  تحتوي المناطق المكتظة بالسكان على عدد قليل من التحولات في جميع الاتجاهات.  لذلك ، يمكن وصف الاستراتيجية الرئيسية ، مدفوعة بالذكاء الاصطناعي ، بإيجاز على النحو التالي: حزم القطع في أقرب وقت ممكن لبعضها البعض. <br><br><h3 style=";text-align:right;direction:rtl">  خيارات أخرى </h3><br>  فيما يلي قائمة ببعض المعلمات الإضافية التي جربتها أثناء تطوير الذكاء الاصطناعي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <b>ارتفاع الكومة</b> : يمكن أن تتدلى الكتل المشغولة فوق الخلايا الفارغة ، مما يخلق نتوءات وثقوب ؛  ومع ذلك ، لا يمكن تأمين الكتل المشغولة على أسطر فارغة تمامًا.  لذلك ، ارتفاع الكومة هو عدد الصفوف التي تحتوي على كتلة مشغولة واحدة على الأقل. </li><li style=";text-align:right;direction:rtl">  <b>إجمالي عدد الأعمدة المشغولة</b> : هذا هو عدد الأعمدة التي تحتوي على خلية مشغولة واحدة على الأقل. </li><li style=";text-align:right;direction:rtl">  <b>إجمالي عدد الخلايا المشغولة</b> : عدد الخلايا المشغولة في الملعب. </li><li style=";text-align:right;direction:rtl">  <b>إجمالي عدد المناطق المتصلة</b> : يتم استخدام خوارزمية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التعبئة</a> هنا لحساب عدد المناطق المتصلة بشكل مستمر.  بالإضافة إلى العثور على "جزر" محتلة ، اكتشف ثقوبًا تمتد على طول المحورين. </li><li style=";text-align:right;direction:rtl">  <b>تشتت ارتفاع العمود</b> : هذا مقياس إحصائي للتغير في ارتفاعات العمود.  إنه مؤشر لخشونة السطح. </li><li style=";text-align:right;direction:rtl">  <b>إجمالي قيمة التكيف</b> : لحساب قيمة التكيف الخاصة بالكومة للرقم المجهول التالي.  يحسب العدد الإجمالي للطرق التي يمكن من خلالها إضافة 7 أنواع من الأشكال إلى الملعب دون ظهور ثقوب جديدة.  من أجل العد الدقيق ، سوف تكون هناك حاجة إلى الاستخدام المتكرر ل BFS.  ولكن لإجراء حساب تقريبي ، يمكن اقتطاع شجرة البحث بشكل كبير. </li><li style=";text-align:right;direction:rtl">  <b>متوسط ​​التقييم للرسم التالي</b> : تعمق هذه المعلمة البحث من خلال تحليل جميع الاحتمالات للرقم غير المعروف التالي.  يستخدم معلمات أخرى لفصل موقع كل نوع من الأشكال ، ثم إرجاع المتوسط ​​لـ 7 تقييمات.  لكل موضع من الشكل ، مطلوب BFS. </li><li style=";text-align:right;direction:rtl">  <b>لعبة المحاكاة المتوسطة</b> : تحاكي المعلمة سلسلة من الألعاب في Tetris ، واختيار القطع باستخدام مولد الأرقام العشوائي الزائف الخاص بها واستخدام AI للعمل معهم.  في نهاية كل لعبة ، يتم تقييم الملعب باستخدام معلمات أخرى.  يتم إرجاع متوسط ​​القيمة لكافة الدفعات. </li></ul><br>  يمكن تخصيص جميع المعلمات بإضافة عوامل مخصصة.  على سبيل المثال ، بدلاً من مجرد حساب الصفوف التي تم مسحها ، يمكنك تعيين أوزانك الخاصة لـ Single و Double و Triple و Tetris ، لمحاكاة نظام النقاط.  إذا أضر التنظيف المتزامن للعديد من الصفوف بالهدف طويل المدى المتمثل في البقاء على قيد الحياة ، فيمكن تعيين وزن سلبي للصفوف الفردية ، بينما يمكن أن تصبح الصفوف الأخرى إيجابية. <br><br>  عامل مفيد آخر هو قيمة الإزاحة.  على سبيل المثال ، يحتوي سطح مستوٍ تمامًا على كومة على تشتت ارتفاعات العمود 0. لكن السطح المستوي تمامًا لا يتكيف مع S و Z ، بالإضافة إلى مجموعات أخرى من الأشكال.  لذلك ، من خلال طرح الثابت ، يجب أن يتمحور التباين حول الخشونة المثلى. <br><br>  يمكن رفع المعلمات المعدلة والمتحيزة إلى حد ما حتى قبل حساب المجموع المرجح يمكنهم قياس اللوغاريتمات أو الأسي.  يمكن اعتبار كل هذه الاحتمالات أوزانًا إضافية يمكن تحسينها بطرق مثل PSO. <br><br>  تعطي العديد من المعلمات فهمًا لمدى قدرة الكومة على التعامل مع قطع إضافية ، على سبيل المثال ، تلك التي تتعامل مع خشونة السطح ، ولكن "إجمالي مقدار التكيف" و "متوسط ​​تقييم الشكل التالي" و "متوسط ​​لعبة المحاكاة" يقيمان الملعب المتغير إدخال الأشكال غير المدرجة في الاثنين المعروفين.  في دراسة الأرقام اللاحقة ، بسبب الإزالة السريعة للسلسلة ، تقل كمية المعرفة الإضافية التي تم الحصول عليها بعمق.  هذا يعني أن المسار الطويل للحزب ليس مهمًا جدًا ، وأن مسار الحزب في المستقبل البعيد ليس مهمًا أيضًا.  في الواقع ، إذا تم تعيين سلسلة قصيرة من الأرقام بشكل غير صحيح بشكل غير صحيح ، فإن الذكاء الاصطناعي يعيد اللعبة بسرعة ، باستخدام الأشكال القليلة التالية لمسح الصفوف المتأثرة.  يتطلب تحديد القيمة المثلى لتحليل الأرقام اللاحقة مزيدًا من البحث. <br><br>  جانب آخر من فائدة المعلمة هو التكلفة الحسابية.  تزداد التكاليف بشكل كبير لأن وظيفة التقييم تستدعي لكل موضع محتمل لرقمين.  نظرًا لأن الذكاء الاصطناعي يجب أن يكون قادرًا على لعب Tetris في الوقت الفعلي ، يمكن استبدال عوامل التكلفة التي توفر معلومات قيمة للحصول على تقنيات أكثر تقريبًا تعمل بشكل أسرع. <br><br><h3 style=";text-align:right;direction:rtl">  تدريب الذكاء الاصطناعي </h3><br>  هناك تسلسل مرضي يمكن أن يؤدي إلى Game Over ، بغض النظر عن الاستراتيجية.  أبسط مثال على ذلك هو التسلسل اللامتناهي لـ tetrimino S و Z ، والذي ، كما هو موضح في الرسوم المتحركة ، يؤدي بسرعة إلى فقدان الذكاء الاصطناعي. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/cb2/66a/2ba/cb266a2ba3575a43876e33f6a2948737.gif"></div><br>  نظرًا لأن الأمر يستغرق أيامًا لتشغيل متغير AI قبل إكمال عدة دفعات وحساب المتوسط ​​، فمن غير العملي تمامًا استخدام متوسط ​​مدة الدفعة كمقياس للتحكم في PSO.  بدلاً من ذلك ، يمكنك زيادة تعقيد اللعبة بسرعة محكومة عن طريق زيادة وتيرة S و Z ، الأمر الذي سيؤدي بمرور الوقت إلى إنشاء بديل لهذا الزوج من الأشكال فقط. <br><br>  لقد حاولت استخدام طريقة التدريس هذه ، لكنني وجدت أن تعليم الذكاء الاصطناعي للعمل مع S و Z المتكررين يضر بالفعل بالقدرة على التعامل مع الأشكال العشوائية الموزعة بالتساوي. <br><br>  في طريقة بديلة مستوحاة من لعبة B-Type ، يتحكم مقياس PSO في تكرار تنظيف الصفوف.  مجال اللعب عبارة عن رسم تخطيطي مكون من 10 أسطر لكتل ​​القمامة العشوائية ، وفي كل مرة يتم مسح الخط ، يظهر أدناه خط قمامة جديد ، يعيد ارتفاع كومة الذاكرة المؤقتة.  نظرًا لأن مجال اللعب يبلغ عرضه 10 أعمدة ، وتتكون كل tetrimino من 4 مربعات ، في المتوسط ​​، يجب على AI مسح صف كل 2.5 tetrimino.  وللتخلص من القمامة ، يجب أن يفعل ذلك بشكل أسرع. <br><br>  لسوء الحظ ، لم تحسن هذه التقنية الأداء أيضًا.  أحد الأسباب المحتملة هو أن ثقوب القمامة العشوائية لا تتطابق تمامًا مع الأوتار التي يتعامل معها الذكاء الاصطناعي في اللعبة الحقيقية.  بالإضافة إلى ذلك ، تنظيف الصف هدف قصير المدى.  تنظيف الصف الجشع لا يحسن بالضرورة البقاء على المدى الطويل.  من وقت لآخر ، لا ينبغي لمس الصفوف لمعالجة مجموعات معينة من الأرقام اللاحقة. <br><br>  اقترح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كولين فاي</a> نهجًا مختلفًا على صفحته على الويب.  قام بإنشاء الرسوم البيانية التي تظهر النسبة المئوية للأشكال التي تم حظرها في كل صف أثناء الكثير من التجارب.  من المثير للاهتمام أن جميع الرسوم البيانية تبدو متطابقة تقريبًا بغض النظر عن عدد الأشكال التي تم إنشاؤها.  بناءً على ذلك ، اقترح أنه يمكنك استخدام صورة تقريبية للدالة لأي دفعة تجريبية عند تقييم التوقع الإحصائي لحظر الرقم في خط الإنشاء ، وبالتالي الحصول على الوقت الذي ستلعب فيه AI حتى نهاية اللعبة.  قررت استكشاف هذا الاحتمال. <br><br>  فيما يلي خريطة حرارية للعديد من مجموعات التجارب ، تحتوي في المجموع على 2،039،900،000 tetrimino.  يتم تلوين كل خلية بناءً على النسبة المئوية للأشكال المقفلة فيها.  لتعزيز التباين البصري ، يتم تحديد لوحة غير خطية.  تم إنشاء الخريطة عن طريق تطبيع قيم الخلايا عن طريق القسمة على النسبة المئوية القصوى للخلايا ، ثم الإعلان عن قوة 0.19 (انظر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"تصحيح غاما"</a> ). <br><br><table style=";text-align:right;direction:rtl"><tbody><tr><td><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/d13/bcd/196/d13bcd1968b1f71c3311f7007c6f573e.png"></div></td><td><table style=";text-align:right;direction:rtl"><tbody><tr><th>  اللون </th><th>  النسبة المئوية </th></tr><tr><td>  <font color="#000000">■</font> </td><td> <code>0.00000000</code> </td> </tr><tr><td>  <font color="#0066FF">■</font> </td><td> <code>0.00000315</code> </td> </tr><tr><td>  <font color="#00CCFF">■</font> </td><td> <code>0.00024227</code> </td> </tr><tr><td>  <font color="#00FFCC">■</font> </td><td> <code>0.00307038</code> </td> </tr><tr><td>  <font color="#00FF66">■</font> </td><td> <code>0.01860818</code> </td> </tr><tr><td>  <font color="#00FF00">■</font> </td><td> <code>0.07527774</code> </td> </tr><tr><td>  <font color="#66FF00">■</font> </td><td> <code>0.23582574</code> </td> </tr><tr><td>  <font color="#CCFF00">■</font> </td><td> <code>0.61928352</code> </td> </tr><tr><td>  <font color="#FFCC00">■</font> </td><td> <code>1.42923040</code> </td> </tr><tr><td>  <font color="#FF6600">■</font> </td><td> <code>2.98867416</code> </td> </tr><tr><td>  <font color="#FF0000">■</font> </td><td> <code>5.78182519</code> </td> </tr></tbody></table></td></tr></tbody></table><br>  الخطوط البرتقالية الداكنة والحمراء في الخطين 17 و 18 تعني أن الغالبية العظمى من الأشكال تنتهي هناك.  اللون الأخضر الباهت من الأسفل هو نتيجة لهندسة الأشكال: 4 فقط من 7 أنواع من tetrimino يمكن أن تظهر في الخط السفلي.  الزوايا السفلية سوداء لأنه من المستحيل الوصول إليها. <br><br>  اللون على طول كل خط متساوي تقريبًا ، وهذا يشير إلى أن الأشكال موزعة بشكل أفقي بالتساوي.  يمكن تفسير الفجوات الطفيفة من خلال النظر إلى الرسوم البيانية للأنواع الفردية من الأشكال: <br><br><table style=";text-align:right;direction:rtl"><tbody><tr><td>  <b>ت</b> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/82c/fb3/c14/82cfb3c1456fce7726985859554021d8.png"></div></td><td>  <b>ي</b> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/f38/1a2/ebdf381a25323b9c73eaed6c467064b5.png"></div></td><td>  <b>ض</b> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/381/986/389/38198638921c4dcbc3a8f1978e665b89.png"></div></td><td>  <b>يا</b> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/669/be1/5e4/669be15e4ba1b9becffb4ee97e398cbb.png"></div></td><td>  <b>ق</b> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/79c/2a5/dc879c2a52f1020a69f76e9554fca978.png"></div></td><td>  <b>لام</b> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/204/acb/fbf204acb6d376818fc6e98f8f517e4e.png"></div></td><td>  <b>أنا</b> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/e41/92b/7bbe4192bbb2204d4b677a9a36354da2.png"></div></td></tr></tbody></table><br>  يتبين أن T هو النوع الأكثر شمولاً: مخططه البياني هو أكثر تجانسًا من جميع الأنواع الأخرى.  الشذوذ في الرسم البياني J - نتيجة تأثير الجدران ؛  يمكن فقط أن يكون كل من <code>Jr</code> و <code>Jl</code> في الأعمدة الجانبية ، مما يجعل AI يستخدم العمودين 1 و 9 في كثير من الأحيان للتعويض. وينطبق الشيء نفسه على L. يبدو أن المدرج التكراري Z و S متشابهين تقريبًا ، مما يؤكد عدم التوازن بسبب حقيقة أن <code>Zv</code> و <code>Sv</code> ليست صور مرآة مثالية لبعضها البعض.  يقتصر النوع O على ملعب 19 × 9 ، ويبدو أن الذكاء الاصطناعي من المرجح أن يستخدم O على الجوانب أكثر من المركز.  تتحول Tetrimino I إلى اليمين ، لأن نقطة انطلاقها تقع هناك ؛  لذلك ، من النادر تأمين القفل في العمود 1. <br><br>  يوضح الجدول النسبة المئوية للأرقام المحظورة في كل صف. <br><br><table style=";text-align:right;direction:rtl"><tbody><tr><th>  سلسلة </th><th>  النسبة المئوية </th></tr><tr><td>  0 </td><td>  0.0000000000 </td></tr><tr><td>  1 </td><td>  0.0000000000 </td></tr><tr><td>  2 </td><td>  0.0000004902 </td></tr><tr><td>  3 </td><td>  0.0000026472 </td></tr><tr><td>  4 </td><td>  0.0000066180 </td></tr><tr><td>  5 </td><td>  0.0000172557 </td></tr><tr><td>  6 </td><td>  0.0000512280 </td></tr><tr><td>  7 </td><td>  0.0001759400 </td></tr><tr><td>  8 </td><td>  0.0006681210 </td></tr><tr><td>  9 </td><td>  0.0023187901 </td></tr><tr><td>  10 </td><td>  0.0077928820 </td></tr><tr><td>  11 </td><td>  0.0259672043 </td></tr><tr><td>  12 </td><td>  0.0866187068 </td></tr><tr><td>  13 </td><td>  0.2901315751 </td></tr><tr><td>  14 </td><td>  0.9771663807 </td></tr><tr><td>  15 </td><td>  3.3000408353 </td></tr><tr><td>  16 </td><td>  10.6989059268 </td></tr><tr><td>  17 </td><td>  28.5687976371 </td></tr><tr><td>  18 </td><td>  50.0335706162 </td></tr><tr><td>  19 </td><td>  6.0077671454 </td></tr></tbody></table><br>  هنا رسم بياني للقيم: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/8a6/943/9d8/8a69439d8d818e46921cc5c9b75bd345.png"></div><br>  إذا لم يؤخذ السطر 19 في الاعتبار ، فإن الرسم البياني يظهر نموًا أسيًا. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> فيما يلي قائمة بنسب عدد الأشكال المقفلة في الصفوف المجاورة. </font></font><br><br><table style=";text-align:right;direction:rtl"><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">السلسلة </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / السلسلة </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></sub> </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> النسبة (٪) </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1/2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.00 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2/3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18.52 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3/4 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 40.00 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4/5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 38.35 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5/6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 33.68 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6/7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12/29 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/8 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 26.33 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8/9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28.81 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9/10 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29.76 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10/11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 01/30 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11/12 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29.98 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12/13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29.85 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13/14 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29.69 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14/15 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29.61 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15/16 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30.84 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16/17 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 37.45 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 17/18 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 57.10 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18/19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 832.81 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"></font><code>16–19</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تأخذ </font><font style="vertical-align: inherit;">الخطوط </font><font style="vertical-align: inherit;">في الاعتبار الأشكال التي تتفاعل مع أرضية الملعب ، بحيث يمكن التخلص منها. في الصفوف ، يكون </font></font><code>0–5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التحديد أصغر من أن يكون له معنى. النسب المتبقية ، أزواج 6 / 7-14 / 15 ، متطابقة تقريبًا ؛ متوسط ​​قيمتها 29.24٪. هذا يعني أن احتمال نمو كومة الذاكرة المؤقتة بخط واحد هو نفسه تقريبًا بغض النظر عن ارتفاع كومة الذاكرة المؤقتة. هذا أمر منطقي ، لأن قواعد Tetris تحد من التفاعل في الجزء العلوي من كومة الذاكرة المؤقتة عندما تكون معبأة بإحكام. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يوضح الرسم البياني التالي سجل </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 في</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المائة من الأشكال في السطور 6-15.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/fd6/7ec/745/fd67ec745b6509ae7c165ae0ebabedcc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إنه قريب من خط مستقيم تمامًا مع </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">معامل تحديد</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قريب من 1 </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">تعطينا </font><font style="vertical-align: inherit;">الصيغة المشتقة من </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الانحدار الخطي</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الموضح أعلاه </font><font style="vertical-align: inherit;">التقاطع مع المحور Y ، بافتراض أن النسبة المئوية للأشكال في الصف 0 تبلغ تقريبًا 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">−7.459</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ٪. ويعكس معكوس هذه القيمة توقعًا إحصائيًا يبلغ 2،877،688،349 tetrimino أو 1،151،175،340 صفًا حتى نهاية اللعبة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذا يجعلنا نفهم ذلك السجل </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تظل النسبة المئوية للأرقام في كل سطر خطية حتى السطر 0. ومع ذلك ، عندما يصل كومة الذاكرة المؤقتة تقريبًا إلى سقف الملعب ، تكون حرية الحركة مقيدة إلى حد انتهاك هذه الخاصية. بالإضافة إلى ذلك ، فإن حظر قطعة على الخط 0 لا يعني بالضرورة انتهاء اللعبة ؛ لا يزال بإمكانك حفظها إذا كان هناك مكان لإنشاء أرقام جديدة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">طريقة أخرى لتقييم قوة الذكاء الاصطناعي هي قياس متوسط ​​عدد الأشكال التي تم إنشاؤها بين التطهير الكامل للملعب. يمكن الحصول على التنظيف الكامل باستخدام 5 tetriminos فقط. على سبيل المثال ، من بين الاحتمالات الأخرى ، يمكن تحقيق ذلك من خلال خمسة أرقام O الموضوعة على أرضية الملعب. بشكل عام ، نظرًا لأن كل tetrimino يتكون من 4 مربعات وعرض الملعب 10 مربعات ، يجب أن يكون عدد الأشكال التي تم إنشاؤها بين التنظيف الكامل مضاعفًا 5 ( منذ ذلك الحين</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 × 5 ن = 2 × 10 ن</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي My AI على متوسط ​​عدد الأشكال التي تم إنشاؤها بين عمليات التنظيف الميدانية الكاملة التي تبلغ 1،181 - وهو عدد قليل إلى حد ما. نظرًا لأن التنظيف الكامل يشبه إعادة تشغيل اللعبة ، يمكن رؤية مجموعة كاملة على أنها سلسلة طويلة للغاية من عمليات إعادة تشغيل اللعبة ، يتبعها تقدم سريع إلى اللعبة. مثل تسلسل البدائل الموصوفة أعلاه </font></font><code>SZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، عادة ما تكون التسلسلات المرضية التي تؤدي إلى نهاية اللعبة قصيرة جدًا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يوضح الرسم البياني أدناه الاحتمال (بالنسبة المئوية) بأن الذكاء الاصطناعي سوف يحقق تطهيرًا كاملاً للحقل بعد العدد المحدد من الأشكال التي تم إنشاؤها.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/f7f/665/112/f7f66511246ef114d27d325a21c9b785.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحدد ترتيب الدرجة في الصيغة أعلاه معدل الانخفاض ، ويفترض ، قوة الذكاء الاصطناعي. وفقًا لهذه الصيغة ، ينتهي ما يقرب من 0.4 ٪ ، أو حوالي 1 من أصل 253 لعبة تبدأ بملعب فارغ ، بتطهير كامل في 5 tetriminos فقط. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على عكس ما اقترحه فاي ، تتطلب الثوابت في التقريبات الخطية والأسية حجم عينة كبير جدًا بحيث R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقترب 1 ، لذلك هذه الطريقة لا تنطبق على PSO. </font><font style="vertical-align: inherit;">ومع ذلك ، يمكن استخدام الثوابت التي تم الحصول عليها باستخدام مجموعات طويلة لتحسين وظيفة التقريب التي تنشئ قيمًا ثابتة محتملة للدفعات القصيرة. </font><font style="vertical-align: inherit;">في نوع من حلقات التغذية الراجعة التطويرية ، يمكن استخدام وظيفة التقريب المحسنة في PSO ، مما يعمل على تحسين الذكاء الاصطناعي ، والذي يمكن استخدامه بدوره لحساب الثوابت الجديدة ، بمثابة معايير مرجعية لوظيفة التقريب.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نسخة جافا </font></font></h3><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عن البرنامج </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالنسبة إلى المطورين غير المعتادين على Lua ، أضفت </font><font style="vertical-align: inherit;">منفذ Java AI </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إلى ملف zip المصدر</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">الفئات عبارة عن ترجمة </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سطرية لكائنات Lua استنادًا إلى عمليات الإغلاق</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الحزم </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ينقسم الرمز إلى حزمتين: </font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <code>tetris.ai</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يحتوي على فصول وواجهات AI. </font></font></li><li style=";text-align:right;direction:rtl"> <code>tetris.gui</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يخلق نموذجًا رسوميًا للملعب. </font></font></li></ul><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> دروس وواجهات AI </font></font></h4><br><font style="vertical-align: inherit;"></font><code>Tetriminos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تصف </font><font style="vertical-align: inherit;">فئة تحمل الاسم المناسب </font><font style="vertical-align: inherit;">tetrimino. </font><font style="vertical-align: inherit;">يتم استخدامه بشكل مشابه </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ويحتوي على ثوابت لجميع أنواع tetrimino:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NONE = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> J = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> O = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> L = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br> <code>NONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعني قيمة غير محددة. </font><font style="vertical-align: inherit;">يتم استخدامه للخلايا الفارغة في الملعب. </font><font style="vertical-align: inherit;">يحتوي </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أيضًا </font></font><code>Tetriminos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على نموذجين من جدول التوجيه. </font></font><code>PATTERNS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- هذا هو صفيف صحيح 4-أبعاد (النوع × دوران × مربع × إحداثيات) يحتوي على الإحداثيات النسبية للمربعات ؛ </font><font style="vertical-align: inherit;">يتم ترتيب الخطوط بحيث يكون اتجاه إنشاء الشكل في كل نوع هو الأول. </font></font><code>ORIENTATIONS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هو نموذج آخر ، صفيف ثنائي الأبعاد (نوع × دوران) من الكائنات </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي </font><font style="vertical-align: inherit;">كل منها </font><font style="vertical-align: inherit;">على إحداثيات المربع كمصفوفة من الكائنات </font></font><code>Point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يحتوي أيضًا على حقول تصف نطاق المواضع المسموح بها للاتجاه المقابل.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Point[] squares = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxY; ... }</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم استخدام Tetrimino rotation (الفهرس الثاني في كل من جدولي التوجيه) في الكائنات </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التي يتعامل معها BFS.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rotation; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visited; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State predecessor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State next; ... }</code> </pre> <br> <code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و </font></font><code>rotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">معا وصف الموقف والتوجه من هذا الرقم. نظرًا لأن نوع Tetrimino يظل ثابتًا من لحظة الإنشاء إلى الحظر ، فإن المجال الخاص به اختياري. </font><font style="vertical-align: inherit;">تنشئ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الفئة </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التي تحتوي على خوارزمية BFS مجموعة كاملة من جميع الكائنات المحتملة </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند إنشائها:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ states = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State[AI.PLAYFIELD_HEIGHT][AI.PLAYFIELD_WIDTH][<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; AI.PLAYFIELD_HEIGHT; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; AI.PLAYFIELD_WIDTH; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rotation = <span class="hljs-number"><span class="hljs-number">0</span></span>; rotation &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; rotation++) { states[y][x][rotation] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(x, y, rotation); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من أن Java تحتوي على واجهة برمجة تطبيقات Collections API الغنية ، إلا أنها </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحتوي على تطبيق خاص بها لقائمة الانتظار. </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يستخدم </font><font style="vertical-align: inherit;">الفصل </font><font style="vertical-align: inherit;">لربط </font></font><code>State.next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الكائنات </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في قائمة مرتبطة. نظرًا لأن جميع الكائنات </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">محددة مسبقًا ، </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ويمكن إضافة </font><font style="vertical-align: inherit;">كل منها </font><font style="vertical-align: inherit;">إلى قائمة الانتظار ليس أكثر من مرة واحدة ، يمكن أن تعمل قائمة الانتظار في مكانها ، مما يلغي الحاجة إلى كائنات حاوية مؤقتة غير ضرورية تستخدم في تطبيقات قائمة الانتظار العامة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"قلب" BFS هي الطريقة الموضحة أدناه </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxRotation = Tetriminos.ORIENTATIONS[tetriminoType].length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mark = globalMark++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!addChild(playfield, tetriminoType, mark, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(queue.isNotEmpty()) { State state = queue.dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxRotation != <span class="hljs-number"><span class="hljs-number">0</span></span>) { addChild(playfield, tetriminoType, mark, state, state.x, state.y, state.rotation == <span class="hljs-number"><span class="hljs-number">0</span></span> ? maxRotation : state.rotation - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxRotation != <span class="hljs-number"><span class="hljs-number">1</span></span>) { addChild(playfield, tetriminoType, mark, state, state.x, state.y, state.rotation == maxRotation ? <span class="hljs-number"><span class="hljs-number">0</span></span> : state.rotation + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } addChild(playfield, tetriminoType, mark, state, state.x - <span class="hljs-number"><span class="hljs-number">1</span></span>, state.y, state.rotation); addChild(playfield, tetriminoType, mark, state, state.x + <span class="hljs-number"><span class="hljs-number">1</span></span>, state.y, state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!addChild(playfield, tetriminoType, mark, state, state.x, state.y + <span class="hljs-number"><span class="hljs-number">1</span></span>, state.rotation)) { lockTetrimino(playfield, tetriminoType, id, state); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يفرز طابورًا مع حالة tetrimino التي تم إنشاؤها ، ثم يسترد العناصر الفرعية بالتسلسل من الحالات التي تم إزالتها من قائمة الانتظار ، ويضيفها مرة أخرى إلى قائمة الانتظار عندما تظهر في الملعب. </font><font style="vertical-align: inherit;">يتم تمرير حقل اللعبة الذي يحتوي على مجموعة من الخلايا المشغولة والخالية ، ونوع Tetrimino الذي تم إنشاؤه ، ومعرف عشوائي إلى </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. أثناء تنفيذ BFS ، يتم استدعاء المستمع عندما يتم الكشف عن موقف القفل.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISearchListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, State state)</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يستمع المستمع إلى ساحة لعب متغيرة تحتوي على tetrimino مقفل في مكانه. يتم أيضًا إرسال نوع Tetrimino الذي تم إنشاؤه ومعرف عشوائي. المعلمة الأخيرة هي </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التي يتم فيها حظر tetrimino. باتباع سلسلة الارتباطات </font></font><code>State.predecessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، يمكنك استعادة كل طريق إلى </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إنشاء شكل. </font></font><br><br> <code>State.visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن تنفيذها على النحو </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">؛ ولكن مع كل التسهيلات اللازمة لفرز قبل تفتيش </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للإغاثة </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. بدلاً من ذلك ، قمت بعمل </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قيمة </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مقارنة بالعداد ، تزداد مع كل مكالمة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة</font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ما قبل الطابور الحالات اللاحقة. يجب أن تكون الحالة اللاحقة داخل الحقل وأن تكون موجودة على 4 خلايا فارغة في الملعب. بالإضافة إلى ذلك ، يجب عدم النظر في الحالة اللاحقة </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. إذا كان الموقف غير مقبول، </font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عودة </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، حتى لو فشلت الدولة اللاحقة لوضعها في المكان لأنه قد زار بالفعل. </font><font style="vertical-align: inherit;">تستخدم </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة </font><font style="vertical-align: inherit;">القيمة المرجعة لتحديد ما إذا كان يمكن إنشاء شكل. إذا لم يتم إنشاء الشكل ، فحينئذٍ يصل كومة الذاكرة المؤقتة إلى القمة ولم يعد من الممكن إجراء البحث ؛ لذلك يعود </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">قابل للإرجاع</font></font><code>search</code><font style="vertical-align: inherit;"></font><code>addChild</code><font style="vertical-align: inherit;"></font><code>false</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أهمية يجري دراستها أيضا لإمكانية النزول خطوة أخرى. إذا كان لا يمكن القيام بذلك ، فإن الحالة الحالية هي موضع القفل وتبدأ المكالمة </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. تقوم الطريقة </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بتغيير الملعب ، واستدعاء المستمع ، ثم استعادة الملعب. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي كل صف من المصفوفة </font></font><code>playfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على عنصر إضافي واحد ، يخزن عدد الخلايا المشغولة في الصف. يتم تنفيذ زيادة عنصر بواسطة الطريقة </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لأنه يميز الخلايا بأنها مشغولة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عندما يتلقى المستمع ساحة لعب معدلة ، يتصل</font></font><code>PlayfieldUtil.clearRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لحذف الصفوف المعبئة يتعرف عليها الأسلوب عن طريق التحقق من القيمة في العنصر الإضافي للصفيف. لإزالة سلسلة ، تستفيد الشفرة من حقيقة أنه في Java ، تعد المصفوفات ثنائية الأبعاد هي في الأساس صفائف من المصفوفات ؛ فإنه يدفع فقط روابط إلى سلاسل. </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي على خطوط مجانية ؛ يكمل عملية التنظيف بإدخال رابط لأحدها. قبل إجراء النقل ، يتم تخزين فهرس الصف الذي يتم محوه في عنصر صف إضافي. ثم يتم دفع الرابط إلى الخط على المكدس. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثم يتصل المستمع</font></font><code>PlayfieldUtil.restoreRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتجاهل التغييرات التي تم إجراؤها على أرض الملعب. </font><font style="vertical-align: inherit;">يتم إلغاء الخطوات بترتيب عكسي. </font><font style="vertical-align: inherit;">أولاً نحصل على صف مجاني من الأعلى. </font><font style="vertical-align: inherit;">ثم ، يتم استرداد الصف المعبأ من المكدس ويتم استعادة الفهرس من العنصر الإضافي. </font><font style="vertical-align: inherit;">يتم استخدامه لتحويل مراجع الخط والعودة إلى مكان الخط المحذوف. </font><font style="vertical-align: inherit;">أخيرًا ، يتم استعادة عنصر إضافي ، ويتم تعيين قيمة عرض الملعب - عدد الخلايا المشغولة في الصف المملوء. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هناك </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أيضًا طريقة </font></font><code>evaluatePlayfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحسب وتكتب 4 معلمات تقييم في فئة الحاوية الموضحة أدناه.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayfieldEvaluation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> holes; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> columnTransitions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowTransitions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wells; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يدير الصف كل هذا </font></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يحتوي على شيئين </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">متصلان معًا من قبل المستمع الموضح أدناه.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, State state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-number"><span class="hljs-number">0</span></span>) { result0 = state; } Orientation orientation = Tetriminos.ORIENTATIONS[tetriminoType][state.rotation]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = playfieldUtil.clearRows(playfield, state.y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalTotalRows = totalRows; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalTotalDropHeight = totalDropHeight; totalRows += rows; totalDropHeight += orientation.maxY - state.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextID = id + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextID == tetriminoIndices.length) { playfieldUtil.evaluatePlayfield(playfield, e); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fitness = computeFitness(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fitness &lt; bestFitness) { bestFitness = fitness; bestResult = result0; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchers[nextID].search(playfield, tetriminoIndices[nextID], nextID); } totalDropHeight = originalTotalDropHeight; totalRows = originalTotalRows; playfieldUtil.restoreRows(playfield, rows); }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن </font><font style="vertical-align: inherit;">للفئة </font><font style="vertical-align: inherit;">التعامل مع أي عدد من الكائنات </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، لكن Nintendo Tetris لا تعرض سوى شكل واحد مقدمًا. </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم تخزين </font><font style="vertical-align: inherit;">الكائنات </font><font style="vertical-align: inherit;">في مصفوفة ، ويعمل الرمز الموضح أعلاه كمستمع مشترك لها. المعرف العشوائي الذي تم تمريره إلى الطريقة </font></font><code>Searcher.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هو في الواقع فهرس المصفوفة ، وهو أيضًا عمق البحث. عندما يتم استدعاء المستمع ، يوجه المعرف المكالمة إلى التالي </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في السلسلة. إذا وصل إلى نهاية المصفوفة ، ثم يقيم الملعب. وعندما يجد ساحة لعب ذات درجة لياقة أعلى ، يكتب المدرج المحظور </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من الأول </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في السلسلة. </font></font><br><br> <code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي على طريقة </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تستقبل الملعب وصفيف يحتوي على أنواع tetrimino التي تم إنشاؤها والتالي. يعود</font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحتوي على الموضع والدوران الذي يجب فيه حظر التتريمينو الأول. </font><font style="vertical-align: inherit;">لا يركز على tetrimino الثاني ؛ </font><font style="vertical-align: inherit;">في المرة التالية التي يتم استدعاؤها ، تقوم بإعادة حساب النتيجة. </font><font style="vertical-align: inherit;">إذا كانت كومة الذاكرة المؤقتة عالية جدًا </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وفشل </font><font style="vertical-align: inherit;">السلسلة </font><font style="vertical-align: inherit;">في وضع كل من tetriminos ، </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فسوف تعود </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] tetriminoIndices)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tetriminoIndices = tetriminoIndices; bestResult = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; bestFitness = Double.MAX_VALUE; searchers[<span class="hljs-number"><span class="hljs-number">0</span></span>].search(playfield, tetriminoIndices[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestResult; }</code> </pre> <br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحدي الذكاء الاصطناعي </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأن إصدار Java غير مرتبط بـ FCEUX ، فمن المحتمل استخدامه في مشاريع أخرى. بالنسبة لأولئك الذين يرغبون في دمج الذكاء الاصطناعي في مكان آخر ، يصف هذا القسم كل ما تحتاجه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أولاً ، قم بإنشاء مثيل </font></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ومثال </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وصفيف لاحتواء جميع أنواع tetrimino المعروفة. بالإضافة إلى ذلك ، قم بإنشاء </font></font><code>PlayfieldUtil.createPlayfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثيل من الملعب عن طريق </font><font style="vertical-align: inherit;">الاتصال </font><font style="vertical-align: inherit;">؛ تقوم بإرجاع صفيف ثنائي الأبعاد مع عمود إضافي ، الذي درسناه أعلاه. ربما ستحتاج أيضًا إلى مولد رقم عشوائي.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(); PlayfieldUtil playfieldUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayfieldUtil(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tetriminos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[AI.TETRIMINOS_SEARCHED]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] playfield = playfieldUtil.createPlayfield(); Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في البداية ، يكون الملعب فارغًا ، وجميع الخلايا ذات صلة </font></font><code>Tetriminos.NONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">إذا قمت بملء الخلايا برمجيًا ، فلا تنسَ كتابة </font></font><code>playfield[rowIndex][AI.PLAYFIELD_WIDTH]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عدد الخلايا المشغولة في كل صف. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">املأ مجموعة أنواع tetrimino بأنواع الشكل الذي تم إنشاؤه مبدئيًا والشكل التالي ، اللذين يتم تحديدهما يدويًا عادةً.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثم نمرر مجال اللعب ومجموعة الأنواع إلى الطريقة </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">سيعود </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حيث تحتاج إلى حظر tetrimino الأول. </font><font style="vertical-align: inherit;">إذا عاد </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، فإن اللعبة انتهت لا مفر منها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">State state = ai.search(playfield, tetriminos);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا كنت بحاجة إلى طريقة من إنشاء شخصية إلى قفل ، فمررها إلى </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة </font></font><code>AI.buildStateList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">State[] states = ai.buildStatesList(state);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتحديث الملعب ، سنمرره </font></font><code>PlayfieldUtil.lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مع نوعه وشيءه </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">تقوم هذه الطريقة بمسح الصفوف المملوءة تلقائيًا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">playfieldUtil.lockTetrimino(playfield, tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>], state);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قبل الاتصال مرة أخرى ، </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحتاج إلى تحديد tetrimino التالي بشكل عشوائي.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>]; tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> معًا ، يبدو هذا كما يلي: </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(); PlayfieldUtil playfieldUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayfieldUtil(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tetriminos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[AI.TETRIMINOS_SEARCHED]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] playfield = playfieldUtil.createPlayfield(); Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... print playfield ... State state = ai.search(playfield, tetriminos); if (state == null) { break; // game over } playfieldUtil.lockTetrimino(playfield, tetriminos[0], state); tetriminos[0] = tetriminos[1]; tetriminos[1] = random.nextInt(7); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بدلاً من عرض الملعب في شكل نصي ، يمكنك استخدام طريقة أكثر إثارة للاهتمام لعرض ما يحدث ... </font></font><br><br><h4 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عرض مجال اللعب </font></font></h4><br><font style="vertical-align: inherit;"></font><code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يقلد </font><font style="vertical-align: inherit;">الفصل </font><font style="vertical-align: inherit;">رسومات Nintendo Tetris ، بما في ذلك الميزات السلوكية الموضحة في الجزء السابق من المقالة.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/d58/dac/a4c/d58daca4c668408a42efa51ad7508d75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لرؤيتها في العمل ، قم بتشغيلها </font></font><code>tetris.gui.Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">كما هو الحال مع إصدار Lua ، يمكننا ضبط سرعة اللعبة عن طريق تغيير القيمة الثابتة في بداية الملف.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> PLAY_FAST = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;</code> </pre> <br> <code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 طرق للتعامل مع الشاشة. </font><font style="vertical-align: inherit;">الطريقة </font></font><code>displayTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تجعل tetrimino النشط في الإحداثيات المحددة. </font><font style="vertical-align: inherit;">يتلقى معلمة تأخير ، مما يؤدي إلى انتظار الطريقة قبل إرجاع العدد المحدد من إطارات الرسوم المتحركة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delay)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تقفل الشكل في مكانه. </font><font style="vertical-align: inherit;">يتم تحديث عدادات الصف والنقاط والمستوى وألوان tetrimino وفقًا لذلك ، لتوضيح السلوك الغريب المتوقع عندما تتجاوز القيم القيم المسموح بها. </font><font style="vertical-align: inherit;">يتضمن تعيين </font></font><code>animate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قيمة </font><font style="vertical-align: inherit;">لمعلمة </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">رسومًا متحركة لتنظيف الصف وخفقان الشاشة عند تلقي Tetris. </font><font style="vertical-align: inherit;">يتم حظر الطريقة حتى انتهاء الرسوم المتحركة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animate)</span></span></span></span></code> </pre> <br> <code>updateStatisticsAndNext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يقوم بزيادة عداد الإحصائيات لـ tetrimino الذي تم إنشاؤه حديثًا وتحديث عرض الشكل التالي. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateStatisticsAndNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> activeTetrimino, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nextTetrimino)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"></font><code>dropTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تخلق </font><font style="vertical-align: inherit;">الطريقة </font><font style="vertical-align: inherit;">شكلاً وتسمح لها بالنزول تحت تأثير "الجاذبية" ، دون القيام بأي محاولات لتدويرها أو تحريكها. </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يستخدمه لآخر رقمين عندما </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعود </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. إذا كانت المعلمة </font></font><code>animate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تعيين </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، ثم عندما يكون من المستحيل لخلق شخصية الستار اللعبة. كما هو الحال مع جميع الطرق الأخرى ، يتم حظر هذه الطريقة حتى انتهاء الرسوم المتحركة. </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا </font><font style="vertical-align: inherit;">تعود </font><font style="vertical-align: inherit;">إلا عندما يمكنها إنشاء شخصية في ساحة لعب مزدحمة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dropTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animate)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب أن يتم استدعاء هذه الطرق الأربعة بواسطة سير العمل ، ولكن </font></font><code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب أن يتم تكوينها في سلسلة ارسال الحدث نفسها. لترى كيف يتم ذلك ، انظر الفصل </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من أجل الاهتمام ، </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يستخدم فئة </font></font><code>Randomizer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحاكي مولد الأرقام العشوائية الزائفة المتحيز من Nintendo Tetris. </font><font style="vertical-align: inherit;">تحتوي </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحزمة </font></font><code>tetris.gui.images</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على ملفات متعلقة بالعرض. </font></font><code>tiles.png</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- هذا هو جدول نمط يحتوي على جميع رسومات البلاط. </font></font><code>background.dat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يخزن معرفات البلاط التي تشكل الخلفية ؛ البيانات المستخرجة من </font></font><code>$BF3F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. و </font></font><code>colors.dat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي بايت توليد الساحات غير عادية اللون التي تظهر على مستوى 138. </font></font><br><br> <code>ImageLoader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي NES الجدول لوحة، و </font></font><code>ImagePane</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مخازن مجموعة كاملة من القيم مستويات المعروض.</font></font><br><br><h4 style=";text-align:right;direction:rtl">  مشاريع أخرى </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من المحتمل أن يتم استخدام الرمز بدلاً من الكتابة للوضع التجريبي. في الواقع ، يمكن تقديم مثل هذا العرض التوضيحي إلى الأبد ، مع الاستفادة من مدى سرعة الذكاء الاصطناعي في مسح مجال اللعب بالكامل. لتحقيق ذلك ، في مولد الأرقام العشوائية الزائفة ، تحتاج إلى استخدام بعض الثابت التعسفي كبذرة ، الأمر الذي سيعطينا تسلسلًا حاسمًا من tetrimino. سيتم تسجيل أول تسلسلين tetrimino. عندما يصل الذكاء الاصطناعي إلى تنظيف الحقل الكامل ، ستتم مقارنة الروتينين التاليين مع أول اثنين من التسلسل. إذا كانا متطابقين (هذا الحدث متوقع كل 49 عملية تنظيف حقل كاملة) ، عندها يمكن تمرير مولد الأرقام العشوائية الزائفة بنفس ثابت البذور ، مما سيؤدي إلى إنشاء حلقة عرض لانهائية. يمكن أن تكون مدة الدورة طويلة جدًا لإخفاء حقيقة أنها دورة. أيضايمكن أن يبدأ العرض التوضيحي عند نقطة عشوائية في الحلقة ، مما يؤدي إلى إنشاء عرض توضيحي جديد في كل مرة.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هناك إمكانية أخرى لاستخدام الذكاء الاصطناعي وهي إنشاء وضع "لاعب مقابل كمبيوتر". في لعبة Tetris متعددة اللاعبين ، أثناء مسح العديد من الخطوط في نفس الوقت ، تظهر خطوط القمامة في الجزء السفلي من حقل الخصم ، مما يرفع الملعب. يجب أن يكون الذكاء الاصطناعي قادرًا على حماية نفسه من الحطام لنفس السبب الذي يمكنه من لعب ألعاب من النوع B. ومع ذلك ، كما ذكرنا سابقًا ، يلعب الذكاء الاصطناعي بشكل متحفظ ، وعادة ما يسعى إلى مسح سطر واحد في كل مرة. أي أنه سيكون قادرًا على الدفاع عن نفسه من الهجمات ، لكنه غير قادر على الهجوم. لكي أتمكن من تغيير سلوكه ، أنشأت واجهة تسمى </font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IChildFilter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation)</span></span></span></span>; }</code> </pre> <br> <code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لديه منشئ بديل يحصل على التنفيذ </font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. إذا كان متاحًا ، </font></font><code>IChildFilter.validate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فهو بمثابة فحص إضافي للحصول على إذن من الدولة الفرعية ؛ إذا عاد </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، لا يتم وضع الحالة التابعة في قائمة الانتظار. </font></font><br><br> <code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هو تنفيذ</font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تهدف إلى التقاط أربعة صفوف (تتريس). </font><font style="vertical-align: inherit;">مثل اللاعبين الأحياء ، تقوم ببناء بئر تدريجيًا في العمود الموجود في أقصى يمين الملعب ، وترتفع خطًا تلو الآخر من الأسفل إلى الأعلى. </font><font style="vertical-align: inherit;">نظرًا لأنه يعمل سطرًا بسطر ، فإنه يرفض الحالات الفرعية التي تضيف مربعًا إلى العمود الموجود في أقصى اليمين. </font><font style="vertical-align: inherit;">عندما يكون الصف بأكمله ، باستثناء عمود البئر ، ممتلئًا تمامًا ، ينتقل الذكاء الاصطناعي إلى الصف التالي. </font><font style="vertical-align: inherit;">عندما تكون 4 أو أكثر من هذه الخطوط جاهزة ، فإنها تسمح لـ "العصا" بالسقوط في البئر والحصول على تتريس. </font><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، يتم تتبع ارتفاع كومة الذاكرة المؤقتة ؛ </font><font style="vertical-align: inherit;">إذا أصبح كبيرًا جدًا ، فإنه </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتوقف عن التأثير على الذكاء الاصطناعي.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/82b/c27/710/82bc27710c0e5200d599be07bf549206.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لاختباره في العملية ، قم بإجراء </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التغييرات التالية:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WellFilter());</code> </pre> <br> <code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعمل ، ولكن ليست فعالة بشكل خاص. يحتوي على مجريات ارشادية بسيطة مصممة لتوضيح المفهوم. للحصول على Tetris في كثير من الأحيان ، تحتاج إلى استخدام استراتيجية أكثر تعقيدًا ، ربما استراتيجية يمكن تحسينها باستخدام PSO. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، يمكنك استخدام تصفية الحالة الفرعية لإنشاء أنماط. فيما يلي مثال على ما يستطيع </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/569/e21/15f/569e2115f8936fc3391d1bb330017d8a.png"></div><br> <code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يبني الصور سطرا بسطر من الأسفل إلى الأعلى ، على غرار طريقة عملها </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">؛ </font><font style="vertical-align: inherit;">ومع ذلك ، بدلاً من الحفاظ على العمود الموجود في أقصى اليمين ، فإنه </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يوافق فقط على الحالات الفرعية التي تتوافق مع نمط معين. </font><font style="vertical-align: inherit;">يحصل </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المنشئ </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على اسم إحدى الصور الموجودة في الحزمة </font></font><code>tetris.gui.patterns</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، والتي يستخدمها كقالب. </font><font style="vertical-align: inherit;">تحتوي كل صورة 20 × 10 على بيكسلات سوداء وبيضاء تتوافق مع الخلايا في الملعب.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PatternFilter(<span class="hljs-string"><span class="hljs-string">"tetriminos"</span></span>));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يخلق سطر الكود الموضح أعلاه الصور الظلية لسبعة أنواع من tetrimino. </font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/0c8/d79/cb30c8d795e12e41d3831a0735637a55.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مثال آخر مع tetrimino T كبير يدور بزاوية. </font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/f95/14c/cf0f9514c3a08b88c4f67117614ade91.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثال آخر. </font><font style="vertical-align: inherit;">إذا نظرت عن كثب ، سترى اسم اللعبة.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/a26/712/284/a267122840a2373e7bb5fb6fa6282018.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثل </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ليس أكثر من إثبات للمفهوم. </font><font style="vertical-align: inherit;">تقتصر الأنماط التي يعالجها على الجزء السفلي من الملعب نظرًا لحقيقة أن محاولات الحصول عليها تنتهي عادةً مع انتهاء اللعبة. </font><font style="vertical-align: inherit;">ومع ذلك ، هذه فكرة مثيرة للاهتمام تستحق المزيد من الدراسة.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إصدار غمبد </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتجاهل برنامج Lua النصي وجافا الجاذبية. بالنسبة لهم ، سرعة الهبوط ليست مهمة ، لأنه اعتمادًا على التكوين ، إما أن ينقلوا الأرقام فورًا إلى الموقع المطلوب ، أو يسحبون على أي مسار مختار. بطريقة ما ، هم فقط يحاكيون تتريس ، لا يلعبونها. ومع ذلك ، في </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ملف مضغوط مع المصادر ،</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هناك نص Lua آخر يلعب عن طريق توليد إشارات أزرار لوحة الألعاب ، والتي تسمح للعبة بالتحكم في حركة الأشكال والجاذبية وكل شيء آخر. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تؤدي إضافة الجاذبية إلى توسيع مساحة البحث بشكل كبير ، مما يجبر الذكاء الاصطناعي على مراعاة القواعد الماكرة للتلاعب بالأشكال. يتم وصف تفاصيل هذه القواعد في الجزء الأول من المقالة ، ويمكن تقديرها بالكامل من خلال دراسة مباشرة للكود.</font></font> فيما يلي أهمها: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">       : ,   . </li><li style=";text-align:right;direction:rtl">   «»   . </li><li style=";text-align:right;direction:rtl">   «»  «»    . </li><li style=";text-align:right;direction:rtl">         . </li><li style=";text-align:right;direction:rtl">          . </li><li style=";text-align:right;direction:rtl">          . </li><li style=";text-align:right;direction:rtl">          . </li><li style=";text-align:right;direction:rtl">   ,        . </li><li style=";text-align:right;direction:rtl">   A  B           . </li><li style=";text-align:right;direction:rtl">  «»  «»       6      16 .     «»  «»   ,     . </li><li style=";text-align:right;direction:rtl">  «»            3 . </li><li style=";text-align:right;direction:rtl">       96 .    ,    — . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لاستيعاب جميع هذه القواعد ، يجب تضمين المعلومات التاريخية في حالات البحث. يحتاجون إلى حقول يتم فيها تخزين عدد الإطارات المعلقة لكل زر وعدد الإطارات بعد آخر إصدار تلقائي. </font><font style="vertical-align: inherit;">تميز </font><font style="vertical-align: inherit;">كل مجموعة فريدة من القيم ، بما في ذلك الإحداثيات </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ودوران tetrimino حالة منفصلة وفريدة. لسوء الحظ ، فإن عدد الاحتمالات كبير للغاية لدرجة أن البحث الكامل عن هذه المساحة غير عملي. تستكشف نسخة AI الخاصة بلوحة الألعاب مجموعة فرعية فقط منها. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يستخدم AI كائنًا </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مع الحقول التالية:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">{ x, y, rotation, Left, Right, Down, A, B, fallTimer, visited, predecessor }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بدلاً من استخدام التحول التلقائي للذكاء الاصطناعي في الإطارات البديلة ، اضغط على زر التحول ثم حرره. </font><font style="vertical-align: inherit;">لذلك ، يحتاج فقط إلى مراقبة ما إذا كان الزر مضغوطًا ، وليس طول الضغط عليه. </font><font style="vertical-align: inherit;">نظرا لعدم التناوب التلقائي، وتنطبق نفس الفكرة إلى أزرار A و B. لذا الميدان </font></font><code>Left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>Right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن أن تفسر على أنها سرد يحتوي على إحدى القيم التالية:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">{ RELEASED, PRESSED }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> من ناحية أخرى ، بالنسبة للنزول الناعم ، يجب عليك أولاً الضغط باستمرار على الزر "لأسفل" لثلاثة إطارات ، الأمر الذي يتطلب وجود 4 حالات: </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">{ RELEASED, PRESSED_FOR_1_FRAME, PRESSED_FOR_2_FRAMES, PRESSED_FOR_3_FRAMES }</code> </pre> <br> <code>Down</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يزداد تدريجياً من القيمة </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إلى </font></font><code>PRESSED_FOR_3_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، حيث يحدث نزول ناعم. بعد ذلك ، يمكن أن تتلقى قيمة </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أو تعود إليها </font></font><code>PRESSED_FOR_2_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، مما يسبب نزولًا ناعمًا كل إطار ثان بعد التأخير الأولي. لا يمكن أن يكون </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من </font></font><code>PRESSED_FOR_1_FRAME</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أو من </font></font><code>PRESSED_FOR_2_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في الواقع ، يستخدم رمز لوا ثابت عدد صحيح ، ولكن المبدأ هو نفسه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وبالمثل، </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و </font></font><code>predecessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم تعيينه القيمة التي تم الحصول عليها عند الكتابة في ولاية طابور الفرعية؛ أنه </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيكون واحدا أكثر من قيمة الدولة الأم. شرط يحتوي على</font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، يساوي سرعة الهبوط ، يعني أن الهبوط التلقائي يحدث في هذا الإطار ، وبالنسبة للحالات اللاحقة من هذه الحالة </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ستكون </font><font style="vertical-align: inherit;">القيمة </font><font style="vertical-align: inherit;">0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كل </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تعريف مسبق </font></font><code>8-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لصفيف يحتوي على جميع الحالات الممكنة ( </font></font><code>20  × 10  × 4  × 2  × 2  × 4  × 2 A × 2 B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ، ويتم تنفيذ BFS بشكل مشابه للطريقة المعروضة </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للصفيف. </font><font style="vertical-align: inherit;">يصف الكود الزائف الموضح أدناه كيفية الحصول على الحالات اللاحقة من حالات السكون.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Slide = (Left == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (Right == PRESSED) Rotate = (A == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (B == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == RELEASED <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> Down == PRESSED_FOR_3_FRAMES then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == RELEASED then nextDown = PRESSED_FOR_1_FRAME <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> nextDown = PRESSED_FOR_2_FRAMES end addChild(Down = nextDown) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED, Down = nextDown) addChild(B = PRESSED, Down = nextDown) end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Slide then addChild() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED) addChild(B = PRESSED) end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> addChild(Left = PRESSED) addChild(Right = PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(Left = PRESSED, A = PRESSED) addChild(Left = PRESSED, B = PRESSED) addChild(Right = PRESSED, A = PRESSED) addChild(Right = PRESSED, B = PRESSED) end end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == PRESSED_FOR_1_FRAME then nextDown = PRESSED_FOR_2_FRAMES <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> nextDown = PRESSED_FOR_3_FRAMES end addChild(Down = nextDown) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED, Down = nextDown) addChild(B = PRESSED, Down = nextDown) end end</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما هو موضح في الكود الزائف أدناه ، </font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تأخذ </font><font style="vertical-align: inherit;">الوظيفة </font><font style="vertical-align: inherit;">في الاعتبار ترتيب الأحداث التي تحدث في كل إطار (على سبيل المثال ، التحول والتناوب والنزول).</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">nextFallTimer = fallTimer + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Left == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y, rotation) then x = x - <span class="hljs-number"><span class="hljs-number">1</span></span> elseif Right == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y, rotation) then x = x + <span class="hljs-number"><span class="hljs-number">1</span></span> end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x, y, nextClockwiseRotation) then rotation = nextClockwiseRotation elseif B == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x, y, nextCounterclockwiseRotation) then rotation = nextCounterclockwiseRotation end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == PRESSED_FOR_3_FRAMES <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> nextFallTimer &gt;= dropSpeed then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> testPosition(x, y + <span class="hljs-number"><span class="hljs-number">1</span></span>, rotation) then y = y + <span class="hljs-number"><span class="hljs-number">1</span></span> nextFallTimer = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lockTetrimino() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end end childState = states[y][x][rotation][Left][Right][Down][A][B] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> childState.visited then childState.visited = mark childState.predecessor = state childState.fallTimer = nextFallTimer <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.enqueue(childState) end</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما في الإصدار السابق ، تقوم </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بإرجاع سلسلة من الكائنات </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. ولكن في هذه الحالة ، </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي </font><font style="vertical-align: inherit;">كل منها </font><font style="vertical-align: inherit;">على العديد من الأزرار التي يجب الضغط عليها في كل إطار. الحقول </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ولا يتم </font></font><code>rotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استخدامها لمعالجة الأشكال ، ولكن يمكن استخدامها للتحقق من الحركة الصحيحة للأشكال. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من تقليص مساحة البحث بشكل كبير بسبب القيود الموضحة أعلاه ، يستغرق إكمال البحث من 1 إلى 3 ثوانٍ. إذا قمت بتشغيله ، ستلاحظ وقفة بعد إنشاء كل tetrimino. بالإضافة إلى ذلك ، تبدو الحركات غير طبيعية للغاية. عادة ما يتم إجراء منعطف فوري قبل القفل. ومع ذلك ، يلعب هذا الذكاء الاصطناعي تقريبًا نفس طريقة الإصدار الذي تجاهل الجاذبية ، حتى بأقصى سرعة.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للتحقق من ذلك ، قم بتشغيله </font></font><code>lua/NintendoTetrisAIGamepadVersion.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، الموجود في </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ملف مضغوط مع المصادر</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">طريقة أبسط لحساب الجاذبية هي الحد من حركة الأشكال فقط عن طريق الدوران ، يليه التحول ، ثم النزول إلى الأسفل. </font><font style="vertical-align: inherit;">الفكرة هي أنه إذا تخلصت من الانزلاق والتمرير ، فإن السرعة الرأسية للأرقام لن يكون لها تأثير يذكر على الذكاء الاصطناعي ؛ </font><font style="vertical-align: inherit;">كل ما يحتاجه هو تسليم الرقم إلى العمود المطلوب ، وستقوم الجاذبية بالباقي. </font><font style="vertical-align: inherit;">ميزة أخرى لهذه التقنية هي أن مساحة البحث صغيرة جدًا ، مما يسمح لك باللعب في الوقت الفعلي ، دون تأخير للحسابات. </font><font style="vertical-align: inherit;">ومع ذلك ، فإن العيب في هذا النهج هو أنه بدون الانزلاق والتمرير ، يلعب الذكاء الاصطناعي أسوأ بكثير. </font><font style="vertical-align: inherit;">ومع ذلك ، فإن Tetris AI ، غير قادر على اللعب في الوقت الحقيقي ، لا قيمة له عمليًا.</font></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إضافة </font></font></h2><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/cfd/2c5/a7e/cfd2c5a7e44131bfc188c3eea6ad5139.png" alt="تتريس"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في وقت سابق ، كتبت مكونًا إضافيًا يحاكي لاعبًا في Tetris إجرائيًا. </font><font style="vertical-align: inherit;">ومع ذلك ، كان لمشروعي بعض العيوب:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قام البوت بإيقاف تشغيل الجاذبية ، مما يسمح لك بأداء الإنزلاق والتمرير ، متجاوزًا قدرات اللاعب عند الحد الأدنى من Nintendo Tetris. </font><font style="vertical-align: inherit;">لم يقم أبدًا برفع الأرقام لأسفل ، ولكن الطريقة الوحيدة لخفض الأرقام لأسفل هي الهبوط الناعم الخاضع للرقابة. </font><font style="vertical-align: inherit;">أي أنه يلعب في عالم نظري ومثالي. </font><font style="vertical-align: inherit;">بصراحة ، يغش.</font></font></li><li style=";text-align:right;direction:rtl">   .    —  ,      .     Double, Triple  Tetris,         —  ,    .         90.    ,   ,       29   -     . </li><li style=";text-align:right;direction:rtl">          .      .       .     ,  Tetris      . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذا القسم ، سأتحدث عن روبوت متقدم يلعب نينتندو تتريس دون تعطيل الجاذبية. </font><font style="vertical-align: inherit;">يقوم بتقييم المخاطر وإدارتها ، ويسعى جاهدًا للحصول على أقصى عدد من النقاط قبل الوصول إلى سرعة نزول عالية.</font></font><br><br><hr><br><h1 style=";text-align:right;direction:rtl">  فيديو </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> شاهد البوت يكسب الحد الأقصى من نقاط Nintendo Tetris بدءًا من المستوى 19 في جميع مقاطع الفيديو الموضحة أدناه. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/l2YOt_GdfA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zsd3eAYMlN0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/efh-_zeQH4Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><hr><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تنزيل </font></font></h1><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TetrisAI_2018-01-28.zip</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يحتوي </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الملف </font></font><code>.zip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على:</font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <code>src</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - شجرة رمز المصدر. </font></font></li><li style=";text-align:right;direction:rtl"> <code>TetrisAI.jar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ملف ثنائي مترجم. </font></font></li><li style=";text-align:right;direction:rtl"> <code>lgpl-2.1.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - رخصة البرمجيات الحرة. </font></font></li></ul><br><hr><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إطلاق </font></font></h1><br><h2 style=";text-align:right;direction:rtl">  المتطلبات الأساسية </h2><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nintaco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو محاكي NES / Famicom.</font></font></li><li style=";text-align:right;direction:rtl"> <code>Tetris (U) [!].nes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ملف Nintendo Tetris ROM. </font></font></li></ul><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إطلاق البرنامج المساعد </font></font></h2><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم بتشغيل Nintaco وفتح </font></font><code>Tetris (U) [!].nes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مقتطف </font></font><code>TetrisAI.jar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من التنزيل </font></font><code>.zip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">افتح نافذة Run Program باختيار Tools | </font><font style="vertical-align: inherit;">تشغيل البرنامج ...</font></font></li><li style=";text-align:right;direction:rtl">        JAR        Find JAR… . </li><li style=";text-align:right;direction:rtl">  Load JAR,   . </li><li style=";text-align:right;direction:rtl">  Run. </li><li style=";text-align:right;direction:rtl">        ,       <code>GAME TYPE</code>  <code>MUSIC TYPE</code> .   <code>D-pad</code> (     )  <code>A-TYPE</code>   .   Start (Enter),      . </li><li style=";text-align:right;direction:rtl">    <code>A-TYPE</code>  <code>D-pad</code> (  )   <code>LEVEL 9</code> . ,    <code>A</code>    Start (   <code>X</code>   Enter),     19,    . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تجدر الإشارة إلى أن البوت مصمم فقط للمستوى 19 وما فوق. </font><font style="vertical-align: inherit;">في المستويات الدنيا ، لن يتمكن من التحكم في القطع.</font></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مرجع السرعة </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتشغيل اللعبة بشكل أسرع ، حدد Machine | </font><font style="vertical-align: inherit;">السرعة | </font><font style="vertical-align: inherit;">ماكس</font></font><br><br><hr><br><h1 style=";text-align:right;direction:rtl">  التفاصيل </h1><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هضبة </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحت المستوى 10 ، تكون سرعة الهبوط في كل مستوى أعلى قليلاً من المستوى السابق. </font><font style="vertical-align: inherit;">ولكن عند المستوى 10 وما فوق ، هناك العديد من الهضاب التي تظل فيها السرعة ثابتة لعدة مستويات. </font><font style="vertical-align: inherit;">هذا نتيجة الطريقة التي تعمل بها آلية الزناد. </font><font style="vertical-align: inherit;">يتم تقديم السرعة على أنها عدد الإطارات لكل نزول ، وهي قيمة عددية. </font><font style="vertical-align: inherit;">أي ، بالنسبة للمستويات الأعلى ، لا يوجد العديد من الخيارات المتبقية: 10-12 ، 13-15 ، 16-18 ، 19-28 و 29+ هي 5 ، 4 ، 3 ، 2 ، وإطار واحد للنزول.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تم تطوير البوت مع مراعاة هضبة 19-28 فقط. في الإطارات الزوجية ، ينقر على لوحة الألعاب "Left" أو "Right" أو A أو B أو لا شيء. وفي الإطارات الفردية ، يسمح بالنزول التلقائي دون الضغط على أي أزرار. يبدو أن اللعبة لا تدرك الحركة الأفقية التي تتزامن مع الدوران ؛ لذلك ، يتم الضغط على كل زر بشكل مستقل في الإطارات الزوجية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على عكس الأساتذة الذين يلعبون على مستويات عالية ، لا يستفيد البوت من التحول المؤجل (DAS) ، المعروف أيضًا باسم التكرار التلقائي ، والتقنيات ذات الصلة. عمله يذكرنا أكثر </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بتقنية الإبهام الاهتزازية لثور أكيرلوند</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ومع ذلك ، فإنه يزيد من تردد الاهتزاز إلى الحد الأقصى النظري الذي تسمح به اللعبة.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يكافأ اللاعبون بـ 40 و 100 و 300 و 1200 نقطة للفرد والمزدوج والثلاثي وتتريس. </font><font style="vertical-align: inherit;">ويتم ضرب النقاط في رقم المستوى بالإضافة إلى 1. وبعبارة أخرى ، للحصول على أقصى درجة ، يجب على اللاعب أن يسعى للحصول على أقصى عدد من Tetris ، حيث يلعب لأطول فترة ممكنة عند مستويات عالية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المستوى 19 هو أعلى مستوى يمكن اختياره على أنه المستوى الأولي ، والذي يسمح للبوت بالقفز مباشرة إلى الهضبة 19-28. </font><font style="vertical-align: inherit;">ومع ذلك ، نظرًا لوجود خطأ في آلية حساب المستوى التي ذكرتها في الجزء السابق ، ستنتقل اللعبة إلى المستوى 20 بعد مسح 140 صفًا ، بدلاً من 200 صف متوقع. وبعد ذلك ، ستغير اللعبة المستويات كل 10 صفوف. </font><font style="vertical-align: inherit;">ومع ذلك ، بعد الوصول إلى 230 صفًا ، سوف يرتفع البوت من الهضبة ويستسلم بسرعة. </font><font style="vertical-align: inherit;">أي أنه يحتاج إلى طلب أكبر عدد ممكن من Tetris قبل تنظيف 230 صفًا.</font></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أصل ناعم </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن أن يزيد النسب اللين أيضًا عدد النقاط. </font><font style="vertical-align: inherit;">للحصول على نقاط ، يجب خفض الرقم برفق ليغلق على أرض الملعب. </font><font style="vertical-align: inherit;">أي نزول ناعم قصير المدى يحدث على طول الطريق عند وضع الرقم لن يؤثر على النتيجة. </font><font style="vertical-align: inherit;">إذا نجح الهبوط ، سيحصل اللاعب على نقطة واحدة لكل خط يتم تجاوزه أثناء الهبوط الناعم. </font><font style="vertical-align: inherit;">ولا يتم ضرب القيمة الناتجة في رقم المستوى ، حتى إذا أدى الهبوط الناعم إلى مسح الصفوف. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">النسب اللين له تأثير ضئيل على النتيجة الإجمالية. </font><font style="vertical-align: inherit;">ومع ذلك ، إذا كان ذلك ممكنًا ، يكمل البوت وضع الرقم عن طريق النقر على "أسفل" للحصول على هذه النقاط. </font><font style="vertical-align: inherit;">في حالات نادرة ، يمكنه متوسط ​​الفرق بين درجة عالية جدًا وتجاوز الحد الأقصى للدرجة.</font></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> خوارزمية الذكاء الاصطناعي </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند إنشاء شكل ، يستكشف البوت كل موضع ممكن للأشكال الحالية والتالية. الموضع المسموح به هو الوضع الذي يرتكز فيه الشكل إما على الخلايا المشغولة أو على أرضية الملعب. من مكان إنشاء الشكل ، يمكن الوصول إلى هذا الموقف من خلال سلسلة من الحركات الأفقية والانعطافات والنزول. تم العثور على مواقع صالحة وتسلسلات مسار باستخدام BSF. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إن وضع قطعة على أرض الملعب له عواقب: 4 خلايا فارغة مشغولة ، ويتم مسح جميع الصفوف المملوءة ، والسماح للصفوف بالنزول. لكل موضع مسموح به للرقم الحالي والعواقب المرتبطة به ، يقوم البوت بفحص كل موضع صالح للرقم التالي ، وتقييم مجموعة النتائج. يتم تقديم سلسلة البحث هذه </font></font><code>SearchChain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم نقل كل من النتائج المجمعة إلى دالة التقييم التي تحسب محتويات الملعب. </font><font style="vertical-align: inherit;">تركيبة مع أقل درجة تفوز والقطعة الحالية توضع وفقًا لذلك. </font><font style="vertical-align: inherit;">نتائج سلسلة البحث تؤثر فقط على الشكل الحالي. </font><font style="vertical-align: inherit;">عند إنشاء الشكل التالي ، يتم تقييمه مع الشكل الذي يليه ، وهكذا.</font></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> دالة التقييم </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> دالة التقييم هي مجموع مرجح للمعلمات التالية: </font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العدد الإجمالي للصفوف التي تم مسحها</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو عدد الصفوف التي تم مسحها بإضافة كل من tetriminos.</font></font></li><li style=";text-align:right;direction:rtl"> <strong>  </strong> –      ,   .     —   ,        ,       . </li><li style=";text-align:right;direction:rtl"> <strong>  -</strong> –    . </li><li style=";text-align:right;direction:rtl"> <strong>   </strong> –  ,     -. </li><li style=";text-align:right;direction:rtl"> <strong>    </strong> –   ,      .         .     . </li><li style=";text-align:right;direction:rtl"> <strong>     </strong> –      .       ,   1.   ,         ,           . </li><li style=";text-align:right;direction:rtl"> <strong>     </strong> –         ,    .  —        ,    —          . </li><li style=";text-align:right;direction:rtl"> <strong>    </strong> –     .   ,         (20). </li><li style=";text-align:right;direction:rtl"> <strong>    </strong> –     .   ,      0. </li><li style=";text-align:right;direction:rtl"> <strong>    </strong> –   ,     ( )    . </li><li style=";text-align:right;direction:rtl"> <strong>    </strong> :    —   ,     ( )    .         .        .          . </li><li style=";text-align:right;direction:rtl"> <strong>   </strong> –           . ,   1  ,   1,     —  0. </li><li style=";text-align:right;direction:rtl"> <strong> </strong> –   . </li><li style=";text-align:right;direction:rtl"> <strong>  </strong> –         . </li><li style=";text-align:right;direction:rtl"> <strong>   </strong> –      . </li><li style=";text-align:right;direction:rtl"> <strong>    </strong> –     .     . </li><li style=";text-align:right;direction:rtl"> <strong>  </strong> –        . </li></ul><br><h2 style=";text-align:right;direction:rtl">  التعلم الآلي </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للعثور على أوزان دالة التقييم ، استخدمنا متغيرًا لطريقة تحسين سرب الجسيمات (PSO) الموضحة في الحاشية السفلية [1]. للحصول على سلوك التقارب الجيد ، يتم تطبيق معاملات القصور الذاتي والتسارع. ويتم تحديد الأحجام القصوى لخطوات الجسيمات عن طريق تحديد قيم سرعتها. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خلال كل تكرار ، تم تقييم الجسيمات بالتوازي للاستفادة الكاملة من موارد الحوسبة المتاحة. بالإضافة إلى ذلك ، بعد اكتشاف التقارب (لم يحدث تحسن بعد عدد معين من التكرارات) ، تم ضبط PSO على إعادة التشغيل تلقائيًا بأوزان مختارة عشوائيًا ، مما سمح لنا بمزيد من استكشاف مساحة البحث.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تم تقييم كل متجه موقف الجسيمات عن طريق محاكاة الانتهاء من 100 دفعة على هضبة من المستويات 19-28. تتضمن المجموعة الكاملة تنظيف 230 صفًا ، ولكن انتهى العديد منها بتدفق الحقل. تم فرز درجات الدُفعة ، وتم تحديد درجات الجسيمات كمتوسط ​​33 دفعة من أصل 100 دفعة. كانت الفكرة هي الاختيار على أساس العدوانية. تعتاد الجسيمات في الثلث العلوي فقط على التسلسلات المرغوبة من الأرقام ، مما يحد من الحاجة إلى لعبة محافظة. نتيجة لذلك ، يميلون إلى دفع اللعبة المعتادة إلى حافة الهاوية ، في انتظار "العصا" التالية.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تم إنشاء تسلسلات الأنماط لـ 100 مجموعة قبل PSO ، وتم استخدام نفس التسلسلات مرارًا وتكرارًا. كان ذلك ضروريًا لإصلاح مساحة البحث ، بحيث يمكن مقارنة خيارات الحل مع بعضها البعض. تم إنشاء التسلسلات باستخدام منطق PRNG Nintendo Tetris الحقيقي ، والذي تم تصميمه لتقليل فرص التكرار بعد بعضها البعض. لكن PRNG لديها أيضًا نقاط ضعف (انظر قسم "اختيار Tetrimino" من مقال سابق): لا تحدد الأرقام بالتساوي. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أدت المحاولات الأولية إلى أن الروبوتات تعمل بقوة. إذا تغلبوا على الهضبة 19-28 ، فعادة ما يحصلون على الدرجة القصوى. ولكن ، لسوء الحظ ، غالبًا ما أدت في وقت مبكر جدًا إلى تجاوزات الحقل. رداً على ذلك ، تم اتخاذ أربع خطوات "لتهدئة" البوتات:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">    :        Tetris,   .      «»          .          .     ;     230 .  ,      Tetris   .        Single, Double  Triple.          ;        . </li><li style=";text-align:right;direction:rtl">          .      ,   ,      7 .         . </li><li style=";text-align:right;direction:rtl">  ,          ,           .        ,       7 . </li><li style=";text-align:right;direction:rtl">          ,      ,      .       ,       .         ,      . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بعد تطبيق كل هذه القواعد لتهدئة البوتات ، أعطت طريقة PSO الأوزان التالية: </font></font><br><br><table style=";text-align:right;direction:rtl"><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> معلمة </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الوزن </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تم مسح إجمالي عدد الصفوف </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.286127095297893900 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إجمالي ارتفاع الحجب </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.701233676909959200 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> العدد الإجمالي لخلايا البئر </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.711304230768307700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إجمالي عدد الآبار العميقة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.910665415998680400 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> العدد الإجمالي للثقوب في الأعمدة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.879338064244357000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إجمالي ثقوب الأعمدة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.168463848297177000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> العدد الإجمالي لأعماق الثقب في الأعمدة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .260.265587111961757270 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الحد الأدنى لعمق ثقب العمود </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.289886584949610500 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الحد الأقصى لعمق ثقب العمود </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.362361055261181730 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> العدد الإجمالي للتحولات في الأعمدة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −0.028668795795469625 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إجمالي يقفز الخط </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.874179981113233100 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إجمالي ارتفاعات الأعمدة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .500.507409683144361900 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ارتفاع كومة الذاكرة المؤقتة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .12.148676202831281000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مرتفعات العمود مبعثر </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .181.187558540281141700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> العدد الإجمالي للخلايا المشغولة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .62.645656132241128000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إجمالي العدد المرجح للخلايا المشغولة </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.242043416268706620 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عمود مرتفعات التشتت </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.287838126164431440 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بما أن السلسلة تسعى إلى تركيبة تقلل من وظيفة التقييم ، يمكن اعتبار المعلمات التي لها أوزان إيجابية مكافآت ، والباقي - الغرامات. </font><font style="vertical-align: inherit;">لكن الأوزان لا تظهر بالضرورة أهمية المعلمات المقابلة ؛ </font><font style="vertical-align: inherit;">لم يتم تطبيعها ، لذلك لا يمكن مقارنتها.</font></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قوة الذكاء الاصطناعي </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتقييم قوة الذكاء الاصطناعي ، تم جمع ما يقرب من 1.7 مليون نتيجة (بالنقاط) من ألعاب المحاكاة على هضبة من 19 إلى 28. لا تعكس النتيجة اللعبة عند المستوى 29 أو أعلى ، ولا تأخذ في الاعتبار النقاط التي تم الحصول عليها من الأصل الناعم. ومع ذلك ، فإنه يشمل الألعاب التي تم الانتهاء منها قبل الأوان بسبب تجاوزات الملعب. تم استخدام منطق Nintendo Tetris PRNG لإنشاء تسلسلات Tetrimino. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من بين هذه النتائج ، كانت أكبر درجة هي 1،313،600 ، والحد الأدنى هو 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المتوسط ​​هو 816،379 ، ويبدو أنه صغير. ولكن كما هو مذكور أدناه ، فإن البيانات مشوهة ، لذا فإن النتيجة المتوسطة 989200 نقطة تعطي فكرة أفضل عن القيمة النموذجية.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما هو مذكور أعلاه ، قام PSO بتحسين الأوزان بناءً على متوسط ​​أفضل ثلث الدفعات. </font><font style="vertical-align: inherit;">في هذه الحالة ، متوسط ​​الدرجات لأفضل الثلث هو 1 108860. في الواقع ، متوسط ​​الدرجات لأفضل 75٪ هو 1000000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">البوت لديه احتمال 47٪ للوصول إلى حد النقطة إلى المستوى 29. لديه احتمال 61٪ من الحصول على 900000 نقطة ل 29. يوضح الرسم البياني أدناه احتمالات تسجيل حتى المستوى 29.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/082/43a/5a808243a35de546e886bcf6cc8663aa.png" alt="كثافة الاحتمال"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يبدو أن الاحتمال ينخفض ​​خطيًا إلى حوالي 900000 نقطة. </font><font style="vertical-align: inherit;">ثم يذهب إلى منحنى سيني مقلوب. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فيما يلي رسم بياني سلس مع عدد الأطراف لكل نقطة تم تسجيلها. </font><font style="vertical-align: inherit;">يتم تحديد شكله من خلال مشتق الرسم البياني الموضح أعلاه.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/cf4/a7c/7b4cf4a7cfc06203bedef3b81243d20b.png" alt="الرسم البياني"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا تجاهلت التقلبات ، فإن ما يصل إلى حوالي 900.000 يكون مستويًا ، ثم ينتقل إلى التوزيع الطبيعي مع المركز حوالي 1.050.000 نقطة. </font><font style="vertical-align: inherit;">أسباب التقلبات ليست واضحة. </font><font style="vertical-align: inherit;">يبدو أن عدد النقاط يفضل القفز بزيادات قدرها 20000 نقطة. </font><font style="vertical-align: inherit;">ربما يرجع ذلك إلى دورة بناء الكومة والحصول على تتريس.</font></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تخصيص ذاكرة الوصول العشوائي وذاكرة القراءة فقط </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لمعالجة ذاكرة وحدة المعالجة المركزية ، ونقل نقرات الزر وتلقي أحداث عرض الإطار ، يستخدم المكون الإضافي </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">واجهة برمجة تطبيقات Nintaco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">تم اكتشاف جميع عناوين الذاكرة باستخدام أدوات تصحيح Nintaco ، وتمت إضافة المعلومات إلى </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Crystal ROMhacking.net wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">في كود المصدر ، تبدو مثل الثوابت في الواجهة </font></font><code>Addresses</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><hr><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المراجع </font></font></h1><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> van den Bergh, F.; Engelbrecht, AP (2006) <br> A study of particle swarm optimization particle trajectories <br> In: <i>Information Sciences 176 (2006)</i> (pp. 937–971) <br> Retrieved from <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">http://researchspace.csir.co.za/dspace/bitstream/handle/10204/1155/van%20den%20bergh_2006_D.pdf</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar421065/">https://habr.com/ru/post/ar421065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar421055/index.html">تطوير الويب المخصص: كيفية التوسع في مشروع دائم النمو</a></li>
<li><a href="../ar421057/index.html">كيفية تجميع العربات لقطارات الركاب</a></li>
<li><a href="../ar421059/index.html">تسريع المواقع بنصائح مبكرة</a></li>
<li><a href="../ar421061/index.html">PostgreSQL: كيف ولماذا يتضخم WAL</a></li>
<li><a href="../ar421063/index.html">كتب جديدة حول برمجة الأطفال في سكراتش</a></li>
<li><a href="../ar421067/index.html">كيف قمنا بتطوير تطبيق AR لمراجعة الأماكن التاريخية</a></li>
<li><a href="../ar421069/index.html">حقيبة ظهر بوبي أوربان: داخل القلعة</a></li>
<li><a href="../ar421071/index.html">وزارة الدفاع والباقي ليست هي نفسها</a></li>
<li><a href="../ar421073/index.html">الحلقة 1. تكلفة الاختراق</a></li>
<li><a href="../ar421075/index.html">القاموس الرقمي من الألف إلى الياء</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>