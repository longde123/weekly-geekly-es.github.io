<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛺️ 🔕 🗃️ Harga tersembunyi perpustakaan CSS-in-JS di Bereaksi aplikasi 👨🏼‍🏭 👐🏻 👩🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam aplikasi front-end modern, teknologi CSS-in-JS cukup populer. Masalahnya adalah memberi pengembang mekanisme untuk bekerja dengan gaya yang lebi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Harga tersembunyi perpustakaan CSS-in-JS di Bereaksi aplikasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/480358/">  Dalam aplikasi front-end modern, teknologi CSS-in-JS cukup populer.  Masalahnya adalah memberi pengembang mekanisme untuk bekerja dengan gaya yang lebih nyaman daripada CSS biasa.  Jangan salah sangka.  Saya sangat suka CSS, tetapi membuat arsitektur CSS yang baik bukanlah tugas yang mudah.  Teknologi CSS-in-JS menawarkan beberapa <a href="https://gist.github.com/threepointone/731b0c47e78d8350ae4e105c1a83867d">keunggulan</a> signifikan dibandingkan gaya CSS konvensional.  Namun, sayangnya, penggunaan CSS-in-JS dapat, dalam aplikasi tertentu, menyebabkan masalah kinerja.  Pada artikel ini saya akan mencoba untuk menguraikan fitur tingkat tinggi dari perpustakaan CSS-in-JS paling populer, berbicara tentang beberapa masalah yang kadang muncul ketika menggunakannya, dan menyarankan cara untuk mengurangi masalah ini. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/480358/"><img src="https://habrastorage.org/webt/u6/f3/cr/u6f3crp6pcjspyohewwxptq84ve.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tinjauan situasi</font> </h2><br>  Di perusahaan saya, diputuskan untuk membuat perpustakaan UI.  Ini akan membawa kita banyak manfaat, akan memungkinkan kita untuk menggunakan kembali fragmen antarmuka standar dalam berbagai proyek.  Saya adalah salah satu sukarelawan yang menerima tugas itu.  Saya memutuskan untuk menggunakan teknologi CSS-in-JS, karena saya sudah terbiasa dengan styling API dari perpustakaan CSS-in-JS paling populer.  Dalam perjalanan kerja, saya berusaha untuk bertindak secara wajar.  Saya merancang logika yang dapat digunakan kembali dan menerapkan properti bersama dalam komponen.  Karena itu, saya mengambil komposisi komponen.  Sebagai contoh, komponen <code>&lt;IconButton /&gt;</code> memperluas komponen <code>&lt;BaseButton /&gt;</code> , yang, pada gilirannya, merupakan implementasi dari entitas <code>styled.button</code> sederhana.  Sayangnya, ternyata <code>IconButton</code> membutuhkan gaya sendiri, jadi saya mengubah komponen ini menjadi komponen bergaya: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IconButton</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">styled</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">BaseButton</span></span>)`  <span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span>; `;</code> </pre> <br>  Semakin banyak komponen muncul di perpustakaan kami, kami menggunakan semakin banyak operasi komposisi.  Ini sepertinya tidak wajar.  Bagaimanapun, komposisi sebenarnya adalah dasar dari React.  Semuanya baik-baik saja sampai saya membuat komponen <code>Table</code> .  Saya mulai merasa bahwa komponen ini berubah dengan lambat.  Terutama dalam situasi di mana jumlah baris dalam tabel melebihi 50. Ini tidak benar.  Oleh karena itu, saya mulai memahami masalahnya dengan menggunakan alat pengembang. <br><br>  Omong-omong, jika Anda pernah bertanya-tanya mengapa aturan CSS tidak dapat diedit menggunakan inspektur alat pengembang, perlu diketahui bahwa ini karena mereka menggunakan <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule">CSSStyleSheet.insertRule ()</a> .  Ini adalah cara yang sangat cepat untuk memodifikasi style sheet.  Tetapi salah satu kelemahannya adalah kenyataan bahwa style sheet yang sesuai tidak lagi dapat diedit oleh inspektur. <br><br>  Tak perlu dikatakan, pohon yang dihasilkan oleh React sangat besar.  Jumlah komponen <code>Context.Consumer</code> begitu besar sehingga saya bisa tidur.  Faktanya adalah bahwa setiap kali komponen gaya tunggal dirender menggunakan <a href="https://www.styled-components.com/">komponen-gaya</a> atau <a href="https://emotion.sh/">emosi</a> , selain menciptakan komponen Bereaksi reguler, <code>Context.Consumer</code> tambahan. Komponen <code>Context.Consumer</code> juga <code>Context.Consumer</code> .  Ini diperlukan untuk memungkinkan skrip yang sesuai (kebanyakan pustaka CSS-in-JS bergantung pada skrip yang dieksekusi saat halaman sedang berjalan) untuk memproses dengan benar aturan gaya yang dihasilkan.  Biasanya ini tidak menimbulkan masalah khusus, tetapi kita tidak boleh lupa bahwa komponen harus memiliki akses ke topik.  Ini berarti perlunya membuat <code>Context.Consumer</code> tambahan. <code>Context.Consumer</code> untuk setiap elemen bergaya, yang memungkinkan Anda untuk "membaca" tema dari komponen <code>ThemeProvider</code> .  Akibatnya, saat membuat komponen bergaya dalam aplikasi dengan tema, 3 komponen dibuat.  Ini adalah satu komponen <code>StyledXXX</code> dan dua komponen <code>Context.Consumer</code> lainnya. <br><br>  Benar, tidak ada yang mengerikan di sini, karena React melakukan tugasnya dengan cepat, yang berarti bahwa dalam kebanyakan kasus kita tidak perlu khawatir.  Tetapi bagaimana jika beberapa komponen bergaya disusun untuk menciptakan komponen yang lebih kompleks?  Bagaimana jika komponen kompleks ini adalah bagian dari daftar panjang atau tabel besar di mana setidaknya 100 komponen ini diberikan?  Di sini dalam situasi seperti itu, kita dihadapkan dengan masalah ... <br><br><h2>  <font color="#3AC1EF">Pembuatan profil</font> </h2><br>  Untuk menguji berbagai solusi CSS-in-JS, saya membuat aplikasi sederhana.  Ini menampilkan teks <code>Hello World</code> 50 kali.  Dalam versi <a href="https://gist.github.com/3nvi/a47c22872d85d584662e1dbed09dab34">pertama</a> aplikasi ini, saya membungkus teks ini dalam elemen <code>div</code> reguler.  Dalam yang <a href="https://gist.github.com/3nvi/fed37f5286be2575b8203ec37ff00c99">kedua</a> , saya menggunakan komponen <code>styled.div</code> .  Selain itu, saya menambahkan tombol ke aplikasi yang menyebabkan semua 50 elemen ini di-render ulang. <br><br>  Setelah merender komponen <code>&lt;App /&gt;</code> , dua React tree berbeda ditampilkan.  Gambar-gambar berikut menunjukkan elemen pohon yang disimpulkan oleh Bereaksi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b7/4c1/161/5b74c11614f8364a88d3cf204c12c7f3.png"></div><br>  <i><font color="#999999">Pohon ditampilkan dalam aplikasi yang menggunakan elemen div reguler</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/d8b/513/370d8b51371c91ac2c3106c636522711.png"></div><br>  <i><font color="#999999">Sebuah pohon ditampilkan dalam aplikasi yang menggunakan styled.div</font></i> <br><br>  Kemudian, menggunakan tombol, saya membuat <code>&lt;App /&gt;</code> 10 kali untuk mengumpulkan data mengenai beban pada sistem, yang komponen tambahan dari <code>Context.Consumer</code> .  Berikut informasi tentang pembuatan ulang aplikasi berulang kali dengan elemen <code>div</code> reguler dalam mode desain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c25/5ef/c20/c255efc205d63352d9e966a8aefbbff7.png"></div><br>  <i><font color="#999999">Merender ulang aplikasi dengan elemen div reguler dalam mode desain.</font></i>  <i><font color="#999999">Nilai rata-rata adalah 2,54 ms.</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/5b1/14a/ddc5b114a6e93cc4dbd7fe52ddf8aa26.png"></div><br>  <i><font color="#999999">Merender ulang aplikasi dengan elemen styled.div dalam mode pengembangan.</font></i>  <i><font color="#999999">Nilai rata-rata adalah 3,98 ms.</font></i> <br><br>  Yang sangat menarik adalah bahwa, rata-rata, aplikasi CSS-in-JS lebih lambat 56,6% dari biasanya.  Tapi itu adalah mode pengembangan.  Bagaimana dengan mode produksi? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/937/07d/34d/93707d34db954762fda1fb82f41fa4ec.png"></div><br>  <i><font color="#999999">Merender ulang aplikasi dengan elemen div yang biasa dalam mode produksi.</font></i>  <i><font color="#999999">Nilai rata-rata adalah 1,06 ms.</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d66/b66/400/d66b66400375542ed0644cfd7c962e11.png"></div><br>  <i><font color="#999999">Merender ulang aplikasi dengan elemen styled.div dalam mode produksi.</font></i>  <i><font color="#999999">Nilai rata-rata adalah 2,27 ms.</font></i> <br><br>  Ketika mode produksi dihidupkan, implementasi div aplikasi tampaknya lebih dari 50% lebih cepat dibandingkan dengan versi yang sama dalam mode pengembangan.  Aplikasi styled.div hanya 43% lebih cepat.  Dan di sini, seperti sebelumnya, jelas bahwa solusi CSS-in-JS hampir dua kali lebih lambat dari solusi biasa.  Apa yang memperlambatnya? <br><br><h2>  <font color="#3AC1EF">Analisis aplikasi selama pelaksanaannya</font> </h2><br>  Jawaban yang jelas untuk pertanyaan apa yang memperlambat aplikasi CSS-in-JS adalah sebagai berikut: "Dikatakan bahwa seratus perpustakaan CSS-in-JS membuat dua <code>Context.Consumer</code> . <code>Context.Consumer</code> per komponen."  Tetapi jika Anda memikirkan semua ini <code>Context.Consumer</code> , maka <code>Context.Consumer</code> hanyalah mekanisme untuk mengakses variabel JS.  Tentu saja, Bereaksi perlu melakukan beberapa pekerjaan untuk mencari tahu di mana membaca nilai yang sesuai, tetapi ini saja tidak menjelaskan hasil pengukuran di atas.  Jawaban sebenarnya untuk pertanyaan ini dapat ditemukan dengan menganalisis alasan menggunakan <code>Context.Consumer</code> .  Faktanya adalah bahwa sebagian besar pustaka CSS-in-JS mengandalkan skrip yang berjalan selama output halaman di browser, yang membantu pustaka secara dinamis memperbarui gaya komponen.  Perpustakaan ini tidak membuat kelas CSS selama perakitan halaman.  Sebaliknya, mereka secara dinamis menghasilkan dan memperbarui <code>&lt;style&gt;</code> dalam dokumen.  Ini dilakukan ketika komponen dipasang, atau ketika sifat-sifatnya berubah.  Tag ini biasanya berisi kelas CSS tunggal yang nama hashnya dipetakan ke komponen Bereaksi tunggal.  Saat properti komponen ini berubah, tag <code>&lt;style&gt;</code> sesuai juga harus berubah.  Berikut cara menjelaskan apa yang sedang dilakukan selama proses ini: <br><br><ul><li>  Aturan CSS yang harus dimiliki tag <code>&lt;style&gt;</code> dibuat ulang. </li><li>  Nama kelas hash baru dibuat yang digunakan untuk menyimpan aturan CSS yang disebutkan sebelumnya. </li><li>  Properti <code>classname</code> dari komponen Bereaksi yang sesuai diperbarui ke yang baru, menunjukkan kelas yang baru saja dibuat. </li></ul><br>  Pertimbangkan, misalnya, perpustakaan <code>styled-components</code> .  Saat membuat komponen <code>styled.div</code> perpustakaan <a href="">memberikan</a> pengenal internal (ID) ke komponen ini dan menambahkan tag <code>&lt;style&gt;</code> ke tag HTML <code>&lt;head&gt;</code> .  Tag ini berisi satu komentar yang merujuk ke pengenal internal komponen Bereaksi yang menjadi milik gaya yang sesuai: <br><br><pre> <code class="css hljs">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">data-styled-components</span></span>&gt;   <span class="hljs-comment"><span class="hljs-comment">/* sc-component-id: sc-bdVaJa */</span></span> &lt;/<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span>&gt;</code> </pre> <br>  Dan berikut ini adalah tindakan yang dilakukan oleh pustaka komponen-gaya saat menampilkan komponen Bereaksi yang sesuai: <br><br><ol><li>  Parsing aturan CSS dari string template komponen-gaya. </li><li>  <a href="">Menghasilkan</a> nama kelas CSS baru (atau mencari tahu apakah <a href="">akan menyimpan</a> nama sebelumnya). </li><li>  <a href="">Melakukan</a> preprocessing gaya menggunakan stylis. </li><li>  <a href="">Sematkan</a> CSS yang dihasilkan dari preprocessing ke tag <code>&lt;style&gt;</code> sesuai dari tag <code>&lt;head&gt;</code> HTML. </li></ol><br>  Agar dapat menggunakan topik di langkah # 1 dari proses ini, <a href="">Context.Consumer diperlukan</a> .  Berkat komponen ini, nilainya dibaca dari topik di string templat.  Agar dapat memodifikasi tag <code>&lt;style&gt;</code> terkait dengan komponen ini, satu lagi <code>Context.Consumer</code> diperlukan dari komponen.  Ini memungkinkan Anda untuk mengakses instance stylesheet.  Itulah sebabnya di sebagian besar pustaka CSS-in-JS kami menemukan dua contoh <code>Context.Consumer</code> . <br><br>  Selain itu, karena semua perhitungan ini mempengaruhi antarmuka pengguna, harus dicatat bahwa mereka harus dilakukan selama fase rendering komponen.  Mereka tidak dapat dieksekusi dalam kode penangan acara untuk siklus hidup komponen Bereaksi (cara ini eksekusi mereka dapat ditunda dan akan terlihat seperti pembentukan halaman lambat untuk pengguna).  Itu sebabnya rendering aplikasi styled.div lebih lambat daripada rendering aplikasi biasa. <br><br>  Semua ini telah diperhatikan oleh pengembang komponen yang ditata.  Mereka mengoptimalkan perpustakaan untuk mengurangi waktu rendering komponen.  Secara khusus, perpustakaan mengetahui apakah komponen bergaya "statis".  Yaitu, apakah gaya komponen bergantung pada tema atau pada properti yang diteruskan ke sana.  Sebagai contoh, komponen statis ditunjukkan di bawah ini: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">StaticStyledDiv</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">styled</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.div</span></span>`  <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:red</span></span> `;</code> </pre> <br>  Dan komponen ini tidak statis: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DynamicStyledDiv</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">styled</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.div</span></span>`  <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: ${props =&gt; props.color} `;</code> </pre> <br>  Jika pustaka menemukan bahwa komponen itu statis, ia lompati <a href="">4 langkah</a> di atas, menyadari bahwa itu tidak akan pernah harus mengubah nama kelas yang dihasilkan (karena tidak ada elemen dinamis yang mungkin diperlukan untuk mengubah aturan CSS yang terkait dengannya).  Selain itu, dalam situasi ini, pustaka <a href="">tidak menampilkan</a> <code>ThemeContext.Consumer</code> sekitar komponen bergaya, karena ketergantungan tema tidak akan lagi membiarkan komponen dianggap "statis". <br><br>  Jika Anda cukup berhati-hati ketika menganalisis tangkapan layar yang disajikan sebelumnya, maka Anda mungkin memperhatikan bahwa bahkan dalam mode produksi untuk setiap <code>styled.div</code> Dua komponen. Komponen pelanggan <code>Context.Consumer</code> .  Cukup menarik, komponen yang dirender adalah "statis," karena tidak ada aturan CSS dinamis yang dikaitkan dengannya.  Dalam situasi seperti itu, orang akan berharap bahwa jika contoh ini ditulis menggunakan pustaka komponen-gaya, itu tidak akan <code>Context.Consumer</code> perlu bekerja dengan tema.  Alasan mengapa tepat dua <code>Context.Consumer</code> ditampilkan di sini adalah karena percobaan, data yang diberikan di atas, dilakukan dengan menggunakan emosi - perpustakaan CSS-in-JS lainnya.  Pustaka ini mengambil pendekatan yang hampir sama dengan komponen yang ditata.  Perbedaan di antara mereka kecil.  Jadi, perpustakaan emosi mem-parsing string templat, memproses ulang gaya menggunakan <a href="https://stylis.js.org/">stylis,</a> dan memperbarui konten dari <code>&lt;style&gt;</code> sesuai.  Namun, di sini, satu perbedaan utama harus diperhatikan antara komponen yang ditata dan emosi.  Terdiri dari fakta bahwa pustaka emosi <a href="">selalu</a> membungkus semua komponen di <code>ThemeContext.Consumer</code> - terlepas dari apakah mereka menggunakan tema atau tidak (ini menjelaskan tampilan tangkapan layar di atas).  Cukup menarik, meskipun emosi membuat lebih banyak komponen Konsumen daripada komponen yang ditata, emosi <a href="https://medium.com/%40tkh44/emotion-ad1c45c6d28b">mengungguli</a> komponen yang ditata dalam hal kinerja.  Ini menunjukkan bahwa jumlah komponen <code>Context.Consumer</code> bukan faktor utama dalam memperlambat rendering.  Perlu dicatat bahwa pada saat penulisan materi ini, versi beta komponen-gaya v5.xx dirilis, yang, menurut pengembang perpustakaan, <a href="https://medium.com/styled-components/announcing-styled-components-v5-beast-mode-389747abd987">mem-bypass</a> emosi dalam hal kinerja. <br><br>  Ringkaslah apa yang kita bicarakan.  Ternyata kombinasi dari banyak elemen <code>Context.Consumer</code> (yang berarti bahwa React harus mengoordinasikan pekerjaan elemen tambahan) dan mekanisme styling dinamis internal dapat memperlambat aplikasi.  Saya harus mengatakan bahwa semua tag <code>&lt;style&gt;</code> ditambahkan ke <code>&lt;head&gt;</code> untuk setiap komponen tidak pernah dihapus.  Ini disebabkan oleh fakta bahwa operasi penghapusan elemen membuat beban besar pada DOM (misalnya, browser harus mengatur ulang halaman karena hal ini).  Muatan ini lebih tinggi daripada beban tambahan pada sistem yang disebabkan oleh kehadiran pada halaman elemen <code>&lt;style&gt;</code> tidak perlu.  Sejujurnya, saya tidak bisa mengatakan dengan yakin bahwa tag <code>&lt;style&gt;</code> yang tidak perlu dapat menyebabkan masalah kinerja.  Mereka hanya menyimpan kelas yang tidak digunakan yang dihasilkan selama operasi halaman (yaitu, data ini tidak dikirim melalui jaringan).  Tetapi Anda harus tahu tentang fitur ini menggunakan teknologi CSS-in-JS. <br><br>  Saya harus mengatakan bahwa tag <code>&lt;style&gt;</code> tidak membuat semua perpustakaan CSS-in-JS, karena tidak semuanya didasarkan pada mekanisme yang beroperasi selama pengoperasian halaman di browser.  Misalnya, pustaka <a href="https://github.com/callstack/linaria">linaria</a> tidak melakukan apa-apa saat halaman berjalan di browser. <br><br>  Ini mendefinisikan satu set kelas CSS tetap selama proses pembangunan proyek dan menyesuaikan korespondensi semua aturan dinamis dalam string template (yaitu, aturan CSS yang bergantung pada properti komponen) dengan properti CSS kustom.  Akibatnya, ketika properti komponen berubah, properti CSS berubah dan tampilan antarmuka berubah.  Berkat ini, linaria jauh lebih cepat daripada perpustakaan yang mengandalkan mekanisme yang beroperasi saat halaman berjalan.  Masalahnya adalah bahwa ketika menggunakan perpustakaan ini, sistem harus melakukan perhitungan jauh lebih sedikit selama rendering komponen.  Satu-satunya hal yang perlu Anda lakukan ketika menggunakan linaria selama rendering adalah ingat untuk <a href="">memperbarui</a> properti CSS kustom.  Namun, pada saat yang sama, pendekatan ini tidak kompatibel dengan IE11, ia memiliki dukungan terbatas untuk properti CSS populer dan, tanpa konfigurasi tambahan, tidak memungkinkan Anda untuk menggunakan tema.  Seperti halnya dengan bidang pengembangan web lainnya, di antara perpustakaan CSS-in-JS-tidak ada yang ideal, cocok untuk semua kesempatan. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Teknologi CSS-in-JS pada suatu waktu tampak seperti revolusi di bidang penataan.  Itu membuat hidup lebih mudah bagi banyak pengembang, dan juga memungkinkan, tanpa upaya tambahan, untuk memecahkan banyak masalah, seperti tabrakan nama dan penggunaan awalan pabrikan browser.  Artikel ini ditulis untuk menjelaskan pertanyaan tentang seberapa populer perpustakaan CSS-in-JS (yang mengontrol gaya saat halaman berjalan) dapat mempengaruhi kinerja proyek web.  Saya ingin menarik perhatian khusus pada fakta bahwa pengaruh perpustakaan ini pada kinerja tidak selalu mengarah pada munculnya masalah yang nyata.  Bahkan, di sebagian besar aplikasi efek ini sama sekali tidak terlihat.  Masalah dapat terjadi pada aplikasi yang memiliki halaman yang berisi ratusan komponen kompleks. <br><br>  Manfaat CSS-in-JS biasanya lebih besar daripada potensi efek negatif dari penggunaan teknologi ini.  Namun, kelemahan CSS-in-JS harus diingat oleh pengembang yang aplikasinya membuat data dalam jumlah besar, yang proyeknya mengandung banyak elemen antarmuka yang terus berubah.  Jika Anda mencurigai bahwa aplikasi Anda terkena efek negatif CSS-in-JS, maka sebelum melakukan refactoring, ada baiknya semuanya dievaluasi dan diukur dengan baik. <br><br>  Berikut adalah beberapa kiat untuk meningkatkan kinerja aplikasi yang menggunakan pustaka CSS-in-JS populer yang melakukan tugasnya ketika halaman berjalan di browser: <br><br><ol><li>  Jangan terlalu terbawa oleh komposisi komponen bergaya.  Cobalah untuk tidak mengulangi kesalahan yang saya bicarakan di awal, dan jangan mencoba, untuk membuat tombol yang tidak menguntungkan, buatlah komposisi tiga komponen bergaya.  Jika Anda ingin "menggunakan kembali" kode, gunakan properti CSS dan buat string templat.  Ini akan memungkinkan Anda melakukannya tanpa banyak komponen yang tidak perlu dari <code>Context.Consumer</code> .  Akibatnya, React harus mengelola lebih sedikit komponen, yang akan meningkatkan produktivitas proyek. </li><li>  Berusaha keras untuk menggunakan komponen "statis".  Beberapa perpustakaan CSS-in-JS mengoptimalkan kode yang dihasilkan jika gaya komponen tidak bergantung pada tema atau properti.  Semakin "statis" ada dalam string template, semakin tinggi kemungkinan skrip dalam pustaka CSS-in-JS akan berjalan lebih cepat. </li><li>  Cobalah untuk menghindari operasi rendering ulang aplikasi Bereaksi Anda yang tidak perlu.  Berjuang untuk membuat hanya ketika Anda benar-benar membutuhkannya.  Berkat ini, tindakan Bereaksi atau tindakan CSS-in-JS library tidak akan dimuat.  Render ulang adalah operasi yang hanya dapat dilakukan dalam kasus luar biasa.  Misalnya - dengan penarikan simultan sejumlah besar komponen "berat". </li><li>  Cari tahu apakah pustaka CSS-in-JS cocok untuk proyek Anda yang tidak menggunakan skrip yang dijalankan saat halaman berjalan di browser.  Terkadang kami memilih teknologi CSS-in-JS karena lebih nyaman bagi pengembang untuk menggunakannya, dan bukan berbagai JavaScript-API.  Tetapi jika aplikasi Anda tidak membutuhkan dukungan jika tidak menggunakan properti CSS secara intensif, maka mungkin Anda dapat menggunakan pustaka CSS-in-JS seperti linaria yang tidak menggunakan skrip yang berjalan saat halaman sedang berjalan.  Pendekatan ini, di samping itu, akan mengurangi ukuran bundel aplikasi sekitar 12 Kb.  Faktanya adalah bahwa ukuran kode dari kebanyakan perpustakaan CSS-in-JS cocok dalam 12-15 Kb, dan kode linaria yang sama kurang dari 1 Kb. </li></ol><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan perpustakaan CSS-in-JS? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480358/">https://habr.com/ru/post/id480358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480348/index.html">Deep Fake Science, krisis reproduktifitas dan dari mana repositori kosong berasal</a></li>
<li><a href="../id480350/index.html">Intisari materi menarik untuk pengembang ponsel # 326 (pada 9 - 15 Desember)</a></li>
<li><a href="../id480352/index.html">Ahli genetika Harvard mengembangkan prototipe aplikasi kencan DNA analisis</a></li>
<li><a href="../id480354/index.html">Memulai dengan metode array JavaScript .map (), .filter () dan .reduce ()</a></li>
<li><a href="../id480356/index.html">Tips Python Berguna Anda Belum Bertemu</a></li>
<li><a href="../id480362/index.html">Petualangan Jerman menipis uranium hexafluoride di Rusia. Bagian 1. Sejarah dan teknologi pengayaan</a></li>
<li><a href="../id480364/index.html">Metafisika Injeksi Ketergantungan</a></li>
<li><a href="../id480368/index.html">Menangkap kebocoran memori dalam C / C ++</a></li>
<li><a href="../id480370/index.html">Konferensi DEFCON 19. Para bos menyukai Excel, peretas juga</a></li>
<li><a href="../id480374/index.html">Bereaksi Robot 'Mengejar Revolusi di Industri Konstruksi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>