<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💉 💀 👩‍⚕️ Rust 2018 est sorti ... mais qu'est-ce que c'est? ⏫ 👩🏾‍🤝‍👩🏼 🏙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article a été écrit par Lin Clarke en collaboration avec l'équipe de développement de Rust («nous» dans le texte). Vous pouvez également lire l' a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 2018 est sorti ... mais qu'est-ce que c'est?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432564/"> Cet article a été écrit par Lin Clarke en collaboration avec l'équipe de développement de Rust («nous» dans le texte).  Vous pouvez également lire l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur le blog officiel de Rust. <br><br>  La première version de Rust 2018 a été publiée le 6 décembre 2018. Dans cette version, nous nous sommes concentrés sur la productivité afin que les développeurs de Rust commencent à travailler le plus efficacement possible. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6de/ed2/a70/6deed2a70423878dfc8d33f655e7a2b1.png"></a> <br>  <i><font color="gray">La chronologie montre la transition de la version bêta à Rust 2018 et Rust 2015. Elle est entourée d'icônes pour les outils et quatre domaines: WebAssembly, embarqué, réseau et CLI.</font></i>  <i><font color="gray">Le cercle rouge - productivité du développeur - entoure tout sauf Rust 2015</font></i> <br><br>  Mais en général, il n'est pas facile d'expliquer ce qu'est Rust 2018. <br><br>  Certains le présentent comme une nouvelle version du langage ... quelque chose comme ça, mais pas vraiment.  Je dis «pas vraiment», car ici, la «nouvelle version» ne signifie pas les nouvelles versions d'autres langues. <br><a name="habracut"></a><br>  Dans la plupart des autres langues, toutes les nouvelles fonctionnalités ajoutent une nouvelle version.  La version précédente n'est pas mise à jour. <br><br>  Le système Rust fonctionne différemment.  Cela est dû à la façon dont le langage se développe.  Presque toutes les nouvelles fonctionnalités sont 100% compatibles avec Rust.  Ils ne nécessitent aucune modification.  Cela signifie qu'il n'y a aucune raison de les limiter au code Rust 2018. Les versions plus récentes du compilateur continueront de prendre en charge le «mode Rust 2015» par défaut. <br><br>  Mais parfois, le développement d'un langage nécessite de l'innovation, par exemple, une nouvelle syntaxe.  Et cette nouvelle syntaxe peut casser les bases de code existantes. <br><br>  Par exemple, la fonction <code>async/await</code> .  Au départ, il n'y avait pas de tels concepts dans Rust.  Mais il s'est avéré que ces primitives sont vraiment utiles, elles simplifient l'écriture de code asynchrone. <br><br>  Pour cette fonction, les mots clés <code>async</code> et <code>await</code> doivent être ajoutés.  Mais vous devez faire attention à ne pas casser l'ancien code où <code>async</code> ou <code>await</code> pouvaient être utilisés comme noms de variables. <br><br>  Ainsi, nous ajoutons des mots clés dans Rust 2018. Bien que la fonction n'ait pas encore été publiée, les mots clés sont désormais réservés.  Toutes les modifications incompatibles pour les trois prochaines années de développement (par exemple, l'ajout de nouveaux mots clés) sont effectuées simultanément dans Rust 1.31. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e5/668/f56/3e5668f562d297179b8d4068b7c9be9b.png"></a> <br><br>  Bien qu'il y ait des modifications incompatibles dans Rust 2018, cela ne signifie pas que votre code se cassera.  Même avec des variables <code>async</code> et en <code>await</code> , le code sera compilé.  Par défaut, le compilateur fonctionne comme auparavant. <br><br>  Mais si vous souhaitez utiliser l'une des nouvelles fonctions, vous pouvez choisir le nouveau mode de compilation de Rust 2018. La commande <code>cargo fix</code> vous indiquera si vous devez mettre à jour le code pour utiliser les nouvelles fonctions et automatiser le processus de modification.  Ensuite, vous pouvez ajouter <code>edition=2018</code> à votre Cargo.toml si vous acceptez l'utilisation de nouvelles fonctions. <br><br>  Ce spécificateur de version dans Cargo.toml ne s'applique pas à l'ensemble du projet et ne s'applique pas à vos dépendances.  Il est limité à un rack spécifique.  Autrement dit, vous pouvez utiliser les caisses Rust 2015 et Rust 2018 en même temps. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bf/3d5/2ee/1bf3d52ee511feea588c85160bd85cf3.png"></a> <br><br>  Par conséquent, même lorsque vous utilisez Rust 2018, tout ressemble à peu près à Rust 2015. La plupart des modifications sont implémentées simultanément dans Rust 2018 et Rust 2015. Seules quelques fonctions nécessitent des modifications incompatibles. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7fe/b6e/f3e/7feb6ef3ece5c67c5b2aec3810ae6d74.png"></a> <br><br>  Rust 2018 n'est pas seulement des changements dans la langue principale.  Non seulement eux. <br><br>  Rust 2018 est, tout d'abord, une impulsion pour améliorer la productivité des développeurs Rust, principalement grâce à des outils qui sont en dehors du langage, ainsi que par le développement d'applications spécifiques et la compréhension de la façon de faire de Rust le langage de programmation le plus efficace pour ces cas. <br><br>  Ainsi, vous pouvez représenter Rust 2018 en tant que spécificateur dans Cargo.toml, qui est utilisé pour inclure plusieurs fonctions qui nécessitent des modifications incompatibles ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b68/747/e52/b68747e52d57489b7f194e245b40a17a.png"></a> <br><br>  Ou vous pouvez l'imaginer à un moment où Rust devient l'un des langages les plus efficaces pour de nombreuses applications - lorsque vous avez besoin de performances, d'une utilisation efficace des ressources ou d'une grande fiabilité. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ca0/1d3/29c/ca01d329c8350531ee936706fa95828f.png"></a> <br><br>  Nous préférons la deuxième version de la définition.  Examinons donc toutes les améliorations apportées en dehors de la langue, puis plongons-nous dans la langue elle-même. <br><br><h1>  Rouille pour des applications spécifiques </h1><br>  Un langage de programmation ne peut pas être efficace en soi, abstraitement.  Il est efficace dans une application particulière.  Par conséquent, nous avons compris qu'il n'était pas seulement nécessaire d'améliorer Rust en tant que langage ou outil.  Il est également nécessaire de simplifier l'utilisation de la rouille dans certaines zones. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/16f/bde/bbf/16fbdebbf44451fdb8f6c75b78794a2a.png"></a> <br><br>  Dans certains cas, cela signifiait la création d'un tout nouvel ensemble d'outils pour un écosystème complètement nouveau.  Dans d'autres cas, polissage des fonctions existantes et bonne documentation pour faciliter la montée et l'exécution d'un système fonctionnel. <br><br>  L'équipe de développement de Rust a formé des groupes de travail dans quatre domaines: <br><br><ul><li>  Webassembly </li><li>  Applications embarquées </li><li>  Tâches réseau </li><li>  Outils de ligne de commande </li></ul><br><h2>  Webassembly </h2><br>  WebAssembly devait créer un tout nouvel ensemble d'outils. <br><br>  L'année dernière, WebAssembly a permis de compiler des langages tels que Rust pour les exécuter sur Internet.  Depuis lors, Rust est rapidement devenu le meilleur langage pour s'intégrer aux applications Web existantes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22c/92f/083/22c92f0837c668948edbf0dccc193428.png"><br><br>  Rust est bien adapté au développement Web pour deux raisons: <br><br><ol><li>  L'écosystème Cargo Crash fonctionne comme la plupart des développeurs d'applications Web sont habitués.  Combinez un tas de petits modules pour former une application plus grande.  Cela signifie que Rust est facile à utiliser exactement là où vous en avez besoin. </li><li>  La rouille a peu de ressources et ne nécessite aucun temps d'exécution.  Vous n'avez pas besoin de beaucoup de code.  Si vous avez un petit module qui fait beaucoup de travail informatique, implémentez quelques lignes Rust pour l'accélérer. </li></ol><br>  En utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">web-sys et js-sys à</a> partir du code Rust, il est facile d'appeler des API Web comme <code>fetch</code> ou <code>appendChild</code> .  Et <code>wasm-bindgen</code> facilite la prise en charge des types de données de niveau supérieur que WebAssembly ne prend pas en charge de manière native. <br><br>  Après avoir écrit le module Rust WebAssembly, il existe des outils pour le connecter facilement au reste de l'application Web.  Vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wasm-pack</a> pour lancer automatiquement ces outils et exécuter le module dans npm si vous le souhaitez. <br><br>  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre Rust et WebAssembly pour plus d'informations</a> . <br><br><h4>  Et ensuite? </h4><br>  Après la sortie de Rust 2018, les développeurs prévoient de discuter avec la communauté des directions à suivre. <br><br><h2>  Applications embarquées </h2><br>  Pour le développement embarqué, il était nécessaire d'augmenter la stabilité des fonctionnalités existantes. <br><br>  Théoriquement, Rust a toujours été un bon langage pour les applications embarquées.  Il s'agit d'une boîte à outils moderne, qui faisait cruellement défaut aux développeurs, et de fonctions de langage de haut niveau très pratiques.  Tout cela sans charge inutile sur le CPU et la mémoire.  Ainsi, Rust est idéal pour être intégré. <br><br>  Mais en pratique, cela s'est avéré différemment.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">canal stable</a> n'avait pas les fonctions nécessaires.  De plus, pour une utilisation sur des appareils embarqués, il était nécessaire de changer la bibliothèque standard.  Cela signifie que les gens devaient compiler leur propre version de la caisse de base Rust (la caisse qui est utilisée dans chaque application Rust pour fournir les blocs de construction de base de Rust - fonctions intégrées et primitives). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/162/8b8/701/1628b8701eeffba2db1c7abe75f5a018.png"></a> <br><br>  En conséquence, les développeurs dépendaient de la version expérimentale de Rust.  Et en l'absence de tests automatiques, l'assemblage expérimental n'a souvent pas fonctionné sur les microcontrôleurs. <br><br>  Pour résoudre ce problème, les développeurs ont essayé de transférer toutes les fonctions nécessaires sur un canal stable, d'ajouter des tests au système CI pour les microcontrôleurs.  Cela signifie que la modification d'un composant de bureau ne cassera pas la version intégrée. <br><br>  Avec de tels changements, le développement de systèmes embarqués sur Rust passe du domaine des expériences avancées au domaine de l'efficacité normale. <br><br>  Pour plus d'informations, consultez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre Rust for Embedded Systems</a> . <br><br><h4>  Et ensuite? </h4><br>  Cette année, Rust a obtenu un très bon soutien pour la célèbre famille ARM Cortex-M.  Cependant, de nombreuses architectures ne sont pas encore bien prises en charge.  Rust doit être étendu pour fournir un support similaire pour d'autres architectures. <br><br><h2>  Tâches réseau </h2><br>  Pour travailler sur le réseau, il fallait intégrer une abstraction clé dans le langage: <code>async/await</code> .  Ainsi, les développeurs peuvent utiliser des idiomes Rust standard même en code asynchrone. <br><br>  Dans les tâches réseau, vous devez souvent attendre.  Par exemple, une réponse à une demande.  Si le code est synchrone, alors le travail sera arrêté: le cœur du processeur sur lequel le code est exécuté ne peut rien faire jusqu'à ce qu'une requête arrive.  Mais en code asynchrone, une telle fonction peut être mise en veille, tandis que le cœur du CPU fera le reste. <br><br>  La programmation asynchrone est également possible dans Rust 2015, et cela présente de nombreux avantages.  Dans les applications hautes performances, l'application serveur gérera beaucoup plus de connexions à chaque serveur.  Les applications embarquées sur de minuscules CPU monothread optimisent l'utilisation d'un seul thread. <br><br>  Mais ces avantages s'accompagnent d'un inconvénient majeur: pour un tel code, la vérification d'emprunt ne fonctionne pas et vous devez utiliser des idiomes Rust non standard (et légèrement confus).  C'est l'avantage de l' <code>async/await</code> .  Cela donne au compilateur les informations nécessaires pour tester les emprunts d'appels de fonction asynchrones. <br><br>  Les mots clés pour <code>async/await</code> implémentés dans la version 1.31, bien qu'ils ne soient pas actuellement pris en charge par l'implémentation.  La plupart du travail est terminé et la fonctionnalité devrait être disponible dans la prochaine version. <br><br><h4>  Et ensuite? </h4><br>  En plus d'un développement efficace de bas niveau, Rust peut fournir un développement plus efficace d'applications réseau à un niveau supérieur. <br><br>  De nombreux serveurs effectuent des tâches de routine: analyser les URL ou travailler avec HTTP.  Si vous les transformez en composants - des abstractions communes qui sont partagées sous forme de caisses - alors il sera facile de les connecter les uns aux autres, formant toutes sortes de configurations de serveur et de framework. <br><br>  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">framework Tide</a> expérimental <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a été</a> créé pour développer et tester des composants. <br><br><h2>  Outils de ligne de commande </h2><br>  Pour les outils de ligne de commande, il était nécessaire de combiner de petites bibliothèques de bas niveau en abstractions de niveau supérieur et de peaufiner certains outils existants. <br><br>  Pour certains scripts, bash est idéal.  Par exemple, pour simplement appeler d'autres outils shell et passer des données entre eux. <br><br>  Mais la rouille est une excellente option pour de nombreux autres outils.  Par exemple, si vous créez un outil complexe comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ripgrep</a> ou un outil CLI en plus des fonctionnalités d'une bibliothèque existante. <br><br>  Rust ne nécessite pas d'exécution et se compile en un seul binaire statique, ce qui simplifie la distribution du programme.  Et vous obtenez des abstractions de haut niveau qui ne sont pas dans d'autres langages, tels que C et C ++. <br><br>  Quoi d'autre peut améliorer la rouille?  Bien sûr, des abstractions d'un niveau encore plus élevé. <br><br>  Avec des abstractions de niveau supérieur, une CLI prête à l'emploi est rapidement et facilement assemblée. <br><br>  Un exemple d'une telle abstraction est la bibliothèque de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">panique humaine</a> .  En l'absence d'une telle bibliothèque, en cas de panne, le code CLI renverra probablement tout le backtracking.  Mais ce n'est pas très intéressant pour les utilisateurs.  Vous pouvez ajouter une gestion des erreurs personnalisée, mais c'est difficile. <br><br>  Avec la bibliothèque de panique humaine, la sortie ira automatiquement au fichier de vidage d'erreur.  L'utilisateur verra un message informatif proposant de signaler un problème et de télécharger le fichier de vidage. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecb/f4a/908/ecbf4a90823e7b1d83ce1688b5d7383a.png"><br><br>  Commencer à développer des outils CLI est également devenu plus facile.  Par exemple, la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">confy</a> automatise sa configuration.  Il ne demande que deux choses: <br><br><ul><li>  Quel est le nom de l'application? </li><li>  Quels paramètres de configuration souhaitez-vous fournir (que vous définissez comme une structure qui peut être sérialisée et désérialisée)? </li></ul><br>  Confy déterminera tout le reste par lui-même. <br><br><h4>  Et ensuite? </h4><br>  Nous avons résumé de nombreuses tâches pour la CLI.  Mais il y a autre chose à abstraire.  Nous allons publier plus de ces bibliothèques de haut niveau. <br><br><h1>  Outils de rouille </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cf/090/e6e2cf09085886f3c044fcec3ce86ed7.png"><br><br>  Lorsque vous écrivez dans n'importe quelle langue, vous travaillez avec ses outils: en commençant par l'éditeur et en continuant avec d'autres outils à toutes les étapes de développement et de support. <br><br>  Cela signifie qu'un langage efficace dépend d'outils efficaces. <br><br>  Voici quelques nouveaux outils (et améliorations des outils existants) dans Rust 2018. <br><br><h2>  Prise en charge IDE </h2><br>  Bien sûr, les performances dépendent du transfert rapide et fluide du code de l'esprit du développeur vers l'écran de l'ordinateur.  C'est là que le support IDE est crucial.  Pour ce faire, nous avons besoin d'outils qui peuvent «expliquer» l'IDE à la signification du code Rust: par exemple, suggérer des options significatives pour l'auto-complétion des chaînes. <br><br>  Dans Rust 2018, la communauté s'est concentrée sur les fonctionnalités requises par l'IDE.  Avec l'avènement de Rust Language Server et IntelliJ Rust, de nombreux IDE prennent désormais entièrement en charge Rust. <br><br><h2>  Compilation plus rapide </h2><br>  Améliorer les performances du compilateur signifie l'accélérer.  C'est ce que nous avons fait. <br><br>  Auparavant, lorsque vous compiliez la caisse Rust, le compilateur recompilait chaque fichier de la caisse.  La compilation incrémentielle est maintenant implémentée: elle ne compile que les parties qui ont changé.  Avec d'autres optimisations, cela a rendu le compilateur Rust beaucoup plus rapide. <br><br><h2>  rustfmt </h2><br>  L'efficacité exige également que nous ne discutions jamais des règles de formatage du code ou que nous ne corrigions manuellement les styles des autres. <br><br>  L'outil rustfmt aide à cela: il reformatera automatiquement le code selon le style par défaut (par lequel la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communauté est parvenue à un consensus</a> ).  Rustfmt garantit que tout le code Rust correspond au même style, comme le format clang pour C ++ ou Prettier pour JavaScript. <br><br><h2>  Clippy </h2><br>  Parfois, il est agréable d'avoir un consultant expérimenté à proximité donnant des conseils sur les meilleures pratiques pour écrire du code.  C'est ce que fait Clippy: il vérifie le code lors de sa visualisation et suggère des idiomes standard. <br><br><h2>  rustfix </h2><br>  Mais si vous avez une ancienne base de code avec des idiomes obsolètes, alors vérifier et corriger indépendamment le code peut être fatigant.  Vous voulez juste que quelqu'un apporte des corrections à la base de code entière. <br><br>  Dans ces cas, rustfix automatise le processus.  Il applique simultanément les règles d'outils comme Clippy et met à jour l'ancien code conformément aux idiomes de Rust 2018. <br><br><h1>  Modifications apportées à Rust lui-même </h1><br>  Les changements dans l'écosystème ont considérablement augmenté l'efficacité de la programmation.  Mais certains problèmes ne peuvent être résolus que par des changements dans la langue elle-même. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/ec4/993/e54ec49930ed33cb1eac85814f10e7b5.png"><br><br>  Comme nous l'avons dit dans l'introduction, la plupart des changements de langue sont entièrement compatibles avec le code Rust existant.  Tous ces changements font partie de Rust 2018. Mais puisqu'ils ne cassent rien, ils fonctionnent dans n'importe quel code Rust ... même dans l'ancien. <br><br>  Examinons les fonctionnalités importantes qui sont ajoutées à toutes les versions.  Regardez ensuite une courte liste des fonctionnalités de Rust 2018. <br><br><h2>  Nouvelles fonctionnalités pour toutes les versions </h2><br>  Voici un petit exemple des nouvelles fonctionnalités qui sont (ou seront) dans toutes les versions du langage. <br><br><h4>  Vérification d'emprunt plus précise </h4><br>  Un gros avantage de Rust est sa vérification d'emprunt.  Il garantit que le code est sûr pour la mémoire.  Mais c'est aussi une fonctionnalité assez compliquée pour les débutants de Rust. <br><br>  Une partie de la difficulté réside dans l'apprentissage de nouveaux concepts.  Mais il y a une autre partie ... Tester les emprunts rejette parfois du code qui semble fonctionner du point de vue d'un programmeur qui comprend parfaitement le concept de sécurité de la mémoire. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d5c/84e/629/d5c84e629b289c9fa88ef9316a4c59a3.png"></a> <br>  <i><font color="gray">Vous ne pouvez pas emprunter une variable car elle est déjà empruntée</font></i> <br><br>  Cela se produit parce que la durée de vie de l'emprunt était censée s'étendre jusqu'à la fin de son champ - par exemple, jusqu'à la fin de la fonction dans laquelle se trouve la variable. <br><br>  Cela signifie que même si la variable a fini de travailler avec la valeur et n'essaie plus d'accéder, les autres variables se voient toujours refuser l'accès à cette valeur jusqu'à la fin de la fonction. <br><br>  Pour corriger la situation, nous avons rendu le chèque plus intelligent.  Elle voit maintenant quand la variable a fini d'utiliser la valeur.  Après cela, il ne bloque pas l'utilisation des données. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0c/805/0cba0c80529d7132ffea917007f9e08b.png"></a> <br><br>  Bien que cela ne soit disponible que dans Rust 2018, mais dans un proche avenir, la fonction sera ajoutée à toutes les autres versions.  Nous écrirons bientôt plus sur ce sujet. <br><br><h4>  Macros procédurales dans la rouille stable </h4><br>  Rust avait des macros avant Rust 1.0.  Mais dans Rust 2018, de sérieuses améliorations ont été apportées, par exemple, des macros procédurales sont apparues.  Ils vous permettent d'ajouter votre propre syntaxe à Rust. <br><br>  Rust 2018 propose deux types de macros procédurales: <br><br><h4>  Macros de fonction </h4><br>  Les macros de type fonction vous permettent de créer des objets qui ressemblent à des appels de fonction normaux, mais qui sont en fait exécutés au moment de la compilation.  Ils prennent un code et en donnent un autre, que le compilateur insère ensuite dans le binaire. <br><br>  Ils existaient avant, mais avec des limites.  Une macro ne peut exécuter que l'instruction de correspondance.  Il n'a pas eu accès à tous les jetons du code entrant. <br><br>  Mais avec les macros procédurales, vous obtenez la même entrée que l'analyseur: le même flux de jetons.  Cela signifie que vous pouvez créer des macros beaucoup plus puissantes comme des fonctions. <br><br><h4>  Macros de type attribut </h4><br>  Si vous connaissez les décorateurs dans des langages comme JavaScript, les macros d'attributs sont très similaires.  Ils vous permettent d'annoter des fragments de code Rust qui doivent être prétraités et transformés en autre chose. <br><br>  La macro dérivée fait exactement cela.  Lorsque vous le placez sur une structure, le compilateur prend cette structure (après l'avoir analysée en tant que liste de jetons) et la traite.  En particulier, il ajoute une implémentation de base des fonctions du trait. <br><br><h4>  Emprunts plus ergonomiques dans les comparaisons </h4><br>  Il y a un simple changement. <br><br>  Auparavant, si vous vouliez emprunter quelque chose et essayer de faire correspondre, vous deviez ajouter une syntaxe étrange: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/91c/a80/cc5/91ca80cc5221b9bfd18473567eac6d87.png"></a> <br><br>  Maintenant, au lieu de <code>&amp;Some(ref s)</code> nous écrivons simplement <code>Some(s)</code> . <br><br><h1>  Nouvelles fonctionnalités de Rust 2018 </h1><br>  La plus petite partie de Rust 2018 est constituée de fonctionnalités spécifiques à cette version.  Voici un petit ensemble de changements dans Rust 2018. <br><br><h3>  Mots clefs </h3><br>  Rust 2018 a ajouté quelques mots clés: <br><br><ul><li> <code>try</code> </li> <li> <code>async/await</code> </li> </ul><br>  Ces fonctionnalités ne sont pas encore entièrement implémentées, mais des mots clés sont ajoutés dans Rust 1.31.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ainsi, à l'avenir, nous n'aurons pas à introduire de nouveaux mots clés (qui deviendraient un changement incompatible) lorsque nous implémenterons ces fonctions. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Système modulaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une grande douleur pour les débutants de Rust est le système modulaire. </font><font style="vertical-align: inherit;">Et c'est clair pourquoi. </font><font style="vertical-align: inherit;">Il était difficile de comprendre pourquoi Rust choisit un module particulier. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, nous avons apporté quelques modifications au mécanisme de chemin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, si vous avez importé un rack, vous pouvez l'utiliser dans le chemin d'accès au niveau supérieur. </font><font style="vertical-align: inherit;">Mais si vous déplacez un code vers un sous-module, il ne fonctionnera plus.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// top level module extern crate serde; // this works fine at the top level impl serde::Serialize for MyType { ... } mod foo { // but it does *not* work in a sub-module impl serde::Serialize for OtherType { ... } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre exemple est le préfixe </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est utilisé à la fois pour la racine de la caisse et la caisse externe. </font><font style="vertical-align: inherit;">Il est difficile de comprendre ce qui nous attend. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous l'avons rendu plus explicite. </font><font style="vertical-align: inherit;">Maintenant, si vous voulez vous référer à la caisse racine, utilisez le préfixe </font></font><code>crate::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceci n'est qu'une des améliorations pour plus de clarté. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez que le code actuel utilise les capacités de Rust 2018, vous devrez probablement mettre à jour le code pour prendre en compte les nouveaux chemins. </font><font style="vertical-align: inherit;">Mais il n'est pas nécessaire de le faire manuellement. </font><font style="vertical-align: inherit;">Avant d'ajouter le spécificateur de version à Cargo.toml, exécutez-le simplement </font></font><code>cargo fix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>rustfix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apportez les modifications nécessaires.</font></font><br><br><h1>  Information additionnelle </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les informations sur la nouvelle version de la langue sont contenues </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le Guide Rust 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432564/">https://habr.com/ru/post/fr432564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432554/index.html">Douglas Engelbart: Renforcer la société du «QI collectif»</a></li>
<li><a href="../fr432556/index.html">Technologie brevetée Tesla pour le positionnement des véhicules</a></li>
<li><a href="../fr432558/index.html">Modèle architectural «Visitor» dans les univers «iOS» et «Swift»</a></li>
<li><a href="../fr432560/index.html">Typographie sur le web. Conférence Yandex à FrontTalks 2018</a></li>
<li><a href="../fr432562/index.html">Techday Make IT Real - 17 décembre, Moscou</a></li>
<li><a href="../fr432566/index.html">Deux mondes ou «ingénieurs ont quelque chose à dire». Sur les différents types de tâches complexes et les processus qui leur sont associés</a></li>
<li><a href="../fr432568/index.html">«Quand vous êtes le rédacteur en chef de Rusbase»: un nouveau podcast sur l'utilisation du contenu et une carrière dans les médias technologiques</a></li>
<li><a href="../fr432572/index.html">Le transistor métal-air étendra la loi de Moore - comment fonctionne la technologie</a></li>
<li><a href="../fr432574/index.html">Conception sophistiquée d'appareils simples</a></li>
<li><a href="../fr432576/index.html">Sous le capot d'un JobIntentService</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>