<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíâ üíÄ üë©‚Äç‚öïÔ∏è Rust 2018 est sorti ... mais qu'est-ce que c'est? ‚è´ üë©üèæ‚Äçü§ù‚Äçüë©üèº üèôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article a √©t√© √©crit par Lin Clarke en collaboration avec l'√©quipe de d√©veloppement de Rust (¬´nous¬ª dans le texte). Vous pouvez √©galement lire l' a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 2018 est sorti ... mais qu'est-ce que c'est?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432564/"> Cet article a √©t√© √©crit par Lin Clarke en collaboration avec l'√©quipe de d√©veloppement de Rust (¬´nous¬ª dans le texte).  Vous pouvez √©galement lire l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur le blog officiel de Rust. <br><br>  La premi√®re version de Rust 2018 a √©t√© publi√©e le 6 d√©cembre 2018. Dans cette version, nous nous sommes concentr√©s sur la productivit√© afin que les d√©veloppeurs de Rust commencent √† travailler le plus efficacement possible. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6de/ed2/a70/6deed2a70423878dfc8d33f655e7a2b1.png"></a> <br>  <i><font color="gray">La chronologie montre la transition de la version b√™ta √† Rust 2018 et Rust 2015. Elle est entour√©e d'ic√¥nes pour les outils et quatre domaines: WebAssembly, embarqu√©, r√©seau et CLI.</font></i>  <i><font color="gray">Le cercle rouge - productivit√© du d√©veloppeur - entoure tout sauf Rust 2015</font></i> <br><br>  Mais en g√©n√©ral, il n'est pas facile d'expliquer ce qu'est Rust 2018. <br><br>  Certains le pr√©sentent comme une nouvelle version du langage ... quelque chose comme √ßa, mais pas vraiment.  Je dis ¬´pas vraiment¬ª, car ici, la ¬´nouvelle version¬ª ne signifie pas les nouvelles versions d'autres langues. <br><a name="habracut"></a><br>  Dans la plupart des autres langues, toutes les nouvelles fonctionnalit√©s ajoutent une nouvelle version.  La version pr√©c√©dente n'est pas mise √† jour. <br><br>  Le syst√®me Rust fonctionne diff√©remment.  Cela est d√ª √† la fa√ßon dont le langage se d√©veloppe.  Presque toutes les nouvelles fonctionnalit√©s sont 100% compatibles avec Rust.  Ils ne n√©cessitent aucune modification.  Cela signifie qu'il n'y a aucune raison de les limiter au code Rust 2018. Les versions plus r√©centes du compilateur continueront de prendre en charge le ¬´mode Rust 2015¬ª par d√©faut. <br><br>  Mais parfois, le d√©veloppement d'un langage n√©cessite de l'innovation, par exemple, une nouvelle syntaxe.  Et cette nouvelle syntaxe peut casser les bases de code existantes. <br><br>  Par exemple, la fonction <code>async/await</code> .  Au d√©part, il n'y avait pas de tels concepts dans Rust.  Mais il s'est av√©r√© que ces primitives sont vraiment utiles, elles simplifient l'√©criture de code asynchrone. <br><br>  Pour cette fonction, les mots cl√©s <code>async</code> et <code>await</code> doivent √™tre ajout√©s.  Mais vous devez faire attention √† ne pas casser l'ancien code o√π <code>async</code> ou <code>await</code> pouvaient √™tre utilis√©s comme noms de variables. <br><br>  Ainsi, nous ajoutons des mots cl√©s dans Rust 2018. Bien que la fonction n'ait pas encore √©t√© publi√©e, les mots cl√©s sont d√©sormais r√©serv√©s.  Toutes les modifications incompatibles pour les trois prochaines ann√©es de d√©veloppement (par exemple, l'ajout de nouveaux mots cl√©s) sont effectu√©es simultan√©ment dans Rust 1.31. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e5/668/f56/3e5668f562d297179b8d4068b7c9be9b.png"></a> <br><br>  Bien qu'il y ait des modifications incompatibles dans Rust 2018, cela ne signifie pas que votre code se cassera.  M√™me avec des variables <code>async</code> et en <code>await</code> , le code sera compil√©.  Par d√©faut, le compilateur fonctionne comme auparavant. <br><br>  Mais si vous souhaitez utiliser l'une des nouvelles fonctions, vous pouvez choisir le nouveau mode de compilation de Rust 2018. La commande <code>cargo fix</code> vous indiquera si vous devez mettre √† jour le code pour utiliser les nouvelles fonctions et automatiser le processus de modification.  Ensuite, vous pouvez ajouter <code>edition=2018</code> √† votre Cargo.toml si vous acceptez l'utilisation de nouvelles fonctions. <br><br>  Ce sp√©cificateur de version dans Cargo.toml ne s'applique pas √† l'ensemble du projet et ne s'applique pas √† vos d√©pendances.  Il est limit√© √† un rack sp√©cifique.  Autrement dit, vous pouvez utiliser les caisses Rust 2015 et Rust 2018 en m√™me temps. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bf/3d5/2ee/1bf3d52ee511feea588c85160bd85cf3.png"></a> <br><br>  Par cons√©quent, m√™me lorsque vous utilisez Rust 2018, tout ressemble √† peu pr√®s √† Rust 2015. La plupart des modifications sont impl√©ment√©es simultan√©ment dans Rust 2018 et Rust 2015. Seules quelques fonctions n√©cessitent des modifications incompatibles. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7fe/b6e/f3e/7feb6ef3ece5c67c5b2aec3810ae6d74.png"></a> <br><br>  Rust 2018 n'est pas seulement des changements dans la langue principale.  Non seulement eux. <br><br>  Rust 2018 est, tout d'abord, une impulsion pour am√©liorer la productivit√© des d√©veloppeurs Rust, principalement gr√¢ce √† des outils qui sont en dehors du langage, ainsi que par le d√©veloppement d'applications sp√©cifiques et la compr√©hension de la fa√ßon de faire de Rust le langage de programmation le plus efficace pour ces cas. <br><br>  Ainsi, vous pouvez repr√©senter Rust 2018 en tant que sp√©cificateur dans Cargo.toml, qui est utilis√© pour inclure plusieurs fonctions qui n√©cessitent des modifications incompatibles ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b68/747/e52/b68747e52d57489b7f194e245b40a17a.png"></a> <br><br>  Ou vous pouvez l'imaginer √† un moment o√π Rust devient l'un des langages les plus efficaces pour de nombreuses applications - lorsque vous avez besoin de performances, d'une utilisation efficace des ressources ou d'une grande fiabilit√©. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ca0/1d3/29c/ca01d329c8350531ee936706fa95828f.png"></a> <br><br>  Nous pr√©f√©rons la deuxi√®me version de la d√©finition.  Examinons donc toutes les am√©liorations apport√©es en dehors de la langue, puis plongons-nous dans la langue elle-m√™me. <br><br><h1>  Rouille pour des applications sp√©cifiques </h1><br>  Un langage de programmation ne peut pas √™tre efficace en soi, abstraitement.  Il est efficace dans une application particuli√®re.  Par cons√©quent, nous avons compris qu'il n'√©tait pas seulement n√©cessaire d'am√©liorer Rust en tant que langage ou outil.  Il est √©galement n√©cessaire de simplifier l'utilisation de la rouille dans certaines zones. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/16f/bde/bbf/16fbdebbf44451fdb8f6c75b78794a2a.png"></a> <br><br>  Dans certains cas, cela signifiait la cr√©ation d'un tout nouvel ensemble d'outils pour un √©cosyst√®me compl√®tement nouveau.  Dans d'autres cas, polissage des fonctions existantes et bonne documentation pour faciliter la mont√©e et l'ex√©cution d'un syst√®me fonctionnel. <br><br>  L'√©quipe de d√©veloppement de Rust a form√© des groupes de travail dans quatre domaines: <br><br><ul><li>  Webassembly </li><li>  Applications embarqu√©es </li><li>  T√¢ches r√©seau </li><li>  Outils de ligne de commande </li></ul><br><h2>  Webassembly </h2><br>  WebAssembly devait cr√©er un tout nouvel ensemble d'outils. <br><br>  L'ann√©e derni√®re, WebAssembly a permis de compiler des langages tels que Rust pour les ex√©cuter sur Internet.  Depuis lors, Rust est rapidement devenu le meilleur langage pour s'int√©grer aux applications Web existantes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22c/92f/083/22c92f0837c668948edbf0dccc193428.png"><br><br>  Rust est bien adapt√© au d√©veloppement Web pour deux raisons: <br><br><ol><li>  L'√©cosyst√®me Cargo Crash fonctionne comme la plupart des d√©veloppeurs d'applications Web sont habitu√©s.  Combinez un tas de petits modules pour former une application plus grande.  Cela signifie que Rust est facile √† utiliser exactement l√† o√π vous en avez besoin. </li><li>  La rouille a peu de ressources et ne n√©cessite aucun temps d'ex√©cution.  Vous n'avez pas besoin de beaucoup de code.  Si vous avez un petit module qui fait beaucoup de travail informatique, impl√©mentez quelques lignes Rust pour l'acc√©l√©rer. </li></ol><br>  En utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">web-sys et js-sys √†</a> partir du code Rust, il est facile d'appeler des API Web comme <code>fetch</code> ou <code>appendChild</code> .  Et <code>wasm-bindgen</code> facilite la prise en charge des types de donn√©es de niveau sup√©rieur que WebAssembly ne prend pas en charge de mani√®re native. <br><br>  Apr√®s avoir √©crit le module Rust WebAssembly, il existe des outils pour le connecter facilement au reste de l'application Web.  Vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wasm-pack</a> pour lancer automatiquement ces outils et ex√©cuter le module dans npm si vous le souhaitez. <br><br>  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre Rust et WebAssembly pour plus d'informations</a> . <br><br><h4>  Et ensuite? </h4><br>  Apr√®s la sortie de Rust 2018, les d√©veloppeurs pr√©voient de discuter avec la communaut√© des directions √† suivre. <br><br><h2>  Applications embarqu√©es </h2><br>  Pour le d√©veloppement embarqu√©, il √©tait n√©cessaire d'augmenter la stabilit√© des fonctionnalit√©s existantes. <br><br>  Th√©oriquement, Rust a toujours √©t√© un bon langage pour les applications embarqu√©es.  Il s'agit d'une bo√Æte √† outils moderne, qui faisait cruellement d√©faut aux d√©veloppeurs, et de fonctions de langage de haut niveau tr√®s pratiques.  Tout cela sans charge inutile sur le CPU et la m√©moire.  Ainsi, Rust est id√©al pour √™tre int√©gr√©. <br><br>  Mais en pratique, cela s'est av√©r√© diff√©remment.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">canal stable</a> n'avait pas les fonctions n√©cessaires.  De plus, pour une utilisation sur des appareils embarqu√©s, il √©tait n√©cessaire de changer la biblioth√®que standard.  Cela signifie que les gens devaient compiler leur propre version de la caisse de base Rust (la caisse qui est utilis√©e dans chaque application Rust pour fournir les blocs de construction de base de Rust - fonctions int√©gr√©es et primitives). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/162/8b8/701/1628b8701eeffba2db1c7abe75f5a018.png"></a> <br><br>  En cons√©quence, les d√©veloppeurs d√©pendaient de la version exp√©rimentale de Rust.  Et en l'absence de tests automatiques, l'assemblage exp√©rimental n'a souvent pas fonctionn√© sur les microcontr√¥leurs. <br><br>  Pour r√©soudre ce probl√®me, les d√©veloppeurs ont essay√© de transf√©rer toutes les fonctions n√©cessaires sur un canal stable, d'ajouter des tests au syst√®me CI pour les microcontr√¥leurs.  Cela signifie que la modification d'un composant de bureau ne cassera pas la version int√©gr√©e. <br><br>  Avec de tels changements, le d√©veloppement de syst√®mes embarqu√©s sur Rust passe du domaine des exp√©riences avanc√©es au domaine de l'efficacit√© normale. <br><br>  Pour plus d'informations, consultez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre Rust for Embedded Systems</a> . <br><br><h4>  Et ensuite? </h4><br>  Cette ann√©e, Rust a obtenu un tr√®s bon soutien pour la c√©l√®bre famille ARM Cortex-M.  Cependant, de nombreuses architectures ne sont pas encore bien prises en charge.  Rust doit √™tre √©tendu pour fournir un support similaire pour d'autres architectures. <br><br><h2>  T√¢ches r√©seau </h2><br>  Pour travailler sur le r√©seau, il fallait int√©grer une abstraction cl√© dans le langage: <code>async/await</code> .  Ainsi, les d√©veloppeurs peuvent utiliser des idiomes Rust standard m√™me en code asynchrone. <br><br>  Dans les t√¢ches r√©seau, vous devez souvent attendre.  Par exemple, une r√©ponse √† une demande.  Si le code est synchrone, alors le travail sera arr√™t√©: le c≈ìur du processeur sur lequel le code est ex√©cut√© ne peut rien faire jusqu'√† ce qu'une requ√™te arrive.  Mais en code asynchrone, une telle fonction peut √™tre mise en veille, tandis que le c≈ìur du CPU fera le reste. <br><br>  La programmation asynchrone est √©galement possible dans Rust 2015, et cela pr√©sente de nombreux avantages.  Dans les applications hautes performances, l'application serveur g√©rera beaucoup plus de connexions √† chaque serveur.  Les applications embarqu√©es sur de minuscules CPU monothread optimisent l'utilisation d'un seul thread. <br><br>  Mais ces avantages s'accompagnent d'un inconv√©nient majeur: pour un tel code, la v√©rification d'emprunt ne fonctionne pas et vous devez utiliser des idiomes Rust non standard (et l√©g√®rement confus).  C'est l'avantage de l' <code>async/await</code> .  Cela donne au compilateur les informations n√©cessaires pour tester les emprunts d'appels de fonction asynchrones. <br><br>  Les mots cl√©s pour <code>async/await</code> impl√©ment√©s dans la version 1.31, bien qu'ils ne soient pas actuellement pris en charge par l'impl√©mentation.  La plupart du travail est termin√© et la fonctionnalit√© devrait √™tre disponible dans la prochaine version. <br><br><h4>  Et ensuite? </h4><br>  En plus d'un d√©veloppement efficace de bas niveau, Rust peut fournir un d√©veloppement plus efficace d'applications r√©seau √† un niveau sup√©rieur. <br><br>  De nombreux serveurs effectuent des t√¢ches de routine: analyser les URL ou travailler avec HTTP.  Si vous les transformez en composants - des abstractions communes qui sont partag√©es sous forme de caisses - alors il sera facile de les connecter les uns aux autres, formant toutes sortes de configurations de serveur et de framework. <br><br>  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">framework Tide</a> exp√©rimental <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a √©t√©</a> cr√©√© pour d√©velopper et tester des composants. <br><br><h2>  Outils de ligne de commande </h2><br>  Pour les outils de ligne de commande, il √©tait n√©cessaire de combiner de petites biblioth√®ques de bas niveau en abstractions de niveau sup√©rieur et de peaufiner certains outils existants. <br><br>  Pour certains scripts, bash est id√©al.  Par exemple, pour simplement appeler d'autres outils shell et passer des donn√©es entre eux. <br><br>  Mais la rouille est une excellente option pour de nombreux autres outils.  Par exemple, si vous cr√©ez un outil complexe comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ripgrep</a> ou un outil CLI en plus des fonctionnalit√©s d'une biblioth√®que existante. <br><br>  Rust ne n√©cessite pas d'ex√©cution et se compile en un seul binaire statique, ce qui simplifie la distribution du programme.  Et vous obtenez des abstractions de haut niveau qui ne sont pas dans d'autres langages, tels que C et C ++. <br><br>  Quoi d'autre peut am√©liorer la rouille?  Bien s√ªr, des abstractions d'un niveau encore plus √©lev√©. <br><br>  Avec des abstractions de niveau sup√©rieur, une CLI pr√™te √† l'emploi est rapidement et facilement assembl√©e. <br><br>  Un exemple d'une telle abstraction est la biblioth√®que de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">panique humaine</a> .  En l'absence d'une telle biblioth√®que, en cas de panne, le code CLI renverra probablement tout le backtracking.  Mais ce n'est pas tr√®s int√©ressant pour les utilisateurs.  Vous pouvez ajouter une gestion des erreurs personnalis√©e, mais c'est difficile. <br><br>  Avec la biblioth√®que de panique humaine, la sortie ira automatiquement au fichier de vidage d'erreur.  L'utilisateur verra un message informatif proposant de signaler un probl√®me et de t√©l√©charger le fichier de vidage. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecb/f4a/908/ecbf4a90823e7b1d83ce1688b5d7383a.png"><br><br>  Commencer √† d√©velopper des outils CLI est √©galement devenu plus facile.  Par exemple, la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">confy</a> automatise sa configuration.  Il ne demande que deux choses: <br><br><ul><li>  Quel est le nom de l'application? </li><li>  Quels param√®tres de configuration souhaitez-vous fournir (que vous d√©finissez comme une structure qui peut √™tre s√©rialis√©e et d√©s√©rialis√©e)? </li></ul><br>  Confy d√©terminera tout le reste par lui-m√™me. <br><br><h4>  Et ensuite? </h4><br>  Nous avons r√©sum√© de nombreuses t√¢ches pour la CLI.  Mais il y a autre chose √† abstraire.  Nous allons publier plus de ces biblioth√®ques de haut niveau. <br><br><h1>  Outils de rouille </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cf/090/e6e2cf09085886f3c044fcec3ce86ed7.png"><br><br>  Lorsque vous √©crivez dans n'importe quelle langue, vous travaillez avec ses outils: en commen√ßant par l'√©diteur et en continuant avec d'autres outils √† toutes les √©tapes de d√©veloppement et de support. <br><br>  Cela signifie qu'un langage efficace d√©pend d'outils efficaces. <br><br>  Voici quelques nouveaux outils (et am√©liorations des outils existants) dans Rust 2018. <br><br><h2>  Prise en charge IDE </h2><br>  Bien s√ªr, les performances d√©pendent du transfert rapide et fluide du code de l'esprit du d√©veloppeur vers l'√©cran de l'ordinateur.  C'est l√† que le support IDE est crucial.  Pour ce faire, nous avons besoin d'outils qui peuvent ¬´expliquer¬ª l'IDE √† la signification du code Rust: par exemple, sugg√©rer des options significatives pour l'auto-compl√©tion des cha√Ænes. <br><br>  Dans Rust 2018, la communaut√© s'est concentr√©e sur les fonctionnalit√©s requises par l'IDE.  Avec l'av√®nement de Rust Language Server et IntelliJ Rust, de nombreux IDE prennent d√©sormais enti√®rement en charge Rust. <br><br><h2>  Compilation plus rapide </h2><br>  Am√©liorer les performances du compilateur signifie l'acc√©l√©rer.  C'est ce que nous avons fait. <br><br>  Auparavant, lorsque vous compiliez la caisse Rust, le compilateur recompilait chaque fichier de la caisse.  La compilation incr√©mentielle est maintenant impl√©ment√©e: elle ne compile que les parties qui ont chang√©.  Avec d'autres optimisations, cela a rendu le compilateur Rust beaucoup plus rapide. <br><br><h2>  rustfmt </h2><br>  L'efficacit√© exige √©galement que nous ne discutions jamais des r√®gles de formatage du code ou que nous ne corrigions manuellement les styles des autres. <br><br>  L'outil rustfmt aide √† cela: il reformatera automatiquement le code selon le style par d√©faut (par lequel la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communaut√© est parvenue √† un consensus</a> ).  Rustfmt garantit que tout le code Rust correspond au m√™me style, comme le format clang pour C ++ ou Prettier pour JavaScript. <br><br><h2>  Clippy </h2><br>  Parfois, il est agr√©able d'avoir un consultant exp√©riment√© √† proximit√© donnant des conseils sur les meilleures pratiques pour √©crire du code.  C'est ce que fait Clippy: il v√©rifie le code lors de sa visualisation et sugg√®re des idiomes standard. <br><br><h2>  rustfix </h2><br>  Mais si vous avez une ancienne base de code avec des idiomes obsol√®tes, alors v√©rifier et corriger ind√©pendamment le code peut √™tre fatigant.  Vous voulez juste que quelqu'un apporte des corrections √† la base de code enti√®re. <br><br>  Dans ces cas, rustfix automatise le processus.  Il applique simultan√©ment les r√®gles d'outils comme Clippy et met √† jour l'ancien code conform√©ment aux idiomes de Rust 2018. <br><br><h1>  Modifications apport√©es √† Rust lui-m√™me </h1><br>  Les changements dans l'√©cosyst√®me ont consid√©rablement augment√© l'efficacit√© de la programmation.  Mais certains probl√®mes ne peuvent √™tre r√©solus que par des changements dans la langue elle-m√™me. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/ec4/993/e54ec49930ed33cb1eac85814f10e7b5.png"><br><br>  Comme nous l'avons dit dans l'introduction, la plupart des changements de langue sont enti√®rement compatibles avec le code Rust existant.  Tous ces changements font partie de Rust 2018. Mais puisqu'ils ne cassent rien, ils fonctionnent dans n'importe quel code Rust ... m√™me dans l'ancien. <br><br>  Examinons les fonctionnalit√©s importantes qui sont ajout√©es √† toutes les versions.  Regardez ensuite une courte liste des fonctionnalit√©s de Rust 2018. <br><br><h2>  Nouvelles fonctionnalit√©s pour toutes les versions </h2><br>  Voici un petit exemple des nouvelles fonctionnalit√©s qui sont (ou seront) dans toutes les versions du langage. <br><br><h4>  V√©rification d'emprunt plus pr√©cise </h4><br>  Un gros avantage de Rust est sa v√©rification d'emprunt.  Il garantit que le code est s√ªr pour la m√©moire.  Mais c'est aussi une fonctionnalit√© assez compliqu√©e pour les d√©butants de Rust. <br><br>  Une partie de la difficult√© r√©side dans l'apprentissage de nouveaux concepts.  Mais il y a une autre partie ... Tester les emprunts rejette parfois du code qui semble fonctionner du point de vue d'un programmeur qui comprend parfaitement le concept de s√©curit√© de la m√©moire. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d5c/84e/629/d5c84e629b289c9fa88ef9316a4c59a3.png"></a> <br>  <i><font color="gray">Vous ne pouvez pas emprunter une variable car elle est d√©j√† emprunt√©e</font></i> <br><br>  Cela se produit parce que la dur√©e de vie de l'emprunt √©tait cens√©e s'√©tendre jusqu'√† la fin de son champ - par exemple, jusqu'√† la fin de la fonction dans laquelle se trouve la variable. <br><br>  Cela signifie que m√™me si la variable a fini de travailler avec la valeur et n'essaie plus d'acc√©der, les autres variables se voient toujours refuser l'acc√®s √† cette valeur jusqu'√† la fin de la fonction. <br><br>  Pour corriger la situation, nous avons rendu le ch√®que plus intelligent.  Elle voit maintenant quand la variable a fini d'utiliser la valeur.  Apr√®s cela, il ne bloque pas l'utilisation des donn√©es. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0c/805/0cba0c80529d7132ffea917007f9e08b.png"></a> <br><br>  Bien que cela ne soit disponible que dans Rust 2018, mais dans un proche avenir, la fonction sera ajout√©e √† toutes les autres versions.  Nous √©crirons bient√¥t plus sur ce sujet. <br><br><h4>  Macros proc√©durales dans la rouille stable </h4><br>  Rust avait des macros avant Rust 1.0.  Mais dans Rust 2018, de s√©rieuses am√©liorations ont √©t√© apport√©es, par exemple, des macros proc√©durales sont apparues.  Ils vous permettent d'ajouter votre propre syntaxe √† Rust. <br><br>  Rust 2018 propose deux types de macros proc√©durales: <br><br><h4>  Macros de fonction </h4><br>  Les macros de type fonction vous permettent de cr√©er des objets qui ressemblent √† des appels de fonction normaux, mais qui sont en fait ex√©cut√©s au moment de la compilation.  Ils prennent un code et en donnent un autre, que le compilateur ins√®re ensuite dans le binaire. <br><br>  Ils existaient avant, mais avec des limites.  Une macro ne peut ex√©cuter que l'instruction de correspondance.  Il n'a pas eu acc√®s √† tous les jetons du code entrant. <br><br>  Mais avec les macros proc√©durales, vous obtenez la m√™me entr√©e que l'analyseur: le m√™me flux de jetons.  Cela signifie que vous pouvez cr√©er des macros beaucoup plus puissantes comme des fonctions. <br><br><h4>  Macros de type attribut </h4><br>  Si vous connaissez les d√©corateurs dans des langages comme JavaScript, les macros d'attributs sont tr√®s similaires.  Ils vous permettent d'annoter des fragments de code Rust qui doivent √™tre pr√©trait√©s et transform√©s en autre chose. <br><br>  La macro d√©riv√©e fait exactement cela.  Lorsque vous le placez sur une structure, le compilateur prend cette structure (apr√®s l'avoir analys√©e en tant que liste de jetons) et la traite.  En particulier, il ajoute une impl√©mentation de base des fonctions du trait. <br><br><h4>  Emprunts plus ergonomiques dans les comparaisons </h4><br>  Il y a un simple changement. <br><br>  Auparavant, si vous vouliez emprunter quelque chose et essayer de faire correspondre, vous deviez ajouter une syntaxe √©trange: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/91c/a80/cc5/91ca80cc5221b9bfd18473567eac6d87.png"></a> <br><br>  Maintenant, au lieu de <code>&amp;Some(ref s)</code> nous √©crivons simplement <code>Some(s)</code> . <br><br><h1>  Nouvelles fonctionnalit√©s de Rust 2018 </h1><br>  La plus petite partie de Rust 2018 est constitu√©e de fonctionnalit√©s sp√©cifiques √† cette version.  Voici un petit ensemble de changements dans Rust 2018. <br><br><h3>  Mots clefs </h3><br>  Rust 2018 a ajout√© quelques mots cl√©s: <br><br><ul><li> <code>try</code> </li> <li> <code>async/await</code> </li> </ul><br>  Ces fonctionnalit√©s ne sont pas encore enti√®rement impl√©ment√©es, mais des mots cl√©s sont ajout√©s dans Rust 1.31.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ainsi, √† l'avenir, nous n'aurons pas √† introduire de nouveaux mots cl√©s (qui deviendraient un changement incompatible) lorsque nous impl√©menterons ces fonctions. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Syst√®me modulaire </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une grande douleur pour les d√©butants de Rust est le syst√®me modulaire. </font><font style="vertical-align: inherit;">Et c'est clair pourquoi. </font><font style="vertical-align: inherit;">Il √©tait difficile de comprendre pourquoi Rust choisit un module particulier. </font><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, nous avons apport√© quelques modifications au m√©canisme de chemin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, si vous avez import√© un rack, vous pouvez l'utiliser dans le chemin d'acc√®s au niveau sup√©rieur. </font><font style="vertical-align: inherit;">Mais si vous d√©placez un code vers un sous-module, il ne fonctionnera plus.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// top level module extern crate serde; // this works fine at the top level impl serde::Serialize for MyType { ... } mod foo { // but it does *not* work in a sub-module impl serde::Serialize for OtherType { ... } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre exemple est le pr√©fixe </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est utilis√© √† la fois pour la racine de la caisse et la caisse externe. </font><font style="vertical-align: inherit;">Il est difficile de comprendre ce qui nous attend. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous l'avons rendu plus explicite. </font><font style="vertical-align: inherit;">Maintenant, si vous voulez vous r√©f√©rer √† la caisse racine, utilisez le pr√©fixe </font></font><code>crate::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceci n'est qu'une des am√©liorations pour plus de clart√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez que le code actuel utilise les capacit√©s de Rust 2018, vous devrez probablement mettre √† jour le code pour prendre en compte les nouveaux chemins. </font><font style="vertical-align: inherit;">Mais il n'est pas n√©cessaire de le faire manuellement. </font><font style="vertical-align: inherit;">Avant d'ajouter le sp√©cificateur de version √† Cargo.toml, ex√©cutez-le simplement </font></font><code>cargo fix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>rustfix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apportez les modifications n√©cessaires.</font></font><br><br><h1>  Information additionnelle </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les informations sur la nouvelle version de la langue sont contenues </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le Guide Rust 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432564/">https://habr.com/ru/post/fr432564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432554/index.html">Douglas Engelbart: Renforcer la soci√©t√© du ¬´QI collectif¬ª</a></li>
<li><a href="../fr432556/index.html">Technologie brevet√©e Tesla pour le positionnement des v√©hicules</a></li>
<li><a href="../fr432558/index.html">Mod√®le architectural ¬´Visitor¬ª dans les univers ¬´iOS¬ª et ¬´Swift¬ª</a></li>
<li><a href="../fr432560/index.html">Typographie sur le web. Conf√©rence Yandex √† FrontTalks 2018</a></li>
<li><a href="../fr432562/index.html">Techday Make IT Real - 17 d√©cembre, Moscou</a></li>
<li><a href="../fr432566/index.html">Deux mondes ou ¬´ing√©nieurs ont quelque chose √† dire¬ª. Sur les diff√©rents types de t√¢ches complexes et les processus qui leur sont associ√©s</a></li>
<li><a href="../fr432568/index.html">¬´Quand vous √™tes le r√©dacteur en chef de Rusbase¬ª: un nouveau podcast sur l'utilisation du contenu et une carri√®re dans les m√©dias technologiques</a></li>
<li><a href="../fr432572/index.html">Le transistor m√©tal-air √©tendra la loi de Moore - comment fonctionne la technologie</a></li>
<li><a href="../fr432574/index.html">Conception sophistiqu√©e d'appareils simples</a></li>
<li><a href="../fr432576/index.html">Sous le capot d'un JobIntentService</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>