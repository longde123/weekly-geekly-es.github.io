<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤³ ğŸ›€ğŸ¾ ğŸ¤“ Menguji aplikasi Flutter. Mulai ğŸ”¦ ğŸŒ‰ ğŸ’ªğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Flutter diingat ketika perlu untuk membuat aplikasi yang cantik dan responsif dengan cepat untuk beberapa platform sekaligus, tetapi bagaimana menjami...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menguji aplikasi Flutter. Mulai</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/468631/"><p>  Flutter diingat ketika perlu untuk membuat aplikasi yang cantik dan responsif dengan cepat untuk beberapa platform sekaligus, tetapi bagaimana menjamin kualitas kode "cepat"? <br>  Anda akan terkejut, tetapi Flutter memiliki sarana untuk tidak hanya memastikan kualitas kode, tetapi juga untuk menjamin pengoperasian antarmuka visual. <br>  Dalam artikel ini, kita akan memeriksa bagaimana hal-hal dengan tes pada Flutter, kita akan menganalisis tes widget dan pengujian integrasi aplikasi secara keseluruhan. </p><br><p><img src="https://habrastorage.org/webt/nr/vc/tb/nrvctbv08rqv1xge9z2zknv69ym.jpeg"></p><a name="habracut"></a><br><p>  Saya mulai mempelajari Flutter lebih dari setahun yang lalu, sebelum rilis resminya, selama penelitian, tidak ada masalah untuk menemukan informasi pengembangan.  Dan ketika saya ingin mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TDD</a> , ternyata informasi tentang pengujian sangat kecil.  Di Rusia, dan secara umum, hampir tidak ada.  Masalah pengujian harus dipelajari secara independen, sesuai dengan kode sumber tes Flutter dan artikel langka dalam bahasa Inggris.  Semua yang saya pelajari tentang pengujian elemen visual, saya jelaskan dalam sebuah artikel untuk membantu mereka yang baru saja mulai mempelajari topik tersebut. </p><br><h2 id="widget-testing-vidzhet-testy">  Pengujian Widget </h2><br><h3 id="obschie-svedeniya">  Informasi umum </h3><br><p>  Tes widget menguji satu widget.  Ini juga bisa disebut uji komponen.  Tujuan dari tes ini adalah untuk membuktikan bahwa antarmuka pengguna widget terlihat dan berinteraksi sesuai rencana.  Menguji widget membutuhkan lingkungan pengujian yang menyediakan konteks yang sesuai untuk siklus hidup widget. <br>  Widget yang diuji memiliki kemampuan untuk menerima tindakan dan peristiwa pengguna, dan meresponsnya, membangun pohon widget anak.  Oleh karena itu, tes widget lebih kompleks daripada tes unit.  Namun, seperti pengujian unit, lingkungan pengujian widget adalah simulasi sederhana, jauh lebih sederhana daripada sistem antarmuka pengguna lengkap. </p><br><p>  Pengujian widget memungkinkan Anda untuk mengisolasi dan menguji perilaku elemen tunggal dari antarmuka visual.  Dan, yang luar biasa, untuk melakukan semua pemeriksaan di konsol, yang ideal untuk pengujian yang dijalankan sebagai bagian dari proses CI / CD. </p><br><p>  File yang berisi tes biasanya terletak di subdirektori <strong>tes</strong> proyek. <br>  Tes dapat dijalankan baik dari IDE atau dari konsol dengan perintah: </p><br><pre><code class="plaintext hljs">$ flutter test</code> </pre> <br><p>  Dalam hal ini, semua tes dengan mask * <strong>_test.dart</strong> dari subdirektori <strong>tes</strong> akan dieksekusi. <br>  Anda dapat menjalankan tes terpisah dengan menentukan nama file: </p><br><pre> <code class="plaintext hljs">$ flutter test test/phone_screen_test.dart</code> </pre> <br><p>  Tes ini dibuat oleh fungsi <strong>testWidgets</strong> , yang menerima alat sebagai parameter <strong>tester</strong> , dengan mana kode tes berinteraksi dengan widget yang diuji: </p><br><pre> <code class="java hljs">testWidgets(<span class="hljs-string"><span class="hljs-string">' '</span></span>, (WidgetTester tester) async { <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><p>  Untuk menggabungkan tes ke dalam blok logis, fungsi tes dapat digabungkan ke dalam grup, di dalam fungsi <strong>grup</strong> : </p><br><pre> <code class="java hljs">group(<span class="hljs-string"><span class="hljs-string">'  '</span></span>, (){ testWidgets(<span class="hljs-string"><span class="hljs-string">' '</span></span>, (WidgetTester tester) async { <span class="hljs-comment"><span class="hljs-comment">//   }); testWidgets(' ', (WidgetTester tester) async { //   }); });</span></span></code> </pre> <br><p>  Fungsi <strong>setUp</strong> dan <strong>tearDown</strong> memungkinkan Anda untuk mengeksekusi beberapa kode "sebelum" dan "setelah" setiap pengujian.  Dengan demikian, fungsi <strong>setUpAll</strong> dan <strong>tearDownAll</strong> memungkinkan Anda untuk menjalankan kode "sebelum" dan "setelah" semua tes, dan jika fungsi-fungsi ini dipanggil dalam grup, mereka akan dipanggil "sebelum" dan "setelah" pelaksanaan semua tes grup: </p><br><pre> <code class="java hljs">setUp(() { <span class="hljs-comment"><span class="hljs-comment">//    }); tearDown(() { //    });</span></span></code> </pre> <br><h3 id="poisk-vidzhetov">  Pencarian widget </h3><br><p>  Untuk melakukan beberapa tindakan pada widget bersarang, Anda perlu menemukannya di pohon widget.  Untuk melakukan ini, ada objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>pencarian</strong></a> global yang memungkinkan Anda menemukan widget: </p><br><ul><li>  di pohon dengan teks - <strong>find.text</strong> , <strong>find.widgetWithText</strong> ; </li><li>  dengan kunci - <strong>find.byKey</strong> ; </li><li>  dengan ikon - <strong>find.byIcon</strong> , <strong>find.widgetWithIcon</strong> ; </li><li>  berdasarkan tipe - <strong>find.byType</strong> ; </li><li>  oleh posisi di pohon - <strong>find.descendant</strong> dan <strong>find.ancestor</strong> ; </li><li>  menggunakan fungsi yang menganalisis widget pada daftar - <strong>find.byWidgetPredicate</strong> . </li></ul><br><h3 id="vzaimodeystvie-s-testiruemym-vidzhetom">  Uji interaksi widget </h3><br><p>  Kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>WidgetTester</strong></a> menyediakan fungsi untuk membuat widget uji, menunggu keadaannya berubah, dan untuk melakukan beberapa tindakan pada widget ini. <br>  Setiap perubahan pada widget menyebabkan perubahan pada kondisinya.  Tetapi lingkungan pengujian tidak membangun kembali widget secara bersamaan.  Anda harus secara independen menunjukkan ke lingkungan pengujian bahwa Anda ingin membangun kembali widget dengan memanggil fungsi <strong>pump</strong> atau <strong>pumpAndSettle</strong> . </p><br><ul><li>  <strong>pumpWidget</strong> - buat widget tes; </li><li>  <strong>pump</strong> - mulai memproses transisi status widget dan menunggu untuk menyelesaikannya dalam batas waktu yang ditentukan (100 ms secara default); </li><li>  <strong>pumpAndSettle</strong> - memanggil pump dalam siklus untuk mengubah status selama batas waktu yang diberikan (100 ms secara default), ini adalah penantian untuk semua animasi selesai; </li><li>  <strong>ketuk</strong> - kirim klik ke widget; </li><li>  <strong>longPress</strong> - tekan lama; </li><li>  <strong>fling</strong> - swipe / swipe; </li><li>  <strong>seret</strong> - transfer; </li><li>  <strong>enterText</strong> - input teks. </li></ul><br><p>  Tes dapat menerapkan kedua skenario positif, memeriksa peluang yang direncanakan, dan yang negatif untuk memastikan bahwa mereka tidak mengarah pada konsekuensi fatal, misalnya, ketika pengguna mengklik ke arah yang salah dan masuk bukan apa yang diperlukan: </p><br><pre> <code class="java hljs">await tester.enterText(find.byKey(Key(<span class="hljs-string"><span class="hljs-string">'phoneField'</span></span>)), <span class="hljs-string"><span class="hljs-string">'bla-bla-bla'</span></span>);</code> </pre> <br><p>  Setelah melakukan tindakan apa pun dengan widget, Anda perlu memanggil <strong>tester.pumpAndSettle ()</strong> untuk mengubah status. </p><br><h3 id="moki">  Moki </h3><br><p>  Banyak yang akrab dengan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Mockito</strong></a> .  Perpustakaan ini dari dunia Jawa ternyata sangat sukses sehingga ada implementasi perpustakaan ini dalam banyak bahasa pemrograman, termasuk Dart. </p><br><p>  Untuk terhubung, Anda harus menambahkan ketergantungan ke proyek.  Tambahkan baris berikut ke file <strong>pubspec.yaml</strong> : </p><br><pre> <code class="plaintext hljs">dependencies: mockito: any</code> </pre> <br><p>  Dan sambungkan dalam file tes: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:mockito/mockito.dart'</span></span>;</code> </pre> <br><p>  Pustaka ini memungkinkan Anda untuk membuat kelas moque, yang bergantung pada widget yang diuji, sehingga pengujian lebih sederhana dan hanya mencakup kode yang kami uji. <br>  Misalnya, jika kami menguji widget <strong>PhoneInputScreen</strong> , yang, ketika diklik, menggunakan layanan <strong>AuthInteractor</strong> , melakukan permintaan ke <strong>backend</strong> authInteractor.checkAccess <strong>()</strong> , lalu mengganti tiruan alih-alih layanan, kami dapat memeriksa hal yang paling penting - fakta mengakses layanan ini. </p><br><p>  Dependency mobs dibuat sebagai turunan dari kelas <strong>Mock</strong> dan mengimplementasikan antarmuka ketergantungan: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractorMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractor</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Kelas di Dart juga merupakan antarmuka, sehingga tidak perlu mendeklarasikan antarmuka secara terpisah, seperti pada beberapa bahasa pemrograman lainnya. </p><br><p>  Untuk menentukan fungsionalitas mok, fungsi <strong>when</strong> digunakan, yang memungkinkan Anda untuk menentukan respons mok terhadap panggilan ke fungsi tertentu: </p><br><pre> <code class="java hljs">when( authInteractor.checkAccess(any), ).thenAnswer((_) =&gt; Future.value(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre> <br><p>  Moki dapat mengembalikan kesalahan atau data yang salah: </p><br><pre> <code class="java hljs">when( authInteractor.checkAccess(any), ).thenAnswer((_) =&gt; Future.error(UnknownHttpStatusCode(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)));</code> </pre> <br><h3 id="proverki">  Cek </h3><br><p>  Selama pengujian, Anda dapat memeriksa widget di layar.  Ini memungkinkan Anda untuk memastikan bahwa keadaan layar yang baru sudah benar dalam hal visibilitas widget yang diinginkan: </p><br><pre> <code class="java hljs">expect(find.text(<span class="hljs-string"><span class="hljs-string">' '</span></span>), findsOneWidget); expect(find.text(<span class="hljs-string"><span class="hljs-string">'  '</span></span>), findsNothing);</code> </pre> <br><p>  Setelah tes selesai, Anda juga dapat memeriksa metode mana dari kelas mob yang dipanggil selama tes, dan berapa kali.  Ini diperlukan, misalnya, untuk memahami apakah data ini atau itu terlalu sering diminta, apakah ada perubahan yang tidak perlu dalam kondisi aplikasi: </p><br><pre> <code class="java hljs">verify(appComponent.authInteractor).called(<span class="hljs-number"><span class="hljs-number">1</span></span>); verify(authInteractor.checkAccess(any)).called(<span class="hljs-number"><span class="hljs-number">1</span></span>); verifyNever(appComponent.profileInteractor);</code> </pre> <br><h3 id="otladka">  Debugging </h3><br><p>  Tes dilakukan di konsol tanpa grafis.  Anda dapat menjalankan tes dalam mode debug dan mengatur breakpoints dalam kode widget. </p><br><p>  Untuk mendapatkan gambaran tentang apa yang terjadi di pohon widget, Anda dapat menggunakan fungsi <strong>debugDumpApp ()</strong> , yang, ketika dipanggil dalam kode uji, menampilkan representasi tekstual dari hierarki seluruh pohon widget pada waktu tertentu di konsol. </p><br><p>  Untuk memahami bagaimana widget menggunakan moki ada fungsi <strong>logInvocations ()</strong> .  Dibutuhkan sebagai parameter daftar moxas dan masalah ke konsol urutan metode panggilan untuk moxas ini yang dilakukan dalam pengujian. </p><br><p>  Contoh kesimpulan seperti itu di bawah ini.  Tanda <strong>VERIFIED</strong> adalah pada panggilan yang diperiksa dalam pengujian menggunakan fungsi <strong>verifikasi</strong> : </p><br><pre> <code class="plaintext hljs">AppComponentMock.sessionChangedInteractor [VERIFIED] AppComponentMock.authInteractor [VERIFIED] AuthInteractorMock.checkAccess(71111111111)</code> </pre> <br><h3 id="podgotovka">  Persiapan </h3><br><p>  Semua dependensi harus diserahkan ke widget yang diuji dalam bentuk mok: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponentMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractorMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractor</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Pemindahan dependensi ke komponen yang diuji harus dilakukan dengan cara tertentu yang diterima dalam aplikasi Anda.  Untuk kesederhanaan bercerita, pertimbangkan contoh di mana dependensi dilewatkan melalui konstruktor. </p><br><p>  Dalam contoh kode, <strong>PhoneInputScreen</strong> adalah widget uji berdasarkan <strong>StatefulWidget</strong> dibungkus dalam <strong>Scaffold</strong> .  Itu dibuat di lingkungan pengujian menggunakan fungsi <strong>pumpWidget ()</strong> : </p><br><pre> <code class="java hljs">await tester.pumpWidget(PhoneInputScreen(mock));</code> </pre> <br><p>  Namun, widget nyata dapat menggunakan penyelarasan untuk widget bersarang, yang membutuhkan <strong>MediaQuery</strong> di pohon widget, widget mungkin mendapatkan <strong>Navigator.of (konteks)</strong> untuk navigasi, jadi lebih praktis untuk membungkus widget yang sedang diuji di <strong>MaterialApp</strong> atau <strong>CupertinoApp</strong> : </p><br><pre> <code class="java hljs">await tester.pumpWidget( MaterialApp( home: PhoneInputScreen(mock), ), );</code> </pre> <br><p>  Setelah membuat widget tes dan setelah tindakan apa pun, Anda perlu memanggil <strong>tester.pumpAndSettle ()</strong> sehingga lingkungan pengujian <strong>menangani</strong> semua perubahan dalam keadaan widget. </p><br><h2 id="integration-tests-integracionnye-testy">  Tes integrasi </h2><br><h3 id="obschie-svedeniya-1">  Informasi umum </h3><br><p>  Tidak seperti tes widget, tes integrasi memeriksa seluruh aplikasi atau sebagian besar dari itu.  Tujuan dari tes integrasi adalah untuk memastikan bahwa semua widget dan layanan bekerja sama seperti yang diharapkan.  Pengoperasian tes integrasi dapat diamati di simulator atau di layar perangkat.  Metode ini merupakan pengganti yang baik untuk pengujian manual.  Selain itu, tes integrasi dapat digunakan untuk menguji kinerja aplikasi. </p><br><p>  Tes integrasi biasanya dilakukan pada perangkat nyata atau emulator, seperti iOS Simulator atau Android Emulator. </p><br><p>  File yang berisi tes integrasi biasanya terletak di subdirektori <strong>test_driver</strong> proyek. </p><br><p>  Aplikasi diisolasi dari kode driver tes dan mulai setelah itu.  Driver tes memungkinkan Anda untuk mengontrol aplikasi selama pengujian.  Ini terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:flutter_driver/driver_extension.dart'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:app_package_name/main.dart'</span></span> as app; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ enableFlutterDriverExtension(); app.main(); }</code> </pre> <br><p>  Tes dijalankan dari baris perintah.  Jika peluncuran aplikasi target dijelaskan dalam file <strong>app.dart</strong> , dan skrip pengujian disebut <strong>app_test.dart</strong> , maka perintah berikut sudah cukup: </p><br><pre> <code class="plaintext hljs">$ flutter drive --target=test_driver/app.dart</code> </pre> <br><p>  Jika skrip uji memiliki nama yang berbeda, maka Anda harus menentukannya secara eksplisit: </p><br><pre> <code class="plaintext hljs">$ flutter drive --target=test_driver/app.dart --driver=test_driver/home_test.dart</code> </pre> <br><p>  Tes dibuat oleh fungsi <strong>tes</strong> , dan dikelompokkan berdasarkan fungsi <strong>grup</strong> . </p><br><pre> <code class="java hljs">group(<span class="hljs-string"><span class="hljs-string">'park-flutter app'</span></span>, () { <span class="hljs-comment"><span class="hljs-comment">// ,       FlutterDriver driver; //     setUpAll(() async { driver = await FlutterDriver.connect(); }); //     tearDownAll(() async { if (driver != null) { driver.close(); } }); test(' ', () async { //   }); test(' ', () async { //   }); }</span></span></code> </pre> <br><p>  Contoh ini menunjukkan kode untuk membuat driver tes di mana tes berinteraksi dengan aplikasi yang diuji. </p><br><h3 id="vzaimodeystvie-s-testiruemym-prilozheniem">  Interaksi dengan aplikasi yang diuji </h3><br><p>  Alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>FlutterDriver</strong></a> berinteraksi dengan aplikasi pengujian melalui metode berikut: </p><br><ul><li>  <strong>ketuk</strong> - kirim klik ke widget; </li><li>  <strong>waitFor</strong> - tunggu widget muncul di layar; </li><li>  <strong>waitForAbsent</strong> - tunggu widget menghilang; </li><li>  <strong>gulir</strong> dan <strong>gulirIntoView</strong> , <strong>scrollUntilVisible</strong> - gulir layar ke offset yang ditentukan atau ke widget yang diinginkan; </li><li>  <strong>enterText</strong> , <strong>getText</strong> - masukkan teks atau ambil teks widget; </li><li>  <strong>tangkapan layar</strong> - dapatkan tangkapan layar; </li><li>  <strong>requestData</strong> - interaksi yang lebih kompleks melalui pemanggilan fungsi di dalam aplikasi yang sedang diuji. </li></ul><br><p>  Mungkin ada situasi ketika Anda perlu memengaruhi status aplikasi global dari kode tes.  Misalnya, untuk menyederhanakan uji integrasi dengan mengganti bagian dari layanan dalam aplikasi dengan moki.  Dalam aplikasi, Anda dapat menentukan penangan permintaan, yang dapat diakses melalui panggilan ke <strong>driver.requestData ('some param')</strong> dalam kode tes: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String msg)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg == <span class="hljs-string"><span class="hljs-string">"some param"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//       return 'some result'; } } enableFlutterDriverExtension(handler: dataHandler); app.main(); }</span></span></code> </pre> <br><h3 id="poisk-vidzhetov-1">  Pencarian widget </h3><br><p>  Pencarian widget selama pengujian integrasi dengan objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>penemuan</strong></a> global berbeda dalam komposisi metode dari fungsionalitas yang sama dalam pengujian widget.  Namun, makna umum secara praktis tidak berubah: </p><br><ul><li>  di pohon dengan teks - <strong>find.text</strong> , <strong>find.widgetWithText</strong> ; </li><li>  dengan kunci - <strong>find.byValueKey</strong> ; </li><li>  berdasarkan tipe - <strong>find.byType</strong> ; </li><li>  di prompt - <strong>find.byTooltip</strong> ; </li><li>  oleh label semantik - <strong>find.bySemanticsLabel</strong> ; </li><li>  oleh posisi di pohon <strong>find.descendant</strong> dan <strong>find.ancestor</strong> . </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Kami mencari cara untuk mengatur pengujian antarmuka aplikasi yang ditulis menggunakan Flutter.  Kami berdua dapat mengimplementasikan tes untuk memverifikasi bahwa kode memenuhi persyaratan spesifikasi teknis, dan melakukan tes dengan tugas ini.  Dari kekurangan pengujian integrasi yang dicatat - tidak ada cara untuk berinteraksi dengan dialog sistem platform.  Tetapi, misalnya, permintaan izin dapat dihindari dengan mengeluarkan izin dari baris perintah pada tahap instalasi aplikasi, seperti yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiket ini</a> . </p><br><p>  Artikel ini adalah titik awal untuk mengeksplorasi topik pengujian yang secara singkat memperkenalkan pembaca tentang cara kerja pengujian antarmuka pengguna.  Itu tidak menyimpan dokumentasi bacaan, dari mana itu cukup mudah untuk mengetahui bagaimana fungsi kelas atau metode tertentu.  Lagi pula, mempelajari topik baru untuk Anda sendiri membutuhkan, pertama-tama, pemahaman tentang semua proses yang sedang berlangsung secara keseluruhan, tanpa detail yang berlebihan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468631/">https://habr.com/ru/post/id468631/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468621/index.html">Kami menerjemahkan jaringan rumah ke DoH, atau klik lain pada hidung pemfilteran</a></li>
<li><a href="../id468623/index.html">Saya ingin ulasan tentang Habr</a></li>
<li><a href="../id468625/index.html">Tanpa server: 15% lebih lambat dan delapan kali lebih mahal</a></li>
<li><a href="../id468627/index.html">ADAM-6200 I / O Modul</a></li>
<li><a href="../id468629/index.html">Bagaimana saya membuat filter yang tidak merusak gambar bahkan setelah jutaan berjalan - bagian 2</a></li>
<li><a href="../id468635/index.html">Logam Transisi Dichalcogenides: Membuka Kunci Rahasia Pertumbuhan Kristal WS2</a></li>
<li><a href="../id468637/index.html">Cara menangani dataset besar di panda. Kami bekerja dengan database FIAS menggunakan python dan memori 8GB</a></li>
<li><a href="../id468639/index.html">Apa yang baru di konsol web 2019</a></li>
<li><a href="../id468641/index.html">Tutorial Untuk Membuat Solusi Blockchain di Hyperledger Composer</a></li>
<li><a href="../id468645/index.html">Dua halaman sudah cukup untuk membuktikan hipotesis 30 tahun dari bidang ilmu komputer.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>