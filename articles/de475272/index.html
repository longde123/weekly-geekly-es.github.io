<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¨ ‚úãüèø üçø Migration auf asynchrone Infrastruktur in Rust üîÖ üïπÔ∏è üîÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="img source 


 In der vergangenen Woche ereignete sich f√ºr die Rust-Community ein riesiges Ereignis - die Compiler-Version 1.39 wurde ver√∂ffentlicht ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migration auf asynchrone Infrastruktur in Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475272/"><p><img src="https://habrastorage.org/webt/ge/nx/jq/genxjqceshgc6yzx52czs1_9ue8.jpeg" alt="Vogelzug"><br>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">img source</a></em> </p><br><p>  In der vergangenen Woche ereignete sich f√ºr die Rust-Community ein riesiges Ereignis - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Compiler-Version 1.39 wurde ver√∂ffentlicht</a> , und damit verbunden die Stabilisierung von asynchronen Funktionen.  In diesem Beitrag werde ich versuchen, alle relevanten √Ñnderungen im Compiler und im √ñkosystem zusammenzufassen und Anweisungen f√ºr die Migration auf das asynchrone Warte-Paradigma bereitzustellen.  Ich werde keine detaillierte Analyse der Asynchronit√§t in Rust durchf√ºhren, es gibt immer noch relevante Artikel √ºber das Habr√©, die helfen werden, in das Thema einzusteigen: </p><br><ul><li>  chat on mio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">teil 2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tokio + Futures-Rs 0,1</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tokio Bewertung</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generatoren</a> (hier wird eine inakzeptable Version der Syntax mit dem <code>await!</code> -Makro verwendet, sie funktioniert nicht bereits, aber der Hintergrund bleibt derselbe). </li></ul><a name="habracut"></a><br><p>  Zus√§tzlich zu diesen Artikeln k√∂nnen Sie auch auf die Dokumentation der Standardbibliothek und die erforderlichen Kisten verweisen sowie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async-Buch</a> (in Englisch) lesen. </p><br><p>  Alle in diesem Artikel beschriebenen Beispiele funktionieren auf dem Stable-Compiler 1.39 und sollten auf allen nachfolgenden Versionen funktionieren.  Der endg√ºltige Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> verf√ºgbar. </p><br><p>  Zur Implementierung von asynchronem Code wurde die <a href="">Futures-0.1-</a> Bibliothek verwendet.  Es bietet die Basismerkmale <code>futures::Future</code> und <code>futures::Stream</code> f√ºr die Arbeit mit verz√∂gertem Computing.  Sie arbeiten mit <code>Result&lt;..&gt;</code> -Typen und bieten eine Reihe von Kombinatoren.  Dar√ºber hinaus bietet die Bibliothek Kan√§le f√ºr die Kommunikation zwischen Tasks (Tasks), verschiedene Schnittstellen f√ºr die Arbeit mit dem Executor und seinem Task-System und vieles mehr. </p><br><p>  Stellen Sie sich ein Beispiel vor, das eine Zahlenreihe aus den h√∂chsten 32 Bits von Fakult√§ten generiert und diese an <code>Sink</code> sendet: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// futures 0.1.29 use futures::prelude::*; use futures::{stream, futures}; fn sink_fibb_series( sink: impl Sink&lt;SinkItem = u32, SinkError = ()&gt;, ) -&gt; impl Future&lt;Item = (), Error = ()&gt; { stream::unfold((1u32, 1), |(mut fact, n)| { while fact.checked_mul(n).is_none() { fact &gt;&gt;= 1; } fact *= n; Some(future::ok((fact, (fact, n + 1)))) }) .forward(sink) .map(|_v| ()) }</span></span></code> </pre> <br><p>  Hinweis: Die Ber√ºcksichtigung von CPU-gebundenen Aufgaben auf Coroutinen ist nicht die beste Anwendung, das Beispiel ist jedoch autark und einfach. </p><br><p>  Wie Sie sehen, sieht der Code ziemlich umst√§ndlich aus: Sie m√ºssen den R√ºckgabewert angeben, obwohl er keinen n√ºtzlichen Wert enth√§lt.  In Futures 0.3 wird der Code etwas einfacher: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// futures 0.3.1 use futures::prelude::*; use futures::stream; async fn sink_fibb_series(sink: impl Sink&lt;u32&gt;) { stream::unfold((1u32, 1), |(mut fact, n)| { async move { while fact.checked_mul(n).is_none() { fact &gt;&gt;= 1; } fact *= n; Some((fact, (fact, n + 1))) } }) .map(Ok) .forward(sink) .map(|_v| ()) .await; }</span></span></code> </pre> <br><p>  Hier wird der Funktion das Schl√ºsselwort <code>async</code> hinzugef√ºgt, das den R√ºckgabewert der Funktion in <code>Future</code> .  Da es sich in unserem Fall um ein Tupel der Gr√∂√üe Null handelt, kann es wie bei gew√∂hnlichen Funktionen einfach weggelassen werden. </p><br><p>  Das Schl√ºsselwort <code>await</code> wird am Ende der Aufrufkette verwendet, um auf die Ausf√ºhrung zu warten.  Dieser Aufruf unterbricht die Ausf√ºhrung im aktuellen asynchronen Kontext und √ºbertr√§gt die Steuerung an den Scheduler, bis der erwartete <code>Future</code> Wert bereit ist.  Dann wird die Ausf√ºhrung mit der letzten <code>await</code> (Beenden der Funktion in unserem Beispiel), d.h.  Der Steuerfluss wird im Vergleich zu einem √§hnlichen Synchroncode nichtlinear. </p><br><p>  Ein weiterer signifikanter Unterschied ist das Vorhandensein eines asynchronen Blocks im K√∂rper des Verschlusses innerhalb von <code>stream::unfold</code> .  Dieser Wrapper ist eine komplette Entsprechung zum Deklarieren einer neuen Async-Funktion mit demselben Body und zum Aufrufen anstelle eines Async-Blocks. </p><br><div class="spoiler">  <b class="spoiler_title"># [feature (async_closure)</b> <div class="spoiler_text"><p>  Vielleicht kann dieser Abschluss bald mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>async_closure</code></a> geschrieben werden, aber leider wurde er noch nicht implementiert: </p><br><pre> <code class="rust hljs">async |(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> fact, n)| { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> fact.checked_mul(n).is_none() { fact &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } fact *= n; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>((fact, (fact, n + <span class="hljs-number"><span class="hljs-number">1</span></span>))) }</code> </pre> </div></div><br><p>  Wie Sie sehen, funktioniert der neue <code>Stream</code> Typ nicht nur mit Elementen des <code>Result&lt;..&gt;</code> wie zuvor.  √Ñhnliche √Ñnderungen wurden am <code>Future</code> Merkmal vorgenommen. Die Versionsdefinitionen lauten wie folgt: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// futures 0.1 trait Future { type Item; type Error; fn poll(&amp;mut self) -&gt; Result&lt;Async&lt;Self::Item&gt;, Self::Error&gt;; } enum Async&lt;T&gt; { Ready(T), NotReady } // futures 0.3 trait Future { type Output; fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;; } enum Poll&lt;T&gt; { Ready(T), Pending }</span></span></code> </pre> <br><p>  Neben der Tatsache, dass der R√ºckgabetyp beliebig sein kann, haben sich auch die Eingabeparameter f√ºr <code>Future::poll</code> ge√§ndert.  Es wurde ein neuer <code>Context</code> Parameter angezeigt, der eine explizite Schnittstelle zum Aufwecken der aktuellen Aufgabe bietet.  Zuvor konnte dasselbe durch globale Variablen eines bestimmten Executors erreicht werden (z. B. durch Aufrufen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>tokio::prelude::task::current().notify()</code></a> ). </p><br><p>  Der grundlegendere Unterschied zwischen der Schnittstelle besteht darin, dass Sie den Link in <code>Pin</code> .  Dieser Wrapper √ºber dem Zeiger garantiert die "Unbeweglichkeit" der Daten im Speicher (eine detailliertere Beschreibung von <code>Pin</code> in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 1.33 des Compilers</a> auf dem Hub oder in englischer Sprache in der Dokumentation der Standardbibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: pin</a> ). </p><br><p>  Lassen Sie uns versuchen, unser Beispiel jetzt auszuf√ºhren.  Als <code>Sink</code> nehmen wir die H√§lfte des Kanals von Futures und geben das Ergebnis ausgangsseitig mit einer gewissen Verz√∂gerung zwischen den Iterationen aus.  Auf Futures-0.1 kann ein solcher Code wie folgt geschrieben werden: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::time::{Duration, Instant}; <span class="hljs-comment"><span class="hljs-comment">// futures 0.1.29 use futures::prelude::*; use futures::sync::mpsc; // tokio 0.1.22 use tokio::runtime::Runtime; use tokio::timer::Delay; fn main() { let mut rt = Runtime::new().unwrap(); let (tx, rx) = mpsc::channel(32); rt.spawn(Box::new(sink_fibb_series(tx.sink_map_err(|_e| ())))); let fut = rx.take(100).for_each(|val| { println!("{}", val); Delay::new(Instant::now() + Duration::from_millis(50)) .map(|_| ()) .map_err(|_| ()) }); rt.spawn(Box::new(fut)); rt.shutdown_on_idle().wait().unwrap(); }</span></span></code> </pre> <br><p>  Ein √§hnlicher Code mit dem neuen Tokio (das zum Zeitpunkt des Schreibens noch Alpha ist) und Futures-0.3 k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::time::Duration; <span class="hljs-comment"><span class="hljs-comment">// futures 0.3.1 use futures::channel::mpsc; use futures::prelude::*; // tokio 0.2.0-alpha.5 use tokio::timer; #[tokio::main] async fn main() { let (tx, rx) = mpsc::channel(32); tokio::spawn(sink_fibb_series(tx)); rx.take(100) .for_each(|val| { println!("{}", val); timer::delay_for(Duration::from_millis(50)) }) .await; }</span></span></code> </pre> <br><p>  Wie Sie sehen, ist der Code mit den neuen Futures viel k√ºrzer geworden.  Nach den Erfahrungen des Autors wird die Anzahl der Zeilen immer deutlich verringert (manchmal sogar beim Umschreiben von synchronem Code).  Aber es scheint mir, dass es einen viel bedeutenderen Unterschied in der Lesbarkeit und das Fehlen einer Mischung aus <code>map</code> / <code>map_err</code> , die aufgrund der Variabilit√§t von Fehlern in Standardtypen in <code>Result&lt;..&gt;</code> erforderlich waren. </p><br><p>  Kombinatoren √ºber Elemente des Typs <code>Result&lt;..&gt;</code> blieben jedoch erhalten und sind separate Typen, einige mit einem leicht aktualisierten Namen.  Jetzt werden sie in zwei verschiedene Typen unterteilt;  diejenigen, die implementiert sind f√ºr: </p><br><ul><li>  alle Elemente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>futures::FuturesExt</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>futures::StreamExt</code></a> ; </li><li>  Elemente vom Typ <code>Result&lt;..&gt;</code> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>futures::TryFuturesExt</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>futures::TryStreamExt</code></a> . </li></ul><br><p>  Die Implementierung der <code>Future</code> und <code>Stream</code> Merkmale ist etwas komplizierter.  Versuchen wir als Beispiel, <code>Stream</code> f√ºr eine bereits betrachtete Zahlenreihe zu implementieren.  Der gemeinsame Typ f√ºr beide Versionen von Futures lautet wie folgt: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactStream</span></span></span></span> { fact: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> FactStream { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { fact: <span class="hljs-number"><span class="hljs-number">1</span></span>, n: <span class="hljs-number"><span class="hljs-number">1</span></span> } } }</code> </pre> <br><p>  F√ºr Futures-0.1 sieht die Implementierung wie folgt aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Stream <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> FactStream { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span></span> = (); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Poll&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;, Self::Error&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fact.checked_mul(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.n).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fact &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fact *= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.n; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.n += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Async::Ready(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fact))) } }</code> </pre> <br><p>  In diesem Beispiel ist die Implementierung von <code>Stream::poll</code> eine vollst√§ndige Kopie von <code>stream::unfold</code> .  Im Falle von Futures-0.3 ist die Implementierung √§quivalent: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Stream <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> FactStream { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll_next</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>: Pin&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;, _cx: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Context&lt;<span class="hljs-symbol"><span class="hljs-symbol">'_</span></span>&gt;) -&gt; Poll&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fact.checked_mul(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.n).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fact &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fact *= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.n; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.n += <span class="hljs-number"><span class="hljs-number">1</span></span>; Poll::Ready(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fact)) } }</code> </pre> <br><p>  Wenn der Typ eines Strukturfelds jedoch <code>Unpin</code> nicht implementiert, wird <code>std::ops::DerefMut</code> nicht auf <code>Pin&lt;&amp;mut T&gt;</code> implementiert, und daher gibt es keinen ver√§nderlichen Zugriff auf alle Felder: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::marker::PhantomPinned; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fact</span></span></span></span> { inner: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    Unpin   _pin: PhantomPinned, } struct FactStream { fact: Fact, n: u32, } impl Stream for FactStream { type Item = u32; fn poll_next(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt; { while self.fact.inner.checked_mul(self.n).is_none() { self.fact.inner &gt;&gt;= 1; // &lt;-   // trait `DerefMut` is required to modify // through a dereference, but it is not // implemented for `std::pin::Pin&lt;&amp;mut FactStream&gt;` } self.fact.inner *= self.n; // &lt;-   self.n += 1; // &lt;- Poll::Ready(Some(self.fact.inner)) } }</span></span></code> </pre> <br><p>  In diesem Fall m√ºssen Sie in der einen oder anderen Form die unsicheren Funktionen <code>Pin::get_unchecked_mut</code> und <code>Pin::map_unchecked_mut</code> verwenden, um eine "Projektion" zu erhalten <code>!Unpin</code>  Gl√ºcklicherweise ist f√ºr solche F√§lle ein sicherer Wrapper in der pin_project-Kiste implementiert (Details zur Implementierung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Bibliotheksdokumentation</a> ). </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> pin_project::pin_project; <span class="hljs-meta"><span class="hljs-meta">#[pin_project]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactStream</span></span></span></span> { fact: Fact, n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Stream <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> FactStream { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll_next</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>: Pin&lt;&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;, _cx: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Context&lt;<span class="hljs-symbol"><span class="hljs-symbol">'_</span></span>&gt;) -&gt; Poll&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> this = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.project(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> this.fact.inner.checked_mul(*this.n).is_none() { this.fact.inner &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } this.fact.inner *= *this.n; *this.n += <span class="hljs-number"><span class="hljs-number">1</span></span>; Poll::Ready(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(this.fact.inner)) } }</code> </pre> <br><p>  Der letzte Punkt, den ich hervorheben m√∂chte, ist die Interstabilit√§t zwischen den Typen verschiedener Versionen.  Dazu gibt es ein Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">futures :: compat</a> , mit dem Sie von alten auf neue Typen konvertieren k√∂nnen und umgekehrt.  Beispielsweise k√∂nnen Sie mit async-await √ºber <code>Stream</code> von Futures-0.1 iterieren: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fmt::Display; <span class="hljs-comment"><span class="hljs-comment">// futures 0.3 use new_futures::compat::Compat01As03 as Compat; use new_futures::StreamExt as _; // futures 0.1 use old_futures::Stream as OldStream; async fn stream_iterate&lt;E&gt;( old_stream: impl OldStream&lt;Item = impl Display, Error = E&gt;, ) -&gt; Result&lt;(), E&gt; { let stream = Compat::new(old_stream); let mut stream = Box::pin(stream); while let Some(item) = stream.as_mut().next().await.transpose()? { println!("{}", item); } Ok(()) }</span></span></code> </pre> <br><p>  Hinweis: Nur tokio executor wird im Artikel als am langlebigsten und am weitesten verbreitet angesehen.  Dennoch endet die Welt nicht dort, zum Beispiel gibt es eine alternative <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>ThreadPool</code></a> Standardbibliothek, die zus√§tzlich futuristische Wrapper f√ºr Typen der Standardbibliothek sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>ThreadPool</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>LocalPool</code></a> aus der betrachteten Futures-0.3-Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>LocalPool</code></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475272/">https://habr.com/ru/post/de475272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475260/index.html">Der Unterschied zwischen einer asynchronen Funktion und einer Funktion, die ein Versprechen zur√ºckgibt</a></li>
<li><a href="../de475262/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 388 (4. - 10. November 2019)</a></li>
<li><a href="../de475264/index.html">Schn√ºffler, die es k√∂nnten: Wie die FakeSecurity-Familie Online-Shops infizierte</a></li>
<li><a href="../de475266/index.html">Wir kehren mobile 1s unter Android um. So f√ºgen Sie ein wenig Funktionalit√§t hinzu und lassen ein paar Abende aus</a></li>
<li><a href="../de475270/index.html">SwiftUI: Erweiterbare / reduzierbare Abschnitte in der Listenansicht erstellen</a></li>
<li><a href="../de475276/index.html">Wie schreibe ich richtig behaupten</a></li>
<li><a href="../de475278/index.html">Wie man einen Hacker anschaut, w√§hrend ein Hacker einen anschaut</a></li>
<li><a href="../de475280/index.html">Cisco Passw√∂rter, DNS Zonen Migration, keine LDAP Anfragen, wir sammeln Ethernet Pakete. Probleme in einem Netzwerk mit r0ot-mi l√∂sen. Teil 2</a></li>
<li><a href="../de475284/index.html">Ein-Minuten-Manager und Affen, Kompendium</a></li>
<li><a href="../de475286/index.html">Kraft-W√§rme-Kopplung: eine Alternative zur zentralen Energieversorgung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>