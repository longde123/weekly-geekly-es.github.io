<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ä ‚òïÔ∏è ü§® Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 7: Sandbox de Native Client Parte 2 üçô üçô üëî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnolog√≠a de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas inform√°ticos". Nikolai Zeldovich, James Mickens. A√±o 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 7: Sandbox de Native Client Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418225/"><h3>  Instituto de Tecnolog√≠a de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas inform√°ticos".  Nikolai Zeldovich, James Mickens.  A√±o 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementaci√≥n de sistemas inform√°ticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y t√©cnicas de seguridad basadas en trabajos cient√≠ficos recientes.  Los temas incluyen seguridad del sistema operativo (SO), caracter√≠sticas, gesti√≥n del flujo de informaci√≥n, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lecci√≥n 1: "Introducci√≥n: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 3: ‚ÄúDesbordamientos del b√∫fer: exploits y protecci√≥n‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 4: ‚ÄúSeparaci√≥n de privilegios‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 5: ‚Äú¬øDe d√≥nde vienen los sistemas de seguridad?‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> <br>  Lecci√≥n 6: ‚ÄúOportunidades‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 7: ‚ÄúSandbox de cliente nativo‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  <b>Audiencia:</b> ¬øpor qu√© el rango de capacidad de memoria del rango de direcciones debe comenzar desde cero? <br><br>  <b>Profesor:</b> porque en t√©rminos de rendimiento, es m√°s eficiente usar el salto de destino si sabe que una direcci√≥n v√°lida es un conjunto continuo de direcciones que comienzan desde cero.  Porque entonces puede hacerlo con una sola m√°scara <b>AND</b> , donde todos los bits altos son uno y solo un par de bits bajos es cero. <br><br>  <b>P√∫blico:</b> pens√© que se supon√≠a que la m√°scara <b>AND</b> deb√≠a proporcionar alineaci√≥n. <br><br>  <b>Profesor:</b> cierto, la m√°scara proporciona alineaci√≥n, pero ¬øpor qu√© comienza desde cero?  Creo que conf√≠an en el <b>hardware</b> segmentado.  B√°sicamente, podr√≠an usarlo para mover el √°rea hacia arriba, en t√©rminos de espacio lineal.  O tal vez solo est√© relacionado con la forma en que la aplicaci√≥n "ve" este rango.  De hecho, puede colocarlo en diferentes desplazamientos en su espacio de direcciones virtuales.  Esto le permitir√° realizar ciertos trucos con hardware segmentado para ejecutar m√∫ltiples m√≥dulos en el mismo espacio de direcciones. <br><br><img src="https://habrastorage.org/webt/_r/ef/sc/_refscc89wngsofm0ajoa0eflym.jpeg"><br><br>  <b>Audiencia: ¬ø</b> Quiz√°s esto se deba a que quieren "atrapar" el punto de recepci√≥n del puntero nulo? <br><br>  <b>Profesor:</b> s√≠, porque quieren atrapar todos los puntos de recepci√≥n.  Pero tienes una manera de hacerlo.  Porque el puntero nulo se refiere al segmento al que se est√° accediendo.  Y si mueve el segmento, puede mostrar una p√°gina cero no utilizada al comienzo de cada segmento.  Entonces esto ayudar√° a hacer algunos m√≥dulos. <br><br>  Creo que una de las razones de esta decisi√≥n, comenzar el rango desde 0, se debe a su deseo de portar su programa a la plataforma <b>x64</b> , que tiene un dise√±o ligeramente diferente.  Pero su art√≠culo no dice esto.  En el dise√±o de 64 bits, el equipo mismo elimin√≥ parte del hardware de segmentaci√≥n, en el que confiaban por razones de eficiencia, por lo que tuvieron que proporcionar un enfoque orientado al software.  Sin embargo, para <b>x32</b> esto todav√≠a no es una buena raz√≥n para que el espacio comience desde cero. <br><br>  Entonces, continuamos con la pregunta principal: ¬øqu√© queremos garantizar desde el punto de vista de la seguridad?  Abordemos este asunto de forma algo "ingenua" y veamos c√≥mo podemos arruinarlo todo, y luego intentemos solucionarlo. <br><br>  Creo que un plan ingenuo es buscar instrucciones prohibidas simplemente escaneando el ejecutable desde el principio hasta el final.  Entonces, ¬øc√≥mo puedes detectar estas instrucciones?  Simplemente puede tomar el c√≥digo del programa y ponerlo en una l√≠nea gigante que va de cero a 256 megabytes, dependiendo de qu√© tan grande sea su c√≥digo, y luego comenzar la b√∫squeda. <br><br><img src="https://habrastorage.org/webt/nl/vt/rv/nlvtrvk-s3z8c_yhuugx0zqaxyc.jpeg"><br><br>  Esta l√≠nea puede contener primero el m√≥dulo de instrucciones <b>NOP</b> , luego el m√≥dulo de instrucciones <b>ADD</b> , <b>NOT</b> , <b>JUMP,</b> y as√≠ sucesivamente.  Simplemente busca y, si encuentra una instrucci√≥n incorrecta, diga que es un m√≥dulo incorrecto y des√©chela.  Y si no ve ninguna llamada del sistema a esta instrucci√≥n, puede habilitar el inicio de este m√≥dulo y hacer todo dentro del rango de 0-256.  ¬øCrees que esto funcionar√° o no?  ¬øDe qu√© est√°n preocupados?  ¬øPor qu√© es tan dif√≠cil? <br><br>  <b>Audiencia:</b> ¬øEst√°n preocupados por el tama√±o de las instrucciones? <br><br>  <b>Profesor:</b> s√≠, el hecho es que la plataforma <b>x86</b> tiene instrucciones de longitud variable.  Esto significa que el tama√±o exacto de la instrucci√≥n depende de los primeros bytes de esta instrucci√≥n.  De hecho, puede mirar el primer byte para decir que la instrucci√≥n ser√° mucho m√°s grande, y luego puede que tenga que mirar un par de bytes m√°s, y luego decidir qu√© tama√±o toma.  Algunas arquitecturas como <b>Spark</b> , <b>ARM</b> , <b>MIPS</b> tienen m√°s instrucciones de longitud fija.  <b>ARM</b> tiene dos longitudes de instrucci√≥n: 2 o 4 bytes.  Pero en la plataforma <b>x86, la</b> longitud de las instrucciones puede ser de 1, 5 y 10 bytes, y si lo intenta, incluso puede obtener una instrucci√≥n bastante larga de 15 bytes.  Sin embargo, estas son instrucciones complejas. <br><br>  Como resultado, puede aparecer un problema.  Si escanea esta l√≠nea de c√≥digo linealmente, todo estar√° bien.  Pero tal vez en tiempo de ejecuci√≥n ir√° a la mitad de alg√∫n tipo de instrucci√≥n, por ejemplo, <b>NO</b> . <br><br><img src="https://habrastorage.org/webt/ob/rv/lj/obrvlj58uew5ji8-9mev7cxwb04.jpeg"><br><br>  Es posible que esta sea una instrucci√≥n multibyte, y si la interpreta a partir del segundo byte, se ver√° completamente diferente. <br><br>  Otro ejemplo en el que "jugaremos" con ensamblador.  Supongamos que tenemos instrucciones <b>25 CD 80 00 00</b> .  Despu√©s de mirar el segundo byte, lo interpretar√° como una instrucci√≥n de cinco bytes, es decir, tendr√° que mirar 5 bytes hacia adelante y ver que es seguido por la instrucci√≥n <b>AND% EAX, 0x00 00 80 CD</b> , comenzando con el operador <b>AND</b> para el registro <b>EAX</b> con algunos constantes definidas, por ejemplo, <b>00 00 80 CD</b> .  Esta es una de las instrucciones seguras que el <b>cliente nativo</b> deber√≠a permitir simplemente mediante la primera regla de verificar las instrucciones binarias.  Pero si, durante la ejecuci√≥n del programa, la <b>CPU</b> decide que debe comenzar a ejecutar el c√≥digo desde el <b>CD</b> , marcar√© este lugar de la instrucci√≥n con una flecha, entonces la instrucci√≥n <b>% EAX, 0x00 00 80 CD</b> , que en realidad es una instrucci√≥n de 4 bytes, significar√° la ejecuci√≥n de <b>INT $ 0x80</b> , que es una forma de hacer una llamada al sistema en <b>Linux</b> . <br><br><img src="https://habrastorage.org/webt/ib/3a/zp/ib3azp3oe9zmfedweosbecx9fto.jpeg"><br><br>  Entonces, si se pierde este hecho, deje que el m√≥dulo poco confiable "salte" al n√∫cleo y realice llamadas al sistema, es decir, haga lo que deseaba evitar.  ¬øC√≥mo podemos evitar esto? <br><br>  Quiz√°s deber√≠amos tratar de ver el desplazamiento de cada byte.  Porque x86 solo puede comenzar a interpretar una instrucci√≥n en bytes, no en bits, l√≠mites.  Por lo tanto, debe mirar el desplazamiento de cada byte para ver d√≥nde comienza la instrucci√≥n.  ¬øCrees que este es un plan factible? <br><br>  <b>P√∫blico:</b> creo que si alguien usa <b>AND</b> , el procesador no saltar√° a este lugar, sino que simplemente permitir√° que se ejecute el programa. <br><br>  <b>Profesor:</b> s√≠, porque b√°sicamente no es propenso a falsos positivos.  Ahora, si realmente lo quieres, puedes cambiar un poco el c√≥digo para evitarlo de alguna manera.  Si sabe exactamente lo que est√° buscando el dispositivo de prueba, podr√≠a cambiar estas instrucciones.  Tal vez configurando <b>Y</b> primero para una instrucci√≥n, y luego use la m√°scara en otra.  Pero es mucho m√°s f√°cil evitar estos arreglos de bytes sospechosos, aunque esto parece bastante inconveniente. <br><br>  Es posible que la arquitectura incluya un cambio de compilador.  B√°sicamente, tienen alg√∫n tipo de componente que realmente necesita compilar el c√≥digo correctamente.  No puede simplemente "despegar" <b>GCC</b> y compilar c√≥digo para <b>Native Client</b> .  Entonces, b√°sicamente, esto es factible.  Pero probablemente, solo piensan que causa demasiados problemas, no ser√° una soluci√≥n confiable o de alto rendimiento, y as√≠ sucesivamente.  Adem√°s, hay varias instrucciones <b>x86</b> que est√°n prohibidas, o deber√≠an considerarse inseguras y, por lo tanto, deber√≠an prohibirse.  Pero en su mayor parte son de un byte de tama√±o, por lo que es bastante dif√≠cil encontrarlos o filtrarlos. <br><br>  Por lo tanto, si no pueden simplemente recopilar y clasificar instrucciones inseguras y esperar lo mejor, deben usar un plan diferente para desarmarlo de manera confiable.  Entonces, ¬øqu√© hace el <b>cliente nativo</b> para asegurarse de que no "tropiece" con esta codificaci√≥n de longitud variable? <br><br>  En cierto sentido, si realmente escaneamos el archivo ejecutable de izquierda a derecha y buscamos todos los c√≥digos incorrectos posibles, y si esa es la forma en que se ejecuta el c√≥digo, entonces estamos en buena forma.  Incluso si hay algunas instrucciones extra√±as y alg√∫n sesgo, el procesador todav√≠a no va a "saltar" all√≠, ejecutar√° el programa en el mismo orden en que se escanean las instrucciones, es decir, de izquierda a derecha. <br><br><img src="https://habrastorage.org/webt/kh/v0/ea/khv0ea7apzgmwqnx1pbaj8k1fgy.jpeg"><br><br>  Por lo tanto, el problema con el desmontaje confiable surge debido al hecho de que en alg√∫n lugar de la aplicaci√≥n puede haber "saltos".  El procesador puede fallar si realiza un "salto" a alguna instrucci√≥n de c√≥digo que no not√≥ al escanear de izquierda a derecha.  Por lo tanto, este es un problema de desmontaje confiable hasta ahora en desarrollo.  Y el plan principal es verificar a d√≥nde conducen todos los "saltos".  De hecho, es bastante simple en alg√∫n nivel.  Hay un mont√≥n de reglas que consideraremos en un segundo, pero el plan aproximado es que si ve una instrucci√≥n de "salto", debe asegurarse de que el prop√≥sito del "salto" se haya notado antes.  Para hacer esto, de hecho, es suficiente escanear de izquierda a derecha, es decir, el procedimiento que describimos en nuestro enfoque ingenuo del problema. <br><br>  En este caso, si ve alguna instrucci√≥n de "salto" y la direcci√≥n a la que apunta esta instrucci√≥n, debe asegurarse de que sea la misma direcci√≥n que ya vio durante el desmontaje de izquierda a derecha. <br><br>  Si se encuentra una instrucci√≥n de salto para este byte de CD, entonces debemos marcar este salto como no v√°lido porque nunca vimos la instrucci√≥n que comienza en el byte de CD, pero vimos otra instrucci√≥n que comienza con el n√∫mero 25. Pero si todas las instrucciones de salto orden√≥ ir al comienzo de la instrucci√≥n, en este caso a 25, luego todo est√° en orden con nosotros.  ¬øEso est√° claro? <br><br>  El √∫nico problema es que no puede verificar los objetivos de cada salto en el programa, porque puede haber saltos indirectos.  Por ejemplo, en <b>x86</b> podr√≠a tener algo as√≠ como un salto al valor de este registro <b>EAX</b> .  Esto es ideal para implementar punteros de funci√≥n. <br><br><img src="https://habrastorage.org/webt/uf/gh/bl/ufghbl_dd-pofxnrp7fy-ne3ee0.jpeg"><br><br>  Es decir, el puntero de funci√≥n est√° en alg√∫n lugar de la memoria, lo mantiene en alg√∫n registro y luego va a cualquier direcci√≥n en el registro de movimiento. <br><br>  Entonces, ¬øc√≥mo lidian estos tipos con los saltos indirectos?  Porque, de hecho, no tengo idea de si esto ser√° un "salto" al byte <b>CD</b> o al byte 25. ¬øQu√© hacen en este caso? <br><br>  <b>Audiencia: ¬ø</b> usando herramientas? <br><br>  <b>Profesor:</b> s√≠, la instrumentaci√≥n es su truco principal.  Por lo tanto, cada vez que ven que el compilador est√° listo para realizar la generaci√≥n, esto es una prueba de que este salto no causar√° problemas.  Para hacer esto, deben asegurarse de que todos los saltos se realicen con una multiplicidad de 32 bytes.  Como lo hacen  Cambian todas las instrucciones de salto a lo que llamaron "pseudo instrucciones".  Estas son las mismas instrucciones, pero con prefijo, que borra los 5 bits bajos en el registro <b>EAX</b> .  El hecho de que la instrucci√≥n borre 5 bits bajos significa que hace que el valor dado sea un m√∫ltiplo de 32, de dos a cinco, y luego ya se realiza un salto a este valor. <br><br><img src="https://habrastorage.org/webt/r3/sf/nq/r3sfnqlxz3egqe8q-0ret79kwzu.jpeg"><br><br>  Si observa esto durante la verificaci√≥n, aseg√∫rese de que este "par" instructivo "saltar√°" solo con una multiplicidad de 32 bytes.  Y luego, para asegurarse de que no hay posibilidad de "saltar" a algunas instrucciones extra√±as, aplica una regla adicional.  Consiste en el hecho de que durante el desmontaje, cuando mira sus instrucciones de izquierda a derecha, se asegura de que el comienzo de cada instrucci√≥n v√°lida tambi√©n sea un m√∫ltiplo de 32 bytes. <br><br>  Por lo tanto, adem√°s de este kit de herramientas, verifica que cada c√≥digo que es m√∫ltiplo de 32 es la instrucci√≥n correcta.  Por una instrucci√≥n v√°lida, me refiero a una instrucci√≥n que se desmonta de izquierda a derecha. <br><br>  <b>Audiencia:</b> ¬øPor qu√© se elige el n√∫mero 32? <br><br>  <b>Profesor:</b> s√≠, ¬øpor qu√© eligieron 32 en lugar de 1000 o 5?  ¬øPor qu√© es malo 5? <br><br>  <b>Audiencia:</b> porque el n√∫mero debe ser una potencia de 2. <br><br>  <b>Profesor:</b> s√≠, bueno, por eso.  Porque de lo contrario, garantizar el uso de algo que sea m√∫ltiplo de 5 requerir√° instrucciones adicionales que conducen a una sobrecarga.  ¬øQu√© tal ocho?  ¬øEs ocho un n√∫mero suficientemente bueno? <br><br>  <b>P√∫blico:</b> puede tener instrucciones de m√°s de ocho bits. <br><br>  <b>Profesor:</b> s√≠, esta puede ser la instrucci√≥n m√°s larga permitida en la plataforma x86.  Si tenemos una instrucci√≥n de 10 bytes y todo debe ser un m√∫ltiplo de 8, entonces no podemos insertarlo en ning√∫n lado.  Entonces, la longitud deber√≠a ser suficiente para todos los casos, porque la instrucci√≥n m√°s grande que vi fue de 15 bytes.  Entonces 32 bytes es suficiente. <br><br>  Si desea adaptar las instrucciones para ingresar o salir del entorno del servicio de procesos, es posible que necesite una cantidad de c√≥digo no trivial en una ranura de 32 bytes.  Por ejemplo, 31 bytes, porque 1 byte contiene una instrucci√≥n.  ¬øDeber√≠a ser mucho m√°s grande?  ¬øDeber√≠amos hacer esto igual a, digamos, 1024 bytes?  Si tiene muchos punteros de funci√≥n o muchos saltos indirectos, cada vez que quiera crear un lugar donde vaya a saltar, debe continuar hasta el pr√≥ximo borde, independientemente de su valor.  Entonces, con 32 bits es un tama√±o bastante normal.  En el peor de los casos, solo perder√° 31 bytes si necesita llegar r√°pidamente al siguiente borde.  Pero si tiene un tama√±o que es m√∫ltiplo de 1024 bytes, entonces es posible desperdiciar un kilobyte completo de memoria en vano para un salto indirecto.  Si tiene funciones cortas o muchos punteros de funci√≥n, un tama√±o tan grande de la multiplicidad de la longitud del "salto" causar√° una p√©rdida significativa de memoria. <br><br>  No creo que el n√∫mero 32 sea un obst√°culo para el <b>Native Client</b> .  Algunos bloques podr√≠an funcionar con una multiplicidad de 16 bits, algunos de 64 o 128 bits, no importa.  Solo 32 bits les parecieron el valor √≥ptimo m√°s aceptable. <br><br>  Entonces, hagamos un plan para un desmontaje confiable.  Como resultado, el compilador debe tener un poco de cuidado al compilar <b>c√≥digo</b> <b>C</b> o <b>C ++</b> en un binario de <b>Native Client</b> y observar las siguientes reglas. <br><br><img src="https://habrastorage.org/webt/c0/nh/kc/c0nhkc4izpqqyrj_rtr2gg-eytu.jpeg"><br><br>  Por lo tanto, cada vez que salta, como se muestra en la l√≠nea superior, debe agregar estas instrucciones adicionales en las 2 l√≠neas inferiores.  E independientemente del hecho de que crea una funci√≥n a la que va a "saltar", nuestra instrucci√≥n saltar√° como la suma <b>Y $ 0xffffffe0,</b> indica <b>% eax</b> .  Y no puede simplemente complementarlo con ceros, porque todo esto debe tener los c√≥digos correctos.  Por lo tanto, la adici√≥n es necesaria para garantizar que todas las instrucciones posibles sean v√°lidas.  Y, afortunadamente, en la plataforma <b>x86</b> , no se describe una sola funci√≥n de <b>noop</b> por un solo byte, o al menos no hay un solo byte de <b>noop</b> 1 de tama√±o.  Por lo tanto, siempre puede agregar cosas al valor de una constante. <br><br>  Entonces, ¬øqu√© nos garantiza esto?  Asegur√©monos de ver siempre lo que sucede en la terminolog√≠a de las instrucciones que se seguir√°n.  Esto es lo que nos da esta regla: la garant√≠a de que una llamada al sistema no se realizar√° por accidente.  Esto se aplica a los saltos, pero ¬øqu√© pasa con los retornos?  ¬øC√≥mo manejan las devoluciones?  ¬øPodemos <b>volver</b> a una funci√≥n en <b>Native Client</b> ?  ¬øQu√© sucede si ejecuta el c√≥digo candente? <br><br>  <b>P√∫blico:</b> puede desbordar la pila. <br><br>  <b>Profesor:</b> es cierto que aparece inesperadamente en la pila.  Pero el hecho es que la pila utilizada por los m√≥dulos de <b>Native Client en</b> realidad contiene algunos datos en su interior.  Por lo tanto, al tratar con <b>Native Client,</b> no debe preocuparse por el desbordamiento de la pila. <br><br>  <b>P√∫blico:</b> espera, pero puedes poner cualquier cosa en la pila.  Y cuando das un salto indirecto. <br><br>  <b>Profesor:</b> es verdad.  El retorno se ve casi como un salto indirecto desde alg√∫n lugar en la memoria, que se encuentra en la parte superior de la pila.  Por lo tanto, creo que una cosa que podr√≠an hacer para la funci√≥n de <b>retorno</b> es establecer el prefijo de la misma manera que en la comprobaci√≥n anterior.  Y este prefijo comprueba qu√© aparece en la parte superior de la pila.  Verifica si esto es v√°lido y cuando escribe o utiliza el operador <b>AND</b> , verifica qu√© est√° en la parte superior de la pila.  Esto parece poco confiable debido al cambio constante de datos.  Porque, por ejemplo, si mira la parte superior de la pila y se asegura de que todo est√© bien all√≠, y luego escribe algo, la secuencia de datos en el mismo m√≥dulo puede modificar algo en la parte superior de la pila, despu√©s de lo cual se referir√° a la incorrecta direcci√≥n <br><br>  <b>P√∫blico:</b> ¬øEsto no se aplica al salto en la misma medida? <br><br>  <b>Profesor:</b> s√≠, ¬øqu√© pasa all√≠ con un salto?  ¬øPueden nuestras condiciones de carrera invalidar de alguna manera esta prueba? <br><br>  <b>Audiencia: ¬ø</b> Pero no se puede escribir el c√≥digo? <br><br>  <b>Profesor:</b> s√≠, el c√≥digo no se puede escribir, esto es cierto.  Por lo tanto, no puede modificar AND.  Pero, ¬øno podr√≠a alg√∫n otro flujo cambiar el prop√≥sito del salto entre estas dos instrucciones? <br><br>  <b>P√∫blico:</b> esto est√° en el registro, as√≠ que ... <br><br>  <b>Profesor:</b> S√≠, esto es algo genial.  Porque si un flujo modifica algo en la memoria o en lo que se carga desde <b>EAX</b> (por s√≠ mismo, lo hace antes de descargar), en este caso, este <b>EAX</b> estar√° en mal estado, pero luego eliminar√° los bits defectuosos.  O puede cambiar la memoria despu√©s, cuando el puntero ya est√° en <b>EAX</b> , por lo que no importa que cambie la ubicaci√≥n de la memoria desde la que se carg√≥ el registro <b>EAX</b> . <br><br>  De hecho, los hilos no comparten conjuntos de registros.  Por lo tanto, si otro hilo cambia el registro <b>EAX</b> , esto no afectar√° el registro <b>EAX</b> de este hilo.  Por lo tanto, otros hilos no pueden invalidar esta secuencia de instrucciones. <br><br>  Hay otra pregunta interesante.  ¬øPodemos evitar esto <b>Y</b> ?  Puedo saltar a donde quiera en cualquier lugar de este espacio de direcciones.      ,       <b>AND</b>  . <br><br><img src="https://habrastorage.org/webt/4p/vf/nk/4pvfnkoa0kmui9vdd5wn2o-jbk0.jpeg"><br><br>       ,      ,   ,    ,  ,        <b>AND</b> .    .     <b>jmp</b> ,      . <br><br><img src="https://habrastorage.org/webt/kg/mf/cu/kgmfcuyc42v0rtkdtzt1ptm1ty4.jpeg"><br><br> ,      ,    -  ,    1237.     ,     32.  <b>Native Client</b>       ,     ,      ,     .          ,   ,      1237      ? <br><br><img src="https://habrastorage.org/webt/dn/_-/_r/dn_-_r-vi7p_qx7nxwwkqmroh-w.jpeg"><br><br>    -  <b>EAX</b> ,   , ,        ,      .  ,    ?     ? <br><br> <b>:</b> <b>NaCl</b>   ,      . <br><br> <b>:</b> ,       .      <b>x86</b>    ,    ,   <b>NaCl</b>   ,  2          .       ,    ,  : ¬´,    ,    !¬ª,              <b>25 CD 80 00 00</b> .     .         ,     <b>x86</b> . <br><br>   ,   <b>Native Client</b>      . ,       ,   ,    ,          <b>NaCl</b> . ,     . <br><br> <b>:</b> ,        ,     .     ,         .  ,      ,     ,       ,     . <br><br><img src="https://habrastorage.org/webt/sq/hd/pl/sqhdplwnbsfj55r8qmp6trwxk5y.jpeg"><br><br> <b>:</b> ,  .     ,   . ,       ,      ,   <b>EAX</b> .           ,   -  .        <b>EAX</b> ,  <b>EBX</b>   .           ,       .          <b>EAX</b>  <b>EBX</b>  <b>AND</b>   .     ,  ,      <b>EAX</b> ,         .         ,   -   <b>64</b>  .    <b>Jmp *% eax</b>   <b>AND</b>   . <br><br><img src="https://habrastorage.org/webt/qz/nf/zt/qznfzt9lqpfreshgcc76zygs8cq.jpeg"><br><br> ,   , ,   ,   .   <b>Intel</b> ,        ,  ,   ,      .       ,   ,             .       <b>AND</b>    ,   <b>EAX</b>  ,    ¬´¬ª . <br><br> ,       ,           .     ,       .     ,    ,   ,   .      ,  ,   ,    . <br> ,     ,  <b>C1</b>  <b>C7</b> . <br><br> <b>C1</b>   ,       ,            .     ,     ¬´¬ª     .   ,       ,      .   ,       ,     - .  ,    . <br> <b>2</b> ,     0   <b>64</b> .     ,     ,        .        ,      ,      . <br><br>  <b>3</b> ,  ,  ,   .        ,  ,         . <br><br> <b>4</b>   ,         <b>hlt</b> .             <b>halt</b> ?     ,  <b>C4</b> .   ,   ,      -  ,      . <br><br>     ,  ,          ? ,          ,      -  . <br>     ,     ,  ,       ,       .    ,       ,     ,  ,           .         . <br><br><img src="https://habrastorage.org/webt/9i/1f/yj/9i1fyjdue4tun6jsa8gnnzkue9c.jpeg"><br><br> 55:20  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Curso MIT "Seguridad de sistemas inform√°ticos".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> 7: ¬´ Native Client¬ª,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br> ,    .  ¬øTe gustan nuestros art√≠culos?  ¬øQuieres ver m√°s materiales interesantes?  <b>Ap√≥yenos</b> haciendo un pedido o recomend√°ndolo a sus amigos, un <b>descuento del 30% para los usuarios de Habr en un an√°logo √∫nico de servidores de nivel de entrada que inventamos para usted:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la verdad sobre VPS (KVM) E5-2650 v4 (6 n√∫cleos) 10GB DDR4 240GB SSD 1Gbps de $ 20 o c√≥mo dividir el servidor?</a>  (las opciones est√°n disponibles con RAID1 y RAID10, hasta 24 n√∫cleos y hasta 40GB DDR4). <br><br> <b>3  </b>    Dell R630     ‚Äî <b>2  Intel Deca-Core Xeon E5-2630 v4 / 128GB DDR4 / 41TB HDD  2240GB SSD / 1Gbps 10 TB ‚Äî  $99,33 </b> ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br>  <b>Dell R730xd 2 veces m√°s barato?</b>  ¬°Solo tenemos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV desde $ 249</a> en los Pa√≠ses Bajos y los Estados Unidos!</b>  Lea sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo construir un edificio de infraestructura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase utilizando servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418225/">https://habr.com/ru/post/es418225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418215/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 5: "De d√≥nde vienen los errores del sistema de seguridad", Parte 2</a></li>
<li><a href="../es418217/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 6: "Oportunidades", parte 1</a></li>
<li><a href="../es418219/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 6: Oportunidades, Parte 2</a></li>
<li><a href="../es418221/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 6: "Oportunidades", parte 3</a></li>
<li><a href="../es418223/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 7: El sandbox del cliente nativo, parte 1</a></li>
<li><a href="../es418227/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 7: El sandbox del cliente nativo, parte 3</a></li>
<li><a href="../es418229/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 8: Modelo de seguridad de red, parte 1</a></li>
<li><a href="../es418233/index.html">BMW mnemotecnia para encontrar valores l√≠mite</a></li>
<li><a href="../es418235/index.html">Saga orquestada o c√≥mo construir transacciones comerciales en servicios con la base de datos por patr√≥n de servicio</a></li>
<li><a href="../es418237/index.html">Desarrollo de aplicaciones multiinquilino en la plataforma SAP Cloud en Neo, Parte 2: Autorizaci√≥n y autenticaci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>