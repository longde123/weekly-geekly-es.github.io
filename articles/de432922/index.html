<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥙 🚊 🖕🏽 Wie wir zwei Wochen lang nach NFS-Fehlern im Linux-Kernel gesucht haben 🚻 ⛵️ 👦🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine detaillierte Beschreibung der Fehlersuche aus der GitLab-Task, die zum Patch für den Linux-Kernel führte 


 Am 14. September meldete der GitLab-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir zwei Wochen lang nach NFS-Fehlern im Linux-Kernel gesucht haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/432922/"><h3 id="podrobnoe-opisanie-poiskov-baga-iz-zadachi-gitlab-kotorye-priveli-k-patchu-dlya-yadra-linux">  Eine detaillierte Beschreibung der Fehlersuche aus der GitLab-Task, die zum Patch für den Linux-Kernel führte </h3><br><p> Am 14. September meldete der GitLab-Support ein kritisches Problem, das bei einem unserer Kunden aufgetreten ist: Zuerst funktioniert GitLab einwandfrei, und dann erhalten Benutzer eine Fehlermeldung.  Sie versuchten, einige Repositorys über Git zu klonen, und plötzlich erschien eine unverständliche Meldung über eine veraltete Datei: Veralteter <code>Stale file error</code> .  Der Fehler blieb lange bestehen und funktionierte erst, als der Systemadministrator <code>ls</code> manuell im Verzeichnis selbst startete. </p><br><p>  Ich musste die internen Mechanismen von Git und dem NFS-Netzwerkdateisystem untersuchen.  Infolgedessen haben wir einen Fehler im Linux v4.0 NFS-Client gefunden. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trond Myklebust hat einen Patch für den Kernel geschrieben</a> . Seit dem 26. Oktober ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Patch im Haupt-Linux-Kernel enthalten</a> . </p><br><p>  In diesem Beitrag werde ich Ihnen erzählen, wie wir das Problem untersucht haben, in welche Richtung wir gedacht haben und mit welchen Tools wir den Fehler verfolgt haben.  Wir waren inspiriert von der exzellenten Detektivarbeit von Oleg Dashevsky, die in dem Beitrag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Wie ich zwei Wochen lang in Ruby nach einem Gedächtnisleck</a> gesucht habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">“ beschrieben wurde</a> . </p><br><img src="https://habrastorage.org/webt/es/0f/-7/es0f-7dbqlnheksnnmxtlwawlic.jpeg"><a name="habracut"></a><br><p>  Es ist auch ein großartiges Beispiel dafür, wie Open Source-Debugging ein Mannschaftssport ist, an dem viele Menschen, Unternehmen und Länder beteiligt sind.  Das Motto von GitLab „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jeder kann etwas beitragen</a> “ gilt nicht nur für GitLab selbst, sondern auch für andere Open-Source-Projekte wie den Linux-Kernel. </p><br><h3 id="vosproizvedenie-baga">  Fehlerreproduktion </h3><br><p>  Wir haben NFS viele Jahre auf GitLab.com gespeichert, es dann jedoch nicht mehr für den Zugriff auf Repository-Daten auf Computern mit Anwendungen verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir haben alle Git-Anrufe nach Gitaly verschoben</a> .  Wir unterstützen NFS für Clients, die ihre Installationen auf GitLab verwalten, jedoch noch nie auf dasselbe Problem wie der oben genannte Client gestoßen sind. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Kunde gab einige nützliche Hinweise</a> : </p><br><ol><li>  Vollständiger Fehlertext: <code>fatal: Couldn't read ./packed-refs: Stale file handle</code> . </li><li>  Anscheinend trat das Problem auf, als der Client die <code>git gc</code> in Git mit dem Befehl <code>git gc</code> manuell startete. </li><li>  Der Fehler verschwand, als der Systemadministrator das Dienstprogramm <code>ls</code> im Verzeichnis startete. </li><li>  Der Fehler verschwand, als der <code>git gc</code> Prozess beendet wurde. </li></ol><br><p>  Es ist klar, dass die ersten beiden Punkte miteinander verbunden sind.  Wenn Sie Änderungen an den Git-Zweig senden, erstellt Git einen schwachen Link - einen langen Dateinamen, der den Zweignamen für das Commit angibt.  Beim Senden an den <code>master</code> wird beispielsweise eine Datei mit dem Namen <code>refs/heads/master</code> im Repository erstellt: </p><br><pre> <code class="plaintext hljs">$ cat refs/heads/master 2e33a554576d06d9e71bfd6814ee9ba3a7838963</code> </pre> <br><p>  Der Befehl <code>git gc</code> führt mehrere Aufgaben aus.  Beispielsweise werden diese schwachen Links (Refs) gesammelt und in eine einzelne Datei mit dem Namen Packed <code>packed-refs</code> .  Dies beschleunigt die Arbeit etwas, da das Lesen einer großen Datei einfacher ist als bei vielen kleinen.  Nach dem Ausführen des <code>git gc</code> die <code>packed-refs</code> Datei beispielsweise folgendermaßen aus: </p><br><pre> <code class="plaintext hljs"># pack-refs with: peeled fully-peeled sorted 564c3424d6f9175cf5f2d522e10d20d781511bf1 refs/heads/10-8-stable edb037cbc85225261e8ede5455be4aad771ba3bb refs/heads/11-0-stable 94b9323033693af247128c8648023fe5b53e80f9 refs/heads/11-1-stable 2e33a554576d06d9e71bfd6814ee9ba3a7838963 refs/heads/master</code> </pre> <br><p>  Wie wird die <code>packed-refs</code> Datei erstellt?  Um dies herauszufinden, haben wir den Befehl <code>strace git gc</code> ausgeführt, bei dem wir ein schwaches Glied hatten.  Hier sind die Zeilen, die relevant sind: </p><br><pre> <code class="plaintext hljs">28705 open("/tmp/libgit2/.git/packed-refs.lock", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 3 28705 open(".git/packed-refs", O_RDONLY) = 3 28705 open("/tmp/libgit2/.git/packed-refs.new", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 4 28705 rename("/tmp/libgit2/.git/packed-refs.new", "/tmp/libgit2/.git/packed-refs") = 0 28705 unlink("/tmp/libgit2/.git/packed-refs.lock") = 0</code> </pre> <br><p>  Systemaufrufe zeigten, dass der Befehl <code>git gc</code> : </p><br><ol><li>  <code>packed-refs.lock</code> .  Dies teilt anderen Prozessen mit, dass die <code>packed-refs</code> gesperrt ist und sich nicht ändern kann. </li><li>  Geöffnet <code>packed-refs.new</code> . </li><li>  Ich habe schwache Glieder in <code>packed-refs.new</code> . </li><li>  Umbenannt in <code>packed-refs.new</code> <code>packed-refs</code> . <code>packed-refs.new</code> in <code>packed-refs.new</code> <code>packed-refs</code> . </li><li>  <code>packed-refs.lock</code> . </li><li>  Schwache Glieder entfernt. </li></ol><br><p>  Der entscheidende Punkt hier ist der vierte, <code>packed-refs</code> Umbenennen, bei dem Git die <code>packed-refs</code> einführt.  <code>git gc</code> sammelt nicht nur schwache Glieder, sondern führt auch eine viel ressourcenintensivere Aufgabe aus - es sucht und entfernt nicht verwendete Objekte.  In großen Repositories kann dies länger als eine Stunde dauern. </p><br><p>  Und wir haben uns gefragt: <code>git gc</code> in großen Repositories die Datei während der Reinigung offen?  Wir haben die <code>strace</code> Protokolle untersucht, das Dienstprogramm <code>lsof</code> gestartet und <code>git gc</code> über den <code>git gc</code> Prozess <code>git gc</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/493/51d/077/49351d077382c8b70317346789331c81.svg" alt="Bild"></p><br><p>  Wie Sie sehen können, wird die <code>packed-refs</code> ganz am Ende geschlossen, nachdem der möglicherweise lange Prozess der <code>Garbage collect objects</code> . </p><br><p>  Es stellte sich also die folgende Frage: Wie verhält sich NFS, wenn die <code>packed-refs</code> auf einem Knoten geöffnet ist und der andere sie zu diesem Zeitpunkt umbenennt? </p><br><p>  "Aus wissenschaftlichen Gründen" baten wir den Kunden, ein Experiment auf zwei verschiedenen Maschinen (Alice und Bob) durchzuführen: <br>  1) Erstellen Sie auf dem gemeinsam genutzten NFS-Volume zwei Dateien: <code>test1.txt</code> und <code>test2.txt</code> mit unterschiedlichen Inhalten, damit Sie leichter zwischen ihnen unterscheiden können: </p><br><pre> <code class="plaintext hljs">alice $ echo "1 - Old file" &gt; /path/to/nfs/test1.txt alice $ echo "2 - New file" &gt; /path/to/nfs/test2.txt</code> </pre> <br><p>  2) Auf Alices <code>test1.txt</code> sollte die Datei <code>test1.txt</code> geöffnet sein: </p><br><pre> <code class="plaintext hljs">alice $ irb irb(main):001:0&gt; File.open('/path/to/nfs/test1.txt')</code> </pre> <br><p>  3) Zeigen Sie auf Alices Computer kontinuierlich den Inhalt von <code>test1.txt</code> : </p><br><pre> <code class="plaintext hljs">alice $ while true; do cat test1.txt; done</code> </pre> <br><p>  4) Führen Sie dann auf Bobs Computer den folgenden Befehl aus: </p><br><pre> <code class="plaintext hljs">bob $ mv -f test2.txt test1.txt</code> </pre> <br><p>  Der letzte Schritt reproduziert, was <code>git gc</code> mit der <code>packed-refs</code> Datei macht, wenn eine vorhandene Datei überschrieben wird. <br>  Auf dem Computer des Clients sah das Ergebnis ungefähr so ​​aus: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file cat: test1.txt: Stale file handle</code> </pre> <br><p>  Da ist!  Wir scheinen das Problem auf kontrollierte Weise kontrolliert zu haben.  Im selben Experiment auf einem Linux-NFS-Server trat dieses Problem jedoch nicht auf.  Das Ergebnis wurde erwartet - nach dem Umbenennen wurde der neue Inhalt akzeptiert: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 2 - New file &lt;--- RENAME HAPPENED 2 - New file 2 - New file</code> </pre> <br><p>  Woher kommt dieser Unterschied im Verhalten?  Es stellt sich heraus, dass der Client <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isilon NFS-</a> Speicher verwendet hat, der nur NFS v4.0 unterstützt.  Als wir die Verbindungseinstellungen mit dem Parameter <code>vers=4.0</code> in <code>/etc/fstab</code> auf v4.0 änderten, ergab der Test ein anderes Ergebnis für den Linux-NFS-Server: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 1 - Old file &lt;--- RENAME HAPPENED 1 - Old file 1 - Old file</code> </pre> <br><p>  Anstelle des veralteten Dateihandles Veraltetes Dateihandle zeigte <code>Stale file handle</code> Linux NFS v4.0-Server veralteten <em>Inhalt an</em> .  Es stellt sich heraus, dass der Unterschied im Verhalten durch die NFS-Spezifikationen erklärt werden kann.  Aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 3010</a> : </p><br><blockquote>  Der Dateideskriptor ist möglicherweise veraltet oder läuft beim Umbenennen ab, jedoch nicht immer.  Server-Implementierern wird empfohlen, Maßnahmen zu ergreifen, um sicherzustellen, dass Dateideskriptoren nicht ablaufen und auf diese Weise nicht ablaufen. </blockquote><p>  Mit anderen Worten, NFS-Server können festlegen, wie sie sich beim Umbenennen einer Datei verhalten <code>Stale file error</code> , und der NFS-Server gibt in solchen Fällen vernünftigerweise einen <code>Stale file error</code> .  Wir haben vorgeschlagen, dass die Ursache des Problems dieselbe ist, obwohl die Ergebnisse unterschiedlich waren.  Wir haben vermutet, dass es sich um eine Cache-Prüfung handelt, da das Dienstprogramm <code>ls</code> im Verzeichnis den Fehler behoben hat.  Jetzt hatten wir ein reproduzierbares Testszenario und wandten uns an Experten - Linux NFS-Betreuer. </p><br><h2 id="lozhnyy-sled-delegirovanie-na-nfs-servere">  False Trace: Delegierung auf einem NFS-Server </h2><br><p>  Als wir es geschafft haben, den Fehler Schritt für Schritt zu reproduzieren, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schrieb</a> ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an die Linux-NFS-Kontakte,</a> was wir gelernt haben.  Ich korrespondierte eine Woche lang mit Bruce Fields, dem Linux-NFS-Server-Betreuer, und er schlug vor, dass der Fehler in NFS lag und ich den Netzwerkverkehr untersuchen musste.  Er dachte, das Problem sei das Delegieren von Aufgaben auf dem NFS-Server. </p><br><h3 id="chto-takoe-delegirovanie-na-nfs-servere">  Was ist eine Delegierung auf einem NFS-Server? </h3><br><p>  Kurz gesagt, die NFS v4-Version verfügt über eine Delegierungsfunktion, um den Dateizugriff zu beschleunigen.  Der Server kann Lese- oder Schreibzugriff an den Client delegieren, sodass der Client den Server nicht ständig fragen muss, ob die Datei von einem anderen Client geändert wurde.  Einfach ausgedrückt bedeutet das Delegieren einer Aufzeichnung, dass Sie jemandem Ihr Notizbuch leihen und sagen: "Sie schreiben hier, und ich werde es abholen, wenn ich bereit bin."  Und eine Person muss nicht jedes Mal nach einem Notizbuch fragen, wenn Sie etwas schreiben müssen - sie hat völlige Handlungsfreiheit, bis das Notizbuch weggenommen wird.  In NFS wird eine Anforderung zur Rückgabe eines Notizbuchs als Delegierungssperrung bezeichnet. </p><br><p>  Ein Fehler beim Widerruf der NFS-Delegierung könnte das Problem des <code>Stale file handle</code> erklären.  Denken <code>test1.txt</code> daran, wie <code>test1.txt</code> in Alices <code>test1.txt</code> geöffnet und dann durch <code>test2.txt</code> ersetzt wurde.  Möglicherweise konnte der Server die Delegierung für <code>test1.txt</code> nicht widerrufen, was zu einem ungültigen Status führte.  Um diese Theorie zu testen, haben wir den NFC-Verkehr mit dem Dienstprogramm <code>tcpdump</code> aufgezeichnet und mit Wireshark visualisiert. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wireshark</a> ist ein großartiges Open-Source-Tool zur Analyse des Netzwerkverkehrs, insbesondere zur Erkundung von NFS in Aktion.  Wir haben den Trace mit dem folgenden Befehl auf einem NFS-Server aufgezeichnet: </p><br><pre> <code class="plaintext hljs">tcpdump -s 0 -w /tmp/nfs.pcap port 2049</code> </pre> <br><p>  Dieser Befehl zeichnet den gesamten NFS-Verkehr auf, der normalerweise über den TCP-Port 2049 geleitet wird. Da unser Experiment mit NFS v4.1, jedoch nicht mit NFS v4.0 erfolgreich war, konnten wir das Verhalten von NFS im funktionierenden und im nicht funktionierenden Fall vergleichen.  Bei Wireshark haben wir folgendes Verhalten festgestellt: </p><br><h3 id="nfs-v40-ustarevshiy-fayl">  NFS v4.0 (veraltete Datei) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a1/0bb/e23/6a10bbe2304b155431010aa4ca577fa7.svg" alt="Bild"></p><br><p>  Dieses Diagramm zeigt, dass Alice in Schritt 1 <code>test1.txt</code> öffnet und einen NFS-Dateideskriptor mit der Kennung <code>stateid</code> 0x3000 empfängt.  Wenn Bob versucht, die Datei umzubenennen, fordert der NFS-Server erneut zum Versuch auf, indem er die Nachricht <code>NFS4ERR_DELAY</code> , und er ruft die Delegierung von Alice über die Nachricht <code>CB_RECALL</code> (Schritt 3).  Alice gibt die Delegierung zurück (DELEGRETURN in Schritt 4) und Bob versucht erneut, die <code>RENAME</code> Nachricht zu senden (Schritt 5).  <code>RENAME</code> wird in beiden Fällen ausgeführt, aber Alice liest die Datei weiterhin mit demselben Deskriptor. </p><br><h3 id="nfs-v41-rabochiy-sluchay">  NFS v4.1 (Arbeitsfall) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3d/1a3/d49/f3d1a3d49e803d73a4dd7f830e9b238a.svg" alt="Bild"></p><br><p>  Hier ist der Unterschied in Schritt 6 sichtbar. In NFS v4.0 (mit einer veralteten Datei) versucht Alice <code>stateid</code> dieselbe <code>stateid</code> .  In NFS v4.1 (Arbeitsfall) führt Alice zusätzliche <code>LOOKUP</code> und <code>OPEN</code> Operationen aus, sodass der Server eine andere <code>stateid</code> .  In v4.0 werden keine zusätzlichen Nachrichten gesendet.  Dies erklärt, warum Alice veraltete Inhalte sieht - sie verwendet einen alten Deskriptor. </p><br><p>  Warum entscheidet sich Alice plötzlich für einen zusätzlichen <code>LOOKUP</code> ?  Anscheinend war der Rückruf der Delegation erfolgreich, aber anscheinend blieb ein Problem bestehen.  Beispielsweise wird der Behinderungsschritt übersprungen.  Um dies zu überprüfen, haben wir die NFS-Delegierung auf dem NFS-Server selbst mit diesem Befehl ausgeschlossen: </p><br><pre> <code class="plaintext hljs">echo 0 &gt; /proc/sys/fs/leases-enable</code> </pre> <br><p>  Wir haben das Experiment wiederholt, aber das Problem ist nicht verschwunden.  Wir haben sichergestellt, dass das Problem nicht auf dem NFS-Server oder der Delegierung liegt, und beschlossen, den NFS-Client im Kernel zu untersuchen. </p><br><h2 id="kopaem-glubzhe-linux-nfs-klient">  Tiefer graben: Linux NFS-Client </h2><br><p>  Die erste Frage, die wir den NFS-Betreuern beantworten mussten, war: </p><br><h3 id="eta-problema-sohranyaetsya-v-posledney-versii-yadra">  Bleibt dieses Problem in der neuesten Kernel-Version bestehen? </h3><br><p>  Das Problem trat in den Kerneln CentOS 7.2 und Ubuntu 16.04 mit den Versionen 3.10.0-862.11.6 bzw. 4.4.0-130 auf.  Beide Kerne blieben jedoch hinter der neuesten Version zurück, die zu diesem Zeitpunkt 4,19-rc2 betrug. </p><br><p>  Wir haben die neue virtuelle Maschine Ubuntu 16.04 auf der Google Cloud Platform (GCP) bereitgestellt, den neuesten Linux-Kernel geklont und die Kernel-Entwicklungsumgebung eingerichtet.  Wir haben die <code>.config</code> Datei mit <code>menuconfig</code> und <code>menuconfig</code> überprüft: </p><br><ol><li>  Der NFS-Treiber wird als Modul kompiliert ( <code>CONFIG_NFSD=m</code> ). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die</a> korrekten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GCP-Kernelparameter</a> sind korrekt angegeben. </li></ol><br><p>  Genetics verfolgt die Entwicklung in Echtzeit von Drosophila, und mit dem ersten Element konnten wir schnell Korrekturen am NFS-Client vornehmen, ohne den Kernel neu zu starten.  Der zweite Punkt garantierte, dass der Kernel nach der Installation gestartet wird.  Glücklicherweise waren wir mit den Standard-Kernel-Parametern zufrieden. </p><br><p>  Wir haben dafür gesorgt, dass das Problem der veralteten Datei in der neuesten Kernel-Version nicht behoben wurde.  Wir fragten uns: </p><br><ol><li>  Wo genau tritt das Problem auf? </li><li>  Warum passiert dies in NFS v4.0, aber nicht in v4.1? </li></ol><br><p>  Um diese Fragen zu beantworten, haben wir uns mit dem NFS-Quellcode befasst.  Wir hatten keinen Kernel-Debugger, also haben wir zwei Arten von Aufrufen an den Quellcode gesendet: </p><br><ol><li>  <code>pr_info()</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>   printk</code></a> ). </li><li>  <code>dump_stack()</code> : Zeigt den Stack-Trace für den aktuellen Funktionsaufruf an. </li></ol><br><p>  Als erstes haben wir beispielsweise eine Verbindung zur Funktion <code>nfs4_file_open()</code> in <code>fs/nfs/nfs4file.c</code> : </p><br><pre> <code class="plaintext hljs">static int nfs4_file_open(struct inode *inode, struct file *filp) { ... pr_info("nfs4_file_open start\n"); dump_stack();</code> </pre> <br><p>  Natürlich könnten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>  dprintk</code> mit dynamischem Linux-Debugging <code>  dprintk</code></a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>rpcdebug</code></a> , aber wir wollten unsere eigenen Nachrichten hinzufügen, um nach Änderungen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>rpcdebug</code></a> . </p><br><p>  Nach jeder Änderung haben wir das Modul neu kompiliert und es mit den folgenden Befehlen im Kernel neu installiert: </p><br><pre> <code class="plaintext hljs">make modules sudo umount /mnt/nfs-test sudo rmmod nfsv4 sudo rmmod nfs sudo insmod fs/nfs/nfs.ko sudo mount -a</code> </pre> <br><p>  Mit dem NFS-Modul konnten wir Experimente wiederholen und Nachrichten empfangen, um den NFS-Code zu verstehen.  Sie können beispielsweise sofort sehen, was passiert, wenn die Anwendung <code>open()</code> aufruft: </p><br><pre> <code class="plaintext hljs">Sep 24 20:20:38 test-kernel kernel: [ 1145.233460] Call Trace: Sep 24 20:20:38 test-kernel kernel: [ 1145.233462] dump_stack+0x8e/0xd5 Sep 24 20:20:38 test-kernel kernel: [ 1145.233480] nfs4_file_open+0x56/0x2a0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233488] ? nfs42_clone_file_range+0x1c0/0x1c0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233490] do_dentry_open+0x1f6/0x360 Sep 24 20:20:38 test-kernel kernel: [ 1145.233492] vfs_open+0x2f/0x40 Sep 24 20:20:38 test-kernel kernel: [ 1145.233493] path_openat+0x2e8/0x1690 Sep 24 20:20:38 test-kernel kernel: [ 1145.233496] ? mem_cgroup_try_charge+0x8b/0x190 Sep 24 20:20:38 test-kernel kernel: [ 1145.233497] do_filp_open+0x9b/0x110 Sep 24 20:20:38 test-kernel kernel: [ 1145.233499] ? __check_object_size+0xb8/0x1b0 Sep 24 20:20:38 test-kernel kernel: [ 1145.233501] ? __alloc_fd+0x46/0x170 Sep 24 20:20:38 test-kernel kernel: [ 1145.233503] do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233505] ? do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233507] __x64_sys_openat+0x20/0x30 Sep 24 20:20:38 test-kernel kernel: [ 1145.233508] do_syscall_64+0x65/0x130</code> </pre> <br><p>  Was sind diese <code>do_dentry_open</code> und <code>vfs_open</code> ?  Linux verfügt über ein virtuelles Dateisystem ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VFS</a> ), eine Abstraktionsschicht, die eine gemeinsame Schnittstelle für alle Dateisysteme bietet.  In der VFS-Dokumentation heißt es: </p><br><blockquote>  VFS implementiert open (2), stat (2), chmod (2) und andere Systemaufrufe.  Das VFS-System verwendet das an sie übergebene Pfadnamenargument, um den Cache nach Verzeichniseinträgen (Dentry-Cache oder Dcache) zu durchsuchen.  Dies bietet eine sehr schnelle Suchmaschine, die den Pfadnamen (oder Dateinamen) in ein bestimmtes Dentry konvertiert.  Dentry befindet sich im RAM und wird niemals auf der Festplatte gespeichert - sie dienen nur der Leistung. </blockquote><br><h3 id="i-nas-osenilo--a-chto-esli-problema-v-dentry-keshe">  Und es wurde uns klar - was ist, wenn das Problem im Dentry-Cache liegt? </h3><br><p>  Wir haben festgestellt, dass der Dentry-Cache normalerweise in <code>fs/nfs/dir.c</code>  Wir waren besonders an der Funktion <code>nfs4_lookup_revalidate()</code> interessiert und haben sie als Experiment früher zum <code>nfs4_lookup_revalidate()</code> : </p><br><pre> <code class="plaintext hljs">diff --git a/fs/nfs/dir.cb/fs/nfs/dir.c index 8bfaa658b2c1..ad479bfeb669 100644 --- a/fs/nfs/dir.c +++ b/fs/nfs/dir.c @@ -1159,6 +1159,7 @@ static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags) trace_nfs_lookup_revalidate_enter(dir, dentry, flags); error = NFS_PROTO(dir)-&gt;lookup(dir, &amp;dentry-&gt;d_name, fhandle, fattr, label); trace_nfs_lookup_revalidate_exit(dir, dentry, flags, error); + goto out_bad; if (error == -ESTALE || error == -ENOENT) goto out_bad; if (error)</code> </pre> <br><p>  Und in diesem Experiment ist kein veraltetes Dateiproblem aufgetreten!  Schließlich haben wir den Trail angegriffen. </p><br><p>  Um herauszufinden, warum das Problem in NFS v4.1 nicht aufgetreten ist, haben wir jedem <code>if</code> Block in dieser Funktion <code>pr_info()</code> -Aufrufe hinzugefügt.  Wir haben mit NFS v4.0 und v4.1 experimentiert und in Version v4.1 eine spezielle Bedingung gefunden: </p><br><pre> <code class="plaintext hljs">if (NFS_SB(dentry-&gt;d_sb)-&gt;caps &amp; NFS_CAP_ATOMIC_OPEN_V1) { goto no_open; }</code> </pre> <br><p>  Was ist <code>NFS_CAP_ATOMIC_OPEN_V1</code> ?  Dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kernel-Patch</a> besagt, dass dies eine Funktion von NFS v4.1 ist, und der Code in <code>fs/nfs/nfs4proc.c</code> bestätigt, dass dieser Parameter in v4.1, aber nicht in v4.0 enthalten ist: </p><br><pre> <code class="plaintext hljs">static const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = { .minor_version = 1, .init_caps = NFS_CAP_READDIRPLUS | NFS_CAP_ATOMIC_OPEN | NFS_CAP_POSIX_LOCK | NFS_CAP_STATEID_NFSV41 | NFS_CAP_ATOMIC_OPEN_V1</code> </pre> <br><p>  Daher haben sich die Versionen unterschiedlich verhalten - in Version <code>goto no_open</code> ruft <code>goto no_open</code> mehr Überprüfungen in der Funktion <code>nfs_lookup_revalidate()</code> , und in Version <code>nfs4_lookup_revalidate()</code> Funktion <code>nfs4_lookup_revalidate()</code> früher zurückgegeben.  Und wie haben wir das Problem gelöst? </p><br><h2 id="reshenie">  Lösung </h2><br><p>  Ich sprach über unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ergebnisse auf der NFS-Mailingliste</a> und schlug einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">primitiven Patch vor</a> .  Eine Woche später <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schickte</a> Trond Myklebust <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Reihe von Patches mit Fehlerkorrekturen an die Mailingliste und fand ein weiteres verwandtes Problem in NFS v4.1</a> . </p><br><p>  Es stellt sich heraus, dass das Update für den NFS v4.0-Fehler tiefer in der Codebasis lag als wir dachten.  Trond hat es im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch gut beschrieben</a> : </p><br><blockquote>  Es muss sichergestellt werden, dass Inode und Dentry beim Öffnen einer bereits geöffneten Datei korrekt überprüft werden.  Im Moment überprüfen wir weder NFSv4.0 noch zweimal, da die geöffnete Datei zwischengespeichert wird.  Lassen Sie uns dies beheben und geöffnete Dateien nur in besonderen Fällen zwischenspeichern, um geöffnete Dateien wiederherzustellen und die Delegierung zurückzugeben. </blockquote><p>  Wir haben sichergestellt, dass dieses Update das veraltete Dateiproblem löst, und Fehlerberichte an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ubuntu-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RedHat-</a> Teams gesendet. </p><br><p>  Wir haben gut verstanden, dass die Änderungen noch nicht in der stabilen Kernel-Version enthalten sind, und haben daher eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorübergehende Lösung für dieses Problem in Gitaly hinzugefügt</a> .  Wir haben experimentiert und überprüft, dass der Kernel beim Aufrufen von <code>stat()</code> in der Datei <code>packed-refs</code> die umbenannte Datei im Dentry-Cache überprüft.  Der Einfachheit halber haben wir dies in Gitaly für jedes Dateisystem implementiert, nicht nur für NFS.  Die Validierung wird nur einmal durchgeführt, bevor Gitaly das Repository öffnet, und für andere Dateien gibt es bereits andere <code>stat()</code> -Aufrufe. </p><br><h2 id="chemu-my-nauchilis">  Was haben wir gelernt? </h2><br><p>  Ein Fehler kann sich in jeder Ecke des Software-Stacks verstecken, und manchmal müssen Sie ihn außerhalb der Anwendung suchen.  Wenn Sie nützliche Verbindungen in der Open Source-Welt haben, wird dies Ihre Arbeit erleichtern. </p><br><p>  Vielen Dank an Trond Myuklebust für die Behebung des Problems und an Bruce Fields für die Beantwortung unserer Fragen und die Unterstützung bei der Ermittlung von NFS.  Für diese Reaktionsfähigkeit und Professionalität schätzen wir die Community der Open Source-Entwickler. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432922/">https://habr.com/ru/post/de432922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432910/index.html">Es ist gefährlich, die virtuelle Realität als Maschine für Empathie zu betrachten</a></li>
<li><a href="../de432912/index.html">So erhalten Sie ein Praktikum bei Google</a></li>
<li><a href="../de432914/index.html">Ein sehr einfacher Chat-Bot für Telegramm für die Kleinsten</a></li>
<li><a href="../de432918/index.html">Entschuldigung, ich habe Ihre recovery.conf gebrochen</a></li>
<li><a href="../de432920/index.html">Der menschliche Faktor im Unternehmen: Ist es gefährlich?</a></li>
<li><a href="../de432926/index.html">24 Rezepte, wie ein Startup auf einer riesigen Weltausstellung erfolgreich sein kann, am Beispiel des Web Summit 2018</a></li>
<li><a href="../de432928/index.html">Was passiert bei Intel und warum wird Amazon AWS trotz lauter Schlagzeilen nicht vollständig auf seine Chips übertragen?</a></li>
<li><a href="../de432930/index.html">Exploit Mittwoch Dezember 2018: Um die neuen Zeitabschnitte zu testen, fuhren sie ...</a></li>
<li><a href="../de432932/index.html">Ökosystem der digitalen Beschaffungswelt (um weniger zu stehlen)</a></li>
<li><a href="../de432934/index.html">Leicht zugängliche Levitation im Ultraschall</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>