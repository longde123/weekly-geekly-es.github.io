<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ô üöä üñïüèΩ Wie wir zwei Wochen lang nach NFS-Fehlern im Linux-Kernel gesucht haben üöª ‚õµÔ∏è üë¶üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine detaillierte Beschreibung der Fehlersuche aus der GitLab-Task, die zum Patch f√ºr den Linux-Kernel f√ºhrte 


 Am 14. September meldete der GitLab-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir zwei Wochen lang nach NFS-Fehlern im Linux-Kernel gesucht haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/432922/"><h3 id="podrobnoe-opisanie-poiskov-baga-iz-zadachi-gitlab-kotorye-priveli-k-patchu-dlya-yadra-linux">  Eine detaillierte Beschreibung der Fehlersuche aus der GitLab-Task, die zum Patch f√ºr den Linux-Kernel f√ºhrte </h3><br><p> Am 14. September meldete der GitLab-Support ein kritisches Problem, das bei einem unserer Kunden aufgetreten ist: Zuerst funktioniert GitLab einwandfrei, und dann erhalten Benutzer eine Fehlermeldung.  Sie versuchten, einige Repositorys √ºber Git zu klonen, und pl√∂tzlich erschien eine unverst√§ndliche Meldung √ºber eine veraltete Datei: Veralteter <code>Stale file error</code> .  Der Fehler blieb lange bestehen und funktionierte erst, als der Systemadministrator <code>ls</code> manuell im Verzeichnis selbst startete. </p><br><p>  Ich musste die internen Mechanismen von Git und dem NFS-Netzwerkdateisystem untersuchen.  Infolgedessen haben wir einen Fehler im Linux v4.0 NFS-Client gefunden. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trond Myklebust hat einen Patch f√ºr den Kernel geschrieben</a> . Seit dem 26. Oktober ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Patch im Haupt-Linux-Kernel enthalten</a> . </p><br><p>  In diesem Beitrag werde ich Ihnen erz√§hlen, wie wir das Problem untersucht haben, in welche Richtung wir gedacht haben und mit welchen Tools wir den Fehler verfolgt haben.  Wir waren inspiriert von der exzellenten Detektivarbeit von Oleg Dashevsky, die in dem Beitrag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûWie ich zwei Wochen lang in Ruby nach einem Ged√§chtnisleck</a> gesucht habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äú beschrieben wurde</a> . </p><br><img src="https://habrastorage.org/webt/es/0f/-7/es0f-7dbqlnheksnnmxtlwawlic.jpeg"><a name="habracut"></a><br><p>  Es ist auch ein gro√üartiges Beispiel daf√ºr, wie Open Source-Debugging ein Mannschaftssport ist, an dem viele Menschen, Unternehmen und L√§nder beteiligt sind.  Das Motto von GitLab ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jeder kann etwas beitragen</a> ‚Äú gilt nicht nur f√ºr GitLab selbst, sondern auch f√ºr andere Open-Source-Projekte wie den Linux-Kernel. </p><br><h3 id="vosproizvedenie-baga">  Fehlerreproduktion </h3><br><p>  Wir haben NFS viele Jahre auf GitLab.com gespeichert, es dann jedoch nicht mehr f√ºr den Zugriff auf Repository-Daten auf Computern mit Anwendungen verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir haben alle Git-Anrufe nach Gitaly verschoben</a> .  Wir unterst√ºtzen NFS f√ºr Clients, die ihre Installationen auf GitLab verwalten, jedoch noch nie auf dasselbe Problem wie der oben genannte Client gesto√üen sind. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Kunde gab einige n√ºtzliche Hinweise</a> : </p><br><ol><li>  Vollst√§ndiger Fehlertext: <code>fatal: Couldn't read ./packed-refs: Stale file handle</code> . </li><li>  Anscheinend trat das Problem auf, als der Client die <code>git gc</code> in Git mit dem Befehl <code>git gc</code> manuell startete. </li><li>  Der Fehler verschwand, als der Systemadministrator das Dienstprogramm <code>ls</code> im Verzeichnis startete. </li><li>  Der Fehler verschwand, als der <code>git gc</code> Prozess beendet wurde. </li></ol><br><p>  Es ist klar, dass die ersten beiden Punkte miteinander verbunden sind.  Wenn Sie √Ñnderungen an den Git-Zweig senden, erstellt Git einen schwachen Link - einen langen Dateinamen, der den Zweignamen f√ºr das Commit angibt.  Beim Senden an den <code>master</code> wird beispielsweise eine Datei mit dem Namen <code>refs/heads/master</code> im Repository erstellt: </p><br><pre> <code class="plaintext hljs">$ cat refs/heads/master 2e33a554576d06d9e71bfd6814ee9ba3a7838963</code> </pre> <br><p>  Der Befehl <code>git gc</code> f√ºhrt mehrere Aufgaben aus.  Beispielsweise werden diese schwachen Links (Refs) gesammelt und in eine einzelne Datei mit dem Namen Packed <code>packed-refs</code> .  Dies beschleunigt die Arbeit etwas, da das Lesen einer gro√üen Datei einfacher ist als bei vielen kleinen.  Nach dem Ausf√ºhren des <code>git gc</code> die <code>packed-refs</code> Datei beispielsweise folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs"># pack-refs with: peeled fully-peeled sorted 564c3424d6f9175cf5f2d522e10d20d781511bf1 refs/heads/10-8-stable edb037cbc85225261e8ede5455be4aad771ba3bb refs/heads/11-0-stable 94b9323033693af247128c8648023fe5b53e80f9 refs/heads/11-1-stable 2e33a554576d06d9e71bfd6814ee9ba3a7838963 refs/heads/master</code> </pre> <br><p>  Wie wird die <code>packed-refs</code> Datei erstellt?  Um dies herauszufinden, haben wir den Befehl <code>strace git gc</code> ausgef√ºhrt, bei dem wir ein schwaches Glied hatten.  Hier sind die Zeilen, die relevant sind: </p><br><pre> <code class="plaintext hljs">28705 open("/tmp/libgit2/.git/packed-refs.lock", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 3 28705 open(".git/packed-refs", O_RDONLY) = 3 28705 open("/tmp/libgit2/.git/packed-refs.new", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 4 28705 rename("/tmp/libgit2/.git/packed-refs.new", "/tmp/libgit2/.git/packed-refs") = 0 28705 unlink("/tmp/libgit2/.git/packed-refs.lock") = 0</code> </pre> <br><p>  Systemaufrufe zeigten, dass der Befehl <code>git gc</code> : </p><br><ol><li>  <code>packed-refs.lock</code> .  Dies teilt anderen Prozessen mit, dass die <code>packed-refs</code> gesperrt ist und sich nicht √§ndern kann. </li><li>  Ge√∂ffnet <code>packed-refs.new</code> . </li><li>  Ich habe schwache Glieder in <code>packed-refs.new</code> . </li><li>  Umbenannt in <code>packed-refs.new</code> <code>packed-refs</code> . <code>packed-refs.new</code> in <code>packed-refs.new</code> <code>packed-refs</code> . </li><li>  <code>packed-refs.lock</code> . </li><li>  Schwache Glieder entfernt. </li></ol><br><p>  Der entscheidende Punkt hier ist der vierte, <code>packed-refs</code> Umbenennen, bei dem Git die <code>packed-refs</code> einf√ºhrt.  <code>git gc</code> sammelt nicht nur schwache Glieder, sondern f√ºhrt auch eine viel ressourcenintensivere Aufgabe aus - es sucht und entfernt nicht verwendete Objekte.  In gro√üen Repositories kann dies l√§nger als eine Stunde dauern. </p><br><p>  Und wir haben uns gefragt: <code>git gc</code> in gro√üen Repositories die Datei w√§hrend der Reinigung offen?  Wir haben die <code>strace</code> Protokolle untersucht, das Dienstprogramm <code>lsof</code> gestartet und <code>git gc</code> √ºber den <code>git gc</code> Prozess <code>git gc</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/493/51d/077/49351d077382c8b70317346789331c81.svg" alt="Bild"></p><br><p>  Wie Sie sehen k√∂nnen, wird die <code>packed-refs</code> ganz am Ende geschlossen, nachdem der m√∂glicherweise lange Prozess der <code>Garbage collect objects</code> . </p><br><p>  Es stellte sich also die folgende Frage: Wie verh√§lt sich NFS, wenn die <code>packed-refs</code> auf einem Knoten ge√∂ffnet ist und der andere sie zu diesem Zeitpunkt umbenennt? </p><br><p>  "Aus wissenschaftlichen Gr√ºnden" baten wir den Kunden, ein Experiment auf zwei verschiedenen Maschinen (Alice und Bob) durchzuf√ºhren: <br>  1) Erstellen Sie auf dem gemeinsam genutzten NFS-Volume zwei Dateien: <code>test1.txt</code> und <code>test2.txt</code> mit unterschiedlichen Inhalten, damit Sie leichter zwischen ihnen unterscheiden k√∂nnen: </p><br><pre> <code class="plaintext hljs">alice $ echo "1 - Old file" &gt; /path/to/nfs/test1.txt alice $ echo "2 - New file" &gt; /path/to/nfs/test2.txt</code> </pre> <br><p>  2) Auf Alices <code>test1.txt</code> sollte die Datei <code>test1.txt</code> ge√∂ffnet sein: </p><br><pre> <code class="plaintext hljs">alice $ irb irb(main):001:0&gt; File.open('/path/to/nfs/test1.txt')</code> </pre> <br><p>  3) Zeigen Sie auf Alices Computer kontinuierlich den Inhalt von <code>test1.txt</code> : </p><br><pre> <code class="plaintext hljs">alice $ while true; do cat test1.txt; done</code> </pre> <br><p>  4) F√ºhren Sie dann auf Bobs Computer den folgenden Befehl aus: </p><br><pre> <code class="plaintext hljs">bob $ mv -f test2.txt test1.txt</code> </pre> <br><p>  Der letzte Schritt reproduziert, was <code>git gc</code> mit der <code>packed-refs</code> Datei macht, wenn eine vorhandene Datei √ºberschrieben wird. <br>  Auf dem Computer des Clients sah das Ergebnis ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file cat: test1.txt: Stale file handle</code> </pre> <br><p>  Da ist!  Wir scheinen das Problem auf kontrollierte Weise kontrolliert zu haben.  Im selben Experiment auf einem Linux-NFS-Server trat dieses Problem jedoch nicht auf.  Das Ergebnis wurde erwartet - nach dem Umbenennen wurde der neue Inhalt akzeptiert: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 2 - New file &lt;--- RENAME HAPPENED 2 - New file 2 - New file</code> </pre> <br><p>  Woher kommt dieser Unterschied im Verhalten?  Es stellt sich heraus, dass der Client <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isilon NFS-</a> Speicher verwendet hat, der nur NFS v4.0 unterst√ºtzt.  Als wir die Verbindungseinstellungen mit dem Parameter <code>vers=4.0</code> in <code>/etc/fstab</code> auf v4.0 √§nderten, ergab der Test ein anderes Ergebnis f√ºr den Linux-NFS-Server: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 1 - Old file &lt;--- RENAME HAPPENED 1 - Old file 1 - Old file</code> </pre> <br><p>  Anstelle des veralteten Dateihandles Veraltetes Dateihandle zeigte <code>Stale file handle</code> Linux NFS v4.0-Server veralteten <em>Inhalt an</em> .  Es stellt sich heraus, dass der Unterschied im Verhalten durch die NFS-Spezifikationen erkl√§rt werden kann.  Aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 3010</a> : </p><br><blockquote>  Der Dateideskriptor ist m√∂glicherweise veraltet oder l√§uft beim Umbenennen ab, jedoch nicht immer.  Server-Implementierern wird empfohlen, Ma√ünahmen zu ergreifen, um sicherzustellen, dass Dateideskriptoren nicht ablaufen und auf diese Weise nicht ablaufen. </blockquote><p>  Mit anderen Worten, NFS-Server k√∂nnen festlegen, wie sie sich beim Umbenennen einer Datei verhalten <code>Stale file error</code> , und der NFS-Server gibt in solchen F√§llen vern√ºnftigerweise einen <code>Stale file error</code> .  Wir haben vorgeschlagen, dass die Ursache des Problems dieselbe ist, obwohl die Ergebnisse unterschiedlich waren.  Wir haben vermutet, dass es sich um eine Cache-Pr√ºfung handelt, da das Dienstprogramm <code>ls</code> im Verzeichnis den Fehler behoben hat.  Jetzt hatten wir ein reproduzierbares Testszenario und wandten uns an Experten - Linux NFS-Betreuer. </p><br><h2 id="lozhnyy-sled-delegirovanie-na-nfs-servere">  False Trace: Delegierung auf einem NFS-Server </h2><br><p>  Als wir es geschafft haben, den Fehler Schritt f√ºr Schritt zu reproduzieren, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schrieb</a> ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an die Linux-NFS-Kontakte,</a> was wir gelernt haben.  Ich korrespondierte eine Woche lang mit Bruce Fields, dem Linux-NFS-Server-Betreuer, und er schlug vor, dass der Fehler in NFS lag und ich den Netzwerkverkehr untersuchen musste.  Er dachte, das Problem sei das Delegieren von Aufgaben auf dem NFS-Server. </p><br><h3 id="chto-takoe-delegirovanie-na-nfs-servere">  Was ist eine Delegierung auf einem NFS-Server? </h3><br><p>  Kurz gesagt, die NFS v4-Version verf√ºgt √ºber eine Delegierungsfunktion, um den Dateizugriff zu beschleunigen.  Der Server kann Lese- oder Schreibzugriff an den Client delegieren, sodass der Client den Server nicht st√§ndig fragen muss, ob die Datei von einem anderen Client ge√§ndert wurde.  Einfach ausgedr√ºckt bedeutet das Delegieren einer Aufzeichnung, dass Sie jemandem Ihr Notizbuch leihen und sagen: "Sie schreiben hier, und ich werde es abholen, wenn ich bereit bin."  Und eine Person muss nicht jedes Mal nach einem Notizbuch fragen, wenn Sie etwas schreiben m√ºssen - sie hat v√∂llige Handlungsfreiheit, bis das Notizbuch weggenommen wird.  In NFS wird eine Anforderung zur R√ºckgabe eines Notizbuchs als Delegierungssperrung bezeichnet. </p><br><p>  Ein Fehler beim Widerruf der NFS-Delegierung k√∂nnte das Problem des <code>Stale file handle</code> erkl√§ren.  Denken <code>test1.txt</code> daran, wie <code>test1.txt</code> in Alices <code>test1.txt</code> ge√∂ffnet und dann durch <code>test2.txt</code> ersetzt wurde.  M√∂glicherweise konnte der Server die Delegierung f√ºr <code>test1.txt</code> nicht widerrufen, was zu einem ung√ºltigen Status f√ºhrte.  Um diese Theorie zu testen, haben wir den NFC-Verkehr mit dem Dienstprogramm <code>tcpdump</code> aufgezeichnet und mit Wireshark visualisiert. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wireshark</a> ist ein gro√üartiges Open-Source-Tool zur Analyse des Netzwerkverkehrs, insbesondere zur Erkundung von NFS in Aktion.  Wir haben den Trace mit dem folgenden Befehl auf einem NFS-Server aufgezeichnet: </p><br><pre> <code class="plaintext hljs">tcpdump -s 0 -w /tmp/nfs.pcap port 2049</code> </pre> <br><p>  Dieser Befehl zeichnet den gesamten NFS-Verkehr auf, der normalerweise √ºber den TCP-Port 2049 geleitet wird. Da unser Experiment mit NFS v4.1, jedoch nicht mit NFS v4.0 erfolgreich war, konnten wir das Verhalten von NFS im funktionierenden und im nicht funktionierenden Fall vergleichen.  Bei Wireshark haben wir folgendes Verhalten festgestellt: </p><br><h3 id="nfs-v40-ustarevshiy-fayl">  NFS v4.0 (veraltete Datei) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a1/0bb/e23/6a10bbe2304b155431010aa4ca577fa7.svg" alt="Bild"></p><br><p>  Dieses Diagramm zeigt, dass Alice in Schritt 1 <code>test1.txt</code> √∂ffnet und einen NFS-Dateideskriptor mit der Kennung <code>stateid</code> 0x3000 empf√§ngt.  Wenn Bob versucht, die Datei umzubenennen, fordert der NFS-Server erneut zum Versuch auf, indem er die Nachricht <code>NFS4ERR_DELAY</code> , und er ruft die Delegierung von Alice √ºber die Nachricht <code>CB_RECALL</code> (Schritt 3).  Alice gibt die Delegierung zur√ºck (DELEGRETURN in Schritt 4) und Bob versucht erneut, die <code>RENAME</code> Nachricht zu senden (Schritt 5).  <code>RENAME</code> wird in beiden F√§llen ausgef√ºhrt, aber Alice liest die Datei weiterhin mit demselben Deskriptor. </p><br><h3 id="nfs-v41-rabochiy-sluchay">  NFS v4.1 (Arbeitsfall) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3d/1a3/d49/f3d1a3d49e803d73a4dd7f830e9b238a.svg" alt="Bild"></p><br><p>  Hier ist der Unterschied in Schritt 6 sichtbar. In NFS v4.0 (mit einer veralteten Datei) versucht Alice <code>stateid</code> dieselbe <code>stateid</code> .  In NFS v4.1 (Arbeitsfall) f√ºhrt Alice zus√§tzliche <code>LOOKUP</code> und <code>OPEN</code> Operationen aus, sodass der Server eine andere <code>stateid</code> .  In v4.0 werden keine zus√§tzlichen Nachrichten gesendet.  Dies erkl√§rt, warum Alice veraltete Inhalte sieht - sie verwendet einen alten Deskriptor. </p><br><p>  Warum entscheidet sich Alice pl√∂tzlich f√ºr einen zus√§tzlichen <code>LOOKUP</code> ?  Anscheinend war der R√ºckruf der Delegation erfolgreich, aber anscheinend blieb ein Problem bestehen.  Beispielsweise wird der Behinderungsschritt √ºbersprungen.  Um dies zu √ºberpr√ºfen, haben wir die NFS-Delegierung auf dem NFS-Server selbst mit diesem Befehl ausgeschlossen: </p><br><pre> <code class="plaintext hljs">echo 0 &gt; /proc/sys/fs/leases-enable</code> </pre> <br><p>  Wir haben das Experiment wiederholt, aber das Problem ist nicht verschwunden.  Wir haben sichergestellt, dass das Problem nicht auf dem NFS-Server oder der Delegierung liegt, und beschlossen, den NFS-Client im Kernel zu untersuchen. </p><br><h2 id="kopaem-glubzhe-linux-nfs-klient">  Tiefer graben: Linux NFS-Client </h2><br><p>  Die erste Frage, die wir den NFS-Betreuern beantworten mussten, war: </p><br><h3 id="eta-problema-sohranyaetsya-v-posledney-versii-yadra">  Bleibt dieses Problem in der neuesten Kernel-Version bestehen? </h3><br><p>  Das Problem trat in den Kerneln CentOS 7.2 und Ubuntu 16.04 mit den Versionen 3.10.0-862.11.6 bzw. 4.4.0-130 auf.  Beide Kerne blieben jedoch hinter der neuesten Version zur√ºck, die zu diesem Zeitpunkt 4,19-rc2 betrug. </p><br><p>  Wir haben die neue virtuelle Maschine Ubuntu 16.04 auf der Google Cloud Platform (GCP) bereitgestellt, den neuesten Linux-Kernel geklont und die Kernel-Entwicklungsumgebung eingerichtet.  Wir haben die <code>.config</code> Datei mit <code>menuconfig</code> und <code>menuconfig</code> √ºberpr√ºft: </p><br><ol><li>  Der NFS-Treiber wird als Modul kompiliert ( <code>CONFIG_NFSD=m</code> ). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die</a> korrekten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GCP-Kernelparameter</a> sind korrekt angegeben. </li></ol><br><p>  Genetics verfolgt die Entwicklung in Echtzeit von Drosophila, und mit dem ersten Element konnten wir schnell Korrekturen am NFS-Client vornehmen, ohne den Kernel neu zu starten.  Der zweite Punkt garantierte, dass der Kernel nach der Installation gestartet wird.  Gl√ºcklicherweise waren wir mit den Standard-Kernel-Parametern zufrieden. </p><br><p>  Wir haben daf√ºr gesorgt, dass das Problem der veralteten Datei in der neuesten Kernel-Version nicht behoben wurde.  Wir fragten uns: </p><br><ol><li>  Wo genau tritt das Problem auf? </li><li>  Warum passiert dies in NFS v4.0, aber nicht in v4.1? </li></ol><br><p>  Um diese Fragen zu beantworten, haben wir uns mit dem NFS-Quellcode befasst.  Wir hatten keinen Kernel-Debugger, also haben wir zwei Arten von Aufrufen an den Quellcode gesendet: </p><br><ol><li>  <code>pr_info()</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>   printk</code></a> ). </li><li>  <code>dump_stack()</code> : Zeigt den Stack-Trace f√ºr den aktuellen Funktionsaufruf an. </li></ol><br><p>  Als erstes haben wir beispielsweise eine Verbindung zur Funktion <code>nfs4_file_open()</code> in <code>fs/nfs/nfs4file.c</code> : </p><br><pre> <code class="plaintext hljs">static int nfs4_file_open(struct inode *inode, struct file *filp) { ... pr_info("nfs4_file_open start\n"); dump_stack();</code> </pre> <br><p>  Nat√ºrlich k√∂nnten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>  dprintk</code> mit dynamischem Linux-Debugging <code>  dprintk</code></a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>rpcdebug</code></a> , aber wir wollten unsere eigenen Nachrichten hinzuf√ºgen, um nach √Ñnderungen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>rpcdebug</code></a> . </p><br><p>  Nach jeder √Ñnderung haben wir das Modul neu kompiliert und es mit den folgenden Befehlen im Kernel neu installiert: </p><br><pre> <code class="plaintext hljs">make modules sudo umount /mnt/nfs-test sudo rmmod nfsv4 sudo rmmod nfs sudo insmod fs/nfs/nfs.ko sudo mount -a</code> </pre> <br><p>  Mit dem NFS-Modul konnten wir Experimente wiederholen und Nachrichten empfangen, um den NFS-Code zu verstehen.  Sie k√∂nnen beispielsweise sofort sehen, was passiert, wenn die Anwendung <code>open()</code> aufruft: </p><br><pre> <code class="plaintext hljs">Sep 24 20:20:38 test-kernel kernel: [ 1145.233460] Call Trace: Sep 24 20:20:38 test-kernel kernel: [ 1145.233462] dump_stack+0x8e/0xd5 Sep 24 20:20:38 test-kernel kernel: [ 1145.233480] nfs4_file_open+0x56/0x2a0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233488] ? nfs42_clone_file_range+0x1c0/0x1c0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233490] do_dentry_open+0x1f6/0x360 Sep 24 20:20:38 test-kernel kernel: [ 1145.233492] vfs_open+0x2f/0x40 Sep 24 20:20:38 test-kernel kernel: [ 1145.233493] path_openat+0x2e8/0x1690 Sep 24 20:20:38 test-kernel kernel: [ 1145.233496] ? mem_cgroup_try_charge+0x8b/0x190 Sep 24 20:20:38 test-kernel kernel: [ 1145.233497] do_filp_open+0x9b/0x110 Sep 24 20:20:38 test-kernel kernel: [ 1145.233499] ? __check_object_size+0xb8/0x1b0 Sep 24 20:20:38 test-kernel kernel: [ 1145.233501] ? __alloc_fd+0x46/0x170 Sep 24 20:20:38 test-kernel kernel: [ 1145.233503] do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233505] ? do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233507] __x64_sys_openat+0x20/0x30 Sep 24 20:20:38 test-kernel kernel: [ 1145.233508] do_syscall_64+0x65/0x130</code> </pre> <br><p>  Was sind diese <code>do_dentry_open</code> und <code>vfs_open</code> ?  Linux verf√ºgt √ºber ein virtuelles Dateisystem ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VFS</a> ), eine Abstraktionsschicht, die eine gemeinsame Schnittstelle f√ºr alle Dateisysteme bietet.  In der VFS-Dokumentation hei√üt es: </p><br><blockquote>  VFS implementiert open (2), stat (2), chmod (2) und andere Systemaufrufe.  Das VFS-System verwendet das an sie √ºbergebene Pfadnamenargument, um den Cache nach Verzeichniseintr√§gen (Dentry-Cache oder Dcache) zu durchsuchen.  Dies bietet eine sehr schnelle Suchmaschine, die den Pfadnamen (oder Dateinamen) in ein bestimmtes Dentry konvertiert.  Dentry befindet sich im RAM und wird niemals auf der Festplatte gespeichert - sie dienen nur der Leistung. </blockquote><br><h3 id="i-nas-osenilo--a-chto-esli-problema-v-dentry-keshe">  Und es wurde uns klar - was ist, wenn das Problem im Dentry-Cache liegt? </h3><br><p>  Wir haben festgestellt, dass der Dentry-Cache normalerweise in <code>fs/nfs/dir.c</code>  Wir waren besonders an der Funktion <code>nfs4_lookup_revalidate()</code> interessiert und haben sie als Experiment fr√ºher zum <code>nfs4_lookup_revalidate()</code> : </p><br><pre> <code class="plaintext hljs">diff --git a/fs/nfs/dir.cb/fs/nfs/dir.c index 8bfaa658b2c1..ad479bfeb669 100644 --- a/fs/nfs/dir.c +++ b/fs/nfs/dir.c @@ -1159,6 +1159,7 @@ static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags) trace_nfs_lookup_revalidate_enter(dir, dentry, flags); error = NFS_PROTO(dir)-&gt;lookup(dir, &amp;dentry-&gt;d_name, fhandle, fattr, label); trace_nfs_lookup_revalidate_exit(dir, dentry, flags, error); + goto out_bad; if (error == -ESTALE || error == -ENOENT) goto out_bad; if (error)</code> </pre> <br><p>  Und in diesem Experiment ist kein veraltetes Dateiproblem aufgetreten!  Schlie√ülich haben wir den Trail angegriffen. </p><br><p>  Um herauszufinden, warum das Problem in NFS v4.1 nicht aufgetreten ist, haben wir jedem <code>if</code> Block in dieser Funktion <code>pr_info()</code> -Aufrufe hinzugef√ºgt.  Wir haben mit NFS v4.0 und v4.1 experimentiert und in Version v4.1 eine spezielle Bedingung gefunden: </p><br><pre> <code class="plaintext hljs">if (NFS_SB(dentry-&gt;d_sb)-&gt;caps &amp; NFS_CAP_ATOMIC_OPEN_V1) { goto no_open; }</code> </pre> <br><p>  Was ist <code>NFS_CAP_ATOMIC_OPEN_V1</code> ?  Dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kernel-Patch</a> besagt, dass dies eine Funktion von NFS v4.1 ist, und der Code in <code>fs/nfs/nfs4proc.c</code> best√§tigt, dass dieser Parameter in v4.1, aber nicht in v4.0 enthalten ist: </p><br><pre> <code class="plaintext hljs">static const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = { .minor_version = 1, .init_caps = NFS_CAP_READDIRPLUS | NFS_CAP_ATOMIC_OPEN | NFS_CAP_POSIX_LOCK | NFS_CAP_STATEID_NFSV41 | NFS_CAP_ATOMIC_OPEN_V1</code> </pre> <br><p>  Daher haben sich die Versionen unterschiedlich verhalten - in Version <code>goto no_open</code> ruft <code>goto no_open</code> mehr √úberpr√ºfungen in der Funktion <code>nfs_lookup_revalidate()</code> , und in Version <code>nfs4_lookup_revalidate()</code> Funktion <code>nfs4_lookup_revalidate()</code> fr√ºher zur√ºckgegeben.  Und wie haben wir das Problem gel√∂st? </p><br><h2 id="reshenie">  L√∂sung </h2><br><p>  Ich sprach √ºber unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ergebnisse auf der NFS-Mailingliste</a> und schlug einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">primitiven Patch vor</a> .  Eine Woche sp√§ter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schickte</a> Trond Myklebust <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Reihe von Patches mit Fehlerkorrekturen an die Mailingliste und fand ein weiteres verwandtes Problem in NFS v4.1</a> . </p><br><p>  Es stellt sich heraus, dass das Update f√ºr den NFS v4.0-Fehler tiefer in der Codebasis lag als wir dachten.  Trond hat es im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch gut beschrieben</a> : </p><br><blockquote>  Es muss sichergestellt werden, dass Inode und Dentry beim √ñffnen einer bereits ge√∂ffneten Datei korrekt √ºberpr√ºft werden.  Im Moment √ºberpr√ºfen wir weder NFSv4.0 noch zweimal, da die ge√∂ffnete Datei zwischengespeichert wird.  Lassen Sie uns dies beheben und ge√∂ffnete Dateien nur in besonderen F√§llen zwischenspeichern, um ge√∂ffnete Dateien wiederherzustellen und die Delegierung zur√ºckzugeben. </blockquote><p>  Wir haben sichergestellt, dass dieses Update das veraltete Dateiproblem l√∂st, und Fehlerberichte an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ubuntu-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RedHat-</a> Teams gesendet. </p><br><p>  Wir haben gut verstanden, dass die √Ñnderungen noch nicht in der stabilen Kernel-Version enthalten sind, und haben daher eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vor√ºbergehende L√∂sung f√ºr dieses Problem in Gitaly hinzugef√ºgt</a> .  Wir haben experimentiert und √ºberpr√ºft, dass der Kernel beim Aufrufen von <code>stat()</code> in der Datei <code>packed-refs</code> die umbenannte Datei im Dentry-Cache √ºberpr√ºft.  Der Einfachheit halber haben wir dies in Gitaly f√ºr jedes Dateisystem implementiert, nicht nur f√ºr NFS.  Die Validierung wird nur einmal durchgef√ºhrt, bevor Gitaly das Repository √∂ffnet, und f√ºr andere Dateien gibt es bereits andere <code>stat()</code> -Aufrufe. </p><br><h2 id="chemu-my-nauchilis">  Was haben wir gelernt? </h2><br><p>  Ein Fehler kann sich in jeder Ecke des Software-Stacks verstecken, und manchmal m√ºssen Sie ihn au√üerhalb der Anwendung suchen.  Wenn Sie n√ºtzliche Verbindungen in der Open Source-Welt haben, wird dies Ihre Arbeit erleichtern. </p><br><p>  Vielen Dank an Trond Myuklebust f√ºr die Behebung des Problems und an Bruce Fields f√ºr die Beantwortung unserer Fragen und die Unterst√ºtzung bei der Ermittlung von NFS.  F√ºr diese Reaktionsf√§higkeit und Professionalit√§t sch√§tzen wir die Community der Open Source-Entwickler. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432922/">https://habr.com/ru/post/de432922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432910/index.html">Es ist gef√§hrlich, die virtuelle Realit√§t als Maschine f√ºr Empathie zu betrachten</a></li>
<li><a href="../de432912/index.html">So erhalten Sie ein Praktikum bei Google</a></li>
<li><a href="../de432914/index.html">Ein sehr einfacher Chat-Bot f√ºr Telegramm f√ºr die Kleinsten</a></li>
<li><a href="../de432918/index.html">Entschuldigung, ich habe Ihre recovery.conf gebrochen</a></li>
<li><a href="../de432920/index.html">Der menschliche Faktor im Unternehmen: Ist es gef√§hrlich?</a></li>
<li><a href="../de432926/index.html">24 Rezepte, wie ein Startup auf einer riesigen Weltausstellung erfolgreich sein kann, am Beispiel des Web Summit 2018</a></li>
<li><a href="../de432928/index.html">Was passiert bei Intel und warum wird Amazon AWS trotz lauter Schlagzeilen nicht vollst√§ndig auf seine Chips √ºbertragen?</a></li>
<li><a href="../de432930/index.html">Exploit Mittwoch Dezember 2018: Um die neuen Zeitabschnitte zu testen, fuhren sie ...</a></li>
<li><a href="../de432932/index.html">√ñkosystem der digitalen Beschaffungswelt (um weniger zu stehlen)</a></li>
<li><a href="../de432934/index.html">Leicht zug√§ngliche Levitation im Ultraschall</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>