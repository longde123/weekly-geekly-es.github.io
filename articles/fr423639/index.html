<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß üïé üë©üèª‚Äçüéì √âcriture plus efficace de tableaux dans la m√©moire persistante d'un contrat intelligent dans Solidity ü§≤üèª üë∏üèæ ‚ô®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, j'ai d√ª travailler un peu avec la blockchain Ethereum . L'id√©e sur laquelle je travaillais exigeait de stocker un assez grand nombre d'enti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcriture plus efficace de tableaux dans la m√©moire persistante d'un contrat intelligent dans Solidity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423639/"> R√©cemment, j'ai d√ª travailler un peu avec la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blockchain Ethereum</a> .  L'id√©e sur laquelle je travaillais exigeait de stocker un assez grand nombre d'entiers directement sur la blockchain afin que le contrat intelligent y ait facilement acc√®s.  La plupart des le√ßons sur le d√©veloppement de contrats intelligents nous disent: "ne stockez pas beaucoup de donn√©es sur la blockchain, c'est cher!"  Mais combien co√ªte ¬´beaucoup¬ª et combien le prix devient-il trop √©lev√© pour une utilisation pratique?  J'ai d√ª d√©couvrir, parce que nous ne pouvions pas rendre nos donn√©es hors cha√Æne, l'id√©e s'est effondr√©e. <br><br>  Je commence √† peine √† travailler avec Solidity et EVM, donc cet article ne pr√©tend pas √™tre la v√©rit√© ultime, mais je n'ai pas pu trouver d'autres documents sur ce sujet ni en russe ni en anglais (bien qu'il soit tr√®s dommage que je ne l'ai pas rencontr√© auparavant) ), donc j'esp√®re que cela peut √™tre utile √† quelqu'un.  Eh bien, ou en dernier recours, cela peut √™tre utile pour moi si des camarades exp√©riment√©s me disent comment et o√π exactement je me trompe. <br><br>  Pour commencer, j'ai d√©cid√© de comprendre rapidement si nous pouvions le faire?  Prenons le type de contrat standard et r√©pandu - le jeton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ERC20</a> .  Au moins, un tel contrat stocke dans la blockchain la correspondance des adresses des personnes qui ont achet√© les jetons √† leurs soldes.  En r√©alit√©, seuls les soldes sont stock√©s, chacun prenant 32 octets (en fait, cela n'a aucun sens d'√©conomiser ici en raison des fonctionnalit√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solidity</a> et EVM).  Un jeton plus ou moins r√©ussi peut facilement avoir des dizaines de milliers de propri√©taires, et nous obtenons donc que le stockage d'environ 320 000 octets dans la blockchain est parfaitement acceptable.  Et nous n'en avons pas besoin de plus! <br><br><h2>  Approche na√Øve </h2><br>  Eh bien, essayons de sauvegarder nos donn√©es.  Une partie importante d'entre eux sont des entiers non sign√©s 8 bits, nous allons donc transf√©rer leur tableau dans le contrat et essayer de les √©crire dans la m√©moire morte: <br><a name="habracut"></a><br><pre><code class="javascript hljs">uint8[] m_test; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint8[] data</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ m_test = data; }</code> </pre> <br>  Dingo!  Cette fonction mange du gaz, comme si elle n'√©tait pas en elle-m√™me.  Une tentative de sauvegarde de 100 valeurs nous a co√ªt√© 814033 gaz, 8100 gaz par octet! <br><br>  Expirez et reculez vers la th√©orie.  Quel est le co√ªt minimum (en gaz) du stockage des donn√©es sur la blockchain Ethereum?  Il faut se rappeler que les donn√©es sont stock√©es dans des blocs de 32 octets.  EVM ne peut lire ou √©crire qu'un bloc entier √† la fois, donc id√©alement, les donn√©es √† √©crire doivent √™tre empaquet√©es aussi efficacement que possible afin qu'une seule commande d'√©criture √©conomise plus imm√©diatement.  Parce que cette m√™me commande d'enregistrement - SSTORE - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">co√ªte √† elle</a> seule <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">20 000 gaz</a> (si nous √©crivons dans une cellule m√©moire que nous n'avons pas √©crite auparavant).  Donc, notre minimum th√©orique, en ignorant toutes les autres d√©penses, est d'environ 625 gaz par octet.  Loin du 8100 que nous avons obtenu dans l'exemple ci-dessus!  Il est maintenant temps de creuser plus profond√©ment et de d√©couvrir qui mange notre gaz et comment l'arr√™ter. <br><br>  Notre premi√®re impulsion devrait √™tre de regarder le code g√©n√©r√© par le compilateur Solidity √† partir de notre ligne isol√©e (m_test = data), car il n'y a plus rien √† voir.  Ceci est une bonne impulsion correcte qui nous familiarisera avec un fait terrifiant - le compilateur √† cet endroit a g√©n√©r√© des horreurs anciennes que vous ne comprendrez pas √† premi√®re vue!  En jetant un coup d'≈ìil √† la liste, nous y voyons non seulement SSTORE (ce qui est pr√©vu), mais aussi SLOAD (chargement √† partir de la m√©moire morte) et m√™me EXP (exponentiation)!  Dans l'ensemble, cela semble √™tre un moyen tr√®s co√ªteux d'enregistrer des donn√©es.  Et le pire de tout, il devient tout √† fait √©vident que SSTORE est appel√© aussi, trop souvent.  Que se passe-t-il ici? <br><br>  Quelques trucs.  Il s'av√®re que le stockage d'entiers 8 bits est presque la pire chose que vous puissiez faire avec EVM / Solidity (l'article, un lien vers lequel j'ai cit√© au d√©but, en parle).  Nous perdons de la productivit√© (ce qui signifie que nous payons plus de gaz) √† chaque tour.  Premi√®rement, lorsque nous transmettons un tableau de valeurs 8 bits √† l'entr√©e de notre fonction, chacune se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©veloppe</a> √† 256 bits.  Autrement dit, seulement par la taille des donn√©es de transaction, nous perdons d√©j√† 32 fois!  Nice  Cependant, un lecteur attentif remarquera que le co√ªt de l'octet stock√© n'est toujours que 13 fois plus √©lev√© que le minimum th√©orique, et non 32, ce qui signifie que lorsque le contrat est d√©finitivement sauvegard√© en m√©moire, tout n'est pas si mal.  Voici la chose: lors de la sauvegarde, il contient toujours les donn√©es et dans la m√©moire permanente du contrat, nos num√©ros 8 bits seront stock√©s de la mani√®re la plus efficace, 32 pi√®ces dans chaque bloc de m√©moire.  Cela soul√®ve la question, mais comment est la conversion des nombres d√©compress√©s "256 bits" qui nous sont parvenus lors de l'entr√©e de la fonction dans une forme compact√©e?  La r√©ponse est "la mani√®re la plus stupide que je puisse imaginer". <br><br>  Si nous √©crivons tout ce qui se passe sous une forme simplifi√©e, notre ligne de code solitaire se transforme en un cycle √©trange: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.length; ++i) { <span class="hljs-comment"><span class="hljs-comment">//      ,    256-bit  8-bit uint8 from_value = uint8(data[i]); //  32-     -        ,     uint256 to_value = get_storage_data_at_offset(m_test, i); //        (    2  ) add_byte_to_value(to_value, i % 32, from_value); //  32-      set_storage_data_at_offset(m_test, i, to_value); }</span></span></code> </pre><br>  L'aspect de ce code n'est presque pas affect√© par l'activation ou la d√©sactivation de l'optimisation (au moins dans la version 0.4.24 du compilateur Solidity), et comme vous pouvez le voir, il appelle SSTORE (dans le cadre de set_storage_data_at_offset) 32 fois plus souvent que n√©cessaire (une fois pour chaque num√©ro de 8 bits, et pas une fois pour 32 de ces num√©ros).  Ce qui nous sauve du fiasco complet, c'est que le r√©enregistrement dans la m√™me cellule ne co√ªte pas 20 000, mais 5 000 gaz.  Donc, chaque 32 octets nous co√ªte 20 000 + 5 000 * 31 = 125 000 gaz, soit environ 4 000 gaz par octet.  Le reste de la valeur que nous avons vu ci-dessus provient de la lecture de la m√©moire (√©galement pas une op√©ration bon march√©) et d'autres calculs cach√©s dans le code ci-dessus dans les fonctions (et il y en a beaucoup). <br><br>  Eh bien, nous ne pouvons rien faire avec le compilateur, <s>nous allons donc chercher un bouton</s> .  Il ne reste plus qu'√† conclure qu'il n'est pas n√©cessaire de transf√©rer et de stocker dans les tableaux de contrats de nombres √† 8 bits de cette mani√®re. <br><br><h2>  Solution simple pour les nombres √† 8 bits </h2><br>  Et qu'est-ce qui est n√©cessaire?  Et donc: <br><br><pre> <code class="javascript hljs">bytes m_test; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes data</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ m_test = data; }</code> </pre><br>  Nous op√©rons dans tous les domaines de type octets.  Avec cette approche, enregistrer 100 valeurs co√ªtera 129914 de gaz - seulement 1300 de gaz par octet, 6 fois mieux que d'utiliser uint8 []!  Le co√ªt pour cela sera un inconv√©nient - les √©l√©ments d'un tableau d'octets de type sont de type bytes1, qui ne se convertit pas automatiquement en aucun des types entiers habituels, vous devrez donc mettre la conversion de type explicite aux bons endroits.  Pas tr√®s sympa, mais le gain est 6 fois plus cher que l'enregistrement, je pense que √ßa vaut le coup!  Et, oui, nous perdrons un peu lorsque nous travaillerons avec ces donn√©es plus tard, lors de la lecture, par rapport au stockage de chaque num√©ro en 256 bits, mais ici l'√©chelle commence √† avoir de l'importance: le gain de la sauvegarde de mille ou deux nombres de 8 bits sous forme compact√©e , selon la t√¢che, l'emportent sur les pertes lors de leur lecture ult√©rieure. <br><br>  Avant d'arriver √† cette approche, j'ai d'abord essay√© d'√©crire une fonction plus efficace pour enregistrer les donn√©es dans l'assembleur de macro local <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JULIA</a> , mais j'ai rencontr√© quelques probl√®mes qui ont rendu ma solution un peu moins efficace et ont donn√© une consommation d'environ 1530 de gaz par octet.  Cependant, il nous est toujours utile dans cet article, donc le travail n'a pas √©t√© fait en vain. <br><br>  De plus, je note que plus vous enregistrez de donn√©es √† la fois, moins le co√ªt par octet sort, ce qui sugg√®re qu'une partie du co√ªt est fixe.  Par exemple, si vous enregistrez 3000 valeurs, alors √† l'approche des octets, nous obtenons 900 gaz par octet. <br><br><h2>  Solution plus g√©n√©rale </h2><br>  Eh bien, √ßa va bien, √ßa se termine bien, non?  Mais nos probl√®mes ne se sont pas termin√©s ici, car parfois nous voulons √©crire non seulement des nombres 8 bits dans la m√©moire du contrat, mais aussi d'autres types de donn√©es qui ne correspondent pas directement au type d'octets.  Autrement dit, il est clair que tout peut √™tre encod√© dans le tampon d'octets, mais le r√©cup√©rer plus tard peut ne plus √™tre pratique, et m√™me co√ªteux en raison de gestes inutiles pour convertir la m√©moire brute au type souhait√©.  La fonction qui enregistre le tableau d'octets transmis dans un tableau du type souhait√© nous est donc toujours utile.  C'est assez simple, mais il m'a fallu beaucoup de temps pour trouver toutes les informations n√©cessaires et comprendre EVM et JULIA pour les √©crire, et tout cela n'a pas √©t√© collect√© en un seul endroit.  Par cons√©quent, je pense que ce sera utile si j'apporte ici ce que j'ai d√©terr√©. <br><br>  Pour commencer, parlons de la fa√ßon dont Solidity stocke un tableau en m√©moire.  Les tableaux sont un concept qui n'existe que dans le cadre de Solidity, EVM n'en sait rien, mais stocke simplement un tableau virtuel de 2 ^ 256 blocs de 32 octets.  Il est clair que les blocs vides ne sont pas stock√©s, mais en fait, nous avons une table de blocs non vides, dont la cl√© est un nombre de 256 bits.  Et c'est pr√©cis√©ment ce nombre que les commandes EVM SSTORE et SLOAD acceptent en entr√©e (ce n'est pas tout √† fait √©vident dans la documentation). <br><br>  Pour stocker des tableaux, Solidity fait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chose</a> si <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©licate</a> : premi√®rement, le tableau de blocs ¬´principal¬ª lui est allou√© quelque part dans la m√©moire constante, dans l'ordre habituel de placement des membres du contrat (ou structures, mais c'est une chanson distincte), comme s'il s'agissait nombre r√©gulier de 256 bits.  Cela garantit que le tableau re√ßoit un bloc complet, ind√©pendamment des autres variables stock√©es.  Ce bloc stocke la longueur du tableau.  Mais comme il n'est pas connu √† l'avance et peut changer (nous parlons ici de tableaux dynamiques), les auteurs de Solidity ont d√ª d√©terminer o√π placer les donn√©es du tableau afin qu'elles ne se croisent pas accidentellement avec les donn√©es d'un autre tableau.  Strictement parlant, c'est une t√¢che insoluble: si vous cr√©ez deux tableaux de plus de 2 ^ 128 de long, alors ils sont garantis de se croiser l√† o√π vous ne les placez pas, mais en pratique, personne ne devrait le faire, donc cette astuce simple est utilis√©e: prenez le hachage SHA3 du num√©ro du bloc principal du tableau , et le nombre r√©sultant est utilis√© comme cl√© dans la table des blocs (qui, je le rappelle, 2 ^ 256).  Par cette cl√©, le premier bloc de donn√©es du tableau est plac√©, et le reste - s√©quentiellement apr√®s, si n√©cessaire.  La probabilit√© de collision de r√©seaux non g√©ants est extr√™mement faible. <br><br>  Ainsi, en th√©orie, tout ce que nous devons faire est de trouver o√π se trouvent les donn√©es du tableau et de copier le tampon d'octets qui nous est pass√© bloc par bloc.  Bien que nous travaillions avec des types inf√©rieurs √† la moiti√© de la taille des blocs, nous gagnerons au moins l√©g√®rement la solution ¬´na√Øve¬ª g√©n√©r√©e par le compilateur. <br><br>  Il n'y a qu'un seul probl√®me - si tout est fait comme √ßa, alors les octets de notre tableau se retourneront.  Parce que EVM est big-endian.  Le moyen le plus simple et le plus efficace, bien s√ªr, est de d√©ployer des octets lors de l'envoi, mais pour la simplicit√© de l'API, j'ai d√©cid√© de le faire dans le code du contrat.  Si vous souhaitez en √©conomiser davantage, n'h√©sitez pas √† supprimer cette partie de la fonction et √† tout faire au moment de l'envoi. <br><br>  Voici la fonction que j'ai obtenue pour transformer un tableau d'octets en un tableau d'entiers sign√©s 64 bits (cependant, il peut √™tre facilement adapt√© √† d'autres types): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign_int64_storage_from_bytes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int64[] storage to, bytes memory from</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    .      int64,     8    (sizeof  Solidity  :( ) to.length = from.length / 8; //     ,  SHA3      uint256 addr; bytes32 base; assembly{ // keccak256   ,    ,          mstore(addr, to_slot) base := keccak256(addr, 32) } uint i = 0; for(uint offset = 0; offset &lt; from.length; offset += 32) { //  32-     //     32  -  ,   ,     uint256 tmp; assembly{ tmp := mload(add(from, add(offset,32))) } //   .  ,     ,       . for(uint b = 0; b &lt; 16; ++b) { uint shift = b*8; uint shift2 = (256 - (b+1)*8); uint low = (tmp &amp; (0xFF &lt;&lt; shift)) &gt;&gt; shift; uint high = (tmp &amp; (0xFF &lt;&lt; shift2)) &gt;&gt; shift2; tmp = tmp &amp; ~( (0xFF &lt;&lt; shift) | (0xFF &lt;&lt; shift2)); tmp = tmp | (low &lt;&lt; shift2) | (high &lt;&lt; shift); } //      assembly{ sstore(add(base, i), tmp) } i += 1; } }</span></span></code> </pre><br>  Avec les nombres 64 bits, nous avons gagn√© moins qu'avec les 8 bits, par rapport au code g√©n√©r√© par le compilateur, mais cette fonction consomme n√©anmoins 718466 gaz (7184 gaz par num√©ro, 898 gaz par octet) contre 1003225 pour les na√Øfs (1003 gaz par num√©ro, 1254 par octet), ce qui rend son utilisation assez significative.  Et comme mentionn√© ci-dessus, vous pouvez √©conomiser davantage en supprimant l'adresse octet de l'appelant. <br><br>  Il convient de noter que la limite de gaz par unit√© dans Ethereum fixe une limite √† la quantit√© de donn√©es que nous pouvons enregistrer en une seule transaction.  Pour aggraver les choses, l'ajout de donn√©es √† un tableau d√©j√† rempli est une t√¢che beaucoup plus compliqu√©e, sauf lorsque le dernier bloc utilis√© du tableau a √©t√© rempli √† la limite (auquel cas vous pouvez utiliser la m√™me fonction, mais avec un retrait diff√©rent).  √Ä l'heure actuelle, la limite de gaz par bloc est d'environ 6 millions, ce qui signifie que nous pouvons plus ou moins √©conomiser 6 Ko de donn√©es √† la fois, mais en r√©alit√© encore moins, en raison d'autres d√©penses. <br><br><h2>  Modifications √† venir </h2><br>  Les changements √† venir dans le r√©seau Ethereum en octobre, qui se produiront avec l'activation des EIP appartenant √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Constantinople</a> , devraient rendre la sauvegarde des donn√©es plus facile et moins co√ªteuse - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EIP 1087</a> sugg√®re que les frais de stockage des donn√©es ne seront pas factur√©s pour chaque commande SSTORE, mais pour le nombre de blocs modifi√©s, ce qui rendra l'approche na√Øve utilis√©e par le compilateur, presque aussi rentable que le code JULIA √©crit manuellement (mais pas tout √† fait - beaucoup de mouvements corporels suppl√©mentaires resteront l√†, en particulier pour les valeurs 8 bits).  La transition pr√©vue vers WebAssembly en tant que langue de base d'EVM changera encore plus l'image, mais c'est encore une perspective tr√®s √©loign√©e, et nous devons r√©soudre les probl√®mes maintenant. <br><br>  Ce message ne pr√©tend pas √™tre la meilleure solution au probl√®me, et je serais heureux si quelqu'un en propose un plus efficace - je viens de commencer √† d√©marrer avec Ethereum, et je pourrais perdre de vue certaines fonctionnalit√©s EVM qui pourraient m'aider.  Mais dans mes recherches sur le net, je n'ai rien vu sur ce probl√®me, et peut-√™tre que les r√©flexions et le code ci-dessus seront utiles √† quelqu'un comme point de d√©part pour l'optimisation. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423639/">https://habr.com/ru/post/fr423639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423629/index.html">Mars IT Infrastructure Change Management</a></li>
<li><a href="../fr423631/index.html">Deux comp√©tences qui vous aideront √† devenir un grand d√©veloppeur</a></li>
<li><a href="../fr423633/index.html">Nous utilisons 54 lois f√©d√©rales au profit de la comptabilit√© √† domicile</a></li>
<li><a href="../fr423635/index.html">Lecteur de livres audio de style r√©tro</a></li>
<li><a href="../fr423637/index.html">7 le√ßons pratiques sur UX</a></li>
<li><a href="../fr423641/index.html">Deep Learning et OpenVINO Toolkit. R√©ponses d'experts Intel</a></li>
<li><a href="../fr423643/index.html">Les banques surveillent de plus en plus la r√©putation de leurs clients: enqu√™te Business Insider</a></li>
<li><a href="../fr423645/index.html">Comment nous avons servi l'infrastructure informatique de Luzhniki pendant la Coupe du monde</a></li>
<li><a href="../fr423647/index.html">Cr√©er un r√©seau neuronal simple</a></li>
<li><a href="../fr423649/index.html">"Kubernetes √† tous les domaines!" - Entretien avec le comit√© de programme de la conf√©rence DevOops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>