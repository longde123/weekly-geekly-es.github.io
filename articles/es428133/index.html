<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçµ ü¶Ñ ‚ô¶Ô∏è Hasura Arquitectura de alto rendimiento GraphQL a SQL Server üöõ üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ üë©üèæ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducci√≥n del art√≠culo "Arquitectura de un motor GraphQL a SQL de alto rendimiento" . 

 Esta es una traducci√≥n de un art√≠...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hasura Arquitectura de alto rendimiento GraphQL a SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428133/">  Hola Habr!  Les presento la traducci√≥n del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Arquitectura de un motor GraphQL a SQL de alto rendimiento"</a> . <br><br>  Esta es una traducci√≥n de un art√≠culo sobre c√≥mo est√° estructurado internamente y qu√© optimizaciones y soluciones arquitect√≥nicas tiene Hasura: un servidor GraphQL liviano de alto rendimiento, que act√∫a como una capa entre su aplicaci√≥n web y la base de datos PostgreSQL. <br><br>  Le permite generar un esquema GraphQL basado en una base de datos existente o crear uno nuevo.  Admite suscripciones GraphQL desde el cuadro basado en activadores de Postgres, control de acceso din√°mico, generaci√≥n autom√°tica de combinaciones, resuelve el problema de las solicitudes N + 1 (procesamiento por lotes) y mucho m√°s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tb/tq/nt/tbtqntldyuxalrgy5wvz9exu5kc.png" width="400"></div><a name="habracut"></a><br>  Puede usar restricciones de claves externas en PostgreSQL para obtener datos jer√°rquicos en una sola consulta.  Por ejemplo, puede ejecutar esta consulta para obtener √°lbumes y sus pistas correspondientes (si se crea una clave externa en la tabla "pista" que apunta a la tabla "√°lbum") <br><br><pre><code class="hljs dos">{ album (where: {year: {_eq: <span class="hljs-number"><span class="hljs-number">2018</span></span>}}) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> tracks { id <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre> <br>  Como habr√°s adivinado, puedes solicitar datos de cualquier profundidad.  Esta API, combinada con el control de acceso, permite a las aplicaciones web consultar datos de PostgreSQL sin escribir su propio backend.  Est√° dise√±ado para responder consultas lo m√°s r√°pido posible, tener un gran ancho de banda, al tiempo que ahorra tiempo de procesador y consumo de memoria en el servidor.  Hablaremos de soluciones arquitect√≥nicas que nos permitieron lograr esto. <br><br><h2>  Solicitar ciclo de vida </h2><br>  Una solicitud enviada a Hasura pasa por las siguientes etapas: <br><br><ol><li>  <b>Recepci√≥n de sesiones</b> : la solicitud cae en la puerta de enlace, que comprueba la clave (si la hay) y agrega varios encabezados, por ejemplo, el identificador y la funci√≥n del usuario. </li><li>  <b>An√°lisis de solicitudes</b> : Hasura recibe la solicitud, analiza los encabezados para obtener informaci√≥n sobre el usuario, crea GraphQL AST en funci√≥n del cuerpo de la solicitud. </li><li>  <b>Validaci√≥n de solicitudes</b> : se realiza una comprobaci√≥n para ver si la solicitud es sem√°nticamente correcta, luego se aplican los derechos de acceso correspondientes a la funci√≥n del usuario. </li><li>  <b>Ejecuci√≥n de la consulta</b> : la consulta se convierte a SQL y se env√≠a a Postgres. </li><li>  <b>Generaci√≥n de respuesta</b> : el resultado de la consulta SQL se procesa y se env√≠a al cliente (la <i>puerta de enlace puede usar gzip si es necesario</i> ). </li></ol><br><h2>  Objetivos </h2><br>  Los requisitos son aproximadamente los siguientes: <br><br><ol><li>  La pila HTTP deber√≠a agregar una sobrecarga m√≠nima y ser capaz de manejar muchas solicitudes concurrentes para un alto rendimiento. </li><li>  Generaci√≥n r√°pida de SQL a partir de consultas GraphQL. </li><li>  La consulta SQL generada deber√≠a ser eficiente para Postgres. </li><li>  El resultado de la consulta SQL se debe pasar efectivamente de Postgres. </li></ol><br><h2>  Procesamiento de consultas GraphQL </h2><br>  Existen varios enfoques para obtener los datos necesarios para una consulta GraphQL: <br><br><h3>  Resolvedores convencionales </h3><br>  La ejecuci√≥n de consultas GraphQL generalmente implica llamar al solucionador para cada campo. <br>  En la solicitud de ejemplo, obtenemos los √°lbumes lanzados en 2018, y luego para cada uno de ellos solicitamos las pistas correspondientes, un problema cl√°sico de las solicitudes N + 1.  El n√∫mero de consultas crece exponencialmente al aumentar la profundidad de la consulta. <br><br>  Las solicitudes hechas por Postgres ser√°n: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">2018</span></span>;</code> </pre><br>  Esta solicitud nos devolver√° todos los √°lbumes.  Suponga que el n√∫mero de √°lbumes devueltos por la solicitud es igual a N. Luego, para cada √°lbum, ejecutaremos la siguiente solicitud: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album_id = &lt;album-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt;</code> </pre><br>  En total, obtienes consultas N + 1 para obtener todos los datos necesarios. <br><br><h3>  Solicitudes por lotes </h3><br>  Las herramientas como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargador de datos</a> est√°n dise√±adas para resolver el problema de las solicitudes N + 1 mediante el procesamiento por lotes.  El n√∫mero de consultas SQL para los datos incrustados ya no depende del tama√±o de la muestra inicial, porque  Ahora afecta el n√∫mero de nodos en la consulta GraphQL.  En este caso, se requieren 2 solicitudes a Postgres para obtener los datos requeridos: <br><br>  Tenemos √°lbumes: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Obtenemos las pistas de los √°lbumes que recibimos en la solicitud anterior: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album_id <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> {the <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> album ids}</code> </pre><br>  En total, se reciben 2 consultas.  Evitamos ejecutar consultas SQL en las pistas para cada √°lbum individual; en su lugar, utilizamos el operador WHERE para obtener todas las pistas necesarias en una consulta a la vez. <br><br><h3>  Se une </h3><br>  Dataloader est√° dise√±ado para trabajar con diferentes fuentes de datos y no permite explotar las capacidades de una en particular.  En nuestro caso, Postgres es la √∫nica fuente de datos y, como todas las bases de datos relacionales, proporciona la capacidad de recopilar datos de varias tablas con una sola consulta utilizando el operador JOIN.  Podemos determinar todas las tablas necesarias para una consulta GraphQL y generar una sola consulta SQL utilizando JOIN para obtener todos los datos.  Resulta que los datos necesarios para cualquier consulta GraphQL se pueden obtener utilizando una sola consulta SQL.  Estos datos se convierten antes de ser enviados al cliente. <br><br>  Tal solicitud: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> album_id, album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> album_title, track.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> track_id, track.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> track_title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Nos devolver√° dichos datos: <br><br><pre> <code class="sql hljs">album_id, album_title, track_id, track_title 1, Album1, 1, track1 1, Album1, 2, track2 2, Album2, NULL, NULL</code> </pre><br>  Luego se convertir√° a JSON y se enviar√° al cliente: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"Album1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tracks"</span></span>: [ {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"track1"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"track2"</span></span>} ] }, { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"Album2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tracks"</span></span> : [] } ]</code> </pre><br><h2>  Optimizaci√≥n de la generaci√≥n de respuesta. </h2><br>  Descubrimos que la mayor parte del tiempo en el procesamiento de consultas se dedica a la funci√≥n de convertir el resultado de una consulta SQL a JSON. <br><br>  Despu√©s de varios intentos de optimizar esta funci√≥n de varias maneras, decidimos transferirla a Postgres.  Postgres 9.4 ( <i>lanzado en el momento del primer lanzamiento de Hasura</i> ) agreg√≥ una funci√≥n para la agregaci√≥n JSON que nos ayud√≥ a hacer nuestro trabajo.  Despu√©s de esta optimizaci√≥n, las consultas SQL comenzaron a verse as√≠: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> json_agg(r.*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> title, json_agg(track.*) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> album.id ) r</code> </pre><br>  El resultado de esta consulta tendr√° una columna y una fila, y este valor se enviar√° al cliente sin m√°s conversiones.  Seg√∫n nuestras pruebas, este enfoque es de 3 a 6 veces m√°s r√°pido que la funci√≥n de conversi√≥n de Haskell. <br><br><h2>  Declaraciones preparadas </h2><br>  Las consultas SQL generadas pueden ser bastante grandes y complejas dependiendo del nivel de anidamiento de la consulta y las condiciones de uso.  Por lo general, las aplicaciones web tienen un conjunto de consultas que se ejecutan repetidamente con diferentes par√°metros.  Por ejemplo, la consulta anterior debe ejecutarse para 2017, en lugar de 2018. Las declaraciones preparadas son m√°s adecuadas para los casos en los que hay una consulta compleja de SQL repetitiva en la que solo se cambian los par√°metros. <br><br>  Digamos que esta consulta se ejecuta por primera vez: <br><br><pre> <code class="hljs dos">{ album (where: {year: {_eq: <span class="hljs-number"><span class="hljs-number">2018</span></span>}}) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> tracks { id <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre><br>  Creamos una declaraci√≥n preparada para la consulta SQL en lugar de ejecutarla: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">PREPARE</span></span> prep_1 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> json_agg(r.*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> title, json_agg(track.*) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> album.</code> </pre><br>  Despu√©s de lo cual lo ejecutamos de inmediato: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> prep_1(<span class="hljs-string"><span class="hljs-string">'2018'</span></span>);</code> </pre><br>  Cuando necesita ejecutar la consulta GraphQL para 2017, simplemente llamamos a la misma declaraci√≥n preparada con un argumento diferente: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> prep_1(<span class="hljs-string"><span class="hljs-string">'2017'</span></span>);</code> </pre><br>  Esto proporciona un aumento del 10-20% en la velocidad dependiendo de la complejidad de la consulta GraphQL. <br><br><h2>  Haskell </h2><br>  Haskell funciona bien por varias razones: <br><br><ul><li>  Lenguaje compilado con excelente rendimiento ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√°s detalles aqu√≠</a> ). </li><li>  Pila HTTP muy eficiente ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">warp</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arquitectura de warp</a> ). </li><li>  Nuestra experiencia ling√º√≠stica previa. </li></ul><br><h2>  Al final </h2><br>  Todas las optimizaciones mencionadas anteriormente dan como resultado ventajas de rendimiento bastante serias: <br><br><img src="https://habrastorage.org/webt/oq/fl/gj/oqflgjy29zi_ar0amyy6xfggvbc.png"><br><br>  De hecho, el bajo consumo de memoria y los retrasos insignificantes en comparaci√≥n con las llamadas directas a PostgreSQL permiten en la mayor√≠a de los casos reemplazar el ORM en su back-end con llamadas a la API GraphQL. <br><br>  <b>Puntos de referencia:</b> <br><br>  Banco de pruebas: <br><br><ol><li>  Laptop con 8GB de RAM y i7 </li><li>  Postgres corriendo en la misma computadora </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wrk</a> , se us√≥ como herramienta de comparaci√≥n y para varios tipos de solicitudes tratamos de "maximizar" rps </li><li>  Una instancia de Hasura GraphQL Engine </li><li>  Tama√±o de la piscina de conexi√≥n: 50 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conjunto de datos</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chinook</a> </li></ol><br><br>  <b>Solicitud 1: tracks_media_some</b> <br><br><pre> <code class="hljs pgsql">query tracks_media_some { tracks (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: {composer: {_eq: "Kurt Cobain"}}){ id <span class="hljs-type"><span class="hljs-type">name</span></span> album { id title } media_type { <span class="hljs-type"><span class="hljs-type">name</span></span> } }}</code> </pre><br><ul><li>  Solicitudes por segundo: 1375 req / s </li><li>  Retraso: 17.5 ms </li><li>  CPU: ~ 30% </li><li>  RAM: ~ 30MB (Hasura) + 90MB (Postgres) </li></ul><br>  <b>Solicitud 2: tracks_media_all</b> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> tracks_media_all { <span class="hljs-section"><span class="hljs-section">tracks</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name media_type { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } }}</code> </pre><br><ul><li>  Solicitudes por segundo: 410 req / s </li><li>  Retraso: 59 ms </li><li>  CPU: ~ 100% </li><li>  RAM: ~ 30MB (Hasura) + 130MB (Postgres) </li></ul><br>  <b>Solicitud 3: album_tracks_genre_some</b> <br><br><pre> <code class="hljs pgsql">query albums_tracks_genre_some { albums (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: {artist_id: {_eq: <span class="hljs-number"><span class="hljs-number">127</span></span>}}) { id title tracks { id <span class="hljs-type"><span class="hljs-type">name</span></span> genre { <span class="hljs-type"><span class="hljs-type">name</span></span> } } }}</code> </pre><br><ul><li>  Solicitudes por segundo: 1029 req / s </li><li>  Retraso: 24 ms </li><li>  CPU: ~ 30% </li><li>  RAM: ~ 30MB (Hasura) + 90MB (Postgres) </li></ul><br>  <b>Solicitud 4: album_tracks_genre_all</b> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> albums_tracks_genre_all { <span class="hljs-section"><span class="hljs-section">albums</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> title tracks { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name genre { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } } }</code> </pre><br><ul><li>  Solicitudes por segundo: 328 req / s </li><li>  Retraso: 73 ms </li><li>  CPU: 100% </li><li>  RAM: ~ 30MB (Hasura) + 130MB (Postgres) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428133/">https://habr.com/ru/post/es428133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428123/index.html">Semana de la seguridad 41: buenas noticias</a></li>
<li><a href="../es428125/index.html">¬øQui√©nes son los an√°lisis de productos y por qu√© se necesitan en un equipo?</a></li>
<li><a href="../es428127/index.html">Cach√© de Nginx: todo nuevo - bien olvidado viejo</a></li>
<li><a href="../es428129/index.html">Simple l√≥gica difusa unida "de lo que era" para un motor de turbina de gas</a></li>
<li><a href="../es428131/index.html">Toda la verdad sobre RTOS. Art√≠culo # 17. Grupos de banderas de eventos: Introducci√≥n y servicios b√°sicos</a></li>
<li><a href="../es428135/index.html">C√≥mo configurar o deshabilitar el linting en el editor de c√≥digo incorporado</a></li>
<li><a href="../es428137/index.html">Olimpiada, concurso de ideas, conferencias sobre gesti√≥n de proyectos de TI y proyecciones de pel√≠culas: 10 pr√≥ximos eventos en la Universidad ITMO</a></li>
<li><a href="../es428141/index.html">El backend para la interfaz, o C√≥mo Yandex.Market crea una API sin muletas</a></li>
<li><a href="../es428143/index.html">Enfoque de implementaci√≥n de ReactJS RBAC</a></li>
<li><a href="../es428147/index.html">Script para recopilar citas y reconocer texto de video en Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>