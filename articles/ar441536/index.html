<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤼 ☃️ 🕘 أصناف من SIMD 🚴🏾 🔠 👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="أثناء تطوير meshoptimizer ، يطرح السؤال غالبًا: "هل يمكن لهذه الخوارزمية استخدام SIMD؟" 

 المكتبة موجهة نحو الأداء ، لكن SIMD لا توفر دائمًا مزايا كب...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>أصناف من SIMD</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441536/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/a9d/05e/c84/a9d05ec8466285f12b0a33e5978a0c00.png" align="left" width="270">  أثناء تطوير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">meshoptimizer</a> ، يطرح السؤال غالبًا: "هل يمكن لهذه الخوارزمية استخدام SIMD؟" <br><br>  المكتبة موجهة نحو الأداء ، لكن SIMD لا توفر دائمًا مزايا كبيرة للسرعة.  لسوء الحظ ، يمكن أن تجعل SIMD الشفرة أقل قدرة على الحركة وأقل قابلية للصيانة.  لذلك ، في كل حالة ، من الضروري البحث عن حل وسط.  عندما يكون الأداء قصوى ، يجب عليك تطوير وصيانة تطبيقات SIMD منفصلة لمجموعات تعليمات SSE و NEON.  في حالات أخرى ، تحتاج إلى فهم تأثير استخدام SIMD.  سنحاول اليوم تسريع شبكة المبسطة ، وهي خوارزمية جديدة تمت إضافتها مؤخرًا إلى المكتبة ، باستخدام مجموعات التعليمات SSEn / AVXn. <br><a name="habracut"></a><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/068/8c9/887/0688c9887f9cb61c268383cb4b6621b7.jpg"></div><br><br>  بالنسبة لمعيارنا ، نقوم بتبسيط نموذج بوذا التايلاندي من 6 ملايين مثلث إلى 0.1٪ من هذا الرقم.  نستخدم برنامج التحويل البرمجي Microsoft Visual Studio 2019 لبنية x64 الهدف.  يمكن للخوارزمية العددية إجراء مثل هذا الترشيد في حوالي 210 مللي ثانية في مؤشر ترابط Intel Core i7-8700K واحد (عند حوالي 4.4 جيجاهرتز).  هذا يتوافق مع حوالي 28.5 مليون مثلث في الثانية.  ربما هذا يكفي في الممارسة العملية ، لكنني كنت فضولي لاستكشاف أقصى قدرات الجهاز. <br><br>  في بعض الحالات ، يمكن مزامنة الإجراء بتقسيم الشبكة إلى أجزاء ، ولكن من الضروري إجراء تحليل إضافي للتوصيل من أجل الحفاظ على الحدود ، لذلك سنقوم في الوقت الحالي بتقييد أنفسنا بتحسينات SIMD البحتة. <br><br><h1 style=";text-align:right;direction:rtl">  سبعة قياسات </h1><br>  لفهم إمكانات التحسين ، سنقوم بإجراء التوصيف باستخدام Intel VTune.  قم بتشغيل الإجراء 100 مرة للتأكد من وجود بيانات كافية. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a7/6f0/cea/1a76f0ceaf9dc88617c5296d6ee73467.png"><br><br>  قمت هنا بتشغيل وضع microarchitecture لإصلاح وقت تنفيذ كل وظيفة ، وكذلك العثور على الاختناقات.  نرى أن الترشيد يتم تنفيذه باستخدام مجموعة من الوظائف ، كل منها يتطلب عددًا معينًا من الدورات.  يتم فرز قائمة الوظائف حسب الوقت.  ها هم من أجل التنفيذ لجعل الخوارزمية أسهل للفهم: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <code>rescalePositions</code> مواضع كل القمم في مكعب واحد للتحضير <code>computeVertexIds</code> باستخدام <code>computeVertexIds</code> </li><li style=";text-align:right;direction:rtl">  <code>computeVertexIds</code> يحسب معرّف كمي 30 بت لكل رأس على شبكة موحدة بحجم معين ، حيث يتم قياس كل محور على شبكة (حجم الشبكة 10 بت ، وبالتالي فإن المعرف هو 30) </li><li style=";text-align:right;direction:rtl">  <code>countTriangles</code> بحساب العدد التقريبي للمثلثات التي سيقوم المبتكر بإنشائها بحجم شبكة معين ، مع افتراض اتحاد كل القمم في خلية شبكة واحدة </li><li style=";text-align:right;direction:rtl">  <code>fillVertexCells</code> تملأ جدولًا <code>fillVertexCells</code> كل الرؤوس للخلايا المقابلة ؛  جميع القمم ذات المعرف نفسه تتوافق مع خلية واحدة </li><li style=";text-align:right;direction:rtl">  <code>fillCellQuadrics</code> تملأ هيكل <code>Quadric</code> (مصفوفة متماثلة <code>Quadric</code> ) لكل خلية لتعكس المعلومات الإجمالية عن الهندسة المقابلة </li><li style=";text-align:right;direction:rtl">  <code>fillCellRemap</code> بحساب مؤشر قمة الرأس لكل خلية ، واختيار واحد من القمم في هذه الخلية ، ويقلل من التشوه الهندسي </li><li style=";text-align:right;direction:rtl">  يعرض <code>filterTriangles</code> المجموعة النهائية من المثلثات وفقًا لجداول vertex-cell-vertex التي تم إنشاؤها مسبقًا ؛  يمكن أن ينتج عن الترجمة الساذجة معدل مثلثات مكررة بنسبة 5٪ تقريبًا ، وبالتالي تقوم الدالة بتصفية التكرارات. </li></ul><br>  يتم تنفيذ <code>computeVertexIds</code> و <code>countTriangles</code> عدة مرات: تحدد الخوارزمية حجم الشبكة لدمج القمم ، وإجراء بحث ثنائي معجل لتحقيق العدد المستهدف من المثلثات (في الحالة 6000 لدينا) وحساب عدد المثلثات التي ستنشئها كل حجم شبكة في كل تكرار.  يتم إطلاق وظائف أخرى مرة واحدة.  في ملفنا ، تعطي خمس ممرات بحث حجم شبكة مستهدف قدره 40 <sup>3</sup> . <br><br>  تفيد VTune بشكل مفيد أن الوظيفة الأكثر كثافة للموارد هي تلك التي تقوم بحساب الترميزات: فهي تستغرق ما يقرب من نصف إجمالي وقت التنفيذ البالغ 21 ثانية.  هذا هو الهدف الأول لتحسين SIMD. <br><br><h1 style=";text-align:right;direction:rtl">  SIMD قطعة قطعة </h1><br>  دعنا نلقي نظرة على الكود المصدري لـ <code>fillCellQuadrics</code> لفهم ما يحسبه بالضبط: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillCellQuadrics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Quadric* cell_quadrics, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* indices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3* vertex_positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* vertex_cells)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; index_count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i0 = indices[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c0 = vertex_cells[i0]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c1 = vertex_cells[i1]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c2 = vertex_cells[i2]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> single_cell = (c0 == c1) &amp; (c0 == c2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = single_cell ? <span class="hljs-number"><span class="hljs-number">3.f</span></span> : <span class="hljs-number"><span class="hljs-number">1.f</span></span>; Quadric Q; quadricFromTriangle(Q, vertex_positions[i0], vertex_positions[i1], vertex_positions[i2], weight); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (single_cell) { quadricAdd(cell_quadrics[c0], Q); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { quadricAdd(cell_quadrics[c0], Q); quadricAdd(cell_quadrics[c1], Q); quadricAdd(cell_quadrics[c2], Q); } } }</code> </pre> <br>  تتكرر الوظيفة على كل المثلثات ، وتحسب المربعي لكل منها ، وتضيفها إلى مربعات كل خلية.  المربعي - مصفوفة متماثلة 4 × 4 ، معروضة كـ 10 أرقام فاصلة عائمة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Quadric</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a00; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a10, a11; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a20, a21, a22; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b0, b1, b2, c; };</code> </pre> <br>  يتطلب حساب المربعي حل معادلة المستوى للمثلث ، وإنشاء مصفوفة من الدرجة الثانية ووزنها باستخدام منطقة المثلث: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quadricFromPlane</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Quadric&amp; Q, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ Q.a00 = a * a; Q.a10 = b * a; Q.a11 = b * b; Q.a20 = c * a; Q.a21 = c * b; Q.a22 = c * c; Q.b0 = d * a; Q.b1 = d * b; Q.b2 = d * c; Qc = d * d; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quadricFromTriangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Quadric&amp; Q, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3&amp; p0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3&amp; p1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3&amp; p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> weight)</span></span></span><span class="hljs-function"> </span></span>{ Vector3 p10 = {p1.x - p0.x, p1.y - p0.y, p1.z - p0.z}; Vector3 p20 = {p2.x - p0.x, p2.y - p0.y, p2.z - p0.z}; Vector3 normal = { p10.y * p20.z - p10.z * p20.y, p10.z * p20.x - p10.x * p20.z, p10.x * p20.y - p10.y * p20.x }; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> area = normalize(normal); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = normal.x*p0.x + normal.y*p0.y + normal.z*p0.z; quadricFromPlane(Q, normal.x, normal.y, normal.z, -distance); quadricMul(Q, area * weight); }</code> </pre> <br>  يبدو أن هناك الكثير من عمليات الفاصلة العائمة ، بحيث يمكن موازنتها باستخدام SIMD.  أولاً ، نحن نمثل كل متجه باعتباره متجه SIMD عريض النطاق ، <code>Quadric</code> أيضًا هيكل <code>Quadric</code> إلى 12 رقمًا عائمًا بدلاً من 10 بحيث يتناسب تمامًا مع ثلاث سجلات SIMD (زيادة الحجم لا يؤثر على الأداء) وتغيير ترتيب الحقول بحيث الحسابات أصبح <code>quadricFromPlane</code> أكثر اتساقا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Quadric</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a00, a11, a22; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pad0; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a10, a21, a20; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pad1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b0, b1, b2, c; };</code> </pre> <br>  هنا ، لا تتسق بعض العمليات الحسابية ، ولا سيما المنتج القياسي ، مع الإصدارات السابقة من SSE.  لحسن الحظ ، ظهرت تعليمات لمنتج عددي في SSE4.1 ، وهو أمر مفيد للغاية بالنسبة لنا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillCellQuadrics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Quadric* cell_quadrics, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* indices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3* vertex_positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* vertex_cells)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yzx = _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zxy = _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dp_xyz = <span class="hljs-number"><span class="hljs-number">0x7f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; index_count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i0 = indices[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c0 = vertex_cells[i0]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c1 = vertex_cells[i1]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c2 = vertex_cells[i2]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> single_cell = (c0 == c1) &amp; (c0 == c2); __m128 p0 = _mm_loadu_ps(&amp;vertex_positions[i0].x); __m128 p1 = _mm_loadu_ps(&amp;vertex_positions[i1].x); __m128 p2 = _mm_loadu_ps(&amp;vertex_positions[i2].x); __m128 p10 = _mm_sub_ps(p1, p0); __m128 p20 = _mm_sub_ps(p2, p0); __m128 normal = _mm_sub_ps( _mm_mul_ps( _mm_shuffle_ps(p10, p10, yzx), _mm_shuffle_ps(p20, p20, zxy)), _mm_mul_ps( _mm_shuffle_ps(p10, p10, zxy), _mm_shuffle_ps(p20, p20, yzx))); __m128 areasq = _mm_dp_ps(normal, normal, dp_xyz); <span class="hljs-comment"><span class="hljs-comment">// SSE4.1 __m128 area = _mm_sqrt_ps(areasq); // masks the result of the division when area==0 // scalar version does this in normalize() normal = _mm_and_ps( _mm_div_ps(normal, area), _mm_cmpneq_ps(area, _mm_setzero_ps())); __m128 distance = _mm_dp_ps(normal, p0, dp_xyz); // SSE4.1 __m128 negdistance = _mm_sub_ps(_mm_setzero_ps(), distance); __m128 normalnegdist = _mm_blend_ps(normal, negdistance, 8); __m128 Qx = _mm_mul_ps(normal, normal); __m128 Qy = _mm_mul_ps( _mm_shuffle_ps(normal, normal, _MM_SHUFFLE(3, 2, 2, 1)), _mm_shuffle_ps(normal, normal, _MM_SHUFFLE(3, 0, 1, 0))); __m128 Qz = _mm_mul_ps(negdistance, normalnegdist); if (single_cell) { area = _mm_mul_ps(area, _mm_set1_ps(3.f)); Qx = _mm_mul_ps(Qx, area); Qy = _mm_mul_ps(Qy, area); Qz = _mm_mul_ps(Qz, area); Quadric&amp; q0 = cell_quadrics[c0]; __m128 q0x = _mm_loadu_ps(&amp;q0.a00); __m128 q0y = _mm_loadu_ps(&amp;q0.a10); __m128 q0z = _mm_loadu_ps(&amp;q0.b0); _mm_storeu_ps(&amp;q0.a00, _mm_add_ps(q0x, Qx)); _mm_storeu_ps(&amp;q0.a10, _mm_add_ps(q0y, Qy)); _mm_storeu_ps(&amp;q0.b0, _mm_add_ps(q0z, Qz)); } else { // omitted for brevity, repeats the if() body // three times for c0/c1/c2 } } }</span></span></code> </pre> <br>  لا يوجد شيء مثير للاهتمام بشكل خاص في هذا الرمز ؛  نحن نستخدم بكثرة تعليمات التحميل / المتجر غير المحاذاة.  على الرغم من أنه يمكن محاذاة مدخلات Vector3 ، يبدو أنه لا توجد عقوبة ملحوظة للقراءات غير المحاذاة.  يرجى ملاحظة أنه في النصف الأول من ناقلات الوظائف لا يتم استخدامها ، وهو أمر جيد - تحتوي ناقلاتنا على ثلاثة مكونات ، وفي بعض الحالات واحد فقط (راجع حساب المساحات / المساحة / المسافة) ، بينما يقوم المعالج بإجراء 4 عمليات على التوازي.  في أي حال ، دعونا نرى كيف ساعد التوازي. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/193/b7c/4a0/193b7c4a0e52429831e1d6feb7999c6f.png"><br><br>  يتم تشغيل مائة بداية من <code>fillCellQuadrics</code> في 5.3 ثوانٍ بدلاً من 9.8 ثانية ، مما يوفر حوالي 45 مللي ثانية في كل عملية - ليس سيئًا ، ولكن ليس مؤثرًا جدًا.  في العديد من الإرشادات ، نستخدم ثلاثة مكونات بدلاً من أربعة ، بالإضافة إلى الضرب الدقيق ، مما يعطي تأخيرًا كبيرًا إلى حد ما.  إذا سبق لك أن كتبت تعليمات SIMD ، فأنت تعلم كيفية القيام بالمنتج القياسي بشكل صحيح. <br><br>  للقيام بذلك ، يجب عليك القيام بأربعة متجهات في وقت واحد.  بدلاً من تخزين متجه واحد كامل في سجل SIMD واحد ، نستخدم ثلاث سجلات - في أحدنا نخزن أربعة مكونات لـ <code>x</code> ، والآخر سنخزن <code></code> ، وفي <code>z</code> الثالث.  هناك حاجة إلى أربعة متجهات للعمل في آن واحد: هذا يعني أننا سنقوم بمعالجة أربعة مثلثات في وقت واحد. <br><br>  لدينا العديد من المصفوفات مع فهرسة ديناميكية.  عادةً ما يساعد على نقل البيانات إلى صفائف محضرة من مكونات <code>x</code> / <code>y</code> / <code>z</code> (أو بالأحرى ، عادةً ما يتم استخدام سجلات SIMD الصغيرة ، على سبيل المثال ، <code>float x[8], y[8], z[8]</code> ، لكل من الرؤوس الثمانية في الإدخال البيانات: يطلق عليها AoSoA (صفائف بنيات الصفيف) وتعطي توازنًا جيدًا بين مكان ذاكرة التخزين المؤقت وسهولة التحميل في سجلات SIMD) ، لكن الفهرسة الديناميكية هنا لن تعمل بشكل جيد للغاية ، لذا قم بتحميل البيانات لأربعة مثلثات كالمعتاد ، وقم بنقل المتجهات باستخدام طريقة ملائمة الماكرو <code>_MM_TRANSPOSE</code> . <br><br>  من الناحية النظرية ، تحتاج إلى حساب كل مكون من أربعة محارف منتهية في سجل SIMD الخاص به (على سبيل المثال ، سيكون لدينا <code>__m128 Q_a00</code> مع أربعة مكونات من <code>a00</code> المحددة).  في هذه الحالة ، تتلاءم العمليات على الكوادارات تمامًا مع تعليمات SIMD عريضة النطاق ، ويبطئ التحويل فعليًا من الكود - وبالتالي ، فإننا نغير المتجهات الأولية فقط ، ثم نعيد معادلات المستوى إلى الوراء ونعمل نفس الكود الذي استخدمناه لحساب الكواداركيات ، لكن نكررها اربع مرات  فيما يلي الكود الذي يحسب بعد ذلك معادلات المستوى (يتم حذف الأجزاء المتبقية للإيجاز): <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i00 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i01 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i02 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i10 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i11 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i12 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i20 = indices[(i + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i21 = indices[(i + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i22 = indices[(i + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i30 = indices[(i + <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i31 = indices[(i + <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32 = indices[(i + <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// load first vertex of each triangle and transpose into vectors with components (pw0 isn't used later) __m128 px0 = _mm_loadu_ps(&amp;vertex_positions[i00].x); __m128 py0 = _mm_loadu_ps(&amp;vertex_positions[i10].x); __m128 pz0 = _mm_loadu_ps(&amp;vertex_positions[i20].x); __m128 pw0 = _mm_loadu_ps(&amp;vertex_positions[i30].x); _MM_TRANSPOSE4_PS(px0, py0, pz0, pw0); // load second vertex of each triangle and transpose into vectors with components __m128 px1 = _mm_loadu_ps(&amp;vertex_positions[i01].x); __m128 py1 = _mm_loadu_ps(&amp;vertex_positions[i11].x); __m128 pz1 = _mm_loadu_ps(&amp;vertex_positions[i21].x); __m128 pw1 = _mm_loadu_ps(&amp;vertex_positions[i31].x); _MM_TRANSPOSE4_PS(px1, py1, pz1, pw1); // load third vertex of each triangle and transpose into vectors with components __m128 px2 = _mm_loadu_ps(&amp;vertex_positions[i02].x); __m128 py2 = _mm_loadu_ps(&amp;vertex_positions[i12].x); __m128 pz2 = _mm_loadu_ps(&amp;vertex_positions[i22].x); __m128 pw2 = _mm_loadu_ps(&amp;vertex_positions[i32].x); _MM_TRANSPOSE4_PS(px2, py2, pz2, pw2); // p1 - p0 __m128 px10 = _mm_sub_ps(px1, px0); __m128 py10 = _mm_sub_ps(py1, py0); __m128 pz10 = _mm_sub_ps(pz1, pz0); // p2 - p0 __m128 px20 = _mm_sub_ps(px2, px0); __m128 py20 = _mm_sub_ps(py2, py0); __m128 pz20 = _mm_sub_ps(pz2, pz0); // cross(p10, p20) __m128 normalx = _mm_sub_ps( _mm_mul_ps(py10, pz20), _mm_mul_ps(pz10, py20)); __m128 normaly = _mm_sub_ps( _mm_mul_ps(pz10, px20), _mm_mul_ps(px10, pz20)); __m128 normalz = _mm_sub_ps( _mm_mul_ps(px10, py20), _mm_mul_ps(py10, px20)); // normalize; note that areasq/area now contain 4 values, not just one __m128 areasq = _mm_add_ps( _mm_mul_ps(normalx, normalx), _mm_add_ps( _mm_mul_ps(normaly, normaly), _mm_mul_ps(normalz, normalz))); __m128 area = _mm_sqrt_ps(areasq); __m128 areanz = _mm_cmpneq_ps(area, _mm_setzero_ps()); normalx = _mm_and_ps(_mm_div_ps(normalx, area), areanz); normaly = _mm_and_ps(_mm_div_ps(normaly, area), areanz); normalz = _mm_and_ps(_mm_div_ps(normalz, area), areanz); __m128 distance = _mm_add_ps( _mm_mul_ps(normalx, px0), _mm_add_ps( _mm_mul_ps(normaly, py0), _mm_mul_ps(normalz, pz0))); __m128 negdistance = _mm_sub_ps(_mm_setzero_ps(), distance); // this computes the plane equations (a, b, c, d) for each of the 4 triangles __m128 plane0 = normalx; __m128 plane1 = normaly; __m128 plane2 = normalz; __m128 plane3 = negdistance; _MM_TRANSPOSE4_PS(plane0, plane1, plane2, plane3);</span></span></code> </pre> <br>  أصبح الكود أطول قليلاً: نحن الآن نعالج أربعة مثلثات في كل تكرار ، ولم نعد بحاجة إلى تعليمات SSE4.1 لهذا الغرض.  من الناحية النظرية ، ينبغي استخدام وحدات SIMD بشكل أكثر كفاءة.  دعونا نرى كيف ساعد. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ca/735/f51/2ca735f51bf3aa28bbf7c28f50489c15.png"><br><br>  حسنا ، هذا جيد.  تسارعت الشفرة بشكل طفيف للغاية ، على الرغم من أن وظيفة <code>fillCellQuadrics</code> تعمل الآن بمعدل أسرع مرتين تقريبًا من الوظيفة الأصلية بدون SIMD ، لكن من غير الواضح ما إذا كان هذا يبرر زيادة كبيرة في التعقيد.  من الناحية النظرية ، يمكنك استخدام AVX2 ومعالجة 8 مثلثات لكل تكرار ، ولكن هنا ستحتاج إلى زيادة دوران الحلقة يدويًا (من الناحية المثالية ، يتم إنشاء كل هذا الرمز باستخدام ISPC ، ولكن محاولاتي الساذجة للحصول عليه لإنشاء رمز جيد لم تنجح: بدلاً من تسلسل التحميل / التخزين أصدر بإصرار مجموعة / مبعثر ، مما يؤدي إلى إبطاء التنفيذ بشكل كبير).  لنجرب شيئًا آخر. <br><br><h1 style=";text-align:right;direction:rtl">  AVX2 = SSE2 + SSE2 </h1><br>  AVX2 عبارة عن مجموعة من التعليمات.  لديها سجلات عائمة بنطاق عريض 8 ، وتعليمات واحدة يمكن أن تؤدي 8 عمليات ؛  لكن في جوهرها ، لا يختلف مثل هذا التعليم عن إرشادات SSE2 التي يتم تنفيذها على نصفين من السجل (على حد علمي ، فك شفرة المعالجات الأولى التي تدعم AVX2 كل تعليمة في اثنين أو أكثر من عمليات التشغيل المصغرة ، وبالتالي فإن أداء الأداء كان محدودًا بمرحلة استخراج التعليمات).  على سبيل المثال ، ينفذ <code>_mm_dp_ps</code> منتجًا عدديًا بين <code>_mm256_dp_ps</code> SSE2 ، وينتج عن <code>_mm256_dp_ps</code> بين نصفي <code>_mm256_dp_ps</code> ، وبالتالي فهو يقتصر على 4 عرض لكل نصف. <br><br>  لهذا السبب ، غالبًا ما يختلف رمز AVX2 عن "SIMD عريض النطاق" الشامل ، ولكن هنا يعمل لصالحنا: بدلاً من محاولة تحسين التوازي عن طريق نقل المتجهات ذات الأربعة أحجام ، نعود إلى الإصدار الأول من SIMD ونضاعف الحلقة باستخدام تعليمات AVX2 بدلاً من SSE2 / SSE4.  ما زلنا بحاجة إلى تحميل وتخزين المتجهات ذات 4 <code>__m128</code> ، ولكن بشكل عام ، نقوم فقط بتغيير <code>__m128</code> إلى <code>__m256</code> و <code>_mm_</code> إلى <code>_mm256</code> في <code>_mm256</code> مع العديد من الإعدادات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i00 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i01 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i02 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i10 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i11 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i12 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; __m256 p0 = _mm256_loadu2_m128( &amp;vertex_positions[i10].x, &amp;vertex_positions[i00].x); __m256 p1 = _mm256_loadu2_m128( &amp;vertex_positions[i11].x, &amp;vertex_positions[i01].x); __m256 p2 = _mm256_loadu2_m128( &amp;vertex_positions[i12].x, &amp;vertex_positions[i02].x); __m256 p10 = _mm256_sub_ps(p1, p0); __m256 p20 = _mm256_sub_ps(p2, p0); __m256 normal = _mm256_sub_ps( _mm256_mul_ps( _mm256_shuffle_ps(p10, p10, yzx), _mm256_shuffle_ps(p20, p20, zxy)), _mm256_mul_ps( _mm256_shuffle_ps(p10, p10, zxy), _mm256_shuffle_ps(p20, p20, yzx))); __m256 areasq = _mm256_dp_ps(normal, normal, dp_xyz); __m256 area = _mm256_sqrt_ps(areasq); __m256 areanz = _mm256_cmp_ps(area, _mm256_setzero_ps(), _CMP_NEQ_OQ); normal = _mm256_and_ps(_mm256_div_ps(normal, area), areanz); __m256 distance = _mm256_dp_ps(normal, p0, dp_xyz); __m256 negdistance = _mm256_sub_ps(_mm256_setzero_ps(), distance); __m256 normalnegdist = _mm256_blend_ps(normal, negdistance, <span class="hljs-number"><span class="hljs-number">0x88</span></span>); __m256 Qx = _mm256_mul_ps(normal, normal); __m256 Qy = _mm256_mul_ps( _mm256_shuffle_ps(normal, normal, _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)), _mm256_shuffle_ps(normal, normal, _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); __m256 Qz = _mm256_mul_ps(negdistance, normalnegdist);</code> </pre> <br>  هنا يمكنك أن تأخذ كل نصف 128-bit من <code>Qz</code> Qx / Qy / Qz المستلمة وتشغيل نفس الكود الذي استخدمناه لإضافة الكواداليك.  بدلاً من ذلك ، نفترض أنه إذا كان للمثلث ثلاثة رؤوس في خلية واحدة ( <code>single_cell == true</code> ) ، فمن المحتمل جدًا أن يكون لدى مثلث آخر ثلاثة رؤوس في خلية أخرى ، ونقوم بإجراء التجميع النهائي للرباعي باستخدام AVX2 أيضًا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c00 = vertex_cells[i00]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c01 = vertex_cells[i01]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c02 = vertex_cells[i02]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c10 = vertex_cells[i10]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c11 = vertex_cells[i11]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c12 = vertex_cells[i12]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> single_cell = (c00 == c01) &amp; (c00 == c02) &amp; (c10 == c11) &amp; (c10 == c12); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (single_cell) { area = _mm256_mul_ps(area, _mm256_set1_ps(<span class="hljs-number"><span class="hljs-number">3.f</span></span>)); Qx = _mm256_mul_ps(Qx, area); Qy = _mm256_mul_ps(Qy, area); Qz = _mm256_mul_ps(Qz, area); Quadric&amp; q00 = cell_quadrics[c00]; Quadric&amp; q10 = cell_quadrics[c10]; __m256 q0x = _mm256_loadu2_m128(&amp;q10.a00, &amp;q00.a00); __m256 q0y = _mm256_loadu2_m128(&amp;q10.a10, &amp;q00.a10); __m256 q0z = _mm256_loadu2_m128(&amp;q10.b0, &amp;q00.b0); _mm256_storeu2_m128(&amp;q10.a00, &amp;q00.a00, _mm256_add_ps(q0x, Qx)); _mm256_storeu2_m128(&amp;q10.a10, &amp;q00.a10, _mm256_add_ps(q0y, Qy)); _mm256_storeu2_m128(&amp;q10.b0, &amp;q00.b0, _mm256_add_ps(q0z, Qz)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// omitted for brevity }</span></span></code> </pre> <br>  الشفرة الناتجة أبسط وموجزة وأسرع من طريقة SSE2 غير الناجحة: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/124/788/954/1247889540c5aab18d1f38738fb46fea.png"><br><br>  بالطبع ، لم نحقق تسارع 8 مرات ، ولكن 2.45 مرة فقط.  لا تزال عمليات التحميل والتخزين واسعة النطاق ، حيث إننا مضطرون للعمل مع تصميم ذاكرة غير مريح بسبب الفهرسة الديناميكية ، والحسابات ليست مثالية لـ SIMD.  ولكن الآن لم تعد <code>fillCellQuadrics</code> عنق الزجاجة في خط أنابيب الملف الشخصي لدينا ، ويمكنك التركيز على وظائف أخرى. <br><br><h1 style=";text-align:right;direction:rtl">  جمع حولها ، والأطفال </h1><br>  لقد أنقذنا 4.8 ثانية من التشغيل التجريبي (48 مللي ثانية في كل تشغيل) ، والآن أصبح الدخيل الرئيسي هو <code>countTriangles</code> .  يبدو أن هذه وظيفة بسيطة ، ولكنها لا تنفذ مرة واحدة ، بل خمس مرات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countTriangles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* vertex_ids, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* indices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index_count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; index_count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id0 = vertex_ids[indices[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id1 = vertex_ids[indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id2 = vertex_ids[indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]]; result += (id0 != id1) &amp; (id0 != id2) &amp; (id1 != id2); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  تتكرر الوظيفة على كل المثلثات المصدر وتحسب عدد المثلثات غير المنحطة من خلال مقارنة معرفات الرؤوس.  ليس من الواضح على الفور كيفية موازاة ذلك باستخدام SIMD ... إلا إذا كنت تستخدم إرشادات التجميع. <br><br>  أضافت مجموعة تعليمات AVX2 عائلة إرشادات التجميع / الانتثار إلى x64 SIMD ؛  يأخذ كل منهم سجلًا متجهًا يحتوي على 4 أو 8 قيم - وفي نفس الوقت ينفذ عمليات تحميل أو حفظ 4 أو 8.  إذا كنت تستخدم التجميع هنا ، فيمكنك تنزيل ثلاثة فهارس وتشغيل التجميع للجميع مرة واحدة (أو في مجموعات من 4 أو 8) ومقارنة النتائج.  لقد كان تجميع معالجات Intel بطيئًا من الناحية التاريخية ، ولكن دعونا نجربها.  للبساطة ، نقوم بتحميل البيانات الخاصة بـ 8 مثلثات ، ونحول المتجهات بشكل مشابه لمحاولتنا السابقة ، ونقارن العناصر المقابلة لكل متجه: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (triangle_count &amp; ~<span class="hljs-number"><span class="hljs-number">7</span></span>); i += <span class="hljs-number"><span class="hljs-number">8</span></span>) { __m256 tri0 = _mm256_loadu2_m128( (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">4</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 tri1 = _mm256_loadu2_m128( (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 tri2 = _mm256_loadu2_m128( (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">6</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 tri3 = _mm256_loadu2_m128( (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">7</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]); _MM_TRANSPOSE8_LANE4_PS(tri0, tri1, tri2, tri3); __m256i i0 = _mm256_castps_si256(tri0); __m256i i1 = _mm256_castps_si256(tri1); __m256i i2 = _mm256_castps_si256(tri2); __m256i id0 = _mm256_i32gather_epi32((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)vertex_ids, i0, <span class="hljs-number"><span class="hljs-number">4</span></span>); __m256i id1 = _mm256_i32gather_epi32((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)vertex_ids, i1, <span class="hljs-number"><span class="hljs-number">4</span></span>); __m256i id2 = _mm256_i32gather_epi32((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)vertex_ids, i2, <span class="hljs-number"><span class="hljs-number">4</span></span>); __m256i deg = _mm256_or_si256( _mm256_cmpeq_epi32(id1, id2), _mm256_or_si256( _mm256_cmpeq_epi32(id0, id1), _mm256_cmpeq_epi32(id0, id2))); result += <span class="hljs-number"><span class="hljs-number">8</span></span> - _mm_popcnt_u32(_mm256_movemask_epi8(deg)) / <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br>  ماكرو <code>_MM_TRANSPOSE8_LANE4_PS</code> في <code>_MM_TRANSPOSE8_LANE4_PS</code> هو ما يعادل <code>_MM_TRANSPOSE4_PS</code> ، وهو غير موجود في الرأس القياسي ، ولكن يمكن عرضه بسهولة.  يستغرق أربعة ناقلات AVX2 وينقل اثنين من المصفوفات 4 × 4 بشكل مستقل عن بعضها البعض: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MM_TRANSPOSE8_LANE4_PS(row0, row1, row2, row3) \ do { \ __m256 __t0, __t1, __t2, __t3; \ __t0 = _mm256_unpacklo_ps(row0, row1); \ __t1 = _mm256_unpackhi_ps(row0, row1); \ __t2 = _mm256_unpacklo_ps(row2, row3); \ __t3 = _mm256_unpackhi_ps(row2, row3); \ row0 = _mm256_shuffle_ps(__t0, __t2, _MM_SHUFFLE(1, 0, 1, 0)); \ row1 = _mm256_shuffle_ps(__t0, __t2, _MM_SHUFFLE(3, 2, 3, 2)); \ row2 = _mm256_shuffle_ps(__t1, __t3, _MM_SHUFFLE(1, 0, 1, 0)); \ row3 = _mm256_shuffle_ps(__t1, __t3, _MM_SHUFFLE(3, 2, 3, 2)); \ } while (0)</span></span></code> </pre> <br>  نظرًا لبعض الميزات الموجودة في مجموعات التعليمات SSE2 / AVX2 ، يجب علينا استخدام عمليات تسجيل الفاصلة العائمة عند نقل المتجهات.  نحن نقوم بتحميل البيانات قليلاً بلا مبالاة ؛  ولكن هذا لا يهم في الأساس ، لأن تجميع الأداء يحدنا: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ef/602/0e0/1ef6020e0d5b0c4bbf962335d77c653a.png"><br><br>  <code>countTriangles</code> الآن حوالي 27٪ ويلاحظ مؤشر أسعار المستهلك الرهيب (دورات لكل تعليمة): نقوم بإرسال تعليمات أقل بمقدار أربعة أضعاف ، لكن التجميع يستغرق الكثير من الوقت.  من الرائع تسريع العمل بشكل عام ، ولكن بالطبع ، فإن اكتساب الأداء محبط إلى حد ما.  لقد نجحنا في تجاوز <code>fillCellQuadrics</code> في الملف الشخصي ، وهو ما يقودنا إلى الوظيفة الأخيرة في أعلى القائمة ، والتي لم نطلع عليها بعد. <br><br><h1 style=";text-align:right;direction:rtl">  الفصل 6 ، حيث يبدأ كل شيء في العمل كما ينبغي </h1><br>  آخر وظيفة هي <code>computeVertexIds</code> .  في الخوارزمية ، يتم تنفيذها 6 مرات ، وبالتالي فهي تمثل أيضًا هدفًا ممتازًا للتحسين.  لأول مرة ، نرى وظيفة يبدو أنها تم إنشاؤها لتحسين واضح في SIMD: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeVertexIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* vertex_ids, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3* vertex_positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vertex_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_size)</span></span></span><span class="hljs-function"> </span></span>{ assert(grid_size &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; grid_size &lt;= <span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cell_scale = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(grid_size - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertex_count; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3&amp; v = vertex_positions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xi = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(vx * cell_scale + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yi = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(vy * cell_scale + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zi = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(vz * cell_scale + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); vertex_ids[i] = (xi &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) | (yi &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | zi; } }</code> </pre> <br>  بعد التحسينات السابقة ، نعرف ما يجب القيام به: استرخ الدورة 4 أو 8 مرات ، حيث لا يوجد أي فائدة في محاولة تسريع تكرار واحد فقط ، ونقل مكونات المتجه وتشغيل الحسابات بالتوازي.  لنقم بذلك باستخدام AVX2 ، ونقوم بمعالجة 8 رؤوس في كل مرة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">__m256 scale = _mm256_set1_ps(cell_scale); __m256 half = _mm256_set1_ps(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (vertex_count &amp; ~<span class="hljs-number"><span class="hljs-number">7</span></span>); i += <span class="hljs-number"><span class="hljs-number">8</span></span>) { __m256 vx = _mm256_loadu2_m128( &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">4</span></span>].x, &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">0</span></span>].x); __m256 vy = _mm256_loadu2_m128( &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">5</span></span>].x, &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">1</span></span>].x); __m256 vz = _mm256_loadu2_m128( &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">6</span></span>].x, &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">2</span></span>].x); __m256 vw = _mm256_loadu2_m128( &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">7</span></span>].x, &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">3</span></span>].x); _MM_TRANSPOSE8_LANE4_PS(vx, vy, vz, vw); __m256i xi = _mm256_cvttps_epi32( _mm256_add_ps(_mm256_mul_ps(vx, scale), half)); __m256i yi = _mm256_cvttps_epi32( _mm256_add_ps(_mm256_mul_ps(vy, scale), half)); __m256i zi = _mm256_cvttps_epi32( _mm256_add_ps(_mm256_mul_ps(vz, scale), half)); __m256i id = _mm256_or_si256( zi, _mm256_or_si256( _mm256_slli_epi32(xi, <span class="hljs-number"><span class="hljs-number">20</span></span>), _mm256_slli_epi32(yi, <span class="hljs-number"><span class="hljs-number">10</span></span>))); _mm256_storeu_si256((__m256i*)&amp;vertex_ids[i], id); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وإلقاء نظرة على النتائج: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/895/365/9c9/8953659c9ee67385751dae656e244dbb.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تسارعنا </font></font><code>computeVertexIds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مرتين. مع الأخذ في الاعتبار جميع التحسينات ، تم تخفيض إجمالي وقت تنفيذ البرنامج إلى حوالي 120 مللي ثانية ، وهو ما يتوافق مع حساب 50 مليون مثلث في الثانية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قد يبدو أننا لم نحقق مرة أخرى نمو الإنتاجية المتوقع: </font></font><code>computeVertexIds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ألا </font><font style="vertical-align: inherit;">ينبغي </font><font style="vertical-align: inherit;">أن يتسارع أكثر من مرتين بعد الموازاة؟ للإجابة على هذا السؤال ، دعونا نحاول معرفة مقدار العمل الذي تؤديه هذه الوظيفة. </font></font><br><br> <code>computeVertexIds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم تنفيذه ست مرات لبدء برنامج واحد: خمس مرات أثناء البحث الثنائي ومرة ​​واحدة في النهاية لحساب المعرفات النهائية التي يتم استخدامها للمعالجة الإضافية. في كل مرة تقوم هذه الوظيفة بمعالجة 3 ملايين رأس ، وقراءة 12 بايت لكل قمة وكتابة 4 بايت.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في المجموع ، أكثر من 100 يدير المبتكر ، هذه الوظيفة معالجة 1.8 مليار رأس ، وقراءة 21 غيغابايت وإعادة كتابة 7 غيغابايت. </font><font style="vertical-align: inherit;">تتطلب معالجة 28 جيجابايت في 1.46 ثانية عرض نطاق ترددي للحافلة يبلغ 19 جيجابايت / ثانية. </font><font style="vertical-align: inherit;">يمكننا التحقق من عرض النطاق الترددي الذاكرة عن طريق تشغيل </font></font><code>memcmp(block1, block2, 512 MB)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">والنتيجة هي 45 مللي ثانية ، أي حوالي 22 جيجابايت / ثانية على لب واحد (على الرغم من أن معيار AIDA64 يُظهر سرعات قراءة على نظامي يصل إلى 31 جيجابايت / ثانية ، لكنه يستخدم عدة مراكز). </font><font style="vertical-align: inherit;">في الواقع ، لقد اقتربنا من الحد الأقصى الممكن تحقيقه من الذاكرة ، وستتطلب زيادة أخرى في الأداء تعبئة أوثق لهذه القمم بحيث تشغل أقل من 12 بايت.</font></font><br><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الخاتمة </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقد اتخذنا خوارزمية محسنة بشكل جيد للغاية تعمل على تبسيط الشبكات الكبيرة بسرعة 28 مليون مثلث في الثانية ، واستخدمنا مجموعات التعليمات SSE و AVX لتسريعها مرتين تقريبًا ، إلى 50 مليون مثلث في الثانية. خلال هذه الرحلة ، كان علينا أن نتعلم طرقًا مختلفة لاستخدام SIMD: سجلات لتخزين المتجهات 3 - واسعة ، وتعليمات SoA ، و AVX2 لتخزين متجهين عريضين - 3 ، وجمع الإرشادات لتسريع تحميل البيانات مقارنة بالتعليمات العددية ، وأخيراً قمنا بتطبيق AVX2 مباشرة لمعالجة الدفق.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">غالبًا ما لا يكون SIMD هو أفضل نقطة بداية للتحسين: لقد مر عقلاني الشبكات بعدة تكرارات من التحسين الخوارزمي و microoptimization دون استخدام إرشادات خاصة بالمنصة. ولكن في مرحلة ما ، يتم استنفاد هذه الاحتمالات ، وإذا كان الأداء حاسمًا ، فإن SIMD أداة رائعة يمكن استخدامها إذا لزم الأمر. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لست متأكدًا من أي من هذه التحسينات ستندرج في الفرع الرئيسي </font></font><code>meshoptimizer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: في النهاية ، هذه مجرد تجربة لمعرفة مدى وفيركلوكيد الشفرة دون تغيير جذري في الخوارزميات. آمل أن يكون هذا المقال مفيدًا وأن يقدم لك أفكارًا لتحسين الشفرة. المصادر النهائية لهذا المقال </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ؛ يستند هذا العمل إلى إصدار </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meshoptimizer 99ab49</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، ويتم نشر نموذج بوذا التايلاندي </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على Sketchfab</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar441536/">https://habr.com/ru/post/ar441536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar441526/index.html">عوامل قيمة البيتكوين</a></li>
<li><a href="../ar441528/index.html">كيف تحولت حياتي إلى كتاب كافكا</a></li>
<li><a href="../ar441530/index.html">سيتم إطلاق SDN في الفضاء: لماذا هذا مطلوب</a></li>
<li><a href="../ar441532/index.html">سمك السلور مقدمة</a></li>
<li><a href="../ar441534/index.html">موازن التحميل لأنظمة الأوركسترا</a></li>
<li><a href="../ar441538/index.html">معمارية مستودع البيانات: التقليدية والسحابة</a></li>
<li><a href="../ar441540/index.html">Vue mixins ، الطريقة الصريحة (على سبيل المثال من البرنامج المساعد لمعدلات BEM)</a></li>
<li><a href="../ar441546/index.html">Hayabusa-2 "تطرق لأول مرة الكويكب</a></li>
<li><a href="../ar441550/index.html">حياة مبرمج بسيط صعب وسهل</a></li>
<li><a href="../ar441554/index.html">تاريخ لينكس بأكمله. الجزء الأول: كيف بدأ كل شيء</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>