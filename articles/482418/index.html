<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 👖 👇🏼 Introducción al lenguaje de consulta cifrado 🐧 ⏩ 🥋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El lenguaje de consulta Cypher se desarrolló originalmente específicamente para el DBMS gráfico Neo4j . El objetivo de Cypher es proporcionar un lengu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducción al lenguaje de consulta cifrado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482418/"><p>  El lenguaje de consulta <em>Cypher</em> se desarrolló originalmente específicamente para el DBMS <a href="https://neo4j.com/" rel="nofollow">gráfico Neo4j</a> .  El objetivo de Cypher es proporcionar un lenguaje de consulta de base de datos gráfica legible por humanos similar a SQL.  Hoy, Cypher es compatible con varios DBMS de gráficos.  <a href="http://www.opencypher.org/" rel="nofollow">OpenCypher</a> fue creado para estandarizar Cypher. </p><br><p>  Los conceptos básicos para trabajar con Neo4j DBMS se describen en el artículo <a href="https://habr.com/ru/post/470541/">Conceptos básicos para trabajar con Neo4j en un navegador</a> . </p><br><p>  Para familiarizarse con Cypher, considere un ejemplo de un árbol genealógico tomado del clásico libro de texto Prolog por I. Bratko.  Este ejemplo mostrará cómo agregar nodos y enlaces a un gráfico, cómo asignarles etiquetas y atributos y cómo hacer preguntas. </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Árbol genealógico en Neo4j, vista editada"></p><a name="habracut"></a><br><p>  Entonces, tengamos un árbol genealógico que se muestra en la imagen a continuación. </p><br><p><img src="https://habrastorage.org/webt/zy/zf/v4/zyzfv4aasw-sokctup7s3vq4csi.png" alt="Árbol genealógico"></p><br><p>  Veamos cómo formar el gráfico correspondiente en Cypher: </p><br><pre><code class="plaintext hljs">CREATE (pam:Person {name: "Pam"}), (tom:Person {name: "Tom"}), (kate:Person {name: "Kate"}), (mary:Person {name: "Mary"}), (bob:Person {name: "Bob"}), (liz:Person {name: "Liz"}), (dick:Person {name: "Dick"}), (ann:Person {name: "Ann"}), (pat:Person {name: "Pat"}), (jack:Person {name: "Jack"}), (jim:Person {name: "Jim"}), (joli:Person {name: "Joli"}), (pam)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(liz), (kate)-[:PARENT]-&gt;(liz), (mary)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(pat), (dick)-[:PARENT]-&gt;(jim), (ann)-[:PARENT]-&gt;(jim), (pat)-[:PARENT]-&gt;(joli), (jack)-[:PARENT]-&gt;(joli)</code> </pre> <br><p>  Una solicitud CREATE para agregar datos a un DBMS gráfico consta de dos partes: agregar nodos y agregar enlaces entre ellos.  A cada nodo que se agregará se le asigna un nombre dentro del marco de esta solicitud, que luego se utiliza para crear enlaces.  Los nodos y las comunicaciones pueden almacenar documentos.  En nuestro caso, los nodos contienen documentos con los campos de nombre, y los enlaces de documentos no contienen.  También se pueden etiquetar nodos y enlaces.  En nuestro caso, a los nodos se les asigna la etiqueta Persona y los enlaces son PADRES.  La etiqueta en las solicitudes se resalta con dos puntos antes de su nombre. </p><br><p>  Entonces, Neo4j nos dijo que: <code>Added 12 labels, created 12 nodes, set 12 properties, created 11 relationships, completed after 9 ms.</code> </p><br><p>  Veamos que tenemos: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) RETURN p</code> </pre> <br><p><img src="https://habrastorage.org/webt/ch/gc/ya/chgcyawfcxryshb6p1xdjtf7fp8.png" alt="Árbol genealógico en Neo4j"></p><br><p>  Nadie nos prohíbe editar la apariencia del gráfico resultante: </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Árbol genealógico en Neo4j, vista editada"></p><br><p>  ¿Qué se puede hacer con esto?  Puede verificar que, por ejemplo, Pam es <br>  Padre de Bob: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans</code> </pre> <br><p>  Obtenemos el subgrafo correspondiente: </p><br><p><img src="https://habrastorage.org/webt/dj/jq/o_/djjqo_tukevpbd1viu8smouuume.png" alt="Pam es padre de Bob"></p><br><p>  Sin embargo, esto no es exactamente lo que necesitamos.  Cambiar la solicitud: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Ahora en respuesta nos hacemos <code>true</code> .  Y si preguntamos: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  No obtendremos nada ... Aquí debe agregar la palabra <code>OPTIONAL</code> , luego si <br>  el resultado estará vacío, luego se devolverá <code>false</code> : </p><br><pre> <code class="plaintext hljs">OPTIONAL MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Ahora obtenemos la respuesta esperada <code>false</code> . </p><br><p>  A continuación, puede ver quién es el padre para quién: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[:PARENT]-&gt;(p2:Person) RETURN p1, p2</code> </pre> <br><p>  Abra la pestaña de resultados con <code>Text</code> y vea una tabla con dos columnas: </p><br><pre> <code class="plaintext hljs">╒═══════════════╤═══════════════╕ │"p1" │"p2" │ ╞═══════════════╪═══════════════╡ │{"name":"Pam"} │{"name":"Bob"} │ ├───────────────┼───────────────┤ │{"name":"Tom"} │{"name":"Bob"} │ ├───────────────┼───────────────┤ │{"name":"Tom"} │{"name":"Liz"} │ ├───────────────┼───────────────┤ │{"name":"Kate"}│{"name":"Liz"} │ ├───────────────┼───────────────┤ │{"name":"Mary"}│{"name":"Ann"} │ ├───────────────┼───────────────┤ │{"name":"Bob"} │{"name":"Ann"} │ ├───────────────┼───────────────┤ │{"name":"Bob"} │{"name":"Pat"} │ ├───────────────┼───────────────┤ │{"name":"Dick"}│{"name":"Jim"} │ ├───────────────┼───────────────┤ │{"name":"Ann"} │{"name":"Jim"} │ ├───────────────┼───────────────┤ │{"name":"Pat"} │{"name":"Joli"}│ ├───────────────┼───────────────┤ │{"name":"Jack"}│{"name":"Joli"}│ └───────────────┴───────────────┘</code> </pre> <br><p>  ¿Qué más podemos aprender?  Por ejemplo, quién es el padre de un miembro específico del género, por ejemplo, para Bob: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Tom" │ ├─────────────┤ │"Pam" │ └─────────────┘</code> </pre> <br><p>  Aquí, como respuesta, no solicitamos el nodo completo, sino solo su atributo específico. </p><br><p>  También podemos averiguar quiénes son los hijos de Bob: </p><br><pre> <code class="plaintext hljs">MATCH (:Person {name: "Bob"})-[:PARENT]-&gt;(child:Person) RETURN child.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════════╕ │"child.name"│ ╞════════════╡ │"Ann" │ ├────────────┤ │"Pat" │ └────────────┘</code> </pre> <br><p>  También podemos preguntar quién tiene hijos: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Pam" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Kate" │ ├─────────────┤ │"Mary" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Dick" │ ├─────────────┤ │"Ann" │ ├─────────────┤ │"Pat" │ ├─────────────┤ │"Jack" │ └─────────────┘</code> </pre> <br><p>  Hmm, Tom y Bob se encontraron dos veces, arréglenlo: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN DISTINCT parent.name</code> </pre> <br><p>  Agregamos la palabra <code>DISTINCT</code> al resultado devuelto de la consulta, lo que significa <br>  similar a eso en SQL. </p><br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Pam" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Kate" │ ├─────────────┤ │"Mary" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Dick" │ ├─────────────┤ │"Ann" │ ├─────────────┤ │"Pat" │ ├─────────────┤ │"Jack" │ └─────────────┘</code> </pre> <br><p>  También puede notar que Neo4j nos devuelve a los padres en el orden en que fueron ingresados ​​en la solicitud <code>CREATE</code> . </p><br><p>  Ahora preguntemos quién es abuelo o abuela: </p><br><pre> <code class="plaintext hljs">MATCH (grandparent:Person)-[:PARENT]-&gt;()-[:PARENT]-&gt;(:Person) RETURN DISTINCT grandparent.name</code> </pre> <br><p>  Genial, eso es todo: </p><br><pre> <code class="plaintext hljs">╒══════════════════╕ │"grandparent.name"│ ╞══════════════════╡ │"Tom" │ ├──────────────────┤ │"Pam" │ ├──────────────────┤ │"Bob" │ ├──────────────────┤ │"Mary" │ └──────────────────┘</code> </pre> <br><p>  En la plantilla de consulta, utilizamos un nodo sin nombre intermedio <code>()</code> y dos relaciones de tipo <code>PARENT</code> . </p><br><p>  Ahora descubrimos quién es el padre.  El padre es un hombre que tiene un hijo.  Por lo tanto, nos faltan datos sobre quién es el hombre.  En consecuencia, para determinar quién es una madre, necesita saber quién es una mujer.  Agregue la información relevante a nuestra base de datos.  Para hacer esto, asignaremos las etiquetas <code>Male</code> y <code>Female</code> a los nodos existentes. </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Tom", "Dick", "Bob", "Jim", "Jack"] SET p:Male</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Pam", "Kate", "Mary", "Liz", "Ann", "Pat", "Joli"] SET p:Female</code> </pre> <br><p>  Expliquemos lo que hicimos aquí: seleccionamos todos los nodos etiquetados como <code>Person</code> , los verificamos <br>  la propiedad de <code>name</code> acuerdo con la lista dada especificada entre corchetes, y asignó a los nodos correspondientes la etiqueta <code>Male</code> o <code>Female</code> respectivamente. </p><br><p>  Comprobar: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Male RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Tom" │ ├────────┤ │"Bob" │ ├────────┤ │"Dick" │ ├────────┤ │"Jack" │ ├────────┤ │"Jim" │ └────────┘</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Female RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Pam" │ ├────────┤ │"Kate" │ ├────────┤ │"Mary" │ ├────────┤ │"Liz" │ ├────────┤ │"Ann" │ ├────────┤ │"Pat" │ ├────────┤ │"Joli" │ └────────┘</code> </pre> <br><p>  Solicitamos todos los nodos etiquetados como <code>Person</code> , que también tienen una etiqueta de <code>Male</code> o <code>Female</code> , respectivamente.  Pero podríamos hacer que nuestras solicitudes sean un poco diferentes: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male) RETURN p.name MATCH (p:Person:Female) RETURN p.name</code> </pre> <br><p>  Echemos un vistazo a nuestro gráfico nuevamente: </p><br><p><img src="https://habrastorage.org/webt/zc/nn/pj/zcnnpj6ynprgddwmbdhoh3ubjp8.png" alt="Árbol genealógico con etiquetas Macho y Hembra"></p><br><p>  Neo4j Browser pintó los nodos en dos colores diferentes según las marcas de Male y <br>  Hembra </p><br><p>  Ok, ahora podemos consultar a todos los padres de la base de datos: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Tom" │ ├────────┤ │"Bob" │ ├────────┤ │"Dick" │ ├────────┤ │"Jack" │ └────────┘</code> </pre> <br><p>  Y madres: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Female)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Pam" │ ├────────┤ │"Kate" │ ├────────┤ │"Mary" │ ├────────┤ │"Ann" │ ├────────┤ │"Pat" │ └────────┘</code> </pre> <br><p>  Ahora formulemos una relación de hermano y hermana.  X es hermano de Y, <br>  si él es un hombre, y para X e Y hay al menos un padre común.  Del mismo modo para <br>  relación hermana </p><br><p>  Actitud del hermano en Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (brother:Person:Male)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN brother.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒══════════════╤════════╕ │"brother.name"│"p.name"│ ╞══════════════╪════════╡ │"Bob" │"Liz" │ └──────────────┴────────┘</code> </pre> <br><p>  Actitud de hermana en Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (sister:Person:Female)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN sister.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╤════════╕ │"sister.name"│"p.name"│ ╞═════════════╪════════╡ │"Liz" │"Bob" │ ├─────────────┼────────┤ │"Ann" │"Pat" │ ├─────────────┼────────┤ │"Pat" │"Ann" │ └─────────────┴────────┘</code> </pre> <br><p>  Entonces, podemos averiguar quién es el padre y quién es el abuelo o la abuela.  ¿Pero qué hay de los ancestros más distantes?  ¿Con bisabuelos, bisabuelos, etc.?  No escribiremos una regla correspondiente para cada caso, y será cada vez más problemático.  De hecho, todo es simple: X es un ancestro de Y si es un ancestro de un padre Y. Cypher proporciona un patrón <code>*</code> que le permite requerir una secuencia de relaciones de cualquier longitud: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Realmente hay un problema en esto: será cualquier conexión.  Agregue una referencia al enlace <code>PARENT</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Para no aumentar la longitud del artículo, encontramos a todos los antepasados ​​de <code>Joli</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(:Person {name: "Joli"}) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Jack" │ ├────────┤ │"Pat" │ ├────────┤ │"Bob" │ ├────────┤ │"Pam" │ ├────────┤ │"Tom" │ └────────┘</code> </pre> <br><p>  Considere una regla más compleja para descubrir quién está relacionado con quién. <br>  Primero, los parientes son antepasados ​​y descendientes, por ejemplo, un hijo y una madre, abuela y nieto.  En segundo lugar, los parientes son hermanos y hermanas, incluidos primos, primos segundos, etc., lo que en términos de antepasados ​​significa que tienen un antepasado común.  Y en tercer lugar, los familiares que tienen descendientes comunes, por ejemplo, marido y mujer, se consideran familiares. </p><br><p>  En Cypher, debe usar <code>UNION</code> para muchos patrones: </p><br><pre> <code class="plaintext hljs">MATCH (r1:Person)-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)&lt;-[:PARENT*]-(:Person)-[:PARENT*]-&gt;(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)-[:PARENT*]-&gt;(:Person)&lt;-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name</code> </pre> <br><p>  Aquí, en la primera regla, se usan conexiones, cuya dirección no nos importa.  Tal conexión se indica sin una flecha, solo un guión <code>-</code> .  La segunda y tercera regla están escritas de una manera obvia y familiar. </p><br><p>  No presentaremos el resultado de la consulta total aquí, solo diremos que los pares de familiares encontrados son 132, lo que es consistente con el valor calculado como el número de pares ordenados de 12. También podríamos especificar esta consulta reemplazando la aparición de la variable <code>r1</code> o <code>r2</code> con <code>(:Person {name: "Liz"})</code> por ejemplo, sin embargo, en nuestro caso esto no tiene mucho sentido, ya que todas las personas en nuestra base de datos son obviamente familiares. </p><br><p>  Esto concluye nuestra discusión sobre la identificación de relaciones entre personas en nuestra base de datos. </p><br><p>  Por último, considere cómo eliminar nodos y enlaces. </p><br><p>  Para eliminar a todas nuestras personas, puede ejecutar la solicitud: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) DELETE p</code> </pre> <br><p>  Sin embargo, Neo4j nos dirá que no puede eliminar nodos que tienen enlaces. <br>  Por lo tanto, primero eliminamos los enlaces y luego repetimos la eliminación de nodos: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[r]-&gt;(p2:Person) DELETE r</code> </pre> <br><p>  Lo que hemos hecho ahora: comparó a dos personas entre las cuales hay una conexión, nombró esta conexión como <code>r</code> y luego la eliminó. </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  El artículo muestra cómo usar las capacidades del lenguaje de consulta Cypher usando un ejemplo simple de un gráfico social.  En particular, examinamos cómo agregar nodos y enlaces con una consulta, cómo buscar datos relacionados, incluso con enlaces indirectos, y cómo asignar etiquetas a los nodos.  Puede encontrar más información sobre Cypher en los enlaces a continuación.  Un buen punto de partida es la "Neo4j Cypher Refcard". </p><br><p>  Neo4j está lejos de ser el único gráfico DBMS.  Entre los otros más populares se encuentran <a href="https://www.cayley.io/" rel="nofollow">Cayley</a> , <a href="https://dgraph.io/" rel="nofollow">Dgraph</a> con lenguaje de consulta GraphQL, <a href="https://www.arangodb.com/" rel="nofollow">ArangoDB</a> y <a href="http://orientdb.com/" rel="nofollow">OrientDB multimodelos</a> .  De particular interés puede ser <a href="https://www.blazegraph.com/" rel="nofollow">Blazegraph</a> con soporte para RDF y SPARQL. </p><br><h2 id="ssylki">  Referencias </h2><br><ul><li>  <a href="https://neo4j.com/developer/cypher-query-language/" rel="nofollow">Neo4j: una introducción a Cypher</a> </li><li>  <a href="https://neo4j.com/docs/cypher-refcard/current/" rel="nofollow">Neo4j Cypher Refcard</a> </li><li>  <a href="http://www.opencypher.org/" rel="nofollow">openCypher</a> </li></ul><br><h2 id="bibliografiya">  Bibliografia </h2><br><ul><li>  Robinson Jan, Weber Jim, Eifrem Emil.  Graficar bases de datos.  Nuevas características <br>  para trabajar con datos relacionados / por.  del ingles  - 2da ed.  - M .: DMK-Press, <br>  2016 - 256 s. </li><li>  Bratko I.Programación en lenguaje Prolog para inteligencia artificial: <br>  trans.  del ingles  - M.: Mir, 1990 .-- 560 p.: Ill. </li></ul><br><h2 id="posleslovie">  Epílogo </h2><br><p>  El autor del artículo conoce solo dos empresas (ambas de San Petersburgo) que utilizan DBMS de gráficos para sus productos.  Pero me gustaría saber cuántas empresas de lectores de este artículo los usan en su desarrollo.  Por lo tanto, propongo participar en la encuesta.  Escriba también sobre su experiencia en los comentarios, será muy interesante saberlo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482418/">https://habr.com/ru/post/482418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482402/index.html">Patrón de fábrica Ejemplo de aplicación en Unity</a></li>
<li><a href="../482404/index.html">Nemotecnia: explorando métodos para aumentar la memoria cerebral</a></li>
<li><a href="../482406/index.html">Los mejores libros de DLC para la serie de ciencia ficción moderna</a></li>
<li><a href="../482410/index.html">Contemplación de la gran semejanza fractal</a></li>
<li><a href="../482416/index.html">Reemplazamos el Asistente de Google con la red neuronal Porfirevich y el troll Alice</a></li>
<li><a href="../482420/index.html">JavaFX - aún no está muerto</a></li>
<li><a href="../482426/index.html">Väterchen Frost o seis dígitos para Habr</a></li>
<li><a href="../482428/index.html">Dotnetru 2019. Resultados</a></li>
<li><a href="../482430/index.html">Estudiar no es una lotería, las métricas mienten</a></li>
<li><a href="../482432/index.html">TI en el sistema escolar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>