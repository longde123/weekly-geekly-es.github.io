<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö® üë®üèø‚Äçüé§ üéÑ Prinzipien der funktionalen Programmierung in JavaScript üö∫ üë®üèº‚Äçüîß üë©üèΩ‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass er nach langer Zeit in der objektorientierten Programmierung √ºber di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prinzipien der funktionalen Programmierung in JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/434112/">  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass er nach langer Zeit in der objektorientierten Programmierung √ºber die Komplexit√§t von Systemen nachgedacht habe.  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">John Ousterhout</a> ist Komplexit√§t alles, was das Verst√§ndnis oder die √Ñnderung von Software erschwert.  Der Autor dieses Artikels entdeckte nach einigen Recherchen die Konzepte der funktionalen Programmierung wie Immunit√§t und reine Funktionen.  Durch die Verwendung solcher Konzepte k√∂nnen Sie Funktionen erstellen, die keine Nebenwirkungen haben.  Die Verwendung dieser Funktionen vereinfacht die Systemunterst√ºtzung und bietet dem Programmierer einige weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorteile</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/abe/e25/7a4/abee257a40cc002c1bdb228bd744ab90.png" alt="Bild"></a> <br><br>  Hier sprechen wir √ºber funktionale Programmierung und einige ihrer wichtigen Prinzipien.  All dies wird durch viele JavaScript-Codebeispiele veranschaulicht. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist funktionale Programmierung?</font> </h2><br>  Sie k√∂nnen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> nachlesen, was funktionale Programmierung ist.  Wir sprechen n√§mlich √ºber die Tatsache, dass die funktionale Programmierung ein Programmierparadigma ist, bei dem der Berechnungsprozess als Berechnung der Werte von Funktionen im mathematischen Verst√§ndnis des letzteren behandelt wird.  Die funktionale Programmierung umfasst die Berechnung der Ergebnisse von Funktionen aus den Quelldaten und den Ergebnissen anderer Funktionen und impliziert keine explizite Speicherung des Programmstatus.  Dementsprechend impliziert dies nicht die Variabilit√§t dieses Zustands. <br><br>  Anhand von Beispielen werden wir nun einige Ideen der funktionalen Programmierung analysieren. <br><br><h2>  <font color="#3AC1EF">Reine Funktionen</font> </h2><br>  Reine Funktionen sind das erste grundlegende Konzept, das untersucht werden muss, um die Essenz der funktionalen Programmierung zu verstehen. <br><br>  Was ist eine ‚Äûreine Funktion‚Äú?  Was macht eine Funktion ‚Äûsauber‚Äú?  Eine reine Funktion muss folgende Anforderungen erf√ºllen: <br><br><ul><li>  Es gibt immer das gleiche Ergebnis zur√ºck, wenn dieselben Argumente √ºbergeben werden (solche Funktionen werden auch als deterministisch bezeichnet). </li><li>  Eine solche Funktion hat keine Nebenwirkungen. </li></ul><br>  Betrachten Sie die erste Eigenschaft reiner Funktionen, n√§mlich die Tatsache, dass sie, wenn sie dieselben Argumente an sie √ºbergeben, immer dasselbe Ergebnis zur√ºckgeben. <br><br><h3>  <font color="#3AC1EF">‚ñç Funktionsargumente und R√ºckgabewerte</font> </h3><br>  Stellen Sie sich vor, wir m√ºssen eine Funktion erstellen, die die Fl√§che eines Kreises berechnet.  Eine Funktion, die nicht rein ist, w√ºrde als Parameter den Radius des Kreises ( <code>radius</code> ) verwenden, wonach sie den Wert der Berechnung des Ausdrucks <code>radius * radius * PI</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateArea</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radius</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> radius * radius * PI; } calculateArea(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  314</span></span></code> </pre> <br>  Warum kann diese Funktion nicht als rein bezeichnet werden?  Tatsache ist, dass es eine globale Konstante verwendet, die nicht als Argument an sie √ºbergeben wird. <br><br>  Stellen Sie sich nun vor, dass einige Mathematiker zu dem Schluss gekommen sind, dass der Wert der Konstante <code>PI</code> die Zahl <code>42</code> , wodurch der Wert dieser Konstante ge√§ndert wurde. <br><br>  Jetzt gibt eine Funktion, die nicht rein ist, wenn ihr der gleiche Eingabewert, die Zahl <code>10</code> , √ºbergeben wird, den Wert <code>10 * 10 * 42 = 4200</code> .  Es stellt sich heraus, dass die Funktion bei Verwendung des Wertes des <code>radius</code> Parameters wie im vorherigen Beispiel ein anderes Ergebnis zur√ºckgibt.  Lassen Sie uns das beheben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateArea</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radius, pi</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> radius * radius * pi; } calculateArea(<span class="hljs-number"><span class="hljs-number">10</span></span>, PI); <span class="hljs-comment"><span class="hljs-comment">//  314</span></span></code> </pre> <br>  Wenn wir diese Funktion aufrufen, √ºbergeben wir ihr immer das Argument <code>pi</code> .  Infolgedessen funktioniert die Funktion nur mit dem, was beim Aufruf an sie √ºbergeben wird, ohne auf globale Entit√§ten zur√ºckzugreifen.  Wenn wir das Verhalten dieser Funktion analysieren, k√∂nnen wir zu folgenden Schlussfolgerungen kommen: <br><br><ul><li>  Wenn die Funktionen das Argument mit einem <code>radius</code> von <code>10</code> und einem Argument <code>pi</code> von <code>3.14</code> , wird immer das gleiche Ergebnis zur√ºckgegeben - <code>314</code> . </li><li>  Bei einem Aufruf mit einem <code>radius</code> von <code>10</code> und einem <code>pi</code> von <code>42</code> wird immer <code>4200</code> . </li></ul><br><h4>  Dateien lesen </h4><br>  Wenn unsere Funktion Dateien liest, ist sie nicht sauber.  Tatsache ist, dass sich der Inhalt der Dateien √§ndern kann. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">charactersCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Character count: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${text.length}</span></span></span><span class="hljs-string">`</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyzeFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileContent = open(filename); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> charactersCounter(fileContent); }</code> </pre> <br><h4>  Zufallszahlengenerierung </h4><br>  Jede Funktion, die auf einem Zufallszahlengenerator basiert, kann nicht rein sein. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yearEndEvaluation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"You get a raise!"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Better luck next year!"</span></span>; } }</code> </pre> <br>  Lassen Sie uns nun √ºber Nebenwirkungen sprechen. <br><br><h3>  <font color="#3AC1EF">‚ñç Nebenwirkungen</font> </h3><br>  Ein Beispiel f√ºr einen Nebeneffekt, der beim Aufrufen einer Funktion auftreten kann, ist die √Ñnderung globaler Variablen oder Argumente, die als Referenz an Funktionen √ºbergeben werden. <br><br>  Angenommen, wir m√ºssen eine Funktion erstellen, die eine Ganzzahl verwendet und diese Zahl um 1 erh√∂ht. So k√∂nnte eine Implementierung einer √§hnlichen Idee aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increaseCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ counter = value + <span class="hljs-number"><span class="hljs-number">1</span></span>; } increaseCounter(counter); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter); <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code> </pre> <br>  Es gibt einen globalen Variablenz√§hler.  Unsere Funktion, die nicht rein ist, empf√§ngt diesen Wert als Argument und √ºberschreibt ihn, indem sie einen zum vorherigen Wert hinzuf√ºgt. <br><br>  Die globale Variable √§ndert sich, √§hnlich wie bei der funktionalen Programmierung ist dies nicht erw√ºnscht. <br><br>  In unserem Fall wird der Wert der globalen Variablen ge√§ndert.  Wie kann die Funktion "boostCounter <code>increaseCounter()</code> unter diesen Bedingungen sauber gemacht werden?  In der Tat ist es sehr einfach: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increaseCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value + <span class="hljs-number"><span class="hljs-number">1</span></span>; } increaseCounter(counter); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(counter); // 1</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, gibt die Funktion <code>2</code> , aber der Wert des globalen Variablenz√§hlers √§ndert sich nicht.  Hier k√∂nnen wir schlie√üen, dass die Funktion den an sie √ºbergebenen Wert zur√ºckgibt, erh√∂ht um <code>1</code> , ohne etwas zu √§ndern. <br><br>  Wenn Sie die beiden oben genannten Regeln zum Schreiben reiner Funktionen befolgen, wird die Navigation in Programmen, die mit solchen Funktionen erstellt wurden, erleichtert.  Es stellt sich heraus, dass jede Funktion isoliert ist und die Teile des Programms au√üerhalb davon nicht beeinflusst. <br><br>  Reine Funktionen sind stabil, konsistent und vorhersehbar.  Wenn diese Funktionen dieselben Eingabedaten empfangen, geben sie immer dasselbe Ergebnis zur√ºck.  Dies erspart dem Programmierer den Versuch, die M√∂glichkeit von Situationen zu ber√ºcksichtigen, in denen die √úbertragung von Funktionen derselben Parameter zu unterschiedlichen Ergebnissen f√ºhrt, da dies mit reinen Funktionen einfach unm√∂glich ist. <br><br><h3>  <font color="#3AC1EF">‚ñç St√§rken reiner Funktionen</font> </h3><br>  Zu den St√§rken reiner Funktionen geh√∂rt die Tatsache, dass mit ihnen geschriebener Code leichter zu testen ist.  Insbesondere m√ºssen Sie keine Stub-Objekte erstellen.  Dies erm√∂glicht Unit-Tests von reinen Funktionen in verschiedenen Kontexten: <br><br><ul><li>  Wenn Parameter A an die Funktion √ºbergeben wird, wird der R√ºckgabewert von B erwartet. </li><li>  Wenn Parameter C an die Funktion √ºbergeben wird, wird der R√ºckgabewert von D erwartet. </li></ul><br>  Als einfaches Beispiel f√ºr diese Idee k√∂nnen wir eine Funktion angeben, die ein Array von Zahlen akzeptiert, und es wird erwartet, dass sie sich bei jeder Nummer dieses Arrays um eins erh√∂ht und ein neues Array mit den folgenden Ergebnissen zur√ºckgibt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> list = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementNumbers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number</span></span></span><span class="hljs-function"> =&gt;</span></span> number + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Hier √ºbergeben wir ein Array von Zahlen an die Funktion. Anschlie√üend verwenden wir die Array-Methode <code>map()</code> , mit der wir jedes Element des Arrays √§ndern und ein neues Array bilden k√∂nnen, das von der Funktion zur√ºckgegeben wird.  Wir rufen die Funktion auf, indem wir ihr ein Listenarray √ºbergeben: <br><br><pre> <code class="javascript hljs">incrementNumbers(list); <span class="hljs-comment"><span class="hljs-comment">//  [2, 3, 4, 5, 6]</span></span></code> </pre> <br>  Von dieser Funktion wird erwartet, dass nach Annahme eines Arrays der Form <code>[1, 2, 3, 4, 5]</code> ein neues Array <code>[2, 3, 4, 5, 6]</code> .  So funktioniert es. <br><br><h2>  <font color="#3AC1EF">Immunit√§t</font> </h2><br>  Die Immunit√§t einer bestimmten Entit√§t kann als die Tatsache beschrieben werden, dass sie sich im Laufe der Zeit nicht √§ndert, oder als die Unm√∂glichkeit, diese Entit√§t zu √§ndern. <br><br>  Wenn sie versuchen, ein unver√§nderliches Objekt zu √§ndern, ist dies nicht erfolgreich.  Stattdessen m√ºssen Sie ein neues Objekt erstellen, das die neuen Werte enth√§lt. <br><br>  Beispielsweise verwendet JavaScript h√§ufig die <code>for</code> Schleife.  Im Verlauf seiner Arbeit werden, wie unten gezeigt, ver√§nderbare Variablen verwendet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> values = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sumOfValues = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; values.length; i++) { sumOfValues += values[i]; } sumOfValues <span class="hljs-comment"><span class="hljs-comment">// 15</span></span></code> </pre> <br>  Bei jeder Iteration der Schleife <code>sumOfValues</code> der Wert der Variablen <code>i</code> und der Wert der globalen Variablen (dies kann als Status des Programms angesehen werden) <code>sumOfValues</code> .  Wie kann in einer solchen Situation die Unver√§nderlichkeit von Unternehmen aufrechterhalten werden?  Die Antwort liegt in der Verwendung von Rekursion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> list = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list, accumulator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulator; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(list.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>), accumulator + list[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } sum(list, accumulator); <span class="hljs-comment"><span class="hljs-comment">// 15 list; // [1, 2, 3, 4, 5] accumulator; // 0</span></span></code> </pre> <br>  Es gibt eine Funktion <code>sum()</code> , die ein Array von Zahlen akzeptiert.  Diese Funktion ruft sich selbst auf, bis das Array leer ist (dies ist der Grundfall unseres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rekursiven Algorithmus</a> ).  Bei jeder solchen "Iteration" addieren wir den Wert eines der Elemente des Arrays zum Parameter der <code>accumulator</code> , ohne den globalen variablen <code>accumulator</code> .  In diesem Fall bleiben die <code>list</code> der globalen Variablen und der <code>accumulator</code> unver√§ndert, und vor und nach dem Funktionsaufruf werden dieselben Werte in ihnen gespeichert. <br><br>  Es ist zu beachten, dass Sie zur Implementierung eines solchen Algorithmus <code>reduce</code> Methode zum <code>reduce</code> Arrays verwenden k√∂nnen.  Wir werden weiter unten dar√ºber sprechen. <br><br>  In der Programmierung ist die Aufgabe weit verbreitet, wenn es erforderlich ist, basierend auf einer bestimmten Vorlage eines Objekts seine endg√ºltige Darstellung zu erstellen.  Stellen Sie sich vor, wir haben eine Zeichenfolge, die in eine Ansicht konvertiert werden muss, die als Teil der URL verwendet werden kann, die zu einer bestimmten Ressource f√ºhrt. <br><br>  Wenn wir dieses Problem mit Ruby und den Prinzipien von OOP l√∂sen, erstellen wir zuerst eine Klasse, beispielsweise <code>UrlSlugify</code> , und erstellen dann eine Methode f√ºr diese Klasse <code>slugify!</code>  Hiermit wird die Zeichenfolge konvertiert. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UrlSlugify</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attr_reader</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">)   @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class"> </span></span>= text end def slugify!   text.downcase!   text.strip!   text.gsub!(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>) end end UrlSlugify.new(<span class="hljs-string"><span class="hljs-string">' I will be a url slug   '</span></span>).slugify! # <span class="hljs-string"><span class="hljs-string">"i-will-be-a-url-slug"</span></span></code> </pre> <br>  Wir haben den Algorithmus implementiert, und das ist wunderbar.  Hier sehen wir einen zwingenden Ansatz f√ºr die Programmierung, wenn wir bei der Verarbeitung der Linie jeden Schritt ihrer Transformation malen.  Zuerst reduzieren wir die Zeichen auf Kleinbuchstaben, entfernen dann unn√∂tige Leerzeichen und √§ndern schlie√ülich die verbleibenden Leerzeichen auf dem Bindestrich. <br><br>  W√§hrend dieser Transformation tritt jedoch eine Mutation des Programmzustands auf. <br><br>  Sie k√∂nnen das Mutationsproblem bew√§ltigen, indem Sie Funktionen erstellen oder Funktionsaufrufe verketten.  Mit anderen Worten, das von der Funktion zur√ºckgegebene Ergebnis wird als Eingabe f√ºr die n√§chste Funktion und damit f√ºr alle Funktionen in einer Kette verwendet.  In diesem Fall √§ndert sich die urspr√ºngliche Zeichenfolge nicht. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string = <span class="hljs-string"><span class="hljs-string">" I will be a url slug   "</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slugify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string.toLowerCase()   .trim()   .split(<span class="hljs-string"><span class="hljs-string">" "</span></span>)   .join(<span class="hljs-string"><span class="hljs-string">"-"</span></span>); } slugify(string); <span class="hljs-comment"><span class="hljs-comment">// i-will-be-a-url-slug</span></span></code> </pre> <br>  Hier verwenden wir die folgenden Funktionen, die in JavaScript durch Standard-String- und Array-Methoden dargestellt werden: <br><br><ul><li>  <code>toLowerCase</code> : Konvertiert Zeichenfolgen in <code>toLowerCase</code> . </li><li>  <code>trim</code> : Entfernt Leerzeichen vom Anfang und Ende einer Zeile. </li><li>  <code>split</code> : Teilt eine Zeichenfolge in Teile und platziert W√∂rter, die durch Leerzeichen in einem Array getrennt sind. </li><li>  <code>join</code> : bildet eine Zeichenfolge mit W√∂rtern, die durch einen Bindestrich getrennt sind, basierend auf einem Array mit W√∂rtern. </li></ul><br>  Mit diesen vier Funktionen k√∂nnen Sie eine Funktion zum Konvertieren einer Zeichenfolge erstellen, die diese Zeichenfolge selbst nicht √§ndert. <br><br><h2>  <font color="#3AC1EF">Transparenz verkn√ºpfen</font> </h2><br>  Erstellen Sie ein Funktionsquadrat <code>square()</code> , das das Ergebnis der Multiplikation einer Zahl mit derselben Zahl zur√ºckgibt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * n; }</code> </pre> <br>  Dies ist eine reine Funktion, die f√ºr denselben Eingabewert immer denselben Ausgabewert zur√ºckgibt. <br><br><pre> <code class="javascript hljs">square(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 4 square(2); // 4 square(2); // 4 // ...</span></span></code> </pre> <br>  Unabh√§ngig davon, wie viele Zahlen <code>2</code> an sie √ºbergeben werden, gibt diese Funktion beispielsweise immer die Zahl <code>4</code> .  Infolgedessen stellt sich heraus, dass ein Aufruf des Formularquadrats <code>square(2)</code> durch die Nummer <code>4</code> .  Dies bedeutet, dass unsere Funktion die Eigenschaft der referenziellen Transparenz hat. <br><br>  Im Allgemeinen k√∂nnen wir sagen, dass eine Funktion, die immer dasselbe Ergebnis f√ºr dieselben an sie √ºbergebenen Eingabewerte zur√ºckgibt, referenzielle Transparenz aufweist. <br><br><h3>  <font color="#3AC1EF">‚ñç Reine Funktionen + unver√§nderliche Daten = referenzielle Transparenz</font> </h3><br>  Mit der im Titel dieses Abschnitts vorgestellten Idee k√∂nnen Sie Funktionen auswendig lernen.  Angenommen, wir haben eine Funktion wie diese: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }</code> </pre> <br>  Wir nennen es so: <br><br><pre> <code class="javascript hljs">sum(<span class="hljs-number"><span class="hljs-number">3</span></span>, sum(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>));</code> </pre> <br>  Das Aufrufen der <code>sum(5, 8)</code> ergibt immer <code>13</code> .  Daher kann der obige Aufruf wie folgt umgeschrieben werden: <br><br><pre> <code class="javascript hljs">sum(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>);</code> </pre> <br>  Dieser Ausdruck ergibt wiederum immer <code>16</code> .  Infolgedessen kann es durch eine numerische Konstante ersetzt und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gespeichert werden</a> . <br><br><h2>  <font color="#3AC1EF">Funktioniert als erstklassige Objekte</font> </h2><br>  Die Idee, Funktionen als Objekte der ersten Klasse wahrzunehmen, besteht darin, dass solche Funktionen als Werte betrachtet werden k√∂nnen und mit ihnen als Daten arbeiten.  Folgende Merkmale der Funktionen k√∂nnen unterschieden werden: <br><br><ul><li>  Verweise auf Funktionen k√∂nnen in Konstanten und Variablen gespeichert werden und √ºber diese auf Funktionen zugreifen. </li><li>  Funktionen k√∂nnen als Parameter an andere Funktionen √ºbergeben werden. </li><li>  Funktionen k√∂nnen von anderen Funktionen zur√ºckgegeben werden. </li></ul><br>  Das hei√üt, es geht darum, Funktionen als Werte zu betrachten und sie wie Daten zu behandeln.  Mit diesem Ansatz k√∂nnen Sie verschiedene Funktionen kombinieren, um neue Funktionen zu erstellen, die neue Funktionen implementieren. <br><br>  Stellen Sie sich vor, wir haben eine Funktion, die zwei √ºbergebene numerische Werte hinzuf√ºgt, diese dann mit <code>2</code> multipliziert und das zur√ºckgibt, was sich herausgestellt hat: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doubleSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) * <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br>  Jetzt schreiben wir eine Funktion, die die Sekunde vom ersten an sie √ºbergebenen numerischen Wert subtrahiert, das Geschehene mit <code>2</code> multipliziert und den berechneten Wert zur√ºckgibt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doubleSubtraction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a - b) * <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br>  Diese Funktionen haben eine √§hnliche Logik, sie unterscheiden sich nur darin, welche Art von Operationen sie mit den an sie √ºbergebenen Zahlen ausf√ºhren.  Wenn wir Funktionen als Werte betrachten und sie als Argumente an andere Funktionen √ºbergeben k√∂nnen, bedeutet dies, dass wir eine Funktion erstellen k√∂nnen, die eine andere Funktion akzeptiert und verwendet, die die Merkmale der Berechnungen beschreibt.  Diese √úberlegungen erm√∂glichen es uns, die folgenden Konstruktionen zu erreichen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtraction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doubleOperator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(a, b) * <span class="hljs-number"><span class="hljs-number">2</span></span>; } doubleOperator(sum, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 8 doubleOperator(subtraction, 3, 1); // 4</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, hat die Funktion <code>doubleOperator()</code> jetzt einen Parameter <code>f</code> , und die Funktion, die sie darstellt, wird zum Verarbeiten der Parameter <code>a</code> und <code>b</code> .  Mit den an die Funktion <code>substraction()</code> Funktionen <code>sum()</code> und <code>substraction()</code> k√∂nnen Sie das Verhalten der Funktion <code>doubleOperator()</code> steuern und entsprechend der darin implementierten Logik √§ndern. <br><br><h2>  <font color="#3AC1EF">Funktionen h√∂herer Ordnung</font> </h2><br>  Unter Funktionen h√∂herer Ordnung verstehen wir Funktionen, die durch mindestens eines der folgenden Merkmale gekennzeichnet sind: <br><br><ul><li>  Eine Funktion verwendet eine andere Funktion als Argument (es kann mehrere solcher Funktionen geben). </li><li>  Die Funktion gibt als Ergebnis ihrer Arbeit eine andere Funktion zur√ºck. </li></ul><br>  M√∂glicherweise sind Sie bereits mit den Standard-JS-Array-Methoden <code>filter()</code> , <code>map()</code> und <code>reduce()</code> vertraut.  Reden wir √ºber sie. <br><br><h3>  <font color="#3AC1EF">‚ñç Filtern von Arrays und der filter () -Methode</font> </h3><br>  Angenommen, wir haben eine bestimmte Sammlung von Elementen, die wir nach Attributen der Elemente dieser Sammlung filtern und eine neue Sammlung bilden m√∂chten.  Die Funktion <code>filter()</code> erwartet ein Kriterium f√ºr die Bewertung der Elemente, anhand dessen bestimmt wird, ob ein Element in die resultierende Sammlung aufgenommen werden soll oder nicht.  Dieses Kriterium wird durch die an sie √ºbergebene Funktion definiert, die <code>true</code> zur√ºckgibt <code>true</code> wenn die Funktion <code>filter()</code> ein Element in die endg√ºltige Auflistung aufnehmen soll, andernfalls <code>false</code> . <br><br>  Stellen Sie sich vor, wir haben ein Array von Ganzzahlen und m√∂chten es filtern, indem wir ein neues Array erhalten, das nur gerade Zahlen aus dem urspr√ºnglichen Array enth√§lt. <br><br><h4>  Imperativer Ansatz </h4><br>  Wenn Sie einen zwingenden Ansatz zur L√∂sung dieses Problems mit JavaScript anwenden, m√ºssen Sie die folgende Abfolge von Aktionen implementieren: <br><br><ul><li>  Erstellen Sie ein leeres Array f√ºr neue Elemente (nennen wir es sogar <code>evenNumbers</code> ). </li><li>  Iterieren Sie √ºber das urspr√ºngliche Array von Ganzzahlen (nennen wir es <code>numbers</code> ). </li><li>  <code>evenNumbers</code> Sie die im Zahlenarray gefundenen geraden Zahlen in das Array <code>evenNumbers</code> . </li></ul><br>  So sieht die Implementierung dieses Algorithmus aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> evenNumbers = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numbers.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numbers[i] % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) {   evenNumbers.push(numbers[i]); } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(evenNumbers); <span class="hljs-comment"><span class="hljs-comment">// (6) [0, 2, 4, 6, 8, 10]</span></span></code> </pre> <br>  Au√üerdem k√∂nnen wir eine Funktion schreiben (nennen wir sie <code>even()</code> ), die, wenn die Zahl gerade ist, <code>true</code> zur√ºckgibt und wenn sie ungerade ist, <code>false</code> zur√ºckgibt und sie dann an die Array-Methode <code>filter()</code> √ºbergibt, die jedes Element des Arrays √ºberpr√ºft , bildet ein neues Array, das nur gerade Zahlen enth√§lt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">even</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listOfNumbers = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; listOfNumbers.filter(even); <span class="hljs-comment"><span class="hljs-comment">// [0, 2, 4, 6, 8, 10]</span></span></code> </pre> <br>  Hier ist √ºbrigens die L√∂sung f√ºr ein interessantes Problem in Bezug auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array-Filterung</a> , das ich bei der Arbeit an funktionalen Programmieraufgaben f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hacker Rank abgeschlossen habe</a> .  Aufgrund der Problembedingung war es erforderlich, ein Array von Ganzzahlen herauszufiltern und nur die Elemente anzuzeigen, die kleiner als ein bestimmter Wert von <code>x</code> . <br><br>  Eine zwingende L√∂sung f√ºr dieses Problem in JavaScript k√∂nnte folgenderma√üen aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filterArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, coll</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultArray = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; coll.length; i++) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coll[i] &lt; x) {     resultArray.push(coll[i]);   } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resultArray; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(filterArray(<span class="hljs-number"><span class="hljs-number">3</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>])); <span class="hljs-comment"><span class="hljs-comment">// (3) [2, 1, 0]</span></span></code> </pre> <br>  Das Wesentliche des imperativen Ansatzes ist, dass wir die Abfolge der von der Funktion ausgef√ºhrten Aktionen skizzieren.  Wir beschreiben n√§mlich die Suche des Arrays, vergleichen das aktuelle Element des Arrays mit <code>x</code> und platzieren dieses Element im <code>resultArray</code> Array, wenn es den Test besteht. <br><br><h4>  Deklarativer Ansatz </h4><br>  Wie kann man zu einem deklarativen Ansatz zur L√∂sung dieses Problems und der entsprechenden Verwendung der <code>filter()</code> -Methode wechseln, bei der es sich um eine Funktion h√∂herer Ordnung handelt?  Zum Beispiel k√∂nnte es so aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">smaller</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, listOfNumbers</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listOfNumbers.filter(smaller, x); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]; filterArray(<span class="hljs-number"><span class="hljs-number">3</span></span>, numbers); <span class="hljs-comment"><span class="hljs-comment">// [2, 1, 0]</span></span></code> </pre> <br>  In diesem Beispiel ist es m√∂glicherweise ungew√∂hnlich, das <code>this</code> in der Funktion <code>smaller()</code> verwenden, aber hier ist nichts kompliziert.  Das <code>this</code> ist das zweite Argument f√ºr die Methode <code>filter()</code> .  In unserem Beispiel ist dies die Nummer <code>3</code> die durch den <code>x</code> Parameter von <code>filterArray()</code> .  Diese Nummer wird dadurch angezeigt. <br><br>  Der gleiche Ansatz kann verwendet werden, wenn das Array Entit√§ten enth√§lt, die eine ziemlich komplexe Struktur haben, z. B. Objekte.  Angenommen, wir haben ein Array, in dem Objekte gespeichert sind, die die Namen der durch die Eigenschaft <code>name</code> dargestellten Personen und Informationen √ºber das Alter dieser durch die Eigenschaft age dargestellten Personen enthalten.  So sieht ein Array aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> people = [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"TK"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">26</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Kaio"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Kazumi"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> } ];</code> </pre> <br>  Wir m√∂chten dieses Array filtern, indem wir nur diejenigen Objekte ausw√§hlen, bei denen es sich um Personen handelt, deren Alter <code>21</code> Jahre √ºberschritten hat.  So l√∂sen Sie dieses Problem: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">olderThan21</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person.age &gt; <span class="hljs-number"><span class="hljs-number">21</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">overAge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">people</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> people.filter(olderThan21); } overAge(people); <span class="hljs-comment"><span class="hljs-comment">// [{ name: 'TK', age: 26 }, { name: 'Kazumi', age: 30 }]</span></span></code> </pre> <br>  Hier haben wir ein Array mit Objekten, die Menschen darstellen.  Wir √ºberpr√ºfen die Elemente dieses Arrays mit der Funktion <code>olderThan21()</code> .  In diesem Fall beziehen wir uns bei der √úberpr√ºfung auf die Eigenschaft <code>age</code> jedes Elements und pr√ºfen, ob der Wert dieser Eigenschaft <code>21</code> √ºberschreitet.  Wir √ºbergeben diese Funktion an die <code>filter()</code> -Methode, die das Array filtert. <br><br><h3>  <font color="#3AC1EF">‚ñç Verarbeitung von Array-Elementen und der map () -Methode</font> </h3><br>  Die <code>map()</code> -Methode wird zum Konvertieren von Array-Elementen verwendet.  Er wendet die an jedes Element des Arrays √ºbergebene Funktion an und erstellt dann ein neues Array, das aus den ge√§nderten Elementen besteht. <br><br>  Lassen Sie uns die Experimente mit dem bereits bekannten Personenfeld fortsetzen.  Jetzt werden wir dieses Array nicht basierend auf der Eigenschaft von Altersobjekten filtern.  Wir m√ºssen auf dieser Grundlage eine Liste von Zeilen der Form <code>TK is 26 years old</code> erstellen, die <code>TK is 26 years old</code> .  Bei diesem Ansatz werden die Zeilen, in die sich die Elemente verwandeln, gem√§√ü der Vorlage <code>p.name is p.age years old</code> <code>p.name</code> , wobei <code>p.name</code> und <code>p.age</code> die Werte der entsprechenden Eigenschaften der Elemente des <code>people</code> . <br><br>  Ein zwingender Ansatz zur L√∂sung dieses Problems in JavaScript sieht folgenderma√üen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> people = [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"TK"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">26</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Kaio"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Kazumi"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> } ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peopleSentences = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; people.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sentence = people[i].name + <span class="hljs-string"><span class="hljs-string">" is "</span></span> + people[i].age + <span class="hljs-string"><span class="hljs-string">" years old"</span></span>; peopleSentences.push(sentence); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(peopleSentences); <span class="hljs-comment"><span class="hljs-comment">// ['TK is 26 years old', 'Kaio is 10 years old', 'Kazumi is 30 years old']</span></span></code> </pre> <br>  Wenn Sie auf einen deklarativen Ansatz zur√ºckgreifen, erhalten Sie Folgendes: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSentence</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${person.name}</span></span></span><span class="hljs-string"> is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${person.age}</span></span></span><span class="hljs-string"> years old`</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peopleSentences</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">people</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> people.map(makeSentence); } peopleSentences(people); <span class="hljs-comment"><span class="hljs-comment">// ['TK is 26 years old', 'Kaio is 10 years old', 'Kazumi is 30 years old']</span></span></code> </pre> <br>  Tats√§chlich besteht die Hauptidee hier darin, dass Sie mit jedem Element des urspr√ºnglichen Arrays etwas tun und es dann in einem neuen Array platzieren m√ºssen. <br><br>  Hier ist eine weitere Aufgabe mit dem Hacker-Rang, die der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktualisierung der Liste gewidmet ist</a> .  Wir sprechen n√§mlich davon, die Werte der Elemente eines vorhandenen numerischen Arrays in ihre absoluten Werte zu √§ndern.  Wenn Sie beispielsweise ein Array <code>[1, 2, 3, -4, 5]</code> es die Form <code>[1, 2, 3, 4, 5]</code> da der Absolutwert von <code>-4</code> <code>4</code> . <br><br>  Hier ist ein Beispiel f√ºr eine einfache L√∂sung dieses Problems, wenn wir ein Array durchlaufen und die Werte seiner Elemente in ihre absoluten Werte √§ndern. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> values = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; values.length; i++) { values[i] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(values[i]); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(values); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5]</span></span></code> </pre> <br>  <code>Math.abs()</code> die Werte der Elemente des Arrays zu konvertieren, wird die <code>Math.abs()</code> -Methode verwendet. Die ge√§nderten Elemente werden an die Stelle geschrieben, an der sie sich vor der Konvertierung befanden. <br><br>         . <br><br> ,        ,   ,       .             .   ,   ,    ,      . <br><br>  ,       ,    <code>map()</code> .     ? <br><br>   ,      <code>abs()</code> ,   ,     . <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1 Math.abs(1); // 1 Math.abs(-2); // 2 Math.abs(2); // 2</span></span></code> </pre> <br>  ,    ,       . <br><br>  ,          ,    <code>Math.abs()</code>      <code>map()</code> .   ,           ?  <code>map()</code>    .        : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> values = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateListMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values.map(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs); } updateListMap(values); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5]</span></span></code> </pre> <br> ,     ,  ,     ,    ,   . <br><br><h3> <font color="#3AC1EF">‚ñç    reduce()</font> </h3><br>    <code>reduce()</code>               . <br><br>            . ,     -.      <code>Product 1</code> , <code>Product 2</code> , <code>Product 3</code>  <code>Product 4</code> .         . <br><br>        ,           .  Zum Beispiel k√∂nnte es so aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orders = [ { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Product 1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Product 2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Product 3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Product 4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span> } ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAmount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; orders.length; i++) { totalAmount += orders[i].amount; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(totalAmount); <span class="hljs-comment"><span class="hljs-comment">// 120</span></span></code> </pre> <br>         <code>reduce()</code> ,      ( <code>sumAmount()</code> ),      ,      <code>reduce()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shoppingCart = [ { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Product 1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Product 2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Product 3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Product 4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span> } ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumAmount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentTotalAmount, order</span></span></span><span class="hljs-function">) =&gt;</span></span> currentTotalAmount + order.amount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTotalAmount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shoppingCart</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shoppingCart.reduce(sumAmount, <span class="hljs-number"><span class="hljs-number">0</span></span>); } getTotalAmount(shoppingCart); <span class="hljs-comment"><span class="hljs-comment">// 120</span></span></code> </pre> <br>    <code>shoppingCart</code> ,    ,  <code>sumAmount()</code> ,     ( <code>order</code> ,       <code>amount</code> ),        ‚Äî <code>currentTotalAmount</code> . <br><br>    <code>reduce()</code> ,    <code>getTotalAmount()</code> ,    <code>sumAmount()</code>    ,   <code>0</code> . <br><br>           <code>map()</code>  <code>reduce()</code> .       ¬´¬ª?    ,      <code>map()</code>    <code>shoppingCart</code>  ,     <code>amount</code>     ,     <code>reduce()</code>   <code>sumAmount()</code> .    : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getAmount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">order</span></span></span><span class="hljs-function">) =&gt;</span></span> order.amount; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumAmount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, amount</span></span></span><span class="hljs-function">) =&gt;</span></span> acc + amount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTotalAmount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shoppingCart</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shoppingCart   .map(getAmount)   .reduce(sumAmount, <span class="hljs-number"><span class="hljs-number">0</span></span>); } getTotalAmount(shoppingCart); <span class="hljs-comment"><span class="hljs-comment">// 120</span></span></code> </pre> <br>  <code>getAmount()</code>        <code>amount</code> .       <code>map()</code> ,    ,   ,    <code>[10, 30, 20, 60]</code> . ,   <code>reduce()</code> ,      . <br><br><h3> <font color="#3AC1EF">‚ñç   filter(), map()  reduce()</font> </h3><br>     ,     ,    <code>filter()</code> , <code>map()</code>  <code>reduce()</code> . ,   ,      . <br><br>    -. ,     : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shoppingCart = [ { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Functional Programming"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"books"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Kindle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"eletronics"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Shoes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"fashion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Clean Code"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"books"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span> } ]</code> </pre> <br>       .         : <br><br><ul><li>      <code>type</code>  ,  ,       <code>books</code> . </li><li>     ,    . </li><li>        . </li></ul><br>    ,   : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shoppingCart = [ { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Functional Programming"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"books"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Kindle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"eletronics"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Shoes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"fashion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">productTitle</span></span>: <span class="hljs-string"><span class="hljs-string">"Clean Code"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"books"</span></span>, <span class="hljs-attr"><span class="hljs-attr">amount</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span> } ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byBooks = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">order</span></span></span><span class="hljs-function">) =&gt;</span></span> order.type == <span class="hljs-string"><span class="hljs-string">"books"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getAmount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">order</span></span></span><span class="hljs-function">) =&gt;</span></span> order.amount; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumAmount = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, amount</span></span></span><span class="hljs-function">) =&gt;</span></span> acc + amount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTotalAmount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shoppingCart</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shoppingCart   .filter(byBooks)   .map(getAmount)   .reduce(sumAmount, <span class="hljs-number"><span class="hljs-number">0</span></span>); } getTotalAmount(shoppingCart); <span class="hljs-comment"><span class="hljs-comment">// 70</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>             JavaScript-. ,    . <br><br>  <b>Liebe Leser!</b>         ? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/n0/ry/op/n0ryop7wfykgkeicz3mtuwghrcu.jpeg"></a> </div><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434112/">https://habr.com/ru/post/de434112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434100/index.html">3D-Drucker√ºbersicht f√ºr Anet A6 und Anet A8</a></li>
<li><a href="../de434102/index.html">Sch√∂ne und informative Animation: F√§lle von Kreisbewegungen und Vibrationen</a></li>
<li><a href="../de434104/index.html">UKW-Boden oder Entmystifizierung von Doppel- / Dreifachquadratantennen</a></li>
<li><a href="../de434106/index.html">Vertrauen Sie auf mobile SDKs</a></li>
<li><a href="../de434110/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 344 (17. - 23. Dezember 2018)</a></li>
<li><a href="../de434114/index.html">19 Ideen f√ºr Node.js Entwickler, die 2019 √ºber sich selbst hinauswachsen wollen</a></li>
<li><a href="../de434116/index.html">Die Geschichte der unglaublichen Leichtigkeit, moderne Softwareentwicklungsinfrastruktur zu hacken</a></li>
<li><a href="../de434118/index.html">React Tutorial Teil 4: √úbergeordnete und untergeordnete Komponenten</a></li>
<li><a href="../de434120/index.html">React Tutorial, Teil 5: Erste Schritte mit einer TODO-Anwendung, Grundlagen des Stylings</a></li>
<li><a href="../de434122/index.html">Drehbuch - Kein Seitenobjekt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>