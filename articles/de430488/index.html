<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏼 👨🏽‍💼 ♈️ Asynchroner Datenaustausch mit einer Remote-Anwendung über SSH 👨🏻 🥦 🌘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Freunde und Kollegen. Mein Name ist immer noch Dmitry Smirnov und ich bin zu meiner großen Freude immer noch der Entwickler von ISPsystem. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchroner Datenaustausch mit einer Remote-Anwendung über SSH</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/430488/">  Guten Tag, Freunde und Kollegen.  Mein Name ist immer noch Dmitry Smirnov und ich bin zu meiner großen Freude immer noch der Entwickler von ISPsystem.  Vor einiger Zeit habe ich angefangen, an einem völlig neuen Projekt zu arbeiten, was mich sehr inspiriert hat, da das neue in unserem Fall der Mangel an Legacy-Code und die Unterstützung für alte Compiler ist.  Hallo, Boost, C ++ 17 und all die anderen Freuden der modernen Entwicklung. <br><br>  So kam es, dass alle meine früheren Projekte Multithread-Projekte waren und ich nur sehr wenig Erfahrung mit asynchronen Lösungen hatte.  Dies wurde für mich in dieser Entwicklung neben modernen leistungsstarken Werkzeugen am angenehmsten. <br><br>  Eine der letzten verwandten Aufgaben war die Notwendigkeit, einen Wrapper über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libssh2-</a> Bibliothek in der Realität einer asynchronen Anwendung mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.Asio zu schreiben</a> , der nicht mehr als zwei Threads <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erzeugen</a> kann.  Ich werde dir davon erzählen. <br><br><img src="https://habrastorage.org/webt/j2/fm/-k/j2fm-k44ityxe7_xjzcrwxwy7hw.jpeg"><br><br>  Hinweis: Der Autor geht davon aus, dass der Leser mit den Grundlagen der asynchronen Entwicklung und boost :: asio vertraut ist. <br><a name="habracut"></a><br><h2>  Herausforderung </h2><br>  Im Allgemeinen lautete die Aufgabe wie folgt: Stellen Sie mit einem RSA-Schlüssel oder einem Benutzernamen und einem Kennwort eine Verbindung zu einem Remote-Server her.  Laden Sie ein Skript auf den Remotecomputer hoch und führen Sie es aus.  Lesen Sie seine Antworten und senden Sie ihm Befehle über dieselbe Verbindung.  In diesem Fall natürlich ohne Blockierung des Flusses (was die Hälfte des gesamten möglichen Pools ist). <br><br>  <b>Haftungsausschluss</b> : Ich weiß, dass Poco mit SSH zusammenarbeitet, aber ich habe keinen Weg gefunden, ihn mit Asio zu heiraten, und es war interessanter, etwas Eigenes zu schreiben :-). <br><br><h2>  Initialisierung </h2><br>  Um die Bibliothek zu initialisieren und zu minimieren, habe ich mich für den üblichen Singleton entschieden: <br><br><div class="spoiler">  <b class="spoiler_title">Init ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LibSSH2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LibSSH2 instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LibSSH2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (libssh2_init(<span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"libssh2 initialization failed"</span></span>); } } ~LibSSH2() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"shutdown libssh2"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; libssh2_exit(); } };</code> </pre> <br><br></div></div><br>  Laut meinem Lieblingshandbuch „Tausendundeiner Weg, um in C ++ auf das Bein zu schießen“ gibt es bei dieser Entscheidung natürlich Fallstricke.  Wenn jemand einen Stream generiert, den er vergessen hat zu stecken, und der Hauptstrom früher endet, können durchaus interessante Spezialeffekte auftreten.  In diesem Fall werde ich diese Möglichkeit jedoch nicht berücksichtigen. <br><br><h2>  Schlüsselentitäten </h2><br>  Nach der Analyse des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiels</a> wird klar, dass wir für unsere kleine Bibliothek drei einfache Entitäten benötigen: Socket, Sitzung und Kanal.  Da es schön ist, synchrone Werkzeuge zu haben, werden wir Asio vorerst beiseite lassen. <br><br>  Beginnen wir mit einem einfachen Socket: <br><br><div class="spoiler">  <b class="spoiler_title">Steckdose</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Socket</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Socket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket(AF_INET, SOCK_STREAM, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_sock == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"failed to create socket"</span></span>); } } ~Socket() { close(m_sock); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_sock = <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br></div></div><br>  Jetzt Sitzung: <br><br><div class="spoiler">  <b class="spoiler_title">Die Sitzung</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Session</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> enable_compression)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(libssh2_session_init())</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_session == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"failed to create libssh2 session"</span></span>); } libssh2_session_set_blocking(m_session, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enable_compression) { libssh2_session_flag(m_session, LIBSSH2_FLAG_COMPRESS, <span class="hljs-number"><span class="hljs-number">1</span></span>); } } ~Session() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> desc = <span class="hljs-string"><span class="hljs-string">"Shutting down libssh2 session"</span></span>; libssh2_session_disconnect(m_session, desc.c_str()); libssh2_session_free(m_session); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: LIBSSH2_SESSION *m_session; }</code> </pre><br></div></div><br>  Da wir jetzt einen Socket und eine Sitzung haben, wäre es schön, eine Wartefunktion für einen Socket in der Realität von libssh2 zu schreiben: <br><br><div class="spoiler">  <b class="spoiler_title">Wartebuchse</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pollfd fds{}; fds.fd = sock; fds.events = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((libssh2_session_block_directions(session) &amp; LIBSSH2_SESSION_BLOCK_INBOUND) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { fds.events |= POLLIN; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((libssh2_session_block_directions(session) &amp; LIBSSH2_SESSION_BLOCK_OUTBOUND) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { fds.events |= POLLOUT; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> poll(&amp;fds, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br></div></div><br>  Tatsächlich unterscheidet sich dies praktisch nicht vom obigen Beispiel, außer dass es select anstelle von poll verwendet. <br><br>  Der Kanal bleibt.  In libssh2 gibt es verschiedene Arten von Kanälen: simple, SCP, direct tcp.  Wir interessieren uns für den einfachsten, einfachsten Kanal: <br><br><div class="spoiler">  <b class="spoiler_title">Kanal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimpleChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(session)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((m_channel = libssh2_channel_open_session(session) == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; GetSessionLastError() == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_channel == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Critical error while opening simple channel"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SendEof() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (libssh2_channel_send_eof(m_channel) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (libssh2_channel_wait_eof(m_channel) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } } ~SimpleChannel() { CloseChannel(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CloseChannel() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc = libssh2_channel_close(m_channel)) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } libssh2_channel_free(m_channel); } LIBSSH2_CHANNEL *m_channel; };</code> </pre> <br></div></div><br>  Nachdem alle grundlegenden Tools bereit sind, müssen Sie noch eine Verbindung zum Host herstellen und die erforderlichen Manipulationen durchführen.  Die asynchrone Aufzeichnung auf dem Kanal und die synchrone Aufnahme sind natürlich sehr unterschiedlich, der Prozess des Verbindungsaufbaus jedoch nicht. <br><br>  Deshalb schreiben wir die Basisklasse: <br><br><div class="spoiler">  <b class="spoiler_title">Grundverbindung</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SshConnectData &amp;connect_data)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">///&lt;    ,     : m_session(connect_data.enable_compression) , m_connect_data(connect_data) { LibSSH2::Init(); ConnectSocket(); HandShake(); ProcessKnownHosts(); Auth(); } ///       bool CheckSocket(int type) const { pollfd fds{}; fds.fd = m_sock; fds.events = type; return poll(&amp;fds, 1, 0) == 1; } bool WantRead() const { return CheckSocket(POLLIN); } bool WantWrite() const { return CheckSocket(POLLOUT); } /*   ,   ,       *  - . */ void ConnectSocket() {...} void HandShake() {...} void Auth() {...} class Socket m_sock; class Session m_session; class SimpleChannel; SshConnectData m_connect_data; };</span></span></span></span></code> </pre> <br></div></div><br>  Jetzt können wir die einfachste Klasse schreiben, um eine Verbindung zum Remote-Host herzustellen und einen beliebigen Befehl darauf auszuführen: <br><br><div class="spoiler">  <b class="spoiler_title">Synchrone Verbindung</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class">:</span></span>:Impl : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseConnectionImpl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SshConnectData &amp;connect_data)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(connect_data)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Begin&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteToChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LIBSSH2_CHANNEL *channel, Begin ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc = libssh2_channel_write(channel, ptr, size)) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size -= rc; ptr += rc; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size != <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;command, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;in = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">SimpleChannel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> return_code = libssh2_channel_exec(channel, command.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_code != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; return_code != LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Critical error while executing ssh command"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!in.empty()) { WriteToChannel(channel, in.c_str(), in.size()); channel.SendEof(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, 4096&gt; buffer{}; rc = libssh2_channel_read(channel, buffer.data(), buffer.size()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { boost::range::copy(boost::adaptors::slice(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, rc), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(response)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; rc != LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"libssh2_channel_read error ("</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(rc) + <span class="hljs-string"><span class="hljs-string">")"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } };</code> </pre> <br></div></div><br>  Bisher war alles, was wir geschrieben haben, eine einfache Reduktion von libssh2-Beispielen auf eine zivilisiertere Form.  Mit all den einfachen Tools zum synchronen Schreiben von Daten in den Kanal können wir nun zu Asio übergehen. <br><br>  Ein Standard-Socket ist gut, aber nicht zu praktisch, wenn Sie asynchron warten müssen, bis er gelesen / geschrieben wird, während Sie Ihr eigenes Geschäft betreiben.  Hier kommt boost :: asio :: ip :: tcp :: socket zur Rettung und hat eine wunderbare Methode: <br><br><pre> <code class="cpp hljs">async_wait(wait_type, WaitHandler)</code> </pre> <br>  Es ist wunderbar aus einem regulären Socket aufgebaut, für den wir die Verbindung bereits im Voraus eingerichtet haben und boost :: asio :: io_context - den Ausführungskontext unserer Anwendung. <br><br><div class="spoiler">  <b class="spoiler_title">Asynchroner Verbindungskonstruktor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncConnection</span></span></span><span class="hljs-class">:</span></span>:Impl : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseConnectionImpl, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt;AsyncConnection::Impl&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Impl(boost::asio::io_context &amp;context, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SshConnectData &amp;connect_data) : BaseConnectionImpl(connect_data) , m_tcp_socket(context, tcp::v4(), m_sock.GetSocket()) { m_tcp_socket.non_blocking(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } };</code> </pre> <br></div></div><br><br>  Jetzt müssen wir die Ausführung eines Befehls auf dem Remote-Host starten und ihn, sobald Daten von ihm eintreffen, an einen Rückruf senden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncRun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;command, CallbackType &amp;&amp;callback)</span></span></span><span class="hljs-function"> </span></span>{ m_read_callback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(callback); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = libssh2_channel_exec(*m_channel, command.c_str()); TryRead(); }</code> </pre> <br>  Durch Ausführen des Befehls übertragen wir die Steuerung an die TryRead () -Methode. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_read_in_progress) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_tcp_socket.async_wait(tcp::socket::wait_read, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, self = shared_from_this()](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WantRead()) { ReadHandler(ec); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_complete) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TryRead(); }); }</code> </pre><br>  Zunächst prüfen wir, ob der Lesevorgang bereits durch einen vorherigen Aufruf ausgeführt wurde.  Wenn nicht, erwarten wir die Lesebereitschaft der Steckdose.  Ein normales Lambda mit der Erfassung von shared_from_this () wird als Wartehandler verwendet. <br><br>  Achten Sie auf den Aufruf von WantRead ().  Wie sich herausstellte, hat Async_wait auch seine Fehler und kann einfach per Timeout zurückkehren.  Um unnötige Aktionen in diesem Fall zu vermeiden, habe ich beschlossen, den Socket durch Abfrage ohne Zeitüberschreitung zu überprüfen - möchte der Socket jetzt wirklich lesen?  Wenn nicht, führen wir TryRead () erneut aus und warten.  Andernfalls beginnen wir sofort mit dem Lesen und Übertragen von Daten zum Rückruf. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != boost::system::errc::success) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_read_in_progress = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ec = LIBSSH2_ERROR_EAGAIN; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, 4096&gt; buffer {}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((ec = libssh2_channel_read(*m_channel, buffer.data(), buffer.size())) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp; boost::range::copy(boost::adaptors::slice(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ec), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(tmp)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_read_callback != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { m_read_callback(tmp); } } m_read_in_progress = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Somit wird ein endloser asynchroner Lesezyklus von der laufenden Anwendung gestartet.  Der nächste Schritt für uns ist das Senden von Anweisungen an die Anwendung: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data, WriteCallbackType &amp;&amp;callback)</span></span></span><span class="hljs-function"> </span></span>{ m_input += data; m_write_callback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(callback); TryWrite(); }</code> </pre><br>  Die an die asynchrone Aufzeichnung übertragenen Daten und Rückrufe werden in der Verbindung gespeichert.  Und führen Sie den nächsten Zyklus aus, nur diesmal die Einträge: <br><br><div class="spoiler">  <b class="spoiler_title">Aufnahmezyklus</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_input.empty() || m_write_in_progress) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_tcp_socket.async_wait(tcp::socket::wait_write, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, self = shared_from_this()](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WantWrite()) { WriteHandler(ec); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_complete) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TryWrite(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != boost::system::errc::success) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_write_in_progress = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ec = LIBSSH2_ERROR_EAGAIN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!m_input.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = m_input.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> read_size = m_input.size(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((ec = libssh2_channel_write(*m_channel, ptr, read_size)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { read_size -= ec; ptr += ec; } AssertResult(ec); m_input.erase(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_input.size() - read_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ec == LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_input.empty() &amp;&amp; m_write_callback != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { m_write_callback(); } m_write_in_progress = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br></div></div><br>  Daher schreiben wir Daten in den Kanal, bis sie alle erfolgreich übertragen wurden.  Dann geben wir die Kontrolle an den Anrufer zurück, damit ein neues Datenelement übertragen werden kann.  Auf diese Weise können Sie nicht nur Anweisungen an eine Anwendung auf dem Host senden, sondern beispielsweise auch Dateien beliebiger Größe in kleinen Portionen hochladen, ohne den Thread zu blockieren, was wichtig ist. <br><br>  Mit dieser Bibliothek konnte ich erfolgreich ein Skript auf einem Remote-Server ausführen, das Dateisystemänderungen verfolgt, gleichzeitig die Ausgabe liest und verschiedene Befehle sendet.  Im Allgemeinen: Eine sehr wertvolle Erfahrung bei der Anpassung der si-style-Bibliothek für ein modernes C ++ - Projekt mit Boost. <br><br>  Ich werde gerne die Tipps erfahrener Boost.Asio-Benutzer lesen, um mehr zu erfahren und meine Lösung zu verbessern :-). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430488/">https://habr.com/ru/post/de430488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430478/index.html">Trading Bots für den Kryptowährungsmarkt. Wo soll ich anfangen?</a></li>
<li><a href="../de430480/index.html">Wie wir die Anwendung beim NASA Space Apps Challenge Hackathon geschrieben haben</a></li>
<li><a href="../de430482/index.html">Das Thema der Panzerplatten in der Kultur von Ost und West</a></li>
<li><a href="../de430484/index.html">Typische NGFW-Implementierungsszenarien</a></li>
<li><a href="../de430486/index.html">Wie Freiberufler leben: vom Entwickler zum technischen Texter</a></li>
<li><a href="../de430490/index.html">Vorwegnehmen, aufklären, entscheiden: Wie und warum EPAM das Java Competency Center aufbaut</a></li>
<li><a href="../de430492/index.html">Intel Neural Compute Stick. Künstlicher Geist auf einem USB-Stick - 2</a></li>
<li><a href="../de430494/index.html">InfoWatch Traffic Monitor. Am Rande von Fehlern und Funktionen</a></li>
<li><a href="../de430496/index.html">NB-IoT: Wie funktioniert es? Teil 1</a></li>
<li><a href="../de430498/index.html">Umgehen Sie die Benutzerkontensteuerung (User Account Control, UAC), indem Sie vertrauenswürdige Verzeichnisse nachahmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>