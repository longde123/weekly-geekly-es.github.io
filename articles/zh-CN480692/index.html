<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧 🚴🏽 💆🏿 MobX或Redux：哪个更适合React状态管理？ 👏🏽 💠 🎍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在JavaScript中，状态管理已成为当今讨论的热点。 在实施状态管理时，开发人员经常发现在Redux中处理样板代码具有挑战性。 因此，事实证明，MobX是Redux的不错选择，Redux以更少的代码提供相同功能。 但是，两个状态管理工具都可以与React一起很好地工作。 

 首先让我们看一下两...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MobX或Redux：哪个更适合React状态管理？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480692/"><img src="https://habrastorage.org/webt/ih/84/tp/ih84tp1bk6iwfgmeg5khccc2qrm.jpeg"><br><br> 在JavaScript中，状态管理已成为当今讨论的热点。 在实施状态管理时，开发人员经常发现在Redux中处理样板代码具有挑战性。 因此，事实证明，MobX是Redux的不错选择，Redux以更少的代码提供相同功能。 但是，两个状态管理工具都可以与React一起很好地工作。 <br><br>  <b>首先让我们看一下两者之间的共同点：</b> <br><br>  1）两者都支持时间旅行调试 <br>  2）两者都包含开源库 <br>  3）两者都提供客户端状态管理 <br>  4）两者都为React本机框架提供了巨大的支持 <br><br> 在此博客中，我们列出了两种状态管理解决方案的所有优点和缺点。 它将帮助<a href="https://www.valuecoders.com/hire-developers/hire-web-app-developers" rel="nofollow">网络开发人员</a>为他们的下一个项目选择最佳的解决方案。 在讨论这一点之前，我们根据以下给出的一些参数比较了Redux和Mobx： <br><a name="habracut"></a><br>  -&gt;维护和可扩展 <br><br> 由于存在纯函数和函数式编程范例，Redux更具可伸缩性和可维护性。 因此，可以使用Redux轻松控制事物。 <br><br>  -&gt;调试过程 <br><br> 与MobX相比，在Redux中进行调试是一种很好的体验，因为它提供了很棒的开发人员工具，并且抽象程度较低。 借助通量范例，Redux变得更加可预测。 另一方面，由于更多的抽象和普通的开发人员工具，MobX中的调试要困难得多。 <br><br>  -&gt;学习曲线 <br><br> 学习MobX很容易，因为它具有稳定的学习曲线。 最大抽象的存在使学习变得容易，并且熟悉OOP概念的JavaScript开发人员在MobX上拥有据点。 另一方面，Redux使用功能性编程范例，这使得很难一目了然。 <br><br>  -&gt;社区 <br><br> 与MobX相比，Redux具有庞大的社区基础。 因此，Redux可以随时随地为开发人员提供强大的社区支持。 <br><br>  -&gt;不纯与纯 <br><br>  MobX不纯，因为状态可以被覆盖。 在这里，您可以轻松地使用新值更新状态。 但是，Redux是纯函数，因为它使用纯函数。 在这里，状态是只读的，不能直接覆盖。 之前的状态被替换为新的状态。 <br><br>  -&gt;可观察与纯数据 <br><br>  MobX使用可观察的存储，而Redux使用普通的Javascript数据存储值。 在Redux中，所有更新都是手动跟踪的。 <br><br>  -&gt;商店 <br><br> 商店是放置数据的地方。  MobX具有多个存储，这些存储在逻辑上是分开的。 另一方面，Redux有一个存储所有状态的大型存储。 通常在Redux中将数据标准化，而在MobX中将数据保持非标准化状态。 <br><br>  <b>Redux vs MobX：代码比较</b> <br><br>  <b><u>道具注射</u></b> <br><br>  React-redux的connect（）函数用于将状态和操作传递给Redux中的prop。 如下图所示： <br><br>  //访问道具 <br><br><pre><code class="markdown hljs"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContactForm</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">contact</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.contact}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">loading</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.loading}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onSubmit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.submit}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span></code> </pre> <br><br>  //将状态注入道具的函数 <br><br><pre> <code class="markdown hljs">function mapStateToProps(state) { return { contact: state.contactStore.contact, errors: state.contactStore.errors } }</code> </pre> <br><br>  //将状态和动作都注入道具 <br><br><pre> <code class="markdown hljs">export default connect(mapStateToProps, { newContact, saveContact, fetchContact, updateContact })(ContactFormPage);</code> </pre> <br><br> 在MobX中， <a href="https://habr.com/en/users/inject/" class="user_link">注入</a>用于注入商店的集合。 这将使商店在道具中可用。 在这里，状态和动作是通过store对象中的属性访问的，因此无需单独传递它们。 <br><br><pre> <code class="markdown hljs">@inject("stores") @observer // injecting store into props class ContactFormPage extends Component { … // accessing store via props const { contactStore:store } = this.props.stores; return ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContactForm</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">form</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.form}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">contact</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store.entity}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> ) … }</code> </pre> <br><br> 因此，我们使用redux-connect-decorators简化了Redux代码，并且MobX版本始终易于阅读。 因此，没有这样明确的赢家。 <br><br>  <b><u>自举</u></b> <br><br> 在Redux中，首先定义存储区，然后通过Provider传递App。 要处理异步功能，您还需要定义redux-thunk和redux-promise-middleware。 此后，redux-devtools-extension允许调试以时间旅行模式存储。 <br><br><pre> <code class="markdown hljs">import { applyMiddleware, createStore } from "redux"; import thunk from "redux-thunk"; import promise from "redux-promise-middleware"; import { composeWithDevTools } from 'redux-devtools-extension'; import rootReducer from "./reducers"; const middleware = composeWithDevTools(applyMiddleware(promise(), thunk)); export default createStore(rootReducer, middleware);</code> </pre> <br><br>  // src / index.js <br><br><pre> <code class="markdown hljs">ReactDOM.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, document.getElementById('root') );</code> </pre> <br><br> 在MobX中，设置了多个商店。 它不需要外部库来处理异步操作，而只需几行代码。 您需要mobx-remotedev来连接redux-devtools-extension调试工具。 <br><br><br><br><pre> <code class="markdown hljs">import remotedev from 'mobx-remotedev'; import Store from './store'; const contactConfig = { name:'Contact Store', global: true, onlyActions:true, filters: { whitelist: /fetch|update|create|Event|entity|entities|handleErrors/ } }; const contactStore = new Store('api/contacts'); const allStores = { contactStore: remotedev(contactStore, contactConfig) }; export default allStores;</code> </pre> <br><br>  // src / index.js <br><br><pre> <code class="markdown hljs">ReactDOM.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">stores</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{allStores}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, document.getElementById('root') );</code> </pre> <br><br> 但是，两者中使用的代码量相同。 但是，MobX包含的导入语句更少。 <br><br>  <b><u>定义动作和减速器</u></b> <br><br> 通过以下代码在Redux中定义了动作和缩减器： <br><br>  //动作 <br><br><pre> <code class="markdown hljs">export function fetchContacts(){ return dispatch =&gt; { dispatch({ type: 'FETCH_CONTACTS', payload: client.get(url) }) } }</code> </pre> <br><br>  //减速器 <br><br><pre> <code class="markdown hljs">switch (action.type) { case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>FULFILLED': { return { ...state, contacts: action.payload.data.data || action.payload.data, loading: false, errors: {} } } case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>PENDING': { return { ...state, loading: true, errors: {} } } case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>REJECTED': { return { ...state, loading: false, errors: { global: action.payload.message } } } }</code> </pre> <br><br> 动作和减速器的逻辑是在MobX中的一类中完成的。 由于使用OOP，Store类被重构以使用类构造函数创建多个商店。 相应的代码如下所示： <br><br><pre> <code class="markdown hljs">@action fetchAll = async() =&gt; { this.loading = true; this.errors = {}; try { const response = await this.service.find({}) runInAction('entities fetched', () =&gt; { this.entities = response.data; this.loading = false; }); } catch(err) { this.handleErrors(err); } }</code> </pre> <br><br> 因此，我们已经看到，两种状态管理解决方案中定义的逻辑都可以完成相同的工作。 唯一的不同是，我们在Redux中使用了33行代码，在MobX中使用了14行代码来获得结果。 因此，您可以使用MobX更快地构建应用程序。 <br><br>  <b>为什么要将MobX用于React应用程序？</b> <br><br>  MobX是经过测试的库，可通过透明地应用功能反应式编程（TFRP）使状态管理变得简单且可扩展。  React和MobX是强大的组合。 <br><br><ul><li> 减少编写代码 </li><li> 易学 </li><li> 嵌套数据很容易 </li><li> 支持面向对象的编程 </li></ul><br><br>  <b>为什么不使用MobX？</b> <br><br><ul><li> 难以调试 </li><li> 更好的替代品 </li><li> 给予过多的自由 </li></ul><br><br>  <b>为什么要将Redux用于React应用程序？</b> <br><br>  Redux是一个独立的库，可以与UI框架一起使用，包括Angular，Vue，Ember，React和vanilla JS。 <br><br><ul><li> 通过中间件的可扩展性 </li><li> 人气与社区 </li><li> 工具支持 </li><li> 可预测性和简单性 </li><li> 单向数据流和不变性 </li><li> 数据和表示分离 </li></ul><br><br>  <b>为什么不使用Redux？</b> <br><br><ul><li> 样板（还原器，选择器，视图，操作类型，操作创建者，...） </li><li> 动作已脱离其效果（在reduce中定义） </li><li> 没有现成的解决副作用的解决方案（可通过redux-thunk或redux-saga等中间件获得） </li></ul><br><br>  <b>最后说明：</b> <br><br> 现在，您可以看到MobX代码库更加敏捷。 使用OOP风格和良好的开发实践，您可以快速创建React应用程序。 主要缺点是编写不良代码非常容易，并且无法维护。 <br><br> 另一方面，Redux很受欢迎，适合于构建大型和复杂的项目。 这是一个带有防护措施的严格框架，可确保每个开发人员编写易于测试和维护的代码。 但是，它不适合小型项目。 <br><br> 我希望我提供了足够的信息来阐明是迁移到MobX还是继续使用Redux。 最终，决定取决于您正在从事的项目类型和可用资源。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN480692/">https://habr.com/ru/post/zh-CN480692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN480682/index.html">英特尔实感LiDAR L515-另一个新的实感</a></li>
<li><a href="../zh-CN480684/index.html">DIY StarWars雪花（更新于2019）</a></li>
<li><a href="../zh-CN480686/index.html">为什么我拒绝移动开发中的跨平台解决方案</a></li>
<li><a href="../zh-CN480688/index.html">Mojibakes来自哪里？ 编码要点</a></li>
<li><a href="../zh-CN480690/index.html">我们便宜地管理英寸百叶窗</a></li>
<li><a href="../zh-CN480694/index.html">我们可以停止调用UX的可访问性和可用性吗？</a></li>
<li><a href="../zh-CN480700/index.html">我们在Chrome中使用console.log（）</a></li>
<li><a href="../zh-CN480702/index.html">人力资源和人才，专家和创造力：第八届哈勃拉撒米纳尔会议过得如何</a></li>
<li><a href="../zh-CN480704/index.html">在网站上进行响应式内容加载</a></li>
<li><a href="../zh-CN480708/index.html">几十年即将结束。 在过去10年中，Google Play上哪些应用下载最多？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>