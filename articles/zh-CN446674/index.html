<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔜 🍷 🙀 我们为确定电磁波到达方向的MUSIC算法建模 🕳️ ☠️ ☀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前言 


 我将从远处开始介绍。 曾几何时，在遥远的2016-2017年，您谦虚的仆人设法在遥远的伊尔默瑙 （德国）进行了为期六个月的培训课程，在那里他成功地（总体上）成功完成了硕士课程通信和信号处理 。 该程序不是一个容易的程序，但是现在，使它恢复起来甚至很愉快。 有时候... 


 因此，在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们为确定电磁波到达方向的MUSIC算法建模</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446674/"><p><img src="https://media.moddb.com/cache/images/groups/1/3/2392/thumb_620x2000/music-cats.jpg" alt="野猫"></p><br><h2 id="predislovie"> 前言 </h2><br><p> 我将从远处开始介绍。 曾几何时，在遥远的2016-2017年，您谦虚的仆人设法在遥远的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">伊尔默瑙</a> （德国）进行了为期六个月的培训课程，在那里他成功地（总体上）成功完成了硕士课程<strong>通信和信号处理</strong> 。 该程序不是一个容易的程序，但是现在，使它恢复起来甚至很愉快。 有时候... </p><a name="habracut"></a><br><p> 因此，在培训结束时，除了文凭，我手上还有很多材料，我认为不共享是错误的。 </p><br><p> 这些材料之一就在您眼前。 </p><br><p>  <strong>准备研讨会时我追求什么目标</strong> ： </p><br><ol><li> 在天线阵列主题中谈论一些已经建立的“智能”方法，该方法最容易使用，并且用俄语进行； </li><li> 在<strong><em>Python 3</em></strong>中进行一次小型仿真，以激起无线电工程师们对编程语言的进一步了解（如果您尚未仔细研究的话）； </li><li> 提供指向优秀英语文献的链接-现在，without，无处可去，而无需阅读外国资源。 </li></ol><br><p>  <strong>注意事项</strong> ： </p><br><ul><li>  MUSIC方法（多重信号分类）-实际上是指预览。 </li></ul><br><blockquote> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">此处</a>找到图表形成和MVDR方法的示例（如果对其他材料有疑问或建议，可以在Github.Gist上继续进行讨论）。 </blockquote><p> 如上所述，我们将使用Python，即： </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p> 您为什么不问MATLAB，它是线性代数建模的最流行，最方便的候选人之一？ 因为，我想证明类似的工作可以在Python中完成，并且Python的范围比MATLAB的范围要广得多。 因此，在我看来，熟悉Python语法是一件有用的事情。 </p><br><p> 让我们开始吧！ </p><br><blockquote> 公式是通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://upmath.me/</a>准备的。 感谢创作者提供的出色工具！ </blockquote><br><h2 id="postanovka-zadachi"> 问题陈述 </h2><br><p> 假设有一个线性天线阵列，该阵列由许多彼此隔开的元件组成 <img src="https://tex.s2cms.ru/svg/%5CDelta%20%3D%20%5Cfrac%7B%5Clambda%7D%7B2%7D" alt="\ Delta = \ frac {\ lambda} {2}">  （天线阵列的步骤），其中 <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  -载波电磁（EM）波的长度。 </p><br><p> 电磁波从不同方向落在该天线阵列上。 </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote> 图  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">自适应天线系统。</a> </blockquote><p> 从图中可以看出，天线阵列被认为是自适应滤波器。 </p><br><p> 实际上，找到系数的最佳矢量（ <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bw%7D_%7Bopt%7D" alt="\ mathbf {w} _ {opt}"> 从数学的角度来看，）是自适应天线阵列的主要任务。 </p><br><p> 最初，我们不知道信号来自哪个特定方向以及有多少方向。 为了解决这一矛盾，我们将使用MUSIC算法，该算法用于以高分辨率估计空间频率。 </p><br><h2 id="modelirovanie-prinyatogo-signala"> 接收信号模拟 </h2><br><p> 我们可以通过以下公式表示接收信号的模型： </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D%20%2B%20%5Cmathbf%7BN%7D%20" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><p></p><br><p> 在哪里 <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BA%7D%20%3D%20%5B%5Cmathbf%7Ba%7D(%5Ctheta_1)%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_2)%20%5Cquad%20...%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_d)%5D" alt="\ mathbf {A} = [\ mathbf {a}（\ theta_1）\ quad \ mathbf {a}（\ theta_2）\ quad ... \ quad \ mathbf {a}（\ theta_d）]">  -天线阵列的扫描向量（转向向量）的矩阵（ <img src="https://tex.s2cms.ru/svg/%20a_i%20%3D%20%5Cexp(-j%20%5Cmu%20m_i)" alt="a_i = \ exp（-j \ mu m_i）">  ， <img src="https://tex.s2cms.ru/svg/m%20%3D%200%2C%201%20...%20(M-1)" alt="m = 0，1 ...（M-1）">  ， <img src="https://tex.s2cms.ru/svg/M" alt="中号">  -天线阵列的元件数， <img src="https://tex.s2cms.ru/svg/d" alt="d">  -电磁波源的数量， <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  -倾斜EM波的到达方向）， <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BS%7D" alt="\ mathbf {S}">  -传输字符矩阵，以及 <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BN%7D" alt="\ mathbf {N}">  -附加噪声矩阵。 </p><br><img src="https://raw.githubusercontent.com/kirlf/CSP/master/Different/assets/ULA.png" alt="ULA" width="600"><br><blockquote> 图  2.全向线性天线阵列（ULAA-均匀线性天线阵列）[1，p。  32]。 </blockquote><p> 让我们以“每天”的方式重新考虑这个公式：在网格上，我们从各种信号中得到一些“混乱”，我们用 <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BX%7D" alt="\ mathbf {X}">  。 我们没有明确接收有关源和方向数量的信息，但是，关于此的信息仍然包含在接收到的信号中。 </p><br><p> 我们开始搜索！ </p><br><p> 为此，它们通常不进行复杂信号幅度矩阵本身的操作，而是采用其协方差进行操作（即，本质上是使用幂）： </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5EH%20%3D%20%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BR%7D_%7Bss%7D%20%5Cmathbf%7BA%7D%5EH%20%2B%20%5Cmathbf%7BR%7D_%7Bnn%7D%20" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><p></p><br><h2 id="usloviya"> 条件 </h2><br><p> 我们介绍一个重要的考虑条件：瑞利角分辨率极限： </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/sin%20(%5Ctheta_R)%20%3D%20%5Cfrac%7B%5Clambda%7D%7BD%7D" alt="sin（\ theta_R）= \ frac {\ lambda} {D}"></div><p></p><br><p> 在哪里 <img src="https://tex.s2cms.ru/svg/D%20%3D%20M%20%5CDelta" alt="D = M \三角洲"> 是线性晶格的长度。 </p><br><p> 我们通过空间频率的概念重新定义电磁波的到达角度： </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmu_R%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20sin(%5Ctheta_R)%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20%5Cfrac%7B%5Clambda%7D%7B%5CDelta%20M%7D%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7BM%7D" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta sin（\ theta_R）= \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><p></p><br><p> 在哪里 <img src="https://tex.s2cms.ru/svg/%5Cmu_R" alt="\ mu_R">  -光束的主瓣有一个标准宽度（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">standard beamwidth</a> ）。 </p><br><p> 为了检查我们的方法的有效性以及在什么条件下，我们引入一些给定的角度间隔值： </p><br><ol><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%20%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 =-\ mu_R，\ quad \ mu_2 = 0，\ quad \ mu_3 = \ mu_R \ quad">  -分成一个光束宽度； </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.5%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.5%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0.5 \ mu_R，\ quad \ mu_2 = 0，\ quad \ mu_3 = 0.5 \ mu_R \ quad">  -划分为一秒的光束宽度； </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.3%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.3%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0.3 \ mu_R，\ quad \ mu_2 = 0，\ quad \ mu_3 = 0.3 \ mu_R \ quad">  -分成光束宽度的十分之三。 </p><br></li></ol><br><p> 定义输入参数： </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode"> 关于方法本身的一些理论 </h2><br><p> 首先，我们注意到MUSIC方法的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">前身</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Pisarenko</a>方法（1973年）。  Pisarenko方法的考虑问题是估计白噪声中复指数和的频率。  V.F. Pisarenko证明，可以从与自相关矩阵的最小特征值相对应的特征向量中找到频率。 随后，此方法成为MUSIC方法的特例。  [2，p。  459] </p><br><p>  Schmidt和他的同事在1979年提出了多信号分类算法（MUSIC）[4]。 该算法的主要方法是将接收信号的协方差矩阵分解为特征值。 由于此算法考虑了不相关的噪声，因此生成的协方差矩阵具有对角线形式。 在此，信号和噪声子空间是使用线性代数计算的，并且彼此正交。 因此，该算法使用正交性来提取信号和噪声子空间[5]。 </p><br><p> 广义MUSIC算法可以定义如下： </p><br><ul><li> 找到协方差矩阵 <img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20" alt="\ mathbf {R} _ {xx}"></li><li> 通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">EVD</a>或其他合适的数值算法查找特征向量： </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BU%7D%5Cmathbf%7B%5CLambda%7D%5Cmathbf%7BU%7D%5EH%20%5Cqquad(1)" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad（1）"></div><p></p><br><ul><li> 通过以下公式找到伪谱（为什么带有伪伪前缀，我们将在下面讨论）： </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(e%5E%7Bj%5Comega%7D)%20%3D%20%5Cfrac%7B1%7D%7B%5Csum%20%5Climits_%7Bi%3Dd%2B1%7D%5E%7BM%7D%7C%5Cmathbf%7Ba%7D%5EH%5Cmathbf%7Bu%7D_i%7C%5E2%7D%20%5Cqquad(2)%20" alt="P_ {MU}（e ^ {j \ omega}）= \ frac {1} {\ sum \ limits_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad（2）"></div><p></p><br><p> 在哪里 <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Ba%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20%20e%5E%7Bj0%5Comega%7D%20%26%20e%5E%7Bj1%5Comega%7D%20%26%20e%5E%7Bj2%5Comega%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Comega%7D%20%5Cend%7Bbmatrix%7D%5ET" alt="\ mathbf {a} = \开始{bmatrix} e ^ {j0 \ omega}＆e ^ {j1 \ omega}＆e ^ {j2 \ omega}＆...＆e ^ {j（M-1）\ omega } \ end {bmatrix} ^ T"> 是在给定范围内的频率ω的指数矢量，并且 <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bu%7D_i" alt="\ mathbf {u} _i">  -与矩阵（1）的噪声子空间相对应的协方差矩阵（1）的第i个特征向量（特征向量）-因此采用 <img src="https://tex.s2cms.ru/svg/d%2B1" alt="d + 1">  （ <img src="https://tex.s2cms.ru/svg/d" alt="d"> 是矩阵（1）的等级。 </p><br><blockquote> 为了更清晰，请尝试运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">reference</a>提供的适当的MATLAB脚本。 注意两点： <br><ul><li> 作者无需在分母（2）中计算第二范数的平方，而是将FFT算法应用于特征向量，这有助于使用内置函数进行建模，并且从数学的角度来看，通常不与该理论相矛盾； </li><li> 通过卷积矩阵计算协方差矩阵；上面显示了一种不同的方法来估计空间频率。 </li></ul><br></blockquote><p> 正如您可能从名称中猜到的那样，MUSIC还是一种用于估计高分辨率接收方向的经典方法。 在此情况下，用于计算伪光谱的算法如下： </p><br><ul><li><p> 我们找到接收信号的协方差矩阵； </p><br></li><li><p> 找到零子空间 <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D_0" alt="\ mathbf {U} _0">  ： </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BU%7D%20%3D%20%5B%5Cmathbf%7BU%7D_s%20%5Cquad%20%5Cmathbf%7BU%7D_0%5D%20" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><p></p><br><ul><li> 选择一些搜索范围： </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Cmu)%20%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7Bj0%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj0%5Cmu_Q%7D%20%5C%5C%20...%20%26...%26...%20%5C%5C%20e%5E%7Bj(M-1)%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Cmu_Q%7D%20%5Cend%7Bbmatrix%7D%20" alt="a（\ mu）= \开始{bmatrix} e ^ {j0 \ mu_1}＆...＆e ^ {j0 \ mu_Q} \\ ...＆...＆... \\ e ^ {j（ M-1）\ mu_1}＆...＆e ^ {j（M-1）\ mu_Q} \ end {bmatrix}"></div><p></p><br><p> 在哪里 <img src="https://tex.s2cms.ru/svg/%5Cmu%20%3D%20-%5Cfrac%7B2%5Cpi%20f_c%7D%7Bc%7D%5CDelta%20sin%5Ctheta%20%3D%20-%5Cfrac%7B2%5Cpi%20%7D%7B%5Clambda%20%7D%5CDelta%20sin%5Ctheta" alt="\ mu =-\ frac {2 \ pi f_c} {c} \ Delta sin \ theta =-\ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li> 计算伪频谱： </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(%5Ctheta)%3D%5Cfrac%7B%5Cmathbf%7Ba%7D%5EH%20(%5Ctheta)%5Cmathbf%7Ba%7D(%5Ctheta)%7D%7B%5Cmathbf%7Ba%7D%5EH(%5Ctheta)%5Cmathbf%7BU%7D_0%20%5Cmathbf%7BU%7D_0%5EH%20%5Cmathbf%7Ba%7D(%5Ctheta)%7D%20" alt="P_ {MU}（\ theta）= \ frac {\ mathbf {a} ^ H（\ theta）\ mathbf {a}（\ theta）} {\ mathbf {a} ^ H（\ theta）\ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a}（\ theta）}"></div><p></p><br><p> 表1中描述了频谱分析与EM波的到达角（DoA-到达方向）分析之间的关系。 </p><br><p> 表1 <strong>MUSIC应用程序之间的通信</strong> ：信号阵列处理和谐波搜索[6]。 </p><br><div class="scrollable-table"><table><thead><tr><th> 可变的 </th><th> 信号阵列处理 </th><th> 谐波搜索 </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/M" alt="中号"></div></td><td> 传感器数量 </td><td> 时间段数 </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/N" alt="ñ"></div></td><td> 时间段数 </td><td> 实验次数 </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/d" alt="d"></div></td><td> 波前数 </td><td> 复杂组件数 </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cmu" alt="\亩"></div></td><td> 空间频率 </td><td> 归一化频率 </td></tr></tbody></table></div><br><p> 通常，可以将通过阵列（光栅）的接收过程与经典离散化过程进行比较，因为 实际上，每个接收具有一定相位延迟（即具有一定时间延迟）的波的传感器都执行采样增量脉冲的功能。 经典频谱分析的实现（实验）数量将与时间段（快照）的数量相对应。 每个源都有自己的波前，在频谱分析的情况下，这等于信号的唯一正弦波数。 </p><br><p> 现在回到计算特征向量的时刻。 我们已经在上面提到了向量 <img src="https://tex.s2cms.ru/svg/a(%5Ctheta_i)%5Cepsilon%20A" alt="a（\ theta_i）\ epsilon A"> 在哪里 <img src="https://tex.s2cms.ru/svg/i%3D1%2C2%2C..%2Cd" alt="i = 1,2，..，d"> 与协方差矩阵的噪声子空间正交，即 </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Ctheta_i)%5ETU_0%3D0%5ET%20" alt="a（\ theta_i）^ TU_0 = 0 ^ T"></div><p></p><br><p> 实际上，我们看到了一个方程组，通过求解可以找到其根-特征向量。 与数值算法（如上所述，该算法适用于EVD）相反，这种方法允许人们获得真实的而不是近似的特征值。 这就是为什么这种方法允许我们获得的不是伪频谱，而是频谱。 相同的想法构成了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Root MUSIC</a>算法的基础。 </p><br><h2 id="modelirovanie"> 造型 </h2><br><p>  ！ 最后，对所有公式进行了描述并作了一些解释。 我们可以开始建模了。 </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles θ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p> 我们可以看到，MUSIC具有更高的分辨率，并且比MVDR所允许的结果总体上更好，例如MVDR可以代表光谱分析的参数化方法。 </p><br><p> 但是，应该牢记的是，使用MUSIC时，我们会使用计算量更大的算法，例如EVD或SVD，要付出更高的准确性，就要付出一定的代价。 </p><br><p> 这样的事情。 </p><br><h2 id="spisok-ispolzovannoy-literatury"> 二手文献清单： </h2><br><ol><li>  Haykin，Simon和KJ Ray Liu。 阵列处理和传感器网络手册。 卷  63.约翰·威利父子（John Wiley＆Sons），2010年。  102-107 </li><li>  Hayes MH统计数字信号处理和建模。  -约翰·威利父子（John Wiley＆Sons），2009年。 </li><li>  Haykin，SimonS。自适应滤波器理论。 印度Pearson Education，2008年。  422-427 </li><li> 里士满（Richmond），ChrisD。“ Capon算法均方误差阈值SNR预测和分辨率的可能性。”  IEEE Transactions on Signal Processing 53.8（2005）：2748-2764。 </li><li>  SKP Gupta，MUSIC和改进的MUSIC算法以模拟到达的确定性，IEEE，2015年。 </li><li> 马丁·哈特教授的演讲（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">数组</a> ） </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446674/">https://habr.com/ru/post/zh-CN446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446654/index.html">我们如何保存代码审查</a></li>
<li><a href="../zh-CN446656/index.html">用神经声码器LPCNet进行1600bit / s语音编码</a></li>
<li><a href="../zh-CN446664/index.html">距SAP论坛2019只有2周的路程！ 那里会有什么？</a></li>
<li><a href="../zh-CN446666/index.html">充分利用图形计算器：TI-83上的游戏</a></li>
<li><a href="../zh-CN446668/index.html">适用于网络的Python：大三学生工作和成长需要了解的知识</a></li>
<li><a href="../zh-CN446676/index.html">为Commodore 116橡胶键盘制作缺失的琴键</a></li>
<li><a href="../zh-CN446678/index.html">实战：波尔图ICPC决赛</a></li>
<li><a href="../zh-CN446680/index.html">编码器的主要本能是从各处消除无效的解决方案</a></li>
<li><a href="../zh-CN446682/index.html">使用OffscreenCanvas和Web Workers加速WebGL / Three.js</a></li>
<li><a href="../zh-CN446688/index.html">在Visual Studio中对C ++ OpenMP进行SIMD扩展</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>