<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚃 🤞 👦🏾 Fallen Sie nicht in die Falle einer vorzeitigen Optimierung 🚵🏽 👩🏻‍🎤 👨🏾‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Donald Knuth sagte einmal die Worte, die später berühmt wurden: „Das eigentliche Problem ist, dass Programmierer, nicht dort, wo sie müssen und nicht,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fallen Sie nicht in die Falle einer vorzeitigen Optimierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/465809/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Donald Knuth</a> sagte einmal die Worte, die später berühmt wurden: „Das eigentliche Problem ist, dass Programmierer, nicht dort, wo sie müssen und nicht, wenn sie brauchen, zu viel Zeit damit verbringen, sich um Effizienz zu kümmern.  Vorzeitige Optimierung ist die Wurzel aller Übel (oder zumindest der meisten von ihnen) in der Programmierung. “ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ps/qf/uj/psqfujg9tiki8nv85hrvqqwpyfy.jpeg"></a> <br><br>  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, möchte darüber sprechen, wie er einst in die Falle der vorzeitigen Optimierung geraten ist und wie er aus seiner eigenen bitteren Erfahrung verstanden hat, dass vorzeitige Optimierung die Wurzel aller Übel ist. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Spiel GeoArena Online</font> </h2><br>  Vor ein paar Jahren habe ich am Web-Spiel GeoArena Online gearbeitet (dann habe ich es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verkauft</a> , die neuen Besitzer haben es auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geoarena.io</a> gepostet).  Es war ein Multiplayer-Spiel im Stil des "letzten Überlebenden".  Dort kontrollierte der Spieler das Schiff und kämpfte eins zu eins gegen einen anderen Spieler. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/a9d/bcc/f49a9dbcc8d59ab914ce355de6231696.png"></div><br>  <i><font color="#999999">Spiel GeoArena Online</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/259/3b0/346/2593b03467d1c05d04b3b23022e131c6.png"></div><br>  <i><font color="#999999">Spiel GeoArena Online</font></i> <br><br>  Ein dynamisches Spiel, dessen Welt voller Partikel und Effekte ist, erfordert ernsthafte Rechenressourcen.  Infolgedessen wurde das Spiel auf einigen alten Computern in besonders angespannten Momenten „langsamer“.  Ich, ein Mann, dem Produktivitätsprobleme nicht gleichgültig sind, nahm die Lösung dieses Problems mit Interesse auf.  „Wie beschleunige ich den clientseitigen JavaScript-Teil von GeoArena?“, Fragte ich mich. <br><br><h2>  <font color="#3AC1EF">Fast.js Bibliothek</font> </h2><br>  Nachdem ich ein bisschen im Internet gesucht hatte, entdeckte ich die Bibliothek <a href="">fast.js.</a>  Es war eine "Sammlung von Mikrooptimierungen, die die Entwicklung sehr schneller JavaScript-Programme vereinfachen sollen".  Diese Bibliothek wurde durch die Verfügbarkeit schnellerer Implementierungen der integrierten Standardmethoden wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array.prototype.forEach () beschleunigt</a> . <br><br>  Ich fand das äußerst interessant.  GeoArena verwendete viele Arrays und führte viele Operationen mit Arrays durch. Die Verwendung von fast.js könnte mir also sehr helfen, das Spiel zu beschleunigen.  Die folgenden Ergebnisse der <code>forEach()</code> Leistungsstudie wurden in <a href="">README</a> für fast.js aufgenommen. <br><br><pre> <code class="javascript hljs">Native .forEach() vs fast.forEach() (<span class="hljs-number"><span class="hljs-number">10</span></span> items)  ✓ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>::forEach() x <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">557</span></span>,<span class="hljs-number"><span class="hljs-number">082</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.37</span></span>% (<span class="hljs-number"><span class="hljs-number">97</span></span> runs sampled)  ✓ fast.forEach() x <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">799</span></span>,<span class="hljs-number"><span class="hljs-number">272</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.41</span></span>% (<span class="hljs-number"><span class="hljs-number">97</span></span> runs sampled)  Result: fast.js is <span class="hljs-number"><span class="hljs-number">2.83</span></span>% faster than <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>::forEach().</code> </pre> <br>  Wie kann eine in einer externen Bibliothek implementierte Methode schneller sein als ihre Standardversion?  Die Sache ist, dass es einen Trick gab (sie, diese Tricks, sind überall zu finden, wo man hinschaut).  Die Bibliothek war nur für die Arbeit mit nicht spärlichen Arrays geeignet. <br><br>  Hier sind einige einfache Beispiele für solche Arrays: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -  :   1  . const sparse1 = [0, , 1]; console.log(sparse1.length); // 3 //  -   const sparse2 = []; // ...   - .   0 - 4    . sparse2[5] = 0; console.log(sparse2.length); // 6</span></span></code> </pre> <br>  Um zu verstehen, warum die Bibliothek mit spärlichen Arrays nicht normal funktionieren kann, habe ich mir den Quellcode angesehen.  Es stellte sich heraus, dass die Implementierung von <code>forEach()</code> in fast.js auf for-Schleifen basiert.  Eine schnelle Implementierung der <code>forEach()</code> -Methode würde ungefähr so ​​aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     . function fastForEach(array, f) {  for (let i = 0; i &lt; array.length; i++) {    f(array[i], i, array);  } } const sparseArray = [1, , 2]; const print = x =&gt; console.log(x); fastForEach(sparseArray, print); //  print() 3 . sparseArray.forEach(print); //  print()  2 .</span></span></code> </pre> <br>  Ein Aufruf der <code>fastForEach()</code> -Methode <code>fastForEach()</code> drei Werte aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Das Aufrufen von <code>sparseArray.forEach()</code> führt nur zur Schlussfolgerung von zwei Werten: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Dieser Unterschied ist auf die Tatsache zurückzuführen, dass JS-Spezifikationen bezüglich der Verwendung von Rückruffunktionen darauf hinweisen, dass solche Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht für entfernte oder nicht initialisierte Array-Indizes</a> (auch als "Löcher" bezeichnet) aufgerufen werden sollten.  Die Implementierung von <code>fastForEach()</code> hat das Array nicht auf Löcher überprüft.  Dies führte zu einer Geschwindigkeitssteigerung auf Kosten der korrekten Arbeit mit spärlichen Arrays.  Dies war perfekt für mich, da in GeoArena keine spärlichen Arrays verwendet wurden. <br><br>  An dieser Stelle sollte ich nur einen kurzen Test auf fast.js machen.  Ich sollte die Bibliothek installieren, die Standardmethoden des <code>Array</code> Objekts in Methoden von fast.js ändern und die Leistung des Spiels testen.  Stattdessen bewegte ich mich in eine ganz andere Richtung. <br><br><h2>  <font color="#3AC1EF">Meine Entwicklung hieß schneller.js</font> </h2><br>  Der in mir lebende manische Perfektionist wollte absolut alles aus der Optimierung der Leistung des Spiels herausholen.  Die Bibliothek fast.js schien mir einfach keine ausreichend gute Lösung zu sein, da ihre Verwendung das Aufrufen ihrer Methoden implizierte.  Dann dachte ich: „Was ist, wenn ich die Standardmethoden von Arrays ersetze, indem ich einfach neue, schnellere Implementierungen dieser Methoden in den Code einbette?  Das würde mir die Notwendigkeit von Bibliotheksmethodenaufrufen ersparen. “ <br><br>  Es war diese Idee, die mich zu der genialen Idee führte, einen Compiler zu erstellen, den ich dreist <a href="">schneller</a> nannte.  Ich hatte vor, es anstelle von fast.js zu verwenden.  Hier ist zum Beispiel das Quellcode-Snippet: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const arr = [1, 2, 3]; const results = arr.map(e =&gt; 2 * e);</span></span></code> </pre> <br>  Der Compiler "schneller.js" würde diesen Code in den folgenden konvertieren - schneller, aber schlechter aussehend: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      faster.js const arr = [1, 2, 3]; const results = new Array(arr.length); const _f = (e =&gt; 2 * e); for (let _i = 0; _i &lt; arr.length; _i++) {  results[_i] = _f(arr[_i], _i, arr); }</span></span></code> </pre> <br>  Die Erstellung von schneller.js wurde von der gleichen Idee angeregt, die fast.js zugrunde lag.  Wir sprechen nämlich von Mikrooptimierungen der Leistung aufgrund der Ablehnung der Unterstützung für dünn besetzte Arrays. <br><br>  Auf den ersten Blick schien mir schneller.js eine äußerst erfolgreiche Entwicklung zu sein.  Hier sind einige Ergebnisse einer Leistungsstudie von schneller.js: <br><br><pre> <code class="javascript hljs">  array-filter large    ✓ native x <span class="hljs-number"><span class="hljs-number">232</span></span>,<span class="hljs-number"><span class="hljs-number">063</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.36</span></span>% (<span class="hljs-number"><span class="hljs-number">58</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">083</span></span>,<span class="hljs-number"><span class="hljs-number">695</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.58</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">367.0</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.386</span></span>μs) than native  array-map large    ✓ native x <span class="hljs-number"><span class="hljs-number">223</span></span>,<span class="hljs-number"><span class="hljs-number">896</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.10</span></span>% (<span class="hljs-number"><span class="hljs-number">58</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">726</span></span>,<span class="hljs-number"><span class="hljs-number">376</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.13</span></span>% (<span class="hljs-number"><span class="hljs-number">60</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">671.1</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.887</span></span>μs) than native  array-reduce large    ✓ native x <span class="hljs-number"><span class="hljs-number">268</span></span>,<span class="hljs-number"><span class="hljs-number">919</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.41</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">621</span></span>,<span class="hljs-number"><span class="hljs-number">540</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.80</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">503.0</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.102</span></span>μs) than native  array-reduceRight large    ✓ native x <span class="hljs-number"><span class="hljs-number">68</span></span>,<span class="hljs-number"><span class="hljs-number">671</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.92</span></span>% (<span class="hljs-number"><span class="hljs-number">53</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">571</span></span>,<span class="hljs-number"><span class="hljs-number">918</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.16</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">2189.1</span></span>% faster (<span class="hljs-number"><span class="hljs-number">13.926</span></span>μs) than native</code> </pre> <br>  Die vollständigen Testergebnisse finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Sie wurden in Node v8.16.1 auf dem 15-Zoll-MacBook Pro 2018 gehalten. <br><br>  Ist meine Entwicklung 2000% schneller als die Standardimplementierung?  Eine solch ernsthafte Produktivitätssteigerung kann zweifellos die stärksten positiven Auswirkungen auf jedes Programm haben.  Richtig? <br>  Nein, nicht wahr. <br><br>  Betrachten Sie ein einfaches Beispiel. <br><br><ul><li>  Stellen Sie sich vor, dass ein durchschnittliches GeoArena-Spiel 5.000 Millisekunden (ms) Rechenzeit benötigt. </li><li>  Der Compiler schneller.js beschleunigt die Ausführung von Array-Methoden durchschnittlich um das Zehnfache (dies ist eine ungefähre Schätzung und wird auch überschätzt; in den meisten realen Anwendungen gibt es nicht einmal eine doppelte Beschleunigung). </li></ul><br>  Und hier ist die Frage, die uns wirklich interessiert: „Welcher Teil dieser 5000 ms wird für die Implementierung von Array-Methoden ausgegeben?“. <br><br>  Angenommen, die Hälfte.  Das heißt, 2500 ms werden für Array-Methoden aufgewendet, die restlichen 2500 ms für alles andere.  Wenn ja, dann sorgt die Verwendung von schneller.js für eine enorme Leistungssteigerung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/1fb/d74/cd31fbd7429d4ce60636a7031c657ac2.png"></div><br>  <i><font color="#999999">Bedingtes Beispiel: Die Ausführungszeit des Programms wird stark reduziert</font></i> <br><br>  Infolgedessen stellt sich heraus, dass die gesamte Rechenzeit um 45% reduziert wurde. <br><br>  Leider sind all diese Argumente sehr, sehr weit von der Realität entfernt.  GeoArena verwendet natürlich viele Array-Methoden.  Die tatsächliche Verteilung der Codeausführungszeit für verschiedene Aufgaben sieht jedoch wie folgt aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/7b8/2ff/2ae7b82ffd8c59c1632f7bab32d2b7fc.png"></div><br>  <i><font color="#999999">Harte Realität</font></i> <br><br>  Leider, was soll ich sagen. <br><br>  Dies ist genau der Fehler, vor dem Donald Knuth gewarnt hat.  Ich habe mich nicht darum bemüht, worauf sie angewendet werden sollen, und ich habe es nicht getan, als es sich gelohnt hat. <br><br>  Hier kommt einfache Mathematik ins Spiel.  Wenn etwas nur 1% der Programmausführungszeit in Anspruch nimmt, führt eine Optimierung im besten Fall nur zu einer Steigerung der Produktivität um 1%. <br><br>  Genau das hatte Donald Knuth im Sinn, als er sagte "nicht dort, wo es gebraucht wird".  Und wenn Sie darüber nachdenken, was „wo Sie es brauchen“, stellt sich heraus, dass dies die Teile der Programme sind, die die Leistungsengpässe darstellen.  Dies sind die Codeteile, die einen wesentlichen Beitrag zur Gesamtleistung des Programms leisten.  Hier wird das Konzept der "Produktivität" im weitesten Sinne verwendet.  Es kann die Laufzeit des Programms, die Größe des kompilierten Codes und etwas anderes enthalten.  Eine 10% ige Verbesserung in dem Teil des Programms, der die Leistung stark beeinflusst, ist besser als eine 100% ige Verbesserung in einigen kleinen Dingen. <br><br>  Knut sprach auch von der Anwendung von Bemühungen "nicht wenn nötig".  Der Punkt dabei ist, dass Sie etwas nur dann optimieren müssen, wenn es notwendig ist.  Natürlich hatte ich einen guten Grund, über Optimierung nachzudenken.  Aber denken Sie daran, dass ich mit der Entwicklung von quick.js begonnen habe und vorher nicht einmal versucht habe, die fast.js-Bibliothek in GeoArena zu testen?  Minuten, die ich damit verbracht habe, fast.js in meinem Spiel zu testen, würden mir Wochen Arbeit ersparen.  Ich hoffe, Sie geraten nicht in dieselbe Falle, in die ich geraten bin. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wenn Sie mit schneller.js experimentieren möchten, können Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese</a> Demo ansehen.  Welche Ergebnisse Sie erhalten, hängt von Ihrem Gerät und Ihrem Browser ab.  Hier zum Beispiel, was in Chrome 76 auf dem 15-Zoll-MacBook Pro 2018 passiert ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08d/7f9/05c/08d7f905cc232d83c0b17a9107d2abd5.png"></div><br>  <i><font color="#999999">Faster.js Testergebnisse</font></i> <br><br>  Vielleicht möchten Sie mehr über die tatsächlichen Ergebnisse der Verwendung von schneller.js in GeoArena erfahren.  Ich habe, als das Spiel noch mir gehörte (wie gesagt, ich habe es verkauft), einige Grundlagenforschung betrieben.  Als Ergebnis stellte sich Folgendes heraus: <br><br><ul><li>  Die Verwendung von schneller.js beschleunigt die Ausführung des Hauptspielzyklus in einem typischen Spiel um etwa 1%. </li><li>  Aufgrund der Verwendung von schneller.js wurde die Größe des Spielpakets um 0,3% erhöht.  Dies verlangsamte das Laden der Spieleseite etwas.  Die Größe des Bundles hat zugenommen, da schneller.js den Standard-Funktionscode in schnelleren, aber auch längeren Code konvertiert. </li></ul><br>  Im Allgemeinen hat schneller.js Vor- und Nachteile, aber meine Entwicklung hatte keinen großen Einfluss auf die Leistung von GeoArena.  Ich hätte das viel früher verstanden, wenn ich mir die Mühe gemacht hätte, das Spiel zuerst mit fast.js zu testen. <br><br>  Möge meine Geschichte Ihnen als Warnung dienen. <br><br>  <b>Liebe Leser!</b>  Sind Sie in die Falle einer vorzeitigen Optimierung geraten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465809/">https://habr.com/ru/post/de465809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465797/index.html">Genetische Algorithmen (oder der Klient ist immer König - und oft ein Narr)</a></li>
<li><a href="../de465801/index.html">Food Design Digest, August 2019</a></li>
<li><a href="../de465803/index.html">Maven-Weg, um Go-Projekte zu bauen</a></li>
<li><a href="../de465805/index.html">Gigatron - ein hausgemachter Mikrocomputer ohne Prozessor</a></li>
<li><a href="../de465807/index.html">Die Geschichte, wie die beliebte JavaScript-Bibliothek begann, Anzeigen im Terminal anzuzeigen</a></li>
<li><a href="../de465811/index.html">14 Tipps zum Schreiben von sauberem React-Code. Teil 1</a></li>
<li><a href="../de465813/index.html">14 Tipps zum Schreiben von sauberem React-Code. Teil 2</a></li>
<li><a href="../de465815/index.html">Wissenschaftler haben Cluster von Nervenzellen gezüchtet und sie an die ISS geschickt</a></li>
<li><a href="../de465817/index.html">Wie Unbehagen uns hilft, den Entwicklungsprozess zu verbessern.</a></li>
<li><a href="../de465819/index.html">Ideales LAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>