<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧐 🚜 🚂 如何使用PieceofScript“ bike”开发和测试API 🖐️ 👊🏾 🍶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PieceofScript是一种简单的语言，用于编写用于自动测试HTTP JSON API的脚本。 

 PieceofScript允许您执行以下操作： 



- 以几乎自然的语言描述YAML格式的API方法，并以该方法的名称来表示，这便于阅读测试 
- 足够灵活以YAML格式描述模型并从中生成随...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何使用PieceofScript“ bike”开发和测试API</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430392/">  PieceofScript是一种简单的语言，用于编写用于自动测试HTTP JSON API的脚本。 <br><br>  PieceofScript允许您执行以下操作： <br><br><ul><li> 以几乎自然的语言描述YAML格式的API方法，并以该方法的名称来表示，这便于阅读测试 </li><li> 足够灵活以YAML格式描述模型并从中生成随机数据 </li><li> 用简单易懂的语言和简单的语法编写复杂的API调用脚本 </li><li> 获得JUnit和HTML格式的测试结果 </li></ul><br> 我之所以写这个“自行车”，是因为SoapUI界面使我失望了。 我想在没有特殊GUI的文本编辑器中简单清晰地描述测试。 另外，git不会消化SoapUI发出的庞大的xml文件，因此很难将特定任务的测试放在完成任务本身的同一分支中。  Postman界面要好得多，但是在开发时，要花很多时间在这里编写/修改请求并按正确的顺序重复它们。 我想自动化。 我还研究了其他测试工具，每个工具都有一个“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">致命缺陷</a> ”，因此为了适应<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NIH综合症，</a>我打开了一个IDE。 <br><br> 这就是它的来历。 <br><br><img src="https://habrastorage.org/webt/be/su/_o/besu_olm_gbromxnr34mzcvy8sy.gif"><br><a name="habracut"></a><br> 解释器是用PHP编写的，是phar存档；它需要PHP 7.2版本，尽管它也可以在7.1上运行。 源代码和文档<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/maximw/PieceofScript</a> 。 开发中的文档。 事实证明，这是最困难和乏味的部分。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试项目，其结构和启动</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试脚本</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API测试方法</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API方法调用</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模型和测试数据的生成</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内建功能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试用例</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">变量和范围</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类型和操作</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运行之间保存数据</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">输出到标准输出和报告</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> -足够的单词，显示代码！ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未来的评论和计划（如果有）</a> <br><br><a name="struct"></a><h2> 测试项目，其结构和启动 </h2><br> 该项目是一个目录，其中包含一组脚本文件，API方法描述文件和测试数据生成器。 <br><br> 在最低版本中，项目如下所示： <br><br><pre><code class="plaintext hljs">./tests endpoints.yaml -  API generators.yaml -  start.pos -   </code> </pre> <br> 启动文件是开始测试过程的脚本。 它在启动时设置： <br><br><pre> <code class="bash hljs">pos.phar run ./start.pos --junit=junit_report.xml -vvv --config=config.yaml</code> </pre> <br> 从包含启动文件的工作目录中读取所有相对路径。 <br> 可以在命令行中使用<i>--config</i>选项指定配置文件，或者将<i>config.yaml</i>放在工作目录中。 该配置是可选的，您需要根据需要进行爬升。  <a href="">有关配置的更多信息</a> 。 <br><br><a name="script"></a><h2> 测试脚本 </h2><br> 对于我自己，我决定在扩展名为.pos的文件中编写脚本，以便您可以在扩展名为IDE的代码中进行代码突出显示设置。 但是解释器对扩展完全不关心。 <br><br> 这是一个虚构论坛的简单脚本示例，其中执行了由不同用户创建和阅读帖子的测试。 <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">"./globals.pos"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ,  $domain include "./globals_local.pos" //     ,    include "./user/*.pos" //       ./user  ./post include "./post/*.pos" //       var $author = User() var $reader = User() var $banned = User() var $post = Post() Register $author //   API,     must $response.code == 201 //     Register $reader must $response.code == 201 Register $banned must $response.code == 201 Add $banned to blacklist of $author //$banned      $author Create post $post by $author //   API   must $response.code == 201 //    API   201 // ...,   ,       assert $response.body.post.content == $post.content var $postId = $response.body.post.id // Id     Read post $postId by $author //     must $response.code == 200 assert $response.body.post.content == $post.content Read post $postId by $reader //      must $response.code == 200 assert $response.body.post.content == $post.content Read post $postId by $banned //        assert $response.code == 404</span></span></code> </pre><br> 是的，如果没有背光，它看起来不会很好。 <br><br> 脚本的每一行都以运算符开头，或者是对API方法的调用。 如果突然，API方法的名称以与其中一个运算符匹配的单词开头，则可以使用“ <i>&gt;</i> ”符号： <br><br><pre> <code class="plaintext hljs">&gt;Include $user to group $userGroup</code> </pre> <br> 运算符不区分大小写。 断言，ASSERT或aSsErT（但是为什么要这样写？）将起作用。 <br> 每个语句或API方法调用必须位于单独的行上。 但是，如果字符串的最后一个字符为<i>\</i> （您好，Python），也可以换行。 <br><br><div class="spoiler">  <b class="spoiler_title">关于换行和缩进的无趣细节</b> <div class="spoiler_text"> 如果注释中使用换行，则下一行也将被视为注释的一部分。 将行包装在块内（ <i>testcase</i> ， <i>if</i> ， <i>while</i> ， <i>foreach</i> ）时，重要的是<i>缩进</i> ，以使下一行落入同一块中。 <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $n = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $i = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $fib1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; \ $fib2 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> $i &lt;= $n <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $fib_sum = \ $fib2 + $fib1 <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> toString($i) + <span class="hljs-string"><span class="hljs-string">"  :"</span></span> + \ toString($fib_sum) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $fib1 = $fib2 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $fib2 = $fib_sum <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $i = $i + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br> 当执行块语句（ <i>testcase</i> ， <i>if</i> ， <i>while</i> ， <i>foreach</i> ）时，块由其行的缩进确定。 缩进被计算为一行开头的空白数。 空格和制表符都视为一个字符，但是制表符通常在编辑器中显示为多个空格。 因此，为避免混淆，最好使用制表符或空格，但不能同时使用。 <br></div></div><br><h4> 运营商完整列表 </h4><br>  <b>require <i>fileName-</i></b>将文件附加到调用运算符的位置。 附件将立即从第一行开始。 完成后，解释器将返回源文件的下一行。 如果请求的文件不可读，将产生错误。 相对路径是从工作目录中计算出来的。 <br><br>  <b>include <i>fileMask-</i></b>与require相似，但是如果请求的文件不可读，则不会有错误。 例如，这对于为不同的测试环境创建设置非常方便。 另外，include可以一次通过掩码连接所有文件。 因此，例如，您可以下载包含测试用例的文件的整个目录。 但是同时，不能保证以任何顺序下载文件。 <br><br>  <b>var <i>$ variable1 = expression1</i> ;</b>  <b><i>$ variable2 = expression2</i> ; ...;</b>  <b><i>$ variableN = expressionN-</i></b>为变量分配值。 如果该变量尚不存在，它将在当前上下文中创建。 <br><br>  <b>令<i>$ variable1 = expression1</i> ;</b>  <b><i>$ variable2 = expression2</i> ; ...;</b>  <b><i>$ variableN = expressionN-</i></b>为变量分配值。 如果该变量不在当前上下文中，则将尝试在全局上下文中创建或修改该变量。 <br><br>  <b>const <i>$ const1 = expression1</i> ;</b>  <b><i>$ const2 = expression2</i> ; ...;</b>  <b><i>$ constN = expressionN-</i></b>设置当前上下文中的常量值。 常量和变量之间的区别仅在于它们无法更改；当您尝试为常量分配值时，在声明之后将发出警告。 如果已经有一个同名的变量，则在尝试将其声明为常量时将生成错误。 否则，变量所适用的所有内容对常量也适用。 <br><br>  <b>导入<i>$ variable1</i> ;</b>  <b><i>$ variable2</i> ; ...;</b>  <b><i>$ variableN-将</i></b>变量从全局复制到当前上下文。 如果您需要对全局变量的值进行操作而不需要更改它，则它可能会很有用。 <br><br>  <b>testcase <i>testCaseName-</i></b>宣布一个测试用例，然后可以使用<i>run</i>语句将其称为一个单元。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在本文的后面阅读更多关于测试用例的信息</a> 。 <br><br>  <b>断言<i>表达式</i></b> -检查<i>表达式</i>是否为<i>true</i> ，否则打印有关失败测试的报告。 <br><br>  <b>must <i>表达式</i></b>与<i>assert</i>相同，仅当测试失败时，当前测试用例才会停止。 在测试用例的上下文之外，脚本将完全终止。 如果发现错误而无法进行进一步的检查，则可以使用它。 <br><br>  <b>运行<i>testCaseName-</i></b>运行指定的测试用例以执行。  <i>在</i>不指定测试用例名称的情况下运行，将启动所有不需要按照声明顺序进行参数声明的测试用例。 <br><br>  <b>while <i>expression-</i></b>一个循环，而<i>expression为</i> true时，执行缩进行的语句比<i>while</i>更为有效。 <br><br>  <b>foreach <i>$数组</i> ;</b>  <b><i>$</i></b> element-遍历数组，对数组的每个下一个元素执行循环体。 还可以获取密钥<b>foreach <i>$ array</i> ;</b>  <b><i>$键</i> ;</b>  <b><i>$元素</i></b> 。  <i>$ key</i>和<i>$ element</i>变量在当前上下文中创建/覆盖。 <br><br>  <b>if <i>expression-</i></b>如果<i>expression为</i> true，则执行缩进行的语句比<i>if多</i> <br><br>  <b>打印<i>expression1</i> ;</b>  <b><i>expression2</i> ; ... <i>expressionN-将expressionM</i></b>的值打印到stdout。 它可用于调试，仅在“健谈”级别<i>--verbosity = 1</i>或<i>-v</i>及更高级别下起作用。 <br><br>  <b>睡眠<i>表达式</i></b> -停顿给定的数字（可以选择整数）秒。 有时您需要让经过测试的API休息一下。 <br><br>  <b>暂停<i>表达式</i></b> -不处于交互模式（命令行选项<i>-n</i> ）类似于<i>sleep</i> 。  <i>表达式</i>是可选的，在这种情况下不会暂停。 并且在交互模式下，在按Enter之前先暂停。 <br><br>  <b>取消</b> -结束测试。 口译员完成工作，创建报告。 <br><br><a name="methods"></a><h2>  API测试方法 </h2><br> 这实际上是您需要测试的内容-使用某些参数进行调用并检查答案是否符合期望。 <br><br>  API方法以YAML格式描述。 默认情况下，描述应在当前目录的<i>endpoints.yaml</i>文件中和/或在其<i>./endpoints</i>子目录的<i>* .yaml</i>文件中。 在测试之前，解释器将尝试一次读取所有这些文件。 <br><br>  <i>endpoints.yaml</i>结构示例： <br><br><pre> <code class="plaintext hljs">Auth $user: method: "POST" url: $domain + "/login" headers: Content-Type: "application/json" format: "json" data: login: $user.login password: $user.password after: - assert $response.code == 200 - let $user.auth_token = $response.body.auth_token Create post $post by $user: method: "POST" url: $domain + "/posts" format: "json" data: $post headers: auth: "Bearer " + $user.auth_token content-type: "application/json" after: - assert $response.code == 201 Read post $postId by $user: method: "GET" url: $domain + "/posts/" + $postId headers: auth: "Bearer " + $user.auth_token content-type: "application/json" after: - assert ($response.code == 200) || ($response.code == 404) Create comment $comment on $post by $user: method: "POST" url: $domain + "/comments/create/" + $post.id format: "json" data: $comment headers: auth: "Bearer " + $user.auth_token content-type: "application/json" after: - assert $response.code == 201</code> </pre><br> 可以用来调用的API方法的名称（YAML结构的顶层）是几乎任意格式的字符串。 <br><br> 可以在名称中的任何位置指定参数。 它们之间应以空格隔开。 例如，最后一个方法中的<i>$ comment</i> ， <i>$ post</i>和<i>$ user</i> 。 <br><br> 另外，在名称中的任何位置都可以在双花括号中指定可选的方法值。 <br><br><pre> <code class="plaintext hljs">Get comments of $post {{$page=1; $perPage=$defaultGlobalPageSize}}: method: "GET" url: $domain + "/comments/" + $post.id query: page: $page per_page: $perPage headers: auth: "Bearer " + $user.auth_token content-type: "application/json" after: - assert $response.code == 200</code> </pre> <br> 在指定可选值的表达式中，全局上下文变量可用。 <br> 可选值很有用，因此您不必在每次调用API方法时都指定它们。 如果只需要在一个地方更改页面大小，为什么要在所有其他地方指示它？ 对该方法的调用示例： <br><br><pre> <code class="plaintext hljs">Get comments of $newPost //     $page  $perPage Get comments of $newPost {{$page=$currentPage+1}} Get comments of {$newPost} {{$perPage=10;$page=100}}</code> </pre><br> 其余的变量（上例中的<i>$域</i> ）将从全局上下文中获取。 稍后我会告诉您更多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关上下文的信息</a> 。 <br><br> 在我看来，以自然语言为API方法提供人类可读的名称很方便，因此测试脚本更易于阅读。 名称不区分大小写，即<i>Auth $ User</i>方法可以称为<i>auth $ User</i>和<i>AUTH $ User</i> 。 但是，变量名称区分大小写，以下更多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关变量的信息</a> 。 <br><br>  <b>重要说明。</b>  YAML格式允许您不要将字符串括在引号中。 但是对于解释器，不带引号的字符串是需要评估的表达式。 例如，声明<code>url: http://example.com/login</code>字段将在执行期间导致语法错误。 因此，它是正确的： <code>url: "http://example.com/login"</code>或<code>url: "http://"+$domain+"/login"</code> <br><br><h4>  API方法描述字段 </h4><br>  <i><b>方法</b></i> -必需的HTTP方法 <br><br>  <i><b>url-</b></i>实际网址，必填 <br><br>  <i><b>标头</b></i> -HTTP标<i><b>头</b></i>列表，可选 <br><br>  <i><b>cookie-</b></i>可选的cookie列表 <br><br>  <i><b>auth-</b></i>用于HTTP身份验证的数据，可选 <br><br><pre> <code class="php hljs">auth: login: $login password: $password type: <span class="hljs-string"><span class="hljs-string">"basic"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  "digest"  "ntlm", - "basic"</span></span></code> </pre> <br>  <i><b>查询</b></i> -URL参数列表，可选 <br><br>  <i><b>格式</b></i> -值之一： <br><br><ul><li>  <i>无</i> -请求没有内文 </li><li>  <i>json-</i>发送到JSON </li><li>  <i>raw-</i>按原样发送字符串 </li><li>  <i>表格</i> -应用程式/ x-www-form-urlencoded格式 </li><li>  <i>多部分</i> -多部分/表单数据格式 </li></ul><br> 可选，默认<i>无</i> <br><br>  <i><b>数据</b></i> -请求主体，将以format <i>格式</i> （可选）指定的<i>格式</i>发送 <br><br><ul><li> 如果<i>没有</i> -可能缺少<i>数据</i>格式（如果存在），将被忽略 </li><li> 对于<i>json</i>格式，任何值 </li><li> 对于<i>原始</i>格式，任何标量值 </li><li> 对于<i>表单</i>格式，其键为字段名称的数组： <br><br><pre> <code class="plaintext hljs">data: login: "Bob" password: $password remember_me: 1</code> </pre> </li><li> 对于<i>多部分</i>格式，具有以下结构的数组： <br><br><pre> <code class="plaintext hljs">data: user_id: value: 42 headers: X-Baz: "bar" avatar: file: "/path/to/file" photo: file: "http://url.to/file" filename: "custom_filename.jpg"</code> </pre> </li></ul><br> 在<i>文件</i>字段中指定的<i>文件</i>必须可读。 如果指定了URL，则必须在php.ini中启用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">allow_url_fopen</a> <br><br>  before-将在HTTP请求之前执行的语句，可选 <br><br>  after-将在HTTP请求之后执行的语句，可选 <br><br> 在执行检查或处理每次执行HTTP请求之前或之后所需的任何数据时， <i>before</i>和<i>after</i>块的想法并不是由测试需求决定的，而由业务逻辑决定。 例如，将发出的授权令牌复制到$用户结构的字段中，以代表该用户调用所有后续API方法。 或者检查响应的HTTP状态，以免每次调用脚本后都检查响应。 <br><br><a name="call"></a><h2>  API方法调用 </h2><br> 要在脚本中调用API方法，您需要根据需要指定其名称和参数。 这是上面描述中调用最后一个API方法的示例： <br><br><pre> <code class="php hljs">Create comment $comments<span class="hljs-number"><span class="hljs-number">.1</span></span> on {$newPost} by {$postAuthor}</code> </pre> <br> 如果参数用大括号括起来，它将按值传递-这样，您可以传递任何表达式。 如果指定不带花括号的参数，则该参数将通过引用传递-它只能是变量和对数组元素的静态访问（通过句点，但不能通过括号[]）。 <br><br><pre> <code class="php hljs">Create comment {$comments[$i]} on $posts<span class="hljs-number"><span class="hljs-number">.0</span></span> by $users<span class="hljs-number"><span class="hljs-number">.1</span></span> Read post {<span class="hljs-number"><span class="hljs-number">123</span></span>} by $user Get comments of $users<span class="hljs-number"><span class="hljs-number">.1</span></span>.id {{$page = <span class="hljs-number"><span class="hljs-number">2</span></span>}}</code> </pre> <br> 每次在调用本身的上下文中（在<i>before</i>和<i>after</i>语句的列表中）以及在调用它的上下文中调用API方法时，都会<i>创建</i>变量<i>$ request</i>和<i>$ response</i> 。 这些是保留名称，我不建议将它们用于其他目的。  <i>$ request</i> <i>在</i>块<i>之前</i>和<i>之后</i>均可用，并且<i>$ response</i>仅在其值变为<i>Null</i> <i>之前的</i> <i>after之后</i> 。 在调用上下文中，这些变量在下一个API方法调用之前可用，在此之前它们将被重新初始化。 <br><br><h4>  $请求结构 </h4><br>  <b>$ request.method-</b>字符串-HTTP方法 <br>  <b>$ request.url-</b>字符串-请求的URL <br>  <b>$ request.query-</b>数组-GET参数列表 <br>  <b>$ request.headers-</b>数组-请求标头列表 <br>  <b>$ request.cookies-</b>数组-cookie列表 <br>  <b>$ reuqest.auth-</b>数组或空-用于HTTP身份验证的数据 <br>  <b>$ request.format-</b>字符串-请求数据格式 <br>  <b>$ request.data-</b>输入<b>any-</b> <i>数据</i>字段中计算出的值 <br><br><h4>  $响应结构 </h4><br>  <b>$ response.network-</b>布尔值-如果错误是在低于HTTP的网络级别上，则为false <br>  <b>$ response.code-</b>数字或Null-响应码，例如200或404 <br>  <b>$ response.status-</b>字符串或Null-响应状态，例如“ 204 No Content”或“ 401未经授权” <br>  <b>$ response.headers-</b>数组-响应标头列表，标头名称为小写 <br>  <b>$ response.cookies-</b>数组-Cookies列表 <br>  <b>$ response.body-</b>任何类型-响应主体都以JSON处理，如果在解析过程中发生错误，则根本没有<i>body</i>元素： <code>@response.body == null</code> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于检查变量是否存在</a> ） <br>  <b>$ response.raw-</b>字符串或Null-原始响应正文 <br>  <b>$ response.duration-</b>类型号-请求持续时间（以秒为单位） <br><br><a name="generators"></a><h2> 模型和测试数据的生成 </h2><br> 生成器用于描述模型并从中生成测试数据。  YAML格式的描述应该在工作目录中的<i>generators.yaml</i>文件中，和/或<i>./generators</i>子目录中的<i>* .yaml</i>文件中。 <br><br><pre> <code class="plaintext hljs">User: body: login: Faker\login() name: Faker\name() email: Faker\email() password: Faker\text(16) child: Child() birthday: dateFormat(Faker\datetime(), "U") settings: notifications_enabled: Faker\boolean() Child: body: name: Faker\name() gender: Faker\integer(1, 2) age: Faker\integer(0, 18) Comment($user): body: content: "Hi! I'm " + $user.name tags: - "tag1" - "tag2"</code> </pre><br> 在上面的示例中，声明了三个生成器<i>User（）</i> ， <i>Child（）</i>和<i>Comment（）</i> 。 在这种情况下，后者的参数<i>为$ user，</i>并且可以在生成时使用此数据。 生成器的参数始终按值传递。 此外，该示例还使用了多个内置函数： <i>Faker \ name（）</i> ， <i>Faker \ email（）</i> ， <i>dateFormat（）</i>等。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内置功能一节</a> 。 <br><br> 从上面的示例调用<i>User（）</i>生成器时，将生成一个在JSON中看起来像这样的结构： <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"fgadrkq"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Lucy Cechtelar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"email"</span></span>: <span class="hljs-string"><span class="hljs-string">"tkshlerin@collins.com"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"gbnaueyaaf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"child"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adaline Reichel"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"gender"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"birthday"</span></span>: <span class="hljs-number"><span class="hljs-number">318038400</span></span>, <span class="hljs-attr"><span class="hljs-attr">"settings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"notifications_enabled"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre><br>  <i>child</i>字段的值是<i>Child</i> <i>（）</i>生成器的结果。 <br><br> 与API方法的描述一样，任何未用引号引起来的字符串都将被视为要评估的表达式。 这不仅可以是对另一个生成器的调用，还可以是任意表达式，例如，在<i>Comment（$ user）</i>生成器中， <i>content</i>字段表示字符串Hi！的串联。 我和名字传递给<i>$用户</i> <br><br> 生成器的名称不区分大小写，并且必须以拉丁字母开头；它们可以包含拉丁字母，数字，下划线和反斜杠。 <br><br> 因为调用生成器和内置函数的语法相同，所以它们共享一个公共的名称空间。 按照惯例，我建议使用反斜杠作为分隔符，以基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/fzaninotto/Faker</a>库指定“供应商”或内置函数库，例如Faker \ something（）函数。 <br><br><div class="spoiler">  <b class="spoiler_title">使用发电机的细微差别，您无法阅读</b> <div class="spoiler_text"> 使用生成器，您可以组成数据结构： <br><br><pre> <code class="plaintext hljs"># Userredentials     $user Userredentials($user): body: login: $user.email password: $user.password #    .     ,    GlobalSearchResult($posts, $comments, $users): body: posts: title: " " list: $posts comments: title: " " list: $comments users: title: " " list: $users</code> </pre><br>  <i>GlobalSearchResult</i>不是在请求中发送给API方法的测试数据，而是一种响应模型，可以使用API​​将发送的内容进行验证，例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>相似（）</i></a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>相同（）</i></a>函数。 <br><br> 生成器可以使用在<i>replace</i>和<i>remove</i>字段中计算出的结构来更改在主体中获得的结构。 我给你看一个例子。 <br><br> 假设您已经有一个<i>User（）</i>生成器，可以为用户创建正确的数据结构。 现在，您需要检查如果提供的数据不正确，API将如何响应。 您可以通过两种方式进行： <br><br><ul><li> 从头开始创建“错误的”用户生成器。 但是随后我们将获得代码重复，例如，稍后，根据业务逻辑的需要向用户添加新字段时，您将不得不在两个地方进行更改。 干！ </li><li> 您可以通过将其设置在<i>主体中</i> ，从现有的User（）结构“继承”它。 在<i>替换</i>和<i>删除中，</i>设置将要添加/更改和删除的字段。 </li></ul><br><pre> <code class="plaintext hljs">#      ,    , #    InvalidUser($user): body: $user replace: email: Faker\String(6, 15) #   password: Faker\String(1, 5) #    new_field: "      ,  " remove: name: size($user.name) &lt; 10 #  ,    10  #      , #        InvalidNewUser: body: User() replace: login: "!@#$%^&amp;*" #   remove: about: true settings: notifications: 100500 #       , #      true</code> </pre><br> 当生成器工作时，首先计算<i>主体中</i>的数据结构，然后覆盖它，并使用<i>replace</i>元素进行补充<i>，</i>然后如果<i>remove</i>中指定的字段值等于<i>true，</i>则删除它们。 如果<i>body</i> ， <i>replace</i>或<i>remove</i>的计算结果不是数组，则不会有错误，但是也没有意义，因为不会有任何字段可以替换和删除。 <br></div></div><br><a name="functions"></a><h2> 内建功能 </h2><br>  <a href="">内置功能的完整列表</a> 。 例如，我只给出其中一些。 <br> 如果已定义返回值的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类型，则</a>在函数名称和参数列表之后显示。 <br><br><h4> 变量操作： </h4><br>  <b>相似</b> （$ var，$ sample，$ checkTypes） <i>布尔值</i> -如果参数的类型相同，则返回<i>true</i> ；如果<i>$ var</i>是数组，则<i>$ sample中的</i>所有字符串键都应位于<i>$ var中</i> ；如果<i>$ checkTypes为</i> true，则相应元素的类型必须匹配。 换句话说， <i>$ var</i>数组的元素是<i>$ sample</i>元素的子集。 <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$变种，样品，$ checkTypes）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布尔</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -类似物</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相似的（） </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">在阵列的情况下的附加的反向状态，在串中的所有的键</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是$ var</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该是在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$样品</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。换句话说，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ var</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">的元素等于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ sample</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组的元素，</font><font style="vertical-align: inherit;">直到元素类型。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ var1，$ var2，... $ varN）-传递值的最大值（如果可以比较）。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ var1，$ var2，... $ varN）-传递值的最小值。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ condition，$ var1，$ var2）-如果$ condition == true，则它将返回$ var1，否则返回$ var2。替换教练操作员（您好，MySQL）。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （$ condition1，$ var1，$ condition2，$ var2，...，$ conditionN，$ varN）-如果$ conditionK == true，将返回第一个遇到的$ varK。 </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用字符串： </font></font></h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大小</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$字符串）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数量</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -以UTF-8编码的线路长度。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$字符串，$ regex）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布尔值</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -检查字符串是否包含</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正则表达式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regexMatch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ string，$ regex）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -将返回一个字符串数组-与常规组</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ regex</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">匹配</font><font style="vertical-align: inherit;">。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数组处理： </font></font></h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阵列的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ VAR1，VAR2 $ ... $ VARN）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的阵列</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -创建的输入和输出元件的阵列。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$数组）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Number-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">中元素的数量。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keys</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ array）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array-数组</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中键的列表。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slice</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ array，$ offset，$ length）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -长度为$ length的$ offset的数组的一部分，（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">append</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$数组，$值）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在数组末尾添加一个元素。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prepend</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$数组，$值）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在数组的开头添加一个元素。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 日期处理： </font></font></h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dateFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ date，$ format）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -日期格式，（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关格式的更多信息</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dateModify</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ date，$ format）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日期</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -更改日期，便于与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相对格式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一起使用</font><font style="vertical-align: inherit;">。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 随机测试数据生成： </font></font></h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faker \整数</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ min，$ max）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -从$ min到$ max包括在内的随机整数</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faker \ ipv4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -随机IPv4 </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faker \ arrayElement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（$ array）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><font style="vertical-align: inherit;">数组中的</font><font style="vertical-align: inherit;">随机元素</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faker \ name</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -随机名称</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faker \ email</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -随机电子邮件</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在没有太多内置函数。</font><font style="vertical-align: inherit;">在测试中，我仅添加了我认为必要的内容。</font><font style="vertical-align: inherit;">您可以根据需要在新版本中添加新功能。</font><font style="vertical-align: inherit;">将来，如果需要，我将添加创建动态连接功能的功能，这些功能在PHP中作为特殊类实现。</font></font><br><br><a name="testcases"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 测试用例 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试用例是可以称为一个单元的一系列语句。</font><font style="vertical-align: inherit;">用编程语言对过程进行某种模拟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试用例由</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">testcase语句</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建</font><font style="vertical-align: inherit;">，后跟</font><i><font style="vertical-align: inherit;">测试用例</font></i><font style="vertical-align: inherit;">的名称，其语法类似于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> names </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">禁止嵌套测试用例。</font></font><br><br><pre> <code class="php hljs">testcase Registration $device <span class="hljs-comment"><span class="hljs-comment">//     var $user = User() Register $user on $device assert $response.code == 201 //        var $user = User() //       InvalidUser() var $user.email = "some_bad_email" Register $user on $device assert $response.code == 400</span></span></code> </pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">run</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句</font><font style="vertical-align: inherit;">可以调用单独的测试用例，也可以调用不需要参数的所有测试用例。</font></font><br><br><pre> <code class="php hljs">run Get all users <span class="hljs-comment"><span class="hljs-comment">//   -,    run Get user $user_id //   -   run //   -,    </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种启动的想法是，测试用例可以用作业务逻辑一部分的独立独立测试，并且可以用作避免在复杂测试场景中重复代码的过程。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数是通过引用或值传递给测试用例的，完全类似于将参数传递给API方法。</font></font><br><br><a name="vars"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 变量和范围 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量名称区分大小写，并以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号开头</font><font style="vertical-align: inherit;">（是的，是的，我是pshpshnik）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果变量类型的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阵列</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后访问各个字段或值的元素是通过点制备：</font></font><code>$users.12.password</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在点之间，只能使用数字或拉丁字母，下划线和带有第一个拉丁字母的数字。</font><font style="vertical-align: inherit;">字段名称也区分大小写。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以动态访问数组元素：</font></font><code>$post.comments[$i + 1].content</code> <br><br><a name="contexts"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上下文有四种类型-变量的范围。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全局上下文</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -首先创建，包含在执行测试用例和API方法调用之外的语句时声明的所有变量。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试用例上下文</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -每次使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">run</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句执行测试用例时，都会创建一个新的</font><b><font style="vertical-align: inherit;">上下文</font></b><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API方法上下文</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -在执行API方法，执行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">before</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分中指定的运算符时创建</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器上下文</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-生成器中不可能创建新的或更改现有的变量，因此全局上下文变量和参数是只读的。</font><font style="vertical-align: inherit;">变量总是按值传递给生成器上下文。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要说明。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有上下文中，如果未在当前上下文中创建它们的名称，则全局上下文变量可用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用变量的运算符示例：</font></font><br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $a = <span class="hljs-number"><span class="hljs-number">1</span></span> let $a = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//    var $b = 1 const $b = 3 //    const $c = 3; $c = 4 //   , $c     </span></span></code> </pre><br><pre> <code class="php hljs">let $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; $a = $a + <span class="hljs-number"><span class="hljs-number">1</span></span>; $a = $a + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $a <span class="hljs-comment"><span class="hljs-comment">// 4</span></span></code> </pre><br><pre> <code class="php hljs">Testcase Context example changes $argument1, $argument2 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $argument3 <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $a = <span class="hljs-string"><span class="hljs-string">"changed"</span></span> let $b = <span class="hljs-string"><span class="hljs-string">"changed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $c = <span class="hljs-string"><span class="hljs-string">"changed"</span></span> import $i let $i = <span class="hljs-string"><span class="hljs-string">"changed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $argument1 = <span class="hljs-string"><span class="hljs-string">"changed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $argument2 = <span class="hljs-string"><span class="hljs-string">"changed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $argument3 = <span class="hljs-string"><span class="hljs-string">"changed"</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,     var $a = "original" var $b = "original" var $i = "original" const $c = "original"; var $paramByRef = "original" var $paramByVal = "original" const $paramConst = "original" run Context example changes $paramByRef, {$paramByVal} and $paramConst //  $a     - print $a // "original" // $b     -,  let    $b print $b // "changed" // $i      print $i // "original" //      ,  var   print $c // "original" //     print $paramByRef // "changed" //     print $paramByVal // "original" //     ,     print $paramConst // "original"</span></span></code> </pre><br><a name="types"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 类型系统和操作 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用宽松的动态类型。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值存储在对应的PHP类型的包装器中。为了更好的理解，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请参见</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PHP类型系统。动态类型转换的自由度有所降低。例如，当添加一个字符串和一个数字时</font></font><code>"2" + 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将产生一个错误，PHP将安静地执行添加。也许将来我将需要修改动态类型的规则，但是到目前为止，我已经尝试在可靠测试所需的便利性和严格性之间找到平衡。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PieceofScript中可用的数据类型：</font></font><br><br> <b><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个数字。为简单起见，我没有为Integer和Float分别创建类型。 PieceofScript中整数和实数之间唯一的显着差异是使用数组作为键：实数将四舍五入为整数。</font></font><br> <code>7 -42 3.14159</code> <br> <br> <b><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -用双引号括起来的字符串，可以用斜杠转义</font></font><br> <code>"I say \"Hello world!\""</code> <br> <br> <b><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null-</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由不区分大小写的常量设置</font></font><br> <code>null</code> <br> <br> <b><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boolean-</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是布尔运算和比较操作的结果，由不区分大小写的常量</font></font><br> <code>true false</code> <br> <br> <b><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Date-</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日期和时间设置。 “内幕”是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DateTime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。常数以单引号指定，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式之一</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br> <code>'now', '2008-08-07 18:11:31', 'last day of next month'</code> <br> <br> <b><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个数组，唯一的非标量类型。结束</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该阵列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">没有这种类型的文字，但是数组可以是生成器，内置函数（例如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -hello PHP 5.3及以下版本）的工作结果，或者您可以简单地访问在赋值后将动态创建的变量键。</font></font><br><br><pre> <code class="plaintext hljs">let $a.1 = 100 let $i = 1 let $a[$i + 1] = 200 let $a.sum = $a.1 + $a.2 print " "; $a.sum //  300 var $b = array(true, 3, $a, "Hi") // [true, 3, {1: 100, 2: 200, "sum":300}, "Hi"]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当访问不存在的变量或数组元素时，测试脚本将停止并生成错误。</font><font style="vertical-align: inherit;">但是，当执行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">语句时</font></i><font style="vertical-align: inherit;">，如果访问了不存在的变量，则不会有错误，但是检查将被视为失败。</font></font><br><br><a name="var_exists"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 检查变量的存在和类型 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们必须单独提及检查变量</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的存在和类型的构造</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在变量名中</font><font style="vertical-align: inherit;">指定</font><i><font style="vertical-align: inherit;">@</font></i><font style="vertical-align: inherit;">而不是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则此构造的结果将是以下之一：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一个字符串，其名称为变量类型或数组元素的类型（如果使用键）； </font></font></li><li> <i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在可访问的上下文中找不到变量，或者数组中具有指定键的元素不存在，则返回</font><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当检查HTTP响应的结构时，此设计可能很有用。 </font></font><br><br><pre> <code class="plaintext hljs">var $a.string_field = "Hello World" var $a.number_field = 3.14 var $a.bool_field = true var $a.date_field = '+1 day' var $a.null_field = null var $a.array_field = array(1, "2") assert @a.string_field == "String" assert @a.number_field == "Number" assert @a.bool_field == "Boolean" assert @a.date_field == "Date" assert @a.null_field == "Null" assert @a.array_field == "Array" assert @a.array_field.0 == "Number" assert @a.array_field.1 == "String" assert @a.array_field.2 == null assert @notExistedVar == null</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 或在类似的结构中： </font></font><br><br><pre> <code class="php hljs">assert @comment.optional_field &amp;&amp; $comment.optional_field &gt; <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一个操作数上优化了布尔运算。</font><font style="vertical-align: inherit;">如果第一个操作数为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">甚至不会尝试计算第二个操作数。</font><font style="vertical-align: inherit;">与</font><i><font style="vertical-align: inherit;">||</font></i><font style="vertical-align: inherit;">类似</font></font><i><font style="vertical-align: inherit;"></font></i>  。 <br><br><a name="storage"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运行之间保存数据 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不仅在任务完成后用于测试，还在开发期间使用了单独的脚本。</font><font style="vertical-align: inherit;">实现该功能时，我对脚本进行了补充和更改。</font><font style="vertical-align: inherit;">后来，该脚本成为编写测试用例的基础，但是在开发过程中，必须一次又一次地进行相同的API调用。</font><font style="vertical-align: inherit;">同时，每次在脚本中都要花很长时间从头开始创建新实体（例如，用户注册），在数据库中创建垃圾，并且以各种方式干扰开发。</font><font style="vertical-align: inherit;">因此，我决定增加在键值存储中两次启动之间保存和恢复变量值的功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">--storage</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令行</font><i><font style="vertical-align: inherit;">选项</font></i><font style="vertical-align: inherit;">启用保存，该</font><i><font style="vertical-align: inherit;">选项</font></i><font style="vertical-align: inherit;">设置存储文件的名称：</font></font><br><br><pre> <code class="bash hljs">pos.phar run ./start.pos --storage=storage.yaml</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据以YAML格式保存，从而易于读取和编辑。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">storage \ get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（字符串$键，$ defaultValue，布尔值$ saveValue = true）-如果键$键不存在或未指定存储文件，则返回$ defaultValue。</font><font style="vertical-align: inherit;">否则，它将返回存储的值。</font><font style="vertical-align: inherit;">如果参数$ saveValue为true并且未找到键$ key，则将$ defaultValue写入那里。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">storage \ set</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（字符串$键，$值）-用键$键保存$值，并返回$值。</font><font style="vertical-align: inherit;">如果尚未设置存储文件，则仅返回$值。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储\键</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（字符串$ regexp = null）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-返回所有可用键的数组。</font><font style="vertical-align: inherit;">如果参数$ regexp不为null，则将返回与此正则表达式相对应的键。</font><font style="vertical-align: inherit;">如果尚未设置存储文件，它将返回一个空数组。</font></font><br><br><a name="output"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 输出到标准输出 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PieceofScript可以生成JUnit和HTML格式的报告。</font><font style="vertical-align: inherit;">首先需要与CI / CD系统集成，例如Jenkins。</font><font style="vertical-align: inherit;">第二个是方便自己查看测试结果，例如在本地测试时。</font><font style="vertical-align: inherit;">可以在启动时设置报告文件：</font></font><pre> <code class="bash hljs">pos.phar run ./start.pos --junit=junit_report.xml --html=report.html</code> </pre> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML报告的示例</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在stdout中显示有关解释器工作的各种信息。有5个标准级别的信息输出。在同一级别显示的所有内容也会在其他“健谈”的内容上显示。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安静</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -最“安静”的级别是通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令行选项设置的</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此级别上，没有任何东西输出到标准输出，甚至是关键的解释器错误。但是通过非零返回码，您可以了解出了问题。</font><font style="vertical-align: inherit;">默认级别是“ </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普通</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，不指定选项。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此级别上，解释器中会生成错误。对API方法的错误请求和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">断言</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失败</font><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行检查</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">详细</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -由选项设置</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-v</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此级别上，显示</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">print</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句的结果</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常详细</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -由</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-vv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项设置</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此级别，显示解释器警告。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-vvv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项设置</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此级别，将显示所有已执行的脚本行。</font><font style="vertical-align: inherit;">API方法的所有请求和答案，所有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结果</font><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查</font><font style="vertical-align: inherit;">。</font></font><br><br><a name="examples"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 例子 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谚语“看一次比听一百次更好”是正确的，在解释中，“看一次代码比读一百次代码更好”。</font><font style="vertical-align: inherit;">我准备了示例并将其放在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/maximw/PosExamples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储库中</font><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 病毒总数 </font></font></h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virustotal.com-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于检查恶意文件和链接的服务。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">除了注释方法外，针对API的公共部分进行了测试，因为 </font><font style="vertical-align: inherit;">我不想乱扔带有测试数据的真正“战斗” API。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要访问API，您需要</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，获取密钥并将其添加到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virustotal / globals.pos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行测试：</font></font><br><br><pre> <code class="bash hljs">pos.phar run ./Virustotal/start.pos</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">车上有一个exe-shnik存放在存储库中吗？</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了进行测试，我从Symfony存储库的Console组件复制了hiddeninput.exe。</font><font style="vertical-align: inherit;">可以删除此文件，并且为了进行测试，请使用其他最大32 mb的文件。</font></font><br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 糕点店 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasebin类似物。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要访问API，您需要</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，获取密钥并将其添加到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pastery / globals.pos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件中</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行测试：</font></font><br><br><pre> <code class="bash hljs">pos.phar run ./Pastery/start.pos</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得注意的是，通过这些测试，在视图数量的限制中发现了一个错误。</font><font style="vertical-align: inherit;">Pastery </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发人员</font><font style="vertical-align: inherit;">已经</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">修复了该</font></a><font style="vertical-align: inherit;">问题。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 里克与弗洛里 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为这个动画系列广为人知，并为许多人所喜爱。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">API由三个几乎相同的部分组成，分别是角色，位置和情节。</font><font style="vertical-align: inherit;">因此，方案几乎是相同的，仅查看测试用例只是这些部分之一。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行测试：</font></font><br><br><pre> <code class="bash hljs">pos.phar run ./RickAndMorty/20MinutesTest.pos</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果您知道以这种方式进行测试很有趣的公共API，请写一封个人电子邮件。 </font></font><br><br><a name="plans"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 未来的评论和计划（如果有） </font></font></h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我列出了一些我不需要的小改进和大改进，但它们很有用。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看清单</font></font></b> <div class="spoiler_text"><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 添加有关Json格式的工作的报告，可能会在运行多个脚本后覆盖 </font></font></li><li>        <i>body</i>   <i>replace</i>  <i>remove</i> </li><li>         ,         YAML </li><li>     HTTP-    ,        </li><li>     ,     <i>run</i>  .  . </li><li>   HTML-     stdout,       -vvv </li><li>        https </li><li>       application/x-www-form-urlencoded   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CURLFile</a> .        Guzzle 6,       </li><li>        « »,           </li><li>       API,             </li><li>  HTML-,         bootstrap- «  »,     . </li></ul></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使用生成器在API响应中验证模型，到目前为止只有两个函数- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相似（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。与他们的验证太“笨拙”。当然，已经可以“手动”验证答案了，在某些情况下，这是不可能的，但是我想使其更方便，并且在可能的情况下，避免手动检查答案。关于如何使用相同的模型描述来生成和验证模型，有一些想法，以避免重复。但是到目前为止，这些想法还不够成熟，因此您无法在代码中实现它们。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为基于OpenAPI（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swagger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAML</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和集合中的</font><font style="vertical-align: inherit;">描述的API方法的脚手架将非常有用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">邮差</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，如果PieofofScript值得，那么很多工作值得坐下来。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最好为某些IDE制作插件，并突出显示代码并自动完成。自动完成测试用例名称，API方法，运算符和变量将非常方便。但是他还没有朝这个方向“挖”。了解Sublime Text和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Language Server协议的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建突出显示</font><font style="vertical-align: inherit;">。如果已经有志趣相投的人精通此类事情，我将感到高兴。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不知道将创建动态连接</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">功能</font></a><font style="vertical-align: inherit;">的能力放在什么优先级</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用PHP实现。一方面，那里的一切都很简单，足以应付自动加载并为所使用的类和名称空间指定规格。另一方面，复杂函数及其依赖关系将不可避免地导致依赖关系之间的命名空间冲突（在最坏的情况下，是不同的版本）。还有一些事情要考虑。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好的测试系统可以并行运行独立的测试。现在，可以通过使用不同的开始文件（连接了不同的测试用例）多次启动解释器来完成此操作。但是我认为我们需要将此功能嵌入到解释器中，并自动检测可以并行启动的功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS一方面，由于这是我的“手工艺品”，因此在中心“我是PR”中张贴帖子是合乎逻辑的。</font><font style="vertical-align: inherit;">另一方面，我不公关，不追求任何商业利益，只是我自己为自己创造的一种工具，我决定“梳理”并公开发布。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430392/">https://habr.com/ru/post/zh-CN430392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430380/index.html">JavaScript指南第5部分：数组和循环</a></li>
<li><a href="../zh-CN430382/index.html">JavaScript指南第4部分：功能</a></li>
<li><a href="../zh-CN430384/index.html">根据噪声特征创建地图</a></li>
<li><a href="../zh-CN430386/index.html">印度将建设固态存储电站</a></li>
<li><a href="../zh-CN430388/index.html">网络峰会非会议</a></li>
<li><a href="../zh-CN430394/index.html">使用RxJava在Android中实现即时搜索</a></li>
<li><a href="../zh-CN430396/index.html">链复制：构建有效的KV存储库（第1/2部分）</a></li>
<li><a href="../zh-CN430398/index.html">如何理解不受欢迎的人或讨论将员工挤出公司的方法</a></li>
<li><a href="../zh-CN430400/index.html">编程中使用键盘和鼠标混合体的经验</a></li>
<li><a href="../zh-CN430402/index.html">关于RecyclerView，developer.android.com沉默了什么？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>