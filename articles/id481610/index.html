<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèΩ ü§≥ üíª PostgreSQL Antipatterns: memperbarui tabel besar yang sedang dimuat üëÇüèæ ü§πüèª üë©üèª‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang harus saya lakukan (dan jelas tidak) jika Anda perlu memperbarui sejumlah besar catatan dalam tabel PostgreSQL "multi-juta" yang digunakan se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL Antipatterns: memperbarui tabel besar yang sedang dimuat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/481610/">  Apa yang harus saya lakukan (dan jelas tidak) jika Anda perlu <b>memperbarui sejumlah besar catatan</b> dalam tabel PostgreSQL "multi-juta" yang digunakan secara aktif - menginisialisasi nilai bidang baru atau memperbaiki kesalahan dalam catatan yang ada?  Dan pada saat yang sama menghemat waktu Anda dan tidak kehilangan uang perusahaan karena downtime. <br><br><img src="https://habrastorage.org/webt/vw/8_/jj/vw8_jjubp0owqcielxtg6gjufng.png"><br><a name="habracut"></a><br>  Siapkan data uji: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl(k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, v <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">chr</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ascii</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) + (random() * <span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) k , (random() * <span class="hljs-number"><span class="hljs-number">100</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) i; <span class="hljs-comment"><span class="hljs-comment">--  ,   ! CREATE INDEX ON tbl(k, v);</span></span></code> </pre> <br>  Misalkan kita hanya ingin meningkatkan nilai v dengan 1 untuk semua catatan dengan k dalam kisaran 'q' .. 'z'. <br><br>  Tetapi, sebelum memulai eksperimen, kami akan menyimpan set data asli agar mendapatkan hasil "bersih" setiap kali: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tbl <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl;</code> </pre> <br><h2>  UPDATE: satu untuk semua, dan semua untuk satu </h2><br>  Opsi termudah yang langsung terlintas dalam pikiran adalah melakukan segala sesuatu "dalam satu PEMBARUAN": <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = v + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/zs/0h/nb/zs0hnbsdmvjrctxn_wkia0wr6oy.png"><br>  <a href="https://explain.tensor.ru/archive/explain/197f26d0cedf3abba51a15d4650c897e:0:2019-12-23">[lihat menjelaskan.tensor.ru]</a> <br><br>  Tampaknya, operasi yang agak sederhana, pada garis yang sepenuhnya "pendek" memerlukan waktu lebih dari 2,5 detik.  Dan jika ekspresi Anda lebih rumit, garis lebih otentik, ada lebih banyak catatan, dan bahkan beberapa pemicu campur tangan - waktu dapat meningkat bahkan hingga menit, tetapi hingga jam.  Misalkan Anda siap menunggu, dan seluruh sistem Anda, terikat pada basis ini, jika memiliki beban OLTP aktif? <br><br>  Masalahnya adalah bahwa begitu UPDATE mendapatkan catatan tertentu, ia <b>memblokirnya sampai akhir eksekusi</b> .  Jika secara bersamaan dengan catatan yang sama ia ingin mengerjakan UPDATE "spot" yang diluncurkan secara parallelly, ia masih akan <b>"mengait" saat menunggu blok</b> untuk permintaan pembaruan, dan akan melorot hingga akhir pekerjaannya. <br><br><img src="https://habrastorage.org/webt/p7/gx/qu/p7gxqutnt9o8zuwiwjlbmrf4fk8.png"><br>  ¬© <a href="http://wumo.com/wumo">wumo.com/wumo</a> <br><br>  Skenario kasus terburuk adalah sistem web, di mana koneksi ke database dibuat sesuai kebutuhan - setelah semua, koneksi "menggantung" seperti itu menumpuk dan akan menghabiskan sumber daya baik dari database dan klien jika Anda tidak membuat mekanisme pertahanan terpisah dari ini. <br><br><h2>  Transaksi terpisah </h2><br>  Secara umum, semuanya tidak terlalu baik jika semuanya dilakukan dalam satu permintaan.  Ya, dan bahkan jika kami membagi satu UPDATE besar menjadi beberapa yang kecil, tetapi membiarkan semuanya bekerja <b>dalam satu transaksi</b> , masalah dengan penguncian akan tetap sama, karena catatan yang dapat diubah dikunci hingga akhir seluruh transaksi. <br><br>  Jadi, kita perlu membagi satu transaksi besar menjadi beberapa.  Untuk melakukan ini, kita dapat menggunakan sarana eksternal dan menulis semacam skrip yang menghasilkan transaksi terpisah, atau menggunakan peluang yang dapat disediakan oleh basis data itu sendiri. <br><br><h4>  PANGGILAN dan manajemen transaksi </h4><br>  Dimulai dengan PostgreSQL 11, <a href="https://postgrespro.ru/docs/postgresql/11/plpgsql-transactions">dimungkinkan untuk mengelola transaksi</a> tepat di dalam kode prosedural: <br><blockquote>  Dalam prosedur yang disebut oleh perintah CALL, serta dalam blok kode anonim (dalam perintah DO), Anda dapat menyelesaikan transaksi dengan mengeksekusi COMMIT dan ROLLBACK.  Setelah transaksi selesai dengan perintah-perintah ini, yang baru akan dimulai secara otomatis. </blockquote>  Tetapi versi ini jauh dari semua orang, dan bekerja dengan CALL memiliki keterbatasan.  Oleh karena itu, kami akan mencoba menyelesaikan masalah kami tanpa cara eksternal, dan agar dapat berfungsi pada semua versi saat ini, dan bahkan dengan perubahan minimal pada server itu sendiri - sehingga tidak perlu untuk mengkompilasi dan memulai kembali apa pun. <br><br>  Untuk alasan yang sama, kami tidak akan mempertimbangkan opsi untuk mengatur <a href="https://blog.dalibo.com/2016/08/19/Autonoumous_transactions_support_in_PostgreSQL.html">transaksi otonom melalui pg_background</a> . <br><br><h4>  Mengelola koneksi "di dalam" pangkalan </h4><br>  PostgreSQL secara historis menggunakan metode yang berbeda untuk <a href="https://www.cybertec-postgresql.com/en/implementing-autonomous-transactions-in-postgres/">meniru transaksi otonom</a> , menghasilkan koneksi tambahan yang terpisah - melalui bahasa prosedural tambahan atau <a href="https://postgrespro.ru/docs/postgresql/12/dblink">modul dblink</a> standar.  Keuntungan dari yang terakhir adalah bahwa secara default itu termasuk dalam sebagian besar distribusi, dan hanya satu perintah yang diperlukan untuk mengaktifkannya dalam database: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION dblink;</code> </pre> <br><h2>  "... dan banyak, banyak anak-anak menjijikkan yang dibawa" </h2><br>  Tetapi sebelum membuat pengikatan dblink, pertama mari kita mencari tahu bagaimana "pengembang reguler" memecah dataset besar, yang perlu dia perbarui, menjadi yang kecil. <br><br><h3>  BATAS naif ... OFFSET </h3><br>  Gagasan pertama adalah melakukan pencarian "pagination": <i>"Ayo pilih <b>seribu catatan berikutnya</b> setiap kali"</i> dengan meningkatkan OFFSET dalam setiap permintaan baru: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k , v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-comment"><span class="hljs-comment">--       k, v --     ! LIMIT $1 OFFSET $2 * $1 ) S WHERE (Tk, Tv) = (Sk, Sv);</span></span></code> </pre> <br>  Sebelum menguji kinerja solusi ini, kami akan mengembalikan dataset: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tbl;</code> </pre> <br>  Seperti yang kita lihat dalam rencana di atas, kita perlu memperbarui sekitar 384K catatan.  Oleh karena itu, mari kita segera melihat bagaimana pembaruan akan dilakukan lebih dekat sampai akhir - <b>di wilayah iterasi 300 dari 1000 entri</b> : <br><br><img src="https://habrastorage.org/webt/j8/h3/ju/j8h3juddfyiwgyg6nxe4yjmp5w4.png"><br>  <a href="https://explain.tensor.ru/archive/explain/922c49ce866d7c879d15c7d144efff86:0:2019-12-23">[lihat menjelaskan.tensor.ru]</a> <br><br>  Oh ... Memutakhirkan sampel pada akhir <b>seluruh catatan 1K</b> akan dikenakan biaya hampir sebanyak waktu <b>seluruh versi asli</b> ! <br><br>  Ini bukan pilihan kita.  Itu masih bisa digunakan entah bagaimana jika Anda mendapatkan beberapa iterasi dan nilai OFFSET kecil.  Karena <b>LIMIT X OFFSET Y</b> untuk database setara dengan " <i>kurangi / pilih / bentuk catatan X + Y pertama, dan kemudian lemparkan Y pertama ke tempat sampah</i> ", yang untuk nilai besar Y terlihat tragis. <br><br>  Sebenarnya, metode <b>ini tidak dapat diterapkan sama sekali</b> !  Kami tidak hanya mengandalkan nilai yang diperbarui untuk pemilihan, kami juga berisiko melewatkan bagian dari catatan, dan memperbarui bagian lainnya dua kali jika blok dengan kunci yang sama sampai ke batas halaman: <br><br><img src="https://habrastorage.org/webt/v0/kh/mn/v0khmnh_afkafan4fvvf4sfgq34.png"><br>  Dalam contoh ini, kami memperbarui catatan hijau dua kali, dan catatan merah tidak pernah.  Hanya karena dengan nilai yang sama dari kunci pengurutan, urutan catatan itu sendiri di dalam blok semacam itu tidak diperbaiki. <br><br><h3>  ORDER Sedih DENGAN ... BATAS </h3><br>  Mari kita sedikit memodifikasi tugas - tambahkan bidang baru di mana kita akan menulis nilai kita v + 1: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> x <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>;</code> </pre> <br>  Harap dicatat bahwa desain ini bekerja hampir secara instan, tanpa menulis ulang seluruh tabel.  Tetapi jika Anda menambahkan nilai DEFAULT, maka - hanya <a href="https://www.depesz.com/2018/04/04/waiting-for-postgresql-11-fast-alter-table-add-column-with-a-non-null-default/">dari versi ke-11</a> . <br><br>  Sudah diajarkan oleh pengalaman pahit, mari kita segera membuat indeks di mana hanya entri yang tidak diinisialisasi yang akan tetap: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> CONCURRENTLY <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl(k, v) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  Indeks CONCURRENTLY tidak memblokir pekerjaan baca-tulis dengan tabel, sementara itu perlahan-lahan bergulir bahkan ke dataset besar. <br><br>  Sekarang idenya adalah <i>"Mari kita pilih dari indeks ini setiap kali <b>hanya seribu catatan pertama</b> "</i> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-comment"><span class="hljs-comment">--   OFFSET! ) S WHERE (Tk, Tv) = (Sk, Sv) AND Tx IS NULL;</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ne/dp/ck/nedpck-lvoeexx1ffpb63v8nd1w.png"><br>  <a href="https://explain.tensor.ru/archive/explain/9a152e5f94595f995599c9c558fc6f37:0:2019-12-23">[lihat menjelaskan.tensor.ru]</a> <br><br>  Sudah jauh lebih baik - durasi setiap transaksi individu sekarang lebih pendek sekitar 6 kali. <br><br>  Tapi mari kita lihat lagi apa rencana iterasi ke-200 akan berubah menjadi: <br><br><pre> <code class="plaintext hljs">Update on tbl t (actual time=530.591..530.591 rows=0 loops=1) Buffers: shared hit=789337 read=1 dirtied=1</code> </pre> <br>  Waktu semakin memburuk lagi (hanya 25%), dan buffer meningkat - tetapi mengapa? <br>  Faktanya adalah bahwa <a href="https://habr.com/ru/company/postgrespro/blog/445820/">MVCC di PostgreSQL</a> meninggalkan "dead souls" dalam indeks - versi dari catatan yang sudah diperbarui, sekarang tidak lagi cocok untuk indeks.  Artinya, dengan hanya mengambil 1000 catatan pertama pada iterasi ke-200, kami <b>masih memindai</b> , meskipun kemudian kami buang, versi 199K tupel sebelumnya sudah berubah. <br><br>  Jika iterasi pada kami diperlukan bukan beberapa ratus, tetapi beberapa ratus ribu, maka degradasi akan lebih terlihat dengan setiap eksekusi permintaan berikutnya. <br><br><h2>  DIPERBARUI menurut segmen </h2><br>  Sebenarnya, mengapa kita begitu terikat pada nilai "1000 rekaman" ini?  Lagi pula, kami <b>tidak memiliki alasan untuk memilih tepat 1000</b> atau nomor tertentu lainnya.  Kami hanya ingin hanya "memotong" seluruh dataset menjadi beberapa, tidak harus sama, <b>segmen terpisah</b> - jadi mari kita gunakan indeks kami untuk tujuan yang dimaksudkan. <br><br>  <b>Pasangan yang diindeks (k, v) sangat</b> baik untuk tugas kita.  Mari kita membangun kueri sehingga dapat membangun pada pasangan yang diproses terakhir: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> kv <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (k, v) &gt; ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) , upd <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (Tk, Tv) = (<span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> kv) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Tx <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> k, v ) <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> upd <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Pada iterasi pertama, cukup bagi kita untuk mengatur parameter kueri ke nilai <b>"nol" ('', 0)</b> , dan untuk setiap iterasi berikutnya kita mengambil <b>hasil dari kueri sebelumnya</b> . <br><br><img src="https://habrastorage.org/webt/ok/ea/fg/okeafgsqia7iejthcmz2wuvsnm0.png"><br>  <a href="https://explain.tensor.ru/archive/explain/2e6ac5867caa6be474c3845dcb7eebcb:0:2019-12-23">[lihat menjelaskan.tensor.ru]</a> <br><br>  Waktu transaksi / kunci kurang dari satu milidetik, tidak ada degradasi dari jumlah iterasi, pemindaian awal penuh dari semua data dalam tabel tidak diperlukan.  Hebat! <br><br><div class="spoiler">  <b class="spoiler_title">Puting versi final dengan dblink</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; v integer = 0; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> PERFORM dblink_connect(<span class="hljs-string"><span class="hljs-string">'dbname='</span></span> || current_database() || <span class="hljs-string"><span class="hljs-string">' port='</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">--  PREPARED STATEMENT,      PERFORM dblink($q$ PREPARE _q(text, integer) AS WITH kv AS ( SELECT k, v FROM tbl WHERE (k, v) &gt; ($1, $2) AND k BETWEEN 'q' AND 'z' AND x IS NULL ORDER BY k, v LIMIT 1 ) , upd AS ( UPDATE tbl T SET x = Tv + 1 WHERE (Tk, Tv) = (TABLE kv) AND Tx IS NULL RETURNING k, v ) TABLE upd LIMIT 1; $q$); -- ,    LOOP SELECT * INTO k, v FROM dblink($p$EXECUTE _q('$p$ || k || $p$',$p$ || v || $p$)$p$) T(k text, v integer); RAISE NOTICE '(k,v) = (''%'',%)', k, v; --   ,     EXIT WHEN (k, v) IS NULL; END LOOP; PERFORM dblink_disconnect(); END; $$ LANGUAGE plpgsql;</span></span></code> </pre> <br></div></div><br>  Keuntungan tambahan dari metode ini adalah kemampuan untuk menghentikan eksekusi skrip ini kapan saja, dan kemudian melanjutkan dari titik yang diinginkan. <br><br><h2>  Perhitungan kompleks dalam UPDATE </h2><br>  Saya akan menyebutkan situasi secara terpisah dengan perhitungan sulit dari nilai yang diberikan - ketika Anda perlu menghitung sesuatu dari tabel tertaut. <br><br>  Waktu yang dihabiskan untuk komputasi juga meningkatkan durasi transaksi.  Oleh karena itu, opsi terbaik adalah <b>mengambil proses penghitungan nilai-nilai ini di</b> luar UPDATE. <br><br>  Misalnya, kami ingin mengisi bidang baru x dengan jumlah catatan yang memiliki nilai yang sama (k, v).  Mari kita buat tabel "sementara", yang generasinya tidak memaksakan kunci tambahan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tmp <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) x <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tmp(k, v);</code> </pre> <br>  Sekarang kita dapat mengulangi sesuai dengan model yang dijelaskan di atas sesuai dengan tabel ini, memperbarui target: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Sx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tmp S <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (Tk, Tv) = (Sk, Sv) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (Sk, Sv) = ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Seperti yang Anda lihat, tidak diperlukan perhitungan yang rumit. <br><br>  Hanya ingat untuk menghapus tabel tambahan nanti. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481610/">https://habr.com/ru/post/id481610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481596/index.html">Parsing ELK 7.5 pengaturan untuk analisis log Mikrotik</a></li>
<li><a href="../id481598/index.html">Kontribusi kecil untuk perang melawan platform kebun binatang UI Avalonia</a></li>
<li><a href="../id481600/index.html">Mesin Wiki Keluarga Bonsai: Hasil 2019</a></li>
<li><a href="../id481604/index.html">Bagaimana pengembang Chelyabinsk keras membuat game untuk Google Play dan jejaring sosial</a></li>
<li><a href="../id481606/index.html">Berlangganan statis menggunakan template Pengamat menggunakan C ++ dan mikrokontroler Cortex M4</a></li>
<li><a href="../id481612/index.html">Kontribusi Kecil Kami untuk Platform Avalonia UI's Fight for Fewer</a></li>
<li><a href="../id481616/index.html">Kubah geodesik. Tentang perangkat dan pengalaman perhitungan saya</a></li>
<li><a href="../id481618/index.html">MVP di Unity atau cara menyederhanakan hidup</a></li>
<li><a href="../id481620/index.html">Juniper SRX dan Cisco ASA: Next Series</a></li>
<li><a href="../id481624/index.html">Kami menulis aplikasi di Flutter bersama dengan Redux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>