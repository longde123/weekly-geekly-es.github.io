<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîº ü•¶ üßõüèΩ Was passiert hinter den Kulissen in C #: die Grundlagen der Arbeit mit dem Stack üçº üïò ü¶é</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich schlage vor, alles zu betrachten, was hinter einfachen Zeilen zum Initialisieren von Objekten, Aufrufen von Methoden und √úbergeben von Parametern ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was passiert hinter den Kulissen in C #: die Grundlagen der Arbeit mit dem Stack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427465/">  Ich schlage vor, alles zu betrachten, was hinter einfachen Zeilen zum Initialisieren von Objekten, Aufrufen von Methoden und √úbergeben von Parametern steht.  Die Verwendung dieser Informationen in der Praxis subtrahiert nat√ºrlich den Stapel der aufrufenden Methode. <br><br><h3>  Haftungsausschluss </h3><br>  Bevor Sie mit der Geschichte beginnen, empfehle ich dringend, dass Sie den ersten Beitrag √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StructLayout lesen</a> , weil  In diesem Artikel wird ein Beispiel verwendet. <br><br>  Der gesamte Code hinter der h√∂heren Ebene wird f√ºr den <b>Debugging-</b> Modus dargestellt. Er ist es, der die konzeptionelle Basis zeigt.  All dies wird auch f√ºr eine 32-Bit-Plattform ber√ºcksichtigt.  Die JIT-Optimierung ist ein separates und gro√ües Thema, das hier nicht ber√ºcksichtigt wird. <br><br>  Ich m√∂chte auch warnen, dass dieser Artikel kein Material enth√§lt, das in realen Projekten verwendet werden sollte. <br><br><h3>  Beginnen Sie mit der Theorie </h3><br>  Jeder Code wird letztendlich zu einer Reihe von Maschinenbefehlen.  Am verst√§ndlichsten ist ihre Darstellung in Form von Assembler-Anweisungen, die direkt einer (oder mehreren) Maschinenanweisungen entsprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ya/yv/k7/yayvk7f2o3tfr5flwaybim4u1m8.jpeg"></div><a name="habracut"></a><br>  Bevor Sie zu einem einfachen Beispiel √ºbergehen, empfehlen wir Ihnen, sich mit einem Software-Stack vertraut zu machen.  <b>Der Software-Stack</b> ist in erster Linie ein Speicher, der in der Regel zum Speichern verschiedener Arten von Daten verwendet wird (in der Regel k√∂nnen sie als <i>tempor√§re Daten bezeichnet werden</i> ).  Es ist auch zu beachten, dass der Stapel in Richtung niedrigerer Adressen w√§chst.  Das hei√üt, je sp√§ter das Objekt auf den Stapel geschoben wird, desto geringer ist seine Adresse. <br><br>  Schauen wir uns nun den n√§chsten Code in Assembler-Sprache an (ich habe einige der Aufrufe weggelassen, die dem Debug-Modus inh√§rent sind). <br><br>  C #: <br><br><pre><code class="plaintext hljs">public class StubClass { public static int StubMethod(int fromEcx, int fromEdx, int fromStack) { int local = 5; return local + fromEcx + fromEdx + fromStack; } public static void CallingMethod() { int local1 = 7, local2 = 8, local3 = 9; int result = StubMethod(local1, local2, local3); } }</code> </pre> <br>  Asm: <br><br><pre> <code class="plaintext hljs">StubClass.StubMethod(Int32, Int32, Int32) 1: push ebp 2: mov ebp, esp 3: sub esp, 0x10 4: mov [ebp-0x4], ecx 5: mov [ebp-0x8], edx 6: xor edx, edx 7: mov [ebp-0xc], edx 8: xor edx, edx 9: mov [ebp-0x10], edx 10: nop 11: mov dword [ebp-0xc], 0x5 12: mov eax, [ebp-0xc] 13: add eax, [ebp-0x4] 14: add eax, [ebp-0x8] 15: add eax, [ebp+0x8] 16: mov [ebp-0x10], eax 17: mov eax, [ebp-0x10] 18: mov esp, ebp 19: pop ebp 20: ret 0x4 StubClass.CallingMethod() 1: push ebp 2: mov ebp, esp 3: sub esp, 0x14 4: xor eax, eax 5: mov [ebp-0x14], eax 6: xor edx, edx 7: mov [ebp-0xc], edx 8: xor edx, edx 9: mov [ebp-0x8], edx 10: xor edx, edx 11: mov [ebp-0x4], edx 12: xor edx, edx 13: mov [ebp-0x10], edx 14: nop 15: mov dword [ebp-0x4], 0x7 16: mov dword [ebp-0x8], 0x8 17: mov dword [ebp-0xc], 0x9 18: push dword [ebp-0xc] 19: mov ecx, [ebp-0x4] 20: mov edx, [ebp-0x8] 21: call StubClass.StubMethod(Int32, Int32, Int32) 22: mov [ebp-0x14], eax 23: mov eax, [ebp-0x14] 24: mov [ebp-0x10], eax 25: nop 26: mov esp, ebp 27: pop ebp 28: ret</code> </pre><br>  Das erste, worauf Sie achten sollten, sind die <b>EBP-</b> und <b>ESP-</b> Register und Operationen mit ihnen. <br><br>  Ein Missverst√§ndnis unter meinen Freunden ist, dass das <b>EBP-</b> Register irgendwie mit einem Zeiger auf den oberen Rand des Stapels zusammenh√§ngt.  Ich muss sagen, dass das nicht so ist. <br><br>  Das <b>ESP-</b> Register ist f√ºr den Zeiger auf die Oberseite des Stapels verantwortlich.  Dementsprechend wird mit jedem <b>PUSH-Befehl</b> (der den Wert oben auf dem Stapel platziert) der Wert dieses Registers dekrementiert (der Stapel w√§chst zu niedrigeren Adressen hin) und mit jeder <b>POP-</b> Operation erh√∂ht er sich.  Der Befehl <b>CALL</b> schiebt auch die R√ºcksprungadresse auf den Stapel, wodurch auch der Wert des <b>ESP-</b> Registers verringert wird.  Tats√§chlich wird das √Ñndern des <b>ESP-</b> Registers nicht nur ausgef√ºhrt, wenn diese Anweisungen ausgef√ºhrt werden (wenn beispielsweise Interrupt-Aufrufe ausgef√ºhrt werden, geschieht dasselbe, wenn die <b>CALL-</b> Anweisungen ausgef√ºhrt werden). <br><br>  Betrachten Sie StubMethod. <br><br>  In der ersten Zeile wird der Inhalt des <b>EBP-</b> Registers gespeichert (auf den Stapel geschoben).  Vor der R√ºckkehr von der Funktion wird dieser Wert wiederhergestellt. <br><br>  In der zweiten Zeile wird der aktuelle Wert oben in der <b>Stapeladresse</b> gespeichert (der Wert des <b>ESP-</b> Registers wird in <b>EBP</b> eingegeben).  In diesem Fall ist das <b>EBP-</b> Register im Kontext des aktuellen Aufrufs eine Art Null.  Die Adressierung erfolgt relativ dazu.  Als n√§chstes verschieben wir den oberen Rand des Stapels an so viele Positionen, wie wir zum Speichern lokaler Variablen und Parameter ben√∂tigen (dritte Zeile).  So etwas wie das Zuweisen von Speicher f√ºr alle lokalen Anforderungen. <br><br>  All dies wird als Prologfunktion bezeichnet. <br><br>  Danach erfolgt der Zugriff auf die Variablen auf dem Stapel √ºber das gespeicherte <b>EBP</b> , das den Ort angibt, an dem die Variablen dieser bestimmten Methode beginnen. <br>  Als n√§chstes folgt die Initialisierung lokaler Variablen. <br><br>  Erinnerung an <i>Fastcall</i> : Das native .net verwendet die <i>Fastcall-</i> Aufrufkonvention. <br>  Die Vereinbarung regelt den Ort und die Reihenfolge der an die Funktion √ºbergebenen Parameter. <br>  Beim <i>Fastcall werden der</i> erste und der zweite Parameter durch die <b>ECX-</b> bzw. <b>EDX-</b> Register geleitet, und die nachfolgenden Parameter werden durch den Stapel geleitet. <br><br>  Bei nicht statischen Methoden ist der erste Parameter implizit und enth√§lt die Adresse des Objekts, f√ºr das die Methode aufgerufen wird (Adresse this). <br><br>  In den Zeilen 4 und 5 werden die Parameter, die √ºber die Register (die ersten 2) √ºbertragen wurden, auf dem Stapel gespeichert. <br><br>  Als N√§chstes wird der Stapelspeicher f√ºr lokale Variablen bereinigt und lokale Variablen initialisiert. <br><br>  Es sei daran erinnert, dass sich das Ergebnis der Funktion im <b>EAX-</b> Register befindet. <br><br>  In den Zeilen 12-16 werden die erforderlichen Variablen hinzugef√ºgt.  Ich mache Sie auf Zeile 15 aufmerksam. Es wird die Adresse aufgerufen, mehr als der Anfang des Stapels, dh der Stapel der vorherigen Methode.  Vor dem Aufruf verschiebt die aufrufende Methode den Parameter an den Anfang des Stapels.  Hier lesen wir es.  Das Ergebnis der Addition wird aus dem <b>EAX-</b> Register abgerufen und auf den Stapel geschoben.  Da dies der R√ºckgabewert von StubMethod ist, wird er erneut in <b>EAX platziert</b> .  Nat√ºrlich sind solche absurden Anweisungen nur im Debug-Modus enthalten, aber sie zeigen, wie unser Code ohne einen intelligenten Optimierer aussieht, der den L√∂wenanteil der Arbeit leistet. <br><br>  Die Zeilen 18 und 19 stellen das vorherige <b>EBP</b> (die aufrufende Methode) und den Zeiger auf den oberen Rand des Stapels (zum Zeitpunkt des Aufrufs der Methode) wieder her. <br><br>  Die letzte Zeile kehrt zur√ºck.  √úber den Wert 0x4 werde ich etwas niedriger berichten. <br>  Diese Befehlsfolge wird als Funktionsepilog bezeichnet. <br><br>  Schauen wir uns nun CallingMethod an.  Gehen wir direkt zu Zeile 18. Hier setzen wir den dritten Parameter oben auf den Stapel.  Bitte beachten Sie, dass wir dies mit der <b>PUSH-</b> Anweisung tun, <b>dh</b> der <b>ESP-</b> Wert wird dekrementiert.  Die anderen 2 Parameter werden in Registern <i>abgelegt</i> ( <i>Fastcall</i> ).  Als n√§chstes wird die StubMethod-Methode aufgerufen.  <b>Rufen Sie nun den</b> Befehl <b>RET 0x4 auf</b> .  Folgende Frage ist hier m√∂glich: Was ist 0x4?  Wie oben erw√§hnt, haben wir die Parameter der aufgerufenen Funktion auf den Stapel verschoben.  Aber jetzt brauchen wir sie nicht.  0x4 gibt an, dass das Byte nach dem Funktionsaufruf aus dem Stapel gel√∂scht werden muss.  Da es einen Parameter gab, m√ºssen Sie 4 Bytes l√∂schen. <br><br>  Hier ist ein Beispiel f√ºr ein Stapelbild: <br><br><img src="https://habrastorage.org/webt/vz/eo/vz/vzeovzr2rvkuetuzi4xyp4iuxye.png"><br><br>  Wenn wir uns also unmittelbar nach dem Aufrufen der Methode umdrehen und sehen, was sich auf der R√ºckseite des Stapels befindet, sehen wir als erstes das <b>EBP,</b> das auf den Stapel geschoben wird (tats√§chlich geschah dies in der ersten Zeile der aktuellen Methode).  Als n√§chstes gibt es eine R√ºcksprungadresse, die angibt, wo die Ausf√ºhrung fortgesetzt wird (wird von der <b>RET-</b> Anweisung verwendet).  Und durch diese Felder sehen wir die Parameter selbst der aktuellen Funktion (ab dem 3. werden die Parameter vorher durch die Register √ºbertragen).  Und dahinter steht der Stapel der aufrufenden Methode selbst! <br>  Das erw√§hnte erste und zweite Feld erl√§utern den Versatz bei + 0x8 unter Bezugnahme auf die Parameter. <br>  Dementsprechend m√ºssen die Parameter beim Aufrufen der Funktion in einer genau definierten Reihenfolge oben im Stapel liegen.  Daher wird vor dem Aufrufen der Methode jeder Parameter auf den Stapel verschoben. <br>  Aber was ist, wenn Sie sie nicht dr√ºcken und die Funktion sie weiterhin akzeptiert? <br><br><h3>  Ein kleines Beispiel </h3><br>  Alle oben genannten Fakten haben mich zu dem unwiderstehlichen Wunsch gemacht, den Stapel einer Methode zu lesen, die meine Funktion aufruft.  Der Gedanke, dass buchst√§blich an einer Stelle aus dem dritten Argument (es wird dem Stapel der aufrufenden Methode am n√§chsten sein) die gesch√§tzten Daten sind, die ich so sehr erhalten m√∂chte, lie√ü mich nicht schlafen. <br><br>  Um den Stapel der aufrufenden Methode zu lesen, muss ich also etwas weiter als bis zu den Parametern gehen. <br><br>  Bei der Bezugnahme auf Parameter basiert die Berechnung der Adresse eines Parameters nur auf der Tatsache, dass die aufrufende Methode sie alle auf den Stapel verschoben hat. <br><br>  Das implizite Durchlaufen des <b>EDX-</b> Parameters (wen interessiert das - der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzte Artikel</a> ) legt jedoch nahe, dass wir den Compiler in einigen F√§llen √ºberlisten k√∂nnen. <br><br>  Das Tool, mit dem ich das gemacht habe, hei√üt StructLayoutAttribute (Funktionen im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> ).  // Eines Tages werde ich etwas anderes als dieses Attribut lernen, das verspreche ich. <br><br>  Wir verwenden alle die gleiche Lieblingstechnik mit Referenztypen. <br><br>  Wenn die √ºberlappenden Methoden eine andere Anzahl von Parametern haben, wird gleichzeitig festgestellt, dass der Compiler die ben√∂tigten nicht auf den Stapel schiebt (wie der imagin√§re, weil er nicht wei√ü, welche). <br>  Die tats√§chlich aufgerufene Methode (mit demselben Versatz von einem anderen Typ) adressiert jedoch die Plusadressen relativ zu ihrem Stapel, dh diejenigen, bei denen die Parameter gesucht werden sollen. <br><br>  Aber dort findet er sie nicht und beginnt, den Stapel der aufrufenden Methode zu lesen. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System; using System.Runtime.InteropServices; namespace Magic { public class StubClass { public StubClass(int id) { Id = id; } public int Id; } [StructLayout(LayoutKind.Explicit)] public class CustomStructWithLayout { [FieldOffset(0)] public Test1 Test1; [FieldOffset(0)] public Test2 Test2; } public class Test1 { public virtual void Useless(int skipFastcall1, int skipFastcall2, StubClass adressOnStack) { adressOnStack.Id = 189; } } public class Test2 { public virtual int Useless() { return 888; } } class Program { static void Main() { Test2 objectWithLayout = new CustomStructWithLayout { Test2 = new Test2(), Test1 = new Test1() }.Test2; StubClass adressOnStack = new StubClass(3); objectWithLayout.Useless(); Console.WriteLine($"MAGIC - {adressOnStack.Id}"); // MAGIC - 189 } } }</code> </pre><br></div></div><br>  Ich werde den Assembler-Sprachcode nicht angeben, da ist alles ziemlich klar, aber wenn Sie Fragen haben, werde ich versuchen, diese in den Kommentaren zu beantworten <br><br>  Ich verstehe vollkommen, dass dieses Beispiel in der Praxis nicht verwendet werden kann, aber meiner Meinung nach kann es sehr n√ºtzlich sein, um das allgemeine Arbeitsschema zu verstehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427465/">https://habr.com/ru/post/de427465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427451/index.html">Verbinden Sie phpStorm-Tasks mit Bitrix24</a></li>
<li><a href="../de427453/index.html">Wie ich die Ton√ºbertragung auf dem Raspberry Pi gemacht habe</a></li>
<li><a href="../de427457/index.html">Die dritte Welle von KI und Systemen f√ºr die Staatssicherheit</a></li>
<li><a href="../de427459/index.html">Diall LED-Lampen aus dem Castorama Store</a></li>
<li><a href="../de427461/index.html">Die Sch√∂nheit NICHT anonymer Funktionen in JavaScript</a></li>
<li><a href="../de427467/index.html">Die k√ºrzeste Einf√ºhrung in die reaktive Programmierung</a></li>
<li><a href="../de427469/index.html">Umsatz und Gewinn von Elektronikherstellern oder mit mehr Marge</a></li>
<li><a href="../de427471/index.html">Mit LEGO EV3 entwickeln wir unbemannte Transportmittel in der High School</a></li>
<li><a href="../de427473/index.html">Welche Probleme der Teamf√ºhrung k√∂nnen mit Hilfe des Spiels gel√∂st werden</a></li>
<li><a href="../de427475/index.html">Android LiveData auf Kotlin mit Retrofit und Coroutinen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>