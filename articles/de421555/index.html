<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèΩ üêç ‚òùüèΩ WideNES-Projekt - Gehen Sie √ºber die Grenzen des NES-Bildschirms hinaus ‚ôâÔ∏è ‚öñÔ∏è üëãüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mitte der 1980er Jahre war das Nintendo Entertainment System (NES) ein Muss. Der beste Sound, die beste Grafik und die besten Spiele unter allen Konso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WideNES-Projekt - Gehen Sie √ºber die Grenzen des NES-Bildschirms hinaus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421555/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif" alt="Bild"></div><br>  Mitte der 1980er Jahre war das Nintendo Entertainment System (NES) ein Muss.  Der beste Sound, die beste Grafik und die besten Spiele unter allen Konsolen dieser Zeit - die Konsole erweiterte die Grenzen des M√∂glichen.  Bisher wurden Projekte wie <em>Super Mario Bros.</em>  , <em>The Legend of Zelda</em> und <em>Metroid</em> gelten als einige der besten Spiele aller Zeiten. <br><br>  Mehr als 30 Jahre nach der Ver√∂ffentlichung von NES f√ºhlen sich klassische Spiele gro√üartig an, was nicht √ºber die Hardware gesagt werden kann, auf der sie gearbeitet haben.  Mit einer Aufl√∂sung von nur 256 x 240 konnte die NES-Konsole den Spielen nicht gen√ºgend Speicherplatz bieten.  Trotzdem gelang es den furchtlosen Entwicklern, sich in die erstaunlichen, unvergesslichen Welten der NES-Spiele einzuf√ºgen: die labyrinthartigen Dungeons von <em>The Legend of Zelda</em> , weite R√§ume des Planeten in <em>Metroid</em> , helle Level von <em>Super Mario Bros.</em>  .  Aufgrund von NES-Hardwarebeschr√§nkungen konnten Spieler jedoch niemals √ºber 256 x 240 hinausgehen ... <br><br>  Bis vor kurzem. <br><br>  Ich pr√§sentiere Ihnen das <strong>wideNES-</strong> Projekt - eine neue Art, NES-Klassiker zu spielen! <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/921/157/9b0/9211579b0ba7322cf563254fcd26c9cc.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/433/ea0/dcd433ea06a9dec672c3457d76ee2181.gif"></div><br>  <strong>wideNES</strong> ist eine neue Technologie zum <em>automatischen</em> und <em>interaktiven</em> Markieren von NES-Spielen <em>in Echtzeit</em> . <br><br>  Wenn sich die Spieler im Level bewegen, zeichnet wideNES den Bildschirm auf und erstellt nach und nach eine Karte des erkundeten Teils der Welt.  In den folgenden Levels synchronisiert wideNES das Gameplay auf dem Bildschirm mit der generierten Karte, sodass die Spieler im Wesentlichen mehr sehen k√∂nnen, indem sie √ºber die Grenzen des NES-Bildschirms hinausschauen!  Das Beste ist, dass die Art und Weise, wie Sie wideNES-Spiele markieren, <em>v√∂llig universell ist</em> , sodass eine Vielzahl von NES-Spielen ohne Konfiguration mit wideNES arbeiten k√∂nnen! <br><br>  Aber wie funktioniert das alles? <br><br><hr><br>  Wenn Sie √ºberpr√ºfen m√∂chten, wie wideNES funktioniert, bevor Sie den Artikel lesen, dann bitte!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ANESE</a> ist der NES-Emulator, den ich geschrieben habe, und derzeit ist es der einzige Emulator, der wideNES implementiert.  Es ist jedoch zu warnen, dass ANESE <em>nicht der</em> beste NES-Emulator der Welt ist, sowohl was die Benutzeroberfl√§che als auch die Emulationsgenauigkeit betrifft.  Die meisten Funktionen (einschlie√ülich der Aufnahme von wideNES) sind nur √ºber die Befehlszeile verf√ºgbar. Obwohl viele beliebte Spiele einwandfrei funktionieren, verhalten sich einige andere m√∂glicherweise unerwartet. <br><br><hr><br><h2>  Wie wideNES funktioniert </h2><br>  Bevor Sie sich mit den Details befassen, ist es wichtig, kurz zu erkl√§ren, wie NES Grafiken rendert. <br><br><h3>  Pixel√ºbertragung mit PPU </h3><br>  Das Herzst√ºck von NES ist der ehrw√ºrdige MOS 6502-Prozessor. In den sp√§ten 70er und fr√ºhen 80er Jahren wurden 6502 <em>√ºberall eingesetzt</em> und arbeiteten in legend√§ren Maschinen wie Commodore 64, Apple II und vielen anderen.  Es war billig, leicht zu programmieren und leistungsf√§hig <em>genug</em> , um gef√§hrlich zu sein. <br><br>  Erg√§nzt wurde 6502 in der NES-Konsole durch einen leistungsstarken Grafik-Coprozessor namens <em>Picture Processing Unit</em> (PPU).  Im Vergleich zu einfachen Videokoprozessoren, die auf √§lteren Systemen verwendet werden, ist PPU eine enorme Verbesserung in Bezug auf die Benutzerfreundlichkeit.  Beispielsweise wurde f√ºnf Jahre vor der Ver√∂ffentlichung von NES der Atari 2600-Prozessor 6502 verwendet, um <em>f√ºr jede Rasterzeile</em> grafische Anweisungen an den Coprozessor zu √ºbertragen, so dass der Prozessor nur sehr wenig Zeit f√ºr die Ausf√ºhrung der Spielelogik hatte.  Zum Vergleich: PPU ben√∂tigte nur ein paar Befehle <em>pro Frame</em> , und dies gab 6502 genug Zeit, um ein interessantes und innovatives Gameplay zu erstellen. <br><br>  PPU ist ein erstaunlicher Chip, seine Art, Grafiken zu rendern, ist fast nichts anderes als die Arbeit moderner GPUs, und eine vollst√§ndige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Artikeln wird ben√∂tigt</a> , um seine Funktionen vollst√§ndig zu erkl√§ren.  Da wideNES nur eine kleine Teilmenge der PPU-Funktionen verwendet, reicht es aus, sie nur kurz zu betrachten: <br><br><ul><li>  Aufl√∂sung: 256 x 240 Pixel, 60 Hz </li><li>  Es funktioniert unabh√§ngig von der CPU <br><ul><li>  Kommuniziert mit der CPU √ºber <em>E / A mit Speicherzuordnung</em> (Adressbereich 0x2000 - 0x2007) </li></ul></li><li>  2 Rendering-Ebenen: <strong>Sprite-</strong> Ebene und <strong>Hintergrundebene</strong> <ul><li>  <strong>Sprite-Schicht</strong> <br><ul><li>  Jedes einzelne Sprite kann an einer beliebigen Stelle auf dem Bildschirm platziert werden. </li><li>  Ideal zum Bewegen von Objekten: Spieler, Feinde, Muscheln </li><li>  Bis zu 64 Sprites mit 8 x 8 Pixeln </li></ul></li><li>  <strong>Hintergrundschicht</strong> <br><ul><li>  An ein Gitter gebunden </li><li>  Ideal f√ºr statische Elemente: Plattformen, gro√üe Hindernisse, Dekorationen </li><li>  Der Videospeicher reicht aus, um 64 x 30 Kacheln mit einer Gr√∂√üe von 8 x 8 Pixel zu speichern <br><ul><li>  Echte <em>interne</em> Aufl√∂sung 512 x 240 mit einem Ansichtsfenster von 256 x 240 </li><li>  Unterst√ºtzt das <strong><em>Scrollen</em></strong> von <strong><em>Hardware</em></strong> , um das 256x240-Ansichtsfenster zu √§ndern <br><ul><li>  Das PPUSCROLL-Register (Adresse 0x2005) steuert die Verschiebung des Ansichtsfensters in X / Y. </li></ul></li></ul></li></ul></li></ul></li></ul><br>  Nachdem wir uns mit dieser <em>sehr</em> kurzen √úbersicht befasst haben, kommen wir zum interessantesten: Wie funktioniert wideNES? <br><br><h3>  Hauptidee </h3><br>  Am Ende jedes Frames sendet die CPU die √Ñnderungsinformationen an die PPU.  Dazu geh√∂ren neue Sprite-Positionen, neue Level-Daten und, was f√ºr wideNES von entscheidender Bedeutung ist, <em>neue Ansichtsfenster-Offsets</em> .  Da wideNES im Emulator funktioniert, ist es f√ºr uns sehr einfach, die in das PPUSCROLL-Register geschriebenen Werte zu verfolgen, was bedeutet, dass es unglaublich einfach ist, zu berechnen, wie viel sich der Bildschirm zwischen zwei Frames bewegt hat! <br><br>  Hmm, was passiert, wenn anstelle jedes neuen Frames <em>direkt √ºber dem</em> alten Frame neue Frames √ºber dem vorherigen Frame gezeichnet, aber auf den aktuellen Bildlaufwert verschoben werden?  Dann bleibt im Laufe der Zeit ein immer gr√∂√üerer Teil des Levels auf dem Bildschirm und erstellt nach und nach ein vollst√§ndiges Bild des Levels! <br><br>  Um zu √ºberpr√ºfen, ob diese Idee von Wert ist, habe ich schnell die erste Implementierung skizziert. <br><br>  Kompilieren ... <br>  Starten ... <br>  Laden Sie <em>Super Mario Bros.</em> herunter <em>.</em>  ... <br><br>  Voila! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/7cb/c7f/1ed7cbc7ff1998d1f5f19af6ca09bb54.gif"></div><br>  Es hat funktioniert! <br><br>  So'ne Art‚Ä¶ <br><br><hr><br><h3>  Ein anderer Ansatz: Warum nicht Ebenen direkt aus ROM-Dateien extrahieren? </h3><br>  Ohne die Details der Implementierung zu ber√ºcksichtigen, wird deutlich, dass diese Technik eine schwerwiegende Einschr√§nkung aufweist: Eine vollst√§ndige Spielkarte kann nur gesammelt werden, wenn der Spieler das gesamte Spiel unabh√§ngig erforscht. <br><br>  Was w√§re, wenn es eine M√∂glichkeit g√§be, Levels aus <em>rohen</em> NES-ROMs zu extrahieren ?! <br><br>  Kann eine solche Technik √ºberhaupt existieren? <br><br>  Nun, h√∂chstwahrscheinlich nicht. <br><br>  Wenn Sie zwei Spiele f√ºr NES spielen, k√∂nnen Sie garantieren, dass beide nur eines gemeinsam haben: Beide funktionieren f√ºr NES.  Alles andere kann ganz anders sein!  Eine solche Nicht√ºbereinstimmung ist eine echte Katastrophe, da NES-Spiele im Wesentlichen unendlich viele Optionen zum Speichern von Level-Daten bieten! <br><br>  Einige Leute haben vollst√§ndige Levels durch Reverse Engineering extrahiert, indem sie die Leveldaten einiger Spiele gespeichert haben (manchmal mit der Erstellung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karteneditoren</a> mit vollem Funktionsumfang!). Dies ist jedoch eine schwierige Aufgabe, die viel Arbeit, Ausdauer und Intelligenz erfordert. <br><br>  Um Level-Daten aus dem ROM zu extrahieren, muss bestimmt werden, welche Teile des ROM Code sind (keine Daten), und dies ist schwierig, da das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auffinden des gesamten Codes in einer Bin√§rdatei einem Stoppproblem entspricht</a> ! <br><br>  WideNES verwendet einen viel einfacheren Ansatz: Anstatt zu erraten, wie das Spiel die Level-Daten in den ROM gepackt hat, startet wideNES einfach das Spiel und verfolgt die Ausgabe! <br><br><hr><br><h3>  Scrollen √ºber 255 hinaus </h3><br>  NES ist ein 8-Bit-System, dh das PPUSCROLL-Register kann nur 8-Bit-Werte empfangen.  Dies begrenzt den maximalen Bildlaufversatz auf 255 Pixel, dh die maximale 8-Bit-Zahl.  Es ist kein Zufall, dass die NES-Bildschirmaufl√∂sung 240 x 256 Pixel betr√§gt, d. H. Eine Verschiebung <em>um</em> 255 Pixel <em>reicht gerade aus,</em> um den gesamten Bildschirm zu scrollen. <br><br>  Aber was passiert, wenn Sie <em>weiter als</em> 255 scrollen? <br><br>  Erstens setzen Spiele das PPUSCROLL-Register auf 0 zur√ºck. Dies erkl√§rt, warum <em>SMB</em> an den Anfang gebracht wird, wenn Mario sich zu weit nach rechts bewegt. <br><br>  Um die 8-Bit-PPUSCROLL-Einschr√§nkungen zu kompensieren, aktualisieren die Spiele ein weiteres PPU-Register: PPUCTRL (Adresse 0x2000).  Die unteren 2 Bits von PPUCTRL setzen den ‚ÄûStartpunkt‚Äú der aktuellen Szene in Vollbildschritten.  Wenn Sie beispielsweise einen Wert von 1 schreiben, wird das Ansichtsfenster um 256 Pixel nach rechts verschoben, bei einem Wert von 2 wird das Ansichtsfenster um 240 Pixel nach unten verschoben.  Der PPUCTRL-Offset wird mit dem PPUSCROLL-Register auf den <em>Stapel</em> verschoben, mit dem Sie den Bildschirm horizontal innerhalb von 512 Pixel oder vertikal innerhalb von 480 Pixel scrollen k√∂nnen. <br><br>  Aber bauen, gibt es nur genug Videospeicher f√ºr Bildschirme mit zwei Ebenen?  Was passiert, wenn das Ansichtsfenster zu weit nach rechts rollt und √ºber den VRAM hinausgeht?  Um diesen Fall zu behandeln, implementiert PPU die Faltung: Alle Teile des Ansichtsfensters au√üerhalb des ausgew√§hlten Videospeichers werden einfach auf die gegen√ºberliegende Kante des Videospeichers reduziert. <br><br>  Eine solche Faltung in Kombination mit intelligenter Manipulation von PPUSCROLL- und PPUCTRL-Registern erm√∂glicht es NES-Spielen, die Illusion von unendlich gro√üen / weiten Welten zu erzeugen!  Dank des langsamen Ladens eines Teils des Levels au√üerhalb des Sichtfensters und des schrittweisen Scrollens in dieses Level merken die Spieler nie, dass sie im VRAM tats√§chlich ‚Äûim Kreis laufen‚Äú! <br><br>  Eine hervorragende Illustration aus dem nesdev-Wiki zeigt, wie <em>Super Mario Bros.</em>  Verwendet diese Eigenschaften, um Ebenen zu erstellen, die l√§nger als zwei Bildschirme sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif"></div><br>  Kehren wir zu der Frage zur√ºck, die wir diskutieren: Wie geht wideNES mit dem Scrollen √ºber 256 hinaus um? <br><br>  Ehrlich gesagt <em>ignoriert</em> wideNES <em>das</em> PPUCTRL-Register <em>vollst√§ndig</em> und verfolgt nur den PPUSCROLL-Unterschied zwischen Frames! <br><br>  Wenn PPUSCROLL unerwartet auf ungef√§hr 256 springt, was normalerweise bedeutet, dass sich der Charakter des Spielers auf dem Bildschirm nach links / oben bewegt hat, und wenn er unerwartet auf ungef√§hr 0 springt, bedeutet dies normalerweise, dass sich der Spieler auf dem Bildschirm nach rechts / unten bewegt hat. <br><br>  Obwohl diese Heuristik einfach aussehen mag - und es ist -, funktioniert sie tats√§chlich gro√üartig! <br><br>  Nach der Implementierung dieser Heuristik hat <em>Super Mario Bros.</em>  , <em>Metroid</em> und viele andere Spiele haben fast perfekt funktioniert! <br><br>  Ich war begeistert und habe einen weiteren NES-Klassiker hochgeladen - <em>Super Mario Bros.</em>  <em>3</em> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a21/1ee/233/a211ee233bcdea56af5b983f9b8715cf.gif"></div><br>  Hmm ... nicht sehr h√ºbsch. <br><br><h3>  Statische Bildschirmelemente ignorieren </h3><br>  Viele Spiele haben statische UI-Elemente an den R√§ndern des Bildschirms.  Bei <em>SMB3 ist</em> dies die linke Spalte und die Statusleiste befindet sich am unteren Rand des Status. <br><br>  Standardm√§√üig werden wideNES-Samples mit 16-Pixel-Schritten von den Bildschirmr√§ndern abgetastet, dh alle statischen Elemente an den R√§ndern werden abgetastet!  Nicht gut! <br><br>  Um dieses Problem zu umgehen, implementiert wideNES Regeln und Heuristiken, die versuchen, statische Bildschirmelemente automatisch zu erkennen und zu maskieren. <br><br>  Im Allgemeinen verwenden NES-Spiele drei verschiedene Arten von statischen Bildschirmelementen: HUDs, Masken und Statusleisten. <br><br><h4>  HUD - kein Problem </h4><br>  Wenn ein Spiel ein HUD √ºber einem Level auferlegt, besteht das HUD wahrscheinlich aus mehreren Sprites.  Beispiel: HUD in <em>Metroid</em> . <br><br>  Gl√ºcklicherweise verursachen solche HUDs keine Probleme, da wideNES derzeit die Sprite-Ebene einfach ignoriert.  Gro√üartig! <br><br><h4>  Masken - nirgendwo einfacher </h4><br>  Die PPU verf√ºgt √ºber eine Funktion, mit der Spiele die 8 Pixel ganz links auf der Hintergrundebene maskieren k√∂nnen.  Sie wird durch Setzen des zweiten Bits des Registers (Adresse 0x2001) aktiviert.  Viele Spiele verwenden diese Funktion, aber zu erkl√§ren, <em>warum</em> sie dies tun, w√ºrde den Rahmen dieses Artikels sprengen. <br><br>  Das Erkennen der enthaltenen Maske ist unglaublich einfach: wideNES verfolgt nur den PPUMASK-Wert und ignoriert die 8 Pixel ganz links, wenn das zweite Bit im Register gesetzt ist! <br><br>  Es scheint, dass die Implementierung dieser einfachen Regel <em>das</em> Problem mit <em>SMB3 behoben hat</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/6ce/6ce/8e56ce6ce6e3f59203422816794e21de.gif"></div><br>  ... gut oder <em>fast</em> beseitigt. <br><br><h4>  Statusleisten sind am schwierigsten </h4><br>  Aufgrund der Einschr√§nkungen der PPU zu einem bestimmten Zeitpunkt auf dem Bildschirm k√∂nnen nicht mehr als 64 Sprites angezeigt werden.  Dar√ºber hinaus k√∂nnen zu jeder Zeit in <em>jeder Rasterzeile</em> nicht mehr als 8 Sprites vorhanden sein.  Diese Einschr√§nkung verhindert, dass Entwickler komplexe HUDs aus Sprites erstellen, und zwingt sie, Teile der Hintergrundebene zum Anzeigen von Informationen zu verwenden. <br><br>  Zus√§tzlich zu Masken gibt es in PPU keine einfache M√∂glichkeit, die Hintergrundebene in den Spielbereich und den Statusbereich zu unterteilen.  Daher gingen die Entwickler zu Tricks √ºber, was zu einer Reihe <em>unorthodoxer</em> Methoden f√ºhrte, um Status-Panels zu erstellen ... <br><br>  WideNES verwendet verschiedene Heuristiken, um verschiedene Arten von Statusanzeigen zu erkennen. Um jedoch Zeit zu sparen, werde ich nur eine der interessantesten betrachten: die IRQ-Verfolgung im mittleren Frame. <br><br><h3>  Mid-Frame-IRQ-Tracking </h3><br>  Im Gegensatz zu modernen GPUs mit gro√üen internen Frame-Puffern haben PPUs im <em>Allgemeinen keinen Frame-Puffer!</em>  Um Platz zu sparen, speichert PPU Szenen als Raster aus 64 x 32 Kacheln mit 8 x 8 Pixeln.  Anstatt die Pixeldaten vorab zu berechnen, werden die Kacheln als <em>Zeiger</em> auf den CHR-Speicher (Zeichenspeicher) gespeichert, der alle Pixeldaten enth√§lt. <br><br>  Seit der Entwicklung von NES in den 80er Jahren wurde PPU ohne Ber√ºcksichtigung moderner Anzeigetechnologien erstellt.  Anstatt das gesamte Bild gleichzeitig zu rendern, gibt die PPU das NTSC-Videosignal aus, das auf einem CRT-Bildschirm angezeigt werden soll, auf dem das Video <em>Pixel f√ºr Pixel</em> , <em>Zeile f√ºr Zeile</em> , von oben nach unten, von oben nach unten, von links nach rechts angezeigt wird. <br><br>  Warum ist das alles so wichtig? <br><br>  Da PPU Frames Zeile f√ºr Zeile von oben nach unten rendert, k√∂nnen Sie PPU-Anweisungen an <em>Mid-Frame</em> senden, um Videoeffekte zu erstellen, die mit keinem anderen Ansatz m√∂glich sind!  Diese Effekte k√∂nnen entweder einfach (z. B. √Ñndern der Palette) oder recht komplex (z. B. Sie haben es erraten und Statusleisten erstellt!) Sein. <br><br>  Um zu erkl√§ren, wie ein PPU-Schreibvorgang im mittleren Frame Statusleisten erstellen kann, habe ich einen <em>unformatierten PPU-</em> und CHR-Speicher-Video-Slice-Dump f√ºr einen einzelnen <em>SMB3-</em> Frame <em>aufgezeichnet</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf6/565/049/cf6565049202c1a832222de6edb291c3.png"></div><br>  Alles sieht gut aus, nichts Besonderes ... aber schauen Sie einfach in die Statusleiste!  Sie ist v√∂llig verzerrt! <br><br>  Schauen Sie sich jetzt dieselbe Rohkippe an, die jedoch nach Zeile 196 erstellt wurde ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5df/8e4/be6/5df8e4be6a32dcefa00429da5fbb4755.png"></div><br>  Ja, das Level sieht schrecklich aus, aber die Statusleiste sieht gut aus! <br><br>  Was ist hier los? <br><br>  <em>SMB3</em> stellt einen Timer ein, der IRQ (Interrupt) genau nach dem Rendern der 195-Rasterzeile ausl√∂st. Er √ºbergibt die folgenden Anweisungen an den IRQ-Handler: <br><br><ul><li>  Setzen Sie PPUSCROLL auf (0,0) (damit die Statusleiste an Ort und Stelle bleibt) </li><li>  Wir ersetzen die Kachelkarte im CHR-Speicher (wir ordnen die Grafiken der Statusleiste an). </li></ul><br>  Da der Rest der Ebene bereits gerendert ist, aktualisiert die PPU den Frame nicht erneut.  Stattdessen wird das Rendern mit diesen Optionen fortgesetzt und eine sch√∂ne unverzerrte Statusleiste angezeigt! <br><br>  Kehren wir zu wideNES zur√ºck: Wenn Sie alle IRQs in der Mitte des Frames beobachten und sich an die Rasterlinie erinnern, auf der sie aufgetreten sind, kann wideNES alle nachfolgenden Rasterzeilen im Datensatz ignorieren!  Wenn IRQ in der Rasterzeile √ºber 240/2 auftritt, werden alle <em>vorherigen</em> Zeilen ignoriert, da eine fr√ºhzeitige Unterbrechung der Rasterzeile bedeutet, dass sich die Statusleiste m√∂glicherweise <em>oben auf dem</em> Bildschirm befindet. <br><br>  Nach der Implementierung dieser Heuristik hat <em>Super Mario Bros.</em>  <em>3</em> perfekt verdient! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/146/44a/b08/14644ab0880d7a2827bcad22d028a0be.gif"></div><br><hr><br>  Ich habe kurz √ºber die M√∂glichkeit nachgedacht, eine Computer-Vision-Bibliothek wie OpenCV zum Erkennen von Statusanzeigen (oder anderen meist statischen Bereichen des Bildschirms) zu verwenden, aber aus diesem Grund habe ich beschlossen, sie aufzugeben.  Die Verwendung einer riesigen, komplexen und undurchsichtigen Computer-Vision-Bibliothek widerspricht den Idealen von wideNES, bei denen ich versuche, kompakte, einfache und transparente Regeln und Heuristiken zu verwenden, um Ergebnisse zu erzielen. <br><br><hr><br><h3>  Szenenerkennung </h3><br>  Mit Ausnahme einiger prominenter Beispiele (z. B. <em>Metroid</em> ) bestehen Spiele f√ºr NES normalerweise <em>nicht</em> innerhalb eines riesigen, untrennbaren Levels.  Im Gegenteil, die meisten NES-Spiele sind in viele kleine unabh√§ngige ‚ÄûSzenen‚Äú unterteilt, zwischen denen sich T√ºren oder √úbergangsbildschirme befinden. <br><br>  Da wideNES nicht das Konzept von "Szenen" hat, passieren beim Szenenwechsel schlimme Dinge ... <br><br>  Hier ist zum Beispiel der erste √úbergang von der <em>Castlevania-</em> Szene, in der Simon Belmont Draculas Schloss betritt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/b5b/8e4/7f7b5b8e4edf5c31dd19682b333d75c9.gif"></div><br>  Wow, alles ist schlecht!  wideNES hat den letzten Teil des Levels mit dem ersten Bildschirm eines neuen Levels komplett neu geschrieben! <br><br>  Offensichtlich ben√∂tigt wideNES eine M√∂glichkeit, Szenen√§nderungen zu erkennen.  Aber welches? <br><br>  <em>Perceptual Hashing!</em> <br><br>  Im Gegensatz zu <em>kryptografischen</em> Hash-Funktionen, die dazu neigen, √§hnliche Eingabedaten gleichm√§√üig √ºber den Ausgabeinformationsraum zu verteilen, versuchen <em>Wahrnehmungs-</em> Hash-Funktionen, √§hnliche Eingabedaten im Ausgabedatenraum ‚Äûnahe beieinander‚Äú zu halten.  Wahrnehmungs-Hashes sind daher ideal, um √§hnliche Bilder zu erkennen! <br><br>  Wahrnehmungs-Hash-Funktionen k√∂nnen unglaublich komplex sein. Einige von ihnen k√∂nnen √§hnliche Bilder erkennen, wenn eines von ihnen gedreht, skaliert, gedehnt und die Farben darin ge√§ndert wurden.  Gl√ºcklicherweise erfordert wideNES keine komplexen Hash-Funktionen, da garantiert wird, dass jeder Frame dieselbe Gr√∂√üe hat.  Daher verwendet wideNES den einfachsten der vorhandenen Wahrnehmungs-Hashes: <em>Summieren aller Pixel auf dem Bildschirm!</em> <br><br>  Es ist einfach, aber es funktioniert ziemlich gut! <br><br>  Sehen Sie sich beispielsweise an, wie √úberg√§nge zwischen Szenen hervorstechen, wenn Sie den Wahrnehmungs-Hash √ºber die Zeit in <em>The Legend of Zelda</em> zeichnen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/799/5e3/f077995e3d509802139543805d7ae61b.png"></div><br>  Derzeit verwendet wideNES einen festen Schwellenwert zwischen Wahrnehmungs-Hash-Werten, um den √úbergang zwischen Szenen abzuschlie√üen, aber das Ergebnis ist alles andere als ideal.  Verschiedene Spiele verwenden unterschiedliche Paletten, und es gibt viele F√§lle, in denen wideNES glaubt, dass ein √úbergang stattgefunden hat, dies jedoch nicht der Fall war.  Im Idealfall sollte wideNES einen dynamischen Schwellenwert verwenden, aber bisher reicht der feste aus. <br><br>  Nach der Implementierung dieser neuen Heuristik erkennt wideNES erfolgreich Simons Eingang von <em>Castlevania</em> zum Schloss und erstellt dementsprechend eine neue Leinwand. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/6da/e81/6446dae81018592433a99f4f50a8b4d0.gif"></div><br>  Und mit dieser Entscheidung haben wir das letzte gro√üe Teil des wideNES-Puzzles umgesetzt. <br><br>  Nachdem ich die einfachste Serialisierung implementiert hatte, konnte ich endlich das Spiel f√ºr NES ausf√ºhren, in mehreren Levels spielen und automatisch Levelkarten erstellen! <br><br><h2>  Was erwartet wideNES in Zukunft? </h2><br>  wideNES besteht aus zwei separaten Teilen: <em>dem</em> wideNES- <em>Kernel</em> , <em>der</em> genau die Regeln / Heuristiken darstellt, die der Technologie zugrunde liegen, und der spezifischen Implementierung von wideNES im ANESE-Emulator. <br><br><h3>  WideNES- <em>Kernverbesserung</em> </h3><br>  Erstens neigt wideNES dazu, √úberg√§nge zwischen Szenen zu aggressiv zu erkennen.  Die Anzahl der falsch positiven Ergebnisse kann minimiert werden, indem ein geeigneterer Wahrnehmungs-Hashing-Algorithmus verwendet wird oder indem zwischen Wahrnehmungs-Hashes auf dynamische Schwellenwerte umgeschaltet wird. <br><br>  Zus√§tzliche Arbeiten sind erforderlich, um statische Bildschirmelemente zu erkennen. ,  <em>Megaman IV</em>  IRQ  ,    , -  wideNES      .        ,  -    . <br><br>    NES    ¬´¬ª .       <em>The Legend of Zelda</em> ,       PPUSCROLL,         ‚Äî PPUADDR. <em>Zelda</em> ‚Äî    ,  wideNES     <em>Zelda</em> .       ¬´¬ª  ,      . <br><br>     -  ¬´¬ª  . ,     <em>Super Mario Bros.</em> Level 1,    ,       ,  wideNES      Level 1:  A,    ,       ,   B, ,  ,        .      Level 1  <em></em>   ,  wideNES    A,      ,   B ¬´¬ª. <br><br>  , wideNES     .               , <em></em>     . <br><br><h3>   wideNES  ANESE </h3><br>    wideNES       NES   ANESE. ANESE ‚Äî  <em></em>  :      CLI,    UI     !   <em></em>    ¬´¬ª. <br><br>   UI, ANESE  wideNES        . ANESE ‚Äî    ,   ! <br><br>        ‚Äî        .  ,  ANESE   ,  wideNES ‚Äî   . wideNES     ,       ! <br><br>     ANESE  wideNES ,      PC      60fps!  ANESE  wideNES    .     ANESE,    wideNES  ,     . <br><br><h2>  Fazit </h2><br>         wideNES,       . , wideNES         ,       .            wideNES,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  wideNES</a> . <br><br>   wideNES    ,             ,         wideNES.      wideNES ,   ,           ! <br><br>   wideNES     !  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ANESE</a> ,  <em>Super Mario Bros.</em> , <em>The Legend of Zelda</em>  <em>Metroid</em> ,     -! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421555/">https://habr.com/ru/post/de421555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421545/index.html">Testbericht zum PocketBook 616 - dem preisg√ºnstigsten Taschenbuch f√ºr 2018 mit Hintergrundbeleuchtung</a></li>
<li><a href="../de421547/index.html">Akzeptanz unabh√§ngiger Rechenzentren</a></li>
<li><a href="../de421549/index.html">Wir schreiben technische Dokumentation: eine Anleitung f√ºr den Laien</a></li>
<li><a href="../de421551/index.html">Vuex meistern - Von Null zu Held</a></li>
<li><a href="../de421553/index.html">Wir teilen technologische Inhalte: Wir haben alle unsere Materialien auf einer Website gesammelt</a></li>
<li><a href="../de421557/index.html">Offene Lektion "Asynchrone Programmierung in Java"</a></li>
<li><a href="../de421559/index.html">Komponenten-UI-Architektur in iOS-Anwendungen</a></li>
<li><a href="../de421561/index.html">12 Fragen zu Rollern, die sich nicht sch√§men zu stellen</a></li>
<li><a href="../de421563/index.html">M√∂glicherweise m√ºssen Sie anders sitzen, um R√ºckenschmerzen loszuwerden.</a></li>
<li><a href="../de421565/index.html">Wie unh√∂flich humanoide Roboter Sie t√§uschen k√∂nnen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>