<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏽 💪🏾 🥜 与1C快速集成：企业 🕴🏽 💪 🀄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我认为，在本文中，我将讨论将第三方应用程序与1C配置集成在一起的最简单方法。 本文将主要吸引使用.Net Core ， PHP和Python编写的开发人员。 

 与1C集成的方法有很多， 1C本身的出色文章甚至致力于此。 从中您将特别了解到1C支持Web服务的机制，这意味着我们可以在1C端实现我们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>与1C快速集成：企业</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462453/"> 我认为，在本文中，我将讨论将第三方应用程序与1C配置集成在一起的最简单方法。 本文将主要吸引使用<b>.Net Core</b> ， <b>PHP</b>和<b>Python</b>编写的开发人员。 <br><br> 与1C集成的方法有很多， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1C</a>本身的出色<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>甚至致力于此。 从中您将特别了解到1C支持Web服务的机制，这意味着我们可以在1C端实现我们自己的服务，因此，可以在客户端应用程序端实现我们自己的ORM库。 这些库之一将在后面讨论。 <br><a name="habracut"></a><br><h2> 对该技术的一般描述 </h2><br><h3> 在1C方面 </h3><br> 这一切都始于将“ Brom”扩展名添加到1C配置中，从而添加了新的Web服务。 该扩展程序是免费提供和许可的（MIT）。 该扩展本身不依赖于特定的数据模型，因此可以安装在支持兼容模式8.3.10或更高版本的任何配置上。 <br><br> 安装扩展程序后，您必须配置有权访问Web服务方法的用户的权限，并在Web服务器上发布配置，以便可以通过http（s）协议访问添加的服务。 在1C方面，不需要任何其他操作。 <br><br><h3> 在客户端 </h3><br> 在客户端，连接了Brom软件包，例如，对于.Net Core，可以使用以下命令完成： <br><br><pre><code class="plaintext hljs">Install-Package Brom -Version 1.0.1-beta08</code> </pre> <br> 或对于Python： <br><br><pre> <code class="plaintext hljs">pip install brome</code> </pre> <br> 安装软件包后，创建一个客户端对象就足够了，通过该对象将与远程1C配置进行交互。 在下文中，我将用C＃给出代码，但是在PHP和Python中，它是相似的。 因此，您可以使用一个命令创建客户端： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span>  = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-string"><span class="hljs-string">@"  = http://mydomain.com/publication_name;  = 1c_user_name;  = 1c_user_pass "</span></span>);</code> </pre> <br> 在构造函数中，足以表明已发布的1C配置的地址，以及我们向其授予扩展名访问权限的用户的数据。 一旦创建了客户端，我们就可以进行最有趣的操作。 <br><br><h2> 调用程序和功能1C </h2><br> 通过创建的溴客户端，我们可以调用1C中定义的过程和函数。 在这种情况下，被调用的方法必须在服务器端，并且包含在全局上下文中或服务器模块（通用模块或管理器模块）中。 例如，这是全局上下文“ Number Prescription”的函数调用的样子： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  = .(<span class="hljs-number"><span class="hljs-number">2547</span></span>, <span class="hljs-string"><span class="hljs-string">" = fr_FR"</span></span>);</code> </pre> <br> 第二个参数是指示本地化（法语）的格式字符串。 参数以自然形式传输，不需要任何其他转换或包装。 <br><br> 这就是对目录管理器模块的按代码查找功能的调用的样子： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ...(<span class="hljs-number"><span class="hljs-number">840</span></span>);</code> </pre> <br> 在这里，我们通过模块管理器目录“货币”调用该函数。 调用的结果将是“ DirectoryReference”类型的对象。 现在，可以将该对象的链接作为参数传递给另一个函数： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ..(, DateTime.Today);</code> </pre> <br> 这次，我们转向通用模块“使用币种”，并恢复其方法“获取课程币种”。 <br><br> 该库支持处理复杂的数据类型，因此可以调用接受输入或返回的方法：链接，数组，结构，值表，值树，系统枚举等。...某些类在客户端库中专门实现，以简化使用1C的工作。 <br><br> 通过在设置中指定远程方法的范围，可以灵活地配置它们。 因此，例如，如果您指定“目录。*。按代码查找”区域，则在所有配置目录中仅“按代码查找”方法将可用。 因此，您可以清楚地指示集成应用程序可以使用哪些方法。 <br><br><h2> 使用链接 </h2><br> 对对象的引用不仅允许将指针传输到1C对象，而且还可以接收对象本身的数据。 在客户端使用链接就像在1C中一样简单。 例如： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ...(<span class="hljs-string"><span class="hljs-string">"00-000018"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = .; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = .; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ..; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> .) { Console.WriteLine((., .)); }</code> </pre> <br> 在这里，我们通过管理器模块找到了指向文档的链接，并获得了文档字段及其表格部分“产品”的值。 首次访问对象字段之后，所有数据都从1C服务器下载并存储在客户端上，直到垃圾回收器删除链接为止。 <br><br> 也可以在客户端访问对象的链接，而无需访问服务器。 为此，只需知道对象的唯一标识符即可： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ...(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Guid(<span class="hljs-string"><span class="hljs-string">"5a32b6ab-4661-11e9-912a-38d547755ef7"</span></span>));</code> </pre> <br> 您还可以仅获取指向预定义集合项的链接： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ...<span class="hljs-number"><span class="hljs-number">18</span></span>_118;</code> </pre> <br><br><h2> 编辑物件 </h2><br> 通过链接到对象，我们可以编辑对象的数据。 为此，只需创建一个对象上下文： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = .(); . = DateTime.Today; . = <span class="hljs-string"><span class="hljs-string">"00-000055"</span></span>; ..(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ..() . = ...(<span class="hljs-string"><span class="hljs-string">"000000104"</span></span>); . = <span class="hljs-number"><span class="hljs-number">3</span></span>; .(.);</code> </pre> <br> 在此示例中，我们通过指向文档的链接创建了文档的上下文，并填充了一些字段，在表格部分“产品”中添加了一行，并以发布模式记录了文档。 <br><br> 如果您需要创建一个新对象，那么这也是可能的： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     var  = ...(); . = " "; .(); //     var  = ...(); . = .; . = " "; . = "T-00012321"; //    .(); //      var  = .;</span></span></code> </pre> <br> 在这里，我们在“ Nomenclature”目录中创建了一个新组，然后创建了目录元素并将其放置在创建的组中。 <br><br><h2> 取样方式 </h2><br> 像任何体面的ORM一样，溴客户端允许您从各种1C对象集合中创建样本。 选择是对满足一组选择条件的集合对象的引用的集合。 要创建选择，只需创建“ Selector”对象： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ...(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = ...(); . (<span class="hljs-string"><span class="hljs-string">", , , ."</span></span>). (<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>). (<span class="hljs-string"><span class="hljs-string">""</span></span>, , .). (<span class="hljs-string"><span class="hljs-string">""</span></span>). (<span class="hljs-string"><span class="hljs-string">""</span></span>, .); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">": {0}; : {1}, : {2}; : {3}"</span></span>, ., ., ., .. ); } <span class="hljs-comment"><span class="hljs-comment">//         var  = .();</span></span></code> </pre> <br> 在此示例中，我们获得了一个示例，其中包含“命名”目录中的元素，这些元素按层次结构位于“家具”组中。 我们指出，除了链接本身之外，还需要加载某些字段的数据。 因此，这些字段的数据将通过单个请求加载，对它们的访问不会导致其他服务器调用。 <br><br><h2> 查询执行 </h2><br> 通常，存储在一个集合中的数据变得不足，因此我们需要获取由复杂查询生成的数据。 为了满足请求，客户端库中提供了一个特殊的类“ Request”。 在客户端处理请求与在1C进行处理非常相似： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = .(<span class="hljs-string"><span class="hljs-string">@"  .  , .  , .    .    . = &amp; "</span></span>); .(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"-0001"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = .(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ) { Console.WriteLine((., .)); }</code> </pre> <br> 在这里，我们创建了一个带有参数的简单查询，该参数从“命名法”目录中选择数据。 作为参数，我们传递了元素的字符串文章。 在一般情况下，参数值还可以是链接，系统枚举甚至数组。 作为查询的结果，我们返回了“ Values Table”，该类在客户端实现。 在此示例中，我们使用循环来推断表行的字段。 <br><br> 在1C端，所有请求都通过查询构建器执行，因此您不仅可以将现成的请求指定为文本，还可以指定包含构建器标记的请求模板： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> = .(<span class="hljs-string"><span class="hljs-string">@"   5 .  , .  , .   { .*}  ..( {(&amp;)}, { ().*, ().*} )   { .} {  .*, .*} "</span></span>); <span class="hljs-comment"><span class="hljs-comment">//         .("..", ""); //      .("", 100, .); //       .("."); .("", .); var  = .(.);</span></span></code> </pre> <br> 在此示例中，我们指定了一个标准化请求，可以根据需要在客户端动态更改其设置。 因此，可以在主程序代码的主体中而不是在请求主体中指示字段，选择和排序。 <br><br>  Run方法接受可选参数“结果的爬网类型”。 如果将爬网类型指定为“按分组”或“按层次结构分组”，则该方法将返回值树，而不是值表。 <br><br> 另外，可以代替运行方法，而可以调用运行包方法（一次执行多个请求）。 在这种情况下，将根据遍历的类型返回一个表数组或一个树数组。 <br><br><h2> 代码段执行 </h2><br> 在某些特殊情况下，您可能需要直接在1C端执行特定的代码段。 为此，Brom客户端提供了“运行”方法。 该方法采用包含可执行代码和一个可选参数的输入文本，这些参数将在“ Parameter”变量的代码中提供： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span>  = .(<span class="hljs-string"><span class="hljs-string">@"  = 0;        =  + ; ; "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] { <span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-number"><span class="hljs-number">67</span></span>, <span class="hljs-number"><span class="hljs-number">12.56</span></span>, <span class="hljs-number"><span class="hljs-number">11.9</span></span> });</code> </pre> <br> 在此示例中，我们执行了一段代码，将数组中的数字求和。 数组本身作为参数传递，并放置在“ Parameter”变量中。 计算结果放置在变量“结果”中。 如果在可执行代码中填充了具有此名称的变量，则执行结束时将返回其值作为“运行”功能的结果。 <br><br> 执行代码片段的能力由扩展中的单独访问角色控制。 建议仅出于测试目的启用此角色，并确保在工作草案中将其禁用，因为 这是一个明显的漏洞。 <br><br><h2> 优点该技术的缺点 </h2><br> 所描述的方法的优点当然应该包括： <br><br><ul><li>  <b>跨平台</b> 。 所有交互都基于SOAP和HTTP协议，并且它们的实现是在所有流行的开发平台上进行的； </li><li>  <b>代码的简单性</b> 。 客户端应用程序一侧的代码几乎与1C一侧的代码相同； </li><li>  <b>内置的序列化机制</b> 。 我们不需要打包和解包数据即可与1C交换数据； </li><li>  <b>支持使用链接</b> 。 我们可以通过链接轻松访问1C对象。 </li><li>  <b>支持1C特定的数据类型</b> 。 我们可以交换1C表，树，结构和其他复杂结构； </li><li>  <b>访问应用程序上下文</b> 。 我们不仅可以访问数据库数据，还可以调用在1C端定义的方法，还可以访问会话状态。 </li></ul><br> 这种技术的缺点也可以解决： <br><br><ul><li>  <b>低数据率</b> 。 由于SOAP协议基于XML序列化，因此大量数据的传输需要时间来交换多余的流量以及打包和拆包数据。 在这种情况下，通过COM连接进行通信似乎是可取的。 </li><li>  <b>并非所有平台都提供方便的客户端</b> 。 如果您不是.Net Core，PHP或Python程序员，那么您将不得不使用SOAP机制自己实现溴客户端，这通常很耗时； </li><li>  <b>查询语言1C的局限性</b> 。 由于与数据库的所有工作都是通过1C查询机制进行的，因此存在一些限制。 例如，您无法实现经典的数据分页，因为 在查询语言1C中，没有分页机制。 </li></ul><br><h2> 与OData的比较 </h2><br> 从上述1C <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>中，您可以发现在1C中：使用标准化的OData协议实现对数据的企业访问。 因此，不提他也是愚蠢的。 <br> 这是一个简短的比较表： <br><div class="scrollable-table"><table><thead><tr><th></th><th> 溴 </th><th> 数据 </th></tr></thead><tbody><tr><td> 通过复杂的选择和排序条件获取收集数据 </td><td>  + </td><td>  + </td></tr><tr><td> 集合数据的页面输出 </td><td></td><td>  + </td></tr><tr><td> 添加和编辑数据 </td><td>  + </td><td>  + </td></tr><tr><td> 支持使用1C类型：企业（链接，表，树等） </td><td>  + </td><td></td></tr><tr><td> 执行任意查询 </td><td>  + </td><td></td></tr><tr><td> 调用服务器的过程和功能 </td><td>  + </td><td></td></tr><tr><td> 任意服务器代码执行 </td><td>  + </td><td></td></tr><tr><td> 现成的可视化工具/用户界面 </td><td></td><td>  + </td></tr><tr><td>  JSON数据传输 </td><td></td><td>  + </td></tr></tbody></table></div><br> 可以看出，这些方法有其优点和缺点，并且在一般情况下是不可互换的。 <br><br><h2> 结论 </h2><br> 我希望这篇评论文章能在将来帮助您快速轻松地创建与基于1C：Enterprise的会计系统紧密集成的门户，个人帐户和服务。 您可以在官方文档中找到有关溴成分的详细信息，这里只是主要功能的简要概述。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462453/">https://habr.com/ru/post/zh-CN462453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462443/index.html">生化危机2帧渲染</a></li>
<li><a href="../zh-CN462445/index.html">Earth Rumble：阴谋论和可能的解释</a></li>
<li><a href="../zh-CN462447/index.html">初级开发人员如何使我的项目更正确</a></li>
<li><a href="../zh-CN462449/index.html">“如何在初学者中建立网络”或“在线数据科学入门”课程复习</a></li>
<li><a href="../zh-CN462451/index.html">便携式微波设备Arinst与Anritsu的比较回顾</a></li>
<li><a href="../zh-CN462455/index.html">激光雕刻机的秘密生活</a></li>
<li><a href="../zh-CN462457/index.html">Maltego的4个发行版。 工作与机会原则</a></li>
<li><a href="../zh-CN462459/index.html">使用CC2531将ZigBee设备添加到Homebridge</a></li>
<li><a href="../zh-CN462461/index.html">GOES-17事故调查结果</a></li>
<li><a href="../zh-CN462465/index.html">使用苹果的故乡</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>