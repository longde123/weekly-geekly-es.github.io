<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏾 🛀🏼 🔃 Nous résolvons les tâches Yandex.Interview dans un style fonctionnel 🔈 👩‍🌾 🚃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques mois, un article a paru dans le blog de Yandex qui parlait du passage de la section algorithmique de l'interview. Entre autres choses,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous résolvons les tâches Yandex.Interview dans un style fonctionnel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p>  Il y a quelques mois, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article a</a> paru dans le blog de Yandex qui parlait du passage de la section algorithmique de l'interview.  Entre autres choses, dans cet article, un lien a été établi vers un concours spécial contenant des tâches similaires à celles proposées par Yandex à leurs candidats. </p><br><p>  Ayant enregistré dans le système, mon attention a été immédiatement attirée par la capacité de résoudre des problèmes sur Haskell.  Le fait est que bien que j'aime la programmation dans cette langue, je n'ai pas progressé plus loin que la mise en œuvre des tâches de différents cours de plateformes éducatives en ligne.  Ayant décidé que leur solution pouvait être un défi intéressant et augmenterait mon niveau en tant que développeur, j'ai procédé à leur résolution. </p><br><p>  Peu importe ce qui en est finalement arrivé, bienvenue au chat. </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A. Pierres et bijoux </h2><br><blockquote> Deux lignes de caractères latins minuscules sont données: la chaîne J et la chaîne S. Les caractères inclus dans la chaîne J sont des «bijoux» et inclus dans la chaîne S sont des «pierres».  Il est nécessaire de déterminer combien de personnages de S sont simultanément des «joyaux».  Autrement dit, vous devez vérifier le nombre de caractères de S dans J. </blockquote><p>  La première tâche est un échauffement, nous allons le résoudre «sur le front».  Nous définissons la fonction <em>jewelleryCount :: String -&gt; String -&gt; Int</em> , qui, en utilisant la convolution de la liste passée par le deuxième argument, résume tous les cas de l'élément en cours de traitement dans la première liste.  À ces fins, nous définissons la fonction <em>elemInt en</em> fonction de la fonction <em>elem</em> , qui, contrairement à la dernière, ne renverra pas True ou False, mais le nombre 0 ou 1. Dans la fonction principale, il vous suffit de lire deux lignes, de les passer à la fonction correspondante et d'imprimer le résultat.  Le verdict du système de test est OK, nous passons à la deuxième tâche. </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em>Le code source pour résoudre cette tâche et d'autres tâches est également disponible dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">référentiel github.</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B. Unités consécutives </h2><br><blockquote>  Il est nécessaire de trouver la plus longue séquence d'unités dans le vecteur binaire et d'imprimer sa longueur. </blockquote><p>  Pour résoudre ce problème, nous implémentons une fonction récursive qui parcourra la liste transférée et calculera la longueur de la séquence requise.  Avec les arguments de la fonction, en plus de la liste elle-même, nous passerons la longueur maximale actuelle et le nombre d'unités consécutives sur l'appel en cours.  Tout d'abord, nous définissons la base de récursivité sur la liste vide, puis l'étape de récursivité elle-même. </p><br><p>  Pour lire les données d'entrée, nous définissons la fonction <em>getUserInputs :: IO [Char]</em> , dans laquelle nous lisons d'abord le nombre n - la taille de la liste, puis en utilisant le combinateur <em>replicateM</em> nous obtenons une fonction qui appellera la fonction <em>&lt;&lt;get&gt; getLine</em> n fois et fusionner les résultats dans une liste . </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p>  Nous envoyons la décision, le verdict est OK.  Nous continuons. </p><br><h2 id="c-udalenie-dublikatov">  C. Suppression des doublons </h2><br><blockquote>  Un tableau d'entiers 32 bits classés dans l'ordre non décroissant est donné.  Il est nécessaire d'en supprimer toutes les répétitions. </blockquote><p>  Commençons par une implémentation simple.  Nous définissons une fonction initiale qui lit un nombre, l'imprime et le renvoie enveloppé dans la monade IO.  Nous définissons également la fonction <em>deleteDoubles :: Int -&gt; Int -&gt; IO ()</em> , qui lit un nombre et l' <em>affiche</em> uniquement s'il n'est pas égal au deuxième argument (nous passerons le nombre lu à l'étape précédente).  Après cela, la fonction s'appelle récursivement et passe ainsi au numéro suivant dans le flux d'entrée.  La base de récursivité est le nombre de nombres à lire, nous lui passerons le premier argument. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p>  Nous envoyons la solution, elle passe tous les tests, et il semblerait que nous pouvons passer à la tâche suivante, mais à mon avis, l'appel récursif de la fonction travaillant dans la monade IO est plus déroutant que concis.  Essayons de l'améliorer. </p><br><p>  Notez que, d'une manière générale, vous pouvez d'abord lire la liste complète des nombres (nous utiliserons le combinateur replicateM déjà familier avec la deuxième tâche), puis la passer à une fonction pure qui filtre toutes les répétitions, et enfin imprimer le résultat. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p>  J'envoie une solution, et la première déception est que le programme ne passe pas le test 193 en raison du dépassement de la limite de mémoire utilisée.  L'erreur principale est de lire la liste entière dans la mémoire dans son ensemble.  Nous allons essayer d'éviter cela et implémenterons un certain hybride des première et deuxième versions. </p><br><p>  Notez que la tâche de suppression des doublons rappelle quelque peu une convolution associative de gauche: à chaque étape, nous calculons une fonction qui, en fonction de l'élément lu et de certains de ses résultats, à l'étape précédente décide d'imprimer, puis passe à la paire de valeurs suivante. </p><br><p>  Une fonction qui imprime ou n'imprime pas le résultat en fonction de ses arguments, après quoi elle retourne son deuxième argument, enveloppé dans la monade IO, est assez simple, appelons-la étape: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p>  Nous avons compris s'il fallait imprimer ou non, selon les valeurs transmises, mais comment organiser la lecture?  Pour ce faire, nous utilisons la fonction de convolution monadique <em>foldM :: (T pliable, Monade m) =&gt; (b -&gt; a -&gt; mb) -&gt; b -&gt; ta -&gt; mb</em> , qui s'applique à la liste des fonctions de lecture. <br>  Par type de fonction foldM, on note qu'à chaque étape le «déballage» du résultat de l'application précédente de la fonction se produit sous le capot de foldM lui-même.  Ainsi, à chaque étape, il suffit de commencer un calcul monadique de l'élément de liste actuel (en fait, lire le numéro suivant) à l'aide de l'opérateur de <em>liaison</em> ( <em>&gt;&gt; =</em> ) et de le transmettre avec le numéro précédent à l'étape.  En conséquence, nous obtenons le programme suivant </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D. Génération de séquences de parenthèses </h2><br><blockquote>  Étant donné un entier n.  Il est nécessaire de dériver toutes les séquences de parenthèses correctes de longueur 2 ⋅ n, ordonnées lexicographiquement (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ). <br>  Seules les parenthèses sont utilisées dans la tâche. <br>  Il est conseillé d'obtenir une solution qui fonctionne dans un temps proportionnel au nombre total de séquences de parenthèses correctes dans la réponse, et utilise en même temps une capacité de mémoire proportionnelle à n. </blockquote><p>  Cette tâche, comme beaucoup d'autres, dans laquelle il est nécessaire de dériver des séquences qui remplissent certaines conditions (par exemple, la tâche d'échanger des pièces de monnaie, d'organiser huit reines et d'autres, peut être lue plus en détail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> ), est résumée succinctement en utilisant la liste monade.  En bref, cette approche est basée sur la liaison monadique pour les listes, dont le sens est de réunir l'ensemble des opérations effectuées sur chaque élément de la liste. </p><br><p>  Définissez une fonction récursive <em>generate ':: Int -&gt; Int -&gt; [[Char]]</em> , qui prend le nombre de parenthèses à mettre comme deuxième argument, et le nombre de parenthèses ouvertes qui sont déjà définies pour être définies comme premier argument.  Pour l'étape de récursivité, nous avons besoin de deux fonctions auxiliaires: <em>possible</em> - retourne une liste de crochets qui peuvent être placés dans l'étape suivante, et <em>étape</em> - fait un appel récursif à la fonction générer avec les paramètres nécessaires. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p>  Nous envoyons la solution, et nous comprenons que nous n'avons pas pris en compte la restriction qui a été imposée sur la quantité de mémoire utilisée par le programme - la solution ne passe pas le 14e test en raison du dépassement de la limite de mémoire utilisée. </p><br><p>  Nous modifions la fonction generate pour qu'au lieu de construire la liste entière des séquences de parenthèses correctes, elle les affiche immédiatement à l'écran.  Pour ce faire, nous devrons ajouter le troisième argument à la fonction - un fragment de la séquence construite pour l'étape en cours.  Je note que dans cette implémentation, nous allons construire la séquence dans l'ordre inverse - cela nous permettra d'utiliser le constructeur de liste ( <em>:)</em> au lieu de l'opérateur de concaténation plus cher ( <em>++</em> ). </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E. Anagrammes </h2><br><blockquote>  Deux lignes sont données, composées de lettres latines minuscules.  Il est nécessaire de déterminer si ces lignes sont des anagrammes, c'est-à-dire si elles diffèrent uniquement dans la séquence de caractères. </blockquote><p>  Pour résoudre ce problème, nous comptons le nombre de fois qu'une lettre apparaît dans chaque ligne et comparons les résultats.  Nous comprenons immédiatement que les listes standards ne nous conviennent pas, et il est nécessaire d'utiliser une structure de données qui nous permettrait d'accéder efficacement à l'élément par son index.  Il existe plusieurs types de données qui satisferaient nos conditions, mais nous utiliserons le tableau immuable standard <em>Data.Array</em> (il existe encore au moins divers tableaux mutables, ainsi que <em>Data.Vector</em> ). </p><br><p>  Pour construire les tableaux nécessaires, nous utilisons la fonction <em>hist :: (Ix a, Num b) =&gt; (a, a) -&gt; [a] -&gt; Array ab</em> , qui, selon la liste des éléments transférés et la plage à laquelle ces éléments doivent appartenir, forme un tableau, qui stocke le nombre de répétitions d'éléments de la liste.  Cette fonction, bien qu'elle ne soit pas incluse dans le module Data.Array, est souvent donnée à titre d'exemple d'utilisation d'une autre fonction de bibliothèque déjà existante, accumArray.  Nous ne pouvons que copier son implémentation et écrire main - l'avantage de la comparaison pour l'égalité pour <em>Array Char Int est</em> déjà défini.  J'attire votre attention sur une fonctionnalité intéressante - en tant qu'index, nous pouvons utiliser non seulement des entiers, mais tout représentant de la classe <em>Ix</em> .  Dans notre cas, Char joue un rôle naturel dans ce rôle. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  Fusionner k listes triées </h2><br><blockquote>  Étant donné k tableaux de nombres entiers non négatifs triés par ordre non décroissant, dont chacun ne dépasse pas 100. Il est nécessaire de construire le résultat de leur fusion: un tableau trié par ordre non décroissant contenant tous les éléments des tableaux k originaux. <br>  La longueur de chaque tableau ne dépasse pas 10 ⋅ k. <br>  Essayez de faire fonctionner la solution pour le temps k ⋅ log (k) ⋅ n, si nous supposons que les tableaux d'entrée sont de longueur n. </blockquote><p>  La fusion de deux listes triées est une tâche de liste classique et est couverte dans de nombreux cours sur la programmation Haskell.  Par exemple, il peut être résolu comme suit. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p>  Eh bien, nous pouvons fusionner deux listes.  Et que faire de la liste des listes?  Convoluez-le avec cette fonction!  Ainsi, nous combinerons toutes les listes en une seule, et nous n'aurons qu'à l'imprimer. </p><br><div class="spoiler">  <b class="spoiler_title">Solution</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p>  Cependant, cette solution a deux problèmes graves - la complexité de calcul est supérieure à celle requise - <em>O (k ^ 2 ⋅ n)</em> au lieu de <em>O (k ⋅ log (k) ⋅ n)</em> , en plus elle utilise beaucoup de mémoire supplémentaire.  En conséquence, cette solution échoue au test numéro 17 en raison du dépassement de la limite de mémoire utilisée - 17,27 Mo au lieu des 10 Mo autorisés. </p><br><p>  Bien que nous ne prêtions pas attention au fait que les nombres fournis à l'entrée appartiennent à une plage limitée de valeurs, et nous continuons à rechercher des solutions pour un cas plus général. </p><br><p>  L'étape suivante consiste à essayer de mettre en œuvre l'approche qui a été proposée dans l'article d'origine avec l'analyse de ces tâches.  Permettez-moi de vous rappeler qu'il est basé sur l'utilisation d'une structure de données qui fournit un moyen efficace d'extraire l'élément minimum.  En tant que telle structure, sélectionnez <em>Data.Set</em> .  Nous initialisons Set avec la liste des premiers éléments, puis à chaque étape nous allons extraire et imprimer l'élément minimum, puis ajouter l'élément suivant de la liste correspondante.  De plus, nous aurons besoin d'une structure <em>Data.Sequence</em> pour stocker les listes elles-mêmes.  Il a été choisi pour des raisons qu'à chaque étape, il est nécessaire à la fois d'avoir un accès rapide à la liste par son index (que la liste ne peut pas fournir), et de changer l'élément de cet élément sans avoir besoin de copier la structure entière (qui en général ne peut pas fournir de <em>données</em> immuables <em>. Array</em> ). </p><br><p>  Ainsi, nous avons le programme suivant: </p><br><div class="spoiler">  <b class="spoiler_title">Solution</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p>  Nous envoyons la solution et découvrons que même si le programme a commencé à consommer beaucoup moins de mémoire (10,26 Mo au lieu de 17,27 Mo au 17e test), il n'a toujours pas atteint la limite.  La raison à cela réside dans le fait qu'avec cette décision, d'une manière ou d'une autre, nous devons lire la totalité des données d'entrée dans la mémoire.  Essayons d'éviter cela à l'aide de la troisième solution à ce problème - le tri par comptage. </p><br><p>  Nous avons déjà effectué le comptage du nombre de caractères entrants lors de la résolution du problème d'anagramme précédent.  De plus, comme pour le résoudre, nous utiliserons <em>Data.Array</em> .  Tout d'abord, nous implémentons la fonction <em>addToArray :: Array Int Int -&gt; [Int] -&gt; Array Int Int</em> , qui forme un tableau basé sur celui existant en augmentant les valeurs aux indices qui correspondent aux valeurs de la liste. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p>  Ensuite, nous utiliserons l'approche que nous connaissons dans le problème de la suppression des répétitions - en utilisant la convolution monadique, en appliquant séquentiellement la fonction <em>addToArray</em> à <em>k</em> tableaux source.  Et ... nous obtenons le même résultat de 10,26 Mo lors du 17e test.  Et puis il est temps de se rappeler que <em>foldl</em> (dont l'analogue est <em>foldM</em> ) selon l'ordre de réduction accepté va d'abord étendre toute la chaîne des expressions imbriquées et ensuite seulement procéder à leur calcul actif.  Comme vous le savez, pour lutter contre ce fait, le module <em>Data.List</em> implémente la fonction <em>foldl '</em> , qui utilise la fonction <em>seq :: a -&gt; b -&gt; b</em> , qui transforme d'abord le premier argument en forme normale de tête faible, c'est-à-dire le réduit à la partie externe - la valeur de la fonction ou du constructeur, puis renvoie la seconde ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ).  Nous n'avons d'autre choix que d'implémenter la fonction <em>foldM 'de</em> manière <em>indépendante</em> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p>  En conséquence, la quantité de mémoire utilisée lors du 17e test a presque diminué de moitié et s'élève à 5,64 Mo!  Bien que les 17e et 18e tests aient été réussis, cette implémentation n'a pas réussi le 19e test pour la même raison que la limite de mémoire a été dépassée - 10,25 Mo. </p><br><p>  D'accord, continuez - nous n'avons pas encore essayé Data.Array.Unboxed.  Ce type de tableaux est remarquable en ce que, contrairement à la norme, il peut stocker les valeurs elles-mêmes, plutôt que des pointeurs vers elles ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ).  De ce fait, ces baies prennent moins d'espace mémoire et sont plus efficaces.  Pour les utiliser, il suffit de modifier les types d'importation et de fonction, car <em>Data.Array</em> et <em>Data.Array.Unboxed</em> implémentent une interface de tableaux <em>IArray</em> immuables. </p><br><p>  Nous envoyons une solution - la consommation de mémoire a diminué de 4,5 fois pour atteindre 2,26 Mo, mais elle n'a pas dépassé la limite de temps - le temps d'exécution était de 1,09 seconde.  À quoi cela pourrait-il être lié?  À en juger par le fait que le temps d'exécution des tests restants reste le même, je pense que la raison n'est pas que le tableau non conditionné s'est avéré plus lent que le contenu, mais en particulier le système de test.  Il semble que la tâche soit interrompue dès qu'une des restrictions est violée.  Cependant, dans de très rares cas, cette implémentation réussit toujours le 19e test avec un résultat de 0,98 seconde, mais échoue au test numéro 20 également en raison du dépassement de la limite de temps. </p><br><p>  Après cela, j'ai essayé d'utiliser l'analogue dangereux de la fonction d'accumulation, qui en théorie devrait être plus rapide, diverses méthodes de mise en mémoire tampon ( <em>hSetBuffering :: Handle -&gt; BufferMode -&gt; fonction IO ()</em> ), des tableaux <em>IOArray</em> mutables, mais aucune de ces méthodes n'a <em>donné</em> de résultats . </p><br><p>  Je ne suis pas enclin à croire que les limites pour Haskell sont trop strictes, et j'espère qu'il existe toujours une solution qui passera tous les tests.  Dans le référentiel du projet, j'ai posté plusieurs versions différentes du code pour résoudre ce problème (avec Array et IOArray), ce sera peut-être le point de départ d'une solution qui passera tous les tests. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Même en dépit du fait que seulement cinq tâches sur six m'ont succombé, j'ai terminé ma tâche principale - pratiquer la programmation fonctionnelle.  Le moindre rôle a été joué par de sévères restrictions sur les ressources consommées par le programme, ce qui nous a obligés à chercher de plus en plus de nouvelles approches pour résoudre les problèmes.  J'espère que leur description sera utile pour ceux qui commencent tout juste leur voyage dans la programmation fonctionnelle </p><br><p>  L'approche fonctionnelle était-elle pratique pour résoudre de tels problèmes?  Honnêtement, j'ai une double impression.  D'une part, les solutions à la plupart des problèmes se sont avérées très concises et les outils expressifs de Haskell lui-même, ainsi que sa riche bibliothèque standard, ont joué un rôle important à cet égard.  D'un autre côté, on ne peut qu'admettre que dans la plupart des cas, la gestion des ressources consommées peut être un certain problème, ce qui ne permettra pas de résoudre le problème dans les restrictions données. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470790/">https://habr.com/ru/post/fr470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470778/index.html">Revue du disque Seagate ST2000DM008: «deux» rapides sans surprix</a></li>
<li><a href="../fr470780/index.html">La barre est prise - la nouvelle de Seagate pour le stockage</a></li>
<li><a href="../fr470782/index.html">Les données à la frontière: comment créer une nouvelle architecture informatique</a></li>
<li><a href="../fr470784/index.html">La conception des couleurs des mondes mystérieux de Dead Cells</a></li>
<li><a href="../fr470786/index.html">Préparation à la certification professionnelle du printemps. Sécurité printanière</a></li>
<li><a href="../fr470792/index.html">Entretien avec l'un des créateurs de Untitled Goose Game</a></li>
<li><a href="../fr470794/index.html">Laravel: expliquer les concepts de base. Première partie: théorie</a></li>
<li><a href="../fr470800/index.html">P - anticipation, ainsi que le programme préliminaire DUMP de Kazan. Voir les rapports qui ont passé la sélection du hachoir à viande</a></li>
<li><a href="../fr470802/index.html">Sauvegarde, partie 6: comparaison des outils de sauvegarde</a></li>
<li><a href="../fr470804/index.html">Alice Award: 5 idées du gagnant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>