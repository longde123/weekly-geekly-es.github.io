<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèæ üõÄüèº üîÉ Nous r√©solvons les t√¢ches Yandex.Interview dans un style fonctionnel üîà üë©‚Äçüåæ üöÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques mois, un article a paru dans le blog de Yandex qui parlait du passage de la section algorithmique de l'interview. Entre autres choses,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous r√©solvons les t√¢ches Yandex.Interview dans un style fonctionnel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p>  Il y a quelques mois, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article a</a> paru dans le blog de Yandex qui parlait du passage de la section algorithmique de l'interview.  Entre autres choses, dans cet article, un lien a √©t√© √©tabli vers un concours sp√©cial contenant des t√¢ches similaires √† celles propos√©es par Yandex √† leurs candidats. </p><br><p>  Ayant enregistr√© dans le syst√®me, mon attention a √©t√© imm√©diatement attir√©e par la capacit√© de r√©soudre des probl√®mes sur Haskell.  Le fait est que bien que j'aime la programmation dans cette langue, je n'ai pas progress√© plus loin que la mise en ≈ìuvre des t√¢ches de diff√©rents cours de plateformes √©ducatives en ligne.  Ayant d√©cid√© que leur solution pouvait √™tre un d√©fi int√©ressant et augmenterait mon niveau en tant que d√©veloppeur, j'ai proc√©d√© √† leur r√©solution. </p><br><p>  Peu importe ce qui en est finalement arriv√©, bienvenue au chat. </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A. Pierres et bijoux </h2><br><blockquote> Deux lignes de caract√®res latins minuscules sont donn√©es: la cha√Æne J et la cha√Æne S. Les caract√®res inclus dans la cha√Æne J sont des ¬´bijoux¬ª et inclus dans la cha√Æne S sont des ¬´pierres¬ª.  Il est n√©cessaire de d√©terminer combien de personnages de S sont simultan√©ment des ¬´joyaux¬ª.  Autrement dit, vous devez v√©rifier le nombre de caract√®res de S dans J. </blockquote><p>  La premi√®re t√¢che est un √©chauffement, nous allons le r√©soudre ¬´sur le front¬ª.  Nous d√©finissons la fonction <em>jewelleryCount :: String -&gt; String -&gt; Int</em> , qui, en utilisant la convolution de la liste pass√©e par le deuxi√®me argument, r√©sume tous les cas de l'√©l√©ment en cours de traitement dans la premi√®re liste.  √Ä ces fins, nous d√©finissons la fonction <em>elemInt en</em> fonction de la fonction <em>elem</em> , qui, contrairement √† la derni√®re, ne renverra pas True ou False, mais le nombre 0 ou 1. Dans la fonction principale, il vous suffit de lire deux lignes, de les passer √† la fonction correspondante et d'imprimer le r√©sultat.  Le verdict du syst√®me de test est OK, nous passons √† la deuxi√®me t√¢che. </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em>Le code source pour r√©soudre cette t√¢che et d'autres t√¢ches est √©galement disponible dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">r√©f√©rentiel github.</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B. Unit√©s cons√©cutives </h2><br><blockquote>  Il est n√©cessaire de trouver la plus longue s√©quence d'unit√©s dans le vecteur binaire et d'imprimer sa longueur. </blockquote><p>  Pour r√©soudre ce probl√®me, nous impl√©mentons une fonction r√©cursive qui parcourra la liste transf√©r√©e et calculera la longueur de la s√©quence requise.  Avec les arguments de la fonction, en plus de la liste elle-m√™me, nous passerons la longueur maximale actuelle et le nombre d'unit√©s cons√©cutives sur l'appel en cours.  Tout d'abord, nous d√©finissons la base de r√©cursivit√© sur la liste vide, puis l'√©tape de r√©cursivit√© elle-m√™me. </p><br><p>  Pour lire les donn√©es d'entr√©e, nous d√©finissons la fonction <em>getUserInputs :: IO [Char]</em> , dans laquelle nous lisons d'abord le nombre n - la taille de la liste, puis en utilisant le combinateur <em>replicateM</em> nous obtenons une fonction qui appellera la fonction <em>&lt;&lt;get&gt; getLine</em> n fois et fusionner les r√©sultats dans une liste . </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p>  Nous envoyons la d√©cision, le verdict est OK.  Nous continuons. </p><br><h2 id="c-udalenie-dublikatov">  C. Suppression des doublons </h2><br><blockquote>  Un tableau d'entiers 32 bits class√©s dans l'ordre non d√©croissant est donn√©.  Il est n√©cessaire d'en supprimer toutes les r√©p√©titions. </blockquote><p>  Commen√ßons par une impl√©mentation simple.  Nous d√©finissons une fonction initiale qui lit un nombre, l'imprime et le renvoie envelopp√© dans la monade IO.  Nous d√©finissons √©galement la fonction <em>deleteDoubles :: Int -&gt; Int -&gt; IO ()</em> , qui lit un nombre et l' <em>affiche</em> uniquement s'il n'est pas √©gal au deuxi√®me argument (nous passerons le nombre lu √† l'√©tape pr√©c√©dente).  Apr√®s cela, la fonction s'appelle r√©cursivement et passe ainsi au num√©ro suivant dans le flux d'entr√©e.  La base de r√©cursivit√© est le nombre de nombres √† lire, nous lui passerons le premier argument. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p>  Nous envoyons la solution, elle passe tous les tests, et il semblerait que nous pouvons passer √† la t√¢che suivante, mais √† mon avis, l'appel r√©cursif de la fonction travaillant dans la monade IO est plus d√©routant que concis.  Essayons de l'am√©liorer. </p><br><p>  Notez que, d'une mani√®re g√©n√©rale, vous pouvez d'abord lire la liste compl√®te des nombres (nous utiliserons le combinateur replicateM d√©j√† familier avec la deuxi√®me t√¢che), puis la passer √† une fonction pure qui filtre toutes les r√©p√©titions, et enfin imprimer le r√©sultat. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p>  J'envoie une solution, et la premi√®re d√©ception est que le programme ne passe pas le test 193 en raison du d√©passement de la limite de m√©moire utilis√©e.  L'erreur principale est de lire la liste enti√®re dans la m√©moire dans son ensemble.  Nous allons essayer d'√©viter cela et impl√©menterons un certain hybride des premi√®re et deuxi√®me versions. </p><br><p>  Notez que la t√¢che de suppression des doublons rappelle quelque peu une convolution associative de gauche: √† chaque √©tape, nous calculons une fonction qui, en fonction de l'√©l√©ment lu et de certains de ses r√©sultats, √† l'√©tape pr√©c√©dente d√©cide d'imprimer, puis passe √† la paire de valeurs suivante. </p><br><p>  Une fonction qui imprime ou n'imprime pas le r√©sultat en fonction de ses arguments, apr√®s quoi elle retourne son deuxi√®me argument, envelopp√© dans la monade IO, est assez simple, appelons-la √©tape: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p>  Nous avons compris s'il fallait imprimer ou non, selon les valeurs transmises, mais comment organiser la lecture?  Pour ce faire, nous utilisons la fonction de convolution monadique <em>foldM :: (T pliable, Monade m) =&gt; (b -&gt; a -&gt; mb) -&gt; b -&gt; ta -&gt; mb</em> , qui s'applique √† la liste des fonctions de lecture. <br>  Par type de fonction foldM, on note qu'√† chaque √©tape le ¬´d√©ballage¬ª du r√©sultat de l'application pr√©c√©dente de la fonction se produit sous le capot de foldM lui-m√™me.  Ainsi, √† chaque √©tape, il suffit de commencer un calcul monadique de l'√©l√©ment de liste actuel (en fait, lire le num√©ro suivant) √† l'aide de l'op√©rateur de <em>liaison</em> ( <em>&gt;&gt; =</em> ) et de le transmettre avec le num√©ro pr√©c√©dent √† l'√©tape.  En cons√©quence, nous obtenons le programme suivant </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D. G√©n√©ration de s√©quences de parenth√®ses </h2><br><blockquote>  √âtant donn√© un entier n.  Il est n√©cessaire de d√©river toutes les s√©quences de parenth√®ses correctes de longueur 2 ‚ãÖ n, ordonn√©es lexicographiquement (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ). <br>  Seules les parenth√®ses sont utilis√©es dans la t√¢che. <br>  Il est conseill√© d'obtenir une solution qui fonctionne dans un temps proportionnel au nombre total de s√©quences de parenth√®ses correctes dans la r√©ponse, et utilise en m√™me temps une capacit√© de m√©moire proportionnelle √† n. </blockquote><p>  Cette t√¢che, comme beaucoup d'autres, dans laquelle il est n√©cessaire de d√©river des s√©quences qui remplissent certaines conditions (par exemple, la t√¢che d'√©changer des pi√®ces de monnaie, d'organiser huit reines et d'autres, peut √™tre lue plus en d√©tail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> ), est r√©sum√©e succinctement en utilisant la liste monade.  En bref, cette approche est bas√©e sur la liaison monadique pour les listes, dont le sens est de r√©unir l'ensemble des op√©rations effectu√©es sur chaque √©l√©ment de la liste. </p><br><p>  D√©finissez une fonction r√©cursive <em>generate ':: Int -&gt; Int -&gt; [[Char]]</em> , qui prend le nombre de parenth√®ses √† mettre comme deuxi√®me argument, et le nombre de parenth√®ses ouvertes qui sont d√©j√† d√©finies pour √™tre d√©finies comme premier argument.  Pour l'√©tape de r√©cursivit√©, nous avons besoin de deux fonctions auxiliaires: <em>possible</em> - retourne une liste de crochets qui peuvent √™tre plac√©s dans l'√©tape suivante, et <em>√©tape</em> - fait un appel r√©cursif √† la fonction g√©n√©rer avec les param√®tres n√©cessaires. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p>  Nous envoyons la solution, et nous comprenons que nous n'avons pas pris en compte la restriction qui a √©t√© impos√©e sur la quantit√© de m√©moire utilis√©e par le programme - la solution ne passe pas le 14e test en raison du d√©passement de la limite de m√©moire utilis√©e. </p><br><p>  Nous modifions la fonction generate pour qu'au lieu de construire la liste enti√®re des s√©quences de parenth√®ses correctes, elle les affiche imm√©diatement √† l'√©cran.  Pour ce faire, nous devrons ajouter le troisi√®me argument √† la fonction - un fragment de la s√©quence construite pour l'√©tape en cours.  Je note que dans cette impl√©mentation, nous allons construire la s√©quence dans l'ordre inverse - cela nous permettra d'utiliser le constructeur de liste ( <em>:)</em> au lieu de l'op√©rateur de concat√©nation plus cher ( <em>++</em> ). </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E. Anagrammes </h2><br><blockquote>  Deux lignes sont donn√©es, compos√©es de lettres latines minuscules.  Il est n√©cessaire de d√©terminer si ces lignes sont des anagrammes, c'est-√†-dire si elles diff√®rent uniquement dans la s√©quence de caract√®res. </blockquote><p>  Pour r√©soudre ce probl√®me, nous comptons le nombre de fois qu'une lettre appara√Æt dans chaque ligne et comparons les r√©sultats.  Nous comprenons imm√©diatement que les listes standards ne nous conviennent pas, et il est n√©cessaire d'utiliser une structure de donn√©es qui nous permettrait d'acc√©der efficacement √† l'√©l√©ment par son index.  Il existe plusieurs types de donn√©es qui satisferaient nos conditions, mais nous utiliserons le tableau immuable standard <em>Data.Array</em> (il existe encore au moins divers tableaux mutables, ainsi que <em>Data.Vector</em> ). </p><br><p>  Pour construire les tableaux n√©cessaires, nous utilisons la fonction <em>hist :: (Ix a, Num b) =&gt; (a, a) -&gt; [a] -&gt; Array ab</em> , qui, selon la liste des √©l√©ments transf√©r√©s et la plage √† laquelle ces √©l√©ments doivent appartenir, forme un tableau, qui stocke le nombre de r√©p√©titions d'√©l√©ments de la liste.  Cette fonction, bien qu'elle ne soit pas incluse dans le module Data.Array, est souvent donn√©e √† titre d'exemple d'utilisation d'une autre fonction de biblioth√®que d√©j√† existante, accumArray.  Nous ne pouvons que copier son impl√©mentation et √©crire main - l'avantage de la comparaison pour l'√©galit√© pour <em>Array Char Int est</em> d√©j√† d√©fini.  J'attire votre attention sur une fonctionnalit√© int√©ressante - en tant qu'index, nous pouvons utiliser non seulement des entiers, mais tout repr√©sentant de la classe <em>Ix</em> .  Dans notre cas, Char joue un r√¥le naturel dans ce r√¥le. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  Fusionner k listes tri√©es </h2><br><blockquote>  √âtant donn√© k tableaux de nombres entiers non n√©gatifs tri√©s par ordre non d√©croissant, dont chacun ne d√©passe pas 100. Il est n√©cessaire de construire le r√©sultat de leur fusion: un tableau tri√© par ordre non d√©croissant contenant tous les √©l√©ments des tableaux k originaux. <br>  La longueur de chaque tableau ne d√©passe pas 10 ‚ãÖ k. <br>  Essayez de faire fonctionner la solution pour le temps k ‚ãÖ log (k) ‚ãÖ n, si nous supposons que les tableaux d'entr√©e sont de longueur n. </blockquote><p>  La fusion de deux listes tri√©es est une t√¢che de liste classique et est couverte dans de nombreux cours sur la programmation Haskell.  Par exemple, il peut √™tre r√©solu comme suit. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p>  Eh bien, nous pouvons fusionner deux listes.  Et que faire de la liste des listes?  Convoluez-le avec cette fonction!  Ainsi, nous combinerons toutes les listes en une seule, et nous n'aurons qu'√† l'imprimer. </p><br><div class="spoiler">  <b class="spoiler_title">Solution</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p>  Cependant, cette solution a deux probl√®mes graves - la complexit√© de calcul est sup√©rieure √† celle requise - <em>O (k ^ 2 ‚ãÖ n)</em> au lieu de <em>O (k ‚ãÖ log (k) ‚ãÖ n)</em> , en plus elle utilise beaucoup de m√©moire suppl√©mentaire.  En cons√©quence, cette solution √©choue au test num√©ro 17 en raison du d√©passement de la limite de m√©moire utilis√©e - 17,27 Mo au lieu des 10 Mo autoris√©s. </p><br><p>  Bien que nous ne pr√™tions pas attention au fait que les nombres fournis √† l'entr√©e appartiennent √† une plage limit√©e de valeurs, et nous continuons √† rechercher des solutions pour un cas plus g√©n√©ral. </p><br><p>  L'√©tape suivante consiste √† essayer de mettre en ≈ìuvre l'approche qui a √©t√© propos√©e dans l'article d'origine avec l'analyse de ces t√¢ches.  Permettez-moi de vous rappeler qu'il est bas√© sur l'utilisation d'une structure de donn√©es qui fournit un moyen efficace d'extraire l'√©l√©ment minimum.  En tant que telle structure, s√©lectionnez <em>Data.Set</em> .  Nous initialisons Set avec la liste des premiers √©l√©ments, puis √† chaque √©tape nous allons extraire et imprimer l'√©l√©ment minimum, puis ajouter l'√©l√©ment suivant de la liste correspondante.  De plus, nous aurons besoin d'une structure <em>Data.Sequence</em> pour stocker les listes elles-m√™mes.  Il a √©t√© choisi pour des raisons qu'√† chaque √©tape, il est n√©cessaire √† la fois d'avoir un acc√®s rapide √† la liste par son index (que la liste ne peut pas fournir), et de changer l'√©l√©ment de cet √©l√©ment sans avoir besoin de copier la structure enti√®re (qui en g√©n√©ral ne peut pas fournir de <em>donn√©es</em> immuables <em>. Array</em> ). </p><br><p>  Ainsi, nous avons le programme suivant: </p><br><div class="spoiler">  <b class="spoiler_title">Solution</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p>  Nous envoyons la solution et d√©couvrons que m√™me si le programme a commenc√© √† consommer beaucoup moins de m√©moire (10,26 Mo au lieu de 17,27 Mo au 17e test), il n'a toujours pas atteint la limite.  La raison √† cela r√©side dans le fait qu'avec cette d√©cision, d'une mani√®re ou d'une autre, nous devons lire la totalit√© des donn√©es d'entr√©e dans la m√©moire.  Essayons d'√©viter cela √† l'aide de la troisi√®me solution √† ce probl√®me - le tri par comptage. </p><br><p>  Nous avons d√©j√† effectu√© le comptage du nombre de caract√®res entrants lors de la r√©solution du probl√®me d'anagramme pr√©c√©dent.  De plus, comme pour le r√©soudre, nous utiliserons <em>Data.Array</em> .  Tout d'abord, nous impl√©mentons la fonction <em>addToArray :: Array Int Int -&gt; [Int] -&gt; Array Int Int</em> , qui forme un tableau bas√© sur celui existant en augmentant les valeurs aux indices qui correspondent aux valeurs de la liste. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p>  Ensuite, nous utiliserons l'approche que nous connaissons dans le probl√®me de la suppression des r√©p√©titions - en utilisant la convolution monadique, en appliquant s√©quentiellement la fonction <em>addToArray</em> √† <em>k</em> tableaux source.  Et ... nous obtenons le m√™me r√©sultat de 10,26 Mo lors du 17e test.  Et puis il est temps de se rappeler que <em>foldl</em> (dont l'analogue est <em>foldM</em> ) selon l'ordre de r√©duction accept√© va d'abord √©tendre toute la cha√Æne des expressions imbriqu√©es et ensuite seulement proc√©der √† leur calcul actif.  Comme vous le savez, pour lutter contre ce fait, le module <em>Data.List</em> impl√©mente la fonction <em>foldl '</em> , qui utilise la fonction <em>seq :: a -&gt; b -&gt; b</em> , qui transforme d'abord le premier argument en forme normale de t√™te faible, c'est-√†-dire le r√©duit √† la partie externe - la valeur de la fonction ou du constructeur, puis renvoie la seconde ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ).  Nous n'avons d'autre choix que d'impl√©menter la fonction <em>foldM 'de</em> mani√®re <em>ind√©pendante</em> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p>  En cons√©quence, la quantit√© de m√©moire utilis√©e lors du 17e test a presque diminu√© de moiti√© et s'√©l√®ve √† 5,64 Mo!  Bien que les 17e et 18e tests aient √©t√© r√©ussis, cette impl√©mentation n'a pas r√©ussi le 19e test pour la m√™me raison que la limite de m√©moire a √©t√© d√©pass√©e - 10,25 Mo. </p><br><p>  D'accord, continuez - nous n'avons pas encore essay√© Data.Array.Unboxed.  Ce type de tableaux est remarquable en ce que, contrairement √† la norme, il peut stocker les valeurs elles-m√™mes, plut√¥t que des pointeurs vers elles ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ).  De ce fait, ces baies prennent moins d'espace m√©moire et sont plus efficaces.  Pour les utiliser, il suffit de modifier les types d'importation et de fonction, car <em>Data.Array</em> et <em>Data.Array.Unboxed</em> impl√©mentent une interface de tableaux <em>IArray</em> immuables. </p><br><p>  Nous envoyons une solution - la consommation de m√©moire a diminu√© de 4,5 fois pour atteindre 2,26 Mo, mais elle n'a pas d√©pass√© la limite de temps - le temps d'ex√©cution √©tait de 1,09 seconde.  √Ä quoi cela pourrait-il √™tre li√©?  √Ä en juger par le fait que le temps d'ex√©cution des tests restants reste le m√™me, je pense que la raison n'est pas que le tableau non conditionn√© s'est av√©r√© plus lent que le contenu, mais en particulier le syst√®me de test.  Il semble que la t√¢che soit interrompue d√®s qu'une des restrictions est viol√©e.  Cependant, dans de tr√®s rares cas, cette impl√©mentation r√©ussit toujours le 19e test avec un r√©sultat de 0,98 seconde, mais √©choue au test num√©ro 20 √©galement en raison du d√©passement de la limite de temps. </p><br><p>  Apr√®s cela, j'ai essay√© d'utiliser l'analogue dangereux de la fonction d'accumulation, qui en th√©orie devrait √™tre plus rapide, diverses m√©thodes de mise en m√©moire tampon ( <em>hSetBuffering :: Handle -&gt; BufferMode -&gt; fonction IO ()</em> ), des tableaux <em>IOArray</em> mutables, mais aucune de ces m√©thodes n'a <em>donn√©</em> de r√©sultats . </p><br><p>  Je ne suis pas enclin √† croire que les limites pour Haskell sont trop strictes, et j'esp√®re qu'il existe toujours une solution qui passera tous les tests.  Dans le r√©f√©rentiel du projet, j'ai post√© plusieurs versions diff√©rentes du code pour r√©soudre ce probl√®me (avec Array et IOArray), ce sera peut-√™tre le point de d√©part d'une solution qui passera tous les tests. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  M√™me en d√©pit du fait que seulement cinq t√¢ches sur six m'ont succomb√©, j'ai termin√© ma t√¢che principale - pratiquer la programmation fonctionnelle.  Le moindre r√¥le a √©t√© jou√© par de s√©v√®res restrictions sur les ressources consomm√©es par le programme, ce qui nous a oblig√©s √† chercher de plus en plus de nouvelles approches pour r√©soudre les probl√®mes.  J'esp√®re que leur description sera utile pour ceux qui commencent tout juste leur voyage dans la programmation fonctionnelle </p><br><p>  L'approche fonctionnelle √©tait-elle pratique pour r√©soudre de tels probl√®mes?  Honn√™tement, j'ai une double impression.  D'une part, les solutions √† la plupart des probl√®mes se sont av√©r√©es tr√®s concises et les outils expressifs de Haskell lui-m√™me, ainsi que sa riche biblioth√®que standard, ont jou√© un r√¥le important √† cet √©gard.  D'un autre c√¥t√©, on ne peut qu'admettre que dans la plupart des cas, la gestion des ressources consomm√©es peut √™tre un certain probl√®me, ce qui ne permettra pas de r√©soudre le probl√®me dans les restrictions donn√©es. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470790/">https://habr.com/ru/post/fr470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470778/index.html">Revue du disque Seagate ST2000DM008: ¬´deux¬ª rapides sans surprix</a></li>
<li><a href="../fr470780/index.html">La barre est prise - la nouvelle de Seagate pour le stockage</a></li>
<li><a href="../fr470782/index.html">Les donn√©es √† la fronti√®re: comment cr√©er une nouvelle architecture informatique</a></li>
<li><a href="../fr470784/index.html">La conception des couleurs des mondes myst√©rieux de Dead Cells</a></li>
<li><a href="../fr470786/index.html">Pr√©paration √† la certification professionnelle du printemps. S√©curit√© printani√®re</a></li>
<li><a href="../fr470792/index.html">Entretien avec l'un des cr√©ateurs de Untitled Goose Game</a></li>
<li><a href="../fr470794/index.html">Laravel: expliquer les concepts de base. Premi√®re partie: th√©orie</a></li>
<li><a href="../fr470800/index.html">P - anticipation, ainsi que le programme pr√©liminaire DUMP de Kazan. Voir les rapports qui ont pass√© la s√©lection du hachoir √† viande</a></li>
<li><a href="../fr470802/index.html">Sauvegarde, partie 6: comparaison des outils de sauvegarde</a></li>
<li><a href="../fr470804/index.html">Alice Award: 5 id√©es du gagnant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>