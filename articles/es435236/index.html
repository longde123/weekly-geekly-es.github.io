<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèΩ üßúüèº üçΩÔ∏è Byte-machine para el fuerte (y no solo) en nativos americanos (parte 3) üìª üÜî üë®üèæ‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ha llegado el a√±o 2019. Las vacaciones de a√±o nuevo est√°n llegando a su fin. Es hora de comenzar a recordar bytes, comandos, variables, bucles ... 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Byte-machine para el fuerte (y no solo) en nativos americanos (parte 3)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435236/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="imagen"><br><br>  Ha llegado el a√±o 2019. Las vacaciones de a√±o nuevo est√°n llegando a su fin.  Es hora de comenzar a recordar bytes, comandos, variables, bucles ... <br><br>  Algo que ya he olvidado con estas vacaciones.  Hay que recordar juntos! <br><br>  Hoy haremos un int√©rprete para nuestra m√°quina de bytes.  Este es el tercer art√≠culo, las primeras partes est√°n aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte 2</a> . <br><br>  ¬°Feliz a√±o nuevo a todos y bienvenidos al corte! <br><a name="habracut"></a><br>  Para empezar, responder√© preguntas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">fpauk</a> .  Estas preguntas son absolutamente correctas.  Ahora la arquitectura de esta m√°quina de bytes es tal que trabajamos con direcciones de procesador directo.  Pero en el c√≥digo de bytes estas direcciones no est√°n, se forman despu√©s del inicio del sistema.  Una vez que se inicia el sistema, podemos crear cualquier puntero, y este c√≥digo funcionar√° correctamente en cualquier plataforma.  Por ejemplo, la direcci√≥n de una variable o matriz se puede obtener con el comando var0.  Este comando funcionar√° en cualquier plataforma y devolver√° la direcci√≥n correcta espec√≠fica de esta plataforma.  Entonces puedes trabajar con esta direcci√≥n como quieras. <br><br>  Pero a√∫n as√≠, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">fpauk tiene</a> raz√≥n.  La direcci√≥n no se puede almacenar en bytecode.  Resulta que podemos escribir c√≥digo independiente de la plataforma, pero para esto debemos hacer algunos esfuerzos.  En particular, aseg√∫rese de que las direcciones no est√©n en el c√≥digo de bytes.  Y pueden ingresar, por ejemplo, si guarda el c√≥digo compilado en un archivo.  Contendr√° datos y puede ser direcciones.  Por ejemplo, los valores de las variables aqu√≠, contexto y otros. <br><br>  Para deshacerse de tal problema, debe hacer que las direcciones sean virtuales.  El direccionamiento del procesador x86 es bastante potente y, en la mayor√≠a de los casos, ni siquiera agregar√° comandos adicionales.  Pero a√∫n as√≠, continuar√© en la arquitectura actual, con direcciones absolutas.  Y luego, cuando lleguemos a las pruebas, ser√° posible rehacer las direcciones en virtuales, y ver c√≥mo esto afectar√° el rendimiento.  Esto es interesante <br><br><h4>  Calentar </h4><br>  Y ahora un poco de ejercicio.  Hagamos otra porci√≥n de comandos de bytes peque√±os pero √∫tiles.  Estos ser√°n los comandos nip, emit, 1+, +!, -!, Count, palabras de trabajo con la pila de retorno r&gt;,&gt; r, r @, un literal de cadena (") y palabras constantes 1, 2, 3, 4, 8. No olvide incluirlos en la tabla de comandos. <br><br><div class="spoiler">  <b class="spoiler_title">Aqu√≠ est√° el c√≥digo para estos comandos</b> <div class="spoiler_text"><pre><code class="cpp hljs">b_nip = <span class="hljs-number"><span class="hljs-number">0x39</span></span> bcmd_nip: pop rax mov [rsp], rax jmp _next b_emit = <span class="hljs-number"><span class="hljs-number">0x81</span></span> bcmd_emit: pop rax mov rsi, offset emit_buf #   mov [rsi], al mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov rdx, <span class="hljs-number"><span class="hljs-number">1</span></span> #   push r8 syscall #   pop r8 jmp _next b_wp = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_wp: incq [rsp] jmp _next b_setp = <span class="hljs-number"><span class="hljs-number">0x48</span></span> bcmd_setp: pop rcx pop rax add [rcx], rax jmp _next b_setm = <span class="hljs-number"><span class="hljs-number">0x49</span></span> bcmd_setm: pop rcx pop rax sub [rcx], rax jmp _next b_2r = <span class="hljs-number"><span class="hljs-number">0x60</span></span> bcmd_2r: pop rax sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], rax jmp _next b_r2 = <span class="hljs-number"><span class="hljs-number">0x61</span></span> bcmd_r2: push [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next b_rget = <span class="hljs-number"><span class="hljs-number">0x62</span></span> bcmd_rget: push [rbp] jmp _next b_str = <span class="hljs-number"><span class="hljs-number">0x82</span></span> bcmd_str: movzx rax, byte ptr [r8] lea r8, [r8 + rax + <span class="hljs-number"><span class="hljs-number">1</span></span>] jmp _next b_count = <span class="hljs-number"><span class="hljs-number">0x84</span></span> bcmd_count: pop rcx movzx rax, byte ptr [rcx] inc rcx push rcx push rax jmp _next b_num1 = <span class="hljs-number"><span class="hljs-number">0x03</span></span> bcmd_num1: push <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _next b_num2 = <span class="hljs-number"><span class="hljs-number">0x04</span></span> bcmd_num2: push <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_num3 = <span class="hljs-number"><span class="hljs-number">0x05</span></span> bcmd_num3: push <span class="hljs-number"><span class="hljs-number">3</span></span> jmp _next b_num4 = <span class="hljs-number"><span class="hljs-number">0x06</span></span> bcmd_num4: push <span class="hljs-number"><span class="hljs-number">4</span></span> jmp _next b_num8 = <span class="hljs-number"><span class="hljs-number">0x07</span></span> bcmd_num8: push <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br></div></div><br>  El comando nip elimina la palabra debajo de la parte superior de la pila.  Es equivalente a intercambiar comandos de soltar.  Esto a veces puede ser √∫til. <br><br>  El comando emitir empuja a un personaje de la pila.  Utiliza la misma llamada al sistema n√∫mero 1, el car√°cter se coloca en un b√∫fer con una longitud de 1. <br><br>  El comando de conteo es muy simple: toma la direcci√≥n de la l√≠nea con el contador de la pila y la convierte en dos valores: la direcci√≥n de la l√≠nea sin el contador y la longitud. <br><br>  Los comandos b_2r, b_r2, b_rget son las palabras Fort r&gt;,&gt; r, r @.  El primero toma la palabra de la pila de retorno y la coloca en la pila aritm√©tica.  El segundo lleva a cabo la operaci√≥n opuesta.  El tercero copia la palabra de la pila de retorno, la coloca en la aritm√©tica, la pila de retorno no cambia. <br><br>  Los comandos b_setp y b_setm son las palabras +!  y -! .. Toman el valor y la direcci√≥n de la pila, y modifican la palabra en la direcci√≥n especificada, agregando o eliminando el valor de la pila. <br><br>  El comando b_str tiene un par√°metro de longitud arbitraria: una l√≠nea con un contador.  Esta l√≠nea est√° en el bytecode despu√©s del byte de comando, y el comando simplemente empuja la direcci√≥n de esta l√≠nea en la pila.  De hecho, este es un literal de cadena. <br><br>  El resto del equipo, creo, no necesita comentarios. <br><br>  Tambi√©n haremos un comando para imprimir una cadena constante (. "). Lo implementaremos como un punto de entrada para escribir, de la siguiente manera: <br><br><pre> <code class="cpp hljs">b_strp = <span class="hljs-number"><span class="hljs-number">0x83</span></span> bcmd_strp: movsx rax, byte ptr [r8] inc r8 push rax push r8 add r8, rax b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx #   pop rsi #   push r8 syscall #   pop r8 jmp _next</code> </pre><br>  Este comando est√° estructurado de manera similar a b_str.  Solo que ella no pone nada en la pila.  La l√≠nea ubicada detr√°s de este comando como par√°metro simplemente se muestra al usuario. <br><br>  El calentamiento ha terminado, ha llegado el momento de algo m√°s serio.  Tratemos con los generadores de palabras y otros comandos var. <br><br><h4>  Palabras generadoras </h4><br>  Recordemos las variables.  Sabemos c√≥mo est√°n organizados a nivel de bytecode (comando var0).  Para crear una nueva variable, el fuerte utiliza la siguiente construcci√≥n: <br><br><pre> <code class="cpp hljs">variable &lt; &gt;</code> </pre><br>  Despu√©s de realizar esta secuencia, se crea una nueva palabra &lt;nombre de variable&gt;.  La ejecuci√≥n de esta nueva palabra empuja la direcci√≥n en la pila para almacenar el valor de la variable.  Tambi√©n hay constantes en el fuerte, se crean as√≠: <br><br><pre> <code class="cpp hljs">&lt;&gt; constant &lt; &gt;</code> </pre><br>  Despu√©s de crear la constante, la ejecuci√≥n de la palabra &lt;nombre constante&gt; se coloca en la pila &lt;valor&gt;. <br><br>  Entonces, tanto la palabra variable como la palabra constante son palabras generadoras.  Est√°n dise√±ados para crear nuevas palabras.  En un fuerte, tales palabras se describen usando create ... does&gt; construct. <br><br>  Las variables y las constantes se pueden definir de la siguiente manera: <br><br><pre> <code class="cpp hljs">: variable create <span class="hljs-number"><span class="hljs-number">0</span></span> , does&gt; ; : constant create , does&gt; @ ;</code> </pre><br>  ¬øQu√© significa todo esto? <br><br>  La palabra crear, cuando se ejecuta, crea una nueva palabra con el nombre que tomar√° cuando se ejecute desde la secuencia de entrada.  Despu√©s de la creaci√≥n, se ejecuta una secuencia de palabras antes de que la palabra lo haga&gt;.  Pero en el momento de la ejecuci√≥n de esta palabra, lo que se escribe despu√©s de&gt; se ejecuta.  Al mismo tiempo, la direcci√≥n de datos ya estar√° en la pila (como se dice en el fuerte, "campos de datos"). <br><br>  Por lo tanto, cuando se crea una variable, se ejecuta la secuencia "0": esta es la reserva de una palabra de m√°quina con relleno cero.  Y cuando se ejecuta la palabra creada, no se hace nada (despu√©s de hacer&gt; no hay nada).  La direcci√≥n de memoria donde se almacena el valor simplemente permanece en la pila. <br><br>  En la definici√≥n de una constante, se reserva una palabra con un valor que se llena en la pila.  Cuando se ejecuta la palabra creada, se ejecuta "@", que recupera el valor en la direcci√≥n especificada. <br><br>  Ahora pensemos en c√≥mo se puede organizar la palabra que creamos.  Empuja la direcci√≥n de datos en la pila (como var0) y luego transfiere el control a una direcci√≥n espec√≠fica, bytecode.  El comando var0 vuelve inmediatamente.  Pero en este caso, necesitamos hacer no un retorno, sino, de hecho, una transici√≥n. <br><br>  Una vez m√°s, formular√© lo que hay que hacer: <br><br><ul><li>  poner la direcci√≥n de datos en la pila </li><li>  saltar a un fragmento de c√≥digo despu√©s de&gt; </li></ul><br>  Resulta que solo necesita transferir el control a otra direcci√≥n de bytecode, pero primero coloque la direcci√≥n del siguiente byte (R8) en la pila. <br><br>  ¬°Es casi un comando de rama!  Y aqu√≠ ella no est√° sola.  Ya tenemos branch8 y branch16.  Nombraremos los nuevos comandos var8 y var16, y dejaremos que estos sean solo los puntos de entrada a los comandos de bifurcaci√≥n.  Ahorramos en la transici√≥n al equipo de transici√≥n :) Entonces, ser√° as√≠: <br><br><pre> <code class="cpp hljs">b_var8 = <span class="hljs-number"><span class="hljs-number">0x29</span></span> bcmd_var8: push r8 b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_var16 = <span class="hljs-number"><span class="hljs-number">0x30</span></span> bcmd_var16: push r8 b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre><br>  En el buen sentido, el comando var32 seguir√° funcionando, y var64 tambi√©n.  No tenemos transiciones tan largas, ya que las transiciones ordinarias no son tan largas.  Pero para el comando var, este es un caso muy realista.  Pero por ahora, no haremos estos comandos.  Lo haremos m√°s tarde, si es necesario. <br><br>  Con los generadores de palabras resueltos.  Era el turno de decidir sobre el diccionario. <br><br><h4>  Vocabulario </h4><br>  Por lo general, cuando hablan de manera simplista sobre el diccionario fort, se presenta en forma de una lista unidireccional de entradas de diccionario.  De hecho, todo es un poco m√°s complicado, ya que el fuerte admite muchos diccionarios.  De hecho, son un √°rbol.  La b√∫squeda de una palabra en dicho √°rbol comienza con una "hoja": esta es la √∫ltima palabra en el diccionario actual.  El diccionario actual est√° definido por la variable de contexto, y la direcci√≥n de la √∫ltima palabra est√° en la palabra del diccionario.  Se usa otra variable para administrar los diccionarios: define un diccionario donde se agregar√°n nuevas palabras.  Por lo tanto, se puede instalar un diccionario para una b√∫squeda y otro para incluir palabras nuevas. <br><br>  Para nuestro caso simple, ser√≠a posible no hacer el soporte de muchos diccionarios, pero decid√≠ no simplificar nada.  De hecho, para comprender el c√≥digo de bytes, la m√°quina de bytes, no es necesario saber lo que se describe en esta secci√≥n.  Por lo tanto, a quienes no les interese, simplemente pueden omitir esta secci√≥n.  Bueno, qui√©n quiere saber los detalles, ¬°adelante! <br><br>  Inicialmente, hay un diccionario b√°sico llamado adelante.  Esto significa que existe tal palabra.  Esta palabra tambi√©n se llama "diccionario", hay cierta confusi√≥n.  Por lo tanto, cuando se trata de una palabra, la llamar√© una palabra del diccionario. <br><br>  Se crean nuevos diccionarios usando esta construcci√≥n: <br><br><pre> <code class="cpp hljs">vocabulary &lt;  &gt;</code> </pre><br>  Esto crea una palabra con el nombre &lt;nombre del diccionario creado&gt;.  Cuando se ejecuta, esta palabra establecer√° el diccionario creado como el diccionario inicial para la b√∫squeda. <br><br>  De hecho, en la palabra del diccionario hay un enlace al √∫ltimo art√≠culo de este diccionario, con el que comienza la b√∫squeda.  Y en el momento de la ejecuci√≥n, esta palabra del diccionario escribe un enlace a su campo de datos en la variable de contexto. <br><br>  M√°s adelante ser√° posible crear el vocabulario de palabras, que en el fuerte, en la implementaci√≥n actual, se describe de manera bastante simple: <br><br><pre> <code class="cpp hljs">: vocabulary create context @ , does&gt; context ! ;</code> </pre><br>  Entonces, crea la palabra adelante.  Usaremos el comando var8.  Bytecode "contexto!"  colocar justo despu√©s del campo de datos: <br><br><pre> <code class="cpp hljs">forth: .byte b_var8 .byte does_voc - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # &lt;--      .      ,    -    . does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit</code> </pre><br>  Ahora volvamos a crear el diccionario en s√≠. <br><br>  En general, en una fortaleza, una descripci√≥n de una palabra en la memoria se denomina "entrada de diccionario".  En t√©rminos ordinarios, dir√≠a que hay un t√≠tulo de art√≠culo y su c√≥digo.  Pero no todo es habitual en un fuerte, all√≠ se llama "campo de nombre", "campo de comunicaci√≥n", "campo de c√≥digo" y "campo de datos".  Tratar√© de decirte qu√© significa todo esto en t√©rminos tradicionales. <br><br>  El campo de nombre es el nombre de la palabra, "l√≠nea con un contador".  Es como en el viejo pascal: byte de longitud de cadena, luego cadena.  El campo de enlace es un enlace al art√≠culo anterior.  Anteriormente, solo hab√≠a una direcci√≥n, pero tendremos un c√≥digo independiente de la plataforma, y ‚Äã‚Äãesto ser√° un desplazamiento.  El campo de c√≥digo, tradicionalmente en el fuerte, es el c√≥digo de m√°quina (cuando la implementaci√≥n est√° en una l√≠nea directa), para las palabras fuera del n√∫cleo se llamaba _call.  Solo tendremos un bytecode.  Y el campo de datos es para palabras que contienen datos, por ejemplo, para variables o constantes.  Por cierto, el diccionario de palabras tambi√©n se refiere a √©l. <br><br>  Para el compilador, todav√≠a necesitamos banderas.  Por lo general, un fuerte solo necesita una bandera, inmediata, y se coloca en un byte largo (a veces hay otra, oculta).  Pero esto es para el c√≥digo cosido directo, donde el control del procesador se transfiere cuando se llama al campo de c√≥digo.  Y tenemos diferentes palabras: c√≥digo de bytes y c√≥digo de m√°quina, y se necesitan al menos dos, o incluso tres, banderas. <br><br>  ¬øCu√°nto se necesita para el campo de la comunicaci√≥n?  Al principio, quer√≠a usar 16 bits.  Este es un enlace a la palabra anterior, y la palabra definitivamente tiene menos de 64 Kb.  Pero luego record√© que la palabra puede contener datos de casi cualquier tama√±o.  Y adem√°s, en presencia de varios diccionarios, el enlace puede pasar por muchas palabras.  Resulta que en la mayor√≠a de los casos, 8 bits son suficientes, pero puede haber 16 y 32. E incluso 64 bits, si hay datos de m√°s de 4 GB.  Bueno, hagamos soporte para todas las opciones.  Qu√© opci√≥n se utiliza: poner en las banderas.  Resulta al menos 4 banderas: el atributo inmediato, el atributo de la palabra central y 2 bits por variante del campo de comunicaci√≥n utilizado.  Es necesario usar un byte separado para las banderas, de ninguna otra manera. <br><br>  Definimos las banderas de la siguiente manera: <br><br><pre> <code class="cpp hljs">f_code = <span class="hljs-number"><span class="hljs-number">0x80</span></span> f_immediate = <span class="hljs-number"><span class="hljs-number">0x60</span></span></code> </pre><br>  El indicador f_code ser√° para las palabras del n√∫cleo escritas en ensamblador, el indicador f_immediate ser√° √∫til para el compilador, sobre esto en el pr√≥ximo art√≠culo.  Y los dos bits menos significativos determinar√°n la longitud del campo de comunicaci√≥n (1, 2, 4 u 8 bytes). <br><br>  Entonces, el t√≠tulo del art√≠culo ser√° as√≠: <br><br><ul><li>  banderas (1 byte) </li><li>  campo de comunicaci√≥n (1-8 bytes) </li><li>  nombre longitud byte </li><li>  nombre (1-255 bytes) </li></ul><br>  Hasta este punto, no he usado las capacidades del ensamblador "macro".  Y ahora los necesitamos.  As√≠ es como obtuve una macro con el elemento de nombre para formar el t√≠tulo de la palabra: <br><br><pre> <code class="cpp hljs">.macro item name, flags = <span class="hljs-number"><span class="hljs-number">0</span></span> link = . - p_item <span class="hljs-number"><span class="hljs-number">9</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags .byte link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">1</span></span> .word . - p_item .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> . - p_item .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">3</span></span> .quad . - p_item .endif p_item = <span class="hljs-number"><span class="hljs-number">9b</span></span> .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\name"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm</code> </pre><br>  Esta macro utiliza el valor p_item: esta es la direcci√≥n de la entrada anterior del diccionario.  Este valor al final se actualiza para uso futuro: p_item = 9b.  Aqu√≠ 9b es una etiqueta, no un n√∫mero, no confunda :) La macro tiene dos par√°metros: el nombre de la palabra y las banderas (opcional).  Al comienzo de la macro, se calcula el desplazamiento de la palabra anterior.  Luego, dependiendo del tama√±o del desplazamiento, se compilan las banderas y el campo de comunicaci√≥n del tama√±o deseado.  Luego, el byte de la longitud del nombre y el nombre mismo. <br><br>  Defina antes de la primera palabra p_item de la siguiente manera: <br><br><pre> <code class="cpp hljs">p_item = .</code> </pre><br>  El punto es la direcci√≥n de compilaci√≥n actual en ensamblador.  Como resultado de esta definici√≥n, la primera palabra se referir√° a s√≠ misma (el campo de comunicaci√≥n ser√° 0).  Esta es una se√±al del fin de los diccionarios. <br><br>  Por cierto, ¬øqu√© habr√° en el campo de c√≥digo de las palabras del n√∫cleo?  Como m√≠nimo, debe guardar el c√≥digo de comando en alguna parte.  Decid√≠ seguir el camino m√°s simple.  Para las palabras del n√∫cleo tambi√©n habr√° un c√≥digo de bytes.  Para la mayor√≠a de los equipos, esto ser√° solo un comando de byte, seguido de b_exit.  Por lo tanto, para el int√©rprete, el indicador f_code no necesita ser analizado, y los comandos para √©l no diferir√°n de ninguna manera.  Solo necesita llamar al c√≥digo de bytes para todos. <br><br>  Hay otra ventaja de esta opci√≥n.  Para los comandos con par√°metros, puede especificar par√°metros seguros.  Por ejemplo, si invoca el comando iluminado en implementaciones de Fort con c√≥digo cosido directo, el sistema se bloquear√°.  Y aqu√≠ se escribir√° all√≠, por ejemplo, iluminado 0, y esta secuencia simplemente pondr√° 0 en la pila.  Incluso para la rama se puede hacer de forma segura! <br><br><pre> <code class="cpp hljs"> .byte branch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit</code> </pre><br>  Con tal llamada habr√° algunos gastos generales, pero para el int√©rprete no ser√°n significativos.  Y el compilador analizar√° las banderas y compilar√° el c√≥digo correcto y r√°pido. <br><br>  La primera palabra, por supuesto, ser√° la palabra "adelante", el vocabulario b√°sico que estamos creando.  Aqu√≠, solo ingrese el comando var √∫til con un enlace al c√≥digo despu√©s de hacer&gt;.  Ya cit√© este c√≥digo en la secci√≥n anterior, pero lo repetir√© nuevamente, con el t√≠tulo: <br><br><pre> <code class="cpp hljs">p_item = . item forth .byte b_var8 .byte does_voc - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">0</span></span> does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit</code> </pre><br>  E inmediatamente crearemos las variables de contexto y las necesitamos para buscar palabras: <br><br><pre> <code class="cpp hljs"> item .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item context context: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Y ahora, debe ser paciente y escribir un t√≠tulo para cada palabra que escribimos en ensamblador con el indicador f_code: <br><br><pre> <code class="cpp hljs"> item <span class="hljs-number"><span class="hljs-number">0</span></span>, f_code .byte b_num0 .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>, f_code .byte b_num1 .byte b_exit ... item <span class="hljs-number"><span class="hljs-number">1</span></span>-, f_code .byte b_wm .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>+, f_code .byte b_wp .byte b_exit item +, f_code .byte b_add .byte b_exit item -, f_code .byte b_sub .byte b_exit item *, f_code .byte b_mul .byte b_exit</code> </pre><br>  Y as√≠ sucesivamente ... <br><br>  Con los equipos escritos en bytecode es a√∫n m√°s f√°cil.  Es suficiente agregar solo un encabezado antes del c√≥digo de bytes, al igual que la palabra, por ejemplo: <br><br><pre> <code class="cpp hljs"> item hold hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint ...</span></span></code> </pre><br>  Para comandos con par√°metros, haremos par√°metros seguros.  Por ejemplo, deje que los comandos lite devuelvan el n√∫mero Pi, si alguien los llama de forma interactiva, habr√° una pascua :) <br><br><pre> <code class="cpp hljs"> item lit8, f_code .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">31</span></span> .byte b_exit item lit16, f_code .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">31415</span></span> .byte b_exit item lit32, f_code .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item lit64, f_code .byte b_lit64 .quad <span class="hljs-number"><span class="hljs-number">31415926535</span></span> .byte b_exit</code> </pre><br>  La √∫ltima palabra en la lista har√° que la palabra adi√≥s simb√≥licamente.  Pero a√∫n necesitamos inicializar la direcci√≥n de esta palabra en el campo de datos.  Para obtener la direcci√≥n de esta palabra, use el comando var0: <br><br><pre> <code class="cpp hljs">last_item: .byte b_var0 item bye, f_code .byte b_bye</code> </pre><br>  En este dise√±o, si llamamos a la direcci√≥n last_item en el bytecode, obtendremos la direcci√≥n de la palabra bye.  Para escribirlo en los campos de datos de la palabra adelante, ejec√∫telo y la direcci√≥n deseada estar√° en contexto.  Por lo tanto, el c√≥digo de inicializaci√≥n del sistema ser√° as√≠: <br><br><pre> <code class="cpp hljs">forth last_item context @ !</code> </pre><br>  Y ahora procedamos directamente al int√©rprete.  Primero, necesitamos trabajar con el b√∫fer de entrada y extraer palabras de √©l.  D√©jame recordarte que el int√©rprete en el fuerte es muy simple.  Extrae las palabras del b√∫fer de entrada en secuencia, trata de encontrarlas.  Si se encuentra la palabra, el int√©rprete la inicia para su ejecuci√≥n. <br><br><h4>  B√∫fer de entrada y extracci√≥n de palabras </h4><br>  Para ser sincero, no quiero pasar mucho tiempo estudiando los est√°ndares del fuerte.  Pero a√∫n as√≠ intentar√© hacerlo lo m√°s cerca posible de ellos, principalmente de memoria.  Si los expertos de fort ver√°n una fuerte discrepancia aqu√≠, escriba, la solucionar√©. <br><br>  El fuerte tiene tres variables para trabajar con el b√∫fer: tib, #tib y&gt; in.  La variable tib empuja la direcci√≥n del b√∫fer de entrada en la pila.  La variable #tib empuja el n√∫mero de caracteres que est√°n en el b√∫fer a la pila.  Y la variable&gt; in contiene el desplazamiento en el b√∫fer de entrada, m√°s all√° del cual se encuentra el texto sin formato.  Define estas variables. <br><br><pre> <code class="cpp hljs"> item tib .byte b_var0 v_tib: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-meta"><span class="hljs-meta">#tib .byte b_var0 v_ntib: .quad 0 item &gt;in .byte b_var0 v_in: .quad 0</span></span></code> </pre><br>  A continuaci√≥n hacemos la palabra blword.  Esta palabra, usando las variables especificadas, obtiene la siguiente palabra del flujo de entrada.  Un espacio se usa como delimitadores y todos los caracteres con un c√≥digo menor que un espacio.  Esta palabra estar√° en ensamblador.  Despu√©s de la depuraci√≥n, result√≥ as√≠: <br><br><pre> <code class="cpp hljs">b_blword = <span class="hljs-number"><span class="hljs-number">0xF0</span></span> bcmd_blword: mov rsi, v_tib #    mov rdx, rsi #   RDX       mov rax, v_in #     mov rcx, v_ntib #    add rsi, rax #  RSI -      sub rcx, rax #     jz <span class="hljs-number"><span class="hljs-number">3f</span></span> word2: lodsb #   AL  RSI   cmp al, <span class="hljs-string"><span class="hljs-string">' '</span></span> ja <span class="hljs-number"><span class="hljs-number">1f</span></span> #    (    ) dec rcx jnz word2 #    <span class="hljs-number"><span class="hljs-number">3</span></span>: sub rsi, rdx mov v_in, rsi push rcx jmp _next <span class="hljs-number"><span class="hljs-number">1</span></span>: lea rdi, [rsi - <span class="hljs-number"><span class="hljs-number">1</span></span>] # RDI = RSI - <span class="hljs-number"><span class="hljs-number">1</span></span> ( ) dec rcx word3: lodsb cmp al, <span class="hljs-string"><span class="hljs-string">' '</span></span> jbe <span class="hljs-number"><span class="hljs-number">2f</span></span> dec rcx jnz word3 <span class="hljs-number"><span class="hljs-number">2</span></span>: mov rax, rsi sub rsi, rdx #        (   ) mov v_in, rsi sub rax, rdi dec rax jz word1 push rdi #   word1: push rax #   jmp _next</code> </pre><br>  Esta palabra es similar a la palabra est√°ndar, pero, a diferencia de ella, tiene en cuenta todos los delimitadores y no copia la palabra en el b√∫fer.  Devuelve solo dos valores en la pila: direcci√≥n y longitud.  Si la palabra no se puede recuperar, devuelve 0. Ha llegado el momento de comenzar a escribir el int√©rprete. <br><br><h4>  B√∫squeda de palabras e int√©rprete </h4><br>  Para comenzar, hagamos que la palabra interprete.  Esta palabra selecciona una nueva palabra del b√∫fer usando blworld, la busca en el diccionario y la ejecuta.  Y as√≠ se repite hasta que se agota el b√∫fer.  Todav√≠a no tenemos la capacidad de buscar una palabra, por lo que escribiremos un comprobante de prueba que simplemente imprima la palabra desde el b√∫fer usando type.  Esto nos dar√° la oportunidad de verificar y depurar blworld: <br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> type repeat drop ; item interpret <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_type .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">1b</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br>  Ahora haz que la palabra salga.  Por lo general, hacen esto cuando implementan sistemas fuertes: usan la palabra salir o abortar para ingresar al modo de int√©rprete.  La palabra salir elimina las pilas e inicia un ciclo interminable de entrada e interpretaci√≥n del b√∫fer.  Con nosotros ser√° solo un llamado a interpretar.  El c√≥digo para esta palabra constar√° de dos partes.  La primera parte estar√° en ensamblador, la segunda parte estar√° en bytecode.  La primera parte: <br><br><pre> <code class="cpp hljs">b_quit = <span class="hljs-number"><span class="hljs-number">0xF1</span></span> bcmd_quit: lea r8, quit mov sp, init_stack mov bp, init_rstack jmp _next</code> </pre><br>  La segunda parte: <br><br><pre> <code class="cpp hljs">quit: .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_bye</code> </pre><br>  Como de costumbre, el c√≥digo del ensamblador se encuentra en la secci√≥n .text, el c√≥digo de bytes est√° en la secci√≥n .data. <br><br>  Y finalmente, cambie el bytecode de inicio.  Solo se inicializar√° el diccionario, se establecer√° un b√∫fer en la l√≠nea de inicio y se llamar√° para salir. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! start_code tib ! </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;  &gt; #tib ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call8 .byte start_code - . - 1 .byte b_call16 .word tib - . - 2 .byte b_set .byte b_lit16 .world 1f - 0f .byte b_call16 .word ntib - . - 2 .byte b_set .byte b_quit start_code: .byte b_var0 0: .ascii "word1 word2 word3" 1:</span></span></span></span></code> </pre><br>  Compilar, vincular, correr! <br><br><pre> <code class="plaintext hljs">$ as forth.s -o forth.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth word1word2wordBye!</code> </pre><br>  Es un poco como gachas, pero este es exactamente el resultado.  Salimos sin delimitadores.  Por cierto, ponga el avance de l√≠nea antes de comprar para el futuro, esto no va a doler. <br><br>  Por supuesto, tuve que jugar con la depuraci√≥n.  Adem√°s del ya mencionado "Fallo de segmentaci√≥n (n√∫cleo descargado)", a veces se obtuvieron resultados interesantes.  Por ejemplo, esto: <br><br><pre> <code class="plaintext hljs">$ ./forth word1word2word3forth)%60Acurrent(context(%600lit8lit16zlit32v%5E%DF%80lit64v%5E%DF%80call8call16call32branch8branch16qbranch8qbranch16exit1-+!-%22*#/$mod%25/mod&amp;abs'dup0drop1swap2rot3-rot4over5pick6roll7depth8@@!Ac@Bc!Cw@Dw!Ei@Fi!G0=P0%3CQ0%3ER=S%3CT%3EU%3C=V%3E=Wvar8)var160base(holdbuf(Qholdpoint(hold@0U110ACp@&amp;20T0!?!%3CgF!A0@RF!5%220'%DE%A61Q-%DD%80:tib(%7F%60(%3Ein(%20%20%20%20%20%20%20interpret01('byeSegmentation%20fault%20(core%20dumped)</code> </pre><br>  Este parece ser nuestro diccionario binario completo con texto cortado en delimitadores :) Sucedi√≥ cuando olvid√© "dec rcx" antes de word3 en el comando b_blword. <br><br>  Podemos elegir palabras de la secuencia de entrada, hay un diccionario.  Ahora necesita implementar una b√∫squeda en el diccionario y lanzar palabras para su ejecuci√≥n.  Esto requerir√° las palabras find, cfa y execute. <br><br>  La palabra find tomar√° la direcci√≥n de la palabra y su longitud de la pila.  Esta palabra ser√° devuelta por la direcci√≥n de la entrada del diccionario o 0 si no se encuentra. <br><br>  La palabra cfa en la direcci√≥n del art√≠culo calcular√° la direcci√≥n del bytecode ejecutable. <br><br>  Y la palabra ejecutar ejecutar√° el c√≥digo de bytes. <br><br>  Comencemos con find.  En los est√°ndares fuertes, se necesita una direcci√≥n: una l√≠nea con un contador.  Pero no quiero copiar una vez m√°s la cadena al b√∫fer, as√≠ que me desviar√© un poco de los est√°ndares.  La palabra find tomar√° dos par√°metros en la pila: la direcci√≥n y la longitud de la cadena (de hecho, eso devuelve la palabra blword).  Despu√©s de la depuraci√≥n, esta palabra tom√≥ la siguiente forma: <br><br><pre> <code class="cpp hljs">b_find = <span class="hljs-number"><span class="hljs-number">0xF2</span></span> bcmd_find: pop rbx #   pop r9 #   mov rdx, v_context mov rdx, [rdx] #        #   find0: mov al, [rdx] #  <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">3</span></span> #   -     ,     ,    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, al jz find_l8 cmp al, <span class="hljs-number"><span class="hljs-number">1</span></span> jz find_l16 cmp al, <span class="hljs-number"><span class="hljs-number">2</span></span> jz find_l32 mov r10, [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">64</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">9</span></span>] #   jmp find1 find_l32: movsx r10, dword ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">32</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">5</span></span>] #   jmp find1 find_l16: movsx r10, word ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">16</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">3</span></span>] #   jmp find1 find_l8: movsx r10, byte ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">8</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">2</span></span>] #   find1: movzx rax, byte ptr [rsi] #       cmp rax, rbx jz find2 #      find3: <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r10, r10 jz find_notfound #  ,    add rdx, r10 #     jmp find0 #  ,   find2: inc rsi mov rdi, r9 mov rcx, rax repz cmpsb jnz find3 #   push rdx jmp _next find_notfound: push r10 jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiz√°s esta sea la palabra m√°s dif√≠cil para hoy. </font><font style="vertical-align: inherit;">Ahora modificamos la palabra interpretar, reemplazando el tipo con "buscar":</font></font><br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> find . repeat drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_find .byte b_call16 .word dot - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la l√≠nea de prueba, debe poner las palabras que est√°n en el diccionario, por ejemplo, "0 1- dup +". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Todo est√° listo para lanzar!</font></font><br><br><pre> <code class="plaintext hljs">$ ld forth.o -o forth $ ./forth 6297733 6297898 6298375 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genial, la b√∫squeda funciona. </font><font style="vertical-align: inherit;">Estas son las direcciones de las palabras (en decimal). </font><font style="vertical-align: inherit;">Ahora la palabra cfa. </font><font style="vertical-align: inherit;">Deje que tambi√©n est√© en ensamblador, es muy simple, trabajar con banderas es similar a encontrar:</font></font><br><br><pre> <code class="cpp hljs">b_cfa = <span class="hljs-number"><span class="hljs-number">0xF3</span></span> bcmd_cfa: pop rdx #    mov al, [rdx] #  <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">3</span></span> #   -     ,     ,    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, al jz cfa_l8 cmp al, <span class="hljs-number"><span class="hljs-number">1</span></span> jz cfa_l16 cmp al, <span class="hljs-number"><span class="hljs-number">2</span></span> jz cfa_l32 lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">9</span></span>] #   (<span class="hljs-number"><span class="hljs-number">64</span></span>  ) jmp cfa1 find_l32: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">5</span></span>] #   (<span class="hljs-number"><span class="hljs-number">32</span></span>  ) jmp cfa1 find_l16: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">3</span></span>] #   (<span class="hljs-number"><span class="hljs-number">16</span></span>  ) jmp cfa1 find_l8: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">2</span></span>] #   (<span class="hljs-number"><span class="hljs-number">8</span></span>  ) xor rax, rax lodsb add rsi, rax push rsi jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y finalmente, la palabra ejecutar, es a√∫n m√°s simple: </font></font><br><br><pre> <code class="cpp hljs">b_execute = <span class="hljs-number"><span class="hljs-number">0xF4</span></span> bcmd_execute: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 #       pop r8 #  - jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corregir la palabra interpretar y correr! </font></font><br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> find cfa execute repeat drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_find .byte b_cfa .byte b_execute .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lanzamiento </font></font><br><br><pre> <code class="plaintext hljs">$ as forth.s -o forth.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth -2 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urrra, ganado! </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(C) Cat Matroskin</font></font></s> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De hecho, si restas 1 de 0 y te sumas el resultado, ser√° -2 :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es genial, pero a√∫n quiero escribir los comandos desde el teclado. Y hay un problema m√°s: nuestro int√©rprete solo entiende los n√∫meros 0, 1, 2, 3, 4 y 8 (que se definen como constantes). ¬øQu√© aprender√≠a √©l a entender cualquier n√∫mero? ¬øNecesita la palabra "n√∫mero"? De la misma manera que para la palabra buscar, no usar√© el b√∫fer. La palabra "n√∫mero"? tomar√° dos par√°metros en la pila: la direcci√≥n de la cadena y la longitud. Si tiene √©xito, devolver√° el n√∫mero recibido y la marca 1. Si la conversi√≥n no tiene √©xito, habr√° un n√∫mero en la pila: 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo result√≥ ser largo, pero bastante simple y lineal:</font></font><br><br><pre> <code class="cpp hljs">b_number = <span class="hljs-number"><span class="hljs-number">0xF5</span></span> bcmd_number: pop rcx #   pop rsi #  xor rax, rax #   xor rbx, rbx #     mov r9, v_base #  xor r10, r10 #   <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz num_false mov bl, [rsi] cmp bl, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jnz <span class="hljs-number"><span class="hljs-number">1f</span></span> inc rsi dec rcx jz num_false jmp num0 <span class="hljs-number"><span class="hljs-number">1</span></span>: cmp bl, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jnz num0 mov r10, <span class="hljs-number"><span class="hljs-number">1</span></span> inc rsi dec rcx jz num_false num0: mov bl, [rsi] cmp bl, <span class="hljs-string"><span class="hljs-string">'0'</span></span> ja num_false cmp bl, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jae num_09 cmp bl, <span class="hljs-string"><span class="hljs-string">'A'</span></span> ja num_false cmp bl, <span class="hljs-string"><span class="hljs-string">'Z'</span></span> jae num_AZ cmp bl, <span class="hljs-string"><span class="hljs-string">'a'</span></span> ja num_false sub bl, <span class="hljs-string"><span class="hljs-string">'a'</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span> jmp num_check num_AZ: sub bl, <span class="hljs-string"><span class="hljs-string">'A'</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span> jmp num_check num_09: sub bl, <span class="hljs-string"><span class="hljs-string">'0'</span></span> num_check: cmp rbx, r9 jge num_false add rax, rbx mul r9 inc rsi dec rcx jnz num0 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r10, r10 push rax push <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _next num_false: xor rcx, rcx push rcx jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modificar interpretar. </font><font style="vertical-align: inherit;">Si la palabra no est√° en el diccionario, intentaremos interpretarla como un n√∫mero:</font></font><br><br><pre> <code class="cpp hljs"># : interpret <span class="hljs-meta"><span class="hljs-meta"># begin # blword dup # while # over over find dup # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> -rot drop drop cfa execute </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> number? drop then # repeat # drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte 0f - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte 1f - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte 2f - . 1: .byte b_numberq .byte b_drop 2: .byte b_branch8 .byte interpret - . 0: .byte b_drop .byte b_exit last_item: .byte b_var0 item bye, f_code .byte b_bye</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y aqu√≠ lo tengo! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depure dicho bytecode en ensamblador, sin puntos de interrupci√≥n en el bytecode, sin la capacidad de simplemente "caminar" a lo largo del bytecode ... Adem√°s, sin los movimientos m√°s f√°ciles en la pila, y sin la capacidad simple de ver el contenido de la pila ... Y en GDB, donde solo la l√≠nea de comando ... Te dir√©: ¬°es solo una explosi√≥n cerebral! </font><font style="vertical-align: inherit;">No peor </font><font style="vertical-align: inherit;">¬°Esta es una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPLOSI√ìN CEREBRAL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero ... somos indios, siempre encontraremos soluciones :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, encontr√© esta soluci√≥n: implement√© un comando para mostrar el contenido de la pila: "s". </font><font style="vertical-align: inherit;">El comando no es el m√°s f√°cil, pero a√∫n m√°s f√°cil de interpretar. </font><font style="vertical-align: inherit;">Y, como se vio despu√©s, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ochchchen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √∫til. </font><font style="vertical-align: inherit;">Aqu√≠ esta:</font></font><br><br><pre> <code class="cpp hljs"># : .s depth dup . c<span class="hljs-string"><span class="hljs-string">": emit do dup while dup pick . 1- again drop ; item .s # 11 22 33 prstack: .byte b_depth # 11 22 33 3 .byte b_dup # 11 22 33 3 3 .byte b_lit8 .byte '(' .byte b_emit .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_strp # 11 22 33 3 .byte 3 .ascii "</span></span>): <span class="hljs-string"><span class="hljs-string">" 1: .byte b_dup # 11 22 33 3 3 .byte b_qnbranch8 # 11 22 33 3 .byte 2f - . .byte b_dup # 11 22 33 3 3 .byte b_pick # 11 22 33 3 11 .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_wm # 11 22 33 2 .byte b_branch8 .byte 1b - . 2: .byte b_drop # 11 22 33 .byte b_exit</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A la derecha, di un ejemplo del contenido de la pila, despu√©s de la ejecuci√≥n de cada comando. </font><font style="vertical-align: inherit;">Por supuesto, hay un ciclo, y este es solo el primer paso. </font><font style="vertical-align: inherit;">Pero el resto son muy similares, solo cambia el valor en la parte superior de la pila. </font><font style="vertical-align: inherit;">Despu√©s de tal "rastro", ¬°el equipo gan√≥ inmediatamente! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para la depuraci√≥n, cre√© las siguientes macros:</font></font><br><br><pre> <code class="cpp hljs">.macro prs new_line = <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_call16 .word prstack - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \new_line &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> .byte b_lit8, <span class="hljs-string"><span class="hljs-string">'\n'</span></span> .byte b_emit .endif .endm</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilizado insertando en los lugares correctos de esta manera: </font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword prs .byte b_dup prs .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over ......</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, el primer lanzamiento produjo el siguiente resultado: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth (2 ): 6297664 1 (3 ): 6297664 1 1 (3 ): 2 6297666 1 (4 ): 2 6297666 1 1 (4 ): 2 3 6297668 1 (5 ): 2 3 6297668 1 1 (3 ): 6 6297670 2 (4 ): 6 6297670 2 2 (4 ): 6 6297670 6297673 1 (5 ): 6 6297670 6297673 1 1 6297670 (2 ): 6 0 (3 ): 6 0 0 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada movimiento en la pila se puede ver claramente. </font><font style="vertical-align: inherit;">Era necesario hacer esto antes :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fui m√°s all√° al hacer otra macro de depuraci√≥n:</font></font><br><br><pre> <code class="cpp hljs">.macro pr <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - <span class="hljs-number"><span class="hljs-number">8f</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n\string"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, se hizo posible hacerlo: </font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword pr blworld prs .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over prs .byte b_find pr find prs .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa pr execute prs .byte b_execute .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_numberq pr numberq prs .byte b_drop <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y entiende esto: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth blworld(2 ): 6297664 2 (4 ): 6297664 2 6297664 2 find(3 ): 6297664 2 0 numberq(2 ): 6297664 0 blworld(3 ): 6297664 6297667 2 (5 ): 6297664 6297667 2 6297667 2 find(4 ): 6297664 6297667 2 0 numberq(3 ): 6297664 6297667 0 blworld(4 ): 6297664 6297667 6297670 1 (6 ): 6297664 6297667 6297670 1 6297670 1 find(5 ): 6297664 6297667 6297670 1 6297958 execute(3 ): 6297664 6297667 6297962 blworld(3 ): 39660590749888 6297672 1 (5 ): 39660590749888 6297672 1 6297672 1 find(4 ): 39660590749888 6297672 1 6298496 execute(2 ): 39660590749888 6298500 39660590749888 blworld(1 ): 0 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fue un intento de interpretar la cadena "20 30 *". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y puede mostrar los n√∫meros de la l√≠nea de origen ... bueno, tal vez entonces ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, esta es una t√©cnica de registro cl√°sica para la depuraci√≥n, pero algo que no recordaba de inmediato. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, como resultado de la depuraci√≥n, encontr√© una pila yendo al extranjero. Esto es lo opuesto al desbordamiento cuando intentan tomar m√°s de lo que ponen. Agreg√≥ su control a ".s". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con la ayuda de nuevas macros, la depuraci√≥n fue r√°pida. Por cierto, antes de eso publiqu√© un bytecode por l√≠nea. Pero el ensamblador le permite colocar varios bytes en una cadena, por qu√© no usarlo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concluyamos la palabra interpretar agregando dos cheques: que la palabra no se ha convertido a un n√∫mero y que salga de la pila al extranjero. Como resultado, interpretar es el siguiente:</font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por cierto, vale la pena se√±alar que ahora el comando quit vac√≠a las pilas y comienza la interpretaci√≥n nuevamente sin cambiar el estado del b√∫fer. </font><font style="vertical-align: inherit;">Por lo tanto, la interpretaci√≥n contin√∫a, pero con pilas "frescas". </font><font style="vertical-align: inherit;">Lo arreglaremos un poco m√°s tarde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo √∫nico que queda es organizar la entrada del teclado.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entrada de teclado </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La entrada del teclado en el fuerte es simple. </font><font style="vertical-align: inherit;">Existe la palabra esperar, toma dos par√°metros: la direcci√≥n del b√∫fer y su tama√±o. </font><font style="vertical-align: inherit;">Esta palabra realiza la entrada del teclado. </font><font style="vertical-align: inherit;">El n√∫mero real de caracteres ingresados ‚Äã‚Äãse coloca en la variable span. </font><font style="vertical-align: inherit;">Hagamos estas palabras. </font><font style="vertical-align: inherit;">Entraremos desde la entrada est√°ndar.</font></font><br><br><pre> <code class="cpp hljs">.data item span span: .byte b_var0 v_span: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> .text b_expect = <span class="hljs-number"><span class="hljs-number">0x88</span></span> bcmd_expect: mov rax, <span class="hljs-number"><span class="hljs-number">0</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_read mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx #   pop rsi #   push r8 syscall #   pop r8 mov rbx, rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jge <span class="hljs-number"><span class="hljs-number">1f</span></span> xor rbx, rbx <span class="hljs-number"><span class="hljs-number">1</span></span>: mov v_span, rbx jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos crear un b√∫fer de entrada de teclado. </font><font style="vertical-align: inherit;">Que tenga 256 caracteres de longitud. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hag√°moslo en lugar de la l√≠nea de prueba anterior.</font></font><br><br><pre> <code class="cpp hljs">inbuf_size = <span class="hljs-number"><span class="hljs-number">256</span></span> inbuf: .byte b_var0 .space inbuf_size</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y modificamos salir, as√≠ como el c√≥digo de bytes inicial. </font><font style="vertical-align: inherit;">Establezca la variable tib en el b√∫fer de entrada inbuf, llame a wait, luego copie el valor de span a #tib. </font><font style="vertical-align: inherit;">La variable&gt; en se anula; llamamos interpretar. </font><font style="vertical-align: inherit;">Y as√≠ lo repetimos en un ciclo. </font><font style="vertical-align: inherit;">Hay adornos: para agregar una solicitud de entrada y ser√≠a bueno mostrar el estado de la pila (¬°y ya tenemos un comando listo para esto!). </font><font style="vertical-align: inherit;">Despu√©s de varias iteraciones, obtuvimos el siguiente c√≥digo (comando iniciar y salir):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_quit inbuf: .byte b_var0 .space inbuf_size # begin inbuf dup tib ! inbuf_size expect span @ #tib ! 0 &gt;in ! interpret again quit: .byte b_strp, 1 .ascii </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n"</span></span></span><span class="hljs-meta"> .byte b_call16 .word prstack - . - 2 .byte b_strp .byte 2 .ascii </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt; "</span></span></span><span class="hljs-meta"> .byte b_call16 .word inbuf - . - 2 .byte b_dup .byte b_call16 .word tib - . - 2 .byte b_set .byte b_lit16 .word inbuf_size .byte b_expect .byte b_call16 .word span - . - 2 .byte b_get .byte b_call16 .word ntib - . - 2 .byte b_set .byte b_num0 .byte b_call16 .word bin - . - 2 .byte b_set .byte b_call16 .word interpret - . - 2 .byte b_branch8, quit - .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y aqu√≠ est√° el resultado: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 60 ( 1 ): 60 &gt; 60 24 ( 3 ): 60 60 24 &gt; rot ( 3 ): 60 24 60 &gt; -rot ( 3 ): 60 60 24 &gt; swap ( 3 ): 60 24 60 &gt; * * . 86400 ( 0 ): &gt; 200 30 /mod ( 2 ): 20 6 &gt; bye Bye! $</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo despu√©s del s√≠mbolo "&gt;" es mi entrada de teclado. </font><font style="vertical-align: inherit;">El resto es la respuesta del sistema. </font><font style="vertical-align: inherit;">Jugu√© un poco con comandos, escribiendo desde el teclado. </font><font style="vertical-align: inherit;">Realiz√≥ varias operaciones de apilamiento, calcul√≥ la cantidad de segundos en d√≠as.</font></font><br><br><h4>  Resumen </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El int√©rprete est√° completo y trabajando. </font><font style="vertical-align: inherit;">Y cort√©smente se despide - a √©l "adi√≥s" y √©l "adi√≥s" :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como invitaci√≥n - el contenido de la pila aritm√©tica. </font><font style="vertical-align: inherit;">El primer n√∫mero entre par√©ntesis es el tama√±o de la pila, luego el contenido y la solicitud para ingresar "&gt;". </font><font style="vertical-align: inherit;">Puede ingresar cualquier comando implementado (cont√© 76 comandos). </font><font style="vertical-align: inherit;">Es cierto que muchos tienen sentido solo para el compilador, por ejemplo, literales, transiciones, comandos de invocaci√≥n.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente completa (aproximadamente 1300 l√≠neas)</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> f_code = <span class="hljs-number"><span class="hljs-number">0x80</span></span> f_immediate = <span class="hljs-number"><span class="hljs-number">0x60</span></span> .macro item name, flags = <span class="hljs-number"><span class="hljs-number">0</span></span> link = p_item - . <span class="hljs-number"><span class="hljs-number">9</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags .byte link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">1</span></span> .word link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">3</span></span> .quad link .endif p_item = <span class="hljs-number"><span class="hljs-number">9b</span></span> .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\name"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm .section .data init_stack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> init_rstack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> emit_buf: .byte <span class="hljs-number"><span class="hljs-number">0</span></span> inbuf_size = <span class="hljs-number"><span class="hljs-number">256</span></span> msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"\nBye!\n"</span></span> msg_bye_len = . - msg_bye bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_num1, bcmd_num2, bcmd_num3, bcmd_num4, bcmd_num8 # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_qnbranch8, bcmd_qnbranch16,bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_wp, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_add, bcmd_sub, bcmd_mul, bcmd_div, bcmd_mod, bcmd_divmod, bcmd_abs # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_var0, bcmd_var8, bcmd_var16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_dup, bcmd_drop, bcmd_swap, bcmd_rot, bcmd_mrot, bcmd_over, bcmd_pick, bcmd_roll # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_depth, bcmd_nip, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_get, bcmd_set, bcmd_get8, bcmd_set8, bcmd_get16, bcmd_set16, bcmd_get32, bcmd_set32 # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_setp, bcmd_setm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_zeq, bcmd_zlt, bcmd_zgt, bcmd_eq, bcmd_lt, bcmd_gt, bcmd_lteq, bcmd_gteq # <span class="hljs-number"><span class="hljs-number">0x50</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_2r, bcmd_r2, bcmd_rget, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_emit, bcmd_str, bcmd_strp, bcmd_count, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_expect, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x90</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_blword, bcmd_quit, bcmd_find, bcmd_cfa, bcmd_execute, bcmd_numberq, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0xF0</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # forth last_item context @ ! quit start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_quit inbuf: .byte b_var0 .space inbuf_size # begin inbuf dup tib ! inbuf_size expect span @ #tib ! <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;in ! interpret again quit: .byte b_strp, <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\n"</span></span> .byte b_call16 .word prstack - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">2</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"&gt; "</span></span> .byte b_call16 .word inbuf - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word inbuf_size .byte b_expect .byte b_call16 .word span - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_num0 .byte b_call16 .word bin - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_branch8, quit - . p_item = . item forth forth: .byte b_var8 .byte does_voc - . .quad <span class="hljs-number"><span class="hljs-number">0</span></span> does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit item current .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item context context: .byte b_var0 v_context: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-number"><span class="hljs-number">0</span></span>, f_code .byte b_num0 .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>, f_code .byte b_num1 .byte b_exit item <span class="hljs-number"><span class="hljs-number">2</span></span>, f_code .byte b_num2 .byte b_exit item <span class="hljs-number"><span class="hljs-number">3</span></span>, f_code .byte b_num3 .byte b_exit item <span class="hljs-number"><span class="hljs-number">4</span></span>, f_code .byte b_num4 .byte b_exit item <span class="hljs-number"><span class="hljs-number">8</span></span>, f_code .byte b_num8 .byte b_exit item lit8, f_code .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">31</span></span> .byte b_exit item lit16, f_code .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">31415</span></span> .byte b_exit item lit32, f_code .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item lit64, f_code .byte b_lit64 .quad <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item call8, f_code .byte b_call8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item call16, f_code .byte b_call16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item call32, f_code .byte b_call32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item branch8, f_code .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item branch16, f_code .byte b_branch16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item qbranch8, f_code .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item qbranch16, f_code .byte b_qbranch16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>, f_code .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>-, f_code .byte b_wm .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>+, f_code .byte b_wp .byte b_exit item +, f_code .byte b_add .byte b_exit item -, f_code .byte b_sub .byte b_exit item *, f_code .byte b_mul .byte b_exit item /, f_code .byte b_div .byte b_exit item mod, f_code .byte b_mod .byte b_exit item /mod, f_code .byte b_divmod .byte b_exit item <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>, f_code .byte b_abs .byte b_exit item dup, f_code .byte b_dup .byte b_exit item drop, f_code .byte b_drop .byte b_exit item swap, f_code .byte b_swap .byte b_exit item rot, f_code .byte b_rot .byte b_exit item -rot, f_code .byte b_mrot .byte b_exit item over, f_code .byte b_over .byte b_exit item pick, f_code .byte b_pick .byte b_exit item roll, f_code .byte b_roll .byte b_exit item depth, f_code .byte b_depth .byte b_exit item @, f_code .byte b_get .byte b_exit item !, f_code .byte b_set .byte b_exit item c@, f_code .byte b_get8 .byte b_exit item c!, f_code .byte b_set8 .byte b_exit item w@, f_code .byte b_get16 .byte b_exit item w!, f_code .byte b_set16 .byte b_exit item i@, f_code .byte b_get32 .byte b_exit item i!, f_code .byte b_set32 .byte b_exit item +!, f_code .byte b_setp .byte b_exit item -!, f_code .byte b_setm .byte b_exit item &gt;r, f_code .byte b_2r .byte b_exit item r&gt;, f_code .byte b_r2 .byte b_exit item r@, f_code .byte b_rget .byte b_exit item <span class="hljs-string"><span class="hljs-string">"0="</span></span>, f_code .byte b_zeq .byte b_exit item <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;, f_code .byte b_zlt .byte b_exit item <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, f_code .byte b_zgt .byte b_exit item <span class="hljs-string"><span class="hljs-string">"="</span></span>, f_code .byte b_eq .byte b_exit item &lt;, f_code .byte b_lt .byte b_exit item &gt;, f_code .byte b_gt .byte b_exit item <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span>, f_code .byte b_lteq .byte b_exit item <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span>, f_code .byte b_gteq .byte b_exit item type, f_code .byte b_type .byte b_exit item expect, f_code .byte b_expect .byte b_exit item emit, f_code .byte b_emit .byte b_exit item count, f_code .byte b_count .byte b_exit item <span class="hljs-string"><span class="hljs-string">"(\")"</span></span>, f_code .byte b_str .byte b_exit item <span class="hljs-string"><span class="hljs-string">"(.\")"</span></span>, f_code .byte b_strp .byte b_exit item var8, f_code .byte b_var8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item var16, f_code .byte b_var16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item base base: .byte b_var0 v_base: .quad <span class="hljs-number"><span class="hljs-number">10</span></span> holdbuf_len = <span class="hljs-number"><span class="hljs-number">70</span></span> item holdbuf holdbuf: .byte b_var0 .space holdbuf_len item holdpoint holdpoint: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item span span: .byte b_var0 v_span: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # : hold holdpoint @ <span class="hljs-number"><span class="hljs-number">1</span></span>- dup holdbuf &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup holdpoint ! c! then ; item hold hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint .byte b_get # @ .byte b_wm # 1- .byte b_dup # dup .byte b_call8 .byte holdbuf - . - 1 # holdbuf .byte b_gt # &gt; .byte b_qbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_drop # drop .byte b_drop # drop .byte b_branch8 #     ( then) .byte 1f - . 0: .byte b_dup # dup .byte b_call8 .byte holdpoint - . - 1 # holdpoint .byte b_set # ! .byte b_set8 # c! 1: .byte b_exit # ; # : # base /mod swap dup 10 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; if c" 0 + else 10 - c" A + then hold ; item # conv: .byte b_call16 .word base - . - 2 # base .byte b_get # @ .byte b_divmod # /mod .byte b_swap # swap .byte b_dup # dup .byte b_lit8 .byte 10 # 10 .byte b_lt # &lt; .byte b_qnbranch8 # if .byte 0f - . .byte b_lit8 .byte '0' # c" 0 .byte b_add # + .byte b_branch8 # else .byte 1f - . 0: .byte b_lit8 .byte '?' # c" A .byte b_add # + 1: .byte b_call16 .word hold - . - 2 # hold .byte b_exit # ; # : &lt;# holdbuf 70 + holdpoint ! ; item &lt;# conv_start: .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_call16 .word holdpoint - . - 2 .byte b_set .byte b_exit # : #s do # dup 0=until ; item #s conv_s: .byte b_call8 .byte conv - . - 1 .byte b_dup .byte b_qbranch8 .byte conv_s - . .byte b_exit # : #&gt; holdpoint @ holdbuf 70 + over - ; item #&gt; conv_end: .byte b_call16 .word holdpoint - . - 2 .byte b_get .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_over .byte b_sub .byte b_exit item . dot: .byte b_dup .byte b_abs .byte b_call8 .byte conv_start - . - 1 .byte b_lit8 .byte ' ' .byte b_call16 .word hold - . - 2 .byte b_call8 .byte conv_s - . - 1 .byte b_drop .byte b_zlt .byte b_qnbranch8 .byte 1f - . .byte b_lit8 .byte '-' .byte b_call16 .word hold - . - 2 1: .byte b_call8 .byte conv_end - . - 1 .byte b_type .byte b_exit item tib tib: .byte b_var0 v_tib: .quad 0 item #tib ntib: .byte b_var0 v_ntib: .quad 0 item &gt;in bin: .byte b_var0 v_in: .quad 0 # : .s depth dup . c": emit do dup while dup pick . 1- again drop ; item .s # 11 22 33 prstack: .byte b_depth # 11 22 33 3 .byte b_dup # 11 22 33 3 3 .byte b_strp .byte 2 .ascii "( " .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_strp # 11 22 33 3 .byte 3 .ascii "): " .byte b_dup, b_zlt .byte b_qnbranch8, 1f - . .byte b_strp .byte 14 .ascii "\nStack fault!\n" .byte b_quit 1: .byte b_dup # 11 22 33 3 3 .byte b_qnbranch8 # 11 22 33 3 .byte 2f - . .byte b_dup # 11 22 33 3 3 .byte b_pick # 11 22 33 3 11 .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_wm # 11 22 33 2 .byte b_branch8 .byte 1b - . 2: .byte b_drop # 11 22 33 .byte b_exit .macro prs new_line = 1 .byte b_call16 .word prstack - . - 2 .if \new_line &gt; 0 .byte b_lit8, '\n' .byte b_emit .endif .endm .macro pr string .byte b_strp .byte 9f - 8f 8: .ascii "\n\string" 9: .endm item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte 0f - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte 1f - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte 2f - . 1: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, 3f - . #     0, ,      3 .byte b_type #    .byte b_strp #   .byte 19 #     .ascii " : word not found!\n" .byte b_quit #    3: .byte b_nip, b_nip #  ,     ( b_over, b_over) 2: #       .byte b_depth #    .byte b_zlt # ,   0 ( 0&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte 14 .ascii "\nstack fault!\n" .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . 0: .byte b_drop .byte b_exit last_item: .byte b_var0 item bye, f_code .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start mov init_stack, rsp mov init_rstack, rbp jmp _next b_var0 = 0x28 bcmd_var0: push r8 b_exit = 0x17 bcmd_exit: mov r8, [rbp] add rbp, 8 _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*8] b_num0 = 0x02 bcmd_num0: push 0 jmp _next b_num1 = 0x03 bcmd_num1: push 1 jmp _next b_num2 = 0x04 bcmd_num2: push 2 jmp _next b_num3 = 0x05 bcmd_num3: push 3 jmp _next b_num4 = 0x06 bcmd_num4: push 4 jmp _next b_num8 = 0x07 bcmd_num8: push 8 jmp _next b_lit8 = 0x08 bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = 0x09 bcmd_lit16: movsx rax, word ptr [r8] add r8, 2 push rax jmp _next b_call8 = 0x0C bcmd_call8: movsx rax, byte ptr [r8] sub rbp, 8 inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = 0x0D bcmd_call16: movsx rax, word ptr [r8] sub rbp, 8 add r8, 2 mov [rbp], r8 add r8, rax jmp _next b_call32 = 0x0E bcmd_call32: movsx rax, dword ptr [r8] sub rbp, 8 add r8, 4 mov [rbp], r8 add r8, rax jmp _next b_lit32 = 0x0A bcmd_lit32: movsx rax, dword ptr [r8] add r8, 4 push rax jmp _next b_lit64 = 0x0B bcmd_lit64: mov rax, [r8] add r8, 8 push rax jmp _next b_dup = 0x30 bcmd_dup: push [rsp] jmp _next b_wm = 0x20 bcmd_wm: decq [rsp] jmp _next b_wp = 0x18 bcmd_wp: incq [rsp] jmp _next b_add = 0x21 bcmd_add: pop rax add [rsp], rax jmp _next b_sub = 0x22 bcmd_sub: pop rax sub [rsp], rax jmp _next b_mul = 0x23 bcmd_mul: pop rax pop rbx imul rbx push rax jmp _next b_div = 0x24 bcmd_div: pop rbx pop rax cqo idiv rbx push rax jmp _next b_mod = 0x25 bcmd_mod: pop rbx pop rax cqo idiv rbx push rdx jmp _next b_divmod = 0x26 bcmd_divmod: pop rbx pop rax cqo idiv rbx push rdx push rax jmp _next b_abs = 0x27 bcmd_abs: mov rax, [rsp] or rax, rax jge _next neg rax mov [rsp], rax jmp _next b_drop = 0x31 bcmd_drop: add rsp, 8 jmp _next b_swap = 0x32 bcmd_swap: pop rax pop rbx push rax push rbx jmp _next b_rot = 0x33 bcmd_rot: pop rax pop rbx pop rcx push rbx push rax push rcx jmp _next b_mrot = 0x34 bcmd_mrot: pop rcx pop rbx pop rax push rcx push rax push rbx jmp _next b_over = 0x35 bcmd_over: push [rsp + 8] jmp _next b_pick = 0x36 bcmd_pick: pop rcx push [rsp + 8*rcx] jmp _next b_roll = 0x37 bcmd_roll: pop rcx mov rbx, [rsp + 8*rcx] roll1: mov rax, [rsp + 8*rcx - 8] mov [rsp + 8*rcx], rax dec rcx jnz roll1 push rbx jmp _next b_depth = 0x38 bcmd_depth: mov rax, init_stack sub rax, rsp sar rax, 3 push rax jmp _next b_nip = 0x39 bcmd_nip: pop rax mov [rsp], rax jmp _next b_get = 0x40 bcmd_get: pop rcx push [rcx] jmp _next b_set = 0x41 bcmd_set: pop rcx pop rax mov [rcx], rax jmp _next b_get8 = 0x42 bcmd_get8: pop rcx movsx rax, byte ptr [rcx] push rax jmp _next b_set8 = 0x43 bcmd_set8: pop rcx pop rax mov [rcx], al jmp _next b_get16 = 0x44 bcmd_get16: pop rcx movsx rax, word ptr [rcx] push rax jmp _next b_set16 = 0x45 bcmd_set16: pop rcx pop rax mov [rcx], ax jmp _next b_get32 = 0x46 bcmd_get32: pop rcx movsx rax, dword ptr [rcx] push rax jmp _next b_set32 = 0x47 bcmd_set32: pop rcx pop rax mov [rcx], eax jmp _next b_setp = 0x48 bcmd_setp: pop rcx pop rax add [rcx], rax jmp _next b_setm = 0x49 bcmd_setm: pop rcx pop rax sub [rcx], rax jmp _next b_2r = 0x60 bcmd_2r: pop rax sub rbp, 8 mov [rbp], rax jmp _next b_r2 = 0x61 bcmd_r2: push [rbp] add rbp, 8 jmp _next b_rget = 0x62 bcmd_rget: push [rbp] jmp _next # 0= b_zeq = 0x50 bcmd_zeq: pop rax or rax, rax jnz rfalse rtrue: push -1 jmp _next rfalse: push 0 jmp _next # 0&lt; b_zlt = 0x51 bcmd_zlt: pop rax or rax, rax jl rtrue push 0 jmp _next # 0&gt; b_zgt = 0x52 bcmd_zgt: pop rax or rax, rax jg rtrue push 0 jmp _next # = b_eq = 0x53 bcmd_eq: pop rbx pop rax cmp rax, rbx jz rtrue push 0 jmp _next # &lt; b_lt = 0x54 bcmd_lt: pop rbx pop rax cmp rax, rbx jl rtrue push 0 jmp _next # &gt; b_gt = 0x55 bcmd_gt: pop rbx pop rax cmp rax, rbx jg rtrue push 0 jmp _next # &lt;= b_lteq = 0x56 bcmd_lteq: pop rbx pop rax cmp rax, rbx jle rtrue push 0 jmp _next # &gt;= b_gteq = 0x57 bcmd_gteq: pop rbx pop rax cmp rax, rbx jge rtrue push 0 jmp _next b_var8 = 0x29 bcmd_var8: push r8 b_branch8 = 0x10 bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_var16 = 0x30 bcmd_var16: push r8 b_branch16 = 0x11 bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = 0x12 bcmd_qbranch8: pop rax or rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = 0x13 bcmd_qbranch16: pop rax or rax, rax jnz bcmd_branch16 add r8, 2 jmp _next b_qnbranch8 = 0x14 bcmd_qnbranch8: pop rax or rax, rax jz bcmd_branch8 inc r8 jmp _next b_qnbranch16 = 0x15 bcmd_qnbranch16:pop rax or rax, rax jz bcmd_branch16 add r8, 2 jmp _next b_bad = 0x00 bcmd_bad: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1  stdout mov rsi, offset msg_bad_byte #     mov rdx, msg_bad_byte_len #   syscall #   mov rax, 60 #    1 - sys_exit mov rbx, 1 #    1 syscall #   b_bye = 0x01 bcmd_bye: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1  stdout mov rsi, offset msg_bye #     mov rdx, msg_bye_len #   syscall #   mov rax, 60 #    60 - sys_exit mov rdi, 0 #    0 syscall #   b_strp = 0x83 bcmd_strp: movsx rax, byte ptr [r8] inc r8 push r8 add r8, rax push rax b_type = 0x80 bcmd_type: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1 - stdout pop rdx #   pop rsi #   push r8 syscall #   pop r8 jmp _next b_expect = 0x88 bcmd_expect: mov rax, 0 #    1 - sys_read mov rdi, 0 #   1 - stdout pop rdx #   pop rsi #   push r8 syscall #   pop r8 mov rbx, rax or rax, rax jge 1f xor rbx, rbx 1: mov v_span, rbx jmp _next b_str = 0x82 bcmd_str: movzx rax, byte ptr [r8] lea r8, [r8 + rax + 1] jmp _next b_count = 0x84 bcmd_count: pop rcx movzx rax, byte ptr [rcx] inc rcx push rcx push rax jmp _next b_emit = 0x81 bcmd_emit: pop rax mov rsi, offset emit_buf #   mov [rsi], al mov rax, 1 #    1 - sys_write mov rdi, 1 #   1 - stdout mov rdx, 1 #   push r8 syscall #   pop r8 jmp _next b_blword = 0xF0 bcmd_blword: mov rsi, v_tib #    mov rdx, rsi #   RDX       mov rax, v_in #     mov rcx, v_ntib #    mov rbx, rcx add rsi, rax #  RSI -      sub rcx, rax #     jz 3f word2: lodsb #   AL  RSI   cmp al, ' ' ja 1f #    (    ) dec rcx jnz word2 #    3: sub rsi, rdx mov v_in, rsi push rcx jmp _next 1: lea rdi, [rsi - 1] # RDI = RSI - 1 ( ) dec rcx jz word9 word3: lodsb cmp al, ' ' jbe 2f dec rcx jnz word3 word9: inc rsi 2: mov rax, rsi sub rsi, rdx #        (   ) cmp rsi, rbx jle 4f mov rsi, rbx 4: mov v_in, rsi sub rax, rdi dec rax jz word1 push rdi #   word1: push rax #   jmp _next b_quit = 0xF1 bcmd_quit: lea r8, quit mov rsp, init_stack mov rbp, init_rstack jmp _next b_find = 0xF2 bcmd_find: pop rbx #   pop r9 #   mov rdx, v_context mov rdx, [rdx] #        #   find0: mov al, [rdx] #  and al, 3 #   -     ,     ,    or al, al jz find_l8 cmp al, 1 jz find_l16 cmp al, 2 jz find_l32 mov r10, [rdx + 1] #  64  lea rsi, [rdx + 9] #   jmp find1 find_l32: movsx r10, dword ptr [rdx + 1] #  32  lea rsi, [rdx + 5] #   jmp find1 find_l16: movsx r10, word ptr [rdx + 1] #  16  lea rsi, [rdx + 3] #   jmp find1 find_l8: movsx r10, byte ptr [rdx + 1] #  8  lea rsi, [rdx + 2] #   find1: movzx rax, byte ptr [rsi] #       cmp rax, rbx jz find2 #      find3: or r10, r10 jz find_notfound #  ,    add rdx, r10 #     jmp find0 #  ,   find2: inc rsi mov rdi, r9 mov rcx, rax repz cmpsb jnz find3 #   push rdx jmp _next find_notfound: push r10 jmp _next b_cfa = 0xF3 bcmd_cfa: pop rdx #    mov al, [rdx] #  and al, 3 #   -     ,     ,    or al, al jz cfa_l8 cmp al, 1 jz cfa_l16 cmp al, 2 jz cfa_l32 lea rsi, [rdx + 9] #   (64  ) jmp cfa1 cfa_l32: lea rsi, [rdx + 5] #   (32  ) jmp cfa1 cfa_l16: lea rsi, [rdx + 3] #   (16  ) jmp cfa1 cfa_l8: lea rsi, [rdx + 2] #   (8  ) cfa1: xor rax, rax lodsb add rsi, rax push rsi jmp _next b_execute = 0xF4 bcmd_execute: sub rbp, 8 mov [rbp], r8 #       pop r8 #  - jmp _next b_numberq = 0xF5 bcmd_numberq: pop rcx #   pop rsi #  xor rax, rax #   xor rbx, rbx #     mov r9, v_base #  xor r10, r10 #   or rcx, rcx jz num_false mov bl, [rsi] cmp bl, '+' jnz 1f inc rsi dec rcx jz num_false jmp num0 1: cmp bl, '-' jnz num0 mov r10, 1 inc rsi dec rcx jz num_false num0: mov bl, [rsi] cmp bl, '0' jb num_false cmp bl, '9' jbe num_09 cmp bl, 'A' jb num_false cmp bl, 'Z' jbe num_AZ cmp bl, 'a' jb num_false cmp bl, 'z' ja num_false sub bl, 'a' - 10 jmp num_check num_AZ: sub bl, 'A' - 10 jmp num_check num_09: sub bl, '0' num_check: cmp rbx, r9 jge num_false mul r9 add rax, rbx inc rsi dec rcx jnz num0 or r10, r10 push rax push 1 jmp _next num_false: xor rcx, rcx push rcx jmp _next</span></span></span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo fuente se est√° haciendo m√°s grande, as√≠ que lo traigo aqu√≠ por √∫ltima vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora su lugar de residencia estar√° en el github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En el mismo lugar, en la carpeta bin puede encontrar la versi√≥n ya compilada para Linux x64. Qui√©n tiene Linux, puede descargarlo y ejecutarlo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y qui√©n tiene Windows: puede instalar WSL (Windows Subsystem for Linux). Me iba para las vacaciones e hice exactamente eso. Result√≥ ser muy simple, tom√≥ alrededor de 5 minutos. Hubo solo un momento, no comenz√≥ de inmediato, el subsistema tuvo que "encenderse" a trav√©s del comando PowerShell. Segu√≠ el enlace del mensaje de error, ejecut√© el comando y funcion√≥. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero tambi√©n hay una manera para que los indios reales lo ejecuten todo en Windows :) No es dif√≠cil hacer esto, solo rehaga algunas palabras que interact√∫en con el sistema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eso es todo! </font><font style="vertical-align: inherit;">La pr√≥xima vez, ejecutaremos el compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr√° una oportunidad para compilar nuevas palabras, habr√° condiciones, ciclos. </font><font style="vertical-align: inherit;">En realidad, ser√° posible escribir en un fuerte m√°s o menos est√°ndar, compilarlo en c√≥digo de bytes y ejecutarlo. </font><font style="vertical-align: inherit;">Bueno, ser√° posible realizar pruebas m√°s serias, verificar el rendimiento de la m√°quina de bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuaci√≥n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-m√°quina para el fuerte (y no solo) en nativos americanos (parte 4)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435236/">https://habr.com/ru/post/es435236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435220/index.html">Kotlin Native: realiza un seguimiento de los archivos</a></li>
<li><a href="../es435224/index.html">C√≥mo comunicarse en una oficina en ingl√©s: 14 expresiones idiom√°ticas √∫tiles</a></li>
<li><a href="../es435226/index.html">Restaurar datos desde cero</a></li>
<li><a href="../es435228/index.html">Kubernetes cluster por $ 20 por mes</a></li>
<li><a href="../es435234/index.html">M√°s inteligente, m√°s preciso y m√°s preciso: c√≥mo la IA cambia los vuelos al espacio</a></li>
<li><a href="../es435240/index.html">Unreal Engine4: efecto de escaneo posterior al proceso</a></li>
<li><a href="../es435242/index.html">¬øPor qu√© tengo miedo de convertirme en un "hombre bombeado"</a></li>
<li><a href="../es435244/index.html">Proyecto ITER en 2018</a></li>
<li><a href="../es435246/index.html">Tesla ha abierto pedidos anticipados para el Modelo 3 en Europa y China</a></li>
<li><a href="../es435248/index.html">Navegaci√≥n dentro de la aplicaci√≥n de Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>