<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèΩ üîÆ üîè Programaci√≥n funcional desde el punto de vista de EcmaScript. Composici√≥n, Curry, Aplicaci√≥n Parcial üòè üë©üèª‚Äç‚úàÔ∏è üöÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 Hoy continuamos nuestra investigaci√≥n sobre programaci√≥n funcional en el contexto de EcmaScript, cuya especificaci√≥n se basa en JavaScri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n funcional desde el punto de vista de EcmaScript. Composici√≥n, Curry, Aplicaci√≥n Parcial</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475324/"> Hola Habr! <br><br>  Hoy continuamos nuestra investigaci√≥n sobre programaci√≥n funcional en el contexto de EcmaScript, cuya especificaci√≥n se basa en JavaScript.  En el art√≠culo anterior, examinamos los conceptos b√°sicos: funciones puras, lambdas, el concepto de inmunidad.  Hoy hablaremos de t√©cnicas de FP un poco m√°s complejas: composici√≥n, curry y funciones puras.  El art√≠culo est√° escrito en el estilo de "pseudo codreview", es decir  resolveremos un problema pr√°ctico, mientras estudiamos los conceptos de transiciones de fase y c√≥digo de refactorizaci√≥n para aproximar este √∫ltimo a los ideales de las transiciones de fase. <br><br>  ¬°Entonces comencemos! <br><br>  Supongamos que tenemos una tarea: crear un conjunto de herramientas para trabajar con pal√≠ndromos. <br><blockquote>  Palindrome <br>  G√©nero masculino <br>  Una palabra o frase que se lee de la misma manera de izquierda a derecha y de derecha a izquierda. <br>  "P.  "Voy con la espada del juez" " <br></blockquote>  Una de las posibles implementaciones de esta tarea podr√≠a verse as√≠: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPalindrom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regexp = <span class="hljs-regexp"><span class="hljs-regexp">/[\.,\/#!$%\^&amp;\*;:{}=\-_`~()?\s]/g</span></span>; str = str.replace(regexp, <span class="hljs-string"><span class="hljs-string">''</span></span>).toLowerCase().split(<span class="hljs-string"><span class="hljs-string">''</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -       ,       return str; } function isPalindrom (str) { const regexp = /[\.,\/#!$%\^&amp;\*;:{}=\-_`~()?\s]/g; str = str.replace(regexp, '').toLowerCase(); return str === str.split('').reverse().join(''); }</span></span></code> </pre> <a name="habracut"></a><br>  Por supuesto, esta implementaci√≥n funciona.  Podemos esperar que getPalindrom funcione correctamente si la API devuelve los datos correctos.  Una llamada a isPalindrom ('Voy con un juez de espada') devolver√° verdadero, y una llamada a isPalindrom ('no es un pal√≠ndromo') devolver√° falso.  ¬øEsta implementaci√≥n es buena en t√©rminos de ideales de programaci√≥n funcional?  Definitivamente no es bueno! <br><br>  De acuerdo con la definici√≥n de Funciones Puras de este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> : <br><blockquote>  Funciones puras (PF): siempre devuelve un resultado previsto. <br>  Propiedades de PF: <br><br>  El resultado de la ejecuci√≥n de PF depende solo de los argumentos pasados ‚Äã‚Äãy del algoritmo que implementa PF <br>  No use valores globales <br>  No modifique valores externos o argumentos pasados <br>  No escriba datos en archivos, bases de datos ni en ning√∫n otro lugar. <br></blockquote>  ¬øY qu√© vemos en nuestro ejemplo con pal√≠ndromos? <br><br>  En primer lugar, hay duplicaci√≥n de c√≥digo, es decir  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se</a> viola el principio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SECO</a> .  En segundo lugar, la funci√≥n getPalindrom accede a la base de datos.  Tercero, las funciones modifican sus argumentos.  Total, nuestras funciones no est√°n limpias. <br><br>  Recordemos la definici√≥n: la programaci√≥n funcional es una forma de escribir c√≥digo mediante la compilaci√≥n de un conjunto de funciones. <br><br>  Componemos un conjunto de funciones para esta tarea: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allNotWordSymbolsRegexpGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> /[\.,\/#!$%\^&amp;\*;:{}=\-_~<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">?\</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">]/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">;//(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement);<span class="hljs-comment"><span class="hljs-comment">//(2) const toLowerCase = str =&gt; str.toLowerCase();//(3) const stringReverse = str =&gt; str.split('').reverse().join('');//(4) const isStringsEqual = (strA, strB) =&gt; strA === strB;//(5)</span></span></code> </pre><br>  En la l√≠nea 1, declaramos la expresi√≥n regular constante en forma funcional.  Este m√©todo de describir constantes se usa a menudo en FP.  En la l√≠nea 2, encapsulamos el m√©todo String.prototype.replace en una abstracci√≥n de reemplazo funcional para que (la llamada de reemplazo) coincida con el contrato de programaci√≥n funcional.  En la l√≠nea 3, se cre√≥ una abstracci√≥n para String.prototype.toLowerCase de la misma manera.  En el cuarto, implementaron una funci√≥n que crea una nueva cadena expandida a partir de la pasada.  5to cheques para la igualdad de la secuencia. <br><br>  ¬°Tenga en cuenta que nuestras caracter√≠sticas son extremadamente limpias!  Hablamos sobre los beneficios de las funciones puras en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> anterior. <br><br>  Ahora necesitamos implementar una verificaci√≥n para ver si la cadena es un pal√≠ndromo.  Una composici√≥n de funciones vendr√° en nuestra ayuda. <br><br>  <b>La composici√≥n de funciones</b> es la uni√≥n de dos o m√°s funciones en una determinada funci√≥n resultante que implementa el comportamiento de aquellas combinadas en la secuencia algor√≠tmica deseada. <br><br>  La definici√≥n puede parecer complicada, pero desde un punto de vista pr√°ctico es justa. <br><br>  Podemos hacer esto: <br><br><pre> <code class="javascript hljs">isStringsEqual(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>)), stringReverse(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>))));</code> </pre><br>  o as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strA = toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strB = stringReverse(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>))); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isStringsEqual(strA, strB));</code> </pre><br>  o ingrese otro grupo de variables explicativas para cada paso del algoritmo implementado.  Tal c√≥digo a menudo se puede ver en proyectos, y este es un ejemplo t√≠pico de composici√≥n: pasar una llamada a una funci√≥n como argumento a otra.  Sin embargo, como vemos, en una situaci√≥n en la que hay muchas funciones, este enfoque es malo, porque  ¬°Este c√≥digo no es legible!  ¬øY ahora qu√©?  Bueno, su programaci√≥n funcional, ¬øestamos en desacuerdo? <br><br>  De hecho, como suele ser el caso en la programaci√≥n funcional, solo necesitamos escribir otra funci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x);</code> </pre><br>  La funci√≥n componer toma una lista de funciones ejecutables como argumentos, las convierte en una matriz, las almacena en un cierre y devuelve una funci√≥n que espera un valor inicial.  Despu√©s de pasar el valor inicial, comienza la ejecuci√≥n secuencial de todas las funciones de la matriz fns.  El argumento de la primera funci√≥n ser√° el valor inicial x pasado, y los argumentos de todas las posteriores ser√°n el resultado de la anterior.  Entonces podemos crear composiciones de cualquier n√∫mero de funciones. <br><br>  Al crear composiciones funcionales, es muy importante monitorear los tipos de par√°metros de entrada y los valores de retorno de cada funci√≥n para que no haya errores inesperados, porque  Pasamos el resultado de la funci√≥n anterior a la siguiente. <br><br>  Sin embargo, ya vemos problemas al aplicar la t√©cnica de composici√≥n a nuestro c√≥digo, porque la funci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replace = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement);</code> </pre><br>  espera aceptar 3 par√°metros de entrada, y solo enviamos uno para componer.  Otra t√©cnica de FP, Curry, nos ayudar√° a resolver este problema. <br><br>  <b>Curry</b> es la conversi√≥n de una funci√≥n de muchos argumentos a una funci√≥n de un argumento. <br><br>  ¬øRecuerdas nuestra funci√≥n de agregar del primer art√≠culo? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">) =&gt;</span></span> x+y;</code> </pre><br>  Se puede curry as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; x+y;</code> </pre><br>  La funci√≥n toma x y devuelve una lambda que espera y y realiza la acci√≥n. <br><br>  Beneficios del curry: <br><br><ul><li>  el c√≥digo se ve mejor; </li><li>  Las funciones curry siempre est√°n limpias. </li></ul><br>  Ahora transformamos nuestra funci√≥n de reemplazo para que solo tome un argumento.  Dado que necesitamos la funci√≥n para reemplazar los caracteres en la cadena con una expresi√≥n regular previamente conocida, podemos crear una funci√≥n parcialmente aplicada. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replacement</span></span></span><span class="hljs-function"> =&gt;</span></span> str =&gt; replace(allNotWordSymbolsRegexpGlobal(), replacement, str);</code> </pre><br>  Como puede ver, arreglamos uno de los argumentos con una constante.  Esto se debe al hecho de que curry es en realidad un caso especial de uso parcial. <br><br>  <b>Una aplicaci√≥n parcial</b> est√° envolviendo una funci√≥n con un contenedor que acepta menos argumentos que la funci√≥n en s√≠; el contenedor debe devolver una funci√≥n que tome el resto de los argumentos. <br><br>  En nuestro caso, creamos la funci√≥n replaceAllNotWordSymbolsGlobal, que es una opci√≥n de reemplazo parcialmente aplicada.  Acepta el reemplazo, lo almacena en un cierre y espera una l√≠nea de entrada para la que llamar√° reemplazar, y regexp con una constante. <br><br>  De vuelta a los pal√≠ndromos.  Cree una composici√≥n de funciones para la sincronizaci√≥n del pal√≠ndromo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormPalindrom = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, stringReverse );</code> </pre><br>  y la composici√≥n de funciones para la l√≠nea con la que compararemos el pal√≠ndromo potencial: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormTestString = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, );</code> </pre><br>  Ahora recuerda lo que dijimos anteriormente: <br><blockquote>  Un ejemplo t√≠pico de composici√≥n es pasar una llamada a una funci√≥n como argumento a otra </blockquote>  y escribe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">'    '</span></span>;<span class="hljs-comment"><span class="hljs-comment">//          , .. ,    ,  ,   -   ,    const isPalindrom = isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</span></span></code> </pre><br>  Aqu√≠ tenemos una soluci√≥n funcional y atractiva: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allNotWordSymbolsRegexpGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> /[\.,\/#!$%\^&amp;\*;:{}=\-_~<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">?\</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">]/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toLowerCase = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stringReverse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringsEqual = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strA, strB</span></span></span><span class="hljs-function">) =&gt;</span></span> strA === strB; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replacement</span></span></span><span class="hljs-function"> =&gt;</span></span> str =&gt; replace(allNotWordSymbolsRegexpGlobal(), replacement, str); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormPalindrom = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, stringReverse ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormTestString = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">'    '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPalindrom = isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</code> </pre><br>  Sin embargo, no queremos hacer curry cada vez o crear funciones parcialmente aplicadas con nuestras manos.  Por supuesto que no queremos, los programadores son gente perezosa.  Por lo tanto, como suele suceder en FP, escribiremos un par de funciones m√°s: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> curry = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> (...args) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fn.length &gt; args.length) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = fn.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, ...args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curry(f); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args) } }</code> </pre><br>  La funci√≥n de curry toma una funci√≥n para curry, la almacena en un cierre y devuelve una lambda.  La lambda espera el resto de los argumentos de la funci√≥n.  Cada vez que se recibe un argumento, verifica si se aceptan todos los argumentos declarados.  Si se acepta, se llama a la funci√≥n y se devuelve su resultado.  Si no, la funci√≥n se vuelve a curry. <br><br>  Tambi√©n podemos crear una funci√≥n parcialmente aplicada para reemplazar la expresi√≥n regular que necesitamos con una cadena vac√≠a: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsToEmpltyGlobal = curry(replace)(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br>  Todo parece estar bien, pero somos perfeccionistas y no nos gustan demasiados corchetes, nos gustar√≠a a√∫n mejor, as√≠ que escribiremos otra funci√≥n o tal vez dos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> party = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, x</span></span></span><span class="hljs-function">) =&gt;</span></span> (...args) =&gt; fn(x, ...args);</code> </pre><br>  Esta es una implementaci√≥n de abstracci√≥n para crear funciones aplicadas parciales.  Toma una funci√≥n y el primer argumento, devuelve una lambda que espera el resto y ejecuta la funci√≥n. <br><br>  Ahora reescribimos party para que podamos crear una funci√≥n parcialmente aplicada de varios argumentos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> party = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, ...args</span></span></span><span class="hljs-function">) =&gt;</span></span> (...rest) =&gt; fn(...args.concat(rest));</code> </pre><br>  Vale la pena se√±alar por separado que las funciones currificadas de esta manera se pueden invocar con cualquier n√∫mero de argumentos menos que declarado (fn.length). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b,c,d</span></span></span><span class="hljs-function">) =&gt;</span></span> a+b+c+d; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = curry(sum); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r1 = fn(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>);<span class="hljs-comment"><span class="hljs-comment">//,   const r2 = fn(1, 2, 3)(4);//       const r3 = fn(1, 2)(3)(4); const r4 = fn(1)(2)(3)(4); const r5 = fn(1)(2, 3, 4); const r6 = fn(1)(2)(3, 4); const r7 = fn(1, 2)(3, 4);</span></span></code> </pre><br>  Volvamos a nuestros pal√≠ndromos.  Podemos reescribir nuestro replaceAllNotWordSymbolsToEmpltyGlobal sin corchetes adicionales: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsToEmpltyGlobal = party(replace,allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br>  Veamos todo el c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    -       const allNotWordSymbolsRegexpGlobal = () =&gt; /[\.,\/#!$%\^&amp;\*;:{}=\-_~()?\s]/g; const replace = (regexp, replacement, str) =&gt; str.replace(regexp, replacement); const toLowerCase = str =&gt; str.toLowerCase(); const stringReverse = str =&gt; str.split('').reverse().join(''); const isStringsEqual = (strA, strB) =&gt; strA === strB; //       const testString = '    '; //           -    rambda.js const compose = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x); const curry = fn =&gt; (...args) =&gt; { if (fn.length &gt; args.length) { const f = fn.bind(null, ...args); return curry(f); } else { return fn(...args) } } const party = (fn, ...args) =&gt; (...rest) =&gt; fn(...args.concat(rest)); //       const replaceAllNotWordSymbolsToEmpltyGlobal = party(replace,allNotWordSymbolsRegexpGlobal(), ''); const processFormPalindrom = compose( replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase, stringReverse ); const processFormTestString = compose( replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase, ); const checkPalindrom = testString =&gt; isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</span></span></code> </pre><br>  Se ve muy bien, pero ¬øqu√© pasa si no es una cadena para nosotros, pero vendr√° una matriz?  Por lo tanto, agregamos una funci√≥n m√°s: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> (...args) =&gt; args.map(fn);</code> </pre><br>  Ahora, si tenemos una matriz para detectar pal√≠ndromos, entonces: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palindroms = [<span class="hljs-string"><span class="hljs-string">'    '</span></span>,<span class="hljs-string"><span class="hljs-string">'   '</span></span>,<span class="hljs-string"><span class="hljs-string">'   '</span></span>. <span class="hljs-string"><span class="hljs-string">' '</span></span>] map(checkPalindrom )(...palindroms ); <span class="hljs-comment"><span class="hljs-comment">// [true, true, true, false]  </span></span></code> </pre><br>  As√≠ es como resolvimos la tarea escribiendo conjuntos de caracter√≠sticas.  Presta atenci√≥n al estilo in√∫til de escribir c√≥digo: esta es una prueba decisiva de pureza funcional. <br><br>  Ahora un poco m√°s de teor√≠a.  Al usar el curry no olvides que cada vez que curries una funci√≥n creas una nueva, es decir  seleccione una celda de memoria para ello.  Es importante controlar esto para evitar fugas. <br><br>  Las bibliotecas funcionales como ramda.js tienen funciones componer y pipe.  compose implementa el algoritmo de composici√≥n de derecha a izquierda y la tuber√≠a de izquierda a derecha.  Nuestra funci√≥n de componer es un an√°logo de tuber√≠a de ramda.  Hay dos funciones de composici√≥n diferentes en la biblioteca desde  La composici√≥n de derecha a izquierda y de izquierda a derecha son dos contratos diferentes de programaci√≥n funcional.  Si uno de los lectores encuentra un art√≠culo que describe todos los contratos existentes de la FP, luego comp√°rtelo en los comentarios, ¬°lo leer√© con gusto y pondr√© un plus en el comentario! <br><br>  El n√∫mero de par√°metros formales de una funci√≥n se llama <b>aridad</b> .  Esta es tambi√©n una definici√≥n importante desde el punto de vista de la teor√≠a de las transiciones de fase. <br><br><h2>  Conclusi√≥n </h2><br>  En el marco de este art√≠culo, examinamos t√©cnicas de programaci√≥n funcional como composici√≥n, curr√≠culum y aplicaci√≥n parcial.  Por supuesto, en proyectos reales usar√° bibliotecas listas para usar con estas herramientas, pero como parte del art√≠culo, implement√© todo en JS nativo para que los lectores con quiz√°s poca experiencia en FP puedan entender c√≥mo funcionan estas t√©cnicas. <br><br>  Tambi√©n eleg√≠ deliberadamente el m√©todo de narraci√≥n: pseudo codreview, para ilustrar mi l√≥gica de lograr la pureza funcional en el c√≥digo. <br><br>  Por cierto, puede continuar el desarrollo de este m√≥dulo de trabajo con pal√≠ndromos y desarrollar sus ideas, por ejemplo, descargar l√≠neas por api, convertirlas en conjuntos de letras y enviarlas al servidor donde la l√≠nea ser√° generada por el pal√≠ndromo y mucho m√°s ... A su discreci√≥n. <br><br>  Tambi√©n ser√≠a bueno deshacerse de la duplicaci√≥n en los procesos de estas l√≠neas: <br><br><pre> <code class="javascript hljs"> replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase,</code> </pre><br>  En general, ¬°es posible y necesario mejorar el c√≥digo constantemente! <br><br>  Hasta futuros art√≠culos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/475324/">https://habr.com/ru/post/475324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../475306/index.html">El traje: historia y perspectivas</a></li>
<li><a href="../475308/index.html">C√≥mo pasar por un buen programador</a></li>
<li><a href="../475314/index.html">Eco-fantas√≠a para proteger el planeta.</a></li>
<li><a href="../475320/index.html">Recomendaciones de Microsoft para deshabilitar la caducidad de la contrase√±a: consecuencias y conclusiones</a></li>
<li><a href="../475322/index.html">Sonido √≥seo de siguiente nivel: revisi√≥n de Aftershokz Aeropex</a></li>
<li><a href="../475326/index.html">C√≥mo los estafadores hacen esto. Herramientas de enga√±o</a></li>
<li><a href="../475328/index.html">Operaci√≥n TA505, cuarta parte. Gemelos</a></li>
<li><a href="../475330/index.html">Concurso de complementos de la plataforma Miro con un premio de $ 21,000</a></li>
<li><a href="../475336/index.html">C√≥mo dejar de fumar correctamente (instrucci√≥n)</a></li>
<li><a href="../475338/index.html">Si no tiene Python, pero hay un modelo Keras y Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>