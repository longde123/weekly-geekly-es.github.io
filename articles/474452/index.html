<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏻 💅🏽 👵🏼 Informe de estado de otoño de Haxe ⬅️ 🔦 🤛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El 26 de octubre, Linz am Rhein (Alemania) organizó la mini conferencia HaxeUp Sessions 2019 dedicada a Haxe y tecnologías relacionadas. Y su evento m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Informe de estado de otoño de Haxe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474452/"><p>  El 26 de octubre, Linz am Rhein (Alemania) organizó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la mini conferencia HaxeUp Sessions 2019</a> dedicada a Haxe y tecnologías relacionadas.  Y su evento más significativo fue, por supuesto, el lanzamiento final de Haxe 4.0.0 (en el momento de la publicación, es decir, después de aproximadamente una semana, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se lanzó la actualización 4.0.1</a> ).  En este artículo, me gustaría presentarle una traducción del primer informe de la conferencia: un informe sobre el trabajo realizado por el equipo de Haxe para 2019. </p><br><p><img src="https://habrastorage.org/webt/hk/ik/sp/hkiksp6o31il9tcdxjjlm6xnmve.png" alt="imagen"></p><a name="habracut"></a><br><p>  Un poco sobre el autor del informe: </p><br><p>  Simon ha estado trabajando con Haxe desde 2010, cuando todavía era estudiante y escribió un trabajo sobre simulaciones fluidas en Flash.  La implementación de tal simulación requirió acceso constante a los datos que describen el estado de las partículas (en cada paso se realizaron más de 100 consultas a conjuntos de datos sobre el estado de cada celda en la simulación), mientras que trabajar con conjuntos en ActionScript 3 no es tan rápido.  Por lo tanto, la implementación inicial fue simplemente inoperante y necesaria para encontrar una solución a este problema.  En su búsqueda, Simon se encontró con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo de Nicolas Kannass</a> (creador de Haxe) sobre los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">códigos de operación</a> de Alchemy que no estaban documentados y que no estaban disponibles con ActionScript, pero Haxe permitió que se usaran.  ¡Reescribiendo la simulación en Haxe usando códigos de operación, Simon obtuvo una simulación que funciona!  Y así, gracias a las matrices lentas en ActionScript, Simon aprendió sobre Haxe. </p><br><p>  Desde 2011, Simon se unió al desarrollo de Haxe, comenzó a estudiar OCaml (en el que está escrito el compilador) y a hacer varias correcciones al compilador. </p><br><p>  Y desde 2012, se convirtió en el principal desarrollador de compiladores.  En el mismo año, se creó la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fundación Haxe</a> (una organización cuyos objetivos principales son desarrollar y mantener el ecosistema Haxe, ayudar a la comunidad a organizar conferencias y servicios de consultoría), y Simon se convirtió en uno de sus cofundadores. </p><br><p><img src="https://habrastorage.org/webt/ic/n2/-z/icn2-zvorldkegboovusqzxfdbo.png" alt="imagen"></p><br><p>  En 2014-2015, Simon invitó a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Josephine Pertosa</a> a la Fundación Haxe, que con el tiempo se hizo responsable de organizar conferencias y relaciones con la comunidad. </p><br><p>  En 2016, Simon hizo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su</a> primera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentación sobre Haxe</a> , y en 2018 organizó las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primeras Sesiones HaxeUp</a> . </p><br><p><img src="https://habrastorage.org/webt/ii/3p/vq/ii3pvqd1f88pj3toyvcaxjcmjr8.png" alt="imagen"></p><br><p>  Entonces, ¿qué pasó en el mundo de Haxe durante el pasado 2019? </p><br><p>  En febrero y marzo, salieron 2 candidatos de lanzamiento (4.0.0-rc1 y 4.0.0-rc2) <br>  En abril, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aurel Bili</a> (como pasante) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexander Kuzmenko</a> (como desarrollador del compilador) se unieron al equipo de la Fundación Haxe. </p><br><p>  En mayo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se celebró</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Haxe US Summit 2019</a> . <br>  En junio, se lanzó Haxe 4.0.0-rc3.  Y en septiembre: Haxe 4.0.0-rc4 y Haxe 4.0.0-rc5. </p><br><p><img src="https://habrastorage.org/webt/bg/cz/di/bgczdidj4imp0y_rteusgqy-dwq.png" alt="imagen"></p><br><p>  Haxe no solo es un compilador, sino también un conjunto completo de varias herramientas, y durante todo el año también se trabajó constantemente en ellas: <br>  Gracias a los esfuerzos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Andy Lee,</a> Haxe ahora usa Azure Pipelines en lugar de Travis CI y AppVeyor.  Esto significa que el ensamblaje y las pruebas automatizadas ahora son mucho más rápidas. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hugh Sanderson</a> continúa trabajando en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hxcpp</a> (una biblioteca para soportar C ++ en Haxe). <br>  De repente, los usuarios de Github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">terurou</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">takashiski se</a> unieron al trabajo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">exteriores para</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Node.js.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rudy Ges</a> trabajó en soluciones y mejoras para soportar el objetivo de C #. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">George Corney</a> continúa apoyando el generador externo HTML. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jens Fisher está</a> trabajando en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vshaxe</a> (una extensión para VS Code para trabajar con Haxe) y en muchos otros proyectos relacionados con Haxe. </p><br><p><img src="https://habrastorage.org/webt/4c/n-/vr/4cn-vrhfusi6b6adnvyldgpyd7y.png" alt="imagen"></p><br><p>  Y el evento principal del año, por supuesto, fue el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esperado lanzamiento de Haxe 4.0.0</a> (así como neko 2.3.0), que coincidió accidentalmente con el HaxeUp 2019 Linz :) </p><br><p><img src="https://habrastorage.org/webt/z6/n5/w0/z6n5w0pvjr4oecito4cd4w0ge_i.png" alt="imagen"></p><br><p>  Simon dedicó la mayor parte del informe a las nuevas características en Haxe 4.0.0 (también puede aprender sobre ellas a partir del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de Alexander Kuzmenko</a> de la última Cumbre de Estados Unidos Haxe 2019). </p><br><p><img src="https://habrastorage.org/webt/mn/-z/u2/mn-zu2pk84sti-8ztm8hvhmvizm.png" alt="imagen"></p><br><p>  El nuevo intérprete de macros eval es varias veces más rápido que el anterior.  Simon habló de él <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en</a> detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en su discurso en la Haxe Summit EU 2017</a> .  Pero desde entonces ha mejorado las capacidades de depuración del código, corrigió muchos errores, rediseñó la implementación de cadenas. </p><br><p><img src="https://habrastorage.org/webt/d_/j3/uq/d_j3uqwvxpukog8q9pgp9prafrw.png" alt="imagen"></p><br><p> Haxe 4 presenta soporte Unicode para todas las plataformas (excepto Neko).  Simon describió esto en detalle en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discurso del año pasado</a> .  Para el usuario final del compilador, esto significa que la expresión <code>"Haxeは最高だぞ！".length</code> para todas las plataformas siempre devolverá <code>10</code> (de nuevo, excepto Neko). </p><br><p>  La codificación UCS-2 es mínimamente compatible (se utiliza una codificación nativa para cada plataforma / idioma; sería poco práctico tratar de admitir la misma codificación en todas partes): </p><br><ul><li>  JavaScript, Flash, HashLink y C ++ usan codificación UCS-2 </li><li>  para eval, PHP, lua - UTF-8 </li><li>  para Java y C # - UTF-16 </li><li>  para Python - UTF-32 </li></ul><br><p>  Todos los caracteres que están fuera del plano multilingüe principal (incluidos los emoji) se representan como "pares sustitutos"; dichos caracteres se representan con dos bytes.  Por ejemplo, si en Java / C # / JavaScript (es decir, para cadenas en codificaciones UTF-16 y UCS-2) solicita la longitud de una cadena que consta de un emoji, el resultado será "2".  Este hecho debe tenerse en cuenta al trabajar con tales cadenas en estas plataformas. </p><br><p>  Haxe 4 presenta un nuevo tipo de iterador: clave-valor: </p><br><p><img src="https://habrastorage.org/webt/h5/8l/1f/h58l1f46pistrquuipoopbqybeq.png" alt="imagen"></p><br><p>  Funciona con contenedores de tipo <code>Map</code> (diccionarios) y cadenas (usando la clase StringTools), el soporte para matrices aún no se ha implementado.  También es posible implementar dicho iterador para clases personalizadas, para esto es suficiente implementar el método <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> para ellos <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> . </p><br><p>  La nueva metaetiqueta <code>@:using</code> permite asociar extensiones estáticas con tipos en el lugar de su declaración. </p><br><p>  En el ejemplo que se muestra en la diapositiva siguiente, la enumeración <code>MyOption</code> asociada con <code>MyOptionTools</code> , por lo que expandimos estáticamente esta enumeración (que es imposible en la situación habitual) y tenemos la oportunidad de llamar al método <code>get()</code> , refiriéndolo como un método de objeto. </p><br><p><img src="https://habrastorage.org/webt/ol/i7/in/oli7inyhluzdfnval9ohazjh-lg.png" alt="imagen"></p><br><p>  En este ejemplo, el método <code>get()</code> está en línea, lo que también permite que el compilador optimice aún más el código: en lugar de llamar al <code>MyOptionTools.get(myOption)</code> , el compilador sustituirá el valor almacenado, es decir, <code>12</code> . </p><br><p>  Si el método no se declara como incrustable, entonces otra herramienta de optimización disponible para el programador es incrustar las funciones en el lugar de su llamada (línea del sitio de la llamada).  Para hacer esto, al llamar a la función, debe usar adicionalmente la <code>inline</code> : </p><br><p><img src="https://habrastorage.org/webt/4p/bb/xp/4pbbxpcwmgfbabo5dih7lpqdmm0.png" alt="imagen"></p><br><p>  Gracias al trabajo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Daniil Korostelev</a> , Haxe ahora tiene la oportunidad de generar clases de ES6 para JavaScript.  Todo lo que necesita hacer es agregar el indicador de compilación <code>-D js-es=6</code> . </p><br><p>  Actualmente, el compilador genera un archivo js para todo el proyecto (puede ser posible en el futuro generar archivos js separados para cada una de las clases, pero hasta ahora esto solo se puede hacer usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramientas adicionales</a> ). </p><br><p><img src="https://habrastorage.org/webt/md/mk/no/mdmknohyzhrkyftm1frzusodoi4.png" alt="imagen"></p><br><p>  Para enumeraciones abstractas, los valores ahora se generan automáticamente. </p><br><p>  En Haxe 3, era necesario establecer valores manualmente para cada constructor.  En Haxe 4, las enumeraciones abstractas creadas encima de <code>Int</code> comportan de acuerdo con las mismas reglas que en C. Las enumeraciones abstractas creadas encima de las cadenas se comportan de manera similar; para ellos, los valores generados coincidirán con los nombres de los constructores. </p><br><p><img src="https://habrastorage.org/webt/mu/gr/uj/mugrujzah5vmzrw-vcgyjzw42ju.png" alt="imagen"></p><br><p>  También vale la pena mencionar algunas mejoras de sintaxis: </p><br><ul><li>  Las enumeraciones abstractas y las funciones externas se han convertido en miembros completos de Haxe y ahora no necesita usar las metaetiquetas <code>@:enum</code> y <code>@:extern</code> para declararlas. </li><li>  4th Haxe utiliza un nuevo tipo de sintaxis de intersección que refleja mejor la esencia de las estructuras en expansión.  Dichas construcciones son más útiles cuando se declaran estructuras de datos: la expresión <code>typedef T = A &amp; B</code> significa que la estructura <code>T</code> tiene todos los campos que están en los tipos <code>A</code> y <code>B</code> </li><li>  de manera similar, las cuatro restricciones del parámetro de tipo de declaración: la entrada <code>&lt;T:A &amp; B&gt;</code> indica que el tipo de parámetro <code>T</code> debe ser tanto <code>A</code> como <code>B</code> </li><li>  la sintaxis anterior funcionará (excepto la sintaxis para restricciones de tipo, porque entrará en conflicto con la nueva sintaxis para describir los tipos de función) </li></ul><br><p><img src="https://habrastorage.org/webt/ju/gt/yu/jugtyumi4hrt7fvt7ridshgzt5a.png" alt="imagen"></p><br><p>  La nueva sintaxis para describir los tipos de función (sintaxis de tipo de función) es más lógica: usar paréntesis alrededor de los tipos de argumentos de función es visualmente más fácil de leer.  Además, la nueva sintaxis le permite definir nombres de argumentos, que se pueden usar como parte de la documentación del código (aunque no afecta la escritura en sí). </p><br><p><img src="https://habrastorage.org/webt/1v/yu/y5/1vyuy5q4ayqlbteqmq3ugx9lzba.png" alt="imagen"></p><br><p>  En este caso, la sintaxis anterior sigue siendo compatible y no está en desuso, ya que  de lo contrario, requeriría demasiados cambios en el código existente (Simon mismo constantemente se encuentra fuera de hábito y continúa usando la sintaxis anterior). </p><br><p>  ¡Haxe 4 finalmente tiene funciones de flecha (o expresiones lambda)! </p><br><p><img src="https://habrastorage.org/webt/vh/49/oo/vh49oomjlu8y1o1t5cs-jmzv7nm.png" alt="imagen"></p><br><p>  Las características de las funciones de flecha en Haxe son: </p><br><ul><li>  <code>return</code> implícito  Si el cuerpo de la función consta de una expresión, esta función devuelve implícitamente el valor de esta expresión </li><li>  Es posible establecer los tipos de argumentos de función, porque  el compilador no siempre puede determinar el tipo requerido (por ejemplo, <code>Float</code> o <code>Int</code> ) </li><li>  si el cuerpo de la función consta de varias expresiones, entonces necesita rodearlo con llaves </li><li>  pero no hay forma de establecer explícitamente el tipo de retorno de la función </li></ul><br><p>  En general, la sintaxis de las funciones de flecha es muy similar a la utilizada en Java 8 (aunque funciona de manera algo diferente). </p><br><p>  Y como mencionamos Java, debería decirse que en Haxe 4 se hizo posible generar bytecode JVM directamente.  Para hacer esto, al compilar un proyecto en Java, simplemente agregue el indicador <code>-D jvm</code> . </p><br><p>  Generar un código de bytes JVM significa que no hay necesidad de usar un compilador Java, y el proceso de compilación es mucho más rápido. </p><br><p><img src="https://habrastorage.org/webt/ut/bc/mw/utbcmwnuwk1ade_vqrztz5rzhjk.png" alt="imagen"></p><br><p>  Hasta ahora, el objetivo JVM tiene un estado experimental por las siguientes razones: </p><br><ul><li>  en algunos casos, el código de bytes es un poco más lento que el resultado de traducir Haxe en Java y luego compilarlo con javac.  Pero el equipo compilador es consciente del problema y sabe cómo solucionarlo, solo requiere trabajo adicional. </li><li>  Hay problemas con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MethodHandle</a> en Android, que también requiere trabajo adicional (Simon se alegrará si se le ayuda a resolver estos problemas). </li></ul><br><p><img src="https://habrastorage.org/webt/yo/ho/r5/yohor5rg8cydts1horbcezmqqf0.png" alt="imagen"></p><br><p>  Una comparación general de generar bytecode directamente (genjvm) y compilar Haxe en código Java, que luego se compila en bytecode (genjava): </p><br><ul><li>  como ya se mencionó, en términos de velocidad de compilación, genjvm es más rápido que genjava <br>  en términos de velocidad de ejecución, bytecode genjvm sigue siendo inferior a genjava </li><li>  hay algunos problemas al usar parámetros de tipo y genjava </li><li>  genJvm usa MethodHandle para referirse a funciones, y genjava usa las llamadas "funciones Waneck" (en honor a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kaui Vanek</a> , gracias a las cuales Java y C # aparecieron en Haxe).  Aunque el código obtenido usando las funciones Waneck no se ve hermoso, funciona y funciona lo suficientemente rápido. </li></ul><br><p>  Consejos generales para trabajar con Java en Haxe: </p><br><ul><li>  Debido al hecho de que el recolector de basura en Java es rápido, los problemas asociados con él son raros.  Por supuesto, crear objetos nuevos constantemente no es una buena idea, pero Java hace un buen trabajo al administrar la memoria y la necesidad de ocuparse constantemente de las asignaciones no es tan grave como en algunas otras plataformas compatibles con Haxe (por ejemplo, en HashLink) </li><li>  Acceder a los campos de una clase en un destino jvm puede funcionar muy lentamente en el caso cuando esto se hace a través de una estructura ( <code>typedef</code> ), mientras que el compilador no puede optimizar dicho código </li><li>  Se debe evitar el uso excesivo de la palabra clave en <code>inline</code> : el compilador JIT hace un trabajo bastante bueno </li><li>  Evite usar <code>Null&lt;T&gt;</code> , especialmente cuando se trata de cálculos matemáticos complejos.  De lo contrario, aparecerán muchas declaraciones condicionales en el código generado, lo que afectará negativamente la velocidad de su código. </li></ul><br><p>  La nueva función Haxe 4, Seguridad nula, puede ayudar a evitar el uso de <code>Null&lt;T&gt;</code> .  Alexander Kuzmenko habló <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en</a> detalle sobre ella <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el HaxeUp del año pasado</a> . </p><br><p><img src="https://habrastorage.org/webt/wx/hk/vk/wxhkvkjk-aq9pjo4mlp6l9hxrzi.png" alt="imagen"></p><br><p>  En el ejemplo de la diapositiva anterior, el método static <code>safe()</code> tiene habilitado el modo Estricto para verificar la seguridad nula, y este método tiene un parámetro <code>arg</code> opcional, que puede tener un valor nulo.  Para que esta función se compile con éxito, el programador deberá agregar una verificación del valor del argumento <code>arg</code> (de lo contrario, el compilador mostrará un mensaje sobre la imposibilidad de llamar al método <code>charAt()</code> en un objeto potencialmente nulo). </p><br><p><img src="https://habrastorage.org/webt/sd/mq/md/sdmqmdmuv3lauh3wopzzblnxm8k.png" alt="imagen"></p><br><p>  La seguridad nula se puede configurar tanto a nivel de paquete (usando una macro) como a tipos y campos individuales de objetos (usando la metaetiqueta <code>@:nullSafety</code> ). </p><br><p>  Los modos en que funcionan las comprobaciones de seguridad nula son: estricto, suelto y desactivado.  Globalmente, estas comprobaciones están deshabilitadas (modo desactivado).  Cuando están activados, el modo Loose se usa de manera predeterminada (a menos que especifique explícitamente el modo).  La diferencia clave entre los modos Loose y Strict es que el modo Loose ignora la posibilidad de cambiar los valores entre operaciones para acceder a estos valores.  En el ejemplo de la diapositiva a continuación, vemos que se ha agregado una verificación <code>null</code> para la variable <code>x</code> .  Sin embargo, en modo estricto, este código no se compila, porque  antes de trabajar directamente con la variable <code>x</code> , se <code>sideEffect()</code> método <code>sideEffect()</code> , que potencialmente puede anular el valor de esta variable, por lo que deberá agregar otra verificación o copiar el valor de la variable a una variable local, con la que continuaremos trabajando. </p><br><p><img src="https://habrastorage.org/webt/m6/sq/6w/m6sq6w1wgue4r9fiylnchvfaxk4.png" alt="imagen"></p><br><p>  Haxe 4 presenta una nueva palabra clave <code>final</code> , que tiene un significado diferente según el contexto: </p><br><ul><li>  si lo usa en lugar de la palabra clave <code>var</code> , al campo declarado de esta manera no se le puede asignar un nuevo valor.  Solo puede configurarlo directamente al declarar (para campos estáticos) o en el constructor (para campos no estáticos) </li><li>  si lo usa al declarar una clase, prohibirá la herencia de ella </li><li>  si lo usa como modificador para acceder a la propiedad de un objeto, esto prohíbe la redefinición de getter / setter en las clases herederas. </li></ul><br><p><img src="https://habrastorage.org/webt/fo/je/_6/foje_6ftilhqwsyhnb-zbskf-l8.png" alt="imagen"></p><br><p>  Teóricamente, el compilador, después de cumplir con la palabra clave <code>final</code> , puede intentar optimizar el código, suponiendo que el valor de este campo no cambia.  Pero por ahora, esta posibilidad solo se está considerando y no se implementa en el compilador. </p><br><p><img src="https://habrastorage.org/webt/aa/z_/th/aaz_thozjk6apzimnpf15tsfsja.png" alt="imagen"></p><br><p>  Y un poco sobre el futuro de Haxe: </p><br><ul><li>  actualmente trabajando en API de E / S asíncrona <br>  El apoyo de rutina está planeado, pero hasta ahora, el trabajo en ellos está estancado en la etapa de planificación.  Quizás aparezcan en Haxe 4.1, y quizás más tarde. </li><li>  la optimización de la cola aparecerá en el compilador </li><li>  y posiblemente las <a href="">funciones disponibles a nivel de módulo</a> .  Aunque la prioridad de esta función cambia constantemente </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474452/">https://habr.com/ru/post/474452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474440/index.html">Dificultades para calcular los ingresos de suscripciones auto-renovables en aplicaciones iOS</a></li>
<li><a href="../474442/index.html">Historia de Irish Life Extension</a></li>
<li><a href="../474444/index.html">5 proyectos de entrenamiento más atrevidos para el desarrollador (Layer, Squoosh, Calculator, Website Crawler, Music Player)</a></li>
<li><a href="../474448/index.html">De lo que es capaz el cerebro de un estudiante en el mundo de la informática</a></li>
<li><a href="../474450/index.html">Deje de usar TTL ridículamente pequeño para DNS</a></li>
<li><a href="../474458/index.html">Total acumulativo en SQL</a></li>
<li><a href="../474460/index.html">Descripción de arquitecturas de procesador en LLVM usando TableGen</a></li>
<li><a href="../474462/index.html">Enorme conjunto de datos abierto del discurso ruso versión 1.0</a></li>
<li><a href="../474466/index.html">Historia del primer diablo</a></li>
<li><a href="../474470/index.html">Ataque DDoS en servicios RDP: reconocer y superar. Experiencia exitosa de Tucha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>