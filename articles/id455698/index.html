<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💌 🌇 👨🏽‍🎓 Buku "Bagaimana JavaScript Bekerja" 🆖 ⛏️ 👅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebagian besar bahasa pemrograman tumbuh dari paradigma kuno yang berasal dari zaman Fortran. Guru JavaScript Douglas Crockford mencabut akar-akar ker...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku "Bagaimana JavaScript Bekerja"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/455698/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/9u/n9/3z/9un93z79xbk2sybh806isswhjxw.jpeg" align="left" alt="gambar"></a>  Sebagian besar bahasa pemrograman tumbuh dari paradigma kuno yang berasal dari zaman Fortran.  Guru JavaScript Douglas Crockford mencabut akar-akar kering ini, memungkinkan kita untuk berpikir tentang masa depan pemrograman, pindah ke tingkat baru dalam memahami persyaratan untuk Bahasa Selanjutnya. <br><br>  Penulis mulai dengan dasar-dasar: nama, angka, nilai logis, karakter, dan informasi dasar lainnya.  Anda akan belajar tidak hanya tentang masalah dan kesulitan bekerja dengan tipe dalam JavaScript, tetapi juga bagaimana cara mengatasinya.  Anda kemudian akan mulai membiasakan diri dengan struktur data dan fungsi untuk memahami mekanisme yang mendasarinya, dan belajar bagaimana menggunakan fungsi tingkat tinggi dan gaya pemrograman berorientasi objek tanpa kelas. <br><a name="habracut"></a><br><h3>  Kutipan <br>  Bagaimana kode bekerja tanpa kelas </h3><br>  Dan Anda berpikir bahwa Anda pintar di luar semua kelas dan gratis. <br>  <i>John Lennon</i> <br><br>  Salah satu ide kunci dalam pengembangan pemrograman berorientasi objek adalah model untuk pertukaran data antara bagian-bagian program.  Nama metode dan argumennya harus direpresentasikan dalam bentuk pesan.  Panggilan metode mengirim pesan ke objek.  Setiap objek ditandai oleh perilakunya sendiri, yang dimanifestasikan saat menerima pesan tertentu.  Pengirim yakin bahwa penerima tahu apa yang harus dilakukan dengan pesan tersebut. <br><br>  Satu manfaat tambahan adalah polimorfisme.  Setiap objek yang mengenali pesan tertentu memiliki hak untuk menerimanya.  Apa yang terjadi selanjutnya tergantung pada spesialisasi objek.  Dan ini adalah pemikiran yang sangat produktif. <br><br>  Sayangnya, kami mulai terganggu oleh warisan - skema yang sangat efektif untuk menggunakan kembali kode.  Pentingnya dikaitkan dengan kemampuan untuk mengurangi biaya tenaga kerja saat mengembangkan suatu program.  Warisan dibangun di atas rencana yang sama, dengan pengecualian beberapa nuansa.  Kita dapat mengatakan bahwa beberapa objek atau kelas objek mirip dengan beberapa objek atau kelas objek lain, tetapi memiliki beberapa perbedaan penting.  Dalam situasi yang sederhana, semuanya bekerja dengan baik.  Harus diingat bahwa OOP modern dimulai dengan Smalltalk, bahasa pemrograman untuk anak-anak.  Ketika situasinya menjadi lebih rumit, pewarisan menjadi problematis.  Ini menimbulkan kohesi kelas yang kuat.  Mengubah satu kelas dapat menyebabkan kegagalan di kelas-kelas yang bergantung padanya.  Modul dari kelas tidak berguna. <br><br>  Selain itu, kami mengamati peningkatan perhatian pada properti, dan bukan pada objek.  Perhatian khusus diberikan pada metode untuk memperoleh (mendapatkan-metode) dan menetapkan (set-metode) nilai untuk masing-masing properti individu, dan bahkan dalam proyek yang kurang berhasil, properti terbuka dan dapat diubah tanpa sepengetahuan objek.  Sangat mungkin untuk memperkenalkan proyek yang lebih sukses, di mana properti disembunyikan, dan metode memproses transaksi, tidak hanya berurusan dengan perubahan properti.  Namun pendekatan ini tidak sering diterapkan. <br><br>  Selain itu, ada terlalu banyak ketergantungan tipe.  Jenis menjadi fitur bahasa Fortran dan kemudian, karena mereka nyaman bagi pembuat kompiler.  Sejak itu, mitologi seputar tipe telah berkembang, setelah memperoleh klaim berlebihan bahwa tipe melindungi program dari kesalahan.  Meskipun pengabdian pada tipe, kesalahan tidak meninggalkan praktik sehari-hari. <br><br>  Jenis dihormati dan dipuji untuk deteksi dini kesalahan perhitungan pada tahap kompilasi.  Semakin cepat pengawasan ditemukan, semakin rendah biaya yang diperlukan untuk menghilangkannya.  Tetapi dengan pengujian program yang tepat, semua kesalahan perhitungan ini terdeteksi dengan sangat cepat.  Oleh karena itu, kesalahan identifikasi jenis diklasifikasikan sebagai biaya rendah. <br><br>  Tipe tidak bisa disalahkan atas penampilan kesalahan yang sulit dideteksi dan mahal.  Kesalahan mereka bukanlah dalam terjadinya masalah yang disebabkan oleh kesalahan seperti itu dan membutuhkan beberapa trik.  Jenis dapat mendorong kita untuk menggunakan metode pemrograman yang tidak jelas, membingungkan, dan meragukan. <br><br>  Jenisnya seperti diet penurunan berat badan.  Diet tidak dituduh kembali dan menambah berat badan.  Ia juga tidak dianggap sebagai penyebab penderitaan atau masalah kesehatan yang ditimbulkannya.  Diet memberi harapan bahwa berat badan akan kembali ke norma yang sehat dan kita akan terus makan junk food. <br><br>  Warisan klasik memungkinkan kita berpikir bahwa kita membuat program berkualitas tinggi, sementara kita membuat lebih banyak kesalahan dan menerapkan warisan yang semakin tidak efisien.  Jika Anda mengabaikan manifestasi negatif, tipe tersebut tampaknya menjadi kemenangan besar.  Manfaatnya jelas.  Tetapi jika Anda melihat jenisnya lebih dekat, Anda akan melihat bahwa biayanya melebihi manfaatnya. <br><br><h3>  Konstruktor </h3><br>  Dalam bab 13, kami bekerja dengan pabrik - fungsi yang mengembalikan fungsi.  Sekarang kita dapat melakukan sesuatu yang mirip dengan konstruktor - fungsi yang mengembalikan objek yang berisi fungsi. <br><br>  Mari kita mulai dengan membuat counter_constructor, mirip dengan generator penghitung.  Ini memiliki dua metode, atas dan ke bawah: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counter_constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">down</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ counter -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({ up, down }); }</code> </pre> <br>  Objek yang dikembalikan beku.  Itu tidak dapat rusak atau rusak.  Objek memiliki status.  Penghitung variabel adalah properti pribadi objek.  Anda dapat mengaksesnya hanya melalui metode.  Dan kita tidak perlu menggunakan ini. <br><br>  Ini adalah keadaan yang sangat penting.  Antarmuka objek adalah metode eksklusif.  Dia memiliki cangkang yang sangat kuat.  Kami mendapatkan enkapsulasi terbaik.  Tidak ada akses langsung ke data.  Ini adalah desain modular yang sangat berkualitas tinggi. <br><br>  Konstruktor adalah fungsi yang mengembalikan objek.  Parameter dan variabel konstruktor menjadi properti pribadi objek.  Tidak memiliki properti publik yang terdiri dari data.  Fungsi internal menjadi metode objek.  Mereka mengubah properti menjadi yang tertutup.  Metode yang jatuh ke objek beku terbuka. <br><br>  Metode harus menerapkan transaksi.  Misalkan, misalnya, kita memiliki objek seseorang.  Anda mungkin perlu mengubah alamat orang yang datanya tersimpan di dalamnya.  Untuk melakukan ini, Anda tidak perlu satu set fungsi terpisah untuk mengubah setiap elemen alamat individual.  Kita memerlukan satu metode yang menerima objek literal, yang mampu menggambarkan semua bagian dari alamat yang perlu diubah. <br><br>  Salah satu ide cemerlang dalam JavaScript adalah objek literal.  Ini adalah sintaks yang bagus dan ekspresif untuk informasi pengelompokan.  Dengan membuat metode yang mengkonsumsi dan membuat objek data, Anda dapat mengurangi jumlah metode, sehingga meningkatkan integritas objek. <br><br>  Ternyata kami memiliki dua jenis objek. <br><br><ul><li>  Objek keras hanya berisi metode.  Objek-objek ini melindungi integritas data yang terkandung dalam penutupan.  Mereka memberi kita polimorfisme dan enkapsulasi. </li><li>  Objek data lunak hanya berisi data.  Mereka tidak punya perilaku.  Ini hanya koleksi praktis yang dapat berfungsi dengan fungsi. </li></ul><br>  Dipercayai bahwa OOP dimulai dengan menambahkan prosedur pada catatan dalam bahasa Kobol, sehingga memastikan semacam perilaku.  Saya percaya bahwa kombinasi metode data dan properti merupakan langkah maju yang penting, tetapi seharusnya tidak menjadi langkah terakhir. <br><br>  Jika objek keras harus dikonversi ke string, metode toJSON harus diaktifkan.  Jika tidak, JSON.stringify akan melihatnya sebagai objek kosong, mengabaikan metode dan data tersembunyi (lihat bab 22). <br><br><h3>  Opsi konstruktor </h3><br>  Suatu ketika saya membuat konstruktor yang membutuhkan sepuluh argumen.  Itu sangat sulit digunakan, karena tidak ada yang bisa mengingat urutan argumennya.  Kemudian diketahui bahwa tidak ada yang menggunakan argumen kedua, saya ingin menghapusnya dari daftar parameter, tetapi itu akan memecah semua kode yang sudah dikembangkan. <br><br>  Jika saya bijaksana, saya akan memiliki konstruktor yang mengambil satu objek sebagai parameter.  Biasanya diambil dari objek literal, tetapi dapat berasal dari sumber lain, misalnya, dari konten JSON. <br><br>  Ini akan memberikan banyak manfaat. <br><br><ul><li>  Baris kunci memberi kode tampilan yang terdokumentasi.  Kode lebih mudah dibaca karena memberi tahu Anda apa masing-masing argumen kepada penelepon. </li><li>  Argumen dapat diatur dalam urutan apa pun. </li><li>  Di masa mendatang, Anda dapat menambahkan argumen baru tanpa merusak kode yang ada. </li><li>  Parameter yang tidak relevan dapat diabaikan. </li></ul><br>  Paling sering, parameter digunakan untuk menginisialisasi properti pribadi.  Ini dilakukan sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_little_constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spec</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { name, mana_cost, colors, type, supertypes, types, subtypes, text, flavor, power, toughness, loyalty, timeshifted, hand, life } = spec;</code> </pre> <br>  Kode ini membuat dan menginisialisasi 15 variabel pribadi menggunakan properti dengan nama yang sama dari spec.  Jika spec tidak memiliki properti yang sesuai, variabel baru diinisialisasi, yang diberi nilai yang tidak ditentukan.  Ini memungkinkan Anda untuk mengisi semua nilai yang hilang dengan nilai default. <br><br><h3>  Komposisi </h3><br>  Ekspresi yang jelas dan efektifitas JavaScript memungkinkan Anda membuat program dalam paradigma klasik, meskipun bahasa ini tidak berlaku untuk yang klasik.  JavaScript juga memungkinkan untuk peningkatan.  Kami dapat bekerja dengan komposisi fungsional.  Jadi, alih-alih menambahkan sesuatu sebagai pengecualian, Anda bisa mendapatkan sedikit ini dan itu.  Konstruktor memiliki tampilan umum berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_little_constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spec</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {} = spec; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _ = other_constructor(spec); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>  = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   spec, , _,  }; return Object.freeze({ , _. }); }</span></span></code> </pre> <br>  Konstruktor Anda dapat memanggil sebanyak mungkin konstruktor lain yang diperlukan untuk mendapatkan akses ke manajemen negara dan perilaku yang mereka berikan.  Anda bahkan dapat melewatkannya objek spec yang sama persis.  Dengan mendokumentasikan parameter spesifikasi, kami mencantumkan properti yang dibutuhkan oleh my_little_constructor dan properti yang dibutuhkan oleh konstruktor lain. <br><br>  Kadang-kadang Anda bisa menambahkan metode yang dihasilkan ke objek beku.  Dalam kasus lain, kami memiliki metode baru yang memanggil metode yang diterima.  Ini memastikan bahwa kode digunakan kembali, mirip dengan warisan, tetapi tanpa kohesi yang kuat.  Panggilan fungsi adalah skema penggunaan kembali kode asli, dan tidak ada yang lebih baik yang telah ditemukan. <br><br><h3>  Ukuran </h3><br>  Dengan pendekatan ini untuk membangun suatu objek, lebih banyak memori yang terlibat daripada ketika menggunakan prototipe, karena setiap objek kaku berisi semua metode objek, dan objek prototipe berisi tautan ke prototipe yang berisi metode.  Apakah perbedaan dalam konsumsi memori signifikan?  Membandingkan perbedaan dengan pencapaian terbaru dalam meningkatkan jumlah memori, kita dapat mengatakan: tidak.  Kita terbiasa membaca memori dalam kilobyte.  Dan sekarang kami mempertimbangkannya dalam gigabytes.  Terhadap latar belakang ini, perbedaannya tidak terasa sama sekali. <br><br>  Perbedaannya dapat dikurangi dengan meningkatkan modularitas.  Penekanan pada transaksi, bukan properti, memungkinkan Anda untuk mengurangi jumlah metode, dan pada saat yang sama meningkatkan konektivitas. <br><br>  Model klasik ditandai oleh keseragaman.  Setiap objek harus merupakan turunan dari kelas.  JavaScript menghapus batasan ini.  Tidak semua objek harus mematuhi aturan ketat seperti itu. <br><br>  Sebagai contoh, saya percaya bahwa tidak masuk akal jika poin menjadi objek yang kaku dengan metode.  Suatu titik bisa menjadi wadah sederhana untuk dua atau tiga angka.  Poin diteruskan ke fungsi yang mampu proyeksi, atau interpolasi, atau hal lain yang dapat dilakukan dengan poin.  Ini bisa menjadi jauh lebih produktif daripada poin subclassing untuk memberi mereka perilaku khusus.  Biarkan fungsinya bekerja. <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 25% untuk penjaja - <b>JavaScript</b> <br><br>  Setelah pembayaran versi kertas buku, sebuah buku elektronik dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455698/">https://habr.com/ru/post/id455698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455684/index.html">Mengapa kami melakukan hackathon untuk penguji</a></li>
<li><a href="../id455686/index.html">Bagaimana Memilih Alat Manajemen Proyek Terbaik Jika Anda Seorang Milenial?</a></li>
<li><a href="../id455692/index.html">ASZP: restyling atau teater dimulai dengan gantungan</a></li>
<li><a href="../id455694/index.html">Arsitektur Penagihan Generasi Selanjutnya: Transisi ke Tarantool</a></li>
<li><a href="../id455696/index.html">Keadaan elektronik masa depan. Bagian 2</a></li>
<li><a href="../id455700/index.html">4 trik yang membantu kami mengoptimalkan frontend</a></li>
<li><a href="../id455702/index.html">Pembuatan angka efektif dalam interval yang diberikan</a></li>
<li><a href="../id455710/index.html">Mengapa kita di Leroy Merlin membutuhkan departemen pengembangan Rusia kita sendiri untuk 200 orang</a></li>
<li><a href="../id455714/index.html">Ekspor Formulir Google secara otomatis ke Notion menggunakan IFTTT dan Django</a></li>
<li><a href="../id455716/index.html">15 Praktik Terbaik untuk Menyebarkan Perangkat Lunak Business Intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>