<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèΩ üíÉüèø üë©üèª‚Äçüíª Tipos dependientes: el futuro de los lenguajes de programaci√≥n ‚òÑÔ∏è üíÜüèº ‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 A pesar de la extravagancia y cierta abstracci√≥n del tema considerado hoy, esperamos que pueda diversificar su fin de semana. Al fina...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos dependientes: el futuro de los lenguajes de programaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432416/">  Hola a todos! <br><br>  A pesar de la extravagancia y cierta abstracci√≥n del tema considerado hoy, esperamos que pueda diversificar su fin de semana.  Al final de la publicaci√≥n, colocamos tres enlaces del autor, lo que le permite familiarizarse con la escritura dependiente en Idris, F * y JavaScript <br><a name="habracut"></a><br>  A veces parece que los lenguajes de programaci√≥n no han cambiado mucho desde los a√±os 60.  Cuando me cuentan sobre esto, a menudo recuerdo cu√°ntas herramientas y funciones interesantes tenemos ahora a nuestra disposici√≥n y c√≥mo simplifican nuestras vidas.  De antemano: se trata de depuradores integrados, y pruebas unitarias, y analizadores est√°ticos, e IDE geniales, as√≠ como matrices escritas y mucho m√°s.  El desarrollo de los idiomas es un proceso largo y progresivo, y no existen tales "balas de plata" con las cuales el desarrollo de los idiomas cambiar√≠a de una vez por todas. <br><br>  Hoy quiero contarles sobre una de las √∫ltimas etapas de este proceso continuo.  La tecnolog√≠a que se discutir√° a√∫n se est√° estudiando activamente, pero todo indica que pronto se arraigar√° en los idiomas principales.  Y nuestra historia comienza con uno de los conceptos m√°s fundamentales en inform√°tica: con los <b>tipos</b> . <br><br><h2>  Mundo de tipos </h2><br>  Escribir es una de esas cosas que son tan inseparables de nuestro pensamiento que apenas pensamos en el concepto de tipos como tal.  ¬øPor qu√© es 1 un <code>int</code> , pero si solo pones este valor entre comillas y se convierte en una <code>string</code> ?  ¬øQu√© es un "tipo" en esencia?  Como suele ser el caso en la programaci√≥n, la respuesta depende de la redacci√≥n de la pregunta. <br><br>  Los tipos son diversos.  En algunos sistemas de tipos, existen l√≠mites muy claros entre tipos y valores.  Entonces, 3, 2 y 1 son valores <code>integer</code> , pero <code>integer</code> no es un valor.  Esta construcci√≥n est√° "incrustada" en el lenguaje y fundamentalmente diferente del significado.  Pero, de hecho, esa diferencia no es necesaria y solo puede limitarnos. <br><br>  Si libera los tipos y los convierte en otra categor√≠a de valores, se abren una serie de posibilidades sorprendentes.  Los valores se pueden almacenar, convertir y pasar a funciones.  Por lo tanto, ser√≠a posible hacer una funci√≥n que tome un tipo como par√°metro, creando funciones generalizadas: aquellas que pueden funcionar con muchos tipos sin sobrecargas.  Puede tener una matriz de valores de un tipo dado, en lugar de hacer una extra√±a aritm√©tica de puntero y conversi√≥n de tipo, como debe hacer en C. Tambi√©n puede recopilar nuevos tipos a medida que se ejecuta el programa y proporcionar caracter√≠sticas como la deserializaci√≥n JSON autom√°tica.  Pero, incluso si trata los tipos como valores, a√∫n no puede hacer todo lo que los tipos pueden hacer con los valores.  Entonces, al operar con instancias de usuario, puede, por ejemplo, comparar sus nombres, verificar su edad o identificador, etc. <br><br><pre> <code class="plaintext hljs">if user.name == "Marin" &amp;&amp; user.age &lt; 65 { print("You can't retire yet!") }</code> </pre> <br>  Sin embargo, cuando intenta hacer lo mismo con el tipo de <code>User</code> , solo puede comparar nombres de tipos y posiblemente nombres de propiedades.  Dado que este es un tipo, no una instancia, no puede verificar los valores de sus propiedades. <br><br><pre> <code class="plaintext hljs">if typeof(user) == User { print("Well, it's a user. That's all I know") }</code> </pre> <br>  ¬øQu√© tan genial ser√≠a si tuvi√©ramos una funci√≥n capaz de recibir solo una lista no vac√≠a de usuarios?  ¬øO una funci√≥n que aceptar√≠a una direcci√≥n de correo electr√≥nico solo si est√° registrada en el formato correcto?  Para estos fines, necesitar√≠a los tipos "matriz no vac√≠a" o "direcci√≥n de correo electr√≥nico".  En este caso, es un tipo dependiente del valor, es decir  sobre el <b>tipo dependiente</b>  En los idiomas principales, esto no es posible. <br><br>  Para que se puedan usar los tipos, el compilador debe verificarlos.  Si afirma que la variable contiene un entero, ser√≠a mejor si no hubiera una <code>string</code> , de lo contrario el compilador jurar√°.  En principio, esto es bueno, porque no nos permite cortejar.  La comprobaci√≥n de tipos es bastante simple: si una funci√≥n devuelve un <code>integer</code> e intentamos devolver <code>"Marin"</code> , entonces esto es un error. <br><br>  Sin embargo, con los tipos dependientes, las cosas se vuelven m√°s complicadas.  El problema es cuando exactamente el compilador verifica los tipos.  ¬øC√≥mo puede asegurarse de que haya exactamente tres valores en la matriz, si el programa a√∫n no se est√° ejecutando?  ¬øC√≥mo asegurarse de que un n√∫mero entero sea mayor que 3, si a√∫n no est√° asignado?  Hay <i>magia</i> en esto ... o, en otras palabras, <i>matem√°ticas</i> .  Si se puede demostrar matem√°ticamente que el conjunto de n√∫meros siempre es mayor que 3, entonces el compilador puede verificar esto. <br><br><h2>  Matem√°ticas en el estudio! </h2><br>  <b>La inducci√≥n matem√°tica</b> se usa para formular evidencia.  La inducci√≥n nos permite confirmar incondicionalmente la verdad de una declaraci√≥n.  Por ejemplo, queremos demostrar que la siguiente f√≥rmula matem√°tica es v√°lida para cualquier n√∫mero positivo: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + x = x * (x + 1) / 2</code> </pre> <br>  Hay un n√∫mero infinito de x posibles, por lo que nos llevar√≠a mucho tiempo verificar todos los n√∫meros manualmente.  Afortunadamente, esto no es necesario.  Solo necesitamos probar dos cosas: <br><br><ol><li>  Esta declaraci√≥n se observa para el primer d√≠a.  (Generalmente es 0 o 1) </li><li>  Si esta afirmaci√≥n es verdadera para el n√∫mero <code>n</code> , entonces ser√° verdadera para el siguiente n√∫mero <code>n + 1</code> </li></ol><br>  Dado que la declaraci√≥n se observa tanto para el primer n√∫mero como para todos los n√∫meros siguientes, sabemos que es cierto para todos los n√∫meros posibles. <br><br>  Probar esto no es dif√≠cil: <br><br><pre> <code class="plaintext hljs">1 = 1 * (1 + 1) / 2 1 = 1</code> </pre> <br>  Ahora tambi√©n tenemos que demostrar que la declaraci√≥n es v√°lida para todos los dem√°s n√∫meros.  Para hacer esto, suponga que funciona para alg√∫n n√∫mero n, y luego aseg√∫rese de que tambi√©n funcione para n + 1. <br><br>  Asumiendo que la siguiente expresi√≥n es verdadera: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + n = n * (n + 1) / 2</code> </pre> <br>  Compru√©balo para <code>n + 1</code> : <br><br><pre> <code class="plaintext hljs">(1 + 2 + 3 + ... + n) + (n + 1) = (n + 1) * ((n + 1) + 1) / 2</code> </pre> <br>  Por lo tanto, podemos reemplazar <code>"(1 + 2 + 3 + ... + n)"</code> igualdad anterior: <br><br><pre> <code class="plaintext hljs">(n * (n + 1) / 2) + (n + 1) = (n + 1) * ((n + 2) / 2)</code> </pre> <br>  y simplificar a <br><br><pre> <code class="plaintext hljs">(n + 1) * (n/2 + 1) = (n + 1) * (n/2 + 1)</code> </pre> <br>  Como ambas partes de la expresi√≥n son iguales, nos aseguramos de que esta afirmaci√≥n sea verdadera.  Esta es una de las formas en que puede verificar la verdad de las declaraciones sin calcular manualmente cada caso, y es sobre la base de este principio que funcionan los tipos dependientes.  Escribe una declaraci√≥n matem√°tica para asegurarse de que la tesis de tipo sea verdadera. <br><br>  La belleza de este enfoque radica en el hecho de que cualquier prueba matem√°tica puede emitirse en forma de un programa de computadora, ¬°y esto es lo que necesitamos! <br><br><h2>  De vuelta a la programaci√≥n </h2><br>  Entonces, descubrimos que algunas cosas pueden probarse primero y luego pasar a valores espec√≠ficos.  Para hacer esto en un lenguaje de programaci√≥n, necesita una forma de expresar estas declaraciones en c√≥digo que se escribir√° en el sistema de tipos en s√≠, es decir, el sistema de tipos debe mejorarse. <br><br>  Considera un ejemplo.  Aqu√≠ tenemos una funci√≥n append que toma dos matrices y las combina.  Como regla general, la firma de dicha funci√≥n se ver√° as√≠: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; Array</code> </pre> <br>  Sin embargo, con solo mirar la firma, no podemos estar seguros de la implementaci√≥n correcta.  El hecho de que la funci√≥n devuelva una matriz no significa que haya hecho algo.  Una forma de verificar el resultado es asegurarse de que la longitud de la matriz resultante sea igual a la suma de las longitudes de las matrices de par√°metros. <br><br><pre> <code class="plaintext hljs">newArray = append([1], [2, 3]) assert(length(newArray) == 3)</code> </pre> <br>  Pero, ¬øpor qu√© verificar esto en tiempo de ejecuci√≥n si puede crear una restricci√≥n que se verificar√° en tiempo de compilaci√≥n? <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; newArray: Array where length(newArray) == length(arr1) + length(arr2)</code> </pre> <br>  Declaramos que <code>append</code> es una funci√≥n que toma dos argumentos de <code>Array</code> y devuelve un nuevo argumento de <code>Array</code> , que llamamos <code>newArray</code> .  Solo que esta vez agregamos una advertencia de que la longitud de la nueva matriz debe ser igual a la suma de las longitudes de todos los argumentos de la funci√≥n.  La declaraci√≥n que ten√≠amos arriba en tiempo de ejecuci√≥n se convierte a tipo en tiempo de compilaci√≥n. <br><br>  El c√≥digo anterior se refiere al mundo de los tipos, no a los valores, es decir, el signo <code>==</code> indica una comparaci√≥n de la <code>length</code> tipo devuelto, y no su valor.  Para que dicho mecanismo funcione, la longitud del tipo devuelto debe proporcionarnos informaci√≥n sobre el n√∫mero real. <br><br>  Para garantizar el funcionamiento de dicho mecanismo, debe asegurarse de que cada n√∫mero sea de un tipo diferente.  Un tipo puede contener solo un valor: 1. Lo mismo se aplica a Dos, Tres y todos los dem√°s n√∫meros.  Naturalmente, tal trabajo es muy agotador, pero es para ese trabajo que tenemos programaci√≥n.  Puede escribir un compilador que lo haga por nosotros. <br><br>  Una vez hecho esto, puede crear tipos separados para matrices que contienen 1, 2, 3 y un n√∫mero diferente de elementos.  <code>ArrayOfOne</code> , <code>ArrayOfTwo</code> , etc. <br><br>  Por lo tanto, puede definir la funci√≥n de longitud, que tomar√° uno de los tipos de matriz anteriores y tendr√° un tipo de retorno dependiente de <code>One</code> para <code>ArrayOfOne</code> , <code>Two</code> para <code>ArrayOfTwo</code> , etc.  para cada n√∫mero <br><br>  Ahora que tenemos un tipo separado para cualquier longitud espec√≠fica de la matriz, podemos verificar (en tiempo de compilaci√≥n) que ambas matrices tienen la misma longitud.  Para hacer esto, compare sus tipos.  Y dado que los tipos tienen los mismos valores que cualquier otro, puede asignarles operaciones.  Puede determinar la adici√≥n de dos tipos espec√≠ficos especificando que la suma de <code>ArrayOfOne</code> y <code>ArrayOfTwo</code> es igual a <code>ArrayOfThree</code> . <br><br>  Esa es toda la informaci√≥n que el compilador necesita para asegurarse de que el c√≥digo que escribi√≥ sea correcto. <br><br>  Supongamos que queremos crear una variable de tipo <code>ArrayOfThree</code> : <br><br><pre> <code class="plaintext hljs">result: ArrayOfThree = append([1], [2, 3])</code> </pre> <br>  El compilador puede determinar que [1] solo tiene un valor, por lo que puede asignar el tipo <code>ArrayOfOne</code> .  Tambi√©n puede asignar <code>ArrayOfTwo</code> a [2, 3]. <br><br>  El compilador sabe que el tipo de resultado debe ser igual a la suma de los tipos del primer y segundo argumento.  Tambi√©n sabe que ArrayOfOne + ArrayOfTwo es igual a ArrayOfThree, es decir, sabe que toda la expresi√≥n en el lado derecho de la identidad es del tipo ArrayOfThree.  Coincide con la expresi√≥n de la izquierda y el compilador est√° satisfecho. <br><br>  Si escribimos lo siguiente: <br><br><pre> <code class="plaintext hljs">result: ArrayOfTwo = append([1], [2, 3])</code> </pre> <br>  entonces el compilador estar√≠a completamente insatisfecho, ya que sabr√≠a que el tipo es incorrecto. <br><br><h2>  La escritura dependiente es genial </h2><br>  En este caso, una gran cantidad de errores es simplemente imposible de permitir.  Con la escritura dependiente, se pueden evitar errores por unidad, accesos a √≠ndices de matriz inexistentes, excepciones de puntero nulo, bucles infinitos y c√≥digo roto. <br><br>  Usando tipos dependientes, puede expresar casi cualquier cosa.  La funci√≥n factorial solo aceptar√° n√∫meros naturales, la funci√≥n de <code>login</code> no aceptar√° l√≠neas vac√≠as, la funci√≥n <code>removeLast</code> solo aceptar√° matrices no vac√≠as.  Adem√°s, todo esto se verifica antes de iniciar el programa. <br><br>  El problema con las comprobaciones de tiempo de ejecuci√≥n es que fallan si el programa ya se est√° ejecutando.  Esto es normal si el programa lo ejecuta solo usted, pero no el usuario.  Los tipos dependientes le permiten llevar tales controles al nivel de tipos, por lo que la falla de este tipo durante la ejecuci√≥n del programa se vuelve imposible. <br><br>  Creo que la escritura dependiente es el futuro de los lenguajes de programaci√≥n convencionales, ¬°y no puedo esperar para esperarlo! <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Idris</a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F *</a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Agregar tipos dependientes a JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432416/">https://habr.com/ru/post/es432416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432404/index.html">Backup for Linux no escribe cartas</a></li>
<li><a href="../es432408/index.html">Fintech digest: preparaci√≥n para desconectar bancos peque√±os de Visa y Mastercard, una calculadora de pensiones y no solo</a></li>
<li><a href="../es432410/index.html">Entidades de estilo DDD con Entity Framework Core</a></li>
<li><a href="../es432412/index.html">Highload ++: C√≥mo ayudar al sistema ERP a hacer frente a 500,000 solicitudes por segundo</a></li>
<li><a href="../es432414/index.html">Viejos secretos para la depuraci√≥n r√°pida: animaci√≥n del c√≥digo fuente</a></li>
<li><a href="../es432418/index.html">Analizando expresiones lambda en Java</a></li>
<li><a href="../es432420/index.html">Introducci√≥n a Git Merge y Git Rebase: por qu√© y cu√°ndo usarlos</a></li>
<li><a href="../es432422/index.html">Modo sin conexi√≥n en iOS y caracter√≠sticas de su implementaci√≥n en Realm</a></li>
<li><a href="../es432424/index.html">Infraestructura certificada HyperFlex para SAP HANA</a></li>
<li><a href="../es432426/index.html">Depuraci√≥n de un error que no se reproduce</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>