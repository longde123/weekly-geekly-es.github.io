<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüç≥ üíÖüèº ‚èπÔ∏è Sob o cap√¥ do React. Escrevemos nossa implementa√ß√£o do zero üëµüèæ üçé üë®üèø‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nesta s√©rie de artigos, criaremos nossa pr√≥pria implementa√ß√£o do React do zero. No final, voc√™ entender√° como o React funciona, quais m√©todos do ciclo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sob o cap√¥ do React. Escrevemos nossa implementa√ß√£o do zero</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458916/">  Nesta s√©rie de artigos, criaremos nossa pr√≥pria implementa√ß√£o do React do zero.  No final, voc√™ entender√° como o React funciona, quais m√©todos do ciclo de vida do componente ele chama e por que.  O artigo √© direcionado para aqueles que j√° usaram o React e desejam aprender sobre seu dispositivo, ou para os mais curiosos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d8/ea8/66a/9d8ea866a9fac6aadd47eb3d51026f61.jpg" alt="imagem"><br><a name="habracut"></a><br>  Este artigo √© uma tradu√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">React Internals, Part One: rendering basic</a> <br><br><h2>  Este √© realmente o primeiro artigo de cinco </h2><br><ol><li>  Rendering Basics &lt;- estamos aqui </li><li>  ComponentWillMount e componentDidMount </li><li>  Update </li><li>  setState </li><li>  Transa√ß√µes </li></ol><br><blockquote>  O material foi criado quando o React 15.3 foi relevante, em particular o uso do ReactDOM e o reconciliador de pilhas.  A rea√ß√£o 16 e acima tem algumas altera√ß√µes.  No entanto, esse material permanece relevante, pois fornece uma id√©ia geral do que est√° acontecendo "sob o cap√¥". <br></blockquote><h2>  Parte 1. No√ß√µes b√°sicas de renderiza√ß√£o </h2><br><h3>  Elementos e componentes </h3><br>  Existem tr√™s tipos de entidades no React: um elemento DOM nativo, um elemento React virtual e um componente. <br><br><h4>  Elementos DOM nativos </h4><br>  Esses s√£o os elementos DOM que o navegador usa para criar a p√°gina da web, por exemplo, div, span, h1.  O React os cria chamando document.createElement () e interage com a p√°gina usando m√©todos da API DOM baseados no navegador, como element.insertBefore (), element.nodeValue e outros. <br><br><h4>  Elemento de rea√ß√£o virtual </h4><br>  Um elemento React virtual (geralmente chamado simplesmente de "elemento") √© um objeto javascript que cont√©m as propriedades necess√°rias para criar ou atualizar um elemento DOM nativo ou uma √°rvore desses elementos.  Com base no elemento React virtual, s√£o criados elementos DOM nativos, como div, span, h1 e outros.  Podemos dizer que um elemento React virtual √© uma inst√¢ncia de um componente composto definido pelo usu√°rio, mais sobre isso abaixo. <br><br><h4>  Componente </h4><br>  Componente √© um termo bastante geral em React.  Componentes s√£o entidades com as quais o React faz v√°rias manipula√ß√µes.  Componentes diferentes servem a prop√≥sitos diferentes.  Por exemplo, o ReactDomComponent da biblioteca ReactDom √© respons√°vel pela vincula√ß√£o entre os elementos React e seus elementos DOM nativos correspondentes. <br><br><h4>  Componentes compostos personalizados </h4><br>  Provavelmente voc√™ j√° encontrou esse tipo de componente.  Ao chamar React.createClass () ou usar as classes ES6 por meio da extens√£o React.Component, voc√™ cria um componente composto personalizado.  Esse componente possui m√©todos de ciclo de vida, como componentWillMount, shouldComponentUpdate e outros.  Podemos redefini-los para adicionar algum tipo de l√≥gica.  Al√©m disso, outros m√©todos s√£o criados, como mountComponent, receiveComponent.  Esses m√©todos s√£o usados ‚Äã‚Äãapenas pelo React para fins internos; n√£o interagimos com eles de forma alguma. <br><br><div class="spoiler">  <b class="spoiler_title">ZanudaMode = on</b> <div class="spoiler_text">  De fato, os componentes criados pelo usu√°rio inicialmente n√£o est√£o completos.  O React os agrupa em um ReactCompositeComponentWrapper, que adiciona todos os m√©todos de ciclo de vida aos nossos componentes, ap√≥s os quais o React pode gerenci√°-los (inserir, atualizar etc.). <br></div></div><br><h3>  Reagir declarativo </h3><br>  Quando se trata de componentes personalizados, nossa tarefa √© definir as classes desses componentes, mas n√£o instanciamos essas classes.  O React os cria quando necess√°rio. <br><br>  Al√©m disso, n√£o criamos elementos explicitamente usando um estilo imperativo; em vez disso, escrevemos em um estilo declarativo usando JSX: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Este c√≥digo com marca√ß√£o JSX √© traduzido pelo compilador no seguinte: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> React.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } }</code> </pre> <br>  Isto √©, em ess√™ncia, ele se transforma em uma constru√ß√£o imperativa para criar um elemento por meio de uma chamada expl√≠cita para React.createElement ().  Mas essa constru√ß√£o est√° dentro do m√©todo render (), que n√£o chamamos explicitamente, o React chamar√° esse m√©todo quando necess√°rio.  Portanto, perceber React √© igualmente declarativo: descrevemos o que queremos receber e React determina como faz√™-lo. <br><br><h3>  Escreva seu pequeno React </h3><br>  Tendo recebido a base t√©cnica necess√°ria, come√ßaremos a criar nossa pr√≥pria implementa√ß√£o do React.  Esta ser√° uma vers√£o muito simplificada, vamos cham√°-la de Feact. <br><br>  Suponha que desejemos criar um aplicativo Feact simples cujo c√≥digo se pareceria com isso: <br><br><pre> <code class="javascript hljs">Feact.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">hello world</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>));</code> </pre> <br>  Primeiro, vamos discordar sobre JSX.  Este √© precisamente um "recuo", porque a an√°lise JSX √© um grande t√≥pico separado que omitiremos como parte de nossa implementa√ß√£o do Feact.  Se estiv√©ssemos lidando com JSX processado, ver√≠amos o seguinte c√≥digo: <br><br><pre> <code class="javascript hljs">Feact.render( Feact.createElement(<span class="hljs-string"><span class="hljs-string">'h1'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'hello world'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>) );</code> </pre> <br>  Ou seja, usamos Feact.createElement em vez de JSX.  Ent√£o, implementamos este m√©todo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createElement(type, props, children) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = { type, <span class="hljs-attr"><span class="hljs-attr">props</span></span>: props || {} }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) { element.props.children = children; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element; } };</code> </pre> <br>  O elemento retornado √© um objeto simples que representa o que queremos renderizar. <br><br><h3>  O que o Feact.render () faz? </h3><br>  Ao chamar Feact.render (), passamos dois par√¢metros: o que queremos renderizar e onde.  Este √© o ponto de partida de qualquer aplicativo React.  Vamos escrever uma implementa√ß√£o do m√©todo render () para Feact: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createElement() { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }, render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentInstance.mountComponent(container); } };</code> </pre> <br>  Ap√≥s a conclus√£o de render (), obtemos uma p√°gina da web finalizada.  Elementos DOM s√£o criados por FeactDOMComponent.  Vamos escrever sua implementa√ß√£o: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactDOMComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props.children; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> textNode = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(text); domElement.appendChild(textNode); container.appendChild(domElement); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._hostNode = domElement; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> domElement; } }</code> </pre> <br>  O m√©todo mountComponent cria um elemento DOM e o armazena neste._hostNode.  N√£o o usaremos agora, mas retornaremos a isso nas seguintes partes. <br><br>  A vers√£o atual do aplicativo pode ser visualizada em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">violino</a> . <br><br>  Literalmente, 40 linhas de c√≥digo foram suficientes para fazer uma implementa√ß√£o primitiva do React.  O Feact que criamos dificilmente conquistar√° o mundo, mas reflete bem a ess√™ncia do que est√° acontecendo sob o cap√¥ do React. <br><br><h3>  Adicionando componentes personalizados </h3><br>  Nosso Feact deve ser capaz de renderizar n√£o apenas elementos em HTML (div, span, etc.), mas tamb√©m componentes compostos definidos pelo usu√°rio: <br><blockquote>  O m√©todo Feact.createElement () descrito anteriormente est√° bom atualmente, ent√£o n√£o o repetirei na listagem de c√≥digos. <br></blockquote><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createClass(spec) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props = props; } Constructor.prototype.render = spec.render; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Constructor; }, render(element, container) { <span class="hljs-comment"><span class="hljs-comment">//      //   , //    } }; const MyTitle = Feact.createClass({ render() { return Feact.createElement('h1', null, this.props.message); } }; Feact.render({ Feact.createElement(MyTitle, { message: 'hey there Feact' }), document.getElementById('root') );</span></span></code> </pre> <br>  Deixe-me lembr√°-lo, se JSX estivesse dispon√≠vel, chamar o m√©todo render () ficaria assim: <br><br><pre> <code class="javascript hljs">Feact.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyTitle</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"hey there Feact"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('root') );</span></span></code> </pre> <br>  Passamos a classe de componente personalizado para createElement.  Um elemento React virtual pode representar um elemento DOM regular ou um componente personalizado.  N√≥s os distinguiremos da seguinte maneira: se passarmos um tipo de string, ent√£o este √© um elemento DOM;  se uma fun√ß√£o, esse elemento representa um componente personalizado. <br><br><h3>  Melhorando o Feact.render () </h3><br>  Se voc√™ observar atentamente o c√≥digo no momento, ver√° que Feact.render () n√£o pode processar componentes personalizados.  Vamos consertar isso: <br><br><pre> <code class="javascript hljs">Feact = { render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactCompositeComponentWrapper(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentInstance.mountComponent(container); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactCompositeComponentWrapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = componentInstance.render(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domComponentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> domComponentInstance.mountComponent(container); } }</code> </pre> <br>  Criamos um wrapper para o item passado.  Dentro do wrapper, criamos uma inst√¢ncia da classe de componentes do usu√°rio e chamamos seu m√©todo componentInstance.render ().  O resultado desse m√©todo pode ser passado para o FeactDOMComponent, onde os elementos DOM correspondentes ser√£o criados. <br><br>  Agora podemos criar e renderizar componentes personalizados.  O Feact criar√° n√≥s DOM com base em componentes personalizados e os mudar√° dependendo das propriedades (acess√≥rios) de nossos componentes personalizados.  Esta √© uma melhoria significativa em nosso Feact. <br><blockquote>  Observe que o FeactCompositeComponentWrapper cria diretamente o FeactDOMComponent.  Um relacionamento t√£o pr√≥ximo √© ruim.  N√≥s vamos corrigir isso mais tarde.  Se o React tivesse a mesma conex√£o estreita, apenas os aplicativos da web poderiam ser criados.  A adi√ß√£o de uma camada adicional do ReactCompositeComponentWrapper permite separar a l√≥gica do React para gerenciar elementos virtuais e a exibi√ß√£o final dos elementos nativos, o que permite usar o React n√£o apenas ao criar aplicativos da Web, mas tamb√©m, por exemplo, React Native para dispositivos m√≥veis. <br></blockquote><h3>  Aprimoramento de componente personalizado </h3><br>  Os componentes personalizados criados podem retornar apenas elementos DOM nativos. Se tentarmos retornar outros componentes personalizados, ocorreremos um erro.  Corrija esta falha.  Imagine que gostar√≠amos de executar o seguinte c√≥digo sem erros: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyMessage = Feact.createClass({ render() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.asTitle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Feact.createElement(MyTitle, { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Feact.createElement(<span class="hljs-string"><span class="hljs-string">'p'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); } } }</code> </pre><br>  O m√©todo render () de um componente personalizado pode retornar um elemento DOM nativo ou outro componente personalizado.  Se a propriedade asTitle for verdadeira, o FeactCompositeComponentWrapper retornar√° o componente personalizado para o FeactDOMComponent onde o erro ocorrer√°.  Corrija FeactCompositeComponentWrapper: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactCompositeComponentWrapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = componentInstance.render(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> element.type === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { element = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> element.type(element.props)).render(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domComponentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); domComponentInstance.mountComponent(container); } }</code> </pre><br>  Na verdade, agora fizemos uma muleta para atender √†s necessidades atuais.  Uma chamada para o m√©todo render retornar√° componentes filhos at√© retornar um elemento DOM nativo.  Isso √© ruim porque esses componentes filhos n√£o participar√£o do ciclo de vida.  Por exemplo, nesse caso, n√£o poderemos implementar a chamada componentWillMount.  N√≥s vamos corrigir isso mais tarde. <br><br><h3>  E, novamente, corrigimos Feact.render () </h3><br>  A primeira vers√£o do Feact.render () s√≥ podia processar elementos DOM nativos.  Agora, apenas os componentes definidos pelo usu√°rio s√£o processados ‚Äã‚Äãcorretamente sem suporte nativo.  √â necess√°rio lidar com os dois casos.  Voc√™ pode escrever uma f√°brica que criar√° um componente dependendo do tipo de elemento passado, mas o React escolheu uma maneira diferente: basta agrupar qualquer componente recebido em outro componente: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TopLevelWrapper = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props = props; }; TopLevelWrapper.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapperElement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createElement(TopLevelWrapper, element); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactCompositeComponentWrapper(wrapperElement); <span class="hljs-comment"><span class="hljs-comment">//   } };</span></span></code> </pre><br>  TopLevelWrapper √© essencialmente um componente personalizado.  Tamb√©m pode ser definido chamando Feact.createClass ().  Seu m√©todo de renderiza√ß√£o simplesmente retorna o elemento passado para ele.  Agora, cada elemento √© envolvido em TopLevelWrapper, e FeactCompositeComponentWrapper sempre receber√° um componente personalizado como entrada. <br><br><h3>  Conclus√£o da primeira parte </h3><br>  Implementamos o Feact, que pode renderizar componentes.  O c√≥digo gerado mostra os conceitos b√°sicos de renderiza√ß√£o.  A renderiza√ß√£o real no React √© muito mais complicada e abrange eventos, foco, rolagem de janelas, desempenho, etc. <br><br>  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">viol√£o</a> final <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da</a> primeira parte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458916/">https://habr.com/ru/post/pt458916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458906/index.html">[Ecaterimburgo, an√∫ncio] Flutteron - um workshop sobre desenvolvimento em Flutter</a></li>
<li><a href="../pt458908/index.html">Digitalizando documentos pela rede</a></li>
<li><a href="../pt458910/index.html">Compara√ß√£o do PostgreSQL com grandes p√°ginas do Linux</a></li>
<li><a href="../pt458912/index.html">Migrando para o Zimbra com o imapsync</a></li>
<li><a href="../pt458914/index.html">O que (n√£o) voc√™ precisa saber para criar jogos no Unity</a></li>
<li><a href="../pt458918/index.html">O que voc√™ pode aprender com o design de jogos hiper-casuais</a></li>
<li><a href="../pt458920/index.html">Confer√™ncia para f√£s do DevOps</a></li>
<li><a href="../pt458922/index.html">Como passar do ESXi para o KVM / LXD e n√£o enlouquecer</a></li>
<li><a href="../pt458924/index.html">Acidentes ajudam voc√™ a aprender</a></li>
<li><a href="../pt458926/index.html">Trag√©dia n√£o vem sozinha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>