<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏉 🏂 👨🏼‍💼 Masalah pemirsa pertama, atau kesulitan mengkonversi aliran video WebRTC ke HLS ♒️ 🤩 ✌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="George menutup laptopnya dan mengusap mata merahnya yang kurang tidur. "Pelanggan terus mengeluh tentang pembekuan aliran; paket perbaikan baru tidak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masalah pemirsa pertama, atau kesulitan mengkonversi aliran video WebRTC ke HLS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/481668/"><p><img src="https://habrastorage.org/webt/af/bt/ar/afbtarp3iizqyc4vnhqj2dxxmte.jpeg"></p><br><p>  George menutup laptopnya dan mengusap mata merahnya yang kurang tidur.  "Pelanggan terus mengeluh tentang pembekuan aliran; paket perbaikan baru tidak membantu sama sekali! Apa yang harus saya lakukan dengan HLS (yang disensor) ini?"  katanya. </p><br><h2 id="the-browser-is-not-only-hypertext-but-also-a-streamer">  Browser tidak hanya hypertext, tetapi juga streamer </h2><br><p>  Browser memiliki pemain untuk waktu yang lama, tetapi ceritanya berbeda dengan video encoder dan streaming.  Sekarang, di hampir semua peramban versi terbaru, kita dapat menemukan modul untuk pengodean, streaming, pengodean, dan pemutaran.  Fungsi-fungsi ini tersedia melalui JavaScript API, dan implementasinya disebut Web Real Time Communications atau WebRTC.  Pustaka yang dibangun dalam peramban ini dapat melakukan banyak hal: mengambil video dari kamera internal, virtual atau USB, kompres dengan codec H.264, VP8, dan VP9, ​​dan kirimkan ke jaringan melalui protokol SRTP;  yaitu, berfungsi sebagai encoder video streamer perangkat lunak.  Akibatnya, kami melihat browser yang memiliki sesuatu yang mirip dengan ffmpeg atau gstreamer, kompres video dengan baik, stream pada RTP, dan memainkan stream video. </p><a name="habracut"></a><br><p>  WebRTC memberi kami kebebasan untuk menerapkan berbagai kasus streaming dalam JavaScript: </p><br><ul><li>  streaming dari browser ke server untuk merekam dan distribusi selanjutnya </li><li>  mendistribusikan aliran peer-to-peer </li><li>  putar aliran pengguna lain dan kirim sendiri (obrolan video) </li><li>  mengonversi protokol lain oleh server, misalnya RTMP, RTSP, dll., dan memutarnya di browser sebagai WebRTC </li></ul><br><p>  Skrip kontrol aliran yang disempurnakan mungkin terlihat seperti ini: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Launching broadcast from browser to server session.createStream({name:”mystream”}).publish(); //Playing broadcast by the browser session.createStream({name:”mystream”}).play();</span></span></code> </pre> <br><h2 id="hls-works-where-webrtc-does-not-work">  HLS berfungsi di mana WebRTC tidak berfungsi </h2><br><p>  WebRTC berjalan di versi browser terbaru, namun, ada dua faktor berikut: 1) Tidak semua pengguna memperbarui browser mereka secara tepat waktu dan mungkin menggunakan versi lama Chrome selama tiga tahun.  2) Pembaruan dan peramban baru, WebView, serta klien lain dan pengirim pesan instan yang membantu pengguna menjelajahi Internet dirilis hampir seminggu sekali.  Tidak perlu dikatakan, tidak semua dari mereka memiliki dukungan WebRTC, dan jika mereka melakukannya, itu dapat dibatasi.  Lihat bagaimana keadaannya sekarang: </p><br><p><img src="https://habrastorage.org/webt/r8/wf/y8/r8wfy8p3nvyulliesmqnwhurhcw.png"></p><br><p>  Perangkat favorit semua orang oleh Apple bisa membuat sakit kepala.  Mereka mulai mendukung WebRTC hanya baru-baru ini dan kadang-kadang, perilaku mereka dibandingkan dengan browser webkit mungkin tampak mengejutkan.  Di mana WebRTC tidak berfungsi atau tidak bekerja dengan baik, HLS berfungsi dengan baik.  Dalam hal ini, kompatibilitas diperlukan, dan sesuatu seperti konverter yang memungkinkan kita untuk mengkonversi WebRTC ke HLS dan memutarnya di hampir semua perangkat. </p><br><p>  HLS pada awalnya tidak disusun untuk aliran waktu-nyata.  Memang, bagaimana kita bisa melakukan streaming video real-time melalui HTTP?  Tugas HLS adalah memotong video menjadi potongan-potongan dan mengirimkannya ke pemutar dengan lancar, tanpa terburu-buru, dengan mengunduhnya satu per satu.  Seorang pemain HLS mengharapkan aliran video yang terbentuk dengan lembut dan halus.  Di sini kita memiliki konflik, karena WebRTC, sebaliknya, dapat kehilangan paket karena persyaratan waktu nyata dan latensi rendah dan memiliki FPS / GOP mengambang dan laju bit variabel - menjadi kebalikan dari HLS dalam hal prediktabilitas dan keteraturan aliran. </p><br><p>  Pendekatan yang jelas - Depacketization WebRTC (SRTP) dan <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">konversi</a> berikutnya <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">ke HLS</a> mungkin tidak berfungsi di pemutar HLS Apple asli atau bekerja dengan pembekuan, yang merupakan bentuk yang tidak cocok untuk produksi.  Pemain asli berarti pemain yang digunakan di Apple iOS Safari, Mac OS Safari, dan Apple TV. </p><br><p>  Oleh karena itu, jika Anda melihat pembekuan HLS pada pemain asli, mungkin ini masalahnya, dan sumber alirannya adalah WebRTC atau aliran dinamis lain dengan markup yang tidak rata.  Selain itu, dalam implementasi pemain Apple asli, ada perilaku yang hanya bisa dipahami secara empiris.  Misalnya, server harus mulai mengirim segmen HLS segera setelah daftar putar m3u8 dikembalikan.  Penundaan 1 detik dapat menyebabkan pembekuan.  Jika konfigurasi bitstream berubah dalam proses (yang cukup umum selama streaming WebRTC), juga akan ada pembekuan. </p><br><h2 id="fighting-freezing-in-native-players">  Melawan pembekuan di pemain asli </h2><br><p>  Dengan demikian, depacketisasi WebRTC dan paket HLS umumnya tidak berfungsi.  Di server video streaming <a href="https://flashphoner.com/">Web Call Server (WCS)</a> , kami memecahkan masalah dengan dua cara, dan kami menawarkan yang ketiga sebagai alternatif: </p><br><p>  1) Transcoding. </p><br><p>  Ini adalah cara paling andal untuk menyelaraskan aliran WebRTC ke persyaratan HLS, mengatur GOP, FPS yang diinginkan, dll.  Namun, dalam beberapa kasus, transcoding bukanlah solusi yang baik;  misalnya, transcoding stream 4k <br>  video VR memang ide yang buruk.  Aliran berbobot seperti itu sangat mahal untuk ditranskrip dalam hal waktu CPU atau sumber daya GPU. </p><br><p><img src="https://habrastorage.org/webt/lk/sb/ap/lksbapmjw9cmefbwccx6l7vx3xs.png"></p><br><p>  2) Menyesuaikan dan menyelaraskan aliran WebRTC saat bepergian agar sesuai dengan persyaratan HLS. </p><br><p>  Ini adalah parser khusus yang menganalisis bitstream H.264 dan menyesuaikannya agar sesuai dengan fitur / bug pemain HLS asli Apple.  Diakui, pemain non-asli seperti video.js dan hls.js lebih toleran terhadap stream <br>  dengan bitrate dinamis dan FPS yang berjalan di WebRTC dan jangan memperlambat di mana implementasi referensi dari Apple HLS pada dasarnya menghasilkan pembekuan. </p><br><p><img src="https://habrastorage.org/webt/hh/c0/0j/hhc00j_fa7tj6frr5tme-rkqojg.png"></p><br><p>  3) Menggunakan RTMP sebagai sumber aliran alih-alih WebRTC. </p><br><p>  Terlepas dari kenyataan bahwa Flash player sudah usang, protokol RTMP aktif digunakan untuk streaming;  ambil OBS Studio, misalnya.  Kita harus mengakui bahwa encoders RTMP menghasilkan lebih banyak secara umum <br>  stream daripada WebRTC dan karenanya praktis tidak menyebabkan pembekuan di HLS, mis. RTMP&gt; Konversi HLS terlihat jauh lebih cocok dalam hal pembekuan, termasuk di pemain HLS asli.  Karena itu, jika streaming <br>  dilakukan dengan menggunakan desktop dan OBS, maka lebih baik menggunakannya untuk konversi ke HLS.  Jika sumbernya adalah browser Chrome, maka RTMP tidak dapat digunakan tanpa menginstal plugin, dan hanya WebRTC yang berfungsi dalam hal ini. </p><br><p><img src="https://habrastorage.org/webt/tm/ne/i2/tmnei2sj-cuw2fpw0wajlyxuz7m.png"><br>  Ketiga metode yang dijelaskan di atas telah diuji dan berfungsi, sehingga Anda dapat memilih berdasarkan tugas. </p><br><h2 id="webrtc-to-hls-on-cdn">  WebRTC ke HLS di CDN </h2><br><p>  Ada beberapa hal yang tidak diinginkan yang akan Anda hadapi dalam sistem terdistribusi ketika ada beberapa server pengiriman aliran WebRTC antara sumber aliran WebRTC dan pemutar HLS, yaitu <a href="https://flashphoner.com/cdn-for-low-latency-webrtc-streaming/">CDN</a> , dalam kasus kami, berdasarkan pada server WCS.  Ini terlihat seperti ini: Ada Origin - server yang menerima aliran WebRTC, dan ada Edge - server yang mendistribusikan aliran ini termasuk melalui HLS.  Mungkin ada banyak server, yang memungkinkan penskalaan horizontal sistem.  Misalnya, 1000 server HLS dapat dihubungkan ke satu server Origin;  dalam hal ini, kapasitas sistem berskala 1000 kali. </p><br><p><img src="https://habrastorage.org/webt/nq/hq/fq/nqhqfqm9_lzyrpxtofqk89jzw6u.png"></p><br><p>  Masalahnya sudah menjadi stabilo di atas;  biasanya muncul di pemain asli: iOS Safari, Mac OS Safari, dan Apple TV.  Maksud kami adalah pemain yang bekerja dengan indikasi langsung dari daftar putar url <br>  tag, misalnya <code>&lt;video src="https://host/test.m3u8"/&gt;</code> .  Segera setelah pemain meminta daftar putar - dan tindakan ini sebenarnya adalah langkah pertama dalam memainkan aliran HLS - server harus segera, tanpa <br>  tunda, mulailah mengirimkan segmen video HLS.  Jika server tidak segera mulai mengirim segmen, pemain akan memutuskan bahwa ia telah ditipu dan berhenti bermain.  Perilaku ini tipikal dari pemain HLS asli Apple, tetapi kami tidak bisa hanya memberi tahu pengguna "jangan gunakan iPhone Mac dan Apple TV untuk memutar stream HLS." </p><br><p>  Jadi, ketika Anda mencoba memainkan aliran HLS di server Edge, server harus segera mulai mengembalikan segmen, tetapi bagaimana seharusnya melakukannya jika tidak memiliki aliran?  Memang, ketika Anda mencoba memainkannya, di sana <br>  tidak ada aliran di server ini.  Logika CDN bekerja berdasarkan prinsip Lazy Loading - itu tidak akan memuat aliran ke server sampai seseorang meminta aliran ini di server ini.  Ada masalah yang terhubung pertama kali <br>  pengguna;  orang pertama yang meminta aliran HLS dari server Edge dan memiliki kecerobohan untuk melakukan ini dari pemutar Apple default akan mendapatkan pembekuan karena itu akan membutuhkan waktu untuk memesan aliran ini <br>  dari server Origin, dapatkan di Edge, dan mulai memotong HLS.  Bahkan jika itu membutuhkan tiga detik, ini tidak akan membantu.  Ini akan membeku. </p><br><p><img src="https://habrastorage.org/webt/g9/he/wh/g9hewhbfu04ypt81daubg0qouvy.png"></p><br><p>  Di sini kita memiliki dua solusi yang mungkin: satu baik-baik saja, dan yang lainnya kurang begitu.  Seseorang dapat meninggalkan pendekatan Lazy Loading di CDN dan mengirim lalu lintas ke semua node, terlepas dari apakah ada pemirsa atau tidak.  Sebuah solusi, mungkin cocok untuk mereka yang tidak terbatas pada sumber daya lalu lintas dan komputasi.  Asal akan mengirim lalu lintas ke semua server Edge, sebagai akibatnya, semua server dan jaringan di antara mereka akan terus dimuat.  Mungkin skema ini hanya cocok untuk beberapa solusi spesifik dengan sejumlah kecil arus masuk.  Saat mereplikasi sejumlah besar aliran, skema seperti itu akan jelas <br>  tidak efisien dalam hal sumber daya.  Dan jika Anda ingat bahwa kami hanya menyelesaikan "masalah pengguna yang terhubung pertama dari browser asli," maka menjadi jelas bahwa itu tidak sepadan. </p><br><p><img src="https://habrastorage.org/webt/dx/n4/yf/dxn4yf28u8gtrczrshxc-smjjuq.png"></p><br><p>  Pilihan kedua lebih elegan, tetapi juga hanya merupakan akhir-sekitar.  Kami memberi pengguna pertama gambar video yang terhubung, tetapi ini masih bukan aliran yang ingin mereka lihat - ini adalah preloader.  Karena kita harus memberi mereka sesuatu dan segera melakukannya, tetapi kami tidak memiliki aliran sumber (masih dipesan dan dikirim dari Asal), kami memutuskan untuk meminta klien untuk menunggu sedikit dan menunjukkan kepada mereka video dari <br>  preloader dengan animasi bergerak.  Pengguna menunggu beberapa detik sementara preloader berputar, dan ketika aliran sebenarnya akhirnya datang, pengguna mulai mendapatkan aliran nyata.  Akibatnya, pengguna pertama akan melihat <br>  preloader, dan mereka yang terhubung setelah itu akhirnya akan melihat aliran HLS biasa yang berasal dari CDN yang beroperasi berdasarkan prinsip Lazy Loading.  Dengan demikian, masalah teknik telah terpecahkan. </p><br><h2 id="but-not-yet-fully-solved">  Namun belum sepenuhnya terpecahkan </h2><br><p>  Tampaknya semuanya bekerja dengan baik.  CDN berfungsi, aliran HLS dimuat dari server Edge, dan masalah pengguna terhubung pertama diselesaikan.  Dan di sini ada perangkap lain - kita berikan <br>  preloader dalam rasio aspek tetap 16: 9, sementara aliran format apa pun dapat memasukkan CDN: 16: 9, 4: 3, 2: 1 (video VR).  Dan ini adalah masalah, karena jika Anda mengirim preloader dalam format 16: 9 ke pemain, dan aliran yang dipesan 4: 3, maka pemain asli akan sekali lagi menghadapi pembekuan. </p><br><p>  Oleh karena itu, tugas baru muncul - Anda perlu tahu dengan rasio aspek apa aliran memasuki CDN dan memberikan rasio yang sama untuk preloader.  Fitur aliran WebRTC adalah pelestarian rasio aspek saat <br>  mengubah resolusi dan transcoding - jika browser memutuskan untuk menurunkan resolusi, itu menurunkannya dalam rasio yang sama.  Jika server memutuskan untuk mentranskode aliran, itu mempertahankan rasio aspek dalam proporsi yang sama.  Oleh karena itu, masuk akal bahwa jika kami ingin menunjukkan preloader untuk HLS, kami menunjukkannya dalam rasio aspek yang sama di mana aliran masuk. </p><br><p><img src="https://habrastorage.org/webt/kn/ee/dr/kneedrbpqw4mfyrvrnpxufev0ui.png"></p><br><p>  CDN berfungsi sebagai berikut: ketika lalu lintas memasuki server Origin, ia menginformasikan server lain di jaringan, termasuk server Edge, tentang aliran baru.  Masalahnya adalah bahwa pada titik ini, resolusi <br>  sumber aliran mungkin belum diketahui.  Resolusi dilakukan oleh konfigurasi H.264 bitstream bersama dengan bingkai kunci.  Oleh karena itu, server Edge dapat menerima informasi tentang streaming, tetapi tidak akan tahu tentang itu <br>  resolusi dan rasio aspek, yang tidak akan memungkinkannya untuk menghasilkan preloader dengan benar.  Dalam hal ini, perlu memberi sinyal keberadaan aliran di CDN hanya jika ada bingkai kunci - ini dijamin untuk memberikan informasi ukuran server Edge dan memungkinkan preloader yang benar dihasilkan untuk mencegah “masalah pertama yang terhubung dengan penonton. . " </p><br><p><img src="https://habrastorage.org/webt/vh/uy/aw/vhuyawuhtqsmyc8zg806egppu6i.png"></p><br><h2 id="summary">  Ringkasan </h2><br><p>  Mengonversi WebRTC ke HLS umumnya menghasilkan pembekuan saat diputar di pemutar Apple bawaan.  Masalahnya dipecahkan dengan menganalisis dan menyesuaikan bitstream H.264 dengan persyaratan HLS Apple, baik dengan ranscoding, <br>  atau bermigrasi ke protokol RTMP dan pembuat enkode sebagai sumber aliran.  Dalam jaringan terdistribusi dengan Lazy Loading of stream, ada masalah dengan viewer pertama yang terhubung, yang diselesaikan dengan menggunakan preloader dan menentukan resolusi pada sisi server Origin - titik masuk dari stream di CDN. </p><br><h2 id="links">  Tautan </h2><br><p>  <a href="https://flashphoner.com/">Server Panggilan Web</a> - <a href="https://flashphoner.com/">Server</a> WebRTC </p><br><p>  <a href="https://flashphoner.com/cdn-for-low-latency-webrtc-streaming/">CDN untuk streaming WebRTC latensi rendah</a> - CDN berbasis WCS </p><br><p>  <a href="https://flashphoner.com/live-broadcasting-of-a-webrtc-stream-to-hls/">Memutar streaming video WebRTC dan RTMP melalui HLS</a> - Fungsi server untuk mengonversi streaming dari berbagai sumber ke HLS </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481668/">https://habr.com/ru/post/id481668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481654/index.html">Kisah bagaimana QA Engineer membuat hidup Anda lebih mudah dengan bantuan Test IT, menggunakan Bot Framework</a></li>
<li><a href="../id481656/index.html">PagerDuty, atau Mengapa Departemen Operasi Mungkin Tidak Tidur di Malam Hari</a></li>
<li><a href="../id481662/index.html">Mencoba alat baru untuk membangun dan mengotomatiskan penyebaran di Kubernetes</a></li>
<li><a href="../id481664/index.html">Harga dan biaya tanpa server: AWS Lambda</a></li>
<li><a href="../id481666/index.html">Aturan SwiftLint Kustom</a></li>
<li><a href="../id481670/index.html">Buat rencana tindakan menggunakan AWS Cloud Adoption Framework</a></li>
<li><a href="../id481672/index.html">Automata seluler di browser</a></li>
<li><a href="../id481674/index.html">Corong penjualan mobil atau bagaimana tidak menggabungkan pelanggan dan bahkan bekerja dengan mereka yang telah menolak layanan Anda?</a></li>
<li><a href="../id481676/index.html">Minggu Keamanan 52: Keamanan untuk Speaker Cerdas dan Kamera IP</a></li>
<li><a href="../id481680/index.html">Menulis TodoMVC di dap. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>