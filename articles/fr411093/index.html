<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎓 🏂🏾 🙌🏿 Panneau de commande centralisé pour sources d'éclairage TsPKIO-2D Rotor 👨‍👨‍👦‍👦 ⛏️ 👨🏽‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Désolé, je ne m'amuse pas depuis longtemps avec le nommage, ainsi qu'avec les périphériques pour la domotique. Plus précisément, cette chose - la télé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panneau de commande centralisé pour sources d'éclairage TsPKIO-2D Rotor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/411093/"><img src="https://habrastorage.org/getpro/geektimes/post_images/72f/6a9/ceb/72f6a9ceb826b19cdb266c3d334da65b.jpg" alt="image"><br><br>  Désolé, je ne m'amuse pas depuis longtemps avec le nommage, ainsi qu'avec les périphériques pour la domotique.  Plus précisément, cette chose - la télécommande de la lumière - s'est avérée parce que je voulais quelque chose avec une interface push-twist-click, et non avec une dispersion habituelle de boutons.  L'effet wow n'a pas été atteint: à la maison, je ne remarque pas la télécommande à bout portant, mais au moins j'ai fermé la gestalt. <br><a name="habracut"></a><br>  TOR TOR: <br><br>  1) Gestion de trois groupes d'éclairage dans la cuisine <br>  2) Gestion de trois groupes d'éclairage dans la salle <br>  3) Gestion de toutes les sources lumineuses en même temps <br>  4) Durée de vie raisonnable de la batterie (à partir d'une semaine) <br>  5) Compatible avec le codage Livolo, SC2260, EV1527 <br><br>  Donc, vous n'avez pas besoin de lire plus si vous n'aimez pas Arduino, les commutateurs Livolo et les prises radio chinoises.  Parce que le premier est la base de la télécommande, et le deuxième et le troisième sont la périphérie. <br><br><h2>  Concept </h2><br>  La logique de contrôle m'a semblé comme suit: <br><br><ol><li>  Une pression sur le «bouton» commute les zones du groupe d'éclairage dans un anneau (cuisine - pièce - tout). </li><li>  Tourner le bouton, selon le sens de rotation, allume ou éteint l'éclairage du groupe sélectionné. </li><li>  Le mode de fonctionnement (groupe sélectionné) est affiché par une indication LED discrète. </li></ol><br>  Étant donné que j'utilise la radiocommande selon l'option la plus méprisée, sans protection contre les interférences et les retours, en même temps, une petite astuce est fournie en cas d'opération manquée. <br><br>  Si le fait de tourner le bouton n'aboutit pas au résultat souhaité, une pression et une rotation combinées dans le sens opposé vous permettent de sauter la commande.  Ensuite, la commande peut être répétée comme d'habitude. <br><br>  Autrement dit, si j'ai tourné le bouton dans le sens des aiguilles d'une montre et que la lumière principale ne s'est pas allumée, je peux appuyer sur le bouton, le tourner dans le sens inverse des aiguilles d'une montre, puis le relâcher et le tourner à nouveau dans le sens des aiguilles d'une montre pour répéter l'activation. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/V0ZpCxEb3-U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Pourquoi si dur?  Ensuite, en plus des protocoles maladroits, j'ai aussi des périphériques maladroits.  Par exemple, les interrupteurs d'éclairage radiocommandés Livolo et les relais radio, qui ont la même commande pour allumer et éteindre, ainsi que les prises radio ordinaires, dans lesquelles les commandes pour allumer et éteindre sont séparées. <br><br>  L'astuce de saut d'équipe vous permet de battre de manière créative la non-inclusion (non-exclusion) sans rompre le schéma général de l'éclairage.  De plus, sauter une commande vous permet de sauter par-dessus des sources de lumière que vous n'avez pas besoin d'activer ou de désactiver. <br><br>  Eh bien, bien sûr, pour comprendre ce qui se passe avec la télécommande, elle a un indicateur séparé qui s'allume lors de l'envoi d'une commande. <br><br>  Si la console n'est pas touchée pendant un certain temps (configuré dans le code), le contrôleur se met en veille.  Cependant, il ne sauvegarde pas le dernier état, et quand il se réveille en appuyant sur le stylo, il recommence sa vie à zéro. <br><br>  Ce n'est pas une erreur.  Je le répète, j'ai des commutateurs sans rétroaction et la console est physiquement incapable d'obtenir des informations sur l'état actuel de chaque périphérique contrôlé. <br><br>  Par conséquent, immédiatement après le réveil, le tour du bouton allume ou éteint la lumière à partir de zéro. <br><br><h2>  Première approche </h2><br>  Le concept visuel du type «boîte avec une torsion» exigeait, comme vous pouvez le deviner, deux choses: des boîtes et des torsions.  Dans la première version, le rôle de la box était joué par une banque d'alimentation mince, dont l'utilisation résolvait deux problèmes à la fois: j'avais à la fois un boîtier et un système de charge de batterie, en plus avec un connecteur.  La batterie elle-même, bien sûr, devait être remplacée par une batterie plus compacte, sinon le remplissage ne pourrait plus tenir. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/640/299/4df/6402994df7e71b82835d12f42541f1f0.jpg" alt="image"><br><br>  Cela s'est avéré plus complexe avec la torsion.  En cherchant, j'ai trouvé que plus le bouton du potentiomètre était joli et plus il était grand, plus le coût de son gramme était proche du coût d'un gramme d'or.  Par conséquent, j'ai acquis un stylo, qui me convenait peu aux propriétés esthétiques. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/232/a3e/b60/232a3eb6074d6d8724fdc76d353274cc.jpg" alt="image"><br><br>  La partie contrôle était le résultat d'une expérience avec ATmega328P et une suite logique du scénario défini par la domotique existante (sur les mêmes protocoles radio Arduino et primitifs). <br><br>  Je n'ai pas acheté très cher une dispersion des contrôleurs mentionnés et des prototypes conditionnels (en fait, un adaptateur d'un petit boîtier à une grande étape) de circuits imprimés dans le but d'essayer d'en faire une version à petit budget d'Arduino avec un nombre minimal (mais raisonnable) d'éléments. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/625/ebb/095/625ebb0959641911621741e00fb1b699.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/be0/e1c/ac4/be0e1cac460246c56f97f0c45e1c8bc7.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/53d/bc5/9f1/53dbc59f1bb9ec5583f84de546b2df76.jpg" alt="image"><br><br>  L'expérience s'est avérée réussie et le contrôleur configuré pour l'environnement Arduino a fait clignoter la LED avec succès après avoir avalé le Blink classique.  Eh bien, sur le principe de «terminer la chouette», j'ai ajouté un encodeur (avec un bouton), trois LED et un émetteur normal avec modulation d'amplitude sur une porteuse de 433,92 MHz à la carte résultante. <br><br>  Pour placer tous les éléments dans un petit boîtier, j'ai dû souffrir un peu, mais la télécommande fonctionnait toujours.  Et bien que, semble-t-il, le problème soit résolu, j'en voulais plus - le cas d'origine. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b0b/716/2cc/b0b7162cc2941009ef081f0f76e4a2a8.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/36b/08b/c76/36b08bc76093a6b66fe3f5e1b3597b1a.jpg" alt="image"><br><br><h2>  Deuxième approche </h2><br>  En fait, la première version (se plaignant) en apparence d'un groupe de camarades a été brisée, donc je l'ai reportée indéfiniment.  Mais il ne l'a pas démonté: c'est dommage. <br><br>  Mais lorsque l'imprimante 3D est apparue, il s'est promis un jour de fabriquer le même boîtier d'origine et donc de clore la question avec la télécommande. <br><br>  Je ne sais pas si cela s’est avéré bon ou mauvais - je ne sais pas vraiment comment évaluer mes affaires.  Mais sur 3DToday, l'équipe est plus accueillante que sur MySKU (dont je ne me plains pas - ce n'est pas un cadeau moi-même), et ils ont évalué le cas plus haut que moi. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5a1/89d/905/5a189d905d402c93afba5e4f4d88c1da.jpg" alt="image"><br><br>  Mais ayant une totale liberté d'action, j'ai abandonné les batteries chinoises fragiles et agitées, et j'ai pris le bon vieux 18650 comme source d'énergie. Et, comme vous pouvez facilement le voir, ce sont précisément ses dimensions qui déterminent largement les dimensions de l'ensemble du boîtier. <br><br>  J'ai commencé à rendre le boîtier lui-même modulaire, composé de nombreuses pièces, ce qui m'a permis de réimprimer uniquement des éléments individuels (erronés ou peu optimaux), et non le produit entier. <br><br>  Un autre point est que je n'aime vraiment pas faire de découpes pour les connecteurs, ce que je ne peux vraiment pas faire.  Par conséquent, dans la chaîne d'approvisionnement, il y a une autre astuce connue par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Evelyn le hérisson</a> : la recharge sans fil. <br><br><img src="https://habrastorage.org/webt/ie/zq/6m/iezq6m_73cckmk6y-bidsohs9ye.jpeg"><br><br>  Dans ma zashashnik, il n'y avait qu'un autre récepteur, que j'ai immédiatement mis en action. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/fDLqxxDvQhM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Enfin, la dernière astuce est assez évidente, mais quand même: pour que la télécommande ne rampe pas autour de la table, j'ai collé un morceau de tapis de voiture antidérapant au fond.  Et à la fin, cette chose est un monolithe absolu, bien que le réorganiser à un autre endroit ne soit pas non plus un problème. <br><br><h2>  Ce qu'il faut pour répéter </h2><br><h3>  Morceau de fer </h3><br>  1) Contrôleur ATmega328P - 1 pc.  (dans mon package TQFP, mais tout le monde peut) <br>  2) Résistance 10 kOhm - 5 pcs.  (4 pour supprimer le rebond de l'encodeur, 1 pour le contrôleur) <br>  3) Résistance 100 Ohms - 3 pcs. <br>  4) Condensateurs céramiques 0,1 microfarads - 4 pcs.  (au contrôleur et suppression du rebond de l'encodeur) <br>  5) Encodeur push (valcoder) - 1 pc.  (J'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEC12-4220F-S0024</a> ) <br>  6) LED - 3 pièces.  (diamètre 3 mm) <br>  7) Carte de charge de batterie au lithium - 1 pc.  (à partir de la banque d'alimentation qui est venue à la main, en théorie, n'importe qui avec un allumage automatique sous charge fera l'affaire) <br>  8) Récepteur de charge sans fil Qi - 1 pc. <br>  9) Un émetteur avec modulation d'amplitude à 433 MHz - 1 pc.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comme ça</a> ) <br>  10) De la fibre de verre pour la carte d'encodeur <br>  11) Imprimante 3D <br>  12) Plastique approprié (j'ai imprimé du PLA) <br>  13) Vis M4x30 - 4 pièces. <br><br>  En général, le nombre de composants peut être réduit.  Par exemple, dans une version très minimale, le contrôleur ne nécessite pas du tout de cerclage, bien que j'ai décidé de suivre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les conseils de Nick Gammon</a> et de ne pas ménager quelques condensateurs et une résistance. <br><br>  De la même manière, vous ne pouvez pas vous soucier de la suppression matérielle du rebond de contact et essayez de vous en tirer avec le logiciel.  Ensuite, vous pouvez barrer quatre autres résistances et une paire de condensateurs. <br><br>  Alternativement, vous pouvez utiliser une carte Arduino prête à l'emploi, comme la Pro Mini, mais dans ce cas, je ne peux pas garantir un faible niveau de consommation d'énergie, et vous devrez le faire vous-même.  Dans le même temps, le cas devra être corrigé. <br><br>  Schéma: <br><br><img src="https://habrastorage.org/webt/wo/xv/hh/woxvhhfaucpc3emhiyipfk56m1s.png"><br><br>  Pour référence, le brochage ATmega328p dans le boîtier TQFP-32 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hobby Electronics</a> : <br><br><img src="https://habrastorage.org/webt/1y/ea/sp/1yeasp0veriyrgvhrafu_inlwlm.jpeg"><br><br>  Pour mon encodeur, j'ai dessiné une petite planche: <br><br><img src="https://habrastorage.org/webt/i2/jg/d7/i2jgd7p7jlv1kyhbyjhoayd3d4k.jpeg"><br><br><img src="https://habrastorage.org/webt/ke/cr/yt/kecrytksno5yhwsjjdpcbwgc9-c.jpeg"><br><br><img src="https://habrastorage.org/webt/6y/vb/8j/6yvb8jl1h6zvpm-z-atgntumnsw.jpeg"><br><br>  S'il est bon, il devra être percé pour monter l'encodeur, ou enfoncé avec son «ventre sur la carte (en prenant soin de l'isolement pour qu'il n'y ait pas de court-circuit) afin que l'encodeur soit monté a) plus ou moins uniformément et b) ne vacille pas.  Historiquement, j'ai une deuxième option. <br><br>  Pour le cas, il est important que la hauteur de la carte avec des pièces, à l'exclusion de l'encodeur, ne soit pas plus (ou pas beaucoup plus) de 5 mm. <br><br><div class="spoiler">  <b class="spoiler_title">Si la carte Arduino n'est pas prête à portée de main, alors pour que tout fonctionne, vous devez d'abord écrire le chargeur de démarrage Arduino sur le contrôleur ATmega328P.</b> <div class="spoiler_text">  Pour ce faire, ajoutez d'abord une description de contrôleur à l'environnement Arduino.  Pour ce faire, rendez-vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site officiel d'Arduino</a> et téléchargez l'archive de description adaptée à votre version de l'environnement ( <a href="">pour 1.6</a> , <a href="">pour 1.5</a> , <a href="">pour 1.0</a> ). <br><br>  Le contenu de l'archive doit être extrait dans le dossier matériel du dossier d'environnement Arduino.  À l'avenir, je décris ce qui se passe sur l'exemple de l'environnement 1.0.3, que j'utilise toujours. <br><br>  Lorsque les descriptions sont copiées, vous devez démarrer Arduino et charger l'esquisse du programmeur dans Arduino, qui sera utilisé comme ce programmeur lui-même.  L'esquisse se trouve dans le menu Fichier - Exemples - ArduinoISP. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/037/517/98f/03751798f648adb8fea47a284a912667.jpg" alt="image"><br><br>  Bien sûr, vous devez choisir votre carte et votre port.  Je choisis Mega, car je l'ai: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/7e7/483/4bd/7e74834bdd786979f926f4b65e2e344f.jpg" alt="image"><br><br>  Après avoir chargé l'esquisse du programmeur, vous devez passer à la carte cible.  C'est-à-dire  dans notre cas - ATmega328 avec une fréquence de 8 MHz et un oscillateur maître interne.  Il figurera dans la liste des tableaux si les descriptions mentionnées ci-dessus sont copiées correctement: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b89/e98/7b2/b89e987b2243a79cc1d36e95d5a7ebab.jpg" alt="image"><br><br>  Vous devez maintenant connecter les lignes MISO, MOSI et SCK de la carte de programmation et de la carte avec le futur Arduino, et également connecter RESET, GND et VCC.  Plus la puissance est meilleure en dernier lieu. <br><br>  Sur la base de l'infographie et de la description d'Arduino Mega ci-dessus, l'image suivante émerge: <br><br>  SPI - Arduino Mega - ATmega328p <br><br>  MISO - 50 - 16 <br>  MOSI - 51 - 15 <br>  SCK - 52 - 17 <br>  SS (RESET) - 53 - 29 <br><br>  Connexion physique à votre goût, j'ai utilisé une méthode exclusivement barbare - des fils de planche à pain ordinaires directement dans les trous de la carte, sans soudure ni isolation: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/c14/df6/d5f/c14df6d5f4cdda937de81eb2fa555ee0.jpg" alt="image"><br><br>  Si tout est prêt, notez le chargeur de démarrage.  Tout d'abord, assurez-vous que le bon programmeur est sélectionné (Service - Programmeur - Arduino en tant que FAI): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/e0c/dc4/a0c/e0cdc4a0c8914fbed3f5328c676f0210.jpg" alt="image"><br><br>  Ensuite, nous faisons le service - Enregistrer le chargeur de démarrage: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/568/21e/12f/56821e12f02cd705995d40429b15eec6.jpg" alt="image"><br></div></div><br>  Après cela, la sortie est une carte Arduino minimaliste, pour charger des croquis dans lesquels vous pouvez utiliser l'adaptateur USB-série ou une carte Arduino complète avec un tel adaptateur à bord.  Dans le premier cas, vous devez connecter RX et TX en croix, et n'oubliez pas de connecter une masse commune.  Dans le deuxième cas, il est en outre nécessaire de court-circuiter la réinitialisation de l'Arduino, qui est utilisé comme adaptateur, à la masse. <br><br>  Si vous, comme moi, n'avez pas de circuit pour réinitialiser automatiquement le contrôleur avant de télécharger l'esquisse, il y a deux options: soit tirer sa réinitialisation, soit simplement allumer son alimentation lorsque l'environnement Arduino indique que le téléchargement a commencé. <br><br><h3>  Logement </h3><br>  Le boîtier, comme je l'ai dit, est modulaire.  Cela signifie que sur la partie intérieure cachée des yeux, vous pouvez laisser entrer le plastique qui est périmé et ne convient plus.  Vous pouvez y mettre de l'électronique: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/030/0a3/251/0300a325144382295c6e3b8d54971e23.jpg" alt="image"><br><br>  J'attire l'attention sur le fait que l'étui est spécifique et est conçu pour s'adapter à ma version du remplissage. <br><br>  Je propose de rendre le rotor transparent pour qu'il disperse la lumière des indicateurs.  Pour plus de poids, un écrou M16 peut être inséré à l'intérieur du rotor: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/9a0/8ef/68e/9a08ef68e2a079da4af3ed1eb148e961.jpg" alt="image"><br><br>  Encore besoin d'une chemise de rotor et d'une couverture.  Le couvercle est simplement inséré vers l'intérieur et repose sur la friction.  Et, bien sûr, vous ne pouvez pas vous passer des parties supérieure et inférieure du boîtier extérieur. <br><br>  J'ai imprimé un rotor avec un remplissage de 10%, le reste des éléments avec un remplissage de 5%.  Plastique - PLA.  La température réglée de la buse sur mon imprimante est de 200 ° C sur les trois premières couches, 185 ° C sur la suivante.  Malheureusement, je ne peux pas dire quelle est la vraie température de la buse.  La table est froide. <br><br>  L'assemblage est simple. <br><br><img src="https://habrastorage.org/webt/ka/cq/2-/kacq2-crn1cictkqxhpb0sok15u.jpeg"><br><br>  Les planches sont placées dans les rainures du boîtier durable, les LED - pieds dans les rainures de la partie inférieure du boîtier durable.  L'antenne de l'émetteur est abaissée, le récepteur de charge sans fil est abaissé de la même manière - de sorte qu'il est plus proche de cette même charge. <br><br><img src="https://habrastorage.org/webt/d9/zu/ex/d9zuextrjywuvjbj4ve68-c2rgg.png"><br><br>  Le remplissage est fixé par une plaque intermédiaire, dans la gorge de laquelle passe le faisceau de câbles du codeur. <br><br>  L'encodeur est fixé avec la plaque supérieure, le tout est serré avec des vis M4x30, qui coupent elles-mêmes les filetages en plastique. <br><br>  Maintenant, le boîtier durable peut être enfermé dans les moitiés du boîtier externe.  Un rotor est placé sur l'arbre du codeur et une chemise est placée sur le rotor.  En option, un tapis antidérapant est collé au bas du corps.  Une autre option est un insert décoratif qui cache la couture entre les moitiés du corps. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text">  Dans le code, vous devez spécifier des commandes pour allumer et éteindre vos périphériques.  Facultatif - modifiez le délai d'arrêt automatique. <br><br>  Tout cela se trouve dans la section variable. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  : http://donalmorrissey.blogspot.ru/2010/04/sleeping-arduino-part-5-wake-up-via.html //  Livolo: http://forum.arduino.cc/index.php?action=dlattach;topic=153525.0;attach=108106 #include &lt;avr/sleep.h&gt; #include &lt;avr/power.h&gt; #include &lt;livolo.h&gt; #define adc_disable() (ADCSRA &amp;= ~(1&lt;&lt;ADEN)) // disable ADC (before power-off) #define adc_enable() (ADCSRA |= (1&lt;&lt;ADEN)) // re-enable ADC #define txPin 7 //   Livolo livolo(txPin); #define PULSESHORT 450 #define PULSELONG 1350 #define PULSESYNC 13950 #define encA 5 #define encB 6 //   #define buttonPin 2 //   () #define roomLed 10 //    #define kitchenLed 9 //    #define switchLed 3 //     #define switchLedTimeOut 150 //      #define switchTreshold 4 //      #define offDelay 15000 //   #define rLev 3 //     #define kLev 3 //     #define glev 2 //     #define txPowerPin 8 //    #define kitchenBackLightOn1 12 #define kitchenBackLightOn2 34 #define kitchenMainLightOn 56 #define roomBackLightOn 12 #define roomMainLightOn1 34 #define roomMainLightOn2 56 #define mainLightOn 12 #define kitchenBackLightOff1 12 #define kitchenBackLightOff2 34 #define kitchenMainLightOff 56 #define roomBackLightOff 12 #define roomMainLighOtff1 34 #define roomMainLightOff2 56 #define mainLightOff 12 #define LivoloID 8500 volatile byte rotorMode = 0; //   byte currentMode = 0; //    int curEncA, prevEncA, curButton, prevButton; //   ,  byte encCountPlus = 0; //   byte encCountMinus = 0; //   unsigned long offTimeOut = 0; //    unsigned long modeTimeOut = 0; //        unsigned long switchLedTime = 0; //      unsigned long modeTime = 0; //   unsigned int modeTreshold = 500; //     (  ) unsigned int bounceTreshold = 200; //     byte rLevState = 0; byte kLevState = 0; byte gLevState = 0; //   k - , r - , h - , b -  boolean kBackState = false; boolean kBackState1 = false; boolean kMainState = false; boolean rBackState = false; boolean rMainState = false; boolean rMainState1 = false; boolean hMainState = false; boolean bMainState = false; boolean afterSleep = false; //      boolean modeTimeOutStart = false; boolean switchLedOn = false; boolean allOn = false; //  " "    boolean allOff = false; //  " "    static void ookPulse(int on, int off) { digitalWrite(txPin, HIGH); delayMicroseconds(on); digitalWrite(txPin, LOW); delayMicroseconds(off); } static void rcSend(long remoteCode) { for (byte reSend = 0; reSend &lt; 8; reSend++) { for(byte repeat=0; repeat&lt;4; repeat++){ for (byte i = 24; i&gt;0; i--) { // transmit remoteID byte txPulse=bitRead(remoteCode, i-1); // read bits from remote ID // Serial.print(txPulse); switch (txPulse) { case 0: // 00 ookPulse(PULSESHORT,PULSELONG); //ookPulse(PULSESHORT,PULSELONG); break; case 1: // 11 ookPulse(PULSELONG,PULSESHORT); //ookPulse(PULSELONG,PULSESHORT); break; } // switch } // for loop ookPulse(PULSESHORT,PULSESYNC); // S(ync) // Serial.println(); } // repeat } delay(150); } void switchLedToggle() { digitalWrite(switchLed, HIGH); switchLedTime = millis(); switchLedOn = true; } void lightsUp(boolean lightsUpMode) { //       ""     //   "" -   if (afterSleep == true) { if (lightsUpMode == false) { gLevState = 1; rLevState = 3; kLevState = 3; } else {gLevState = 0; rLevState = 0; kLevState = 0; } afterSleep = false; //   " " } //   if (rotorMode == 2) { if (lightsUpMode == false){ if (allOff == false) { switchLedToggle(); if (digitalRead(buttonPin) == HIGH) { //   gLevState = 0; rLevState = 0; kLevState = 0; rcSend(kitchenBackLightOff1); rcSend(kitchenBackLightOff2); rcSend(roomBackLightOff); livolo.sendButton(LivoloID, mainLightOff); } allOff = true; allOn = false; } } if (lightsUpMode == true){ //  ,    if (allOn == false) { switchLedToggle(); if (digitalRead(buttonPin) == HIGH) { gLevState = 1; rLevState = 3; kLevState = 3; rcSend(kitchenBackLightOn1); rcSend(kitchenBackLightOn2); rcSend(roomBackLightOn); livolo.sendButton(LivoloID, mainLightOff); //    Livolo livolo.sendButton(LivoloID, kitchenMainLightOn); //#1   livolo.sendButton(LivoloID, roomMainLightOn1); // #2 livolo.sendButton(LivoloID, roomMainLightOn2); // #3 livolo.sendButton(LivoloID, mainLightOn); // #6 } allOn = true; allOff = false; } } } //  if (rotorMode == 1) { if (lightsUpMode == false &amp;&amp; kLevState &gt; 0) { switchLedToggle(); if (digitalRead(buttonPin) == HIGH) { if (kLevState == 3) { //   livolo.sendButton(LivoloID, kitchenMainLightOff); // #3 } if (kLevState == 2) { //   2 livolo.sendButton(LivoloID, kitchenBackLightOff2); // #6 } if (kLevState == 1) { //   1 rcSend(kitchenBackLightOff1); } } if (kLevState!=0) { kLevState--;} // Serial.println(kLevState); } if (lightsUpMode == true &amp;&amp; kLevState &lt; 3) { switchLedToggle(); kLevState++; if (digitalRead(buttonPin) == HIGH) { if (kLevState &gt; 3) {kLevState = 3;} // Serial.println(kLevState); if (kLevState == 1) { //   1 rcSend(kitchenBackLightOn1); } if (kLevState == 2) { //   2 livolo.sendButton(LivoloID, kitchenBackLightOn2); // #6 } if (kLevState == 3) { //   livolo.sendButton(LivoloID, kitchenMainLightOn); // #3 } } } } //  if (rotorMode == 0) { if (lightsUpMode == false &amp;&amp; rLevState &gt; 0) { switchLedToggle(); if (digitalRead(buttonPin) == HIGH) { if (rLevState == 3) { //  1 livolo.sendButton(LivoloID, roomMainLighOtff1); //#1 } if (rLevState == 2) { //   livolo.sendButton(LivoloID, roomMainLightOff2); // #2 } if (rLevState == 1) { //   rcSend(roomBackLightOff); } } if (rLevState != 0) { rLevState--; } } if (lightsUpMode == true &amp;&amp; rLevState &lt; 3) { switchLedToggle(); rLevState++; if (digitalRead(buttonPin) == HIGH) { if (rLevState == 1) { //   rcSend(roomBackLightOn); } if (rLevState == 2) { //   livolo.sendButton(LivoloID, roomMainLightOn1); //#1 } if (rLevState == 3) { //   1 livolo.sendButton(LivoloID, roomMainLightOn2); // #2 } } } } } void wakeUp() { detachInterrupt(0); } void setMode() { if (rotorMode &gt;= 2 ) { rotorMode = 0; } else { rotorMode++; } offTimeOut = millis(); } void ledBlink() { for (byte iLed = 0; iLed&lt;3; iLed++) { digitalWrite(kitchenLed, HIGH); digitalWrite(roomLed, HIGH); delay(100); digitalWrite(kitchenLed, LOW); digitalWrite(roomLed, LOW); delay(100); } } void setLed() { if (rotorMode == 0) { //  digitalWrite(roomLed, HIGH); digitalWrite(kitchenLed, LOW); } if (rotorMode == 1) { //  digitalWrite(roomLed, LOW); digitalWrite(kitchenLed, HIGH); } if (rotorMode == 2) { //    digitalWrite(roomLed, HIGH); digitalWrite(kitchenLed, HIGH); } } void enterSleep() { // ledBlink(); afterSleep = true; digitalWrite(txPin, LOW); digitalWrite(txPowerPin, LOW); digitalWrite(roomLed, LOW); digitalWrite(kitchenLed, LOW); digitalWrite(switchLed, LOW); pinMode(txPin, INPUT); pinMode(txPowerPin, INPUT); pinMode(roomLed, INPUT); pinMode(kitchenLed, INPUT); pinMode(switchLed, INPUT); attachInterrupt(0, wakeUp, LOW); adc_disable(); set_sleep_mode(SLEEP_MODE_PWR_DOWN); sleep_enable(); sleep_mode(); sleep_disable(); power_all_enable(); pinMode(txPin, OUTPUT); pinMode(txPowerPin, OUTPUT); pinMode(roomLed, OUTPUT); pinMode(kitchenLed, OUTPUT); pinMode(switchLed, OUTPUT); digitalWrite(txPin, LOW); digitalWrite(txPowerPin, HIGH); // ledBlink(); setLed(); offTimeOut = millis(); allOn = false; allOff = false; } void setup() { // Serial.begin(115200); pinMode(txPin, OUTPUT); pinMode(txPowerPin, OUTPUT); pinMode(roomLed, OUTPUT); pinMode(kitchenLed, OUTPUT); pinMode(switchLed, OUTPUT); digitalWrite(txPin, LOW); digitalWrite(txPowerPin, HIGH); digitalWrite(roomLed, LOW); digitalWrite(kitchenLed, LOW); digitalWrite(switchLed, LOW); // pinMode(buttonPin, INPUT_PULLUP); pinMode(buttonPin, INPUT); pinMode(encA, INPUT); pinMode(encB, INPUT); prevEncA = digitalRead(encA); offTimeOut = millis(); rotorMode = 0; setLed(); prevButton = digitalRead(buttonPin); } void loop() { if ((millis() - offTimeOut) &gt; offDelay) { enterSleep(); } else { //     if (switchLedOn == true) { if ((millis() - switchLedTime) &gt; switchLedTimeOut) { digitalWrite(switchLed, LOW); switchLedOn = false; } } //       if (digitalRead(buttonPin) == LOW) { offTimeOut = millis(); } //   curButton = digitalRead(buttonPin); if ((prevButton == HIGH) &amp;&amp; (curButton == LOW)) { if (modeTimeOutStart == false) { modeTimeOut = millis(); modeTimeOutStart = true; } } else { if (modeTimeOutStart == true) { modeTime = millis() - modeTimeOut; if ((modeTime &lt; modeTreshold) &amp;&amp; (modeTime &gt; bounceTreshold)) { setMode(); modeTimeOutStart = false; prevButton = digitalRead(buttonPin); } else { modeTimeOutStart = false; prevButton = digitalRead(buttonPin); } } } //    if (currentMode != rotorMode) { //       ,     currentMode = rotorMode; //     setLed(); } //   curEncA = digitalRead(encA); if ((prevEncA == LOW) &amp;&amp; (curEncA == HIGH)) { offTimeOut = millis(); if (digitalRead(encB) == LOW) { encCountMinus++; encCountPlus = 0; // Serial.println("Encoder Minus"); if (encCountMinus &gt; switchTreshold) { encCountMinus = 0; lightsUp(false); } } else { encCountPlus++; encCountMinus = 0; // Serial.println("Encoder Plus"); if (encCountPlus &gt; switchTreshold) { encCountPlus = 0; lightsUp(true); } } } prevEncA = curEncA; } }</span></span></code> </pre> <br></div></div><br>  Modèle de cas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par référence</a> . <br><br>  C’est tout. <br><br>  PS: J'ai essayé de ne rien oublier, mais j'ai pu.  Si oui, je m'excuse et ferai de mon mieux pour répondre correctement aux questions principales et corriger les erreurs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr411093/">https://habr.com/ru/post/fr411093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr411083/index.html">Coucher de soleil "Etoiles de l'humanité"</a></li>
<li><a href="../fr411085/index.html">Pi-Sonos v3.0: travailler sur des bugs ou un tout nouveau projet?</a></li>
<li><a href="../fr411087/index.html">L'avenir proche des cartes vidéo</a></li>
<li><a href="../fr411089/index.html">Comment identifier un satellite en orbite</a></li>
<li><a href="../fr411091/index.html">Technologies des centres de données: informations générales sur les commutateurs QFX</a></li>
<li><a href="../fr411097/index.html">Messagerie mobile autonome</a></li>
<li><a href="../fr411099/index.html">Il est facile d'évaluer PPFD lors de l'éclairage d'une usine avec des LED blanches: 1000 lux = 15 μmol / s / m2</a></li>
<li><a href="../fr411101/index.html">Les autorités de New York ont ​​autorisé l'augmentation du coût de l'électricité pour les mineurs</a></li>
<li><a href="../fr411105/index.html">Les performances du drone Courier dépendent de l'endroit où vous vivez</a></li>
<li><a href="../fr411109/index.html">Porsche et Bugatti utilisent l'impression 3D pour créer des détails rares et complexes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>