<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏻 🧗🏼 👩‍🚒 Assembler insere ... em C #? 👋🏼 🖐🏻 💪🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Então, essa história começou com uma coincidência de três fatores. Eu: 



1. escreveu principalmente em c #; 
2. apenas imaginava aproximadamente com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembler insere ... em C #?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464931/">  Então, essa história começou com uma coincidência de três fatores.  Eu: <br><br><ol><li>  escreveu principalmente em c #; </li><li>  apenas imaginava aproximadamente como ele é organizado e funciona; </li><li>  ficou interessado em montador. </li></ol><br>  Essa mistura aparentemente inocente deu origem a uma idéia estranha: é possível de alguma forma combinar essas línguas?  Adicione em C # a capacidade de fazer inserções de assembler, como no C ++. <br><br>  Se você está interessado em quais consequências isso levou, seja bem-vindo ao gato. <br><br> <a href=""><img src="https://habrastorage.org/webt/u-/sg/dk/u-sgdkb-3zwyqg682kuh2vvv1vq.png"></a> <br><a name="habracut"></a><br><h2>  Primeiras dificuldades </h2><br>  Mesmo naquele momento, percebi que é muito improvável que existam ferramentas padrão para chamar código assembler a partir do código C # - isso contradiz muito um dos conceitos importantes da linguagem: segurança de memória.  Após um estudo superficial da questão (que, entre outras coisas, confirmou o palpite inicial - “fora da caixa” não existe essa possibilidade), ficou claro que, além do problema ideológico, existe um problema puramente técnico: o C #, como você sabe, é compilado em um bytecode intermediário, que interpretado ainda mais pela máquina virtual CLR.  E é precisamente aqui que nos deparamos com o mesmo problema: por um lado, o compilador (daqui em diante vou me referir à Roslyn da Microsoft, já que é de fato o padrão no campo dos compiladores C #), obviamente, não pode reconhecer e converter comandos assembler de uma exibição de texto em uma representação binária, o que significa que devemos usar instruções de máquina diretamente em sua forma binária como uma inserção e, por outro lado, a máquina virtual possui seu próprio bytecode e não pode reconhecer e executar esse  comandos agrupados que oferecemos a ela. <br><br>  A solução teórica para esse problema é óbvia - você precisa garantir que o código de inserção binário seja executado pelo processador, ignorando a interpretação da máquina virtual.  A coisa mais simples que vem à mente é armazenar o código binário como uma matriz de bytes, para a qual o controle será transferido de alguma forma no momento certo.  A partir daqui, surge a primeira tarefa: você precisa criar uma maneira de transferir o controle para o que está contido em uma área de memória arbitrária. <br><br><h2>  Primeiro protótipo: "chamando" uma matriz </h2><br>  Esta tarefa é talvez o obstáculo mais sério para as inserções.  Usando as ferramentas de linguagem, é fácil obter um ponteiro para nossa matriz, mas no mundo C # os ponteiros existem apenas nos dados e é impossível transformá-lo em um ponteiro para, digamos, uma função para que possa ser chamado mais tarde (bom, ou pelo menos eu não consegui descobrir como fazer). <br><br>  Felizmente (ou infelizmente), nada é novo sob a lua e uma rápida pesquisa no Yandex pelas palavras “C #” e “assembler insert” me levou a um artigo na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">edição de dezembro de 2007 da revista]] [Aker]</a> .  Tendo honestamente copiado a função de lá e adaptado às minhas necessidades, obtive <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualProtect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flNewProtect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpflOldProtect</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* InvokeAsm(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* firstAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* secondAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] code) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;i; p += <span class="hljs-number"><span class="hljs-number">0x14</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; i = *p; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* b = code) { *p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)b; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> prev; VirtualProtect((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)code.Length, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, &amp;prev); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)i; }</code> </pre> <br>  A idéia principal desse código é substituir o endereço de retorno da função <code>InvokeAsm()</code> na pilha pelo endereço da matriz de bytes para o qual você deseja transferir o controle.  Depois de sair da função, em vez de continuar executando o programa, a execução do nosso código binário começará. <br><br>  Lidaremos com a mágica que <code>InvokeAsm()</code> em <code>InvokeAsm()</code> com mais detalhes.  Primeiro, declaramos uma variável local, que, é claro, aparece na pilha, e então obtemos seu endereço (obtendo assim o endereço do topo da pilha).  Em seguida, adicionamos a ela uma certa constante mágica obtida calculando meticulosamente no depurador o deslocamento do endereço de retorno em relação ao topo da pilha, salve o endereço de retorno e, em vez disso, escreva o endereço da nossa matriz de bytes.  O significado sagrado de salvar o endereço de retorno é óbvio - precisamos continuar executando o programa após nossa inserção, o que significa que precisamos saber para onde transferir o controle após ele.  Em seguida, vem a chamada para a função WinAPI da biblioteca kernel32.dll - <code>VirtualProtect()</code> .  É necessário para alterar os atributos da página de memória na qual o código de inserção está localizado.  Obviamente, ao compilar o programa, ele aparece na seção de dados e a página de memória correspondente possui acesso de leitura e gravação.  Também precisamos adicionar permissão para executar seu conteúdo.  Finalmente, retornamos o endereço de retorno real armazenado.  Obviamente, esse endereço não será retornado para o código chamado <code>InvokeAsm()</code> , porque  execução imediatamente após o <code>return (void*)i;</code>  "Falha" na inserção.  No entanto, as convenções de chamada usadas pela máquina virtual (stdcall com otimização desabilitada e fastcall com habilitado) significam retornar o valor através do registro EAX, ou seja,  para retornar da inserção, precisamos seguir duas instruções: <code>push eax</code> (código 0x50) e <code>ret</code> (código 0xC3). <br><br><div class="spoiler">  <b class="spoiler_title">Esclarecimento</b> <div class="spoiler_text">  No futuro, falaremos sobre a arquitetura do x86 (ou melhor, IA-32) - brega devido ao fato de que naquela época eu estava pelo menos de alguma forma familiarizado com ele, ao contrário, digamos, do x86-64.  No entanto, o método de transferência de controle descrito acima deve funcionar no código de 64 bits. <br></div></div><br>  Por fim, você deve prestar atenção a dois argumentos não utilizados: <code>void* firstAsmArg</code> e <code>void* secondAsmArg</code> .  Eles são necessários para transferir dados arbitrários do usuário para a inserção do assembler.  Esses argumentos serão localizados em um local conhecido na pilha (stdcall) ou, novamente, em registros conhecidos (fastcall). <br><br><div class="spoiler">  <b class="spoiler_title">Um pouco sobre otimização</b> <div class="spoiler_text">  Visto que, do ponto de vista do compilador, o código não entende o que é, pode inadvertidamente lançar alguma chamada de fundamental importância / alinhar algo / não salvar algum argumento "não utilizado" / de alguma forma interferir na implementação do nosso plano.  Isso é parcialmente resolvido pelo <code>[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</code> , no entanto, mesmo essas precauções não produzem o efeito desejado: por exemplo, a variável local <code>i</code> , que é a chave para toda a função, acaba sendo registrada, o que obviamente estraga tudo .  Portanto, para eliminar completamente a probabilidade de algo dar errado, você deve criar uma biblioteca com a otimização desabilitada (desabilite-a nas propriedades do projeto ou use a configuração de Depuração).  Conseqüentemente, stdcall será usado, portanto, no futuro, procederei dessa convenção de chamada. <br></div></div><br><h2>  Aprimoramentos </h2><br><h3>  Seguro é melhor que inseguro </h3><br>  Obviamente, não há questão de segurança (no sentido em que essa palavra é usada em C #).  No entanto, o método <code>InvokeAsm()</code> descrito acima opera em ponteiros, o que significa que ele só pode ser chamado a partir do bloco marcado com a palavra-chave <code>unsafe</code> , o que nem sempre é conveniente - pelo menos requer compilação com a opção / insegura (ou a marca de seleção correspondente nas propriedades do projeto no VS).  Portanto, parece lógico fornecer um shell que opere pelo menos IntPtr (na pior das hipóteses) e, idealmente, permite que o usuário especifique os tipos a serem transmitidos e retornados.  Bem, isso soa genérico, escrevemos genérico, o que mais existe, alguém pergunta, para conversar?  De fato - há algo. <br><br>  O mais óbvio: como obter um ponteiro para um argumento cujo tipo é desconhecido?  Construções do tipo <code>T* ptr = &amp;arg</code> não <code>T* ptr = &amp;arg</code> permitidas em C # e, em geral, não é difícil entender o motivo: o usuário pode muito bem usar um dos tipos gerenciados como parâmetro de tipo, um ponteiro para o qual não pode ser obtido.  A solução poderia ser limitar um parâmetro do tipo <code>unmanaged</code> , mas, em primeiro lugar, ele apareceu apenas no C # 7.3 e, em segundo lugar, não permite a passagem de strings e matrizes como argumentos, embora o operador <code>fixed</code> permita que sejam usados ​​(obtemos o ponteiro para o primeiro caractere ou elemento de matriz, respectivamente).  Além disso, eu gostaria de dar ao usuário a oportunidade de operar, incluindo tipos controlados - desde que começamos a violar as regras do idioma, as violaremos até o fim! <br><br><h3>  Obtendo um ponteiro para um objeto gerenciado e um objeto por ponteiro </h3><br>  E, novamente, após uma deliberação não muito proveitosa, comecei a procurar as soluções finais.  Desta vez, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre Habré</a> me ajudou.  Em resumo, um dos métodos propostos é escrever uma biblioteca auxiliar, e não em C #, mas diretamente em IL.  Sua tarefa é enviar um objeto (na verdade uma referência ao objeto) para a pilha da máquina virtual, transmitida como argumento e, em seguida, recuperar outra coisa da pilha - por exemplo, um número ou <code>IntPtr</code> .  Executando as mesmas etapas na ordem inversa, você pode converter o ponteiro (por exemplo, retornado da inserção do assembler) em um objeto.  Este método é bom porque tudo o que acontece é claro e transparente.  Mas há um sinal de menos: eu queria continuar com o menor número possível de arquivos, então, em vez de escrever uma biblioteca separada, decidi incorporar o código IL na principal.  A única maneira que encontrei é escrever métodos stub em C #, criar o projeto, desmontar o binário usando o ildasm, reescrever o código dos métodos stub e recompilar tudo com o ilasm.  Essas são algumas ações adicionais e, desde que você precise executá-las sempre que construí-las após fazer alterações no código ... Em geral, me cansei muito rapidamente e comecei a procurar alternativas. <br><br>  Naquele momento, um livro maravilhoso caiu em minhas mãos, graças ao qual aprendi muito por mim mesmo - “CLR via C #”, de Jeffrey Richter.  Nele, em algum ponto do século XX, falamos sobre a estrutura <code>GCHandle</code> , que possui um método <code>Alloc()</code> que pega um objeto e um dos <code>GCHandleType</code> enumeração <code>GCHandleType</code> .  Portanto, se você chamar esse método passando o objeto desejado e <code>GCHandle.Pinned</code> , poderá obter o endereço desse objeto na memória.  Além disso, antes de chamar <code>GCHandle.Free()</code> objeto é fixo, ou seja,  totalmente protegido contra os efeitos do coletor de lixo.  No entanto, existem certos problemas.  Primeiro, o <code>GCHandle</code> não ajuda em nada a concluir a conversão "ponteiro → objeto", apenas "objeto → ponteiro".  Mais importante, para usar <code>GCHandleType.Pinned</code> classe ou estrutura do objeto cujo endereço queremos obter deve ter o atributo <code>[StructLayout(LayoutKind.Sequential)]</code> , enquanto <code>LayoutKind.Auto</code> usado por <code>LayoutKind.Auto</code> .  Portanto, esse método é adequado apenas para alguns tipos padrão e para os tipos personalizados que foram originalmente projetados com isso em mente.  Não é exatamente o método universal que gostaríamos de encontrar, certo? <br><br>  Bem, tente novamente.  Agora vamos prestar atenção a duas funções não documentadas, as quais, no entanto, são suportadas por Roslyn: <code>__makeref()</code> e <code>__refvalue()</code> .  O primeiro deles pega um objeto e retorna uma instância da estrutura <code>TypedReference</code> que armazena uma referência ao objeto e seu tipo, enquanto o segundo extrai o objeto da instância <code>typedReference</code> transmitida.  Por que esses recursos são importantes para nós?  Porque <code>TypedReference</code> é uma estrutura!  No contexto da discussão, isso significa que podemos obter um ponteiro para ele, que, em combinação, será um ponteiro para o primeiro campo dessa estrutura.  Ou seja, ele armazena o próprio link para o objeto que nos interessa.  Então, para obter um ponteiro para um objeto gerenciado, precisamos ler o valor de um ponteiro para o que <code>__makeref()</code> retornará e convertê-lo em um ponteiro.  Para obter um objeto por ponteiro, você deve chamar <code>__makeref()</code> de um objeto condicionalmente vazio do tipo necessário, obter um ponteiro para a instância <code>TypedReference</code> retornada, escrever um ponteiro para o objeto e chamar <code>__refvalue()</code> .  O resultado é algo como este código: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tout ToInstance&lt;Tout&gt;(IntPtr ptr) { Tout temp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; TypedReference tr = __makeref(temp); Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr); Tout instance = __refvalue(tr, Tout); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ToPointer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;tr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> **(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>***)&amp;tr; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Observação</b> <div class="spoiler_text">  Retornando à tarefa de escrever um invólucro seguro para <code>InvokeAsm()</code> , <code>InvokeAsm()</code> -se que o método de obter ponteiros usando <code>__makeref()</code> e <code>__refvalue()</code> , diferentemente do <code>GCHandle.Alloc(GCHandleType.Pinned)</code> , não garante que nosso coletor de lixo não esteja em lugar algum. o objeto não se moverá.  Portanto, o wrapper deve começar desativando o coletor de lixo e finalizando com a restauração de sua funcionalidade.  A solução é bastante rude, mas eficaz. <br></div></div><br><h2>  Para quem não se lembra de códigos de operação </h2><br>  Então, aprendemos como chamar código binário, aprendemos como passá-lo como argumentos, não apenas valores imediatos, mas também ponteiros para qualquer coisa ... Existe apenas um problema.  Onde obter o mesmo código binário?  Você pode se armar com um lápis, um bloco de notas e uma tabela de opcode (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta</a> ) ou usar um editor hexadecimal com suporte a assembler x86 ou até mesmo um tradutor completo, mas todas essas opções significam que o usuário precisará usar outra coisa, exceto a biblioteca.  Não era exatamente isso que eu queria, então decidi incluir meu tradutor na biblioteca, que era tradicionalmente chamada SASM (abreviação de Stack Assembler; não tem nada a ver com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IDE</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">Isenção de responsabilidade</b> <div class="spoiler_text">  Eu não sou bom em analisar strings, então o código do tradutor ... bem, imperfeito, para dizer o mínimo.  Além disso, eu não sou forte em expressões regulares, então elas não estão lá.  E, em geral - um analisador iterativo. <br></div></div><br>  Provavelmente não vou falar sobre o processo de criação desse "milagre" - não há nada interessante nesta história, mas descreverei brevemente os principais recursos.  Atualmente, a maioria das instruções x86 é suportada.  As instruções matemáticas do coprocessador para trabalhar com números de ponto flutuante e de extensões (MMX, SSE, AVX) ainda não são suportadas.  É possível declarar constantes, procedimentos, variáveis ​​de pilha local, variáveis ​​globais, cuja memória é alocada durante a tradução diretamente em uma matriz com código binário (se essas variáveis ​​forem nomeadas usando rótulos, seu valor também poderá ser obtido no C # após a inserção, chamando métodos <code>GetBYTEVariable()</code> , <code>GetWORDVariable()</code> , <code>GetDWORDVariable()</code> , <code>GetAStringVariable()</code> e <code>GetWStringVariable()</code> do objeto <code>SASMCode</code> ), <code>addr</code> e <code>invoke</code> estão presentes.  Um dos recursos importantes é o suporte à importação de funções de bibliotecas externas usando a construção <code>extern &lt; &gt; lib &lt; &gt;</code> . <br><br>  <code>asmret</code> macro <code>asmret</code> é digna de um parágrafo separado.  No processo de tradução, ele se desdobra em 11 instruções que formam o epílogo.  O prólogo é adicionado ao início do código traduzido por padrão.  Sua tarefa é salvar / restaurar o estado do processador.  Além disso, o prólogo adiciona quatro constantes - <code>$first</code> , <code>$second</code> , <code>$this</code> e <code>$return</code> .  Durante a conversão, essas constantes são substituídas por endereços na pilha, nos quais, respectivamente, são o primeiro e o segundo argumentos passados ​​para a inserção do assembler, o endereço do primeiro comando de inserção e o endereço de retorno. <br><br><h2>  Sumário </h2><br>  O código dirá muito mais do que palavras, e seria estranho não compartilhar o resultado de um trabalho bastante longo, então convido todos os que me interessam ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br>  Se, no entanto, eu tentar generalizar de alguma forma tudo o que foi feito, então, na minha opinião, um projeto interessante e até, até certo ponto, não inútil, acabou.  Por exemplo, algoritmos idênticos para classificar inserções em C # e usar inserções de assembler diferem na velocidade em mais de duas vezes (é claro, a favor do assembler).  Em projetos sérios, é claro, não é recomendável usar a biblioteca resultante (efeitos colaterais imprevisíveis são possíveis, embora não muito prováveis), mas é bem possível para si mesmo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464931/">https://habr.com/ru/post/pt464931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464919/index.html">Controle de recursos embutidos da RAM usada no aplicativo</a></li>
<li><a href="../pt464921/index.html">System.IO.Pipelines - uma ferramenta pouco conhecida para os amantes de alto desempenho</a></li>
<li><a href="../pt464925/index.html">UX Voice Guide: situações, padrões, ferramentas (e um pouco de apoio moral)</a></li>
<li><a href="../pt464927/index.html">Mineiro ASIC em segunda mão: riscos, verificação e hashrate religado</a></li>
<li><a href="../pt464929/index.html">Carregamento lento da imagem do navegador (atributo de carregamento)</a></li>
<li><a href="../pt464933/index.html">Aplicativos para e-books no sistema operacional Android. Parte 4. Jogos</a></li>
<li><a href="../pt464935/index.html">Confortável DevOpsSec: Nemesida WAF gratuito para NGINX com API e conta pessoal</a></li>
<li><a href="../pt464937/index.html">O resumo de materiais interessantes para o desenvolvedor móvel nº 312 (de 19 a 25 de agosto)</a></li>
<li><a href="../pt464939/index.html">Testando anotações @ NonNull / @ Nullable</a></li>
<li><a href="../pt464947/index.html">Eventos digitais em Moscou, de 25 de agosto a 1 de setembro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>