<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèª üßóüèº üë©‚Äçüöí Assembler insere ... em C #? üëãüèº üñêüèª üí™üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ent√£o, essa hist√≥ria come√ßou com uma coincid√™ncia de tr√™s fatores. Eu: 



1. escreveu principalmente em c #; 
2. apenas imaginava aproximadamente com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembler insere ... em C #?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464931/">  Ent√£o, essa hist√≥ria come√ßou com uma coincid√™ncia de tr√™s fatores.  Eu: <br><br><ol><li>  escreveu principalmente em c #; </li><li>  apenas imaginava aproximadamente como ele √© organizado e funciona; </li><li>  ficou interessado em montador. </li></ol><br>  Essa mistura aparentemente inocente deu origem a uma id√©ia estranha: √© poss√≠vel de alguma forma combinar essas l√≠nguas?  Adicione em C # a capacidade de fazer inser√ß√µes de assembler, como no C ++. <br><br>  Se voc√™ est√° interessado em quais consequ√™ncias isso levou, seja bem-vindo ao gato. <br><br> <a href=""><img src="https://habrastorage.org/webt/u-/sg/dk/u-sgdkb-3zwyqg682kuh2vvv1vq.png"></a> <br><a name="habracut"></a><br><h2>  Primeiras dificuldades </h2><br>  Mesmo naquele momento, percebi que √© muito improv√°vel que existam ferramentas padr√£o para chamar c√≥digo assembler a partir do c√≥digo C # - isso contradiz muito um dos conceitos importantes da linguagem: seguran√ßa de mem√≥ria.  Ap√≥s um estudo superficial da quest√£o (que, entre outras coisas, confirmou o palpite inicial - ‚Äúfora da caixa‚Äù n√£o existe essa possibilidade), ficou claro que, al√©m do problema ideol√≥gico, existe um problema puramente t√©cnico: o C #, como voc√™ sabe, √© compilado em um bytecode intermedi√°rio, que interpretado ainda mais pela m√°quina virtual CLR.  E √© precisamente aqui que nos deparamos com o mesmo problema: por um lado, o compilador (daqui em diante vou me referir √† Roslyn da Microsoft, j√° que √© de fato o padr√£o no campo dos compiladores C #), obviamente, n√£o pode reconhecer e converter comandos assembler de uma exibi√ß√£o de texto em uma representa√ß√£o bin√°ria, o que significa que devemos usar instru√ß√µes de m√°quina diretamente em sua forma bin√°ria como uma inser√ß√£o e, por outro lado, a m√°quina virtual possui seu pr√≥prio bytecode e n√£o pode reconhecer e executar esse  comandos agrupados que oferecemos a ela. <br><br>  A solu√ß√£o te√≥rica para esse problema √© √≥bvia - voc√™ precisa garantir que o c√≥digo de inser√ß√£o bin√°rio seja executado pelo processador, ignorando a interpreta√ß√£o da m√°quina virtual.  A coisa mais simples que vem √† mente √© armazenar o c√≥digo bin√°rio como uma matriz de bytes, para a qual o controle ser√° transferido de alguma forma no momento certo.  A partir daqui, surge a primeira tarefa: voc√™ precisa criar uma maneira de transferir o controle para o que est√° contido em uma √°rea de mem√≥ria arbitr√°ria. <br><br><h2>  Primeiro prot√≥tipo: "chamando" uma matriz </h2><br>  Esta tarefa √© talvez o obst√°culo mais s√©rio para as inser√ß√µes.  Usando as ferramentas de linguagem, √© f√°cil obter um ponteiro para nossa matriz, mas no mundo C # os ponteiros existem apenas nos dados e √© imposs√≠vel transform√°-lo em um ponteiro para, digamos, uma fun√ß√£o para que possa ser chamado mais tarde (bom, ou pelo menos eu n√£o consegui descobrir como fazer). <br><br>  Felizmente (ou infelizmente), nada √© novo sob a lua e uma r√°pida pesquisa no Yandex pelas palavras ‚ÄúC #‚Äù e ‚Äúassembler insert‚Äù me levou a um artigo na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">edi√ß√£o de dezembro de 2007 da revista]] [Aker]</a> .  Tendo honestamente copiado a fun√ß√£o de l√° e adaptado √†s minhas necessidades, obtive <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualProtect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flNewProtect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpflOldProtect</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* InvokeAsm(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* firstAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* secondAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] code) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;i; p += <span class="hljs-number"><span class="hljs-number">0x14</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; i = *p; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* b = code) { *p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)b; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> prev; VirtualProtect((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)code.Length, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, &amp;prev); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)i; }</code> </pre> <br>  A id√©ia principal desse c√≥digo √© substituir o endere√ßo de retorno da fun√ß√£o <code>InvokeAsm()</code> na pilha pelo endere√ßo da matriz de bytes para o qual voc√™ deseja transferir o controle.  Depois de sair da fun√ß√£o, em vez de continuar executando o programa, a execu√ß√£o do nosso c√≥digo bin√°rio come√ßar√°. <br><br>  Lidaremos com a m√°gica que <code>InvokeAsm()</code> em <code>InvokeAsm()</code> com mais detalhes.  Primeiro, declaramos uma vari√°vel local, que, √© claro, aparece na pilha, e ent√£o obtemos seu endere√ßo (obtendo assim o endere√ßo do topo da pilha).  Em seguida, adicionamos a ela uma certa constante m√°gica obtida calculando meticulosamente no depurador o deslocamento do endere√ßo de retorno em rela√ß√£o ao topo da pilha, salve o endere√ßo de retorno e, em vez disso, escreva o endere√ßo da nossa matriz de bytes.  O significado sagrado de salvar o endere√ßo de retorno √© √≥bvio - precisamos continuar executando o programa ap√≥s nossa inser√ß√£o, o que significa que precisamos saber para onde transferir o controle ap√≥s ele.  Em seguida, vem a chamada para a fun√ß√£o WinAPI da biblioteca kernel32.dll - <code>VirtualProtect()</code> .  √â necess√°rio para alterar os atributos da p√°gina de mem√≥ria na qual o c√≥digo de inser√ß√£o est√° localizado.  Obviamente, ao compilar o programa, ele aparece na se√ß√£o de dados e a p√°gina de mem√≥ria correspondente possui acesso de leitura e grava√ß√£o.  Tamb√©m precisamos adicionar permiss√£o para executar seu conte√∫do.  Finalmente, retornamos o endere√ßo de retorno real armazenado.  Obviamente, esse endere√ßo n√£o ser√° retornado para o c√≥digo chamado <code>InvokeAsm()</code> , porque  execu√ß√£o imediatamente ap√≥s o <code>return (void*)i;</code>  "Falha" na inser√ß√£o.  No entanto, as conven√ß√µes de chamada usadas pela m√°quina virtual (stdcall com otimiza√ß√£o desabilitada e fastcall com habilitado) significam retornar o valor atrav√©s do registro EAX, ou seja,  para retornar da inser√ß√£o, precisamos seguir duas instru√ß√µes: <code>push eax</code> (c√≥digo 0x50) e <code>ret</code> (c√≥digo 0xC3). <br><br><div class="spoiler">  <b class="spoiler_title">Esclarecimento</b> <div class="spoiler_text">  No futuro, falaremos sobre a arquitetura do x86 (ou melhor, IA-32) - brega devido ao fato de que naquela √©poca eu estava pelo menos de alguma forma familiarizado com ele, ao contr√°rio, digamos, do x86-64.  No entanto, o m√©todo de transfer√™ncia de controle descrito acima deve funcionar no c√≥digo de 64 bits. <br></div></div><br>  Por fim, voc√™ deve prestar aten√ß√£o a dois argumentos n√£o utilizados: <code>void* firstAsmArg</code> e <code>void* secondAsmArg</code> .  Eles s√£o necess√°rios para transferir dados arbitr√°rios do usu√°rio para a inser√ß√£o do assembler.  Esses argumentos ser√£o localizados em um local conhecido na pilha (stdcall) ou, novamente, em registros conhecidos (fastcall). <br><br><div class="spoiler">  <b class="spoiler_title">Um pouco sobre otimiza√ß√£o</b> <div class="spoiler_text">  Visto que, do ponto de vista do compilador, o c√≥digo n√£o entende o que √©, pode inadvertidamente lan√ßar alguma chamada de fundamental import√¢ncia / alinhar algo / n√£o salvar algum argumento "n√£o utilizado" / de alguma forma interferir na implementa√ß√£o do nosso plano.  Isso √© parcialmente resolvido pelo <code>[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</code> , no entanto, mesmo essas precau√ß√µes n√£o produzem o efeito desejado: por exemplo, a vari√°vel local <code>i</code> , que √© a chave para toda a fun√ß√£o, acaba sendo registrada, o que obviamente estraga tudo .  Portanto, para eliminar completamente a probabilidade de algo dar errado, voc√™ deve criar uma biblioteca com a otimiza√ß√£o desabilitada (desabilite-a nas propriedades do projeto ou use a configura√ß√£o de Depura√ß√£o).  Conseq√ºentemente, stdcall ser√° usado, portanto, no futuro, procederei dessa conven√ß√£o de chamada. <br></div></div><br><h2>  Aprimoramentos </h2><br><h3>  Seguro √© melhor que inseguro </h3><br>  Obviamente, n√£o h√° quest√£o de seguran√ßa (no sentido em que essa palavra √© usada em C #).  No entanto, o m√©todo <code>InvokeAsm()</code> descrito acima opera em ponteiros, o que significa que ele s√≥ pode ser chamado a partir do bloco marcado com a palavra-chave <code>unsafe</code> , o que nem sempre √© conveniente - pelo menos requer compila√ß√£o com a op√ß√£o / insegura (ou a marca de sele√ß√£o correspondente nas propriedades do projeto no VS).  Portanto, parece l√≥gico fornecer um shell que opere pelo menos IntPtr (na pior das hip√≥teses) e, idealmente, permite que o usu√°rio especifique os tipos a serem transmitidos e retornados.  Bem, isso soa gen√©rico, escrevemos gen√©rico, o que mais existe, algu√©m pergunta, para conversar?  De fato - h√° algo. <br><br>  O mais √≥bvio: como obter um ponteiro para um argumento cujo tipo √© desconhecido?  Constru√ß√µes do tipo <code>T* ptr = &amp;arg</code> n√£o <code>T* ptr = &amp;arg</code> permitidas em C # e, em geral, n√£o √© dif√≠cil entender o motivo: o usu√°rio pode muito bem usar um dos tipos gerenciados como par√¢metro de tipo, um ponteiro para o qual n√£o pode ser obtido.  A solu√ß√£o poderia ser limitar um par√¢metro do tipo <code>unmanaged</code> , mas, em primeiro lugar, ele apareceu apenas no C # 7.3 e, em segundo lugar, n√£o permite a passagem de strings e matrizes como argumentos, embora o operador <code>fixed</code> permita que sejam usados ‚Äã‚Äã(obtemos o ponteiro para o primeiro caractere ou elemento de matriz, respectivamente).  Al√©m disso, eu gostaria de dar ao usu√°rio a oportunidade de operar, incluindo tipos controlados - desde que come√ßamos a violar as regras do idioma, as violaremos at√© o fim! <br><br><h3>  Obtendo um ponteiro para um objeto gerenciado e um objeto por ponteiro </h3><br>  E, novamente, ap√≥s uma delibera√ß√£o n√£o muito proveitosa, comecei a procurar as solu√ß√µes finais.  Desta vez, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre Habr√©</a> me ajudou.  Em resumo, um dos m√©todos propostos √© escrever uma biblioteca auxiliar, e n√£o em C #, mas diretamente em IL.  Sua tarefa √© enviar um objeto (na verdade uma refer√™ncia ao objeto) para a pilha da m√°quina virtual, transmitida como argumento e, em seguida, recuperar outra coisa da pilha - por exemplo, um n√∫mero ou <code>IntPtr</code> .  Executando as mesmas etapas na ordem inversa, voc√™ pode converter o ponteiro (por exemplo, retornado da inser√ß√£o do assembler) em um objeto.  Este m√©todo √© bom porque tudo o que acontece √© claro e transparente.  Mas h√° um sinal de menos: eu queria continuar com o menor n√∫mero poss√≠vel de arquivos, ent√£o, em vez de escrever uma biblioteca separada, decidi incorporar o c√≥digo IL na principal.  A √∫nica maneira que encontrei √© escrever m√©todos stub em C #, criar o projeto, desmontar o bin√°rio usando o ildasm, reescrever o c√≥digo dos m√©todos stub e recompilar tudo com o ilasm.  Essas s√£o algumas a√ß√µes adicionais e, desde que voc√™ precise execut√°-las sempre que constru√≠-las ap√≥s fazer altera√ß√µes no c√≥digo ... Em geral, me cansei muito rapidamente e comecei a procurar alternativas. <br><br>  Naquele momento, um livro maravilhoso caiu em minhas m√£os, gra√ßas ao qual aprendi muito por mim mesmo - ‚ÄúCLR via C #‚Äù, de Jeffrey Richter.  Nele, em algum ponto do s√©culo XX, falamos sobre a estrutura <code>GCHandle</code> , que possui um m√©todo <code>Alloc()</code> que pega um objeto e um dos <code>GCHandleType</code> enumera√ß√£o <code>GCHandleType</code> .  Portanto, se voc√™ chamar esse m√©todo passando o objeto desejado e <code>GCHandle.Pinned</code> , poder√° obter o endere√ßo desse objeto na mem√≥ria.  Al√©m disso, antes de chamar <code>GCHandle.Free()</code> objeto √© fixo, ou seja,  totalmente protegido contra os efeitos do coletor de lixo.  No entanto, existem certos problemas.  Primeiro, o <code>GCHandle</code> n√£o ajuda em nada a concluir a convers√£o "ponteiro ‚Üí objeto", apenas "objeto ‚Üí ponteiro".  Mais importante, para usar <code>GCHandleType.Pinned</code> classe ou estrutura do objeto cujo endere√ßo queremos obter deve ter o atributo <code>[StructLayout(LayoutKind.Sequential)]</code> , enquanto <code>LayoutKind.Auto</code> usado por <code>LayoutKind.Auto</code> .  Portanto, esse m√©todo √© adequado apenas para alguns tipos padr√£o e para os tipos personalizados que foram originalmente projetados com isso em mente.  N√£o √© exatamente o m√©todo universal que gostar√≠amos de encontrar, certo? <br><br>  Bem, tente novamente.  Agora vamos prestar aten√ß√£o a duas fun√ß√µes n√£o documentadas, as quais, no entanto, s√£o suportadas por Roslyn: <code>__makeref()</code> e <code>__refvalue()</code> .  O primeiro deles pega um objeto e retorna uma inst√¢ncia da estrutura <code>TypedReference</code> que armazena uma refer√™ncia ao objeto e seu tipo, enquanto o segundo extrai o objeto da inst√¢ncia <code>typedReference</code> transmitida.  Por que esses recursos s√£o importantes para n√≥s?  Porque <code>TypedReference</code> √© uma estrutura!  No contexto da discuss√£o, isso significa que podemos obter um ponteiro para ele, que, em combina√ß√£o, ser√° um ponteiro para o primeiro campo dessa estrutura.  Ou seja, ele armazena o pr√≥prio link para o objeto que nos interessa.  Ent√£o, para obter um ponteiro para um objeto gerenciado, precisamos ler o valor de um ponteiro para o que <code>__makeref()</code> retornar√° e convert√™-lo em um ponteiro.  Para obter um objeto por ponteiro, voc√™ deve chamar <code>__makeref()</code> de um objeto condicionalmente vazio do tipo necess√°rio, obter um ponteiro para a inst√¢ncia <code>TypedReference</code> retornada, escrever um ponteiro para o objeto e chamar <code>__refvalue()</code> .  O resultado √© algo como este c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tout ToInstance&lt;Tout&gt;(IntPtr ptr) { Tout temp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; TypedReference tr = __makeref(temp); Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr); Tout instance = __refvalue(tr, Tout); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ToPointer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;tr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> **(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>***)&amp;tr; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Observa√ß√£o</b> <div class="spoiler_text">  Retornando √† tarefa de escrever um inv√≥lucro seguro para <code>InvokeAsm()</code> , <code>InvokeAsm()</code> -se que o m√©todo de obter ponteiros usando <code>__makeref()</code> e <code>__refvalue()</code> , diferentemente do <code>GCHandle.Alloc(GCHandleType.Pinned)</code> , n√£o garante que nosso coletor de lixo n√£o esteja em lugar algum. o objeto n√£o se mover√°.  Portanto, o wrapper deve come√ßar desativando o coletor de lixo e finalizando com a restaura√ß√£o de sua funcionalidade.  A solu√ß√£o √© bastante rude, mas eficaz. <br></div></div><br><h2>  Para quem n√£o se lembra de c√≥digos de opera√ß√£o </h2><br>  Ent√£o, aprendemos como chamar c√≥digo bin√°rio, aprendemos como pass√°-lo como argumentos, n√£o apenas valores imediatos, mas tamb√©m ponteiros para qualquer coisa ... Existe apenas um problema.  Onde obter o mesmo c√≥digo bin√°rio?  Voc√™ pode se armar com um l√°pis, um bloco de notas e uma tabela de opcode (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta</a> ) ou usar um editor hexadecimal com suporte a assembler x86 ou at√© mesmo um tradutor completo, mas todas essas op√ß√µes significam que o usu√°rio precisar√° usar outra coisa, exceto a biblioteca.  N√£o era exatamente isso que eu queria, ent√£o decidi incluir meu tradutor na biblioteca, que era tradicionalmente chamada SASM (abrevia√ß√£o de Stack Assembler; n√£o tem nada a ver com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IDE</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">Isen√ß√£o de responsabilidade</b> <div class="spoiler_text">  Eu n√£o sou bom em analisar strings, ent√£o o c√≥digo do tradutor ... bem, imperfeito, para dizer o m√≠nimo.  Al√©m disso, eu n√£o sou forte em express√µes regulares, ent√£o elas n√£o est√£o l√°.  E, em geral - um analisador iterativo. <br></div></div><br>  Provavelmente n√£o vou falar sobre o processo de cria√ß√£o desse "milagre" - n√£o h√° nada interessante nesta hist√≥ria, mas descreverei brevemente os principais recursos.  Atualmente, a maioria das instru√ß√µes x86 √© suportada.  As instru√ß√µes matem√°ticas do coprocessador para trabalhar com n√∫meros de ponto flutuante e de extens√µes (MMX, SSE, AVX) ainda n√£o s√£o suportadas.  √â poss√≠vel declarar constantes, procedimentos, vari√°veis ‚Äã‚Äãde pilha local, vari√°veis ‚Äã‚Äãglobais, cuja mem√≥ria √© alocada durante a tradu√ß√£o diretamente em uma matriz com c√≥digo bin√°rio (se essas vari√°veis ‚Äã‚Äãforem nomeadas usando r√≥tulos, seu valor tamb√©m poder√° ser obtido no C # ap√≥s a inser√ß√£o, chamando m√©todos <code>GetBYTEVariable()</code> , <code>GetWORDVariable()</code> , <code>GetDWORDVariable()</code> , <code>GetAStringVariable()</code> e <code>GetWStringVariable()</code> do objeto <code>SASMCode</code> ), <code>addr</code> e <code>invoke</code> est√£o presentes.  Um dos recursos importantes √© o suporte √† importa√ß√£o de fun√ß√µes de bibliotecas externas usando a constru√ß√£o <code>extern &lt; &gt; lib &lt; &gt;</code> . <br><br>  <code>asmret</code> macro <code>asmret</code> √© digna de um par√°grafo separado.  No processo de tradu√ß√£o, ele se desdobra em 11 instru√ß√µes que formam o ep√≠logo.  O pr√≥logo √© adicionado ao in√≠cio do c√≥digo traduzido por padr√£o.  Sua tarefa √© salvar / restaurar o estado do processador.  Al√©m disso, o pr√≥logo adiciona quatro constantes - <code>$first</code> , <code>$second</code> , <code>$this</code> e <code>$return</code> .  Durante a convers√£o, essas constantes s√£o substitu√≠das por endere√ßos na pilha, nos quais, respectivamente, s√£o o primeiro e o segundo argumentos passados ‚Äã‚Äãpara a inser√ß√£o do assembler, o endere√ßo do primeiro comando de inser√ß√£o e o endere√ßo de retorno. <br><br><h2>  Sum√°rio </h2><br>  O c√≥digo dir√° muito mais do que palavras, e seria estranho n√£o compartilhar o resultado de um trabalho bastante longo, ent√£o convido todos os que me interessam ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br>  Se, no entanto, eu tentar generalizar de alguma forma tudo o que foi feito, ent√£o, na minha opini√£o, um projeto interessante e at√©, at√© certo ponto, n√£o in√∫til, acabou.  Por exemplo, algoritmos id√™nticos para classificar inser√ß√µes em C # e usar inser√ß√µes de assembler diferem na velocidade em mais de duas vezes (√© claro, a favor do assembler).  Em projetos s√©rios, √© claro, n√£o √© recomend√°vel usar a biblioteca resultante (efeitos colaterais imprevis√≠veis s√£o poss√≠veis, embora n√£o muito prov√°veis), mas √© bem poss√≠vel para si mesmo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464931/">https://habr.com/ru/post/pt464931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464919/index.html">Controle de recursos embutidos da RAM usada no aplicativo</a></li>
<li><a href="../pt464921/index.html">System.IO.Pipelines - uma ferramenta pouco conhecida para os amantes de alto desempenho</a></li>
<li><a href="../pt464925/index.html">UX Voice Guide: situa√ß√µes, padr√µes, ferramentas (e um pouco de apoio moral)</a></li>
<li><a href="../pt464927/index.html">Mineiro ASIC em segunda m√£o: riscos, verifica√ß√£o e hashrate religado</a></li>
<li><a href="../pt464929/index.html">Carregamento lento da imagem do navegador (atributo de carregamento)</a></li>
<li><a href="../pt464933/index.html">Aplicativos para e-books no sistema operacional Android. Parte 4. Jogos</a></li>
<li><a href="../pt464935/index.html">Confort√°vel DevOpsSec: Nemesida WAF gratuito para NGINX com API e conta pessoal</a></li>
<li><a href="../pt464937/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel n¬∫ 312 (de 19 a 25 de agosto)</a></li>
<li><a href="../pt464939/index.html">Testando anota√ß√µes @ NonNull / @ Nullable</a></li>
<li><a href="../pt464947/index.html">Eventos digitais em Moscou, de 25 de agosto a 1 de setembro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>