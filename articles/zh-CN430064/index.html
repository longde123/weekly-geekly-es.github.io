<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏿 👨🏽‍🌾 👨‍❤️‍👨 C ++：自发性考古，为什么不应该使用C风格的变量函数 🏓 🔅 🏷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="与往常一样，这一切都始于错误。 这是我第一次使用Java Native Interface，并且在C ++部分中，我包装了一个创建Java对象的函数。 该函数CallVoidMethod是可变的，即 除了指向JNI环境的指针，指向要创建的对象类型的指针以及被调用方法的标识符（在本例中为构造函数）之外...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++：自发性考古，为什么不应该使用C风格的变量函数</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430064/">与往常一样，这一切都始于错误。 这是我第一次使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java Native Interface，</a>并且在C ++部分中，我包装了一个创建Java对象的函数。 该函数<code>CallVoidMethod</code>是可变的，即 除了指向<abbr title="Java本机接口">JNI</abbr>环境的指针，指向要创建的对象类型的指针以及被调用方法的标识符（在本例中为构造函数）之外，它还接受任意数量的其他参数。 这是合乎逻辑的，因为 这些其他参数传递给Java端的被调用方法，并且这些方法可以不同，具有任何类型的不同数量的参数。 <br><br> 因此，我还使包装器变量。 为了将任意数量的参数传递给<code>CallVoidMethod</code>使用了<code>va_list</code> ，因为在这种情况下它是不同的。 是的，这就是<code>va_list</code>发送到<code>CallVoidMethod</code> 。 并丢弃了JVM常规分段错误。 <br><br> 在两个小时内，我设法尝试了从第八版到第十一版的JVM的多个版本，因为：首先，这是我第一次使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Java虚拟机">JVM</a> ，在这个问题上，我对StackOverflow的信任程度超过了我，其次，有人然后在StackOverflow上，我建议在这种情况下不要使用OpenJDK，而是使用OracleJDK，而不是8，而是10。只有到那时，我才最终注意到，除了变量<code>CallVoidMethod</code>之外，还有<code>CallVoidMethodV</code> ，它通过<code>va_list</code>接受任意数量的参数。 <br><br> 我最不喜欢这个故事的地方是，我没有立即注意到省略号（省略号）和<code>va_list</code>之间的区别。 在注意到之后，我无法向自己解释根本的区别是什么。 因此，我们需要处理省略号， <code>va_list</code>以及变量模板（因为我们仍在讨论C ++）。 <br><a name="habracut"></a><br><h3> 标准中说了省略号和va_list呢？ </h3><br>  C ++标准仅描述了其要求与标准C的要求之间的差异。稍后将讨论这些差异本身，但是现在，我将简要解释一下标准C所说的内容（从C89开始）。 <br><br><ul><li> 您可以声明一个带有任意数量参数的函数。 即 一个函数可以有比参数更多的参数。 为此，其参数列表必须以省略号结尾，但是还必须至少存在一个固定参数<i>[C11 6.9.1 / 8]</i> ： <br><br><pre> <code class="plaintext hljs">void foo(int parm1, int parm2, ...);</code> </pre> </li><li> 有关与省略号相对应的参数的数量和类型的信息不会传递给函数本身。 即 在最后一个命名参数（在上面的示例中为<code>parm2</code> ）之后<i>[C11 6.7.6.3/9]</i> 。 <br></li><li> 要访问这些参数，必须使用在<code>&lt;stdarg.h&gt;</code>标头中声明的<code>va_list</code>类型和4个（在C11标准之前为3）宏： <code>va_start</code> ， <code>va_arg</code> ， <code>va_end</code>和<code>va_copy</code> （从C11开始） <i>[C11 7.16]</i> 。 <br><br><div class="spoiler">  <b class="spoiler_title">举个例子</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int add(int count, ...) { int result = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; ++i) { result += va_arg(args, int); } va_end(args); return result; }</code> </pre> <br> 是的，该函数不知道它有多少个参数。 她需要以某种方式传递这个数字。 在这种情况下，通过单个命名参数（另一个常见的选择是将<code>NULL</code>作为最后一个参数传递，如<code>execl</code>或0）。 </div></div></li><li> 最后一个命名参数不能具有<code>register</code>存储类；它不能是函数或数组。 否则，未定义的行为<i>[C11 7.16.1.4/4]</i> 。 </li><li> 而且，对于最后一个命名的自变量和所有无名的自变量，都应用了“ <i>默认自变量提升</i> ”（ <i>默认自变量提升</i> ；如果将此概念很好地翻译成俄语，我很乐意使用它）。 这意味着，如果参数的类型为<code>char</code> ， <code>short</code> （带或不带符号）或<code>float</code> ，则必须以<code>int</code> ， <code>int</code> （带或不带符号）或<code>double</code>形式访问相应的参数。 否则，未定义行为<i>[C11 7.16.1.1/2]</i> 。 </li><li> 关于<code>va_list</code>类型，只说它是在<code>&lt;stdarg.h&gt;</code>中<code>&lt;stdarg.h&gt;</code>并且是完整的（也就是说，已知这种类型的对象的大小） <i>[C11 7.16 / 3]</i> 。 </li></ul><br><h3> 怎么了 但是因为！ </h3><br>  C中没有很多类型。 为什么在标准中声明<code>va_list</code> ，但对其内部结构却什么也没说？ <br><br> 如果可以通过<code>va_list</code>传递函数的任意数量的参数，为什么需要省略号？ 现在可以说：“作为语法糖”，但是40年前，我敢肯定，没有时间使用糖。 <br><br>  Philip James Plauger <i>Phillip James Plauger</i>在<i>《标准C库》</i> （1992年）一书中说，最初C是专门为PDP-11计算机创建的。 并且可以使用简单的指针算法对函数的所有参数进行排序。 问题随着C的普及以及将编译器转移到其他体系结构而出现。  <i>Brian Kernighan</i>和Dennis Ritchie于1978年出版的第一版<i>C编程语言</i>明确指出： <blockquote> 顺便说一句，没有一种可接受的方式来编写任意数量的参数的可移植函数，因为 对于被调用函数，没有可移植的方法来查找被调用时传递给它的参数数量。  ... <code>printf</code>是任意数量参数的最典型的C语言函数，...是不可移植的，必须为每个系统实现。 </blockquote> 这本书介绍了<code>printf</code> ，但还没有<code>vprintf</code> ，也没有提到类型和宏<code>va_*</code> 。 它们出现在第二版的C编程语言（1988）中，这是开发第一个C标准（C89，又名ANSI C）的委员会的优点。 该委员会在标准中添加了<code>&lt;stdarg.h&gt;</code>标题，以Andrew Koenig为增加UNIX OS的可移植性而创建的<code>&lt;varargs.h&gt;</code>为基础。 决定将<code>va_*</code>宏保留为宏，以便现有编译器更容易支持新标准。 <br><br> 现在，随着C89和<code>va_*</code>系列的出现，创建可移植变量函数成为可能。 尽管这个家庭的内部结构仍然没有任何描述，也没有任何要求，但是很清楚为什么。 <br><br> 出于好奇，您可以找到<code>&lt;stdarg.h&gt;</code>的实现示例。 例如，相同的“ C标准库”提供了<b>Borland Turbo C ++</b>的示例： <br><br><div class="spoiler">  <b class="spoiler_title">来自Borland Turbo C ++的&lt;stdarg.h&gt;</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#ifndef _STADARG #define _STADARG #define _AUPBND 1 #define _ADNBND 1 typedef char* va_list #define va_arg(ap, T) \ (*(T*)(((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND))) #define va_end(ap) \ (void)0 #define va_start(ap, A) \ (void)((ap) = (char*)&amp;(A) + _Bnd(A, _AUPBND)) #define _Bnd(X, bnd) \ (sizeof(X) + (bnd) &amp; ~(bnd)) #endif</code> </pre> <br></div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">适用于AMD64的</a>更新得多的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SystemV ABI</a>将此类型用于<code>va_list</code> ： <br><br><div class="spoiler">  <b class="spoiler_title">va_list SystemV ABI AMD64</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1];</code> </pre> <br></div></div><br> 通常，可以说类型和宏<code>va_*</code>为遍历变量函数的参数提供了标准接口，并且出于历史原因，它们的实现取决于编译器，目标平台和体系结构。 此外，省略号（即通常为可变函数）早于<code>va_list</code> （即标头<code>&lt;stdarg.h&gt;</code> ）出现在C中。 并不是创建<code>va_list</code>来代替省略号，而是使开发人员能够编写其可移植变量函数。 <br><br>  C ++很大程度上保持了与C的向后兼容性，因此上述所有内容均适用于C。 但是也有功能。 <br><br><h3>  C ++中的变量函数 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WG21</a>工作组参与了C ++标准的开发。  1989年，以新创建的C89标准为基础，并逐渐更改以描述C ++本身。  1995年，从<i>约翰·</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">米科（</a> <i>John Micco</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">）收到了</a>提案<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">N0695</a> ，其中作者建议更改对宏<code>va_*</code>的限制： <br><br><ul><li> 因为 与C不同，C ++允许您获取变量的<code>register</code>地址，然后变量函数的最后一个命名参数可以具有此存储类。 <br></li><li> 因为  C ++中出现的链接违反了C变量函数的不成文规则-参数的大小必须匹配其声明的类型的大小-然后最后一个命名参数不能是链接。 否则，行为含糊。 <br></li><li> 因为 在C ++中，没有“ <i>默认情况下提高参数类型</i> ”的概念，然后是 <br><blockquote> 如果参数<code>parmN</code>声明为...与在应用默认参数提升后产生的类型不兼容的类型，则该行为未定义 </blockquote> 必须替换为 <blockquote> 如果参数<code>parmN</code>声明为...与在传递没有参数的参数时导致的类型不兼容的类型，则行为未定义 </blockquote></li></ul> 为了分享我的痛苦，我什至没有翻译最后一点。 首先，C ++ Standard中的“ <i>默认参数类型升级</i> ”仍为<i>[C ++ 17 8.2.2 / 9]</i> 。 其次，与标准C相比，我很困惑这个短语的含义。 只有阅读了N0695，我才终于明白：我的意思是相同的。 <br><br> 但是，全部采用了3个更改<i>[C ++ 98 18.7 / 3]</i> 。 早在C ++中，对变量函数至少要具有一个命名参数的要求（在这种情况下，您将无法访问其他命名参数，但稍后再进行介绍）已经消失了，并且未命名参数的有效类型列表已添加了指向类成员和<abbr title="普通的旧数据">POD</abbr>类型的指针。 <br><br>  C ++ 03标准未对变函数进行任何更改。  C ++ 11开始将类型为<code>std::nullptr_t</code>的未命名参数转换为<code>void*</code>并允许编译器自行决定使用非平凡的构造函数和析构函数来支持类型<i>[C ++ 11 5.2.2 / 7]</i> 。  C ++ 14允许使用函数和数组作为最后一个命名参数<i>[C ++ 14 18.10 / 3]</i> ，C ++ 17禁止使用由lambda捕获的<i>扩展包</i>和变量<i>[C ++ 17 21.10.1 / 1]</i> 。 <br><br> 结果，C ++在其陷阱中增加了可变函数。 只有非平凡的构造函数/析构函数的未指定类型支持才值得。 下面，我将尝试将变量函数的所有非显而易见的特性简化为一个列表，并通过具体示例对其进行补充。 <br><br><h3> 如何轻松，错误地使用变量函数 </h3><br><ol><li> 用提升的类型声明最后一个命名的参数是不正确的，即  <code>char</code> ，有<code>signed char</code> ， <code>unsigned char</code> ， <code>singed short</code> ， <code>unsigned short</code>或<code>float</code> 。 根据标准的结果将是不确定的行为。 <br><br><div class="spoiler">  <b class="spoiler_title">无效的代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(float n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> <br></div></div><br> 在我手头的所有编译器（gcc，clang，MSVC）中，只有<b>clang</b>发出警告。 <br><br><div class="spoiler">  <b class="spoiler_title">lang警告</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object that undergoes default argument promotion to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br> 并且尽管在所有情况下编译后的代码都能正常运行，但您不应指望它。 <br><br><div class="spoiler">  <b class="spoiler_title">没错</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(double n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li> 将最后一个命名的参数声明为引用是不正确的。 任何链接。 在这种情况下，该标准还保证了未定义的行为。 <br><br><div class="spoiler">  <b class="spoiler_title">无效的代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int&amp; n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br>  <b>gcc 7.3.0</b>编译了此代码，没有任何注释。  <b>lang 6.0.0</b>发出了警告，但仍进行了编译。 <br><br><div class="spoiler">  <b class="spoiler_title">lang警告</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object of reference type to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br> 在这两种情况下，该程序都能正常运行（幸运的是，您不能依赖它）。 但是<b>MSVC 19.15.26730</b>表现出色-拒绝编译代码，因为  <code>va_start</code>参数不能为引用。 <br><br><div class="spoiler">  <b class="spoiler_title">来自MSVC的错误</b> <div class="spoiler_text"><pre> <code class="diff hljs">c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vadefs.h(151): error C2338: va_start argument must not have reference type and must not be parenthesized</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">好吧，正确的选项看起来像这样</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int* n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li> 请求<code>va_arg</code>引发<code>char</code>类型<code>char</code> ， <code>short</code>或<code>float</code>是错误的。 <br><br><div class="spoiler">  <b class="spoiler_title">无效的代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); } int main() { foo(0, 1, 2.0f, 3); return 0; }</code> </pre> </div></div><br> 这里更有趣。  <b>编译</b>时的<b>gcc</b>发出警告，有必要使用<code>double</code>而不是<code>float</code> ，并且如果仍然执行此代码，则程序将以错误结尾。 <br><br><div class="spoiler">  <b class="spoiler_title">海湾合作委员会警告</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:15: warning: 'float' is promoted to 'double' when passed through '...' std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~~ ./test.cpp:9:15: note: (so you should pass 'double' not 'float' to 'va_arg') ./test.cpp:9:15: note: if this code is reached, the program will abort</code> </pre> </div></div><br> 实际上，该程序因抱怨无效指令而崩溃。 <br> 转储分析表明该程序收到了SIGILL信号。 并且还显示了<code>va_list</code>的结构。 对于32位，这是 <br><br><pre> <code class="diff hljs">va = 0xfffc6918 ""</code> </pre> <br> 即  <code>va_list</code>只是<code>char*</code> 。 对于64位： <br><br><pre> <code class="diff hljs">va = {{gp_offset = 16, fp_offset = 48, overflow_arg_area = 0x7ffef147e7e0, reg_save_area = 0x7ffef147e720}}</code> </pre> <br> 即 完全与SystemV ABI AMD64中描述的相同。 <br><br> 编译时发出的<b>clang</b>警告未定义的行为，还建议用<code>double</code>代替<code>float</code> 。 <br><br><div class="spoiler">  <b class="spoiler_title">lang警告</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:26: warning: second argument to 'va_arg' is of promotable type 'float'; this va_arg has undefined behavior because arguments will be promoted to 'double' [-Wvarargs] std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~</code> </pre> </div></div><br> 但是程序不再崩溃，32位版本产生： <br><br><pre> <code class="diff hljs">1 0 1073741824</code> </pre> <br>  64位： <br><br><pre> <code class="diff hljs">1 0 3</code> </pre> <br>  <b>MSVC</b>会产生完全相同的结果，即使使用<code>/Wall</code>也不会发出警告。 <br><br> 这里可以假定32位和64位之间的差异是由于以下事实：在第一种情况下，ABI将所有参数通过堆栈传递给调用的函数，而在第二种情况下，前四个（Windows）或六个（Linux）参数通过处理器寄存器传递，其余的则通过堆栈[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wiki</a> ]。 但是不，如果您不使用4而是使用19来调用<code>foo</code> ，并以相同的方式输出它们，结果将是相同的：32位版本完全混乱，而64位一个<code>float</code>为零。 即 重点当然是在ABI中，而不是在使用寄存器传递参数时。 <br><br><div class="spoiler">  <b class="spoiler_title">好吧，当然，这样做是对的</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, double) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li> 传递带有非平凡的构造函数或析构函数作为未命名参数的类的实例是不正确的。 当然，除非该代码的命运使您至少比“现在就编译并运行”更能激发您一点。 <br><br><div class="spoiler">  <b class="spoiler_title">无效的代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; struct Bar { Bar() { std::cout &lt;&lt; "Bar default ctor" &lt;&lt; std::endl; } Bar(const Bar&amp;) { std::cout &lt;&lt; "Bar copy ctor" &lt;&lt; std::endl; } ~Bar() { std::cout &lt;&lt; "Bar dtor" &lt;&lt; std::endl; } }; struct Cafe { Cafe() { std::cout &lt;&lt; "Cafe default ctor" &lt;&lt; std::endl; } Cafe(const Cafe&amp;) { std::cout &lt;&lt; "Cafe copy ctor" &lt;&lt; std::endl; } ~Cafe() { std::cout &lt;&lt; "Cafe dtor" &lt;&lt; std::endl; } }; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto b = va_arg(va, Bar); va_end(va); } int main() { Bar b; Cafe c; foo(1, b, c); return 0; }</code> </pre> </div></div><br> 叮叮当当再次变得更加严格。 他只是拒绝编译此代码，因为第二个参数<code>va_arg</code>不是POD类型，并警告该程序将在启动时<code>va_arg</code> 。 <br><br><div class="spoiler">  <b class="spoiler_title">lang警告</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:23:31: error: second argument to 'va_arg' is of non-POD type 'Bar' [-Wnon-pod-varargs] const auto b = va_arg(va, Bar); ^~~ ./test.cpp:31:12: error: cannot pass object of non-trivial type 'Bar' through variadic function; call will abort at runtime [-Wnon-pod-varargs] foo(1, b, c); ^</code> </pre> </div></div><br> 如果仍然使用<code>-Wno-non-pod-varargs</code>标志进行编译，那么它将是这样。 <br><br>  <b>MSVC</b>警告在这种情况下，将类型与非平凡的构造函数一起使用是不可移植的。 <br><br><div class="spoiler">  <b class="spoiler_title">来自MSVC的警告</b> <div class="spoiler_text"><pre> <code class="diff hljs">d:\my documents\visual studio 2017\projects\test\test\main.cpp(31): warning C4840:    "Bar"         </code> </pre> </div></div><br> 但是代码可以编译并正确运行。 在控制台中获得以下内容： <br><br><div class="spoiler">  <b class="spoiler_title">启动结果</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br> 即 仅在调用<code>va_arg</code>时创建一个副本，事实证明该参数是通过引用传递的。 虽然不明显，但标准允许。 <br><br>  <b>gcc 6.3.0</b>编译时没有任何注释。 输出是相同的： <br><br><div class="spoiler">  <b class="spoiler_title">启动结果</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  <b>gcc 7.3.0</b>也不警告任何东西，但是行为正在改变： <br><br><div class="spoiler">  <b class="spoiler_title">启动结果</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Cafe copy ctor Bar copy ctor Before va_arg Bar copy ctor Bar dtor Bar dtor Cafe dtor Cafe dtor Bar dtor</code> </pre> </div></div><br> 即 此版本的编译器按值传递参数，并且在调用时， <code>va_arg</code>会创建另一个副本。 如果从构造函数/析构函数有副作用，则在从gcc的第6版切换到第7版时寻找这种差异会很有趣。 <br><br> 顺便说一句，如果您显式传递并请求对该类的引用： <br><br><div class="spoiler">  <b class="spoiler_title">另一个错误的代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto&amp; b = va_arg(va, Bar&amp;); va_end(va); } int main() { Bar b; Cafe c; foo(1, std::ref(b), c); return 0; }</code> </pre> </div></div><br> 那么所有编译器都会抛出错误。 按标准要求。 <br><br> 通常，如果您确实愿意，最好通过指针传递参数。 <br><br><div class="spoiler">  <b class="spoiler_title">像这样</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto* b = va_arg(va, Bar*); va_end(va); } int main() { Bar b; Cafe c; foo(1, &amp;b, &amp;c); return 0; }</code> </pre> </div></div><br></li></ol><br><h3> 重载分辨率和变量函数 </h3><br> 一方面，一切都很简单：即使在标准或用户定义的类型转换的情况下，与省略号的匹配也比与常规命名参数的匹配差。 <br><br><div class="spoiler">  <b class="spoiler_title">过载示例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } int main() { foo(1); foo(1ul); foo(); return 0; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">启动结果</b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function C variadic function</code> </pre> </div></div><br> 但这仅在需要单独考虑对不带参数的<code>foo</code>的调用之前有效。 <br><br><div class="spoiler">  <b class="spoiler_title">不带参数调用foo</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">编译器输出</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:16:9: error: call of overloaded 'foo()' is ambiguous foo(); ^ ./test.cpp:3:6: note: candidate: void foo(...) void foo(...) ^~~ ./test.cpp:8:6: note: candidate: void foo() void foo() ^~~</code> </pre> </div></div><br> 一切都是按照标准进行的：没有参数-无法与省略号进行比较，并且当重载得到解决时，变量函数不会比平时的函数差。 <br><br><h3> 但是什么时候值得使用变量函数 </h3><br> 好吧，变异函数有时表现得不太明显，在C ++的上下文中，它们很容易移植。  Internet上有许多技巧，例如“请勿创建或使用可变C函数”，但是它们不会从C ++标准中删除其支持。 那么这些功能有一些好处吗？ 好吧 <br><br><ul><li> 最常见和最明显的情况是向后兼容。 在这里，我将同时包括使用第三方C库（我在JNI中的情况）和为C ++实现提供C API。 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="替换失败不是错误">SFINAE</a> 。 在这里非常有用的是，在C ++中，变量函数不需要具有命名参数，并且在解析重载函数时，变量函数被认为是最后一个（如果存在至少一个参数）。 与其他函数一样，变量函数只能声明，而不能调用。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static void detect(const U&amp;); static int detect(...); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; };</code> </pre> </div></div><br> 尽管在C ++ 14中，您可以做一些不同的事情。 <br><br><div class="spoiler">  <b class="spoiler_title">另一个例子</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static constexpr bool detect(const U*) { return true; } template &lt;class U&gt; static constexpr bool detect(...) { return false; } public: static constexpr bool value = detect&lt;T&gt;(nullptr); };</code> </pre> </div></div><br> 在这种情况下，已经有必要注意观察哪些参数可以调用<code>detect(...)</code> 。 我宁愿更改几行代码，并使用现代方法替代变量函数，但要避免所有缺点。 <br></li></ul><br><h3> 变体模板或现代C ++中如何从任意数量的参数创建函数 </h3><br>  Douglas Gregor，JaakkoJärvi和Gary Powell在2004年提出了变量模板的想法，即 在采用C ++ 11标准之前7年，正式支持这些变量模板。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该标准包括其提案的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三版N2080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从一开始就创建了变量模板，以便程序员有机会从任意数量的参数中创建类型安全（可移植！）的函数。</font><font style="vertical-align: inherit;">另一个目标是简化对具有可变数量参数的类模板的支持，但是现在我们只在谈论可变函数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量模板为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ [C ++ 17 17.5.3]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带来了三个新概念</font><font style="vertical-align: inherit;">：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板参数包（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板参数包</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">） -是一个参数模板，而不是它是可以传送的任何（包括0）模板参数的数量;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一包函数参数（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function parameter pack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-因此，这是一个可以接受任何数量（包括0）数量的函数参数的函数参数；</font></font><br></li><li><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包的扩展</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><i><font style="vertical-align: inherit;">包扩展</font></i><font style="vertical-align: inherit;">）是唯一可以使用参数包完成的操作。</font></font><br></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { printf(format.c_str(), args...); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这</font></font><code>class ... Args</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是模板参数</font></font><code>Args ... args</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的包</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">是功能参数的包，并且</font></font><code>args...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是功能参数的包的扩展。</font></font></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在标准本身</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3 / 4]中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给出了在何处以及如何扩展参数包的完整列表</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在讨论变量函数时，可以这样说：</font></font><br><br><ul><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数参数包可以扩展为另一个函数的参数列表</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void bar(const std::string&amp; format, Args ... args) { foo&lt;Args...&gt;(format.c_str(), args...); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或到初始化列表</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { const auto list = {args...}; }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或到lambda捕获列表</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { auto lambda = [&amp;format, args...] () { printf(format.c_str(), args...); }; lambda(); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在卷积表达式中扩展另一个函数参数包</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; int foo(Args ... args) { return (0 + ... + args); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">卷积出现在C ++ 14中，可以是一元和二进制，也可以是左右。</font><font style="vertical-align: inherit;">与往常一样，最完整的描述在Standard </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 8.1.6]中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种类型的参数包都可以扩展为sizeof ...运算符</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(Args ... args) { const auto size1 = sizeof...(Args); const auto size2 = sizeof...(args); }</code> </pre> </div></div><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在公开的明确省略号包需要支持各种模板（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图案</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）公开并避免这种不确定性。</font></font><br><br><div class="spoiler">  <b class="spoiler_title">举个例子</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo() { using OneTuple = std::tuple&lt;std::tuple&lt;Args&gt;...&gt;; using NestTuple = std::tuple&lt;std::tuple&lt;Args...&gt;&gt;; }</code> </pre> <br> <code>OneTuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-得出一个单例元组（</font></font><code>std:tuple&lt;std::tuple&lt;int&gt;&gt;, std::tuple&lt;double&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><code>NestTuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的元组</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">-一个包含一个元素的元组-另一个元组（</font></font><code>std::tuple&lt;std::tuple&lt;int, double&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用变量模板的printf的示例实现 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如我已经提到的，还创建了变量模板，以直接替代C的变量函数。这些模板的作者自己提出了非常简单但类型安全的版本-C </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中最早的变量函数之一。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板上的printf</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void printf(const char* s) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') throw std::runtime_error("invalid format string: missing arguments"); std::cout &lt;&lt; *s++; } } template &lt;typename T, typename ... Args&gt; void printf(const char* s, T value, Args ... args) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') { std::cout &lt;&lt; value; return printf(++s, args...); } std::cout &lt;&lt; *s++; } throw std::runtime_error("extra arguments provided to printf"); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我怀疑，然后通过递归调用重载函数，出现了这种可变参数枚举的模式。</font><font style="vertical-align: inherit;">但是我仍然更喜欢没有递归的选项。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板上的printf，没有递归</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;typename ... Args&gt; void printf(const std::string&amp; fmt, const Args&amp; ... args) { size_t fmtIndex = 0; size_t placeHolders = 0; auto printFmt = [&amp;fmt, &amp;fmtIndex, &amp;placeHolders]() { for (; fmtIndex &lt; fmt.size(); ++fmtIndex) { if (fmt[fmtIndex] != '%') std::cout &lt;&lt; fmt[fmtIndex]; else if (++fmtIndex &lt; fmt.size()) { if (fmt[fmtIndex] == '%') std::cout &lt;&lt; '%'; else { ++fmtIndex; ++placeHolders; break; } } } }; ((printFmt(), std::cout &lt;&lt; args), ..., (printFmt())); if (placeHolders &lt; sizeof...(args)) throw std::runtime_error("extra arguments provided to printf"); if (placeHolders &gt; sizeof...(args)) throw std::runtime_error("invalid format string: missing arguments"); }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 重载分辨率和可变模板功能 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在解析时，这些可变函数在其他方面被认为是标准的和最不专门的。</font><font style="vertical-align: inherit;">但是，没有参数的调用没有问题。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过载示例</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } template &lt;class T&gt; void foo(T) { std::cout &lt;&lt; "Template function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); foo(2.0); foo(1, 2); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动结果</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function without arguments Template function Template variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决重载后，变量模板函数只能绕过变量C函数（尽管为什么要混合它们？）。</font><font style="vertical-align: inherit;">除了-当然！</font><font style="vertical-align: inherit;">-不带参数的通话。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不带参数的通话</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动结果</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Template variadic function C variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与省略号进行比较-相应的功能丢失，与省略号进行比较-模板功能低于非模板功能。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 快速了解可变模板功能的速度 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2008年，卢瓦克乔利（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">卢瓦克乔利</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）提交给标准化委员会C ++的提案</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2772</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这在实践中已经表明，模板函数的变化较慢类似的功能，这是初始化列表的参数（</font></font><code>std::initializer_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">尽管这与作者本人的理论依据相抵触，但Joli提出实施它</font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是借助于初始化列表而不是变量模板。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但在2009年，已经出现了反驳。</font><font style="vertical-align: inherit;">在Joli的测试中，发现了一个“严重错误”（甚至对他本人而言）。</font><font style="vertical-align: inherit;">新测试（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）表明变量模板功能仍然更快，有时甚至更快。</font><font style="vertical-align: inherit;">这并不奇怪，因为 </font><font style="vertical-align: inherit;">初始化列表会复制其元素，对于变量模板，您可以在编译阶段进行大量操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然而，在C ++ 11和随后的标准</font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是通常的模板功能，即通过初始化列表发送的参数的任意数量。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 简要总结和结论 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 因此，C样式变量函数： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们不知道他们的论据数目或类型。</font><font style="vertical-align: inherit;">开发人员必须使用该函数的部分参数，才能传递有关其余参数的信息。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐式提高未命名参数（和姓氏）的类型。</font><font style="vertical-align: inherit;">如果您忘记了它，则会得到模糊的行为。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 它们保持与纯C的向后兼容性，因此不支持通过引用传递参数。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在C ++ 11之前，不支持</font><font style="vertical-align: inherit;">非</font></font><abbr title="普通的旧数据"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的</font><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">，并且由于C ++ 11对非平凡类型的支持由编译器自行决定。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码的行为取决于编译器及其版本。 </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量函数的唯一允许用途是与C ++代码中的C API交互。</font><font style="vertical-align: inherit;">对于其他所有东西，包括</font></font><abbr title="替换失败不是错误"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，都有可变的模板函数，它们可以：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 了解他们所有参数的数量和类型。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 输入safe，请勿更改其参数的类型。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 它们支持以任何形式传递参数-按值，按指针，按引用，通过通用链接。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 像任何其他C ++函数一样，对参数类型没有任何限制。 </font></font><br></li><li>        (   C ),   . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与C样式对应函数相比，可变模板函数可能更冗长，有时甚至需要使用自己的重载非模板版本（递归参数遍历）。</font><font style="vertical-align: inherit;">他们很难阅读和写作。</font><font style="vertical-align: inherit;">但是，由于没有列出的缺点和存在的优点，所有这些费用都可以得到补偿。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好了，结论很简单：仅由于向后兼容，C风格的变量函数仍保留在C ++中，并且它们提供了广泛的选择。</font><font style="vertical-align: inherit;">在现代C ++中，强烈建议不要编写新的，如果可能的话，不要使用现有的可变C函数。</font><font style="vertical-align: inherit;">可变模板函数属于现代C ++领域，并且更加安全。</font><font style="vertical-align: inherit;">使用它们。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 文献资料 </font></font></h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PJ Plauger，标准C库</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan和Dennis M. Ritchie，C编程语言，第一版</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan和Dennis M. Ritchie，《 C编程语言》第二版</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准C11，草案N1570</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 98标准</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 03标准</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11标准，草案N3337</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准C ++ 14，草案N4296</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17标准，草案N4659</font></font></a> <br></li></ul><br><h3> 聚苯乙烯 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很容易找到和下载网上提到的书籍的电子版本。</font><font style="vertical-align: inherit;">但是我不确定这是否合法，因此我不提供链接。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430064/">https://habr.com/ru/post/zh-CN430064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430052/index.html">为什么对硬件开发人员进行质量监管很重要</a></li>
<li><a href="../zh-CN430054/index.html">莫斯科HolyJS 2018：免费在线广播，派对和科技说唱</a></li>
<li><a href="../zh-CN430058/index.html">液压管路中的波动过程。 基础知识</a></li>
<li><a href="../zh-CN430060/index.html">Hackspace，Denis Perevalov，Anastasia Krokhaleva-编程的魔力</a></li>
<li><a href="../zh-CN430062/index.html">微服务。 Java示例的开发和重构模式</a></li>
<li><a href="../zh-CN430068/index.html">的顺序</a></li>
<li><a href="../zh-CN430070/index.html">堆栈和队列是两个错误的范例，对此可以做什么</a></li>
<li><a href="../zh-CN430072/index.html">服务器端Swift被低估：Paul Hudson访谈</a></li>
<li><a href="../zh-CN430074/index.html">我如何差点感染试图出售靴子的病毒</a></li>
<li><a href="../zh-CN430076/index.html">免费转播DotNext 2018莫斯科</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>