<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏼 🤷🏾 👨🏻‍🏭 Gambar Docker juga dapat dibangun di werf menggunakan Dockerfile biasa ✌🏼 🏇🏼 💨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lebih baik terlambat daripada tidak sama sekali. Atau bagaimana kami hampir membuat kesalahan serius, tidak memiliki dukungan Dockerfiles biasa untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gambar Docker juga dapat dibangun di werf menggunakan Dockerfile biasa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/463613/">  <i>Lebih baik terlambat daripada tidak sama sekali.</i>  <i>Atau bagaimana kami hampir membuat kesalahan serius, tidak memiliki dukungan Dockerfiles biasa untuk membangun gambar aplikasi.</i> <br><br><img src="https://habrastorage.org/webt/on/ut/ju/onutju4gqnldsccyq0bbeywfnng.png"><br><br>  Kami akan berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> , sebuah utilitas GitOps yang terintegrasi dengan sistem CI / CD dan menyediakan kontrol atas seluruh siklus hidup aplikasi, memungkinkan Anda untuk: <br><br><ul><li>  Kumpulkan dan publikasikan gambar </li><li>  Menyebarkan aplikasi di Kubernetes </li><li>  Hapus gambar yang tidak digunakan menggunakan kebijakan khusus. </li></ul><a name="habracut"></a><br>  Filosofi dari proyek ini adalah untuk merakit alat tingkat rendah ke dalam satu sistem terpadu yang memberi para insinyur DevOps kendali atas aplikasi.  Jika memungkinkan, utilitas yang ada (seperti Helm dan Docker) harus dilibatkan.  Jika tidak ada solusi untuk masalah, kami dapat membuat dan memelihara semua yang diperlukan untuk ini. <br><br><h2>  Latar Belakang: Kolektor Gambar Anda </h2><br>  Inilah yang terjadi dengan kolektor gambar di werf: kami tidak memiliki Dockerfile biasa.  Jika Anda dengan cepat terjun ke dalam sejarah proyek, maka masalah ini memanifestasikan dirinya dalam versi pertama werf (kemudian masih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dikenal sebagai dapp</a> ). <br><br>  Membuat alat untuk membangun aplikasi dalam gambar Docker, kami segera menyadari bahwa Dockerfile tidak cocok untuk beberapa tugas yang sangat spesifik: <br><br><ol><li>  Kebutuhan untuk membangun aplikasi web kecil yang khas sesuai dengan skema standar berikut: <br><ul><li>  Instal dependensi aplikasi di seluruh sistem </li><li>  instal bundel pustaka dependensi aplikasi, </li><li>  mengumpulkan aset </li><li>  dan yang paling penting, perbarui kode dalam gambar dengan cepat dan efisien. </li></ul></li><li>  Ketika perubahan dibuat untuk memproyeksikan file, pembangun harus dengan cepat membuat layer baru dengan menerapkan patch ke file yang dimodifikasi. </li><li>  Jika file tertentu telah berubah, maka perlu untuk membangun kembali tahap dependen yang sesuai. </li></ol><br>  Hari ini di pengumpul kami ada banyak kemungkinan lain, tetapi keinginan dan dorongan awal adalah mereka. <br><br>  Secara umum, tanpa berpikir dua kali, kami mempersenjatai diri dengan bahasa pemrograman yang digunakan <i>(lihat di bawah)</i> dan mulai bekerja - terapkan <b>DSL kami sendiri</b> !  Sesuai dengan tugas, itu dimaksudkan untuk menggambarkan proses perakitan secara bertahap dan untuk menentukan dependensi dari tahapan ini pada file.  Dan dilengkapi oleh <b>kolektornya sendiri</b> , yang mengubah DSL menjadi tujuan akhir - gambar rakitan.  Pada awalnya, DSL berada di Ruby, dan ketika kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beralih ke Golang</a> , konfigurasi kolektor kami mulai dijelaskan dalam file YAML. <br><br><img src="https://habrastorage.org/webt/z5/ji/sr/z5jisrzzlmuxu5r3gct98dovmxq.png"><br>  <i>Konfigurasi lama untuk dapp di Ruby</i> <br><br><img src="https://habrastorage.org/webt/wc/h1/jj/wch1jjegx2n6zxtxh3-ky9ouedu.png"><br>  <i>Konfigurasi saat ini untuk werf di YAML</i> <br><br>  Mekanisme kolektor juga berubah seiring waktu.  Pertama, kami hanya membuat Dockerfile sementara sementara dari konfigurasi kami dengan cepat, dan kemudian mulai menjalankan instruksi perakitan dalam wadah sementara dan membuat komit. <br><br>  <i><b>NB</b> : Saat ini, kolektor kami, yang bekerja dengan konfigurasi (dalam YAML) dan disebut sebagai kolektor-Stapel, telah berkembang menjadi alat yang cukup kuat.</i>  <i>Penjelasan terperincinya layak untuk artikel terpisah, dan detail utama dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .</i> <br><br><h2>  Kesadaran masalah </h2><br>  Tetapi kami menyadari, dan tidak segera, bahwa kami melakukan satu kesalahan: kami tidak menambahkan kemampuan <b>untuk mengumpulkan gambar melalui Dockerfile standar</b> dan mengintegrasikannya ke dalam infrastruktur yang sama untuk manajemen aplikasi terintegrasi (mis., Mengumpulkan gambar, menyebarkan dan membersihkannya).  Bagaimana Anda bisa membuat alat penyebaran di Kubernetes dan tidak mengimplementasikan dukungan Dockerfile, mis.  cara standar untuk menggambarkan gambar untuk sebagian besar proyek? .. <br><br>  Alih-alih menjawab pertanyaan seperti itu, kami menawarkan solusi.  Bagaimana jika Anda sudah memiliki Dockerfile (atau satu set Dockerfiles) dan ingin menggunakan werf? <br><br>  <i><b>NB</b> : Ngomong-ngomong, mengapa Anda bahkan ingin menggunakan werf?</i>  <i>Fitur utama adalah sebagai berikut:</i> <br><br><ul><li>  <i>siklus manajemen aplikasi lengkap termasuk pembersihan gambar;</i> </li><li>  <i>kemampuan untuk mengontrol perakitan beberapa gambar dari satu konfigurasi;</i> </li><li>  <i>Peningkatan proses penyebaran bagan Helm yang kompatibel.</i> </li></ul><br>  <i>Daftar yang lebih lengkap dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman proyek</a> .</i> <br><br>  Jadi, jika sebelumnya kami menyarankan untuk menulis ulang Dockerfile ke konfigurasi kami, sekarang sekarang kami akan dengan senang mengatakan: "Biarkan kami membangun Dockerfile Anda!" <br><br><h2>  Bagaimana cara menggunakan </h2><br>  Implementasi penuh fitur ini muncul dalam <a href="">rilis werf v1.0.3-beta.1</a> .  Prinsip umum sederhana: pengguna menentukan path ke Dockerfile yang ada di konfigurasi werf, dan kemudian menjalankan <code>werf build</code> ... <code>werf build</code> dan hanya itu - werf akan mengumpulkan gambar.  Pertimbangkan contoh abstrak. <br><br>  <code>Dockerfile</code> berikut di root proyek: <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 RUN echo Building ...</code> </pre> <br>  Dan nyatakan <code>werf.yaml</code> yang menggunakan <code>Dockerfile</code> ini: <br><br><pre> <code class="plaintext hljs">configVersion: 1 project: dockerfile-example --- image: ~ dockerfile: ./Dockerfile</code> </pre> <br>  Itu saja!  Tetap <b>menjalankan <code>werf build</code></b> : <br><br><img src="https://habrastorage.org/webt/uk/jm/7j/ukjm7j_4aryw5zgbugqusuxvdue.png"><br><br>  Selain itu, Anda dapat mendeklarasikan <code>werf.yaml</code> berikut untuk membuat beberapa gambar dari Dockerfiles yang berbeda sekaligus: <br><br><pre> <code class="plaintext hljs">configVersion: 1 project: dockerfile-example --- image: backend dockerfile: ./dockerfiles/Dockerfile-backend --- image: frontend dockerfile: ./dockerfiles/Dockerfile-frontend</code> </pre> <br>  Akhirnya, ia juga mendukung transfer parameter build tambahan - seperti <code>--build-arg</code> dan <code>--add-host</code> - melalui konfigurasi werf.  Deskripsi lengkap tentang konfigurasi gambar Dockerfile tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman dokumentasi</a> . <br><br><h2>  Bagaimana cara kerjanya? </h2><br>  Selama proses pembuatan, cache lapisan lokal standar dalam fungsi Docker.  Namun, yang penting, werf juga <b>mengintegrasikan konfigurasi Dockerfile ke dalam infrastrukturnya</b> .  Apa artinya ini? <br><br><ol><li>  Setiap gambar yang dikumpulkan dari Dockerfile terdiri dari satu tahap yang disebut <code>dockerfile</code> (lebih lanjut tentang tahap apa dalam werf, Anda dapat membaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). </li><li>  Untuk tahap, <code>dockerfile</code> tidak menghitung tanda tangan, yang tergantung pada isi konfigurasi Dockerfile.  Ketika konfigurasi Dockerfile diubah, tanda tangan tahap <code>dockerfile</code> dan tidak memulai pembangunan kembali tahap ini dengan konfigurasi Dockerfile baru.  Jika tanda tangan tidak berubah, maka werf mengambil gambar dari cache <i>(detail lebih lanjut tentang penggunaan tanda tangan di werf dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan ini</a> )</i> . </li><li>  Selanjutnya, gambar yang dikumpulkan dapat dipublikasikan <code>werf publish</code> (atau <code>werf build-and-publish</code> ) dan digunakan untuk penyebaran di Kubernetes.  Gambar yang diterbitkan dalam Docker Registry akan dibersihkan dengan pembersih werf standar, yaitu  itu akan secara otomatis membersihkan gambar lama (lebih tua dari N hari), gambar yang terkait dengan cabang Git yang tidak ada, dan kebijakan lainnya. </li></ol><br>  Anda dapat mempelajari lebih lanjut tentang poin-poin yang dijelaskan di sini dari dokumentasi: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proses penerbitan</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Integrasi dengan proses penyebaran di Kubernetes</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proses pembersihan</a> . </li></ul><br><h2>  Catatan dan Tindakan Pencegahan </h2><br><h3>  1. URL eksternal di ADD tidak didukung </h3><br>  Menggunakan URL eksternal dalam arahan <code>ADD</code> saat ini tidak didukung.  Werf tidak akan memulai pembangunan kembali ketika sumber daya berubah ke URL yang ditentukan.  Segera direncanakan untuk menambahkan fitur ini. <br><br><h3>  2. Anda tidak dapat menambahkan .git ke gambar </h3><br>  Secara umum, menambahkan direktori <code>.git</code> ke gambar adalah praktik buruk yang <s>keji</s> , dan inilah alasannya: <br><br><ol><li>  Jika <code>.git</code> tetap di gambar akhir, ini melanggar prinsip-prinsip aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">12 faktor</a> : karena gambar akhir harus dikaitkan dengan satu komit, seharusnya tidak mungkin untuk melakukan <code>git checkout</code> komit yang sewenang-wenang. </li><li>  <code>.git</code> meningkatkan ukuran gambar (repositori mungkin besar karena fakta bahwa file-file besar pernah ditambahkan ke dalamnya dan kemudian dihapus).  Ukuran pohon-kerja, yang hanya dikaitkan dengan komit tertentu, tidak akan bergantung pada riwayat operasi di Git.  Pada saat yang sama, menambahkan dan kemudian menghapus <code>.git</code> dari gambar terakhir tidak akan berfungsi: gambar masih akan mendapatkan lapisan tambahan - ini adalah cara kerja Docker. </li><li>  Docker dapat memulai pembangunan kembali yang tidak perlu, bahkan jika komit yang sama sedang dibangun, tetapi dari pohon kerja yang berbeda.  Misalnya, GitLab membuat direktori kloning terpisah di <code>/home/gitlab-runner/builds/HASH/[0-N]/yourproject</code> ketika perakitan paralel diaktifkan.  Rekondisi tambahan akan disebabkan oleh fakta bahwa direktori <code>.git</code> berbeda dalam versi kloning berbeda dari repositori yang sama, bahkan jika komit yang sama dikumpulkan. </li></ol><br>  Poin terakhir memiliki konsekuensi ketika menggunakan werf.  Jika mengharuskan cache yang dikumpulkan hadir ketika perintah tertentu dijalankan (misalnya, <code>werf deploy</code> ).  Selama operasi perintah tersebut, werf menghitung tanda tangan panggung untuk gambar yang ditentukan dalam <code>werf.yaml</code> , dan mereka harus berada dalam cache rakitan - jika tidak tim tidak akan dapat terus bekerja.  Jika tanda tangan tahap akan bergantung pada isi <code>.git</code> , maka kita mendapatkan cache yang tidak stabil untuk perubahan file yang tidak relevan, dan werf tidak akan dapat memaafkan pengawasan seperti itu (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> untuk lebih jelasnya) <br><br>  Secara umum, <b>menambahkan hanya file-file tertentu yang diperlukan</b> melalui instruksi <code>ADD</code> dalam hal apa pun meningkatkan efisiensi dan keandalan <code>Dockerfile</code> ditulis, dan juga meningkatkan stabilitas cache yang disusun oleh <code>Dockerfile</code> ini terhadap perubahan yang tidak relevan dalam Git. <br><br><h2>  Ringkasan </h2><br>  Cara awal kami menulis kompiler kami sendiri untuk kebutuhan tertentu adalah sulit, jujur ​​dan langsung: daripada menggunakan kruk di atas Dockerfile standar, kami menulis solusi kami sendiri dengan sintaks khusus.  Dan ini memberikan keuntungannya: pembangun-Stapel berupaya dengan tugasnya dengan sempurna. <br><br>  Namun, dalam proses penulisan kolektor kami sendiri, kami mengabaikan dukungan Dockerfiles yang ada.  Sekarang cacat ini telah diperbaiki, dan di masa depan kami berencana untuk mengembangkan dukungan Dockerfile bersama dengan kolektor Stapel kustom kami untuk perakitan terdistribusi dan untuk perakitan menggunakan Kubernet (mis. Perakitan pada pelari di dalam Kubernetes, seperti yang dilakukan di kaniko). <br><br>  Jadi jika Anda tiba-tiba memiliki beberapa Dockerfiles tergeletak di sekitar ... <b>cobalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a></b> ! <br><br><h2>  PS Daftar dokumentasi terkait </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan untuk memulai dengan cepat</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konfigurasi pembangun Dockerfile</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahapan perangkat di werf</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proses penerbitan gambar</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Integrasi dengan proses penyebaran di Kubernetes</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proses pembersihan</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stapel-builder sebagai alternatif dari Dockerfile</a> . </li></ul><br>  Baca juga di blog kami: “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf adalah alat CI / CD kami di Kubernetes (laporan ulasan dan video)</a> .” </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463613/">https://habr.com/ru/post/id463613/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463601/index.html">Pisahkan metode logging di Java / logback</a></li>
<li><a href="../id463605/index.html">Intelektual teknis - dari luar angkasa</a></li>
<li><a href="../id463607/index.html">Alternatif bawaan redux dengan Bereaksi Konteks dan kait</a></li>
<li><a href="../id463609/index.html">Sistem rekomendasi untuk Directum Club. Bagian Satu, Kolaboratif</a></li>
<li><a href="../id463611/index.html">Plugin yang fantastis, vol. 2. Berlatih</a></li>
<li><a href="../id463617/index.html">Fitur pengujian MMO seluler</a></li>
<li><a href="../id463619/index.html">Bekerja dari jarak jauh: pengalaman kami</a></li>
<li><a href="../id463623/index.html">Kami dipilih dari hutan tes: kami sedang membangun jalan singkat dari perlengkapan ke pengujian</a></li>
<li><a href="../id463625/index.html">Pemantauan jaringan dan deteksi aktivitas jaringan abnormal menggunakan solusi Flowmon Networks</a></li>
<li><a href="../id463627/index.html">Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>