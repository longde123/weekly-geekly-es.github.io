<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò†Ô∏è üë®üèæ‚Äç‚öïÔ∏è üòú Entwicklung von Schnittstellenkarten auf Soil Xilinx Zynq 7000 f√ºr die Sprachaufzeichnung im analogen und digitalen Format ü§æüèΩ üåµ üÜó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir unsere Erfahrungen bei der Entwicklung von Schnittstellenkarten der Schnittstelleneinheit auf Basis des SoC ARM + FPGA Xi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung von Schnittstellenkarten auf Soil Xilinx Zynq 7000 f√ºr die Sprachaufzeichnung im analogen und digitalen Format</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415435/"><img src="https://habrastorage.org/webt/rg/2_/55/rg2_55mpm_gc8ip2vlemo9tel9k.jpeg"><br><br>  In diesem Artikel werden wir unsere Erfahrungen bei der Entwicklung von Schnittstellenkarten der Schnittstelleneinheit auf Basis des SoC ARM + FPGA Xilinx Zynq 7000 teilen. Die Karten wurden f√ºr die Aufzeichnung von Sprachsignalen im analogen und digitalen PRI / BRI-Format (ISDN, E1 / T1) entwickelt.  Das endg√ºltige Ger√§t selbst wird zur Aufzeichnung von Verhandlungen in der Zivilluftfahrt verwendet. <br><a name="habracut"></a><br><h2>  Eisen: Auswahl der Ger√§tehardwareplattform </h2><br>  Die Wahl der Hardwareplattform wurde durch die Unterst√ºtzung von PRI / BRI-Protokollen bestimmt, die nur auf der FPGA-Seite implementiert werden k√∂nnen.  Mikrocontroller (MCUs) und Mikroprozessoren (MPUs) passten nicht. <br><br>  Man k√∂nnte zwei L√∂sungen f√ºr dieses Problem w√§hlen: <br><br><ol><li>  Microblaze IP-Kernsynthese </li><li>  SoC Zynq-7000. </li></ol><br>  Wir haben uns f√ºr ein System auf einem Zynq 7000-Chip (SoC) entschieden, weil  Es ist einfacher, Softwareanwendungen zu schreiben und bietet mehr Funktionen f√ºr aktuelle und zuk√ºnftige Aufgaben. <br><br>  Insgesamt wurde im Rahmen des Projekts die folgende Liste von Eisen gesammelt: <br><br>  <b>1. Xilinx Zynq 7020</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mars-ZX3</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mars EB1</a> ) <br><img src="https://habrastorage.org/webt/ls/g9/4w/lsg94w0qj20bxkf5t8k2gzvzx1e.jpeg"><br>  <i>Enclustra Mars ZX3 SOM</i> <br><img src="https://habrastorage.org/webt/ft/z3/4t/ftz34tc8zkk-9gddjcx2atmufc8.jpeg"><br>  <i>Enclustra Mars EB1 Baseboard</i> <br><br>  <b>2. TI TLV320AIC34</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tlv320aic34evm-k</a> und USB-Motherboard). <br><br><img src="https://habrastorage.org/webt/3z/ls/g-/3zlsg-yry1k4e4qyqu1g-o0xt4a.jpeg"><br>  <i>Debugboard f√ºr tlv320aic34 (tlv320aic34evm-k)</i> <br><br><img src="https://habrastorage.org/webt/pb/mk/84/pbmk84mawx1rbpmqreghow9fjim.jpeg"><br>  <i>USB-MODEVM-Erweiterungskarte f√ºr tlv320aic34evm-k</i> <br><br>  <b>3. IDT82P2288 - PRI, XHFC-4SU - BRI-Mikroschaltungen,</b> es gab keine Debugging-Kits, daher haben wir den Grundstein nur als IP-Kern f√ºr Tests gelegt, und die Feuertaufe erfolgte direkt nach der Herstellung von Prototypenplatinen. <br><br><h2>  Arbeiten Sie mit dem System auf dem Xilinx Zynq 7000-Chip </h2><br><br><img src="https://habrastorage.org/webt/t5/2n/ka/t52nkauzukagn0mp_aruobwjigm.png"><br>  <i>Die interne Struktur des SoC Xilinx Zynq 7000</i> <br><br><img src="https://habrastorage.org/webt/u9/nn/nl/u9nnnlwp0nib8s4td2drrorqm54.png"><br>  <i>Schritte zum Generieren von Startdateien f√ºr Xilinx Zynq</i> <br><br>  Das Flashen / Herunterladen von ausf√ºhrbaren Dateien f√ºr Zynq unterscheidet sich vom √ºblichen Download f√ºr MPU.  Die √ºbliche Arbeit mit Cortex-A-Prozessoren ist das Laden von U-Boot, Kernel Linux und Rootfs.  Und auf Zynq erscheint Bitstream, die Firmware-Datei f√ºr FPGAs.  Der Bitstrom enth√§lt eine Beschreibung der Hardwarebl√∂cke auf dem FPGA und der internen Kommunikation mit dem Prozessor.  Diese Datei wird beim Systemstart geladen.  Auch auf der Linux-Seite gibt es einen Mechanismus, mit dem Sie den PL-Teil sofort w√§hrend des Betriebs flashen k√∂nnen. Ein solches Ger√§t hei√üt xdevcfg ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ZYNQ FPGA Manager seit 2018.1</a> ). <br><br><h2>  PRI / BRI-Schnittstellen </h2><br><img src="https://habrastorage.org/webt/om/zo/dr/omzodrzsfz9d5oqyo-ukvvsozve.jpeg"><br>  <i>Merkmale digitaler Netzwerke PRI / BRI</i> <br><br>  PRI (Primary Rate Interface) ist eine Standard-ISDN-Netzwerkschnittstelle, die die Disziplin des Verbindens von ISDN-Stationen mit Breitbandleitungen definiert, die lokale und zentrale Vermittlungsstellen oder Netzwerk-Switches verbinden. <br><br><img src="https://habrastorage.org/webt/_5/p0/5k/_5p05km2btytoe7ptkdrfuz_-8o.png"><br>  <i>Art des √ºbertragenen Rahmens f√ºr PRI</i> <br><br><img src="https://habrastorage.org/webt/rp/ux/hd/rpuxhdxujlk8c2cnxxgdga74-tk.png"><br>  <i>Ansicht des √ºbertragenen Rahmens f√ºr BRI</i> <br><br><img src="https://habrastorage.org/webt/-i/1c/90/-i1c90_mrzspj2jhrog9akk_u4g.png"><br>  <i>Die interne Struktur der PRI-Physik - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDT82P2288</a></i> <br><br><img src="https://habrastorage.org/webt/ca/iv/s5/caivs5jr2frxcu_xiign_my2db8.png"><br>  <i>Die interne Struktur der BRI-Physik - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XHFC-4SU</a></i> <br><br><h2>  Audio Codec TLV320AIC34 </h2><br>  Der vierkanalige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLV320AIC34-Audiocodec mit</a> geringem Stromverbrauch f√ºr tragbares Audio und Telefonie ist eine gute L√∂sung f√ºr die Verwendung in der analogen Telefonie. <br><br><img src="https://habrastorage.org/webt/7i/7g/lr/7i7glrlam_fmxm2inkwcgqinrl8.png"><br>  <i>Tlv320aic34 Einteiliger Audio-Codec enth√§lt zwei solche Funktionsbl√∂cke</i> <br><br>  Daten k√∂nnen √ºber die I2S-Schnittstelle sowie √ºber DSP, PCM und TDM √ºbertragen werden. <br><br>  I2S ist ein serieller Busschnittstellenstandard, der zum Anschlie√üen digitaler Audioger√§te verwendet wird und 3 Leiter, die von einem aktiven zu einem passiven Ger√§t wechseln, sowie 4 entsprechende Signale elektrisch darstellt: <br><br><ol><li>  Bittakt (BCLK). </li><li>  Taktsignalrahmen (nach Worten) Synchronisation (WCLK). </li><li>  Datensignal, das 2 zeitlich geteilte Kan√§le (DIN / DOUT) senden oder empfangen kann. </li></ol><br>  Die Kan√§le zum Empfangen und Senden von Daten sind unterteilt, dh es gibt einen separaten Kanal zum Empfangen von Daten und einen Kanal zum Senden.  Der Controller empf√§ngt die vom Audio-Codec √ºbertragenen Daten, aber auch das Gegenteil ist m√∂glich. <br><br><img src="https://habrastorage.org/webt/p5/op/th/p5opthpov06xstxalowbqz_emt8.png"><br>  <i>I2S-Frame, Funktionen der I2S-Schnittstelle</i> <br><br>  Nachdem wir alle Hardwarekomponenten ausgew√§hlt hatten, l√∂sten wir das Problem der Verbindung von Audio-Codec und Xilinx Zynq 7020. <br><br><h2>  Suchen Sie nach I2S-Kernen </h2><br>  Der wahrscheinlich schwierigste Moment bei der Arbeit mit dem Audiostream im Xilinx Zynq 7020 war, dass sich auf dem Prozessor dieses Systems im Grunde kein I2S-Bus auf dem Chip befindet, sodass ich den I2S-Kern finden musste.  Diese Aufgabe wurde durch die Bedingung erschwert, dass der IP-Core frei sein sollte. <br><br>  Wir haben uns f√ºr mehrere IP-Cores entschieden.  Gefunden f√ºr Bare-Metal-Core I2S <b>Digilent</b> .  Wir haben mehrere IP-Cores auf <b>OpenCores gefunden</b> und wahrscheinlich ist die beste Option f√ºr uns der IP-Core von <b>Analog Devices</b> .  Sie produzieren IP-Cores f√ºr ihre Ger√§te, f√ºr die FPGA / FPGA-Interaktion. <br><br>  Wir interessieren uns f√ºr den IP-Core namens <b>AXI-I2S-ADI.</b>  Analog Devices selbst bewirbt diese IP-Cores f√ºr seine Hardwareplattformen. <br><br>  Gesamtliste der Anwendungsf√§lle: <br><br><ol><li>  Bare Metal - IP-Core f√ºr I2S (Digilent ZYBO Audio) </li><li>  opencores.org </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AXI-I2S-ADI-Controller</a> (analoge Ger√§te) </li></ol><br><h3>  AXI-I2S-ADI IP Core </h3><br>  Der IP-Core selbst sieht folgenderma√üen aus: Er enth√§lt die Zeilen bclk, wclk, din, dout.  Es wird eine Verbindung zum DMA Xilinx Zynq 7000 hergestellt. In unserem Beispiel wird der DMA PS-Teil verwendet.  Der gesamte Datenaustausch erfolgt √ºber DMA.  DMA kann eine eigenst√§ndige Einheit oder ein integraler Bestandteil von PS SoC sein. <br><br>  Bei der Konfiguration dieses IP-Kernels ist es wichtig, nicht zu vergessen, die mclk-Master-Frequenz an tlv320aic34 selbst zu senden. Optional, wenn Sie das Debugging-Kit f√ºr tlv320aic34 verwenden - senden Sie eine externe Master-Frequenz. <br><br><img src="https://habrastorage.org/webt/i8/xn/z4/i8xnz4rijta_07gc1zgc2a8vfxc.png"><br>  <i>Funktionsbaustein mit angeschlossenem axi-i2s-adi</i> <br><br>  Nach dem Konfigurationsvorgang bestand die Aufgabe darin, die Funktionalit√§t unter Linux zu starten. <br><br><h2>  Starten und konfigurieren Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ger√§tebaum</a> f√ºr tlv320aic34 </h2><br>  I2c konfigurieren (tlv320aic34 ist auf dieser Schnittstelle konfiguriert): <br><br><pre><code class="cpp hljs">i2c0: i2c@e0004000 { ... tlv320aic3x: tlv320aic3x@<span class="hljs-number"><span class="hljs-number">18</span></span> { <span class="hljs-meta"><span class="hljs-meta">#sound-dai-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "ti,tlv320aic3x"; reg = &lt;0x18&gt;; gpio-reset = &lt;&amp;axi_gpio_0 0 0&gt;; ai3x-gpio-func = &lt;&amp;axi_gpio_0 1 0&gt;, /* AIC3X_GPIO1_FUNC_DISABLED */ &lt;&amp;axi_gpio_0 2 0&gt;; /* AIC3X_GPIO2_FUNC_DIGITAL_MIC_INPUT */ AVDD-supply = &lt;&amp;vmmc2&gt;; DRVDD-supply = &lt;&amp;vmmc2&gt;; IOVDD-supply = &lt;&amp;vmmc2&gt;; DVDD-supply = &lt;&amp;vmmc2&gt;; ai3x-micbias-vg = &lt;1&gt;; }; ... };</span></span></span></span></code> </pre> <br>  I2s konfigurieren (Audiodaten werden √ºber diese Schnittstelle √ºbertragen): <br><br><pre> <code class="cpp hljs">i2s_clk: i2s_clk { <span class="hljs-meta"><span class="hljs-meta">#clock-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "fixed-clock"; clock-frequency = &lt;11289600&gt;; clock-output-names = "i2s_clk"; }; axi_i2s_adi_0: axi_i2s_adi@43C00000 { compatible = "adi,axi-i2s-1.00.a"; reg = &lt;0x43C00000 0x1000&gt;; xlnx,bclk-pol = &lt;0x0&gt;; xlnx,dma-type = &lt;0x1&gt;; xlnx,has-rx = &lt;0x1&gt;; xlnx,has-tx = &lt;0x1&gt;; xlnx,lrclk-pol = &lt;0x0&gt;; xlnx,num-ch = &lt;0x1&gt;; xlnx,s-axi-min-size = &lt;0x000001FF&gt;; xlnx,slot-width = &lt;0x18&gt;; }; &amp;axi_i2s_adi_0 { #sound-dai-cells = &lt;0&gt;; compatible = "adi,axi-i2s-1.00.a"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;i2s_clk&gt;; clock-names = "axi", "ref"; dmas = &lt;&amp;dmac_s 0 &amp;dmac_s 1&gt;; dma-names = "tx", "rx"; };</span></span></span></span></code> </pre> <br>  Einstellen der Soundkarte im Ger√§tebaum (Audiokarten): <br><br><pre> <code class="cpp hljs"> sound { compatible = <span class="hljs-string"><span class="hljs-string">"simple-audio-card"</span></span>; simple-audio-card,name = <span class="hljs-string"><span class="hljs-string">"TLV320AIC34"</span></span>; simple-audio-card,format = <span class="hljs-string"><span class="hljs-string">"i2s"</span></span>; simple-audio-card,bitclock-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,frame-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,widgets = ... simple-audio-card,routing = ... dailink0_master: simple-audio-card,cpu { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;axi_i2s_adi_0&gt;; }; simple-audio-card,codec { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;tlv320aic3x&gt;; }; }; };</code> </pre> <br>  Nach all den Manipulationen zum Konfigurieren und Konfigurieren des Codecs im Ger√§tebaum unter Linux erschien die begehrte Audiokarte und wir konnten Musik h√∂ren (unser erster Musiktitel war Highway to Hell, AC / DC). <br><br>  Hier ist, was wir daf√ºr tun mussten: <br><br><ul><li>  Generierte die erforderliche Frequenz mit clk_wiz (Taktungsassistent) </li><li>  Richtig konfiguriertes DTS f√ºr tlv320aic34 </li><li>  Unterst√ºtzung f√ºr tlv320aic3x-Treiber hinzugef√ºgt </li><li>  Audiopakete zu buildroot hinzugef√ºgt, um Audiostreams abzuspielen (aplay, madplay usw.) </li></ul><br>  Bei der Entwicklung des Endger√§ts standen wir vor der Aufgabe, 4 tlv320aic34-Mikroschaltungen anzuschlie√üen.  Der oben beschriebene tlv320aic34-Chip enth√§lt 2 Bl√∂cke zum Arbeiten mit dem Audiostream. Jeder Block verf√ºgt √ºber eine eigene i2c-Leitung zum Konfigurieren und Einrichten von Audioparametern.  Ein Block kann jeweils nur vier Adressen haben. Es ist unm√∂glich, vier tlv320aic34-Mikroschaltungen an eine i2c-Schnittstelle anzuschlie√üen. Sie m√ºssen zwei i2c-Schnittstellen (8 unabh√§ngige Audiobl√∂cke) verwenden.  Wenn Sie mclk, blck, wclk, din / dout einzeln starten, m√ºssen Sie f√ºr jeden Block insgesamt 40 Signalleitungen hinzuf√ºgen, was aus Sicht der Schaltung f√ºr das von uns ausgew√§hlte som-Modul unm√∂glich und irrational ist, da Sie zus√§tzlich zu diesen Signalen viele andere Leitungen und anschlie√üen mussten Schnittstellen. <br><br>  Aus diesem Grund haben wir beschlossen, die Audiokarte in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TDM-Modus</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schalten</a> , in dem alle mclk-, bclk-, din- und dout-Leitungen kombiniert werden, wodurch sich die Gesamtzahl der Kommunikationsleitungen verringert.  Diese Entscheidung wirkte sich auf den Betrieb von axi-i2s-adi aus, da der IP-Core selbst im Master-Modus arbeitete.  Diese √Ñnderung erlaubte es uns auch nicht, unseren IP-Core im TDM-Modus zu verwenden, und eine willensstarke Entscheidung, die Verwendung des ausgew√§hlten IP-Core aufzugeben.  Ich musste einen IP-Kernel schreiben, um den i2s-Verkehr abzuh√∂ren und an dma zu senden. Mit dieser L√∂sung konnten wir eine gemeinsame Schnittstelle f√ºr den Empfang von Daten erstellen, die nicht vom Kartentyp f√ºr die Aufzeichnung von Anrufen abh√§ngen (analoge und digitale Karten). <br><br>  Die anf√§ngliche Architektur zum Empfangen des Audiostreams und seiner Verarbeitung √ºber die i2s-Schnittstelle: <br><br><img src="https://habrastorage.org/webt/yn/24/2d/yn242d_8cm4kazs2ycwceevqqe8.jpeg"><br><br>  Die endg√ºltige Architektur f√ºr den Empfang des Audiostreams und seine Verarbeitung √ºber die i2s-Schnittstelle: <br><br><img src="https://habrastorage.org/webt/mz/py/dt/mzpydtgravupatvivp_zmpiitig.jpeg"><br><br>  Architektur des Empfangs eines PRI-Streams und seiner Verarbeitung: <br><br><img src="https://habrastorage.org/webt/qx/ee/7w/qxee7wt1mdazgm0tu0eukbm5rmy.jpeg"><br><br>  Architektur des Empfangs und der Verarbeitung von BRI-Streams: <br><br><img src="https://habrastorage.org/webt/wd/uf/ny/wdufnykenpfxgwyhrnr3x6ep2kg.jpeg"><br><br><h2>  Axi dma </h2><br>  Dies ist ein wichtiges Element des Datensynchronisationssystems f√ºr dma. <br><br><img src="https://habrastorage.org/webt/v7/fx/pk/v7fxpk_3eemrqnlmy3iejsjrup4.png"><br>  <i>AXI DMA-Konfigurationsfenster in Xilinx Vivado</i> <br><br>  Auf dem Druckbildschirm wird der AXI DMA-Block selbst angezeigt.  Es hat viele Parameter.  Sie k√∂nnen dem Bus konfigurieren, wie viele Daten √ºbertragen werden sollen.  Daten k√∂nnen ausgerichtet oder in einem beliebigen Format sein.  Eine detaillierte Beschreibung der Funktionsweise und Interaktion mit Axi Dma ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der technischen Dokumentation beschrieben</a> (von Version zu Version werden Ungenauigkeiten in der Beschreibung hinzugef√ºgt und korrigiert sowie IP-Kernel verfeinert). <br><br><h2>  √úberpr√ºfen Sie die Daten√ºbertragung √ºber die Testoptionen AXI DMA und AXI DMA </h2><br>  Bei der Entwicklung des Treibers haben wir uns entschlossen, Open Source zu finden und an unsere Aufgabe anzupassen.  Als Ergebnis haben wir die Quellen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Projekts ezdma ausgew√§hlt</a> (Wortspiel, gelesen als easy dma). <br><br>  Der n√§chste Schritt ist die Entwicklung eines Testtreibers. Dies war eine Vorbereitungsphase f√ºr den Moment, als ein IP-Core mit vorgefertigten Funktionen aus der FPGA-Entwicklungsabteilung zu uns kam (der beschriebene Entwicklungsprozess wurde von eingebetteten Programmierern gebildet).  Vor diesem Moment haben wir uns entschlossen, AXI DMA und AXI DATA FIFO zu verwenden und einen Loopback durchzuf√ºhren, um zuk√ºnftige Fehler zu vermeiden.  Wir haben das Senden und Empfangen von Daten geloopt und das Ergebnis unserer Arbeit und die Leistung unseres Fahrers √ºberpr√ºft.  Wir haben die Funktionalit√§t ein wenig angepasst, sie auf der Interaktionsoberfl√§che an unsere W√ºnsche angepasst und erneut die Funktionsf√§higkeit des Treibers und das ausgew√§hlte Interaktionsprinzip √ºberpr√ºft. <br><br><img src="https://habrastorage.org/webt/iw/si/uj/iwsiujsbv1tckuamu1lsjalzrao.png"><br>  <i>Look-Back-Block-Design, der erste Weg, um AXI DMA zu testen</i> <br><br>  Ein Beispiel f√ºr eine Beschreibung von DMA und ezdma in einem Ger√§tebaum: <br><br><pre> <code class="cpp hljs">/ { amba_pl: amba_pl { <span class="hljs-meta"><span class="hljs-meta">#address-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1&gt;; #size-cells = &lt;1&gt;; compatible = "simple-bus"; ranges ; axi_dma_1: axi_dma { #dma-cells = &lt;1&gt;; compatible = "xlnx,axi-dma-1.00.a"; reg = &lt;0x40400000 0x10000&gt;; clock-names = "s_axi_lite_aclk", "m_axi_sg_aclk", "m_axi_mm2s_aclk", "m_axi_s2mm_aclk"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 29 4 0 30 4&gt;; xlnx,addrwidth = &lt;0x20&gt;; xlnx,include-sg; dma-channel@40400000 { compatible = "xlnx,axi-dma-mm2s-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 29 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; dma-channel@40400030 { compatible = "xlnx,axi-dma-s2mm-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 30 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; }; ezdma0 { compatible = "ezdma"; dmas = &lt;&amp;axi_dma_1 0 &amp;axi_dma_1 1&gt;; dma-names = "loop_tx", "loop_rx"; // used when obtaining reference to above DMA core using dma_request_slave_channel() ezdma,dirs = &lt;2 1&gt;; // direction of DMA channel: 1 = RX (dev-&gt;cpu), 2 = TX (cpu-&gt;dev) }; ... }; };</span></span></span></span></code> </pre> <br>  Mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tool Device Tree Generator</a> k√∂nnen Sie problemlos dts / dtsi-Dateien erstellen. <br><br>  Der zweite Schritt in unserem Entwicklungsprozess ist die Erstellung eines Test-IP-Kernels zur √úberpr√ºfung der Treiberleistung. Nur dieses Mal sind die Daten aussagekr√§ftig, und die √úbertragung √ºber AXIS an AXI_DMA (wie in der endg√ºltigen Version des IP-Kernels). <br><br><img src="https://habrastorage.org/webt/uc/nc/iz/ucncizx2gwl3am9mxz5iursdy1q.png"><br>  <i>Workflow der AXIS-Schnittstelle</i> <br><br>  Wir implementieren zwei Varianten von IP-Kerneln zur Datengenerierung, die erste getestete Version wird √ºber verilog implementiert, die zweite - auf HLS (in diesem Zusammenhang erschien HLS unter dem Motto ‚Äûstylisch-mode-jugend‚Äú). <br><br>  Der Verilog-Datengenerator (und im Allgemeinen in den Sprachen der HDL-Familie - Verilog, VHDL usw.) ist eine Standardl√∂sung bei der Entwicklung von IP-Kernen dieses Typs.  Hier sind einige Codefragmente f√ºr den Zwischen-IP-Kernel: <br><br><pre> <code class="hljs sql">module GenCnt ( ‚Ä¶. assign HandsHake = m_axis_din_tready &amp; m_axis_dout_tvalid; always @(posedge Clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Rst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sIDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (smCnt) sIDLE: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sDATA; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sDATA: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cnt == cTopCnt - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sLAST; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... endmodule</code> </pre> <br>  Eine detailliertere Beschreibung ist nicht erforderlich, da dies eine typische Aufgabe eines FPGA-Designers ist. <br><br>  Ein interessanteres "Biest" ist hier HLS.  <b>Vivado HLS (High Level Synthesis)</b> ist die neue Xilinx CAD-Software zum Erstellen digitaler Ger√§te mit Hochsprachen wie OpenCL, C oder C ++. <br><br>  C / C ++ sind die Hauptsprachen f√ºr einen Embedded-Software-Ingenieur. Daher ist die L√∂sung eines Problems mit diesen Sprachen im Hinblick auf die Implementierung und vergleichende Analyse f√ºr zuk√ºnftige Projekte interessanter. <br><br>  Hier sind zwei kleine Beispiele f√ºr die Arbeit mit HLS.  Das erste Beispiel ist ein Datengenerator f√ºr AXI_DMA, das zweite Beispiel ist der Datenaustausch zwischen dem Prozessorteil und der programmierbaren Logik √ºber die Schnittstelle s_axilite. <br><br>  Der Datenaustausch √ºber die s_axilite-Schnittstelle (das zweite Beispiel) wurde so implementiert, dass jederzeit in procfs der geladene Bitstrom subtrahiert werden konnte und die Korrektheit der Arbeit durch Versionierung f√ºr den PL-Teil von SoC verfolgt werden konnte.  Hier erscheint ein sehr interessanter Punkt bei s_axilite: Vivado HLS generiert einen Treiber f√ºr Linux (der Treiber wiederum haben wir angepasst, um procfs zu verarbeiten, um die Vererbung des Schreibens zu bewahren).  Ein Beispiel f√ºr den generierten Code f√ºr Linux finden Sie unten (der Pfad zur Quelll√∂sung1 / impl / ip / drivers / name_xxx / src /). <br><br><img src="https://habrastorage.org/webt/ss/kd/rh/sskdrh3olokqp7miv9qm-ni1gnq.png"><br>  <i>Stufen der HLS-Synthese und der RTL-Codegenerierung</i> <br><br>  HLS-Datengenerator zur √úberpr√ºfung des Betriebs mit AXI_DMA: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ap_axi_sdata.h&gt; #include &lt;hls_stream.h&gt; #define SIZE_STREAM 1024 struct axis { int tdata; bool tlast; }; void data_generation(axis outStream[SIZE_STREAM]) { #pragma HLS INTERFACE axis port=outStream int i = 0; do{ outStream[i].tdata = i; outStream[i].tlast = (i == (SIZE_STREAM - 1)) ? 1 : 0; i++; }while( i &lt; SIZE_STREAM); }</span></span></span></span></code> </pre> <br>  Ein Beispiel f√ºr die Versionierung und den Typ der Schnittstellenkarte: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void info( int &amp;aVersion, int &amp;bSubVersion, int &amp;cTypeBoard, int version, int subVersion, int typeBoard ){ #pragma HLS INTERFACE s_axilite port=aVersion #pragma HLS INTERFACE s_axilite port=bSubVersion #pragma HLS INTERFACE s_axilite port=cTypeBoard #pragma HLS INTERFACE ap_ctrl_none port=return aVersion = version; bSubVersion = subVersion; cTypeBoard = typeBoard; }</span></span></span></span></code> </pre> <br>  Wie Sie bemerkt haben, ist es f√ºr die Entwicklung auf hls sehr wichtig, die Arbeit und Anwendung verschiedener Pragmas (HLS-Pragma) zu verstehen, da der Synthesevorgang direkt mit Pragmas verbunden ist. <br><br>  Generierter Treiber f√ºr s_axilite: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== #ifdef __linux__ /***************************** Include Files *********************************/ #include "xinfo.h" /***************** Macros (Inline Functions) Definitions *********************/ #define MAX_UIO_PATH_SIZE 256 #define MAX_UIO_NAME_SIZE 64 #define MAX_UIO_MAPS 5 #define UIO_INVALID_ADDR 0 /**************************** Type Definitions ******************************/ typedef struct { u32 addr; u32 size; } XInfo_uio_map; typedef struct { int uio_fd; int uio_num; char name[ MAX_UIO_NAME_SIZE ]; char version[ MAX_UIO_NAME_SIZE ]; XInfo_uio_map maps[ MAX_UIO_MAPS ]; } XInfo_uio_info; /***************** Variable Definitions **************************************/ static XInfo_uio_info uio_info; /************************** Function Implementation *************************/ static int line_from_file(char* filename, char* linebuf) { char* s; int i; FILE* fp = fopen(filename, "r"); if (!fp) return -1; s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp); fclose(fp); if (!s) return -2; for (i=0; (*s)&amp;&amp;(i&lt;MAX_UIO_NAME_SIZE); i++) { if (*s == '\n') *s = 0; s++; } return 0; } static int uio_info_read_name(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/name", info-&gt;uio_num); return line_from_file(file, info-&gt;name); } static int uio_info_read_version(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/version", info-&gt;uio_num); return line_from_file(file, info-&gt;version); } static int uio_info_read_map_addr(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; info-&gt;maps[n].addr = UIO_INVALID_ADDR; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/addr", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].addr); fclose(fp); if (ret &lt; 0) return -2; return 0; } static int uio_info_read_map_size(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/size", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].size); fclose(fp); if (ret &lt; 0) return -2; return 0; } int XInfo_Initialize(XInfo *InstancePtr, const char* InstanceName) { XInfo_uio_info *InfoPtr = &amp;uio_info; struct dirent **namelist; int i, n; char* s; char file[ MAX_UIO_PATH_SIZE ]; char name[ MAX_UIO_NAME_SIZE ]; int flag = 0; assert(InstancePtr != NULL); n = scandir("/sys/class/uio", &amp;namelist, 0, alphasort); if (n &lt; 0) return XST_DEVICE_NOT_FOUND; for (i = 0; i &lt; n; i++) { strcpy(file, "/sys/class/uio/"); strcat(file, namelist[i]-&gt;d_name); strcat(file, "/name"); if ((line_from_file(file, name) == 0) &amp;&amp; (strcmp(name, InstanceName) == 0)) { flag = 1; s = namelist[i]-&gt;d_name; s += 3; // "uio" InfoPtr-&gt;uio_num = atoi(s); break; } } if (flag == 0) return XST_DEVICE_NOT_FOUND; uio_info_read_name(InfoPtr); uio_info_read_version(InfoPtr); for (n = 0; n &lt; MAX_UIO_MAPS; ++n) { uio_info_read_map_addr(InfoPtr, n); uio_info_read_map_size(InfoPtr, n); } sprintf(file, "/dev/uio%d", InfoPtr-&gt;uio_num); if ((InfoPtr-&gt;uio_fd = open(file, O_RDWR)) &lt; 0) { return XST_OPEN_DEVICE_FAILED; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> slave interface 'Axilites' should be mapped to uioX/map0 InstancePtr-&gt;Axilites_BaseAddress = (u32)mmap(NULL, InfoPtr-&gt;maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr-&gt;uio_fd, 0 * getpagesize()); assert(InstancePtr-&gt;Axilites_BaseAddress); InstancePtr-&gt;IsReady = XIL_COMPONENT_IS_READY; return XST_SUCCESS; } int XInfo_Release(XInfo *InstancePtr) { XInfo_uio_info *InfoPtr = &amp;uio_info; assert(InstancePtr != NULL); assert(InstancePtr-&gt;IsReady == XIL_COMPONENT_IS_READY); munmap((void*)InstancePtr-&gt;Axilites_BaseAddress, InfoPtr-&gt;maps[0].size); close(InfoPtr-&gt;uio_fd); return XST_SUCCESS; } #endif</span></span></code> </pre> <br>  Eine wichtige Datei, die Ihnen den Speicherort von Variablen (Registern) im Adressraum angibt, ist die Datei x # your_name # _hw.h.  Sie k√∂nnen die Richtigkeit des geschriebenen IP-Kernels jederzeit mit dem devmem-Tool √ºberpr√ºfen. <br><br>  Der Inhalt dieser Datei: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== // AXILiteS // 0x00 : reserved // 0x04 : reserved // 0x08 : reserved // 0x0c : reserved // 0x10 : Data signal of aVersion // bit 31~0 - aVersion[31:0] (Read) // 0x14 : Control signal of aVersion // bit 0 - aVersion_ap_vld (Read/COR) // others - reserved // 0x18 : Data signal of bSubVersion // bit 31~0 - bSubVersion[31:0] (Read) // 0x1c : Control signal of bSubVersion // bit 0 - bSubVersion_ap_vld (Read/COR) // others - reserved // 0x20 : Data signal of cTypeBoard // bit 31~0 - cTypeBoard[31:0] (Read) // 0x24 : Control signal of cTypeBoard // bit 0 - cTypeBoard_ap_vld (Read/COR) // others - reserved // (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake) #define XINFO_AXILITES_ADDR_AVERSION_DATA 0x10 #define XINFO_AXILITES_BITS_AVERSION_DATA 32 #define XINFO_AXILITES_ADDR_AVERSION_CTRL 0x14 #define XINFO_AXILITES_ADDR_BSUBVERSION_DATA 0x18 #define XINFO_AXILITES_BITS_BSUBVERSION_DATA 32 #define XINFO_AXILITES_ADDR_BSUBVERSION_CTRL 0x1c #define XINFO_AXILITES_ADDR_CTYPEBOARD_DATA 0x20 #define XINFO_AXILITES_BITS_CTYPEBOARD_DATA 32 #define XINFO_AXILITES_ADDR_CTYPEBOARD_CTRL 0x24</span></span></code> </pre><br>  Diese Datei beschreibt die Adressen der Register, die Register entsprechen der Position der Argumente in der Funktion.  Nach der Synthese des Projekts k√∂nnen Sie sehen, wie das erstellte Projekt in Zyklen ausgef√ºhrt wird. <br><br><img src="https://habrastorage.org/webt/lj/jw/na/ljjwnalfpfgcsi4yindklhqvowe.png"><br>  <i>Projekt Beat Beispiel</i> <br><br>  Die Arbeit mit hls hat gezeigt, dass dieses Tool zur schnellen L√∂sung von Aufgaben geeignet ist, insbesondere zur L√∂sung mathematischer Probleme der Computer Vision, die in C ++ oder C leicht beschrieben werden k√∂nnen, sowie zur Erstellung kleiner IP-Kernel f√ºr Interaktionen und Austausch Informationen mit Standard-FPGA-Schnittstellen. <br><br>  Gleichzeitig ist HLS nicht f√ºr die Implementierung bestimmter Hardwareschnittstellen geeignet, beispielsweise in unserem Fall I2S, und der generierte RTL-Code nimmt auf dem FPGA mehr Platz ein als in Standard-HDL-Sprachen geschrieben. <br><br>  Der letzte Schritt beim Treiber-Test ist die Entwicklung eines I2S-Verkehrsgenerators.  Dieser IP-Core wiederholt die Funktionalit√§t fr√ºherer IP-Kernel, mit der Ausnahme, dass er inkrementelle Daten (Datenverkehr) generiert, die echten I2S-Daten im TDM-Modus entsprechen. <br><br><img src="https://habrastorage.org/webt/vc/81/xz/vc81xzbieylxtzhrp6lz-psikva.png"><br>  <i>Blockdesign f√ºr zuk√ºnftige benutzerdefinierte I2S-Kerntests und I2S-Verkehrsgenerator</i> <br><br>  Als Ergebnis haben wir die Ergebnisse von hls, axi dma und s_axilite erhalten und die Leistung unserer Software und Treiber √ºberpr√ºft. <br><br><h2>  Schlussfolgerungen </h2><br>  Wir haben es geschafft, die notwendigen Arten von Schnittstellenkarten sowie IP-Kernel f√ºr tdm, pri, bri zu entwickeln.  Wir haben den aktuellen Ansatz f√ºr die Entwicklung solcher Ger√§te erheblich verbessert und eine umfassende L√∂sung geschaffen, die mit √§hnlichen Schnittstellenkarten von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asterick</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patton</a> und anderen konkurrieren kann.  Der Vorteil unserer L√∂sung besteht darin, dass der Entwickler f√ºr die Daten√ºbertragung keine Zwischenverbindung zwischen PC und PCI ben√∂tigt, sondern die empfangenen Informationen direkt √ºber Ethernet √ºbertragen kann. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415435/">https://habr.com/ru/post/de415435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415423/index.html">Public Key-Infrastruktur: Zertifizierungsstelle basierend auf OpenSSL und SQLite3 Utility (Postcryptum)</a></li>
<li><a href="../de415427/index.html">Die ganze Wahrheit √ºber RTOS von Colin Walls. Artikel 4. Aufgaben, Kontextwechsel und Interrupts</a></li>
<li><a href="../de415429/index.html">Die ganze Wahrheit √ºber RTOS von Colin Walls. Artikel 5. Aufgabeninteraktion und Synchronisation</a></li>
<li><a href="../de415431/index.html">Hackathon-Ank√ºndigung SmartMail Hack 2: Call of Data</a></li>
<li><a href="../de415433/index.html">Verwalten von Ver√∂ffentlichungen zu GIS-Wohnungen und kommunalen Diensten - wir teilen Erfahrungen und k√§mpfen mit Intuition</a></li>
<li><a href="../de415437/index.html">Wie man ML in Prod rollt: Sechs Rechen, auf die wir getreten sind</a></li>
<li><a href="../de415439/index.html">Zwingt Sie die Unternehmenskommunikation dazu, Sie zu beenden oder in ein Projekt wie ein Spiel zu ziehen?</a></li>
<li><a href="../de415441/index.html">In den USA nehmen Ransomware-Angriffe auf Regierungsbeh√∂rden zu</a></li>
<li><a href="../de415443/index.html">MDG und ITMO University laden zur Summer School f√ºr maschinelles Lernen ein</a></li>
<li><a href="../de415445/index.html">Die Zusammenfassung der Ereignisse f√ºr HR-Experten im Bereich IT f√ºr Juli 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>