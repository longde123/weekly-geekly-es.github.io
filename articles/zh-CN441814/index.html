<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍇 🖖 🧒🏽 熵编码rANS或如何编写自己的存档器 🤾🏾 👰🏿 💇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="那些从事数据压缩或想要编写自己的存档器的人可能会对本文感兴趣。 

  

 这篇文章主要是用Fabian Giesen维护的博客资料撰写的。 

 引言 
 熵编码方法rANS（rangge + ANS）是FSE算法的同级算法，这是我之前写的 。 缩写ANS表示非对称数字系统 ，名称中的单词范围暗...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>熵编码rANS或如何编写自己的存档器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/441814/"> 那些从事数据压缩或想要编写自己的存档器的人可能会对本文感兴趣。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/jz/w8/xk/jzw8xkq1k6enudm8xozmna6m3ia.jpeg"></a> <br><br> 这篇文章主要是用Fabian Giesen维护的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客</a>资料撰写的。 <br><a name="habracut"></a><br><h2> 引言 </h2><br> 熵编码方法rANS（rangge + ANS）是FSE算法的同级算法，这是我之前<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">写的</a> 。 缩写ANS表示<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">非对称数字系统</a> ，名称中的单词范围暗示了这种方法与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区间编码</a>的相似之处。  rANS的作者是<a href="">Yarek Duda</a> 。 <br><br> 通过rANS方法，您可以以极高的速度获得几乎最佳的压缩效果。 在这种情况下，rANS并不比FSE差，这并不奇怪：这两种算法都基于共同的理论基础。 但是，rANS算法比FSE更易于实现。 <br><br> 首先，将有很长的“理论”部分，然后我们将尝试编写一个简单的存档器。 <br><br><h2> 方法说明 </h2><br> 该算法的操作由以下简单公式确定： <br><br>  <b>编码：</b> <code>C(s,x): x := (x / Fs) * M + Bs + (x % Fs)</code> <br>  <b>解码：</b> <code>D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> <br><br> 让我们详细分析它们。 <br><br> 编码函数<b>C（s，x）</b>接收要编码的字符<b>s</b> （使其为整数）和编码器<b>x</b>的当前状态（也是整数）。 <br><br>  <b>F <sub>s-</sub></b>符号频率<b>s</b> 。 上面的Fs除数是整数。 <br>  <b>M</b>是字母表中所有符号频率的总和（ <b>M =</b> ΣF <b><sub>s</sub></b> ）。 <br>  <b>在<sub>s中</sub></b> ，对应于编码字符的间隔的开始（在下图中）。 <br>  <b>x</b> ％ <b>Fs</b>是<b>x</b>除以<b>F <sub>s</sub></b>的余数。 <br><br> 工作原理与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">算术编码</a>相同：我们将段<b>[</b> 0， <b>M）</b>分成几部分，以使每个字符<b>s</b>对应于一个间隔，该间隔的大小等于字符<b>s</b>的频率。 在任何间隔中出现值<b>x％M</b>表示相应符号的编码。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6i/vl/ql/6ivlqldcqlkeuwsxu6fcypus39o.png"></div><br> 在编码开始时， <b>用</b>任意合适的值初始化<b>x</b> ，然后依次计算所有编码字符的函数<b>C（s，x）</b> 。 <br><br> 函数<b>C（s，x）的</b>每次计算都会增加<b>x</b>的值。 当它太大时，应该将数据转储到输出中： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt;= x_max) {   writeToStream(x % b); <span class="hljs-comment"><span class="hljs-comment">//     x /= b; //  x }</span></span></code> </pre> <br> 此步骤称为<i>重新规范化</i> 。 之后，您可以继续编码。 <br><br> 在代码上方，出现了新的常量： <b>x_max</b>和<b>b</b> 。 理论上，数字<b>M</b> ， <b>b</b>和<b>x_max</b>是通过某种关系关联的，但是实际上，如果将状态uint32用于状态<code>x</code>则使用以下值最有效： <br><br>  <b>M</b> = 2 ^ <b>k</b> ，其中<b>k</b> &lt;= 16 <br>  <b>b</b> = 2 ^ 16（uint32的一半大小） <br><br>  <b>M</b> = 2 ^ <b>k</b>的选择是由于在解码功能中存在被<b>M</b>除的事实，因此可以用按位运算来替换其余部分的除法。 <br><br>  <b>k</b>的值是从以下考虑因素中选择的： <b>k</b>值越大， <b>F <sub>s</sub></b>的精度越高，压缩效率越高。 在这种情况下，必须考虑到存储频率表的一些开销，因此使用<b>k</b>的最大值并不总是值得的。 <br><br>  <b>x_max</b>的值应确保不发生溢出。 基于编码函数，我们得到<b>x</b> &lt; <b>uint32_max</b> * <b>Fs</b> / <b>M</b>或略有不同的方式： <b>x_max</b> &lt;=（ <b>b</b> * <b>L</b> ）* <b>Fs</b> / <b>M</b> ，其中<b>L</b> &lt;= <b>uint32_max</b> / <b>b</b> 。 在实际代码中，该条件采用x / b&gt; = L / M * Fs的形式，以避免计算中的溢出。 <br><br> 选择<b>b</b> = 2 ^ 16（uint32大小的一半）的方式是，如果<b>x</b>超过<b>x_max</b> ，则除以<b>b便</b>足以继续工作。 结果， <code>while</code>将在第一次迭代后结束，这意味着可以将其替换为简单的<code>if</code> 。 <br><br> 结果，编码功能采用以下形式： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansState; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RANS_L = <span class="hljs-number"><span class="hljs-number">1u</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> k = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   constexpr uint32_t RANS_M = 1u &lt;&lt; k; // M = 2^k //   s void RansEnc(RansState&amp; x, uint32_t s, RansOutBuf&amp; out) {   assert(x &gt;= RANS_L); //        uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //   s   assert(Fs &gt; 0 &amp;&amp; Fs &lt;= RANS_M);     // renormalize   if ((x &gt;&gt; 16) &gt;= (RANS_L &gt;&gt; k) * Fs) { // x / b &gt;=  L / M * Fs       out.put( x &amp; 0xffff );       x &gt;&gt;= 16;   }   x = ((x / Fs) &lt;&lt; k) + Bs + (x % Fs); // C(s,x)     assert(x &gt;= RANS_L); //      }</span></span></code> </pre> <br> 在编码结束时，您必须保存<b>x</b>的值，因为解码将从该值开始。 是的，我们将从头到尾解码，即从最后一个编码字符到第一个字符进行解码。  （在有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FSE</a>的文章中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>对这一点进行了足够详细的解释。） <br><br> 我想再详细介绍一下编码公式的工作原理。 <br><br><pre> <code class="cpp hljs">x := (x / Fs) * M + Bs + (x % Fs)</code> </pre> <br> 在计算（ <code>x / Fs) * M</code> ，变量<b>x</b>包含<b>k个</b>最低有效位（请回想<b>M</b> = 2 ^ <b>k</b> ）。 加<code>+ Bs + (x % Fs)</code>本质上是从字符<b>s</b>的间隔开始向这些位写入某个值，因为<b>Bs</b>是间隔的开始，并且（x％Fs）是此间隔内的数字（间隔的大小为Fs）。 因此，在解码时，我们可以通过其落入的间隔（x％M）确定编码的字符。 <br><br>  <b>解码方式</b> <br><br> 让我们继续进行解码功能。 <br><br><pre> <code class="cpp hljs">D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> </pre> <br> 如上所述，所需字符<b>s</b>由除法<b>x</b> ％ <b>M</b>的余数确定<b>。</b> 值（x％M）下降的间隔是这样的字符。 <br><br> 之前，我们专门定义了M = 2 ^ k以简化解码功能。 它最终像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansDecode(RansState&amp; x, RansInBuf&amp; in) {   assert(x &gt;= RANS_L); <span class="hljs-comment"><span class="hljs-comment">//       uint32_t x_mod = x &amp; (RANS_M - 1); // = x % M   //  ,    x_mod,     assert(x_mod &lt; dct.size());   uint32_t s = dct[x_mod]; //     uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //    s   x = (x &gt;&gt; k) * Fs + x_mod - Bs;     // renormalize   if (x &lt; RANS_L) {       x = (x &lt;&lt; 16) | in.read16(); //  16    }     assert(x &gt;= RANS_L); //     return s; }</span></span></code> </pre> <br> 解码从在编码结束时获得的<b>x</b>开始。 为此，必须将其与编码数据一起保存。 <br><br> 在解码结束时，解码器<b>x</b>的状态应与编码完全相同。 通常，在每个步骤中<b>x</b>必须与相应的编码步骤完全相同。 这个事实在调试时很有帮助。 <br><br> 如您所见，由于没有除法运算，因此解码比编码更快。 <br><br> 解码功能中最困难的时刻是确定值下降的间隔（x％M）的方法。 <br><br> 最简单，最快的方法是使用大小为<b>M</b>的<b>sym []</b>表<b>。</b> 在这种情况下，我们得到的表大小与FSE算法中的表大小相同，不同之处在于，在rANS中，该表没有“混合”，字符是有序的，并且这样的表更易于构建。 <br><br> 这种方法的主要缺点是<b>符号</b>表的大小，它随着<b>k的</b>增加呈指数增长。 <br><br><h2> 别名方法 </h2><br> 发明了一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">别名方法</a>来更有效地确定间隔中的命中。 使用此方法，您可以使用小表格快速确定所需的间隔-根据字母中的字符数。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kv/v0/gu/kvv0guji6nfuxxr6mcjorxxsv9a.png"></div><br> 在这里可以找到冗长而冗长的解释： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">飞镖，骰子和硬币</a> 。 我将简要描述该方法的本质：我们采用最长间隔的一部分并将其附加到最短间隔，以便总大小恰好为<b>M</b> / <b>N</b> （其中<b>N</b>是字母中的字符数）。 事实证明，如果顺序执行此操作，则最终将得到<b>N</b>对大小为<b>M</b> / <b>N的</b>对<b>。</b> <br><br> 自然， <b>M</b>必须可以被<b>N</b>整除<b>。</b> 如果我们回想起我们有<b>M</b> = 2 ^ <b>k</b> ，那么字母表的大小原来也是2的幂。 这是没有问题的，因为您始终可以使用零频率的未使用字符将字母补充到所需的大小。 <br><br> 字符间隔被分成几部分的事实使编码过程复杂一点，但是却不多。 如果您还记得FSE，那么间隔通常会分布在整个范围内，好像是疯狂的混音器在处理它们，而没有任何效果=） <br><br> 确定所需的间隔并不困难：将<b>x</b>除以<b>N</b> ，然后归为一对。 接下来，我们将<b>x％N</b>除法的余数与成对线段之间的边界进行比较，并以一个间隔或另一个间隔落入。 <br><br><h2> 我们在实践中尝试 </h2><br> 我们将使用<a href="">完成示例</a>的代码。 <br><br> 我们从文件中获取数据进行压缩： <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> in_size; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* in_bytes = read_file(<span class="hljs-string"><span class="hljs-string">"book1"</span></span>, &amp;in_size);</code> </pre> <br>  <b>1.</b>首先，您需要确定<b>数据结构</b> 。 <br><br> 我们使用最简单的选项：我们将使用字母[0 ... 255]编码一个字节。 <br><br>  <b>2.</b>下一步是确定字母<b>字符</b>的<b>频率</b> ： <br><br>  （功能<code>stats.count_freqs</code> ） <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; in_size; i++) {   freqs[in_bytes[i]]++; }</code> </pre> <br>  <b>3.</b>因此，我们有符号频率，但是现在我们需要对其进行<b>归一化</b> ，即成比例地减小（或增大），以便使总数为M = 2 ^ k。 这看起来并不简单，所以我们使用现成的函数： <br><br><pre> <code class="plaintext hljs">stats.normalize_freqs(...);</code> </pre> <br> 顺便说一句，您需要确定<b>k</b>的值。 由于我们的字母由256个字符组成，因此<b>k</b>不应小于8。 首先，取最大值-16，然后再尝试其他值。 <br><br>  <b>4.</b>建立<b>别名表</b> ： <br><br><pre> <code class="cpp hljs">stats.make_alias_table();</code> </pre> <br>  <b>5.我们</b> <b>从头开始</b>编码，然后以正常顺序解码。 <br><br><pre> <code class="cpp hljs">RansState rans; <span class="hljs-comment"><span class="hljs-comment">//  rANS,    x RansEncInit(&amp;rans); //    uint8_t* ptr = out_buf + out_max_size; // *end* of output buffer for (size_t i = in_size; i &gt; 0; i--) { // NB: working in reverse!   int s = in_bytes[i - 1];   RansEncPutAlias(&amp;rans, &amp;ptr, &amp;stats, s, prob_bits); } //   .     . RansEncFlush(&amp;rans, &amp;ptr);</span></span></code> </pre> <br> 此外，通过引用的示例使用现成的统计信息对压缩数据进行解码。 在现实生活中，要进行解码，您需要保存一个频率表（统计信息）以及压缩数据。 在最简单的情况下，您将不得不在上面花费N * k位。 <br><br> 如上所述，让我们看看k的各种值的压缩结果（在代码中为<code>prob_bits</code> ），同时考虑到由于记录频率表而导致的大小增加： <br><br>  （ <i>原书1文件</i> <i>大小</i> ：768771） <br>  k = 16：435059 + 512 = 435571字节 <br>  k = <b>15</b> ：435078 + 480 = <b>435558</b>字节 <br>  k = 14：435113 + 448 = 435561字节 <br>  k = 13：435239 + 416 = 435655字节 <br>  k = 12：435603 + 384 = 435987字节 <br>  k = 11：436530 + 352 = 436882字节 <br>  k = 10：440895 + 320 = 441215字节 <br>  k = 9：453418 + 288 = 453706字节 <br>  k = 8：473126 + 256 = 473382字节 <br><br> 您会看到k越高，压缩效果越好。 但是在某个点（在k = 16处），频率表的开销开始超过增加精度的好处。 如果压缩较小的文件，则此效果将出现在较小的k上。 <br><br> 您还需要说几句有关“ interleaved rANS”的技巧，该技巧<a href="">在此示例中</a>另外实现。 这个想法是交替使用两个独立的状态变量可以更好地利用处理器并行性。 结果，解码甚至更快。 <br><br> 总之，我想指出的是所选的文件压缩方法太简单了。 它没有考虑数据的特征，这就是压缩远非最佳的原因。 如果仔细看一下输入，您会发现某些<i>字母组合</i>比其他<i>字母组合</i>更常见，而有些根本没有。 利用这一事实，可以显着改善压缩。 但这是另一篇文章的主题。 <br><br><h2> 后记 </h2><br> 当有许多经过时间考验的实用程序时，为什么还要编写自己的存档器？ 答案很简单：针对特定格式量身定制的存档器压缩效果更好。 <br><br> 在<b>Playrix上</b>开发游戏时，我们经常依靠减少构建大小的需求。 游戏不断发展，内容不断增长，而且空间有限。 <br><br> 再次<s>，</s>我们<s>渴望地</s>查看资源，我们意识到，鉴于文件的结构，某些文件的压缩比zip更好。 在实验过程中，我们设法显着减小了自己的动画格式的大小，并且图形文件的压缩也发生了一些变化。 <br><br> 在开发压缩算法时，诸如rANS或FSE之类的通用熵编码器是必不可少的工具。 它完全承担了编写位数最少的字符的任务，从而使开发人员可以专注于算法的主要细节。 而且它在编码和解码方面都非常快。 <br><br> 我希望本文能帮助您了解rANS并在您的项目中开始使用它。 <br><br><h2> 参考文献 </h2><br> 在这里，您可以看到rANS实施的工作示例（具有不同的优化选项）： <br><br> 法比安·吉森（Fabian Giesen）： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/rygorous/ryg_rans</a> <br><br> 您可以在Fabian的博客上（英语）阅读有趣的详细信息： <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rANS注释</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">具有静态概率分布的rANS</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在实践中</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441814/">https://habr.com/ru/post/zh-CN441814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441804/index.html">在哪里教孩子编程？</a></li>
<li><a href="../zh-CN441806/index.html">没有VPN的VPN或有关SSH非常规使用的故事</a></li>
<li><a href="../zh-CN441808/index.html">我们将于3月6日邀请您参加ElixirLangMoscow聚会＃9</a></li>
<li><a href="../zh-CN441810/index.html">用于微控制器的Eclipse（STM32）+ FreeRTOS Task Aware调试器</a></li>
<li><a href="../zh-CN441812/index.html">在Acronis上进行Meetup直播</a></li>
<li><a href="../zh-CN441816/index.html">法国当局因帮助客户避税而对瑞银银行处以40亿美元罚款</a></li>
<li><a href="../zh-CN441818/index.html">平衡网站性能。 第2部分：技术优化</a></li>
<li><a href="../zh-CN441820/index.html">蒸汽中的恐怖奉献-原因再次是小熊维尼，习近平和中国对政治色彩的愤怒</a></li>
<li><a href="../zh-CN441824/index.html">消防管理作为领导者工作的一部分</a></li>
<li><a href="../zh-CN441826/index.html">音频流媒体市场正在发生什么：讨论流媒体平台的发展</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>