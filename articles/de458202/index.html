<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëá ü§Ωüèº üõë Schauen Sie sich einfach SObjectizer an, wenn Sie Actors oder CSP in Ihrem C ++ - Projekt verwenden m√∂chten üçÅ üö∂üèø ü§õüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein paar Worte zu SObjectizer und seiner Geschichte 


 SObjectizer ist ein eher kleines C ++ - Framework, das die Entwicklung von Multithread-Anwendu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schauen Sie sich einfach SObjectizer an, wenn Sie Actors oder CSP in Ihrem C ++ - Projekt verwenden m√∂chten</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458202/"><p><img src="https://habrastorage.org/webt/qq/0_/at/qq0_atvjcf2gb0uklnpqjbl31hw.jpeg"></p><br><h1 id="a-few-words-about-sobjectizer-and-its-history">  Ein paar Worte zu SObjectizer und seiner Geschichte </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">SObjectizer</a> ist ein eher kleines C ++ - Framework, das die Entwicklung von Multithread-Anwendungen vereinfacht.  Mit SObjectizer kann ein Entwickler Ans√§tze aus CSP-Modellen (Actor, Publish-Subscribe und Communicating Sequential Processes) verwenden.  Es ist ein OpenSource-Projekt, das unter der BSD-3-CLAUSE-Lizenz vertrieben wird. </p><br><p>  SObjectizer hat eine lange Geschichte.  SObjectizer selbst wurde 2002 als SObjectizer-4-Projekt geboren.  Es basierte jedoch auf Ideen aus fr√ºheren SCADA Objectizer, die zwischen 1995 und 2000 entwickelt wurden. SObjectizer-4 wurde 2006 als Open-Source-Version bereitgestellt, aber seine Entwicklung wurde bald danach gestoppt.  Eine neue Version von SObjectizer mit dem Namen SObjectizer-5 wurde 2010 gestartet und 2013 als Open-Source-Version bereitgestellt. Die Entwicklung von SObjectizer-5 ist noch im Gange und SObjectizer-5 enth√§lt seit 2013 viele neue Funktionen. </p><br><p>  SObjectizer ist im russischen Segment des Internets mehr oder weniger bekannt, aber au√üerhalb des exUSSR fast unbekannt.  Dies liegt daran, dass der SObjectizer haupts√§chlich f√ºr lokale Projekte in exUSSR-L√§ndern verwendet wurde und viele Artikel, Pr√§sentationen und Vortr√§ge √ºber SObjectizer auf Russisch sind. </p><br><h1 id="a-niche-for-sobjectizer-and-similar-tools">  Eine Nische f√ºr SObjectizer und √§hnliche Tools </h1><br><p>  Multithreading wird sowohl beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Parallel-Computing</a> als auch beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Concurrent-Computing verwendet</a> .  Es gibt jedoch einen gro√üen Unterschied zwischen parallelem und gleichzeitigem Computing.  Infolgedessen gibt es Tools f√ºr das parallele Computing und Tools f√ºr das gleichzeitige Computing, die sich unterscheiden. </p><a name="habracut"></a><br><p>  Beim parallelen Rechnen geht es grob gesagt darum, mehrere Kerne zu verwenden, um die Berechnungszeiten zu verk√ºrzen.  Das Umcodieren einer Videodatei von einem Format in ein anderes kann beispielsweise auf einem CPU-Kern eine Stunde dauern, auf vier CPU-Kernen jedoch nur 15 Minuten.  Tools wie OpenMP, Intel TBB, HPX oder cpp-taskflow sind f√ºr die Verwendung im Parallel Computing konzipiert.  Und diese Tools unterst√ºtzen geeignete Ans√§tze f√ºr diesen Bereich, wie z. B. aufgabenbasierte oder Datenflussprogrammierung. </p><br><p>  Beim Concurrent Computing geht es darum, viele (wahrscheinlich unterschiedliche) Aufgaben gleichzeitig zu erledigen.  Datenbankserver oder MQ-Broker k√∂nnen gute Beispiele sein: Ein Server muss eine Verbindung akzeptieren, Daten von akzeptierten Verbindungen lesen und analysieren, empfangene Anforderungen verarbeiten (mehrere Aktionen f√ºr jede Anforderung ausf√ºhren), Antworten senden usw.  Streng genommen muss beim gleichzeitigen Rechnen kein Multithreading verwendet werden: Alle diese Aufgaben k√∂nnen mit nur einem Worker-Thread ausgef√ºhrt werden.  Die Verwendung von Multithreading und mehreren CPU-Kernen kann Ihre Anwendung jedoch leistungsf√§higer, skalierbarer und reaktionsf√§higer machen. </p><br><p>  Ans√§tze wie Actor Model oder CSP sind f√ºr den Umgang mit Concurrent Computing vorgesehen.  Gute Anwendungsbeispiele Akteure im Bereich Concurrent Computing sind das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">InfineSQL-Projekt</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Yandex Message-Queue</a> .  In beiden Projekten werden Schauspieler eingesetzt. </p><br><p>  Daher sind die Tools wie SObjectizer, QP / C ++ oder CAF, die das Actor Model unterst√ºtzen, hilfreich bei der L√∂sung von Aufgaben aus dem Bereich Concurrent Computing.  Dies bedeutet, dass die Verwendung von SObjectizer bei Aufgaben wie der Konvertierung von Videostreams wahrscheinlich nichts bringt.  Sie k√∂nnen jedoch ein ganz anderes Ergebnis erzielen, wenn Sie einen Nachrichtenbroker zus√§tzlich zu SObjectizer implementieren. </p><br><h2 id="disclaimer">  Haftungsausschluss </h2><br><p>  Die Verwendung von Actor- oder CSP-Modellen kann Ihnen bei einigen Aufgaben enorme Vorteile bringen, es gibt jedoch keine Garantie daf√ºr, dass diese Modelle f√ºr Ihr spezielles Problem geeignet sind.  Der Vortrag √ºber die Anwendbarkeit von Schauspieler- oder CSP-Modellen geht √ºber den Rahmen dieses Artikels hinaus.  Nehmen wir an, dass das Akteur- oder / und CSP-Modell f√ºr Ihre Aufgaben anwendbar ist und Sie wissen, wie Sie sie effizient einsetzen k√∂nnen. </p><br><h1 id="what-sobjectizer-can-give-to-a-user">  Was kann SObjectizer einem Benutzer geben? </h1><br><h2 id="shared-nothing-and-fire-and-forget-principles-just-out-of-box">  Shared-Nothing- und Fire-and-Forget-Prinzipien sind sofort einsatzbereit </h2><br><p>  Die Verwendung von Akteuren setzt das Fehlen gemeinsamer Daten voraus.  Jeder Akteur besitzt seine Daten und diese Daten sind f√ºr niemanden sichtbar.  Dies ist ein <em>Shared-Nothing-Prinzip</em> , das beispielsweise in der Entwicklung verteilter Anwendungen bekannt ist.  In Multithread-Anwendungen hat das Shared-Nothing-Prinzip einen wichtigen Vorteil: Es erm√∂glicht die Vermeidung gef√§hrlicher Probleme bei der Arbeit mit gemeinsam genutzten Daten wie Deadlocks und Datenrennen. </p><br><p>  Die Interaktion zwischen Akteuren (Agenten) in SObjectizer erfolgt nur √ºber asynchrone Nachrichten.  Ein Agent sendet eine Nachricht an einen anderen Agenten, und dieser Vorgang blockiert den Absender nicht (in einem h√§ufigen Fall). </p><br><p>  Die asynchrone Interaktion erm√∂glicht die Verwendung eines anderen n√ºtzlichen Prinzips: <em>Feuer und Vergessen</em> .  Wenn ein Agent eine Operation ausf√ºhren muss, sendet er eine Nachricht (l√∂st sie aus) und setzt seine Arbeit fort.  In den meisten F√§llen wird die Nachricht empfangen und verarbeitet. </p><br><p>  Beispielsweise kann es einen Agenten geben, der akzeptierte Verbindungen liest und eingehende Daten analysiert.  Wenn die gesamte PDU gelesen und analysiert wird, sendet der Agent diese PDU einfach an einen anderen Agentenprozessor und kehrt zum Lesen / Parsen neuer eingehender Daten zur√ºck. </p><br><h2 id="dispatchers">  Dispatcher </h2><br><p>  Dispatcher sind einer der Eckpfeiler von SObjectizer.  Dispatcher stellen einen Arbeitskontext (auch als Arbeitsthread bezeichnet) bereit, in dem ein Agent eingehende Nachrichten verarbeitet.  Anstatt Arbeitsthreads (oder Thread-Pools) manuell zu erstellen, erstellt ein Benutzer Dispatcher und bindet Agenten an diese.  Ein Benutzer kann in einer Anwendung so viele Disponenten erstellen, wie er m√∂chte. </p><br><p>  Das Beste an Dispatchern und Agenten in SObjectizer ist die Trennung von Konzepten: Disponenten sind f√ºr die Verwaltung des Arbeitskontexts und der eigenen Nachrichtenwarteschlangen verantwortlich, Agenten f√ºhren die Anwendungslogik aus und k√ºmmern sich nicht um den Arbeitskontext.  Es erm√∂glicht das Verschieben eines Agenten von einem Dispatcher zu einem anderen buchst√§blich durch einen Klick.  Gestern hat ein Agent an one_thread dispatcher gearbeitet, heute k√∂nnen wir es wieder an active_obj dispatcher binden und morgen k√∂nnen wir es wieder an thread_pool dispatcher binden.  Ohne eine Zeile in der Implementierung des Agenten zu √§ndern. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">In SObjectizer-5.6.0</a> gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">acht Arten von Dispatchern</a> (und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">weitere</a> in so5extra-Begleitprojekt): von sehr einfachen (one_thread oder thread_pool) bis zu anspruchsvollen (wie adv_thread_pool oder prio_dedicated_threads :: one_per_prio).  Und ein Benutzer kann seinen eigenen Dispatcher f√ºr bestimmte Bedingungen schreiben. </p><br><h2 id="hierarchical-state-machines-are-built-in-functionality">  Hierarchische Zustandsautomaten sind integrierte Funktionen </h2><br><p>  Agenten (Akteure) in SObjectizer sind Zustandsautomaten: Die Reaktion auf eine eingehende Nachricht h√§ngt vom aktuellen Status des Agenten ab.  SObjectizer unterst√ºtzt die meisten Funktionen der hierarchischen Zustandsautomaten (HSM): verschachtelte Zust√§nde, Deep- und Flat-Verlauf f√ºr einen Zustand, Handler on_enter / on_exit, Zeitlimits f√ºr den Verbleib in einem Zustand.  Nur orthogonale Zust√§nde werden in SObjectizer derzeit nicht unterst√ºtzt (wir haben in unseren Projekten keine Notwendigkeit f√ºr diese Funktion gesehen, und niemand hat uns gebeten, Unterst√ºtzung f√ºr diese Funktion hinzuzuf√ºgen). </p><br><h2 id="csp-like-channels-just-out-of-box">  CSP-√§hnliche Kan√§le sind sofort einsatzbereit </h2><br><p> Es ist nicht erforderlich, die Agenten von SObjectizer (auch als Schauspieler bezeichnet) zu verwenden.  Die gesamte Anwendung kann nur mit <code>std::thread</code> Objekten und SObjectizer- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ketten (auch bekannt als CSP-Kan√§le) entwickelt werden</a> .  In diesem Fall √§hnelt die Anwendungsentwicklung mit SObjectizer der Entwicklung in der Sprache Go (einschlie√ülich eines Analogons des <code>select</code> von Go, mit dem Nachrichten von mehreren Kan√§len abgewartet werden k√∂nnen). </p><br><p>  Die Ketten von SObjectizer k√∂nnen ein sehr wichtiges Merkmal haben: den eingebauten Gegendruckmechanismus.  Wenn ein Benutzer eine gr√∂√üenbeschr√§nkte Kette erstellt und dann versucht, eine Nachricht in die vollst√§ndige Kette zu verschieben, kann der Sendevorgang den Absender f√ºr einige Zeit blockieren.  Es erm√∂glicht die L√∂sung eines bekannten Problems mit einem schnellen Produzenten und einem langsamen Konsumenten. </p><br><p>  Die Ketten von SObjectizer haben eine weitere interessante Funktion: Eine Kette kann als sehr einfaches Lastverteilungswerkzeug verwendet werden.  Mehrere Threads k√∂nnen gleichzeitig auf den <em>Empfang</em> von derselben Mchain warten.  Wenn eine neue Nachricht an diese Kette gesendet wird, liest und verarbeitet nur ein Thread diese Nachricht. </p><br><h2 id="only-a-part-of-an-application-can-use-sobjectizer">  Nur ein Teil einer Anwendung kann SObjectizer verwenden </h2><br><p>  Es ist nicht erforderlich, SObjectizer in jedem Teil einer Anwendung zu verwenden.  Mit SObjectizer kann nur ein Teil einer Anwendung entwickelt werden.  Wenn Sie also bereits Qt oder wxWidgets oder Boost.Asio als Hauptframework f√ºr Ihre Anwendung verwenden, k√∂nnen Sie SObjectize in nur einem Submodul Ihrer App verwenden. </p><br><p>  Wir hatten Erfahrung mit der Verwendung von SObjectizer f√ºr die Entwicklung von Bibliotheken, die die Verwendung von SObjectizer als Implementierungsdetail verbergen.  Die √∂ffentliche API dieser Bibliotheken hat das Vorhandensein von SObjectizer √ºberhaupt nicht verf√ºgbar gemacht.  SObjectizer stand vollst√§ndig unter der Kontrolle einer Bibliothek: Die Bibliothek startete und stoppte SObjectizer nach Bedarf.  Diese Bibliotheken wurden in Anwendungen verwendet, denen das Vorhandensein von SObjectizer √ºberhaupt nicht bekannt war. </p><br><p>  Wenn SObjectizer nur in einem Teil einer Anwendung verwendet wird, besteht eine Kommunikationsaufgabe zwischen SObjectizer- und Nicht-SObjectizer-Teilen der Anwendung.  Diese Aufgabe ist leicht zu l√∂sen: Nachrichten von einem Nicht-SObjectizer-Teil an einen SObjectizer-Teil k√∂nnen √ºber den normalen SObjectizer-Mechanismus f√ºr die Nachrichten√ºbermittlung gesendet werden.  Nachrichten in die entgegengesetzte Richtung k√∂nnen √ºber Ketten √ºbermittelt werden. </p><br><h2 id="you-can-run-several-instances-of-sobjectizer-at-the-same-time">  Sie k√∂nnen mehrere Instanzen von SObjectizer gleichzeitig ausf√ºhren </h2><br><p>  Mit SObjectizer k√∂nnen mehrere Instanzen von SObjectizer (als SObjectizer-Umgebung bezeichnet) gleichzeitig in einer Anwendung ausgef√ºhrt werden.  Jede SObjectizer-Umgebung ist unabh√§ngig von anderen solchen Umgebungen. </p><br><p>  Diese Funktion ist in Situationen von unsch√§tzbarem Wert, in denen Sie eine Anwendung aus mehreren unabh√§ngigen Modulen erstellen m√ºssen.  Einige Module k√∂nnen SObjectizer verwenden, andere nicht.  Die Module, f√ºr die SObjectizer erforderlich ist, k√∂nnen die Kopie der SObjectizer-Umgebung ausf√ºhren und haben keinen Einfluss auf andere Module in der Anwendung. </p><br><h2 id="timers-are-part-of-sobjectizer">  Timer sind Teil von SObjectizer </h2><br><p>  Die Unterst√ºtzung von Timern in Form von verz√∂gerten und periodischen Nachrichten ist ein weiterer Eckpfeiler von SObjectizer.  SObjectizer verf√ºgt √ºber mehrere Implementierungen von Timer-Mechanismen (timer_wheel, timer_heap und timer_list) und kann Zehntausende, Hunderte und Tausende von Millionen von Timern in einer Anwendung verarbeiten.  Ein Benutzer kann den am besten geeigneten Zeitgebermechanismus f√ºr eine Anwendung ausw√§hlen.  Dar√ºber hinaus kann ein Benutzer seine eigene Implementierung von timer_thread / timer_manager bereitstellen, wenn keine der Standardimplementierungen f√ºr die Bedingungen des Benutzers geeignet ist. </p><br><h2 id="sobjectizer-has-various-customization-points-and-tuning-options">  SObjectizer verf√ºgt √ºber verschiedene Anpassungspunkte und Optimierungsoptionen </h2><br><p>  SObjectizer erm√∂glicht die Anpassung mehrerer wichtiger Mechanismen.  Beispielsweise kann ein Benutzer eine der Standardimplementierungen von timer_thread (oder timer_manager) ausw√§hlen.  Oder kann eine eigene Implementierung bereitstellen.  Ein Benutzer kann eine Implementierung von Sperrobjekten ausw√§hlen, die von Nachrichtenwarteschlangen in den Dispatchern von SObjectizer verwendet werden.  Oder kann eine eigene Implementierung bereitstellen. </p><br><p>  Ein Benutzer kann seinen eigenen Dispatcher implementieren.  Ein Benutzer kann ein eigenes Meldungsfeld implementieren.  Ein Benutzer kann seinen eigenen Nachrichtenumschlag implementieren.  Ein Benutzer kann seinen eigenen event_queue_hook implementieren.  Und so weiter. </p><br><h1 id="where-sobjectizer-can-or-cant-be-used">  Wo kann SObjectizer eingesetzt werden oder nicht? </h1><br><p>  Es ist viel einfacher zu sagen, wo SObjectizer aus objektiven Gr√ºnden nicht verwendet werden kann.  Wir beginnen die Diskussion mit der Aufz√§hlung solcher Bereiche und geben dann einige Beispiele f√ºr die Verwendung von SObjectizer in der Vergangenheit (und nicht nur in der Vergangenheit). </p><br><h2 id="where-sobjectizer-cant-be-used">  Wo kann SObjectizer nicht verwendet werden? </h2><br><h3 id="tasks-related-to-parallel-computing">  Aufgaben im Zusammenhang mit parallelem Rechnen </h3><br><p>  Wie oben erw√§hnt, sind Schauspieler- und CSP-Modelle keine gute Wahl f√ºr Hochleistungsrechnen und andere Bereiche des Parallelrechnens.  Wenn Sie also mehrere Matrizen verwenden oder Videostreams transkodieren m√ºssen, sind Tools wie OpenMP, Intel TBB, cpp-taskflow, HPX oder MPI besser geeignet. </p><br><h3 id="hard-real-time-systems">  Harte Echtzeitsysteme </h3><br><p>  Trotz der Tatsache, dass SObjectizer seine Wurzeln in SCADA-Systemen hat, kann die aktuelle Implementierung von SObjectizer (auch bekannt als SObjectizer-5) nicht in harten Echtzeitsystemen verwendet werden.  Dies liegt haupts√§chlich an der Verwendung des dynamischen Speichers in der SObjectizer-Implementierung: Nachrichten sind dynamisch zugewiesene Objekte (SObjectizer kann jedoch vorab zugewiesene Objekte als Nachrichten verwenden), Disponenten verwenden dynamischen Speicher f√ºr Nachrichtenwarteschlangen, selbst Zeitlimits f√ºr Agentenstatus verwenden dynamisch zugewiesene Objekte Zeitpr√ºfung durchf√ºhren. </p><br><p>  Leider wird der Begriff "Echtzeit" in der modernen Welt stark √ºberstrapaziert.  Es wird oft √ºber Echtzeit-Webdienste wie "Echtzeit-Webanwendung" oder "Echtzeit-Webanalyse" usw. gesprochen.  Der Begriff "Online" oder "Live" ist f√ºr solche Anwendungen geeigneter als der Begriff "Echtzeit", selbst in "weicher Echtzeit" -Form.  Wenn wir also von einer "Echtzeit-Webanwendung" sprechen, kann SObjectizer problemlos in solchen "Echtzeit" -Systemen verwendet werden. </p><br><h3 id="constrained-embedded-systems">  Eingeschr√§nkte eingebettete Systeme </h3><br><p>  SObjectizer basiert auf der C ++ - Standardbibliothek: <code>std::thread</code> wird f√ºr die Threadverwaltung verwendet, <code>std::atomic</code> , <code>std::mutex</code> , <code>std::condition_variable</code> werden f√ºr die Datensynchronisation verwendet, RTTI und <code>dynamic_cast</code> werden verwendet, um SObjectizer zu vergr√∂√üern (zum Beispiel) , <code>std::type_index</code> werden zur Identifizierung des Nachrichtentyps verwendet), C ++ - Ausnahmen werden zur Fehlerberichterstattung verwendet. </p><br><p>  Dies bedeutet, dass SObjectizer nicht in Umgebungen verwendet werden kann, in denen solche Funktionen der Standardbibliothek nicht verf√ºgbar sind.  Zum Beispiel bei der Entwicklung von eingeschr√§nkten eingebetteten Systemen, bei denen nur ein Teil von C ++ und C ++ stdlib verwendet werden kann. </p><br><h2 id="where-sobjectizer-was-used-in-the-past">  Wo wurde in der Vergangenheit SObjectizer verwendet? </h2><br><p>  Jetzt versuchen wir kurz √ºber einige Anwendungsf√§lle der Verwendung von SObjectizer in der Vergangenheit (und nicht nur in der Vergangenheit) zu sprechen.  Leider sind die Informationen nicht vollst√§ndig, da einige Probleme auftreten. </p><br><p>  Erstens kennen wir nicht alle Verwendungszwecke von SObjectizer.  SObjectizer ist eine kostenlose Software, die auch in propriet√§ren Projekten verwendet werden kann.  Einige Leute bekommen einfach SObjectizer und verwenden es, ohne uns Feedback zu geben.  Manchmal erhalten wir Informationen √ºber die Verwendung von SObjectizer (jedoch ohne Details), manchmal wissen wir nichts. </p><br><p>  Das zweite Problem ist die Erlaubnis, Informationen √ºber die Verwendung von SObjectizer in einem bestimmten Projekt auszutauschen.  Wir haben diese Erlaubnis sehr selten erhalten. In den meisten F√§llen m√∂chten Benutzer von SObjectizer keine Implementierungsdetails ihrer Projekte √∂ffnen (manchmal verstehen wir die Gr√ºnde, manchmal nicht). </p><br><p>  Wir entschuldigen uns daf√ºr, dass die bereitgestellten Informationen so knapp aussehen und keine Details enthalten.  Dennoch gibt es einige Beispiele f√ºr die Verwendung von SObjectizer: </p><br><ul><li>  SMS / USSD-Aggregationsgateway, das mehr als 500 Millionen Nachrichten pro Monat verarbeitet; </li><li>  Teil des Systems f√ºr Online-Zahlungen √ºber Geldautomaten einer der gr√∂√üten russischen Banken; </li><li>  Simulationsmodellierung wirtschaftlicher Prozesse (im Rahmen der Doktorarbeit); </li><li>  verteiltes Datenerfassungs- und Analysesystem.  Daten, die an Punkten gesammelt wurden, die weltweit durch die Befehle des zentralen Knotens verteilt wurden.  MQTT wurde als Transportmittel f√ºr die Kontrolle und die Verteilung erfasster Daten verwendet. </li><li>  Testumgebung zur √úberpr√ºfung des Echtzeitsteuerungssystems f√ºr Eisenbahnausr√ºstung; </li><li>  automatische Steuerung f√ºr Theaterkulisse.  Weitere Details finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ; </li><li>  Komponenten der Datenverwaltungsplattform in einem Online-Werbesystem. </li></ul><br><h1 id="a-taste-of-sobjectizer">  Ein Vorgeschmack auf SObjectizer </h1><br><p>  Schauen wir uns einige einfache Beispiele an, um einen Eindruck von SObjectizer zu bekommen.  Dies sind sehr einfache Beispiele, f√ºr die hoffentlich keine zus√§tzlichen Erkl√§rungen erforderlich sind, mit Ausnahme der Kommentare im Code. </p><br><h2 id="the-traditional-hello-world-example-in-actor-models-style">  Das traditionelle "Hello, World" -Beispiel im Stil von Actor Model </h2><br><p>  Das einfachste Beispiel mit nur einem Agenten, der auf eine <code>hello</code> Nachricht reagiert und seine Arbeit beendet: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'hello' message. so_subscribe_self().event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register an instance of demo agent. auto mbox = env.introduce_coop([](so_5::coop_t &amp; coop) { auto * a = coop.make_agent&lt;demo&gt;(); return a-&gt;so_direct_mbox(); }); // Send hello message to registered agent. so_5::send&lt;hello&gt;(mbox, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><h2 id="another-version-of-hello-world-with-agents-and-publishsubscribe-model">  Eine andere Version von "Hello, World" mit Agenten und Publish / Subscribe-Modell </h2><br><p>  Das einfachste Beispiel mit mehreren Agenten, die alle auf dieselbe Instanz der <code>hello</code> Nachricht reagieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::string_literals; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { const std::string name_; void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; name_ &lt;&lt; ": greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: demo(context_t ctx, std::string name, so_5::mbox_t board) : agent_t{std::move(ctx)} , name_{std::move(name)} { // Create a subscription for hello message from board. so_subscribe(board).event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Mbox to be used for speading hello message. auto board = env.create_mbox(); // Create several agents in separate coops. for(const auto &amp; n : {"Alice"s, "Bob"s, "Mike"s}) env.register_agent_as_coop(env.make_agent&lt;demo&gt;(n, board)); // Spread hello message to all subscribers. so_5::send&lt;hello&gt;(board, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><p>  Wenn wir dieses Beispiel ausf√ºhren, k√∂nnen wir so etwas erhalten: </p><br><pre> <code class="plaintext hljs">Alice: greeting received: Hello, World! Bob: greeting received: Hello, World! Mike: greeting received: Hello, World!</code> </pre> <br><h2 id="hello-world-example-in-csp-style">  Beispiel "Hallo Welt" im CSP-Stil </h2><br><p>  Schauen wir uns ein Beispiel f√ºr SObjectizer ohne Akteure an, nur <code>std::thread</code> und CSP-√§hnliche Kan√§le. </p><br><h3 id="very-simple-version">  Sehr einfache Version </h3><br><p>  Dies ist eine sehr einfache Version, die nicht ausnahmesicher ist: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Channel to be used. auto ch = so_5::create_mchain(sobj); std::thread demo_thread{demo_thread_func, ch}; // Send a greeting. so_5::send&lt;hello&gt;(ch, "Hello, World!"); // Wait for demo thread. demo_thread.join(); }</span></span></span></span></code> </pre> <br><h3 id="more-robust-but-still-simple-version">  Robustere, aber dennoch einfache Version </h3><br><p>  Dies ist eine modifizierte Version des oben gezeigten Beispiels mit der zus√§tzlichen Ausnahmesicherheit: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Demo thread. We need object now, but thread will be started later. std::thread demo_thread; // Auto-joiner for the demo thread. auto demo_joiner = so_5::auto_join(demo_thread); // Channel to be used. This channel will be automatically closed // in the case of an exception. so_5::mchain_master_handle_t ch_handle{ so_5::create_mchain(sobj), so_5::mchain_props::close_mode_t::retain_content }; // Now we can run demo thread. demo_thread = std::thread{demo_thread_func, *ch_handle}; // Send a greeting. so_5::send&lt;hello&gt;(*ch_handle, "Hello, World!"); // There is no need to wait for something explicitly. }</span></span></span></span></code> </pre> <br><h2 id="a-rather-simple-hsm-example-blinking_led">  Ein ziemlich einfaches HSM-Beispiel: blinking_led </h2><br><p>  Dies ist ein Standardbeispiel aus der SObjectizer-Distribution.  Der Hauptagent dieses Beispiels ist ein HSM, der durch das folgende Zustandsdiagramm beschrieben werden kann: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eca/679/59d/eca67959d472d154ce57878d4ffe0120.png" alt="blinking_led statechart"></p><br><p>  Der Quellcode des Beispiels: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;so_5/all.hpp&gt; class blinking_led final : public so_5::agent_t { state_t off{ this }, blinking{ this }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; public : struct turn_on_off final : public so_5::signal_t {}; blinking_led( context_t ctx ) : so_5::agent_t{ ctx } { this &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ std::cout &lt;&lt; "ON" &lt;&lt; std::endl; } ) .on_exit( []{ std::cout &lt;&lt; "off" &lt;&lt; std::endl; } ) .time_limit( std::chrono::milliseconds{1500}, blink_off ); blink_off .time_limit( std::chrono::milliseconds{750}, blink_on ); } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { auto m = env.introduce_coop( []( so_5::coop_t &amp; coop ) { auto led = coop.make_agent&lt; blinking_led &gt;(); return led-&gt;so_direct_mbox(); } ); auto pause = []( unsigned int v ) { std::this_thread::sleep_for( std::chrono::seconds{v} ); }; std::cout &lt;&lt; "Turn blinking on for 10s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 10 ); std::cout &lt;&lt; "Turn blinking off for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Turn blinking on for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Stopping..." &lt;&lt; std::endl; env.stop(); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre> <br><h2 id="timers-overload-control-for-an-agent-and-active_obj-dispatcher">  Timer, √úberlastungskontrolle f√ºr einen Agenten und den Dispatcher active_obj </h2><br><p>  Die √úberlastungskontrolle ist eines der Hauptprobleme f√ºr Akteure: Nachrichtenwarteschlangen f√ºr Akteure sind normalerweise unbegrenzt, und dies kann zu einem unkontrollierten Wachstum von Warteschlangen f√ºhren, wenn ein schneller Nachrichtenproduzent Nachrichten schneller sendet, als der Empf√§nger sie verarbeiten kann.  Das folgende Beispiel zeigt die Funktion von SObjectizer als <em>Nachrichtenlimits</em> .  Es erm√∂glicht die Begrenzung der Anzahl der Nachrichten in der Warteschlange des Agenten und den Schutz des Empf√§ngers vor redundanten Nachrichten. </p><br><p>  Dieses Beispiel zeigt auch die Verwendung des Timers in Form einer periodischen Nachricht.  Dort wird auch die Bindung von Agenten an den Dispatcher active_obj angezeigt.  Die Bindung an diesen Dispatcher bedeutet, dass jeder Agent des Coop an einem eigenen Worker-Thread arbeitet (z. B. wird ein Agent zu einem aktiven Objekt). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::chrono_literals; // Message to be sent to the consumer. struct task { int task_id_; }; // An agent for utilization of unhandled tasks. class trash_can final : public so_5::agent_t { public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'task' message. // Event-handler is specified in the form of a lambda-function. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "unhandled task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; }); } }; // The consumer of 'task' messages. class consumer final : public so_5::agent_t { public: // We need the constructor. consumer(context_t ctx, so_5::mbox_t trash_mbox) : so_5::agent_t{ctx + // Only three 'task' messages can wait in the queue. limit_then_redirect&lt;task&gt;(3, // All other messages will go to that mbox. [trash_mbox]{ return trash_mbox; })} { // Define a reaction to incoming 'task' message. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "handling task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; std::this_thread::sleep_for(75ms); }); } }; // The producer of 'test' messages. class producer final : public so_5::agent_t { const so_5::mbox_t dest_; so_5::timer_id_t task_timer_; int id_counter_{}; // Type of periodic signal to produce new 'test' message. struct generate_next final : public so_5::signal_t {}; void on_next(mhood_t&lt;generate_next&gt;) { // Produce a new 'task' message. so_5::send&lt;task&gt;(dest_, id_counter_); ++id_counter_; // Should the work be stopped? if(id_counter_ &gt;= 10) so_deregister_agent_coop_normally(); } public: producer(context_t ctx, so_5::mbox_t dest) : so_5::agent_t{std::move(ctx)} , dest_{std::move(dest)} {} void so_define_agent() override { so_subscribe_self().event(&amp;producer::on_next); } // This method will be automatically called by SObjectizer // when agent starts its work inside SObjectizer Environment. void so_evt_start() override { // Initiate a periodic message with no initial delay // and repetition every 25ms. task_timer_ = so_5::send_periodic&lt;generate_next&gt;(*this, 0ms, 25ms); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register coop with agents. // All agents will be bound to active_obj dispatcher and will // work on separate threads. env.introduce_coop( so_5::disp::active_obj::make_dispatcher(env).binder(), [](so_5::coop_t &amp; coop) { auto * trash = coop.make_agent&lt;trash_can&gt;(); auto * handler = coop.make_agent&lt;consumer&gt;(trash-&gt;so_direct_mbox()); coop.make_agent&lt;producer&gt;(handler-&gt;so_direct_mbox()); }); }); }</span></span></span></span></code> </pre> <br><p>  Wenn wir dieses Beispiel ausf√ºhren, sehen wir die folgende Ausgabe: </p><br><pre> <code class="plaintext hljs">handling task: 0 handling task: 1 unhandled task: 5 unhandled task: 6 handling task: 2 unhandled task: 8 unhandled task: 9 handling task: 3 handling task: 4 handling task: 7</code> </pre> <br><p>  Diese Ausgabe zeigt, dass mehrere Nachrichten, die nicht in das definierte Limit passen, abgelehnt und an einen anderen Empf√§nger umgeleitet werden. </p><br><h2 id="more-examples">  Weitere Beispiele </h2><br><p>  Ein Beispiel, das dem Code aus realen Anwendungen mehr oder weniger √§hnlich ist, finden Sie in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Shrimp-Demo-Projekt</a> .  Eine weitere Reihe interessanter Beispiele finden Sie in dieser Mini-Serie √ºber das klassische "Problem der Speisephilosophen": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Teil 1</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Teil 2</a> .  Und nat√ºrlich gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">in SObjectizer selbst viele Beispiele</a> . </p><br><h1 id="what-about-the-performance">  Was ist mit der Leistung? </h1><br><p>  Es gibt eine sehr einfache Antwort: Es ist mehr als gut genug f√ºr uns.  SObjectizer kann Millionen von Nachrichten pro Sekunde verteilen. Die tats√§chliche Geschwindigkeit h√§ngt von den verwendeten Dispatcher-Typen, Nachrichtentypen, dem Ladeprofil, der verwendeten Hardware / dem verwendeten Betriebssystem / dem verwendeten Compiler usw. ab.  In einer realen Anwendung verwenden wir normalerweise nur einen Bruchteil der SObjectizer-Geschwindigkeit. </p><br><p>  Die Leistung von SObjectizer f√ºr Ihre bestimmte Aufgabe h√§ngt stark von Ihrer Aufgabe, der speziellen L√∂sung dieser Aufgabe, Ihrer Hardware oder virtuellen Umgebung, der Version Ihres Compilers und Ihrem Betriebssystem ab.  Der beste Weg, um eine Antwort auf diese Frage zu finden, besteht darin, einen eigenen Benchmark zu erstellen, der f√ºr Ihre Aufgabe spezifisch ist, und damit zu experimentieren. </p><br><p>  Wenn Sie Zahlen von einigen synthetischen Benchmarks m√∂chten, befinden sich einige Programme im Ordner test / so_5 / Bench der SObjectizer-Distribution. </p><br><h2 id="a-note-about-comparison-with-different-tools">  Ein Hinweis zum Vergleich mit verschiedenen Werkzeugen </h2><br><p>  Wir denken, dass ein Benchmarking-Spiel, das die Geschwindigkeit verschiedener Tools vergleicht, ein Marketing-Spiel ist.  Wir haben in der Vergangenheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">einen Versuch unternommen,</a> aber schnell erkannt, dass dies nur eine Verschwendung unserer Zeit ist.  Also spielen wir dieses Spiel jetzt nicht.  Wir verwenden unsere Zeit und unsere Ressourcen nur f√ºr Benchmarks, mit denen wir das Fehlen von Leistungseinbu√üen √ºberpr√ºfen und einige Eckf√§lle beheben k√∂nnen (z. B. die Leistung von MPMC-Mboxes mit einer gro√üen Anzahl von Abonnenten oder die Leistung eines Agenten mit Hunderttausenden von Abonnements). um einige SObjectizer-spezifische Vorg√§nge zu beschleunigen (wie die Registrierung / Abmeldung eines Coops). </p><br><p>  Also √ºberlassen wir den Geschwindigkeitsvergleich denen, die dieses Spiel m√∂gen und Zeit haben, es zu spielen. </p><br><h1 id="why-sobjectizer-does-look-exactly-as-it-is">  Warum sieht SObjectizer genauso aus wie es ist? </h1><br><p>  Es gibt mehrere "Actor Frameworks" f√ºr C ++, die alle unterschiedlich aussehen.  Es scheint, dass es einige objektive Gr√ºnde hat: Jedes Framework hat seine einzigartigen Merkmale und zielt auf unterschiedliche Ziele ab.  Dar√ºber hinaus k√∂nnen Akteure in C ++ sehr unterschiedlich implementiert werden.  Die Hauptfrage lautet also nicht "Warum sieht Framework X nicht wie Framework Y aus?", Sondern "Warum sieht Framework X so aus, wie es ist?" </p><br><p>  Jetzt werden wir versuchen, einige Gr√ºnde f√ºr die Hauptfunktionen des SObjectizers kurz zu beschreiben.  Wir hoffen, dass dies ein besseres Verst√§ndnis der F√§higkeiten von SObjectizer erm√∂glicht.  Bevor wir beginnen, muss jedoch eines sehr wichtig erw√§hnt werden: SObjectizer war noch nie ein Experiment.  Es wurde f√ºr die L√∂sung realer Arbeiten entwickelt und hat sich basierend auf den realen Erfahrungen weiterentwickelt. </p><br><h2 id="agents-are-objects-of-classes-derived-from-agent_t">  Agenten sind Objekte von Klassen, die von agent_t abgeleitet sind </h2><br><p>  Agenten (auch als Akteure bezeichnet) in SObjectzer sind Objekte benutzerdefinierter Klassen, die von einer speziellen Klasse <code>agent_t</code> abgeleitet werden <code>agent_t</code> .  In winzigen Spielzeugbeispielen mag es √ºberfl√ºssig aussehen, aber unsere Erfahrung zeigt, dass dieser Ansatz die Entwicklung realer Software erheblich vereinfacht, bei der Agenten normalerweise die Gr√∂√üe in mehreren hundert Zeilen haben (Sie k√∂nnen eines der Beispiele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier sehen</a> , aber dieser Blog-Beitrag ist in Russisch).  Manchmal sogar in mehreren tausend Zeilen. </p><br><p>  Die Erfahrung zeigt uns, dass ein einfacher Agent mit der ersten Version in hundert Zeilen in einigen n√§chsten Jahren der Evolution viel dicker und komplexer wird.  Nach f√ºnf Jahren k√∂nnen Sie also ein Monster in tausend Zeilen mit Dutzenden von Methoden finden. </p><br><p>  Durch die Verwendung von Klassen k√∂nnen wir die Komplexit√§t von Agenten verwalten.  Wir k√∂nnen die Vererbung von Klassen verwenden.  Und wir k√∂nnen auch Vorlagenklassen verwenden.  Dies sind sehr n√ºtzliche Techniken, die die Entwicklung von Agentenfamilien mit √§hnlicher Logik erheblich vereinfachen. </p><br><h2 id="messages-as-objects-of-user-structsclasses">  Nachrichten als Objekte von Benutzerstrukturen / -klassen </h2><br><p>  Nachrichten in SObjectizer sind Objekte benutzerdefinierter Strukturen oder Klassen.  Daf√ºr gibt es mindestens zwei Gr√ºnde: </p><br><ul><li>  Die Entwicklung von SObjectizer-5 begann 2010, als C ++ 11 noch nicht standardisiert war.  Am Anfang konnten wir solche Funktionen von C ++ 11 nicht als variable Vorlagen und als <code>std::tuple</code> tuple-Klasse verwenden.  Die einzige Wahl, die wir hatten, war die Verwendung eines Objekts einer Klasse, die von einer speziellen Klasse <code>message_t</code> .  Jetzt ist es nicht mehr erforderlich, den Nachrichtentyp von <code>message_t</code> , aber SObjectizer verpackt ein Benutzerobjekt ohnehin unter der Haube in ein von <code>message_t</code> abgeleitetes Objekt. </li><li>  Der Inhalt einer Nachricht kann leicht ge√§ndert werden, ohne dass die Signaturen der Ereignishandler ge√§ndert werden m√ºssen.  Und es gibt ein Steuerelement von einem Compiler: Wenn Sie ein Feld aus einer Nachricht entfernen oder dessen Typ √§ndern, informiert Sie der Compiler √ºber einen falschen Zugriff auf dieses Feld. </li></ul><br><p>  Die Verwendung von Nachrichten als Objekte erm√∂glicht es auch, mit vorab zugewiesenen Nachrichten zu arbeiten und eine empfangene Nachricht in einem Container zu speichern und sp√§ter erneut zu senden. </p><br><h2 id="coops-of-agents">  Coops von Agenten </h2><br><p>  Eine Gruppe von Agenten ist wahrscheinlich eine der einzigartigen Funktionen von SObjectizer.  Ein Coop ist eine Gruppe von Agenten, die SObjectizer auf transaktionale Weise hinzugef√ºgt und daraus entfernt werden sollten.  Wenn ein Coop drei Agenten enth√§lt, sollten alle diese Agenten erfolgreich zu SObjectizer hinzugef√ºgt werden, oder es sollte keiner von ihnen hinzugef√ºgt werden.  Ebenso sollten alle drei Agenten aus SObjectizer entfernt werden oder alle drei Agenten sollten ihre Arbeit fortsetzen. </p><br><p>  Der Bedarf an Coops wurde kurz nach dem Beginn des SObjectizer-Lebens entdeckt.  Es wurde klar, dass Agenten von Gruppen und nicht von einzelnen Instanzen erstellt werden.  Coops wurden erfunden, um das Leben eines Entwicklers zu vereinfachen: Es ist nicht erforderlich, die Erstellung des n√§chsten Agenten zu steuern und zuvor erstellte Agenten zu entfernen, wenn die Erstellung eines neuen Agenten fehlschl√§gt. </p><br><p>  Ein Coop kann auch als Supervisor im All-for-One-Modus angesehen werden: Wenn ein Agent aus dem Coop ausf√§llt, wird der gesamte Coop aus der SObjectizer-Umgebung entfernt und zerst√∂rt (ein Benutzer kann darauf reagieren und den Coop erneut erstellen). </p><br><h2 id="message-boxes">  Meldungsfelder </h2><br><p>  Nachrichtenfelder sind eine weitere einzigartige Funktion von SObjectizer.  Nachrichten in SObjectizer werden an ein Nachrichtenfeld (mbox) und nicht direkt an einen Agenten gesendet.  Es kann einen Empf√§nger hinter der mbox geben, oder es kann eine Million Abonnenten geben, oder es kann niemand geben. </p><br><p>  Mit Mboxes k√∂nnen wir die grundlegenden Funktionen des Publish-Subscribe-Modells unterst√ºtzen.  Eine mbox kann als MQ-Broker und der Nachrichtentyp als Thema angesehen werden. </p><br><p>  Mit Mboxes k√∂nnen wir auch verschiedene interessante Formen der Nachrichten√ºbermittlung implementieren.  Zum Beispiel gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Round-Robin-Mbox</a> , die Nachrichten zwischen Round-Robin-Teilnehmern verteilt.  Es gibt auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">beibehaltene mbox</a> , die die zuletzt gesendete Nachricht enth√§lt und diese automatisch f√ºr jeden neuen Abonnenten erneut sendet.  Es gibt auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">einfachen Wrapper um libmosquitto</a> , mit dem MQTT als Transport f√ºr eine verteilte Anwendung verwendet werden kann. </p><br><h2 id="agents-as-hsm">  Agenten als HSM </h2><br><p>  Agenten in SObjectizer sind Zustandsautomaten.  Dies war von Anfang an einfach deshalb so, weil SObjectizer Wurzeln im SCADA-Bereich hat, in dem Zustandsautomaten aktiv verwendet werden.  Es wurde jedoch schnell klar, dass Agenten in Form einer Zustandsmaschine auch in verschiedenen Nischen (wie Telekommunikations- und Finanzanwendungen) n√ºtzlich sein k√∂nnen. </p><br><p>  Die Unterst√ºtzung hierarchischer Zustandsautomaten (z. B. on_enter / on_exit-Handler, verschachtelte Zust√§nde, Zeitlimits usw.) wurde nach einiger Zeit der Verwendung von SObjectizer in der Produktion hinzugef√ºgt.  Und diese Funktion machte SObjectizer noch leistungsf√§higer und bequemer. </p><br><h2 id="usage-of-c-exceptions">  Verwendung von C ++ - Ausnahmen </h2><br><p>  C ++ - Ausnahmen werden in SObjectizer als Hauptmechanismus f√ºr die Fehlerberichterstattung verwendet.  Trotz der Tatsache, dass die Verwendung von C ++ - Ausnahmen manchmal kostspielig sein kann, haben wir uns entschieden, Ausnahmen anstelle von Fehlercodes zu verwenden. </p><br><p>  Wir hatten eine negative Erfahrung mit Fehlercodes in SObjectizer-4, wo keine Ausnahmen verwendet wurden.  Dies f√ºhrte dazu, dass Fehler im Anwendungscode nicht erkannt wurden und manchmal wichtige Aktionen nicht ausgef√ºhrt wurden, weil beim Erstellen eines neuen Coops oder beim Senden einer Nachricht ein Fehler aufgetreten ist.  Dieser Fehler wurde jedoch ignoriert und viel sp√§ter entdeckt. </p><br><p>  Die Verwendung von C ++ - Ausnahmen in SObjectizer-5 erm√∂glicht das Schreiben von korrekterem und robusterem Code.  In der Regel werden Ausnahmen von SObjectizer sehr selten ausgel√∂st, sodass die Verwendung von Ausnahmen keine negativen Auswirkungen auf die Leistung von SObjectizer oder die Leistung von Anwendungen hat, die √ºber SObjectizer geschrieben wurden. </p><br><h2 id="no-support-for-distributed-applications-out-of-box">  Keine Unterst√ºtzung f√ºr verteilte Anwendungen "out of box" </h2><br><p>  SObjectzer-5 bietet keine integrierte Unterst√ºtzung f√ºr verteilte Anwendungen.  Dies bedeutet, dass SObjectizer Nachrichten nur innerhalb eines Prozesses verteilt.  Wenn Sie die Verteilung von Nachrichten zwischen Prozessen oder Notizen organisieren m√ºssen, m√ºssen Sie eine Art IPC in Ihre Anwendung integrieren. </p><br><p>  Dies liegt nicht daran, dass wir in SObjectizer keine IPC-Form implementieren k√∂nnen.  Das hatten wir schon in SObjectizer-4.  Und weil wir solche Erfahrungen haben, haben wir uns entschieden, dies in SObjectizer-5 nicht zu tun.  Wir haben gelernt, dass es keinen IPC-Typ gibt, der perfekt f√ºr unterschiedliche Bedingungen geeignet ist. </p><br><p>  Wenn Sie eine gute Kommunikation zwischen Knoten in Ihrer Anwendung w√ºnschen, m√ºssen Sie die entsprechenden zugrunde liegenden Protokolle ausw√§hlen.  Wenn Sie beispielsweise Millionen kleiner Pakete mit kurzlebigen Daten verteilen m√ºssen (z. B. Verteilung der Messwerte der aktuellen Wetterbedingungen), m√ºssen Sie einen IPC verwenden.  Wenn Sie jedoch gro√üe BLOBs (wie 4K / 8K-Videostreams oder Archive mit darin enthaltenen Finanzdaten) √ºbertragen m√ºssen, m√ºssen Sie einen anderen IPC-Typ verwenden. </p><br><p>  Und wir sprechen nicht √ºber Introperabilit√§t mit Software, die in verschiedenen Sprachen geschrieben ist ... </p><br><p>  Sie k√∂nnen glauben, dass ein universelles "Akteur-Framework" Ihnen einen IPC bieten kann, der f√ºr verschiedene Bedingungen geeignet ist.  Aber wir wissen, dass es nur Marketing-Bullshit ist.  Unsere Erfahrung zeigt uns, dass es viel einfacher und sicherer ist, den IPC, den Sie in Ihrer Anwendung ben√∂tigen, hinzuzuf√ºgen, als sich auf Ideen, Bed√ºrfnisse und Kenntnisse der Autoren eines "Actor Framework" einer dritten Partei zu verlassen. </p><br><p>  Mit SObjectizer k√∂nnen verschiedene IPC-Typen in Form von benutzerdefinierten Mboxes integriert werden.  Auf diese Weise kann die Tatsache der Nachrichtenverteilung √ºber ein Netzwerk vor den Benutzern eines SObjectizers verborgen werden. </p><br><h1 id="instead-of-the-conclusion">  Anstelle der Schlussfolgerung </h1><br><p>  Das SObjectizer-Framework ist kein gro√ües, aber kein kleines.  Es ist daher unm√∂glich, dem Leser in nur einer √úbersicht einen ziemlich tiefen Eindruck von SObjectizer zu vermitteln.  Aus diesem Grund laden wir Sie ein, sich das SObjectizer-Projekt anzusehen. </p><br><p>  SObjectizer selbst lebt auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GitHub</a> .  Es gibt das Projekt-Wiki auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GitHub</a> und wir empfehlen, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">SObjectizer 5.6 Basics zu beginnen</a> und dann zu Artikeln aus ausf√ºhrlichen Serien zu gehen.  F√ºr diejenigen, die tiefer gehen m√∂chten, empfehlen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">wir einen Blick unter den Haubenbereich des SObjectizers</a> . </p><br><p>  Wenn Sie Fragen haben, k√∂nnen Sie uns in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">SObjectizer-Gruppe</a> in den Google-Gruppen Fragen stellen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458202/">https://habr.com/ru/post/de458202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458180/index.html">Kea-basierter Failover-DHCP-Server</a></li>
<li><a href="../de458182/index.html">Wir lesen VKontakte √ºber RSS</a></li>
<li><a href="../de458184/index.html">Haxe und PHP: statische Eingabe, Pfeilfunktionen, Metaprogrammierung und vieles mehr</a></li>
<li><a href="../de458186/index.html">WAL in PostgreSQL: 1. Puffercache</a></li>
<li><a href="../de458190/index.html">Ich sehe, es bedeutet, dass ich existiere: Deep Learning Review in Computer Vision (Teil 2)</a></li>
<li><a href="../de458204/index.html">So bewerten Sie die Speicherleistung unter Linux: Benchmarking mit offenen Tools</a></li>
<li><a href="../de458206/index.html">Erhabener Text 3 f√ºr das Site-Layout. Passen Sie das Erscheinungsbild an und installieren Sie Plugins. Anf√§ngerleitfaden</a></li>
<li><a href="../de458208/index.html">Digitale Veranstaltungen in Moskau vom 01. bis 07. Juli</a></li>
<li><a href="../de458214/index.html">Pentest-Labor "Pentestit Test Lab 12" - volle Passage</a></li>
<li><a href="../de458218/index.html">Kiefer- und Gesichtschirurgie oder nicht? Das ist die Frage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>