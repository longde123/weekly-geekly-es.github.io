<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÆÔ∏è üí™üèº ‚úåÔ∏è Beobachten Sie mich in vollem Umfang: Nutzen Sie das Beste aus Live-Videos auf mobilen Plattformen üò´ üïß üëé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der einfachste Weg, Videos auf einem mobilen Ger√§t abzuspielen, besteht darin, die Verbindung zu einem vorhandenen Player im System zu √∂ffnen. Dies is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beobachten Sie mich in vollem Umfang: Nutzen Sie das Beste aus Live-Videos auf mobilen Plattformen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/467669/"><img src="https://habrastorage.org/webt/3z/wx/89/3zwx89x0wbx0euzwj3a_f8vttwo.jpeg"><br><br>  Der einfachste Weg, Videos auf einem mobilen Ger√§t abzuspielen, besteht darin, die Verbindung zu einem vorhandenen Player im System zu √∂ffnen. Dies ist jedoch nicht immer effektiv. <br><br>  Sie k√∂nnen ExoPlayer verwenden und optimieren oder sogar Ihren eigenen Video-Player nur mit Codecs und Sockets schreiben.  In dem Artikel wird √ºber die Arbeit des Streamings und der Videowiedergabe gesprochen und dar√ºber, wie die Verz√∂gerung beim Starten des Videos verringert, die Reaktionszeit zwischen dem Streamer und dem Betrachter verk√ºrzt und der Stromverbrauch und die Eisenlast optimiert werden k√∂nnen. <br><br>  Wir werden dies anhand bestimmter Anwendungen als Beispiel analysieren: Odnoklassniki Mobile Client (wo Videos abgespielt werden) und OK Live (wo Sendungen vom Telefon auf 1080p gestreamt werden).  Es gibt keine Meisterkurse zum Abspielen eines Videos anhand von Codebeispielen.  Die Geschichte konzentriert sich darauf, wie das Video von innen aussieht und wie Sie mit Kenntnis der allgemeinen Architektur von Videoplayern und Video-Streaming jedes System verstehen und verbessern k√∂nnen. <br><br>  Das Material basiert auf der Abschrift des Berichts von <b>Alexander Tobol</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@alatobol</a></b> ) und <b>Ivan Grigoriev</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ivan_a</a></b> ) von der <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mobius-</a></b> Konferenz. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/e1JYFRwHzkQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><h2>  Eintrag </h2><br>  F√ºr den Anfang - ein paar Zahlen zum Video in Odnoklassniki. <br><br>  Der durchschnittliche durchschnittliche t√§gliche VOD-Verkehr (Video on Demand) betr√§gt mehr als eineinhalb Terabit pro Sekunde und bei Live-√úbertragungen mehr als 3 Terabit pro Sekunde. <br><br>  Jetzt gibt es in OK mehr als 870 Millionen Videoaufrufe pro Tag, von denen mehr als die H√§lfte von Mobilger√§ten stammen. <br><br><img src="https://habrastorage.org/webt/xt/nl/ij/xtnlijaizuntzzpkihtkpi-juws.jpeg"><br><br>  Wenn Sie sich die Geschichte des Streamings ansehen, erschien 2007 ein mobiles Video auf YouTube.  Wir sind sp√§ter in diesen Zug gestiegen, aber 2014-2015 hatten wir bereits eine 4K-Videowiedergabe auf Mobilger√§ten und in den letzten Jahren haben wir unsere Player aktiv weiterentwickelt.  Dar√ºber und das Gespr√§ch wird gehen. <br><br>  Der zweite Trend, der 2015 bei Periscope auftrat, war die Ausstrahlung von Telefonen.  Wir haben unsere OK Live-Anwendung gestartet, mit der Sie sogar Full HD-Videos √ºber Mobilfunknetze streamen k√∂nnen.  In der zweiten H√§lfte des Materials werden wir auch √ºber Streaming sprechen. <br><br>  Wir werden uns nicht mit der API f√ºr die Arbeit mit Videos befassen, sondern tauchen jetzt tief ein und versuchen herauszufinden, was im Inneren passiert. <br><br><img src="https://habrastorage.org/webt/4d/ne/-v/4dne-vlspxhbv3rm3wxixirrc8o.jpeg"><br><br>  Wenn Sie ein Video mit einer Kamera aufnehmen, gelangt es zum Codec, von dort zum Socket und dann zum Server (unabh√§ngig davon, ob VOD oder Live).  Und dann verteilt der Server es in umgekehrter Reihenfolge an das Publikum. <br><br>  Beginnen wir mit dem KPI-Player.  Was wollen wir von ihm? <br><br><ul><li>  Schneller erster Frame.  Benutzer m√∂chten nicht auf den Start der Wiedergabe warten. </li><li>  Fehlende Pufferung.  Niemand mag es, in einen Oberk√∂rper zu laufen. </li><li>  Hohe Qualit√§t.  Als es noch fast keinen 4K-Inhalt gab, haben wir bereits 4K-Unterst√ºtzung f√ºr ‚ÄûOutgrowing‚Äú aktiviert: Wenn Sie den Player daf√ºr ausschalten und die Leistung ermitteln, wird 1080p auch auf schwachen Ger√§ten perfekt wiedergegeben. </li><li>  UX-Anforderungen.  Wir brauchen das Video, um es beim Scrollen auf dem Band abzuspielen, und f√ºr das Band m√ºssen wir das Video vorab abrufen. </li></ul><br><br>  Auf diese Weise gibt es viele Probleme.  Der Stream f√ºr 4K-Videos ist gro√ü, und wir arbeiten auf Mobilger√§ten, bei denen Probleme mit dem Netzwerk auftreten, verschiedene Funktionen von Videoformaten und Containern auf verschiedenen Ger√§ten vorhanden sind und die Ger√§te selbst ebenfalls zu einem Problem werden k√∂nnen. <br><br>  Wo startet das Video Ihrer Meinung nach schneller, unter iOS oder Android? <br><br>  In der Tat ist jede Antwort richtig: Es kommt darauf an, was, wo und wie man spielt.  Wenn wir eine Region Russlands mit einem nicht so guten Netzwerk nehmen, werden wir sehen, dass AVPlayer bei etwa 800 Millisekunden startet.  Mit demselben Netzwerk wird ExoPlayer auf Android, das ein anderes Format spielt, in 660 ms gestartet.  Und wenn Sie Ihren Player auf iOS machen, kann er noch schneller laufen. <br><br><img src="https://habrastorage.org/webt/eb/jl/ao/ebjlao75uhegqjpd6mn-nfjuakk.jpeg"><br><br>  Es gibt eine Nuance darin, dass wir den Durchschnitt f√ºr Benutzer messen und die durchschnittliche Leistung von iOS-Ger√§ten h√∂her ist als bei Android. <br><br>  Der erste Teil des Materials wird theoretisch sein: Wir werden lernen, was Video ist und wie die Architektur eines Live-Players aussieht.  Und im zweiten Teil vergleichen wir die Spieler und sprechen dar√ºber, wann Sie Ihre eigenen schreiben sollen. <br><br><h2>  Teil eins </h2><br><h3>  Was ist Video? </h3><br>  Beginnen wir mit den grundlegendsten.  Video ist 60 oder 24 Bilder pro Sekunde. <br><br>  Das Speichern mit einem vollst√§ndigen Satz von Bildern ist nat√ºrlich ziemlich teuer.  Daher werden sie folgenderma√üen gespeichert: Einige Frames werden als Referenzframes (I-Frames) bezeichnet, w√§hrend andere (B-Frames und P-Frames) als ‚ÄûDiffs‚Äú bezeichnet werden.  Tats√§chlich haben Sie eine JPG-Datei und bestimmte √Ñnderungen daran. <br><br><img src="https://habrastorage.org/webt/lf/rk/nt/lfrknthpx0phqp5u7psr0if5j78.jpeg"><br><br>  Es gibt auch das Konzept der GOP (Bildgruppe) - dies ist ein unabh√§ngiger Satz von Rahmen, der mit einem Referenzrahmen beginnt und mit einem Satz von Unterschieden fortgesetzt wird.  Es kann unabh√§ngig gespielt, ausgepackt und so weiter werden.  Wenn Sie einen Opornik in der Gruppe verloren haben, sind die verbleibenden Frames dort nicht mehr relevant. <br><br>  Es gibt viele Codierungsalgorithmen, Transformationsmatrizen, Bewegungssuche und dergleichen - darin unterscheiden sich Codecs. <br><br><h3>  Codec-Leistung </h3><br><br><img src="https://habrastorage.org/webt/q7/mj/ts/q7mjtslvjdqlperjccv0etipmgk.jpeg"><br><br>  Der Klassiker H.264 ist seit 2003 bekannt und hat sich gut entwickelt.  Wir werden seine Wirksamkeit als Basis nehmen.  Er arbeitet und spielt √ºberall.  Es bietet Hardware-Unterst√ºtzung f√ºr CPU / GPU (sowohl unter iOS als auch unter Android).  Dies bedeutet, dass es entweder einen speziellen Coprozessor gibt, der ihn codieren kann, oder integrierte Befehlss√§tze, mit denen Sie dies schnell tun k√∂nnen.  Im Durchschnitt bietet die Hardwareunterst√ºtzung eine bis zu 10-mal schnellere Leistung und spart Akkulaufzeit. <br><br>  Im Jahr 2010 erschien VP8 von Google.  In Bezug auf die Effizienz unterscheidet es sich nicht von H.264.  Nun, tats√§chlich ist die Effektivit√§t des Codecs eine sehr kontroverse Sache.  In der Stirn wird es als Verh√§ltnis des Originalvideos zum komprimierten Video gemessen, aber es ist klar, dass es unterschiedliche Videoartefakte gibt.  Daher bieten wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zu detaillierten Vergleichen von Codecs der Moskauer Staatlichen Universit√§t.  Hier beschr√§nken wir uns jedoch auf die Tatsache, dass VP8 auf eine Softwareorganisation ausgerichtet ist, Sie es √ºberall hin mitnehmen k√∂nnen und es normalerweise als Fallback verwendet wird, wenn keine native H.264-Unterst√ºtzung vorhanden ist. <br><br>  2013 erschien eine neue Generation von Codecs - H.265 (HEVC) und VP9.  Der H.265-Codec erh√∂ht die Effizienz um 50%. Bei Android-Videos k√∂nnen sie jedoch nicht codiert werden. Der Decoder wurde nur mit Android 5.0+ angezeigt.  Aber unter iOS gibt es Unterst√ºtzung. <br><br>  Es gibt eine Alternative zu H.265 - VP9.  Trotzdem, aber von Google unterst√ºtzt.  Nun, V9 ist YouTube und H.265 ist Netflix.  Jeder hat seine eigenen Besonderheiten: Einer funktioniert nicht mit iOS, der andere hat Probleme mit Android.  Am Ende bleiben viele auf H.264. <br><br>  In Zukunft wird uns der AV1-Codec versprochen, er hat bereits eine Software-Implementierung und seine Effizienz ist 35% h√∂her als die der 2013er Codecs.  Jetzt in Chrome und Firefox verf√ºgbar, und im Jahr 2020 verspricht Google Hardware-Unterst√ºtzung - ich denke, wir werden h√∂chstwahrscheinlich alle darauf umsteigen. <br><br>  Schlie√ülich k√ºndigten sie k√ºrzlich den H.266 / JVEC-Codec an und sagten, dass alles besser und schneller sein werde. <br><br>  Das Hauptmuster: Je h√∂her die Effizienz des Codecs ist, desto mehr Rechenressourcen werden von den Ger√§ten ben√∂tigt. <br><br>  Im Allgemeinen nimmt standardm√§√üig jeder H.264, und f√ºr bestimmte Ger√§te kann dies kompliziert sein. <br><br><h3>  Qualit√§t, Aufl√∂sung und Bitrate </h3><br>  Im Jahr 2019 werden Sie niemanden mit adaptiver Qualit√§t √ºberraschen: Benutzer laden Videos in einer Qualit√§t hoch oder streamen sie, und wir schneiden eine Reihe verschiedener Qualit√§ten ab und senden die am besten geeigneten an Ger√§te. <br><br>  In diesem Fall muss die Videoaufl√∂sung mit der Bitrate korrelieren.  Wenn die Aufl√∂sung verdoppelt wird, sollte sich auch die Bitrate verdoppeln: <br><br><img src="https://habrastorage.org/webt/vg/f0/y_/vgf0y_ve9h6r_0r-bvioww1qivw.jpeg"><br><br>  Wenn Sie eine gro√üe Aufl√∂sung mit einer niedrigen Bitrate komprimieren oder umgekehrt, kommt es nat√ºrlich entweder zu Artefakten oder zu einem nutzlosen Brennen der Bitrate. <br><br>  Wie ist die Bitrate des codierten Videos mit der urspr√ºnglichen Informationsmenge zu vergleichen?  Auf einem 4K-Bildschirm k√∂nnen wir fast 6 Gbit / s an Informationen wiedergeben (wenn Sie alle Pixel und ihre Frequenz mit 60 Bildern pro Sekunde z√§hlen), w√§hrend die Codec-Bitrate 50 Mbit / s betragen kann.  Das hei√üt, der Codec komprimiert das Video bis zu 100 Mal. <br><br><h3>  Liefertechnik </h3><br>  Sie haben Audio und Video mit einigen Codecs gepackt.  Wenn Sie es einfach zu Hause lassen, k√∂nnen Sie alle Audio- und Videodaten addieren, indem Sie einen kleinen Index hinzuf√ºgen, der angibt, ab welcher Sekunde Audio und Video gestartet werden.  Das Video kann jedoch nicht auf das Telefon √ºbertragen werden. F√ºr das Online-Streaming zum Viewer gibt es zwei Hauptklassen von Protokollen: Streaming und Segmentierung. <br><br><img src="https://habrastorage.org/webt/yd/mn/bp/ydmnbpqbfq8p19nbq2wmdx4ktzi.jpeg"><br><br>  Das Streaming-Protokoll impliziert, dass Sie auf dem Server, auch auf dem Client, einen Status haben und Daten senden.  Der Server kann beispielsweise die Qualit√§t anpassen.  Sehr oft ist dies eine UDP-Verbindung. <br><br>  Solche Protokolle sind f√ºr den Server sehr komplex und schwer zu liefern.  F√ºr stark geladene √úbersetzungen verwenden wir segmentierte Protokolle, die auf HTTP basieren, von Nginx und CDN zwischengespeichert werden k√∂nnen und viel einfacher zu verteilen sind.  Und der Server ist f√ºr nichts verantwortlich und in diesem Fall zustandslos. <br><br>  Wie die Segmentlieferung aussieht: Wir schneiden das vorhandene Video in Segmente und begleiten sie mit einem Header f√ºr Audio und Video, MPEG-TS und MP4 als Beispiel f√ºr den Transport.  Am Telefon geben wir ein Manifest mit Informationen dar√ºber, wo und f√ºr welche Qualit√§t das Segment liegt, und dieses Manifest kann regelm√§√üig aktualisiert werden. <br><br>  In der Vergangenheit liefert Apple √ºber HLS und Android √ºber DASH.  Mal sehen, wie sie sich unterscheiden. <br><br>  Beginnen wir mit dem √§lteren HLS, es hat ein Manifest, das alle verf√ºgbaren Qualit√§ten beschreibt - niedrig, mittel, hoch und so weiter.  Es gibt Bitraten dieser Eigenschaften, so dass der Spieler sofort die richtige ausw√§hlen kann.  Er w√§hlt die Qualit√§t und erh√§lt ein verschachteltes Manifest mit einer Liste von Links zu Segmenten.  Die Dauer dieser Segmente wird ebenfalls angegeben. <br><br><img src="https://habrastorage.org/webt/v5/xw/1r/v5xw1rnetgtu4wzdg7zmxsy2dqa.jpeg"><br><br>  Hier gibt es eine interessante Funktion: Um das erste Bild abzuspielen, m√ºssen Sie zwei zus√§tzliche Roundtrips durchf√ºhren.  Bei der ersten Anforderung erhalten Sie das Hauptmanifest, die zweitverschachtelten Manifeste und greifen erst dann auf die Daten selbst zu, was nicht sehr gut ist. <br><br><img src="https://habrastorage.org/webt/hy/2u/af/hy2uafqbmeujkyq9ishlykfqppc.jpeg"><br><br>  Die zweite Schwierigkeit: HLS wurde f√ºr die Arbeit im Internet √ºber HTTP entwickelt, aber der √§ltere MPEG-2-Transportstrom wurde als Container f√ºr Videodaten ausgew√§hlt, der f√ºr ganz andere Zwecke entwickelt wurde: die √úbertragung eines Signals von einem Satelliten in verrauschten Kan√§len.  Als Ergebnis erhalten wir zus√§tzliche Header, die im Fall von HLS v√∂llig nutzlos sind und nur zus√§tzlichen Aufwand verursachen. <br><br><img src="https://habrastorage.org/webt/tm/ks/hs/tmkshszo_5atstyrbip1r64qs84.jpeg"><br><br>  F√ºgen Sie den Netzwerk-Overhead und die Komplexit√§t des Parsens hinzu: Wenn Sie versuchen, 4K in DASH und HLS in Chrome zu spielen, werden Sie den Unterschied sp√ºren, wenn Ihr Computer mit HLS-Paketen ‚Äûabhebt‚Äú. <br><br>  Apple versucht dies zu l√∂sen.  2016 k√ºndigten sie die M√∂glichkeit der Verwendung von fragmentiertem MPEG-4 an. Es gab eine gewisse Unterst√ºtzung f√ºr DASH in HLS, aber das zus√§tzliche RTT und seine Funktionen verschwanden nicht. <br><br><img src="https://habrastorage.org/webt/xa/zy/ai/xazyaila94udoix88ia0vvea0yq.jpeg"><br><br>  DASH sieht etwas einfacher aus: Sie haben ein Manifest mit allen darin enthaltenen Qualit√§ten, und jede Qualit√§t besteht aus einer Reihe von Segmenten.  Sie k√∂nnen ein Segment spielen, um in einer Qualit√§t zu spielen, und dann verstehen, dass die Geschwindigkeit gestiegen ist, vom n√§chsten Segment, um zu einem anderen zu wechseln.  Alle Segmente beginnen immer mit Referenzrahmen, sodass umgeschaltet werden kann. <br><br>  Hier ist ein kleiner Teller √ºber die Auswahl: <br><br><img src="https://habrastorage.org/webt/mq/n1/pk/mqn1pkjswjel-yxavreufexrrjm.jpeg"><br><br>  In HLS sind historisch unterst√ºtzte Videocodecs nur H.264, in MPEG-DASH k√∂nnen Sie jeden schieben.  Das Hauptproblem von HLS ist eine zus√§tzliche Rundreise zu Beginn, die sowohl auf iOS als auch auf Android mit 4.0 gut funktioniert.  Und DASH wird haupts√§chlich von Google (Chrome und Android) unterst√ºtzt und kann nicht unter iOS gespielt werden. <br><br><h3>  Player-Architektur </h3><br>  Wir haben das Video mehr oder weniger aussortiert. Nun wollen wir sehen, wie jeder Player aussieht. <br><br><img src="https://habrastorage.org/webt/li/uj/ra/liujrart9xshdsg8d1ffcgztm6g.jpeg"><br><br>  Beginnen wir mit dem Netzwerkteil: Beim Starten eines Videos folgt der Player dem Manifest, w√§hlt irgendwie die Qualit√§t aus, folgt dann dem Segment, l√§dt es herunter, muss dann die Frames dekodieren, versteht, dass sich gen√ºgend Frames im Puffer f√ºr die Wiedergabe befinden, und startet dann die Wiedergabe. <br><br>  Die allgemeine Architektur des Spielers: <br><br><img src="https://habrastorage.org/webt/-z/n2/1q/-zn21q-9ufwdrtdwgongpnk9bcg.jpeg"><br><br>  Es gibt einen Netzwerkteil, einen Socket, von dem die Daten stammen. <br><br>  Danach - ein Demultiplexer oder etwas, das Audio- und Videostreams von einem Transport (HLS / DASH) erh√§lt.  Sie sendet sie an die entsprechenden Codecs. <br><br>  Codecs dekodieren Video und Audio, und dann passiert das Interessanteste: Sie m√ºssen synchronisiert werden, damit Video und Audio gleichzeitig abgespielt werden.  Hierf√ºr gibt es verschiedene Mechanismen, die auf Zeitstempeln basieren. <br><br>  Dann m√ºssen Sie es irgendwo rendern - in Textur, Oberfl√§che, GL oder Metall, √ºberall. <br><br>  Und am Eingang befindet sich eine Ladesteuerung, die die Daten l√§dt und den Puffer steuert. <br><br>  Wie sieht die Laststeuerung bei allen Spielern aus?  Es gibt einige Datenmengen, die heruntergeladen werden m√ºssen.  Der Spieler wartet, bis er heruntergeladen wurde, beginnt dann zu spielen und wir laden weiter herunter.  Wir haben die maximale Puffergrenze, bei deren Erreichen der Download stoppt.  Danach sinkt w√§hrend der Wiedergabe die Datenmenge im Puffer - und es gibt einen Mindestrand, an dem das Laden beginnt.  Das alles lebt also auch: <br><br><img src="https://habrastorage.org/webt/4z/qj/rr/4zqjrrvsfqngzhxe9dx6h_kncfw.jpeg"><br><br>  Wie sieht der Hauptschleifen-Thread aus?  Spieler sind mit dem Konzept des ‚ÄûTick Threads‚Äú vertraut, es scheint hier zu sein.  Es gibt einen Teil, der f√ºr das Netzwerk verantwortlich ist und alles in einem Puffer stapelt.  Es gibt einen Extraktor, der es entpackt und an die Codecs sendet, wo sein Zwischenpuffer und dann zum Rendern gehen.  Und Sie haben ein H√§kchen, das sie verschiebt und steuert und sich mit der Synchronisation befasst. <br><br><img src="https://habrastorage.org/webt/1e/1f/g6/1e1fg6x4ncbeslmzch3timofmfs.jpeg"><br><br>  Drau√üen haben Sie eine Anwendung, die einige Befehle √ºber eine Nachrichtenwarteschlange sendet und einige Informationen √ºber Listener empf√§ngt.  Und manchmal kann ein Gegendruck auftreten, der die Qualit√§t verringert - beispielsweise in einer Situation, in der Ihr Puffer leer ist oder der Render nicht mehr zurechtkommt (z. B. werden Drop-Frames angezeigt). <br><br><h3>  Sch√§tzer </h3><br>  Bei der Anpassung st√ºtzt sich der Player auf zwei Hauptparameter: Netzwerkgeschwindigkeit und Datenpuffer. <br><br>  So sieht es aus: Zun√§chst wird eine bestimmte Qualit√§t reproduziert, beispielsweise 720p.  Sie haben einen wachsenden Puffer, der immer mehr zwischengespeichert wird.  Dann w√§chst die Geschwindigkeit, Sie verstehen, dass Sie noch mehr herunterladen k√∂nnen, der Puffer w√§chst.  Und in diesem Moment verstehen Sie, dass Sie einige Grenzen des Mindestpuffers √ºberschreiten, wenn Sie die folgende Qualit√§t ausprobieren k√∂nnen. <br><br><img src="https://habrastorage.org/webt/ef/ti/ch/eftichq4decehj34b_ekowarlmi.jpeg"><br><br>  Es ist klar, dass Sie es sorgf√§ltig versuchen m√ºssen: Es gibt auch einen Sch√§tzer, der angibt, ob Sie diese Qualit√§t in Bezug auf die Netzwerkgeschwindigkeit erreichen k√∂nnen.  Wenn Sie in diese Bewertung passen und der Pufferbestand dies zul√§sst, wechseln Sie beispielsweise zu 1080p und spielen weiter. <br><br><h3>  √úberdruckschutz </h3><br>  Bei uns erschien sie im Laufe der Zeit durch Versuch und Irrtum.  Die Notwendigkeit daf√ºr entsteht, wenn Sie Ihre Ausr√ºstung leicht √ºberlasten. <br><br>  Es gibt eine Situation, in der das Netzwerk w√§hrend der Wiedergabe stumpf wird oder die Ressourcen im Backend zur Neige gehen.  Wenn der Player die Wiedergabe fortsetzt, beginnt er aufzuholen. <br><br>  In diesem Moment hat sich im Manifest des Spielers eine riesige Anzahl von Segmenten angesammelt, die alle schnell auf einmal heruntergeladen werden und wir bekommen einen "Verkehrssto√ü".  Die Situation kann sich verschlimmern, wenn auf den Clients eine Zeit√ºberschreitung auftritt und der Player beginnt, die Daten erneut abzufragen.  Daher ist es unbedingt erforderlich, einen Gegendruck im System vorzusehen. <br><br>  Der erste einfache Weg, den wir nat√ºrlich verwenden, ist der Throttler auf dem Server.  Er versteht, dass der Verkehr endet, die Qualit√§t verringert und die Kunden absichtlich verlangsamt, um nicht genau diesen Schlag zu bekommen. <br><br><img src="https://habrastorage.org/webt/bn/ed/nz/bnednzqso81wrz0doypdlaa2phq.jpeg"><br><br>  Dies wirkt sich jedoch nicht sehr gut auf die Sch√§tzer aus.  Sie k√∂nnen die gleichen "Wendungen" erzeugen.  Unterst√ºtzen Sie daher nach M√∂glichkeit die Entfernung von Qualit√§t aus dem Manifest.  Dazu m√ºssen Sie entweder das Manifest regelm√§√üig aktualisieren oder, wenn es einen Feedback-Kanal gibt, den Befehl zum Entfernen der Qualit√§t geben, und der Player wechselt automatisch zu einem anderen, niedrigeren. <br><br><h3>  Spieler </h3><br>  Unter iOS gibt es nur nativen AVPlayer, unter Android gibt es jedoch eine Auswahl.  Es gibt einen nativen MediaPlayer, aber einen Open Source Java-basierten ExoPlayer, den Anwendungen "mitbringen".  Was sind ihre Vor- und Nachteile? <br><br>  Vergleichen Sie alle drei: <br><br><img src="https://habrastorage.org/webt/tf/cr/lg/tfcrlg3alc4srbn9r3plynsxqna.jpeg"><br><br>  Im Fall von adaptivem Streaming spielt ExoPlayer DASH / HLS und verf√ºgt √ºber viele erweiterbare Module f√ºr andere Protokolle, w√§hrend AVPlayer immer schlechter wird. <br><br>  Die Unterst√ºtzung von Betriebssystemversionen ist im Prinzip f√ºr alle √ºberall geeignet. <br><br>  Beim Vorabrufen wissen Sie, dass Sie nach dem Ende eines Videos Folgendes auf dem Band abspielen und vorab laden m√∂chten. <br><br>  Es gibt ein Problem mit Bugfixes von nativen Spielern.  Im Fall von ExoPlayer rollen Sie es einfach in eine neue Version Ihrer Anwendung, aber in nativem AVPlayer und MediaPlayer wird der Fehler erst in der n√§chsten Betriebssystemversion behoben.  Wir sind schmerzhaft darauf gesto√üen: In iOS 8.01 wurde unser Video schlecht abgespielt, in iOS 8.02 funktionierte das gesamte Portal nicht mehr, in 8.03 funktionierte alles wieder.  Und in diesem Fall hing nichts von uns ab. Wir sa√üen nur da und warteten darauf, dass Apple die n√§chste Version herausbrachte. <br><br>  Das ExoPlayer-Team spricht √ºber die Ineffizienz des Energieverbrauchs bei Audio.  Es gibt allgemeine Empfehlungen von Google: Um Audio abzuspielen, verwenden Sie MediaPlayer f√ºr alles andere Exo. <br><br>  Verstanden werden wir ExoPLayer mit DASH f√ºr Videos unter Android und AVPlayer mit HLS unter iOS verwenden. <br><br><h3>  Schneller erster Frame </h3><br>  Denken Sie auch hier an die Zeit bis zum ersten Frame.  So sieht es unter iOS HLS aus: zuerst RTT hinter dem Manifest, dann eine weitere RTT hinter dem verschachtelten Manifest, erst dann - das Segment abrufen und spielen.  In Android ist eine RTT weniger, es beginnt etwas besser. <br><br><img src="https://habrastorage.org/webt/gu/b7/hx/gub7hxr1ex5bhq6vanms80ht7x0.jpeg"><br><br><h3>  Puffergr√∂√üe </h3><br>  Nun besch√§ftigen wir uns mit den Puffern.  Wir haben eine Mindestmenge an Daten, die heruntergeladen werden m√ºssen, bevor wir mit dem Spielen beginnen.  In AVPlayer wird dieser Wert mit AVPlayerItem PreferredForwardBufferDuration konfiguriert. <br><br><img src="https://habrastorage.org/webt/lm/cs/mg/lmcsmgwqpuukx1lsowi_xuneiba.jpeg"><br><br>  Unter Android verf√ºgt ExoPlayer √ºber viel mehr Konfigurationsmechanismen.  Es gibt denselben Mindestpuffer, der zum Starten ben√∂tigt wird.  Es gibt jedoch auch eine separate Einstellung f√ºr das Zur√ºckweisen (wenn Ihr Netzwerk ausfiel, gingen die Daten aus dem Puffer aus und es wurde zur√ºckgegeben): <br><br><img src="https://habrastorage.org/webt/bs/wn/gj/bswngj3l6icqyk3detrxe82ve2s.jpeg"><br><br>  Was ist der Gewinn?  Wenn Sie ein gutes Netzwerk haben, starten Sie schnell und k√§mpfen um einen schnellen ersten Frame. Zum ersten Mal k√∂nnen Sie versuchen, ein Risiko einzugehen.  Wenn das Netzwerk jedoch w√§hrend der Wiedergabe unterbrochen wird, m√ºssen Sie offensichtlich mehr Pufferung anfordern, um w√§hrend der Zur√ºckweisung wiederzugeben, damit kein wiederholtes Problem auftritt. <br><br><h3>  Originalqualit√§t </h3><br><br><img src="https://habrastorage.org/webt/ec/1r/ns/ec1rnsjfbh1yk0cxiusj5x06w7g.jpeg"><br><br>  HLS unter iOS hat ein cooles Problem: Es beginnt immer mit der ersten Qualit√§t im m3u8-Manifest.  Was du ihm zur√ºckgibst, wird beginnen.  Und nur dann wird die Download-Geschwindigkeit gemessen und die Wiedergabe in normaler Qualit√§t gestartet.  Es ist klar, dass dies nicht erlaubt sein sollte. <br><br>  Logische Optimierung - Qualit√§t neu sortieren.  Entweder auf dem Server (durch Hinzuf√ºgen eines zus√§tzlichen Parameters zur bevorzugten Qualit√§t wird das Manifest neu sortiert) oder auf dem Client (erstellen Sie einen Proxy, der dies f√ºr Sie erledigt). <br><br>  Und unter Android gibt es daf√ºr einen DefaultBandwidthMeter-Parameter.  Es gibt einen Wert an, der die Standardbandbreite Ihres Bandes ber√ºcksichtigt. <br><br><img src="https://habrastorage.org/webt/vs/b3/m8/vsb3m8lvbwp3kwuc2mi9btg3im4.jpeg"><br><br>  So funktioniert es: Der Code enth√§lt eine riesige Konstantentabelle, und die Parameter sind einfach - das Land (Region) und die Art der Verbindung (Wi-Fi, 2G, 3G, 4G).  Was sind die Bedeutungen?  Wenn Sie beispielsweise √ºber WLAN verf√ºgen und sich in den USA befinden, betr√§gt Ihre anf√§ngliche Bandbreite 5,6 Mbit / s.  Und wenn 3G 700 kbps ist. <br><br>  Es ist ersichtlich, dass 4G nach Sch√§tzungen von Google in Russland 2-3 Mal schneller ist als in Amerika. <br><br>  Es ist klar, dass Russland ein gro√ües Land ist, und ein solches Setup hat uns √ºberhaupt nicht gepasst.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie dies einfach tun m√∂chten, merken Sie sich daher den vorherigen Wert f√ºr das aktuelle Netzwerk, subtrahieren Sie f√ºr alle F√§lle eine Einheit und starten Sie es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine gro√üe Anwendung haben, die Videos auf der ganzen Welt wiedergibt, sammeln Sie Statistiken zu Subnetzen und empfehlen Sie vom Server die Qualit√§t, von der aus Sie beginnen sollen. </font><font style="vertical-align: inherit;">Beachten Sie, dass es nach dem Puffern ratsam ist, den Wert des Puffers zu erh√∂hen (unter Android ist dies problemlos zul√§ssig).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So beschleunigen Sie den R√ºcklauf </font></font></h3><br>         (seek),       ,   . , ,       ,    . <br><br><img src="https://habrastorage.org/webt/ay/be/50/aybe50r6ymkweqtj9wygtuhdxga.jpeg"><br><br>   ,     ,  -     .   iOS,    ,       ,        ,    (  ,     ,   ). <br><br>  ExoPlayer   2.7.0   ,    ,    ¬´  ¬ª.                .  ,    . <br><br><img src="https://habrastorage.org/webt/3j/3a/i_/3j3ai__smnqi_oytag8ny1rico0.jpeg"><br><br>       (     ,        ),     - ,     Android  prepare(mediaSource),   seekTo().   ,   ,     ,   .     ‚Äî     : <br><br><img src="https://habrastorage.org/webt/pe/oy/d_/peoyd_g_aartazc_lofykbivmn0.jpeg"><br><br> ,     (  ,  ),    .     ( 100 ),            ,     . <br><br><img src="https://habrastorage.org/webt/0l/uh/7s/0luh7sbufo5x4qmxbscuzvd-xwk.jpeg"><br><br><h3>  </h3><br>  iOS   ,    Android    legacy-. <br>    TextureView.   ,     ,    ,   ,   UI.    ‚Äî      . <br><br>  SurfaceView.    ,       .     Android-        . YouTube       ,    . <br><br>    GLSurfaceView ‚Äî     .     ,         . <br><br><img src="https://habrastorage.org/webt/yx/tw/wg/yxtwwgajtkdlsclcsyadebja9cg.jpeg"><br><br>   :  ,     ExoPlayer,       23%.  ¬´¬ª   10%.        4% .     4% ‚Äî  ,   . <br><br><h3> :   Android </h3><br><ul><li>  MediaPlayer  ,     ExoPlayer </li><li>  start, seek, swap </li><li>   ,    </li><li>   view   </li></ul><br><h3> :   iOS </h3><br>  iOS  : <br><br><ul><li>     RTT  HLS  AVPlayer </li><li>   </li><li>     AVPlayer#pause </li><li>  ‚Äî  ,     iOS </li></ul><br><br>       DASH-,    ¬´  live-¬ª.  : <br><br><ul><li> cURL  GCDAsyncSocket </li><li> AVAssetReader,     </li><li> CADisplayLink </li><li> AVSampleBufferDisplayLayer </li></ul><br><br>  ,     .       28%, ¬´¬ª   6%.   ,     HLS  DASH       100 /,     6%. <br><br>    iOS  : <br><br><ul><li>  start  seek </li><li>  HLS over Fragmented mp4 </li><li>   DASH- </li></ul><br><br> ,        . <br><br><h3>    : </h3><br>    ,   ,    . <br><br><ul><li>     (  mp4) </li><li>    (ExoPlayer, AVPlayer) </li><li>    firstFrame, seek, emptyBuffer </li><li>       </li><li>    (      ) </li><li>    - ,  .     4,    :  performance,  ,  . </li></ul><br><br>   ‚Äî  . <br><br><h2>  :     </h2><br>  ,        ? <br><br><img src="https://habrastorage.org/webt/ji/0p/pk/ji0ppk9wacev99cddvsw0alqjj0.jpeg"><br><br>  API      .  API         iOS  Android,    ‚Äî    ,  . <br><br> :   - wrapper    ,    POSIX-,    ,        . <br><br> <b>     ?</b> <br><br><ul><li>   </li><li>    </li><li>     </li><li>  Schnellstart </li></ul><br><br> <b>    ?</b> <br><br><ul><li>  bandwidth </li><li>  </li><li>     </li><li>   (N x RTT,       RTT) </li></ul><br><br><h3>     </h3><br><br><img src="https://habrastorage.org/webt/-b/ae/va/-baevaqjpxvp9nnr2ecdrjmgqr4.jpeg"><br><br>   ‚Äî   .     ,       ,    . <br><br>       :        ,      ,      .       ‚Äî  low latency. <br><br> ,     ‚Äî    .           . <br><br>   ‚Äî    4K. ,          ,        .      ,     30  ,           .     ,    . <br><br><h3>  </h3><br>   , , ,     .         (       100 ). <br><br> -    ,  ,         . <br><br>       .       100      ,  . ,        300 kbps  FullHD-  480p,     FullHD   .     ,  :  ,       ,   overhead-.      . <br><br>      : <br><br><img src="https://habrastorage.org/webt/kk/xs/xu/kkxsxux2cegqqdg5w9cuny-wzps.jpeg"><br><br>     ,      ,   .     ,     -     ,       ,   . <br><br>       MediaCodec  VideoToolbox (   ).      Server Transcoder. <br><br>   ‚Äî   ,       . <br><br><h3>   </h3><br>      ,     .  ,  ,    reliability ‚Äî  ( ), throughput ‚Äî   (   )  low latency ‚Äî   (    ). <br><br><img src="https://habrastorage.org/webt/zz/pc/xm/zzpcxmj1krgbg9qpfgxbb2q32wi.jpeg"><br><br>        ,   .       ,  - . <br><br><h3>  </h3><br> ,    : RTMP  WebRTC ‚Äî  , OKMP ‚Äî   . <br><br>  ,  RTMP   TCP,    ‚Äî UDP. <br><br><h3> RTMP </h3><br>  Was gibt er?  In gewisser Weise ist dies ein Standard, der von allen Diensten unterst√ºtzt wird - YouTube, Twitch, Flash, OK.  Sie verwenden es, damit Benutzer Live-Streams hochladen k√∂nnen.  Wenn Sie einen Live-Stream an einen Drittanbieter streamen m√∂chten, m√ºssen Sie h√∂chstwahrscheinlich mit RTMP arbeiten. <br><br>  Die minimale Verz√∂gerung, die wir von einem Bandlaufwerk zu einem Player erreichen konnten, betr√§gt 300 ms, aber dies ist in einem idealen Netzwerk bei sch√∂nem Wetter.  Wenn wir ein echtes Netzwerk haben, w√§chst die Verz√∂gerung normalerweise auf 2-3 Sekunden, und wenn alles im Netzwerk schlecht ist, kann sie auf mehrere zehn Sekunden anwachsen. <br><br>  RTMP unterst√ºtzt das √Ñndern der Aufl√∂sung und der Bitrate im laufenden Betrieb (die anderen genannten Protokolle sind dieselben, es gibt jedoch fehlerhafte Informationen zu RTMP, dass keine √Ñnderungen im laufenden Betrieb vorgenommen werden). <br><br>  Von den Minuspunkten: Basierend auf TCP (wir werden sp√§ter erkl√§ren, warum dies schlecht ist) ist die Verz√∂gerung unkontrolliert. <br><br>  Wenn Sie sich das Dreieck ansehen, kann RTMP keine geringe Latenz geben.  Es kann erhalten werden, aber √ºberhaupt nicht garantiert. <br><br>  Au√üerdem ist RTMP ein kleiner Mist: Es unterst√ºtzt keine neuen Codecs, da Adobe dies nicht tut und die Dokumentation ziemlich alt und krumm ist. <br><br><img src="https://habrastorage.org/webt/e_/p6/sm/e_p6sm4qifhwi6ftl0hgl-aiodk.jpeg"><br><br>  Warum ist TCP nicht f√ºr Live-√úbertragungen geeignet?  TCP gibt eine Zustellgarantie: Die Daten, die Sie in den Socket eingeben, werden genau in der Reihenfolge und in der Form geliefert, in der Sie sie dort abgelegt haben.  Nichts wird fallen gelassen oder neu angeordnet.  TCP wird dies entweder tun oder sterben.  Dies bedeutet jedoch, dass eine Verz√∂gerungsgarantie ausgeschlossen ist - er kann keine alten Daten l√∂schen, die m√∂glicherweise bereits gesendet werden m√ºssen.  Der Puffer, die R√ºckst√§nde usw. beginnen zu wachsen. <br><br><img src="https://habrastorage.org/webt/nt/vw/tb/ntvwtb4fybykxeul4gf9cmhlnva.jpeg"><br><br>  Zur Veranschaulichung das Head of Line-Blockierungsproblem.  Es findet sich nicht nur im Streaming, sondern auch in vielen anderen F√§llen. <br><br>  Was ist das?  Wir haben einen anfangs leeren Empf√§ngerpuffer.  Wir empfangen Daten von irgendwoher: viele Daten und viele IP-Pakete.  Wir haben das erste IP-Paket empfangen, und auf dem Empf√§nger k√∂nnen wir mit der Methode recv () dieses Paket subtrahieren, Daten abrufen, verlieren, rendern.  Aber dann ging pl√∂tzlich das zweite Paket verloren.  Was passiert als n√§chstes? <br><br>  Um ein verlorenes IP-Paket wiederherzustellen, muss TCP erneut √ºbertragen.  Dazu m√ºssen Sie RTT ausgeben, w√§hrend die erneute √úbertragung ebenfalls verloren gehen kann, und wir werden in Zyklen vorgehen.  Wenn es viele Pakete gibt, wird dies definitiv passieren. <br><br>  Danach kommen viele Daten, die wir nicht lesen k√∂nnen, weil wir stehen und auf das zweite Paket warten.  Obwohl er einen Broadcast-Frame zeigte, der vor f√ºnf Minuten passiert ist und nicht mehr ben√∂tigt wird. <br><br>  Um ein anderes Problem zu verstehen, schauen wir uns die RTMP-Anpassung an.  Wir machen die Anpassung auf der Absenderseite.  Wenn das Netzwerk Daten nicht mit der Geschwindigkeit stopfen kann, mit der sie in den Socket gestellt werden, wird der Puffer gef√ºllt und der Socket sagt EWOULDBLOCK oder wird blockiert, wenn in diesem Moment die Blockierung verwendet wird. <br><br><img src="https://habrastorage.org/webt/oy/6z/uy/oy6zuyjliks8epvjx4g83uq5d_m.jpeg"><br><br>  Erst in diesem Moment verstehen wir, dass wir Probleme haben und die Qualit√§t reduzieren m√ºssen. <br><br>  Angenommen, wir haben ein Netzwerk mit einer bestimmten Geschwindigkeit von 4 Mbit / s.  Wir haben eine Sockelgr√∂√üe von 250 KB gew√§hlt (entsprechend 0,5 Sekunden bei unserer Geschwindigkeit).  Pl√∂tzlich fiel das Netzwerk zehnmal aus - dies ist eine normale Situation.  Wir haben 400 kbps.  Der Puffer f√ºllte sich schnell in einer halben Sekunde und erst in diesem Moment verstehen wir, dass wir herunterschalten m√ºssen. <br><br><img src="https://habrastorage.org/webt/te/7l/0p/te7l0pkef3gz8ntjm7gq27yvxnm.jpeg"><br><br>  Das Problem ist jedoch, dass wir einen 250-KB-Puffer haben, der 5 Sekunden lang √ºbertragen wird.  Wir sind bereits v√∂llig im R√ºckstand: Wir m√ºssen zuerst die alten Daten verschieben, und erst dann werden neue und angepasste Daten die Echtzeit einholen. <br><br>  Was zu tun ist?  Hier ist unser ‚ÄûDreieck der Kompromisse‚Äú nur relevant. <br><br><img src="https://habrastorage.org/webt/s2/0k/fa/s20kfaykbgel7si5vtpcjiwla1w.jpeg"><br><br><ul><li>  Wir k√∂nnen den Senderpuffer reduzieren, anstatt 0,5 Sekunden - 0,1 Sekunden.  Wir verlieren jedoch Bandbreite, da wir h√§ufig in Panik geraten und herunterschalten.  Dar√ºber hinaus funktioniert TCP so, dass, wenn Sie einen Senderpuffer kleiner als RTT setzen, Sie nicht die volle Bandbreite des Kanals nutzen k√∂nnen, dieser um ein Vielfaches abnimmt. </li><li>  Wir k√∂nnen den Empf√§ngerpuffer erh√∂hen.  Mit einem gro√üen Puffer, Daten ankommen, k√∂nnen wir einige Unregelm√§√üigkeiten innerhalb des Puffers ausgleichen.  Aber nat√ºrlich verlieren wir die geringe Latenz, da wir sofort einen 5-Sekunden-Puffer eingerichtet haben. </li><li>  Wir k√∂nnen alte Daten aggressiv l√∂schen.  In TCP besteht die einzige M√∂glichkeit darin, die Verbindung zu trennen und neu zu erstellen.  Wir verlieren an Zuverl√§ssigkeit, weil der Spieler zu diesem Zeitpunkt nichts zu zeigen hat. </li></ul><br><br><h3>  WebRTC </h3><br>  Dies ist eine C ++ - Bibliothek, die bereits Erfahrungen ber√ºcksichtigt und auf UDP ausgef√ºhrt wird.  Builds unter iOS, Android, ist in Browser integriert, unterst√ºtzt HTML5.  Da es f√ºr P2P-Anrufe gesperrt ist, betr√§gt die Verz√∂gerung 0,1-1 Sekunden. <br><br><img src="https://habrastorage.org/webt/gu/jv/co/gujvcogf5z-3szbr4b3fqxcs38m.jpeg"><br><br>  Von den Minuspunkten: Dies ist eine monolithische Bibliothek mit einer F√ºlle von Verm√§chtnissen, die nicht entfernt werden k√∂nnen.  Aufgrund seines Fokus auf P2P-Aufrufe wird au√üerdem eine geringe Latenz priorisiert.  Es scheint, dass wir das wollten, aber daf√ºr opfert sie andere Parameter.  Und es gibt keine Einstellungen zum √Ñndern der Priorit√§ten. <br><br>  Es sollte auch ber√ºcksichtigt werden, dass die Bibliothek f√ºr eine Konversation zwischen zwei Clients ohne Server clientorientiert ist.  Sie m√ºssen nach einem Server eines Drittanbieters suchen oder einen eigenen schreiben. <br><br>  Was soll ich w√§hlen - RTMP oder WebRTC?  Wir haben beide Protokolle implementiert und in verschiedenen Szenarien getestet.  In der Grafik hat WebRTC eine geringe Verz√∂gerung, aber einen geringen Durchsatz, w√§hrend RTMP das Gegenteil hat.  Und zwischen ihnen ist ein Loch. <br><br>  Und wir wollten ein Protokoll erstellen, das diese L√ºcke vollst√§ndig abdeckt und sowohl im WebRTC- als auch im RTMP-Modus funktioniert.  Sie machten und nannten es OKMP. <br><br><img src="https://habrastorage.org/webt/xq/8y/p1/xq8yp1lyi_jxdqc8h-tyzw0grgi.jpeg"><br><h3>  Okmp </h3><br>  Dies ist ein flexibles Protokoll f√ºr UDP. <br><br>  Unterst√ºtzt Multiplexing.  Was bedeutet das: Es gibt mehrere Kan√§le innerhalb der Sitzung (im Fall von OK Live - der Manager, Audio und Video).  Innerhalb jedes Kanals wird garantiert, dass die Daten in einer bestimmten Reihenfolge geliefert werden (es wird jedoch nicht garantiert, dass sie selbst geliefert werden), und die Reihenfolge zwischen den Kan√§len wird nicht garantiert, da dies nicht wichtig ist. <br><br>  Was gibt es?  Erstens gab es uns die M√∂glichkeit, Kan√§le zu priorisieren.  Wir k√∂nnen sagen, dass der Steuerkanal eine hohe Priorit√§t hat, der Ton mittel ist und das Video niedrig ist.  Video-Jitter und ungleichm√§√üige Video√ºbertragung sind leichter zu verschleiern, und der Benutzer hat weniger Probleme mit Videoproblemen als mit unangenehmem Stottern von Audio. <br><br><img src="https://habrastorage.org/webt/vd/nq/pp/vdnqppsvt33b7j82m2hxdgnf1ag.jpeg"><br><br>  Zus√§tzlich bietet unser Protokoll eine optionale Liefergarantie.  Wir k√∂nnen sagen, dass wir auf einem bestimmten Kanal im TCP-Modus mit garantierter Zustellung arbeiten und im Rest einige Drops zulassen. <br><br>  Dank dessen kann auch eine Verz√∂gerungsgarantie gegeben werden: Es gibt keine Garantie f√ºr eine Verz√∂gerung auf dem TCP-Kanal, aber auf den anderen, auf denen Tropfen zul√§ssig sind, wird ein Schwellenwert festgelegt, nach dem die Daten zu fallen beginnen und wir die Lieferung alter Daten einstellen. <br><br>  F√ºr Audio betr√§gt dies beispielsweise 1 Sekunde und f√ºr Video 0,5 Sekunden.  Warum ist die Schwelle anders?  Dies ist ein weiterer Priorisierungsmechanismus.  Da es f√ºr uns wichtiger ist, dass das Audio fl√ºssig ist, lassen wir das Video zun√§chst fallen. <br><br>  Unser Protokoll ist flexibel konfiguriert: Es gibt keinen einzigen Betriebsmodus. Wir √§ndern die Einstellungen im laufenden Betrieb, um in den gew√ºnschten Modus zu wechseln, ohne dass dies f√ºr den Benutzer sichtbar ist.  Warum?  Zum Beispiel f√ºr dieselben Videoanrufe: Wenn ein Videoanruf in einem Stream gestartet wird, √ºbertragen wir ihn leise in den Modus mit niedriger Latenz.  Und dann zur√ºck zum Durchsatzmodus f√ºr maximale Qualit√§t. <br>  Implementierungsschwierigkeiten <br><br><img src="https://habrastorage.org/webt/zv/jl/wk/zvjlwkvrqjhldwib10ocewpc7iu.jpeg"><br><br>  Wenn Sie sich entscheiden, Ihr Protokoll in UDP zu schreiben, werden Sie nat√ºrlich auf einige Probleme sto√üen.  Mit TCP erhalten wir Mechanismen, die wir selbst auf UDP schreiben m√ºssen: <br><br><ul><li>  Packen / Entpacken.  Sie m√ºssen die Daten in Pakete mit einer Gr√∂√üe von ca. 1,5 KB schneiden, damit sie in das MTU-Netzwerk passen. </li><li>  Nachbestellung.  Sie senden Pakete in einer Reihenfolge, und sie werden unterwegs neu angeordnet und kommen in einer anderen.  Um dies zu √ºberwinden, m√ºssen Sie die Reihenfolge mit der Paketnummer festlegen und diese am Empf√§nger neu anordnen. </li><li>  Verluste.  Nat√ºrlich gibt es Verluste.  Wenn ein Verlust auftritt, muss der Empf√§nger dem Absender separat mitteilen, dass "ich diese Pakete empfangen habe, diese aber nicht erhalten habe", und der Absender muss die fehlenden Pakete erneut √ºbertragen.  Oder sie fallen lassen. </li><li>  Flusskontrolle  Wenn der Empf√§nger keine Daten empf√§ngt, nicht mit der Geschwindigkeit Schritt h√§lt, mit der wir sie verschieben, k√∂nnen die Daten verloren gehen. Wir m√ºssen diese Situation verarbeiten.  Im Fall von TCP wird der Sende-Socket blockiert, und im Fall von UDP wird er nicht blockiert. Sie m√ºssen sich dar√ºber im Klaren sein, dass der Empf√§nger keine Daten empf√§ngt, und die gesendete Datenmenge reduzieren. </li><li>  √úberlastungskontrolle.  √Ñhnliches gilt, nur in diesem Fall ist das Netzwerk gestorben.  Wenn wir Pakete an das verstorbene Netzwerk senden, zerst√∂ren wir nicht nur unsere Verbindung, sondern auch die benachbarten. </li><li>  Verschl√ºsselung  Sie m√ºssen sich um die Verschl√ºsselung k√ºmmern </li><li>  ... und vieles mehr </li></ul><br><br><h3>  OKMP vs RTMP </h3><br>  Was haben wir bekommen, als wir angefangen haben, OKMP anstelle von RTMP zu verwenden? <br><br><ul><li>  Die durchschnittliche Erh√∂hung der OKLive-Bitrate betr√§gt 30%. </li><li>  Jitter (Ma√ü f√ºr ungleichm√§√üige Paketankunft) - 0% (im Durchschnitt gleich). </li><li>  Jitter Audio - -25% </li><li>  Jitter Video - 40% </li></ul><br><br>  √Ñnderungen in Audio und Video - Demonstration der Priorit√§ten in unserem Protokoll.  Audio geben wir eine h√∂here Priorit√§t, und es begann aufgrund des Videos reibungsloser zu kommen. <br><br><h3>  So w√§hlen Sie ein Protokoll f√ºr das Streaming aus </h3><br><br><img src="https://habrastorage.org/webt/_l/g3/vs/_lg3vsf20spfixqon5z0m4fwa0w.jpeg"><br><br>  Wenn Sie eine geringe Latenz ben√∂tigen - WebRTC. <br><br>  Wenn Sie mit externen Diensten arbeiten und Videos auf Diensten von Drittanbietern ver√∂ffentlichen m√∂chten, m√ºssen Sie RTMP verwenden. <br><br>  Wenn Sie ein auf Ihre Skripte zugeschnittenes Protokoll w√ºnschen, implementieren Sie Ihr eigenes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467669/">https://habr.com/ru/post/de467669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467659/index.html">Beschleunigen Sie die Ausf√ºhrung von Aufgaben am Beispiel einer zus√§tzlichen Konfiguration des aktualisierten HyperX FURY DDR4-Speichers erheblich</a></li>
<li><a href="../de467661/index.html">Dosimeter f√ºr Seryozha. Teil I. Polimaster - Nuklidj√§ger</a></li>
<li><a href="../de467663/index.html">Unterst√ºtzung f√ºr hardwarespezifische Anweisungen in .NET Core (jetzt nicht nur SIMD)</a></li>
<li><a href="../de467665/index.html">ROS LKW Wagen. Teil 5. Arbeiten in Rviz und Pavillon: Xacro, neue Sensoren</a></li>
<li><a href="../de467667/index.html">Organisation Projektplanung (Teil 4)</a></li>
<li><a href="../de467671/index.html">NLX Retro Computer</a></li>
<li><a href="../de467673/index.html">Eingebaute Go-Funktionen</a></li>
<li><a href="../de467675/index.html">Modellieren des Anwendungsstatus mithilfe von Store-Objekten in SwiftUI</a></li>
<li><a href="../de467677/index.html">Tests oder Typen</a></li>
<li><a href="../de467679/index.html">PyCrunch - Intelligente Testausf√ºhrung und visuelle Codeabdeckung in der IDE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>