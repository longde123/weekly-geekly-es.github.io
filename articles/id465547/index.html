<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸ’» ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ» ğŸ  Panduan SQL: Cara Menulis Pertanyaan dengan Lebih Baik (Bagian 1) ğŸ‘ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ¥ª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pelajari tentang antipatterns, rencana eksekusi, kompleksitas waktu, penyetelan kueri, dan optimasi SQL 
 Structured Query Language (SQL) adalah keter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan SQL: Cara Menulis Pertanyaan dengan Lebih Baik (Bagian 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3>  Pelajari tentang antipatterns, rencana eksekusi, kompleksitas waktu, penyetelan kueri, dan optimasi SQL </h3><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Structured Query Language (SQL) adalah keterampilan yang sangat diperlukan dalam industri ilmu komputer, dan secara umum, mempelajari keterampilan ini relatif sederhana.  Namun, kebanyakan orang lupa bahwa SQL tidak hanya tentang menulis kueri, itu hanya langkah pertama lebih jauh.  Memastikan kinerja kueri atau mencocokkan konteks tempat Anda bekerja adalah hal yang sama sekali berbeda. <br><br>  Inilah sebabnya mengapa panduan SQL ini akan memberi Anda gambaran kecil dari beberapa langkah yang dapat Anda lalui untuk mengevaluasi permintaan Anda: <br><br><ul><li>  Pertama, Anda akan mulai dengan gambaran singkat tentang pentingnya pembelajaran SQL untuk bekerja di bidang ilmu data; </li><li>  Selanjutnya, Anda akan terlebih dahulu mempelajari cara memproses dan mengeksekusi query SQL untuk memahami pentingnya membuat query kualitas.  Lebih khusus lagi, Anda akan melihat bahwa permintaan dianalisis, ditulis ulang, dioptimalkan dan akhirnya dievaluasi. </li><li>  Dengan mengingat hal ini, Anda tidak hanya akan beralih ke beberapa antipemicu kueri yang dibuat pemula saat menulis kueri, tetapi juga mempelajari lebih lanjut tentang alternatif dan solusi untuk kemungkinan kesalahan ini;  Selain itu, Anda akan mempelajari lebih lanjut tentang pendekatan kueri berbasis set. </li><li>  Anda juga akan melihat bahwa antipatterns ini berasal dari masalah kinerja dan bahwa, selain pendekatan "manual" untuk meningkatkan kueri SQL, Anda dapat menganalisis kueri Anda dengan cara yang lebih terstruktur dan mendalam, menggunakan beberapa alat lain yang membantu Anda melihat rencana kueri;  Dan </li><li>  Anda akan belajar secara singkat tentang kompleksitas waktu dan notasi O besar, untuk mendapatkan gambaran tentang kompleksitas rencana eksekusi dalam waktu sebelum menjalankan permintaan; </li><li>  Anda akan mempelajari secara singkat cara mengoptimalkan kueri Anda. </li></ul><a name="habracut"></a><br><h2>  Mengapa Anda harus belajar SQL untuk bekerja dengan data? </h2><br>  SQL masih jauh dari mati: ini adalah salah satu keterampilan yang paling dicari yang Anda temukan dalam deskripsi pekerjaan dari industri pengolahan dan analisis data, terlepas dari apakah Anda melamar analitik data, insinyur data, spesialis data atau peran lainnya.  Ini dikonfirmasi oleh 70% responden dari Survei Gaji Sains Data O 'Reilly untuk 2016, yang menunjukkan bahwa mereka menggunakan SQL dalam konteks profesional mereka.  Selain itu, dalam survei ini, SQL menonjol di atas bahasa pemrograman R (57%) dan Python (54%). <br><br>  Anda mendapatkan gambaran: SQL adalah keterampilan yang diperlukan ketika Anda bekerja untuk mendapatkan pekerjaan di industri TI. <br><br>  Tidak buruk untuk bahasa yang dikembangkan pada awal 1970-an, bukan? <br><br>  Tetapi mengapa ini sering digunakan?  Dan mengapa dia tidak mati, terlepas dari kenyataan bahwa dia ada begitu lama? <br><br>  Ada beberapa alasan: salah satu alasan pertama bisa jadi bahwa perusahaan terutama menyimpan data dalam sistem manajemen basis data relasional (RDBMS) atau dalam sistem manajemen aliran data relasional (RDSMS), dan SQL diperlukan untuk mengakses data ini.  SQL adalah <i>lingua franca</i> data: memungkinkan untuk berinteraksi dengan hampir semua basis data atau bahkan membangun data Anda sendiri secara lokal! <br><br>  Jika ini masih belum cukup, perlu diingat bahwa ada beberapa implementasi SQL yang tidak kompatibel antara vendor dan tidak selalu sesuai dengan standar.  Pengetahuan tentang SQL standar, oleh karena itu, merupakan persyaratan bagi Anda untuk menemukan jalan Anda di industri (ilmu komputer). <br><br>  Selain itu, aman untuk mengatakan bahwa teknologi yang lebih baru juga telah bergabung dengan SQL, seperti Hive, antarmuka bahasa query seperti SQL untuk meminta dan mengelola set data besar, atau Spark SQL, yang dapat digunakan untuk menjalankan query SQL.  Sekali lagi, SQL yang Anda temukan akan berbeda dari standar yang dapat Anda pelajari, tetapi kurva belajar akan jauh lebih sederhana. <br><br>  Jika Anda ingin membuat perbandingan, anggap itu sebagai pembelajaran aljabar linier: setelah memasukkan semua upaya ini ke dalam subjek yang satu ini, Anda tahu bahwa Anda dapat menggunakannya untuk menguasai pembelajaran mesin juga! <br><br>  Singkatnya, inilah mengapa Anda harus mempelajari bahasa permintaan ini: <br><br><ul><li>  Sangat mudah dipelajari, bahkan untuk pemula.  Kurva pembelajaran cukup sederhana dan bertahap, sehingga Anda akan menulis kueri sesegera mungkin. </li><li>  Ini mengikuti prinsip "belajar sekali, gunakan di mana-mana", jadi ini adalah investasi besar waktu Anda! </li><li>  Ini merupakan tambahan yang bagus untuk bahasa pemrograman;  Dalam beberapa kasus, menulis kueri bahkan lebih baik daripada menulis kode, karena lebih efisien! </li><li>  ... </li></ul><br>  Tunggu apa lagi  :) <br><br><h2>  Pemrosesan SQL dan eksekusi permintaan </h2><br>  Untuk meningkatkan kinerja kueri SQL Anda, Anda harus terlebih dahulu tahu apa yang terjadi di dalamnya ketika Anda mengklik pintasan untuk menjalankan kueri. <br><br>  Pertama, permintaan diurai menjadi pohon parse;  Permintaan dianalisis untuk kepatuhan dengan persyaratan sintaksis dan semantik.  Parser membuat representasi internal dari permintaan input.  Output ini kemudian ditransfer ke mekanisme penulisan ulang. <br><br>  Kemudian, pengoptimal harus menemukan eksekusi yang optimal atau rencana kueri untuk kueri yang diberikan.  Rencana eksekusi secara akurat menentukan algoritma mana yang digunakan untuk setiap operasi, dan bagaimana operasi dikoordinasikan. <br><br>  Untuk menemukan rencana eksekusi yang paling optimal, optimizer mendaftar semua rencana implementasi yang mungkin, menentukan kualitas atau biaya setiap rencana, menerima informasi tentang keadaan database saat ini, dan kemudian memilih yang terbaik sebagai rencana implementasi akhir.  Karena pengoptimal kueri bisa tidak sempurna, pengguna dan administrator database terkadang harus memeriksa dan menyesuaikan rencana yang dibuat oleh pengoptimal secara manual untuk meningkatkan kinerja. <br><br>  Sekarang Anda mungkin bertanya-tanya apa yang dianggap sebagai "rencana permintaan yang baik". <br><br>  Seperti yang sudah Anda baca, kualitas biaya rencana memainkan peran penting.  Lebih khusus lagi, hal-hal seperti jumlah disk I / O yang diperlukan untuk mengevaluasi paket, biaya CPU paket, dan total waktu respons yang dapat diamati oleh klien database, dan total waktu eksekusi, adalah penting.  Di sinilah konsep kompleksitas waktu muncul.  Anda akan belajar lebih banyak tentang ini nanti. <br><br>  Kemudian, rencana kueri yang dipilih dijalankan, dievaluasi oleh mekanisme eksekusi sistem, dan hasil kueri dikembalikan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br><h2>  Menulis Pertanyaan SQL </h2><br>  Mungkin tidak menjadi jelas dari bagian sebelumnya bahwa prinsip Garbage In, Garbage Out (GIGO) secara alami memanifestasikan dirinya dalam proses memproses dan mengeksekusi kueri: orang yang merumuskan kueri juga memiliki kunci untuk kinerja kueri SQL Anda.  Jika pengoptimal menerima permintaan yang diformulasikan dengan buruk, ia dapat melakukan sebanyak ... <br><br>  Ini berarti bahwa ada beberapa hal yang dapat Anda lakukan saat menulis permintaan.  Seperti yang telah Anda lihat dalam pendahuluan, tanggung jawab di sini ada dua: yaitu tidak hanya tentang menulis kueri yang memenuhi standar tertentu, tetapi juga tentang mengumpulkan ide tentang di mana masalah kinerja mungkin tersembunyi dalam kueri Anda. <br><br>  Titik awal yang ideal adalah memikirkan "tempat" dalam pertanyaan Anda di mana masalah mungkin timbul.  Dan, secara umum, ada empat kata kunci di mana pendatang baru dapat mengharapkan masalah kinerja terjadi: <br><br><ul><li> Kondisi <code>WHERE</code> ; </li><li>  Kata kunci apa pun <code>INNER JOIN</code> atau <code>LEFT JOIN</code> ;  Dan juga </li><li>  Kondisi <code>HAVING</code> ; </li></ul><br>  Tentu saja, pendekatan ini sederhana dan naif, tetapi, bagi seorang pemula, poin-poin ini adalah petunjuk yang sangat baik, dan aman untuk mengatakan bahwa ketika Anda pertama kali memulai, kesalahan terjadi di tempat-tempat ini dan, anehnya, di mana juga sulit untuk diperhatikan. <br><br>  Namun, Anda juga harus memahami bahwa kinerja adalah sesuatu yang harus menjadi bermakna.  Namun, hanya mengatakan bahwa kalimat dan kata kunci ini buruk bukan yang Anda butuhkan ketika Anda berpikir tentang kinerja SQL.  Memiliki <code>HAVING</code> <code>WHERE</code> atau <code>HAVING</code> dalam permintaan tidak berarti bahwa itu adalah permintaan yang buruk ... <br><br>  Periksa bagian selanjutnya untuk mempelajari lebih lanjut tentang antipatterns dan pendekatan alternatif untuk membangun kueri Anda.  Kiat dan trik ini dimaksudkan sebagai panduan.  Bagaimana dan jika Anda benar-benar perlu menulis ulang permintaan Anda tergantung, antara lain, pada jumlah data, basis data, dan berapa kali Anda harus menyelesaikan permintaan.  Ini sepenuhnya tergantung pada tujuan permintaan Anda dan memiliki pengetahuan sebelumnya tentang database yang dengannya Anda akan bekerja sangat penting! <br><br><h3>  1. Ambil hanya data yang diperlukan </h3><br>  Kesimpulan "semakin banyak data, semakin baik" - tidak harus diikuti saat menulis SQL: Anda berisiko tidak hanya bingung dengan mendapatkan lebih banyak data daripada yang benar-benar Anda butuhkan, tetapi kinerja mungkin menderita karena permintaan Anda menerima terlalu banyak data. <br><br>  Inilah sebabnya, sebagai suatu peraturan, Anda harus memperhatikan <code>SELECT</code> , <code>DISTINCT</code> dan pernyataan <code>LIKE</code> . <br><br><h4>  <code>SELECT</code> </h4><br>  Hal pertama yang dapat Anda periksa saat menulis kueri adalah apakah <code>SELECT</code> seringkas mungkin.  Tujuannya di sini adalah untuk menghapus kolom yang tidak perlu dari <code>SELECT</code> .  Dengan cara ini Anda memaksakan diri untuk hanya mengambil data yang melayani tujuan permintaan Anda. <br><br>  Jika Anda telah mengkorelasikan subkueri dengan <code>EXISTS</code> , Anda harus mencoba menggunakan konstanta dalam <code>SELECT</code> subkueri ini alih-alih memilih nilai kolom yang sebenarnya.  Ini sangat nyaman ketika Anda hanya memeriksa keberadaannya. <br><br>  <b>Ingat</b> bahwa subquery yang berkorelasi adalah subquery yang menggunakan nilai dari kueri eksternal.  Dan perhatikan bahwa meskipun <code>NULL</code> dapat berfungsi sebagai "konstan" dalam konteks ini, ini sangat membingungkan! <br><br>  Pertimbangkan contoh berikut untuk memahami apa yang dimaksud dengan menggunakan konstanta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Fines <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fines.driverslicensenr = drivers.driverslicensenr);</code> </pre> <br>  <b>Kiat: Sangat</b> berguna untuk mengetahui bahwa memiliki subquery yang berkorelasi tidak selalu merupakan ide yang baik.  Anda selalu dapat mempertimbangkan untuk menyingkirkannya, misalnya, dengan menulis ulang menggunakan <code>INNER JOIN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> drivers <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> fines <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fines.driverslicensenr = drivers.driverslicensenr;</code> </pre> <br><h4>  Pengoperasian <code>DISTINCT</code> </h4><br>  Pernyataan <code>SELECT DISTINCT</code> digunakan untuk mengembalikan hanya nilai yang berbeda.  <code>DISTINCT</code> adalah poin yang tentunya harus dihindari jika memungkinkan.  Seperti dalam contoh lain, waktu eksekusi hanya meningkat ketika kalimat ini ditambahkan ke permintaan.  Karena itu, selalu berguna untuk mempertimbangkan apakah Anda benar-benar membutuhkan operasi <code>DISTINCT</code> ini untuk mendapatkan hasil yang ingin Anda capai. <br><br><h4>  Pernyataan <code>LIKE</code> </h4><br>  Saat menggunakan operator <code>LIKE</code> dalam kueri, indeks tidak digunakan jika pola dimulai dengan <code>%</code> atau <code>_</code> .  Ini akan mencegah database menggunakan indeks (jika ada).  Tentu saja, dari sudut pandang lain, dapat juga dikatakan bahwa jenis permintaan ini berpotensi memungkinkan untuk mendapatkan terlalu banyak catatan yang belum tentu memenuhi tujuan permintaan tersebut. <br><br>  Sekali lagi, mengetahui data yang disimpan dalam database dapat membantu Anda merumuskan template yang akan memfilter semua data dengan benar untuk menemukan hanya baris yang benar-benar penting untuk permintaan Anda. <br><br><h3>  2. Batasi hasil Anda </h3><br>  Jika Anda tidak dapat menghindari memfilter <code>SELECT</code> Anda, Anda dapat membatasi hasil Anda dengan cara lain.  Di sinilah pendekatan seperti <code>LIMIT</code> dan konversi tipe data masuk. <br><br><h4>  <code>TOP</code> , <code>LIMIT</code> dan <code>ROWNUM</code> </h4><br>  Anda bisa menambahkan pernyataan <code>LIMIT</code> atau <code>TOP</code> ke kueri untuk menentukan jumlah maksimum baris untuk set hasil.  Berikut ini beberapa contohnya: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers;</code> </pre> <br>  Perhatikan bahwa Anda dapat menentukan <code>PERCENT</code> , misalnya, jika Anda mengubah baris permintaan pertama dengan <code>SELECT TOP 50 PERCENT *</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Atau, Anda bisa menambahkan <code>ROWNUM</code> setara dengan menggunakan <code>LIMIT</code> dalam kueri: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><h4>  Konversi tipe data </h4><br>  Yang paling efektif harus selalu digunakan, mis.  terkecil, tipe data.  Selalu ada risiko saat Anda memberikan tipe data besar, sementara yang lebih kecil akan lebih memadai. <br><br>  Namun, saat menambahkan konversi tipe data ke kueri, hanya waktu eksekusi yang meningkat. <br><br>  Alternatifnya adalah menghindari konversi tipe data sebanyak mungkin.  Harap perhatikan juga bahwa tidak selalu mungkin untuk menghapus atau melewati konversi tipe data dari kueri, tetapi Anda harus selalu berusaha untuk memasukkannya, dan Anda harus memeriksa efek dari penambahan sebelum menjalankan kueri. <br><br><h3>  3. Jangan membuat pertanyaan lebih rumit dari yang seharusnya </h3><br>  Konversi tipe data mengarahkan Anda ke titik berikut: Anda tidak boleh terlalu mendesain kueri Anda.  Cobalah membuatnya sederhana dan efektif.  Ini mungkin tampak terlalu sederhana atau bodoh bahkan untuk menjadi petunjuk, terutama karena permintaan bisa rumit. <br><br>  Namun, dalam contoh yang disebutkan di bagian berikut, Anda akan melihat bahwa Anda dapat dengan mudah mulai membuat kueri sederhana yang lebih kompleks dari yang seharusnya. <br><br><h4>  <code>OR</code> operator </h4><br>  Saat Anda menggunakan operator <code>OR</code> dalam kueri Anda, kemungkinan besar Anda tidak menggunakan indeks. <br><br>  Ingat bahwa indeks adalah struktur data yang meningkatkan kecepatan pencarian data dalam tabel database, tetapi mahal: catatan tambahan akan diperlukan dan ruang penyimpanan tambahan akan diperlukan untuk mempertahankan struktur data indeks.  Indeks digunakan untuk mencari atau mencari data dengan cepat tanpa harus mencari setiap baris dalam database setiap kali tabel database diakses.  Indeks dapat dibuat menggunakan satu atau lebih kolom dalam tabel database. <br><br>  Jika Anda tidak menggunakan indeks yang termasuk dalam basis data, pelaksanaan kueri Anda akan memakan waktu lebih lama.  Inilah sebabnya mengapa yang terbaik adalah mencari alternatif untuk menggunakan operator <code>OR</code> dalam permintaan Anda; <br><br>  Pertimbangkan pertanyaan berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">678910</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">345678</span></span>;</code> </pre> <br>  Operator dapat diganti dengan: <br><br>  Kondisi dengan <code>IN</code> ;  atau <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-number"><span class="hljs-number">678910</span></span>, <span class="hljs-number"><span class="hljs-number">345678</span></span>);</code> </pre> <br>  Dua <code>SELECT</code> dengan <code>UNION</code> . <br><br>  <b>Kiat: di</b> sini Anda harus berhati-hati untuk tidak menggunakan operasi <code>UNION</code> tidak perlu, karena Anda melihat tabel yang sama beberapa kali.  Pada saat yang sama, Anda harus memahami bahwa ketika Anda menggunakan <code>UNION</code> dalam permintaan Anda, waktu eksekusi meningkat.  Alternatif untuk operasi <code>UNION</code> : merumuskan kembali kueri sehingga semua kondisi ditempatkan dalam <code>SELECT</code> tunggal, atau menggunakan <code>OUTER JOIN</code> bukan <code>UNION</code> . <br><br>  <b>Kiat:</b> Ingatlah bahwa saat <code>OR</code> - dan operator lain yang akan disebutkan di bagian berikut - kemungkinan besar tidak menggunakan indeks, pencarian indeks tidak selalu lebih baik! <br><br><h4>  <code>NOT</code> operator </h4><br>  Ketika kueri Anda berisi operator <code>NOT</code> , kemungkinan indeks tidak digunakan, seperti dengan operator <code>OR</code> .  Ini pasti akan memperlambat permintaan Anda.  Jika Anda tidak tahu apa yang dimaksud di sini, pertimbangkan pertanyaan berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1980</span></span>);</code> </pre> <br>  Permintaan ini tentu akan berjalan lebih lambat dari yang Anda harapkan, terutama karena dirumuskan jauh lebih kompleks daripada yang bisa terjadi: dalam kasus seperti ini, yang terbaik adalah mencari alternatif.  Pertimbangkan untuk mengganti <code>NOT</code> operator pembanding seperti <code>&gt;</code> , <code>&lt;&gt;</code> atau <code>!&gt;</code> ;  Contoh di atas sebenarnya dapat ditulis ulang dan terlihat seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Itu sudah terlihat lebih baik, bukan? <br><br><h4>  <code>AND</code> operator </h4><br>  Operator <code>AND</code> adalah operator lain yang tidak menggunakan indeks dan yang dapat memperlambat kueri jika digunakan dengan cara yang terlalu rumit dan tidak efisien, seperti dalam contoh berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Lebih baik menulis ulang kueri ini menggunakan pernyataan <code>BETWEEN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br><h4>  <code>ANY</code> dan <code>ALL</code> </h4><br>  Selain itu, operator <code>ANY</code> dan <code>ALL</code> adalah operator yang harus Anda berhati-hati, karena jika Anda memasukkannya ke dalam kueri Anda, indeks tidak akan digunakan.  Fungsi agregasi alternatif seperti <code>MIN</code> atau <code>MAX</code> berguna di sini. <br><br>  Kiat: dalam kasus di mana Anda menggunakan alternatif yang diusulkan, Anda harus menyadari bahwa semua fungsi agregasi, seperti <code>SUM</code> , <code>AVG</code> , <code>MIN</code> , <code>MAX</code> melalui banyak baris, dapat menyebabkan kueri yang panjang.  Dalam kasus seperti itu, Anda dapat mencoba meminimalkan jumlah baris untuk memproses atau pra-menghitung nilai-nilai ini.  Sekali lagi Anda melihat bahwa penting untuk mengetahui tentang lingkungan Anda, tujuan permintaan Anda, ... Ketika Anda memutuskan permintaan mana yang akan digunakan! <br><br><h4>  Isolasikan kolom dalam kondisi </h4><br>  Juga, dalam kasus di mana kolom digunakan dalam perhitungan atau dalam fungsi skalar, indeks tidak digunakan.  Solusi yang mungkin adalah dengan memilih kolom tertentu sehingga tidak lagi menjadi bagian dari perhitungan atau fungsi.  Perhatikan contoh berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Terlihat lucu, ya?  Alih-alih, cobalah merevisi perhitungan dan menulis ulang kueri seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">1970</span></span>;</code> </pre> <br><h3>  4. Kurangnya kekuatan kasar </h3><br>  Kiat terakhir ini berarti Anda tidak boleh membatasi permintaan terlalu banyak, karena ini dapat mempengaruhi kinerjanya.  Ini terutama berlaku untuk gabungan dan klausa HAVING. <br><br><h4>  Pesanan meja bergabung </h4><br>  Saat bergabung dengan dua tabel, mungkin penting untuk mempertimbangkan urutan tabel dalam gabungan.  Jika Anda melihat bahwa satu tabel secara signifikan lebih besar dari yang lain, Anda mungkin perlu menulis ulang kueri sehingga tabel terbesar ditempatkan terakhir dalam gabungan. <br><br><h4>  Kondisi koneksi yang berlebihan </h4><br>  Jika Anda menambahkan terlalu banyak kondisi ke koneksi SQL, Anda harus memilih jalur tertentu.  Namun, mungkin jalan ini tidak selalu lebih efisien. <br><br><h4>  Kondisi <code>HAVING</code> </h4><br>  <code>HAVING</code> pada awalnya ditambahkan ke SQL karena kata kunci <code>WHERE</code> tidak dapat digunakan dengan fungsi agregat.  <code>HAVING</code> biasanya digunakan dengan <code>GROUP BY</code> untuk membatasi grup dari baris yang dikembalikan hanya kepada mereka yang memenuhi persyaratan tertentu.  Namun, jika kondisi ini digunakan dalam kueri, indeks tidak digunakan, yang, seperti yang sudah Anda ketahui, dapat mengarah pada fakta bahwa kueri sebenarnya tidak berfungsi dengan baik. <br><br>  Jika Anda mencari alternatif, coba gunakan <code>WHERE</code> . <br><br>  Pertimbangkan pertanyaan berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br>  Kueri pertama menggunakan <code>WHERE</code> untuk membatasi jumlah baris yang perlu diringkas, sedangkan kueri kedua meringkas semua baris dalam tabel, dan kemudian menggunakan <code>HAVING</code> untuk membuang jumlah yang dihitung.  Dalam kasus seperti itu, opsi <code>WHERE</code> jelas lebih baik karena Anda tidak menghabiskan sumber daya. <br><br>  Dapat dilihat bahwa ini bukan tentang membatasi hasil yang ditetapkan, tetapi tentang membatasi jumlah menengah dari catatan dalam kueri. <br><br>  Perlu dicatat bahwa perbedaan antara kedua kondisi adalah bahwa <code>WHERE</code> memperkenalkan kondisi untuk baris individual, sedangkan <code>HAVING</code> memperkenalkan kondisi untuk agregasi atau hasil seleksi, di mana satu hasil, seperti <code>MIN</code> , <code>MAX</code> , <code>SUM</code> , ... adalah dibuat dari beberapa baris. <br><br>  Anda lihat, penilaian kualitas, penulisan dan penulisan ulang permintaan bukanlah tugas yang mudah, mengingat bahwa mereka harus seproduktif mungkin;  Pencegahan antipatterns dan pertimbangan opsi alternatif juga akan menjadi bagian dari tanggung jawab ketika menulis pertanyaan yang perlu dilakukan pada basis data di lingkungan profesional. <br><br>  Daftar ini hanyalah gambaran kecil dari beberapa antipattern dan tip yang saya harap akan membantu pemula;  Jika Anda ingin mengetahui apa yang oleh pengembang lama dianggap sebagai anti-pola yang paling umum, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi ini</a> . <br><br><h2>  Pendekatan berbasis set versus prosedural untuk menulis kueri </h2><br>  Antipattern yang disebutkan di atas menyiratkan bahwa mereka benar-benar turun ke perbedaan dalam pendekatan berbasis set dan prosedural untuk membangun pertanyaan Anda. <br><br>  Pendekatan prosedural untuk pertanyaan adalah pendekatan yang sangat mirip dengan pemrograman: Anda memberi tahu sistem apa yang harus dilakukan dan bagaimana melakukannya. <br><br>  Contoh dari ini adalah kondisi berlebihan dalam koneksi atau kasus ketika Anda menyalahgunakan kondisi <code>HAVING</code> , seperti dalam contoh di atas, di mana Anda meminta basis data dengan mengeksekusi fungsi dan kemudian memanggil fungsi lain, atau Anda menggunakan logika yang berisi kondisi, loop, fungsi yang ditentukan pengguna ( UDF), kursor, ... untuk mendapatkan hasil akhirnya.  Dengan pendekatan ini, Anda akan sering meminta subkumpulan data, lalu meminta subkumpulan data lainnya, dan seterusnya. <br><br>  Tidak mengherankan, pendekatan ini sering disebut permintaan "langkah-demi-langkah" atau "baris demi baris". <br><br>  Pendekatan lain adalah pendekatan berbasis set, di mana Anda cukup menunjukkan apa yang harus dilakukan.  Peran Anda adalah untuk menentukan kondisi atau persyaratan untuk kumpulan hasil yang ingin Anda terima dari kueri.  Anda membiarkan cara data Anda diambil ke mekanisme internal yang menentukan pelaksanaan kueri: Anda membiarkan mesin database menentukan algoritma terbaik atau logika pemrosesan untuk menjalankan kueri Anda. <br><br>  Karena SQL berbasis set, tidak mengherankan bahwa pendekatan ini akan lebih efisien daripada prosedural, dan juga menjelaskan mengapa, dalam beberapa kasus, SQL dapat berjalan lebih cepat daripada kode. <br><br>  <b>Saran adalah</b> pendekatan berbasis permintaan terhadap permintaan juga merupakan salah satu yang akan diminta oleh sebagian besar pengusaha terkemuka di industri teknologi informasi!  Sering kali perlu untuk beralih di antara kedua jenis pendekatan ini. <br><br>  <b>Harap dicatat</b> bahwa jika Anda memerlukan permintaan prosedural, Anda harus mempertimbangkan untuk menulis ulang atau refactoring. <br><br>  Bagian selanjutnya akan membahas rencana dan optimisasi kueri. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465547/">https://habr.com/ru/post/id465547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465535/index.html">Siapa yang mengimplementasikan IPv6, dan apa yang menghambat perkembangannya</a></li>
<li><a href="../id465537/index.html">Yandex: rumah pintar dewasa</a></li>
<li><a href="../id465539/index.html">766 km - rekor jangkauan baru untuk LoRaWAN</a></li>
<li><a href="../id465541/index.html">Dari Perusahaan ke SMB: Kami berbagi pengalaman kami dalam mengadaptasi solusi perusahaan untuk usaha kecil dan menengah dengan monetisasi menggunakan model SaaS</a></li>
<li><a href="../id465545/index.html">Di sisi berbeda negara: bagaimana Facebook digoreng di Kongres AS, sementara Telegram bertarung dengan FSB</a></li>
<li><a href="../id465551/index.html">September Digest Event TI (Bagian Satu)</a></li>
<li><a href="../id465553/index.html">Bahasa pemrograman Ãœ. Pendahuluan, motivasi untuk menciptakan, tujuan</a></li>
<li><a href="../id465555/index.html">12 Ketrampilan Lunak yang Membuat Manajer Proyek TI tak terbendung</a></li>
<li><a href="../id465557/index.html">Batas Waktu Pengembangan Produk</a></li>
<li><a href="../id465561/index.html">Apa yang saya pelajari dari seorang programmer terkemuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>