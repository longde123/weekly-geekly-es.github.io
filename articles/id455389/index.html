<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›¢ï¸ ğŸ‘©ğŸ¾â€ğŸ”¬ ğŸ‘ğŸ½ Haxe 4: Apa yang Baru? ğŸŒŠ ğŸ ğŸ§£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya membawa perhatian Anda pada terjemahan laporan Alexander Kuzmenko (sejak April tahun ini ia secara resmi bekerja sebagai pengembang kompiler Haxe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haxe 4: Apa yang Baru?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455389/"><p>  Saya membawa perhatian Anda pada terjemahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Alexander Kuzmenko</a> (sejak April tahun ini ia secara resmi bekerja sebagai pengembang kompiler Haxe) tentang perubahan dalam bahasa Haxe yang telah terjadi sejak rilis Haxe 3.4. </p><br><img src="https://habrastorage.org/webt/0m/0e/mw/0m0emw609dcl9ycql2oa069lzfu.jpeg" alt="gambar"><br><p>  Lebih dari dua setengah tahun telah berlalu sejak rilis Haxe 3.4.  Selama waktu ini, 7 rilis patch, 5 rilis preview Haxe 4 dan 2 kandidat rilis Haxe 4. dirilis. Ini masih jauh dari versi baru dan hampir siap ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekitar 20 masalah</a> masih harus diselesaikan). </p><a name="habracut"></a><br><img src="https://habrastorage.org/webt/jh/wp/7_/jhwp7_vztjntd_31hhmpqqreabe.png" alt="Dahulu kala ..."><br><p>  Alexander berterima kasih kepada komunitas Haxe karena melaporkan bug, atas keinginan mereka untuk berpartisipasi dalam pengembangan bahasa.  Berkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek evolusi haxe</a> , hal-hal seperti Haxe 4 akan muncul dengan: </p><br><ul><li>  markup inline </li><li>  fungsi inlining di lokasi panggilan </li><li>  fungsi panah </li></ul><br><img src="https://habrastorage.org/webt/kn/qf/fu/knqffu_thrc2godjucb5t4izbt0.png" alt="gambar"><br><p>  Juga, dalam kerangka kerja proyek ini, diskusi sedang diadakan tentang inovasi yang mungkin terjadi seperti: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Janji</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini polimorfik,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tipe</a> standar (parameter tipe default). </p><br><p>  Selanjutnya, Alexander berbicara <b>tentang perubahan dalam sintaksis bahasa</b> . </p><br><img src="https://habrastorage.org/webt/pg/jn/sy/pgjnsymvkyhlespf0rcj-dw6j8s.png" alt="Sintaks baru untuk menggambarkan tipe fungsi"><br><p> Yang pertama adalah sintaks baru untuk menggambarkan sintaks tipe fungsi.  Sintaksis lama agak aneh. <br>  Haxe adalah bahasa pemrograman multi-paradigma, ia selalu memiliki dukungan untuk fungsi kelas satu, tetapi sintaks untuk menggambarkan tipe fungsi diwarisi dari bahasa fungsional (dan berbeda dari yang diadopsi dalam paradigma lain).  Dan programmer yang akrab dengan pemrograman fungsional mengharapkan fungsi dengan sintaks ini untuk mendukung currying otomatis.  Tetapi di Haxe hal ini tidak terjadi. <br>  Kelemahan utama dari sintaksis lama, menurut Alexander, adalah ketidakmampuan untuk menentukan nama-nama argumen, itulah sebabnya Anda harus menulis komentar anotasi panjang dengan deskripsi argumen. <br>  Tapi sekarang kami memiliki sintaks baru untuk menggambarkan tipe fungsi (yang, omong-omong, ditambahkan ke bahasa sebagai bagian dari inisiatif haxe-evolution), di mana ada kesempatan seperti itu (meskipun ini opsional, tetapi disarankan).  Sintaks baru lebih mudah dibaca dan bahkan dapat dianggap sebagai bagian dari dokumentasi untuk kode. <br>  Kelemahan lain dari sintaks lama untuk menggambarkan tipe fungsi adalah inkonsistensi - kebutuhan untuk menentukan tipe argumen fungsi bahkan ketika fungsi tidak menerima argumen: <code>Void-&gt;Void</code> (fungsi ini tidak mengambil argumen dan tidak mengembalikan apa-apa). <br>  Dalam sintaks baru, ini diterapkan lebih elegan: <code>()-&gt;Void</code> </p><br><img src="https://habrastorage.org/webt/xv/nr/fq/xvnrfqcbcxakqrci6y_p1hibh_4.png" alt="Fungsi panah"><br><p>  Yang kedua adalah fungsi panah atau ekspresi lambda - bentuk singkat untuk menggambarkan fungsi anonim.  Komunitas telah lama meminta untuk menambahkannya ke bahasa, dan akhirnya itu terjadi! <br>  Dalam fungsi tersebut, alih-alih kata kunci <code>return</code> , urutan karakter <code>-&gt;</code> (maka nama sintaksnya adalah "fungsi panah"). <br>  Dalam sintaks baru, masih dimungkinkan untuk mengatur tipe argumen (karena sistem inferensi tipe otomatis tidak selalu dapat melakukan seperti yang diinginkan programmer, misalnya, kompiler dapat memutuskan untuk menggunakan <code>Float</code> daripada <code>Int</code> ). <br>  Satu-satunya batasan sintaks baru adalah ketidakmampuan untuk secara eksplisit mengatur tipe pengembalian.  Jika perlu, maka Anda memiliki pilihan untuk menggunakan sintaks lama atau menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sintaks tipe-centang</a> di badan fungsi, yang akan memberi tahu kompilator jenis pengembalian. </p><br><img src="https://habrastorage.org/webt/wh/ri/-8/whri-8d5u0nvjgkiybnrjp1vrag.png" alt="Fungsi panah tidak memiliki representasi khusus di pohon sintaksis"><br><p>  Fungsi panah tidak memiliki representasi khusus di pohon sintaksis, mereka diproses dengan cara yang sama seperti fungsi anonim biasa.  Urutan <code>-&gt;</code> diganti oleh kata kunci <code>return</code> . </p><br><img src="https://habrastorage.org/webt/nd/8c/kt/nd8cktem7lhra7ll-qao6hdatva.png" alt="final - sekarang adalah kata kunci"><br><p>  Perubahan ketiga - <code>final</code> sekarang <code>final</code> menjadi kata kunci (di Haxe 3 <code>final</code> adalah salah satu dari meta tag yang ada di kompiler). <br>  Jika Anda menerapkannya ke kelas, itu akan melarang warisan darinya, hal yang sama berlaku untuk antarmuka.  Menerapkan kualifikasi <code>final</code> untuk metode kelas akan mencegahnya ditimpa di kelas anak-anak. <br>  Namun, di Haxe, ada cara untuk mengatasi pembatasan yang diberlakukan oleh kata kunci <code>final</code> - Anda dapat menggunakan tag meta <code>@:hack</code> untuk ini (tetapi Anda hanya harus melakukan ini jika benar-benar diperlukan). </p><br><img src="https://habrastorage.org/webt/ec/v3/mp/ecv3mpajsnrn6kxkrwx3rwkqlwe.png" alt="Mendeklarasikan bidang opsional dalam struktur anonim"><br><p>  Perubahan keempat adalah cara untuk mendeklarasikan bidang opsional dalam struktur anonim.  Sebelumnya, tag meta <code>@:optional</code> digunakan untuk ini, sekarang tambahkan saja tanda tanya di depan nama bidang. </p><br><img src="https://habrastorage.org/webt/r8/i3/qb/r8i3qbo2r2seeqtyns2yhsbr5r8.png" alt="Daftar abstrak"><br><p>  Kelima, enumerasi abstrak telah menjadi anggota penuh dari keluarga tipe Haxe, dan alih-alih tag meta <code>@:enum</code> kata kunci <code>@:enum</code> sekarang digunakan untuk mendeklarasikannya. </p><br><img src="https://habrastorage.org/webt/ew/b3/xt/ewb3xtnkjr_fdk4jtcdj-ezboao.png" alt="Kata kunci eksternal"><br><p>  Perubahan serupa memengaruhi tag meta <code>@:extern</code> . </p><br><img src="https://habrastorage.org/webt/pb/g3/ip/pbg3ipuxlefguxcw5m-2qybtuqq.png" alt="Sintaks baru untuk tipe gabungan (tipe persimpangan)"><br><p>  Ketujuh adalah sintaks persimpangan tipe baru yang lebih baik mencerminkan esensi dari struktur yang meluas. <br>  Sintaks baru yang sama digunakan untuk membatasi batasan parameter tipe, lebih akurat menyampaikan batasan yang dikenakan pada suatu jenis.  Untuk seseorang yang tidak terbiasa dengan Haxe, sintaksis lama <code>MyClass&lt;T:(Type1, Type2)&gt;</code> dapat dianggap sebagai persyaratan untuk jenis parameter <code>T</code> baik <code>Type1</code> atau <code>Type2</code> .  Sintaks baru secara eksplisit memberitahu kita bahwa <code>T</code> harus menjadi <code>Type1</code> dan <code>Type2</code> bersamaan. </p><br><img src="https://habrastorage.org/webt/e9/un/cj/e9uncj0a6tk4uh0keuuopuwokgy.png" alt="Sintaksis yang disederhanakan untuk mendeklarasikan kamus kosong"><br><p>  Kedelapan adalah kemampuan untuk menggunakan <code>[]</code> untuk mendeklarasikan wadah <code>Map</code> kosong (namun, jika Anda tidak secara eksplisit menentukan jenis variabel, kompiler akan menampilkan jenis sebagai array untuk kasus ini). </p><br><p>  Setelah berbicara tentang perubahan dalam sintaksis, mari kita beralih ke deskripsi <b>fungsi baru dalam bahasa</b> . <br>  Mari kita mulai dengan iterator nilai kunci yang baru </p><br><img src="https://habrastorage.org/webt/gw/sg/3v/gwsg3vpv6qco2n61v4zxh0dfzvw.png" alt="Iterator nilai kunci"><br><p>  Sintaks baru telah ditambahkan untuk penggunaannya. <br>  Untuk mendukung iterator tersebut, tipe harus mengimplementasikan metode <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> , atau metode <code>hasNext():Bool</code> dan <code>next():{key:K, value:V}</code> .  Pada saat yang sama, tipe <code>KeyValueIterator&lt;K, V&gt;</code> adalah sinonim untuk iterator reguler dalam struktur anonim <code>Iterator&lt;{key:K, value:V}&gt;</code> . <br>  Iterator nilai kunci diimplementasikan untuk beberapa jenis dari pustaka standar Haxe ( <code>String</code> , <code>Map</code> , <code>DynamicAccess</code> ), dan pekerjaan juga sedang berlangsung untuk mengimplementasikannya untuk array. </p><br><img src="https://habrastorage.org/webt/67/-f/g0/67-fg0qimh9gu7b8qvkaazjf4ti.png" alt="Dukungan untuk iterator baru untuk tipe bawaan"><br><p>  Untuk string, indeks karakter dalam string digunakan sebagai kunci, dan kode karakter pada indeks yang diberikan digunakan sebagai nilai (jika karakter itu sendiri diperlukan, maka metode <code>String.fromCharCode()</code> dapat digunakan). <br>  Untuk wadah <code>Map</code> , iterator baru bekerja sama dengan metode iterasi lama, yaitu, menerima array kunci dalam wadah dan melewatinya, meminta nilai untuk masing-masing kunci. <br>  Untuk <code>DynamicAccess</code> (pembungkus untuk objek anonim), iterator bekerja menggunakan refleksi (untuk mendapatkan daftar bidang objek menggunakan metode <code>Reflect.fields()</code> dan untuk mendapatkan nilai bidang dengan namanya menggunakan metode <code>Reflect.field()</code> ). </p><br><img src="https://habrastorage.org/webt/ml/u7/qj/mlu7qjpnq86muxduteld_riofzu.png" alt="Penerjemah makro baru"><br><p>  Haxe 4 menggunakan penerjemah makro yang sepenuhnya baru, "eval".  Simon Krajewski, penulis penerjemah, menggambarkannya secara terperinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di blog resmi Haxe</a> , dan juga dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan perkembangannya tahun lalu</a> . <br>  Perubahan utama dalam pekerjaan juru bahasa: </p><br><ul><li>  beberapa kali lebih cepat dari penerjemah makro yang lama (rata-rata 4 kali) </li><li>  mendukung debugging interaktif (sebelumnya, untuk makro, hanya output konsol yang dapat digunakan) </li><li>  digunakan untuk menjalankan compiler dalam mode interpreter (sebelumnya neko digunakan untuk ini. Omong-omong, eval juga melampaui neko dalam kecepatan). </li></ul><br><img src="https://habrastorage.org/webt/f3/ef/e8/f3efe8ko9czu8tdyo5kzjswkfto.png" alt="Dukungan Unicode"><br><p>  Dukungan Unicode untuk semua platform (dengan pengecualian neko) adalah salah satu perubahan terbesar dalam Haxe 4. Simon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membicarakan hal ini secara</a> rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tahun lalu</a> .  Tapi di sini adalah gambaran singkat dari keadaan saat ini dukungan string Unicode di Haxe: </p><br><ul><li>  untuk dukungan unicode penuh Lua, PHP, Python dan eval (penerjemah makro) diimplementasikan (pengkodean UTF8) </li><li>  untuk platform lain (JavaScript, C #, Java, Flash, HashLink dan C ++), digunakan pengkodean UTF16. </li></ul><br><p>  Dengan demikian, garis-garis di Haxe bekerja dengan cara yang sama untuk karakter yang termasuk dalam bidang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multibahasa utama</a> , tetapi untuk karakter di luar bidang ini (misalnya, untuk emoji), kode untuk bekerja dengan garis dapat menghasilkan hasil yang berbeda tergantung pada platform (tetapi ini masih lebih baik, daripada situasi yang kita miliki di Haxe 3, ketika setiap platform memiliki perilaku sendiri). </p><br><img src="https://habrastorage.org/webt/5o/o2/fp/5oo2fp2s4h2t9rpqnvfyrbwb7gs.png" alt="Iterator String Baru"><br><p>  Untuk string Unicode-encoded (baik dalam UTF8 dan UTF16), iterator khusus telah ditambahkan ke perpustakaan standar Haxe yang bekerja sama pada SEMUA platform untuk semua karakter (baik dalam bidang multibahasa utama dan seterusnya): </p><br><pre> <code class="plaintext hljs">haxe.iterators.StringIteratorUnicode haxe.iterators.StringKeyValueIteratorUnicode</code> </pre> <br><img src="https://habrastorage.org/webt/3k/zv/xu/3kzvxup9p5crewap3u76tnfqhlg.png" alt="Fitur untuk Dukungan Unicode"><br><p>  Karena kenyataan bahwa penerapan string bervariasi dari platform ke platform, perlu diingat beberapa nuansa pekerjaan mereka.  Di UTF16, setiap karakter membutuhkan 2 byte, jadi mengakses karakter dalam string dengan indeks cepat, tetapi hanya di dalam bidang multibahasa utama.  Di sisi lain, di UTF8 semua karakter didukung, tetapi ini dicapai dengan mengorbankan pencarian lambat untuk karakter dalam string (karena karakter dapat menempati jumlah byte yang berbeda dalam memori, mengakses karakter berdasarkan indeks memerlukan pengulangan melalui garis setiap kali dari awal).  Oleh karena itu, ketika bekerja dengan string besar dalam Lua dan PHP, Anda harus ingat bahwa akses ke karakter sewenang-wenang bekerja cukup lambat (juga pada platform ini, panjang string dihitung lagi setiap kali). <br>  Namun, meskipun dukungan Unicode penuh dinyatakan untuk Python, pembatasan ini tidak berlaku untuk itu karena garis-garis di dalamnya diimplementasikan dalam cara yang sedikit berbeda: untuk karakter dalam bidang multibahasa utama, itu menggunakan pengkodean UTF16, dan untuk karakter yang lebih luas (3 dan lebih banyak byte) Python menggunakan UTF32. <br>  Optimalisasi tambahan diterapkan untuk penerjemah makro eval: string "tahu" apakah itu berisi karakter Unicode.  Jika tidak mengandung karakter seperti itu, string diinterpretasikan sebagai terdiri dari karakter ASCII (di mana setiap karakter membutuhkan 1 byte).  Akses berurutan menurut indeks dalam eval juga dioptimalkan: posisi karakter terakhir yang diakses di-cache dalam baris.  Jadi jika Anda pertama kali beralih ke karakter ke-10 dalam string, maka ketika Anda selanjutnya beralih ke karakter ke-20, eval akan mencarinya bukan dari awal baris, tetapi mulai dari 10.  Selain itu, panjang string dalam eval di-cache, yaitu, itu dihitung hanya pada permintaan pertama. </p><br><img src="https://habrastorage.org/webt/je/gi/ne/jegineguad8fp4dlqyhfbboxy8c.png" alt="Dukungan Namespace untuk flag kompilasi"><br><p>  Haxe 4 memperkenalkan dukungan untuk ruang nama untuk flag kompilasi, yang dapat berguna, misalnya, untuk mengatur kode saat menulis pustaka kustom. <br>  Juga, namespace yang disediakan untuk bendera kompilasi muncul - <code>target</code> , yang digunakan oleh kompiler untuk menggambarkan platform target dan perilakunya: </p><br><ul><li>  <code>target.name</code> - nama platform (js, cpp, php, dll.) </li><li>  <code>target.utf16</code> - mengatakan bahwa dukungan Unicode diimplementasikan menggunakan UTF16 </li><li>  <code>target.sys</code> - menunjukkan apakah kelas dari paket sys tersedia (misalnya, untuk bekerja dengan sistem file) </li><li>  <code>target.static</code> - menunjukkan apakah platform statis (pada platform statis, tipe dasar <code>Int</code> , <code>Float</code> dan <code>Bool</code> tidak boleh memiliki <code>null</code> sebagai nilainya) </li><li>  <code>target.threaded</code> - menunjukkan apakah platform mendukung multithreading </li></ul><br><img src="https://habrastorage.org/webt/qt/ue/c_/qtuec_vbswkwgylwnidy9xuaeou.png" alt="Dukungan Namespace untuk tag meta"><br><p>  Demikian pula, dukungan namespace untuk tag meta telah muncul.  Sejauh ini tidak ada ruang nama yang dicadangkan untuk tag meta dalam bahasa, tetapi situasinya mungkin berubah di masa mendatang. </p><br><img src="https://habrastorage.org/webt/cc/yj/ye/ccyjyemwz1ti9vgddvccyu4iqeq.png" alt="Jenis Baru - ReadOnlyArray"><br><p>  Tipe <code>ReadOnlyArray</code> ditambahkan ke pustaka standar Haxe - abstraksi atas array biasa, di mana metode hanya tersedia untuk membaca data dari array. </p><br><img src="https://habrastorage.org/webt/jr/ia/2o/jria2ovebta0bwm-lezr7jvv7ao.png" alt="Field Terakhir dan Variabel Lokal"><br><p>  Inovasi lain dalam bahasa ini adalah bidang terakhir dan variabel lokal. <br>  Jika <code>final</code> digunakan sebagai pengganti kata kunci <code>var</code> ketika mendeklarasikan bidang kelas atau variabel lokal, ini berarti bahwa bidang atau variabel ini tidak dapat dipindahkan (kompiler akan memberikan kesalahan ketika mencoba melakukan ini).  Tetapi pada saat yang sama, keadaannya dapat diubah, sehingga bidang terakhir atau variabel tidak konstan. </p><br><img src="https://habrastorage.org/webt/j-/8u/f9/j-8uf9asp_ivqbxn8kypatexma0.png" alt="Kompiler mengontrol inisialisasi bidang terakhir"><br><p>  Nilai-nilai dari bidang terakhir harus diinisialisasi ketika mereka dideklarasikan, atau dalam konstruktor, jika tidak, kompiler akan melempar kesalahan. </p><br><img src="https://habrastorage.org/webt/2h/yd/wi/2hydwitcbuwstefblzdr09sxqzk.png" alt="Hashlink"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HashLink</a> adalah platform baru dengan mesin virtualnya sendiri, dibuat khusus untuk Haxe.  HashLink mendukung apa yang disebut "kompilasi ganda" - kode dapat dikompilasi baik dalam bytecode (yang sangat cepat, mempercepat proses debugging aplikasi yang dikembangkan), atau dalam C-code (yang ditandai dengan peningkatan kinerja).  Nicholas mendedikasikan HashLink untuk beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting blog Haxe</a> dan juga membicarakannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi</a> Seattle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tahun lalu</a> .  Teknologi HashLink digunakan dalam gim populer seperti Dead Cells dan Northgard. </p><br><img src="https://habrastorage.org/webt/zy/a4/eh/zya4eh5l7t3zqihviw5qvtcrsfc.png" alt="Keamanan kosong"><br><p>  Fitur baru yang menarik dari Haxe 4 adalah keamanan Null, yang masih dalam tahap percobaan (karena positif palsu dan tidak cukupnya pemeriksaan keamanan kode). <br>  Apa itu keamanan nol?  Jika fungsi Anda tidak secara eksplisit menyatakan bahwa ia dapat menerima <code>null</code> sebagai nilai parameter, maka ketika Anda mencoba untuk meneruskannya, kompiler akan melempar kesalahan yang sesuai.  Selain itu, untuk parameter fungsi yang dapat mengambil <code>null</code> sebagai nilai, kompiler akan meminta Anda untuk menulis kode tambahan untuk memverifikasi dan menangani kasus-kasus tersebut. <br>  Fungsionalitas ini dinonaktifkan secara default, tetapi tidak memengaruhi kecepatan eksekusi kode (jika Anda mengaktifkannya), karena pemeriksaan yang dijelaskan hanya dilakukan pada tahap kompilasi.  Itu dapat diaktifkan untuk semua kode, serta secara bertahap diaktifkan untuk masing-masing bidang, kelas, dan paket (sehingga memberikan transisi bertahap ke kode yang lebih aman).  Anda dapat menggunakan meta tag dan makro khusus untuk ini. <br>  Mode-mode di mana Null-security dapat bekerja adalah: <code>Strict</code> (paling ketat), <code>Loose</code> (mode default) dan <code>Off</code> (digunakan untuk menonaktifkan pemeriksaan untuk paket dan tipe individual). </p><br><img src="https://habrastorage.org/webt/mn/9l/jh/mn9ljhu2_wwwonpjo7qhcoiasyw.png" alt="Mode pemeriksaan keamanan nol standar"><br><p>  Untuk fungsi yang ditunjukkan pada slide, pemeriksaan keamanan Null diaktifkan.  Kita melihat bahwa fungsi ini memiliki parameter opsional <code>s</code> , yaitu, kita dapat memasukkan <code>null</code> ke dalamnya sebagai nilai parameter.  Saat mencoba mengkompilasi kode dengan fungsi seperti itu, kompiler akan menghasilkan sejumlah kesalahan: </p><br><ul><li>  ketika mencoba mengakses beberapa bidang objek <code>s</code> (karena mungkin <code>null</code> ) </li><li>  ketika mencoba untuk menetapkan str variabel, yang, seperti yang kita lihat, tidak boleh <code>null</code> (kalau tidak kita seharusnya menyatakan itu bukan sebagai <code>String</code> , tetapi sebagai <code>Null&lt;String&gt;</code> ) </li><li>  ketika mencoba mengembalikan objek <code>s</code> dari suatu fungsi (karena fungsi seharusnya tidak mengembalikan <code>null</code> ) </li></ul><br><p>  Bagaimana cara memperbaiki kesalahan ini? </p><br><img src="https://habrastorage.org/webt/ku/w-/l8/kuw-l8prqna5xq7c21ushemgtqs.png" alt="Perbaiki bug keamanan nol"><br><p>  Kita hanya perlu menambahkan pemeriksaan <code>null</code> ke kode (di dalam blok dengan pemeriksaan <code>null</code> , kompiler "tahu" bahwa <code>s</code> tidak dapat <code>null</code> dan dapat digunakan dengan aman dengannya), dan juga memastikan bahwa fungsi tersebut tidak mengembalikan <code>null</code> ! </p><br><img src="https://habrastorage.org/webt/x1/xj/jp/x1xjjpwn8ikrulbtulxj_iixlq4.png" alt="Saat melakukan pemeriksaan untuk keamanan Null, kompiler memperhitungkan urutan eksekusi program"><br><p>  Selain itu, ketika melakukan pemeriksaan untuk keamanan Null, kompiler memperhitungkan urutan di mana program dijalankan.  Sebagai contoh, jika setelah memeriksa nilai parameter <code>s</code> ke null untuk menghentikan fungsi (atau melempar pengecualian), kompiler akan "tahu" bahwa setelah pemeriksaan seperti itu, parameter <code>s</code> tidak bisa lagi menjadi <code>null</code> , dan dapat digunakan dengan aman. </p><br><img src="https://habrastorage.org/webt/6f/vq/cj/6fvqcjbu-dixmrxcfuwtd8mskvk.png" alt="Mode ketat untuk melakukan pemeriksaan keamanan nol"><br><p>  Jika kompiler mengaktifkan mode pemeriksaan ketat untuk keamanan Null, itu akan memerlukan pemeriksaan tambahan untuk <code>null</code> dalam kasus di mana antara pemeriksaan awal dari nilai untuk <code>null</code> dan upaya untuk mengakses bidang objek kode apa pun yang dieksekusi kode yang dapat mengaturnya ke <code>null</code> . </p><br><img src="https://habrastorage.org/webt/ci/6m/u4/ci6mu4zsvkdjf33vvbetz30mf2m.png" alt="Mode longgar untuk melakukan pemeriksaan keamanan nol"><br><p>  Dalam mode Loose (digunakan secara default), kompiler tidak akan memerlukan pemeriksaan seperti itu (omong-omong, perilaku ini juga digunakan secara default dalam TypeScript). </p><br><img src="https://habrastorage.org/webt/je/wo/5q/jewo5qwzmavidsf-jss4bwug79i.png" alt="Memeriksa inisialisasi bidang ketika melakukan pemeriksaan untuk keamanan nol"><br><p>  Juga, ketika pemeriksaan untuk keamanan Null dihidupkan, kompiler memeriksa apakah bidang di kelas diinisialisasi (langsung ketika mereka dinyatakan atau dalam konstruktor).  Jika tidak, kompiler akan melempar kesalahan ketika mencoba untuk melewatkan objek dari kelas seperti itu, serta ketika mencoba memanggil metode pada objek tersebut, sampai semua bidang objek diinisialisasi.  Pemeriksaan tersebut dapat dimatikan untuk masing-masing bidang kelas dengan menandai mereka dengan tag meta <code>@:nullSafety(Off)</code> <br>  Alexander <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> lebih banyak tentang keamanan Null di Haxe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oktober lalu</a> . </p><br><img src="https://habrastorage.org/webt/ui/f3/za/uif3zavird4vri76gqfiaukfsxo.png" alt="Menghasilkan kelas ES6 untuk JavaScript"><br><p>  Haxe 4 memperkenalkan kemampuan untuk menghasilkan kelas ES6 untuk JavaScript, ini diaktifkan menggunakan flag kompilasi <code>js-es=6</code> . </p><br><img src="https://habrastorage.org/webt/z7/5c/ow/z75cowptrmqn5bxfa7oerxkxsro.png" alt="Fungsi Di Tempat"><br><p>  Menanamkan fungsi di tempat panggilan (panggilan-situs inlining) menyediakan lebih banyak opsi untuk mengontrol keseimbangan antara kinerja kode dan ukuran.  Fungsi ini juga digunakan di perpustakaan standar Haxe. <br>  Seperti apa dia?  Ini memungkinkan Anda untuk menyematkan badan fungsi (menggunakan <code>inline</code> ) hanya di tempat-tempat di mana ia diperlukan untuk memastikan kinerja tinggi (misalnya, jika perlu, memanggil metode yang cukup produktif dalam loop), sementara di tempat lain badan fungsi tidak tertanam.  Akibatnya, ukuran kode yang dihasilkan akan sedikit meningkat. </p><br><img src="https://habrastorage.org/webt/ke/0y/wf/ke0ywfco0j5pbynruiqr4mgqhxw.png" alt="Ekstensi Otomatis untuk Jenis"><br><p>  Penggunaan otomatis (ekstensi otomatis untuk tipe) berarti sekarang untuk tipe Anda dapat mendeklarasikan ekstensi statis di tempat deklarasi tipe.  Ini menghilangkan kebutuhan untuk <code>using type;</code> konstruk <code>using type;</code> setiap kali <code>using type;</code>  di setiap modul di mana jenis dan metode ekstensi digunakan.  Saat ini, ekstensi jenis ini hanya diterapkan untuk transfer, tetapi pada rilis final (dan pada build malam) dapat digunakan tidak hanya untuk transfer. </p><br><img src="https://habrastorage.org/webt/ru/ts/6s/ruts6snzqmgjdbx1g0kmjc92oxw.png" alt="Mengesampingkan operator untuk mengakses bidang objek"><br><p>  Dalam Haxe 4, dimungkinkan untuk mendefinisikan ulang operator untuk mengakses bidang objek untuk tipe abstrak (hanya untuk bidang yang tidak ada dalam tipe).  Untuk melakukan ini, gunakan metode yang ditandai dengan tag meta <code>@:op(ab)</code> . </p><br><img src="https://habrastorage.org/webt/qv/fu/fj/qvfufjhriheejf1q6i0epu82pw8.png" alt="Markup bawaan"><br><p>  Markup bawaan adalah fitur eksperimental lain di Haxe.  Kode markup bawaan tidak diproses oleh kompiler sebagai dokumen xml - kompilator melihatnya sebagai string yang dibungkus dengan tag meta <code>@:markup</code> .           . </p><br><img src="https://habrastorage.org/webt/ms/an/zi/msanzicye9bpsmkbw55m6zcs34a.png" alt="   "><br><p>    -,   - <code>@:markup</code>    ,     . </p><br><img src="https://habrastorage.org/webt/pg/ek/2w/pgek2wa4v-ocjxauyq6e9oopvfc.png" alt="      untyped-"><br><p>               (  <code>untyped</code> ).           . ,   ,  <code>Js.build()</code>     - <code>@:markup</code>     ,        <code>&lt;js&gt;</code> ,     js-. </p><br><img src="https://habrastorage.org/webt/gk/vd/1f/gkvd1f3duuldpzde1zmmgvwbkza.png" alt=" -  - "><br><p>  Haxe 4     -  - ,    â€”       . </p><br><img src="https://habrastorage.org/webt/br/gp/0c/brgp0cim1eozg7jjcopjmtx1xys.png" alt="     "><br><p>       .  ,        .   ,   <code>Int</code> ,      ,    C. </p><br><img src="https://habrastorage.org/webt/cj/3g/lf/cj3glfbn9l5owjjunjtrsn2jzvw.png" alt="     "><br><p>         â€”       . </p><br><p> <b>     :</b> </p><br><img src="https://habrastorage.org/webt/y4/hl/fw/y4hlfwwz_db02rgmsj4f1jgw6r8.png" alt=" JVM- "><br><p>    JVM-   JDK,            Java-.    .         . </p><br><img src="https://habrastorage.org/webt/wj/ut/_z/wjut_zypg87r1f508zovsks2dio.png" alt=""><br><p>      ,     <code>async</code> / <code>await</code>  <code>yield</code> .       (   C#,       ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>     Haxe    github. </p><br><img src="https://habrastorage.org/webt/ou/7r/gh/ou7rghzmynbwwvah6l7rumqpl8i.png" alt=",    "><br><p>  Haxe  <a href="">,    </a> .     ( )     .        ,    . </p><br><img src="https://habrastorage.org/webt/ty/y4/xw/tyy4xwdn9olejstawrdlqbux_tu.png" alt=" API     "><br><p>       API     .     ,   ,    API    . </p><br><p>      Haxe 4  ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455389/">https://habr.com/ru/post/id455389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455375/index.html">Menulis UDR dalam Pascal</a></li>
<li><a href="../id455377/index.html">Arsitektur IoT</a></li>
<li><a href="../id455379/index.html">(Statis) Pemilihan wadah optimal dalam program C ++</a></li>
<li><a href="../id455381/index.html">3CX merespon dukungan teknis: menangkap lalu lintas SIP di server PBX</a></li>
<li><a href="../id455387/index.html">Memahami Pembelajaran Mesin di Elastic Stack (alias Elasticsearch, alias ELK)</a></li>
<li><a href="../id455391/index.html">Bagian 1: RISC-V / RocketChip di Habitat Tidak Alami</a></li>
<li><a href="../id455393/index.html">Tentang penggunaan metode parametrik estimasi spektral dalam radar - metode MUSIC. Penambahan artikel</a></li>
<li><a href="../id455397/index.html">Bagaimana kami merancang dan mengimplementasikan jaringan baru pada Huawei di kantor Moskow, bagian 1</a></li>
<li><a href="../id455401/index.html">Tcl untuk Cisco IOS dalam Contoh Sederhana</a></li>
<li><a href="../id455403/index.html">Dari lima sen ke permainan dewa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>