<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📩 📒 👶🏼 Blockchain untuk yang terkecil 🙌🏼 🅰️ 💴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penafian 


 Teks ini tidak terikat dengan proyek crypto yang ada dan mewakili "kuda bulat dalam ruang hampa" untuk perendaman pertama dalam topik ini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain untuk yang terkecil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480220/"><h2 id="disclaimer">  Penafian </h2><br><p>  Teks ini tidak terikat dengan proyek crypto yang ada dan mewakili "kuda bulat dalam ruang hampa" untuk perendaman pertama dalam topik ini.  Spesialis, kemungkinan besar, tidak akan membutuhkan kebenaran umum seperti itu.  Dan ya, ini Longrid.  Meski banyak yang tertinggal di belakang layar. </p><br><h2 id="vvodnaya">  Pendahuluan </h2><br><p>  Pertama-tama, blockchain modis.  Dan inilah alasan utama mengapa mereka tertarik.  Sepertinya ini adalah teknologi "joker" yang dapat dan harus diterapkan di mana-mana.  Tetapi ini tidak benar.  Dan agar Anda tidak harus mengambil kata-kata saya untuk itu, saya akan memberi tahu Anda apa sebenarnya blockchain itu, di mana itu berlaku, dan di mana itu diperlukan, seperti payung untuk memancing. </p><br><p>  Jadi ... <a name="habracut"></a></p><br><h2 id="blokcheyn">  Blockchain </h2><br><p>  Istilah ini berasal dari bahasa Inggris "rantai blok", yang diterjemahkan sebagai "rantai blok".  Setiap blok baru berisi hash dari blok sebelumnya, membentuk daftar tertaut tunggal di mana hash dari setiap blok direkam di blok berikutnya. </p><br><p> Hash blok tergantung pada semua blok sebelumnya.  Dengan demikian, hash dari blok terakhir mencerminkan keadaan seluruh database.  Dan rantai hash dari blok terakhir ke yang pertama adalah bukti kekekalannya.  Ketika sebuah blok baru ditambahkan, itu "ditautkan" ke blok terakhir dan hashnya menjadi keadaan baru dari database. </p><br><p>  Jika ada blok yang ada diubah, rantai hash akan dilanggar dan tempat pelanggarannya akan menunjukkan blok yang diubah.  Anda dapat menghitung ulang dan mengubah semua hash ke akhir rantai - maka konektivitas kriptografi akan tetap, tetapi hash dari blok terakhir akan berubah.  Jika keadaan database - dan ini adalah hash dari blok terakhir - diketahui, maka pemalsuan tidak mungkin. </p><br><p>  Faktanya, itu saja. </p><br><h2 id="baza-dannyh">  Basis data </h2><br><p>  Kita sudah tahu bahwa blockchain hanyalah cara untuk melindungi database dari gangguan.  Apa yang seharusnya menjadi basis data itu sendiri?  Bahkan, dapat berupa apa saja - SQL, BigTable, Key-Value, sistem file.  Tetapi penggunaan blockchain memberlakukan batasannya. </p><br><p>  Basis data yang dilindungi blockchain dari empat properti CRUD ("Buat, Baca, Perbarui, Hapus") hanya memungkinkan dua yang pertama.  Anda tidak dapat mengubah atau menghapus data dari database seperti itu - karena akan segera kehilangan integritas kriptografi.  Blockchain memungkinkan Anda untuk hanya membaca dan membuat blok baru. </p><br><p>  Basis yang cacat seperti itu disebut registry.  Untuk alur kerja, aktivitas paten, dan - tentu saja!  - cryptocurrency model seperti itu dapat diterima dan organik.  Tetapi menggunakannya sebagai database tujuan umum hampir tidak mungkin. </p><br><p>  Kata kuncinya di sini adalah "hampir."  Ada cara untuk merekonsiliasi database blockchain “lengkap” dan metode ini disebut “log transaksi”. </p><br><p>  Ambil, misalnya, database nilai kunci sederhana yang menyimpan entitas sewenang-wenang yang terkait dengan kunci unik.  Mereka dapat dibuat dan dihapus, membaca dan membuat perubahan. </p><br><p>  Untuk setiap entitas, hitung hash, dan kemudian secara harfiah memesan (urutkan berdasarkan abjad) daftar yang dihasilkan.  Untuk setiap pasangan hash, hitung hash dari jumlah literal (gabungan) hash ini.  Kemudian, pada daftar yang dihasilkan, lakukan hal yang sama.  Dan seterusnya sampai kita membangun pohon hash, di atasnya akan ada nilai tunggal.  Mekanisme ini disebut pohon Merkle dan di bagian atas akan ada hash yang mencerminkan keadaan database. </p><br><p>  Selanjutnya, kita akan membuat daftar yang terhubung secara tunggal sesuai dengan semua aturan blockchain, yang akan berisi catatan tentang keadaan basis data, kunci dan nilai baru entitas.  Nah, dan hash dari entri sebelumnya, tentu saja.  Ini sudah akan menjadi blockchain - blockchain transaksi, yang masing-masing dikaitkan dengan keadaan database dan berisi esensi dari perubahan yang dilakukan oleh transaksi ini. </p><br><p>  Jika kuncinya baru, maka entitas dibuat.  Jika ada, itu berubah.  Jika nilai baru nol, entitas dihapus.  Setiap perubahan mengarah ke penghitungan ulang cabang-cabang pohon Merkle yang terkena dampak dan keadaan baru dari pangkalan. </p><br><p>  Pada prinsipnya, skema yang sama dapat diterapkan untuk database relasional, dan untuk yang lainnya - jika perlu.  Log transaksi akan mencatat perubahan, pohon Merkle akan membuktikan keandalannya.  Tidak buruk kan? </p><br><h2 id="decentralizaciya-dannyh">  Desentralisasi data </h2><br><p>  Mengapa repot dengan semua mekanisme otentikasi ini?  Kemudian, dengan begitu Anda bisa membangun database terdistribusi yang bisa Anda percayai.  Sekalipun simpul-simpul jaringan tempat penyimpanan basis data ini, kami tidak percaya. </p><br><p>  Basis data yang terdesentralisasi direplikasi dan didistribusikan.  Setiap basis data pengguna yang direplikasi disimpan secara sama dan lengkap, dan basis data yang didistribusikan disimpan secara berbeda dan sebagian.  Nilai plus dari pendekatan pertama adalah dalam kontrol penuh atas database, dan nilai minus adalah persyaratan tinggi untuk volume penyimpanan.  Pro dan kontra dari pendekatan kedua dicerminkan - volume seluruh database bisa berkali-kali lebih besar dari kemampuan setiap pengguna tunggal, tetapi dengan biaya kontrol yang tidak mencukupi dan, akibatnya, penurunan kepercayaan pada keandalannya. </p><br><p>  Setiap pengguna basis data dapat menambahkan bloknya sendiri.  Tetapi basis hanya dapat diandalkan ketika semua instansinya sama.  Sinkronisasi adalah cara untuk menjaga keandalan suatu basis data.  Dimungkinkan untuk melakukan operasi apa pun dengannya - membaca atau menulis - asalkan cukup relevan sehingga tindakan yang sama dengannya menghasilkan hasil yang sama. </p><br><p>  Secara umum, sinkronisasi terdiri dari memperoleh status terakhir dari basis data, diikuti dengan secara berurutan memperoleh elemen-elemen yang hilang sampai integritas sepenuhnya dipulihkan. </p><br><h2 id="raspredelennaya-set">  Jaringan terdistribusi </h2><br><p>  Desentralisasi menjamin stabilitas sistem terhadap pengaruh destruktif - baik dari peretas tunggal, dan dari perusahaan dan struktur yang berkuasa.  Sistem desentralisasi akan hidup selama ada koneksi antara elemen-elemennya. </p><br><p>  Peserta dalam jaringan terdistribusi membentuk grafik, simpul-simpulnya adalah komputer yang terhubung ke Internet, dan ujung-ujungnya terhubung oleh tepi.  Setiap node memiliki pengidentifikasi unik - akun, kunci publik dari tanda tangan elektronik, atau yang lainnya.  Pengidentifikasi ini digunakan untuk mengatasi pesan, dan cara merutekannya tergantung pada arsitektur jaringan. </p><br><p>  Arsitektur paling sederhana adalah grafik yang terhubung sepenuhnya, di mana setiap pengidentifikasi berhubungan dengan alamat jaringan nyata dan ada kemungkinan komunikasi semua dengan semua orang.  Tetapi dalam infrastruktur jaringan nyata, kemungkinan menghubungkan semua orang dengan semua orang mungkin tidak.  Selain itu, karena kebutuhan untuk memberi tahu semua peserta, dengan pertumbuhan jaringan, lalu lintas akan tumbuh sebanding dengan jumlah peserta.  Cepat atau lambat akan muncul batas efisiensi, di luar mana degradasi jaringan akan dimulai, hingga berhenti total. </p><br><p>  Model yang lebih kompleks adalah grafik siklik terarah.  Pengidentifikasi disusun dalam satu daftar, yang dilingkarkan sehingga setiap node memiliki "tetangga" di kiri dan kanan.  Menerima pesan dari tetangga di sebelah kiri dan mengirimkannya ke kanan, node mengirimkannya dengan relay.  Skema ini tidak tergantung pada ukuran jaringan, karena node berinteraksi dengan jumlah tetangga yang relatif kecil.  Skema ini dapat ditingkatkan dan ditambah, tetapi intinya adalah bahwa setiap node hanya akan berinteraksi dengan subnet sendiri, yang, sebagian tumpang tindih, menerapkan grafik terhubung ukuran tak terbatas. </p><br><p>  Tetapi ini tidak memberikan solusi untuk situasi di mana node dapat terhubung ke orang lain secara sepihak.  Dari jaringan pribadi yang tersembunyi di belakang perutean Terjemahan Alamat Jaringan (NAT), mereka dapat mengirim pesan, tetapi mereka tidak dapat menerimanya.  Bagi mereka, perlu untuk menerapkan model di mana mereka membuat koneksi, dan pesan diterima sebagai tanggapan atas permintaan.  "Masalah NAT traversal" mungkin memiliki solusi dalam bentuk router "suar" yang terpisah atau node lain yang mengimplementasikan fungsi-fungsi ini.  Pola dengan router mirip dengan pola bintang arsitektur jaringan. </p><br><p>  Arsitektur "cincin" dan "bintang" dapat ditingkatkan dan digunakan dalam kombinasi, namun arsitektur "jaringan jala" adalah yang paling efisien, yang mengubah grafik asli yang terhubung sepenuhnya menjadi grafik yang tidak terhubung dengan mengurangi koneksi dan mengubah koneksi langsung menjadi "rute" dari beberapa rute perantara.  Untuk melakukan ini, setiap node harus dapat, jika perlu, menjadi router untuk tetangga.  Khususnya jalur yang tidak dapat diakses dan penutupan node menakutkan untuk arsitektur seperti itu - jaringan akan membangun kembali rute yang rusak dan memperbaiki diri.  Dan ini paling efektif dalam hal kinerja. </p><br><p>  Tetapi Anda harus membayar semuanya.  Aparat matematika dari jaringan mesh (dari bahasa Inggris. Mesh - "sel") jauh lebih rumit dan saya mungkin akan menahan diri untuk tidak menggambarkannya di sini.  Mereka yang tertarik saya akan merujuk ke "masalah salesman keliling", dan kemudian - jika ini tidak membuat mereka takut - untuk teori permainan.  Ada semua jawaban di sana - bagi mereka yang bisa mendapatkannya. </p><br><h2 id="problema-vetvleniya">  Masalah percabangan </h2><br><p>  Blockchain memiliki satu cacat fatal - di mana ada daftar yang terhubung, pohon bisa ada.  Ini tidak bertentangan dengan apa pun, karena beberapa yang berikutnya dapat merujuk ke blok yang sama.  Setiap cabang yang dihasilkan dapat diandalkan, memelihara integritas kriptografi dan memiliki statusnya sendiri.  Tapi pangkalan secara keseluruhan masuk ke superposisi semua negara ini dan menjadi tidak pasti. </p><br><p>  Masalah ini sangat relevan dalam sistem desentralisasi, di mana node yang berbeda secara mandiri dapat membuat perubahan pada database, menyebabkan garpu (dari garpu bahasa Inggris - "garpu").  Ada dua cara untuk mengatasinya - menghindari situasi perekaman serentak dan menghilangkan konsekuensinya. </p><br><h2 id="mayning">  Penambangan </h2><br><p>  Anda mungkin pernah mendengar bahwa pengguna BitCoin membakar listrik sebagian besar waktu, menghabiskan sumber daya komputasi untuk menyelesaikan masalah matematika yang tidak berguna?  Jika tidak, sekarang Anda tahu itu ... </p><br><p>  Nomor acak ditambahkan ke setiap blok baru.  Ini acak, tetapi hash dari blok yang dihasilkan harus memenuhi ketentuan.  Misalnya, mulailah dengan 10 nol.  Dan sekarang node yang ingin menulis blok baru menyortir angka-angka ini sampai hash memenuhi kondisi kompleksitas yang ditentukan.  Dan "ladang" dari komputer, kartu video atau perangkat yang dirancang khusus menyerap kilowatt dan menghasilkan panas.  Nah, dan hash yang diperlukan, tentu saja. </p><br><p>  Kenapa semua ini?  Tapi sangat sederhana.  Dari banyak peserta dalam teori probabilitas, hash ditemukan setiap 10 menit oleh satu orang.  Dia menulis blok.  Ini adalah cara termudah untuk melindungi dari percabangan. </p><br><p>  Dan yang paling tidak efisien, karena terlepas dari kerumitan tugas, “garpu” terjadi.  Kemudian, mereka yang menemukan garpu menghapus blok dari cabang yang lebih pendek dan secara berurutan memindahkannya ke ujung yang lebih panjang. </p><br><p>  Dan agar partisipan jaringan tertarik untuk melakukan semua ini, untuk sumber daya yang mereka habiskan, mereka mendapatkan koin cryptocurrency "entah dari mana."  Ini penambangan (dari bahasa Inggris. "Penambangan" - bekerja di tambang). </p><br><h2 id="pow-pos-dpos">  PoW, PoS, DPoS ... </h2><br><p>  Menghitung hash hanya satu cara untuk memilih satu dari banyak.  Ini adalah Bukti Kerja, yang berarti "bukti kerja yang dilakukan."  Dengan menghitung hash yang diinginkan, para peserta melakukan pekerjaan, dan hash yang ditemukan adalah bukti ini.  Bukti listrik terbuang. </p><br><p>  Ketika hijau membicarakannya, beberapa orang peduli.  Tetapi ketika uang baru mulai mengancam yang lama, pemerintah menarik kembali ekologi.  Namun, kesia-siaan menambang pada waktu itu tidak dipahami hanya oleh mereka yang menerima uang untuk itu.  Saatnya mengubah sesuatu ... </p><br><p>  Dan di sana muncul Bukti kepemilikan, "bukti kepemilikan."  Semuanya sederhana, siapa yang lebih kaya - dia benar.  Faktanya, semuanya sedikit lebih rumit, tetapi itu tidak masalah - penciptaan blok (dan mendapatkan hadiah untuk mereka!) Di tangan mereka yang memiliki kepemilikan saham lebih tinggi. </p><br><p>  Kemudian muncul DPoS (PoS yang didelegasikan dengan demokrasi dan pemungutan suara), PoI ("bukti penting" berdasarkan beberapa metrik seperti aktivitas aktivitas dan waktu aktif), dan lebih banyak, dan lebih banyak, dan lebih ... </p><br><p>  Esensinya tetap sama - diperlukan mekanisme yang memungkinkan hanya satu orang untuk menulis blok baru ke rantai di setiap slot waktu.  Kenapa dia harus membuktikan bahwa dia layak dan umumnya lebih baik daripada siapa pun. </p><br><h2 id="a-esli-ne-dokazyvat">  Dan jika tidak terbukti? </h2><br><p>  Dan di sini kita berhenti dan mengingat mengapa sangat penting bagi kita bahwa rekaman itu dilakukan oleh satu orang.  Ya, agar rantai tidak terpecah menjadi pohon.  Tapi mengapa? </p><br><p>  Jika rantai memiliki dua blok terakhir, maka basis data berada di dua negara sekaligus.  Dan jika lebih - maka dalam superposisi semua keadaan yang memungkinkan.  Basis menjadi tidak pasti.  Seluruh basis, secara keseluruhan.  Apakah kita memerlukan integritas pangkalan yang monolitik?  Untuk memverifikasi keaslian suatu elemen, seluruh basis tidak diperlukan - hanya bagian-bagian yang terkait dengannya yang diperlukan. </p><br><p>  Dan jika kita secara independen mengubah basis data di tempat yang berbeda dan setiap perubahan didukung oleh integritas kriptografi, maka kita akan memiliki basis data tidak terbatas, yang himpunan bagiannya akan menjadi deterministik.  Dan jika, selain bercabang, kita juga berurusan dengan percabangan, maka ukuran ketidakpastian akan meningkat dan menurun pada saat yang sama.  Dan setiap node dapat menambahkan blok apa saja ke rantai kapan saja, jika Anda pertama-tama membawa semua status elemen yang terpengaruh ke subset deterministik dari database. </p><br><p>  Ini adalah blockchain tanpa blockchain.  Lebih tepatnya, register pada grafik yang diarahkan asiklik. </p><br><h2 id="kriptovalyuta">  Cryptocurrency </h2><br><p>  Kami mengatakan "cryptocurrency" - kami maksudkan "blockchain", kami katakan "blockchain" ... tetapi tidak, yang terjadi adalah sebaliknya.  Apa itu cryptocurrency? </p><br><p>  Bayangkan sebuah database yang berisi entri dengan kolom "akun pengirim", "akun penerima" dan "jumlah".  Tidak lebih, hanya tiga kolom ini.  Dengan setiap entri di akun pengirim, jumlah uang menjadi kurang dari jumlah yang ditunjukkan, dan pada akun penerima - lebih banyak.  Jika Anda mengumpulkan semua catatan di mana uang ditransfer ke satu akun dan menambahkannya, lalu kurangi dari jumlah yang diterima semua operasi di mana uang ditransfer dari akun, kami mendapatkan jumlah yang sekarang ada di akun ini.  Dengan setiap entri baru, uang ditransfer dari akun ke akun dan sebagainya. </p><br><p>  Lihat betapa sederhananya itu?  Hanya satu tabel tiga kolom - dan kami sudah memiliki sistem keuangan kami sendiri.  Dan semuanya akan seperti itu, jika bukan karena satu masalah.  Pada awalnya, ketika tabel kosong, semua akun memiliki nilai yang sama - nol.  Dan ini berarti tidak ada operasi yang dapat dilakukan.  Nah, karena kalau tidak, beberapa akun akan memiliki nilai negatif, dan ini ... apakah itu salah?  Atau tidak? </p><br><h2 id="emissiya">  Emisi </h2><br><p>  Jika kita menganggap uang kertas sebagai penerimaan utang pemerintah, maka seluruh jumlah uang kertas adalah total utang negara kepada warganya.  Dan jika di akun mereka nomor yang berbeda dengan tanda plus, maka pada "akun negara" bersyarat - jumlah mereka dengan tanda minus.  Lalu semuanya bertemu. </p><br><p>  Akuntan menyebut saldo ini "saldo", mereka juga memiliki akun aktif (sangat negatif) dan pasif (sangat positif).  Mereka juga memiliki akun aktif-pasif, tetapi jika alasan dan kehidupan sangat berharga bagi Anda, menjauhlah dari rawa gambut akuntansi, karena mereka bahkan memiliki "saldo pada akun yang tidak seimbang", keberadaan yang tidak dimiliki oleh setiap orang. </p><br><p>  Artinya adalah sebagai berikut.  Karena fakta bahwa akun penerbit mungkin negatif, mereka mentransfer uang yang tidak mereka miliki dan dengan demikian “mencetaknya”.  Secara teoritis, mereka dapat melakukan ini dalam jumlah berapa pun.  Dalam praktiknya, penerbit adalah bagian dari sistem yang harus mengatur jumlah uang beredar.  Cara melakukan ini - setiap proyek memutuskan sendiri. </p><br><h2 id="inflyaciya">  Inflasi </h2><br><p>  Semua nilai total sistem diperkirakan dalam total utang peserta satu sama lain.  Unit moneter adalah kuantum dari total utang ini.  Semakin banyak unit moneter dimasukkan ke dalam sirkulasi, semakin rendah biaya masing-masing.  Dan semakin rendah nilai obyektif dari penghematan masing-masing peserta. </p><br><p>  Inflasi adalah efek samping dari masalah apa pun.  Jika memungkinkan, itu harus dihindari. </p><br><h2 id="deflyaciya">  Deflasi </h2><br><p>  Jika ada jumlah yang ditransfer ke akun penerbit, maka uang ini akan "dibakar".  Jumlah pasokan uang akan berkurang, nilai unit moneter akan meningkat, dan semua peserta dalam sistem akan menjadi sedikit lebih kaya.  Selain itu, sang dermawan, tentu saja, yang mengambil uangnya dari peredaran. </p><br><p>  Mekanisme insentif dapat dilampirkan pada mekanisme ini.  Misalnya, untuk memberikan kemampuan untuk melakukan beberapa tindakan untuk komisi yang didebit dari peserta dalam pertukaran uang.  Misalnya, membakar uangnya sendiri, seorang peserta mengumpulkan komisi untuk memproses pembayaran dari pengirim dana. </p><br><p>  Penghapusan bagian dari pasokan uang dari sirkulasi meningkatkan nilai dari bagian yang tersisa.  Dan proses ini layak merangsang, tetapi tidak terlalu aktif, karena jumlah uang beredar harus cukup besar untuk memastikan semua kegiatan yang diperlukan. </p><br><p>  Hal utama, seperti dalam segala hal, adalah keseimbangan dan rasa proporsi. </p><br><h2 id="ne-tolko-dengi">  Bukan hanya uang </h2><br><p>  Ketika kami berbicara tentang blockchain, kami menyebutkan basis data yang sewenang-wenang, dan bukan hanya catatan jumlah akun.  Jadi, kita dapat menyimpan informasi apa pun dalam database terdistribusi.  Ini membuka peluang besar.  Database publik yang tidak dapat dihancurkan dan dipalsukan akan menemukan aplikasi di mana-mana. </p><br><p>  Anda hanya perlu menemukan insentif bagi peserta untuk masuk akal bagi diri mereka sendiri dalam menjaga komputer mereka menyala. </p><br><h2 id="umnye-kontrakty">  Kontrak yang cerdas </h2><br><p>  Secara teknis, ini sama dengan prosedur tersimpan dalam database.  Yaitu, kode yang dapat dieksekusi dalam beberapa bahasa pemrograman, yang dapat membuat perubahan pada database.  Dan nama itu karena telah berkembang secara historis. </p><br><p>  Dalam cryptocurrency, kontrak pintar adalah jenis peserta yang bukan orang yang hidup, tetapi otomat yang perilakunya ditentukan oleh kode.  Ketika operasi pengiriman uang dilakukan kepada anggota ini, kode dijalankan.  Dia dapat melakukan apa saja - mentransfer jumlah yang diterima ke peserta lain dengan mencicil, menyimpan uang yang diterima hingga jam X dan kemudian memilih satu dan mentransfer semua uang kepadanya.  Yang terakhir, omong-omong, adalah implementasi klasik dari semua jenis roulette, lotere dan undian.  Anda cukup menyimpan informasi ke basis data yang telah dibayarkan oleh beberapa peserta untuk layanan ini, dan kemudian peserta lain yang terhubung akan dapat menerima informasi ini dan menyediakan layanan. </p><br><p>  Ada beberapa "automata" tertentu yang disebut "oracle".       ( , )      .              "" ,   .  ,         ,     . </p><br><p>    ,           .    -     ,      ,         . </p><br><p>        ,     —                  ,         . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kita bisa membuat mesin virtual terdistribusi di dalam basis terdistribusi. </font><font style="vertical-align: inherit;">Dapat diandalkan yang sama (yaitu, diverifikasi), seperti yang lainnya.</font></font></p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Faktanya, itu saja.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejumlah besar inovasi tidak lebih dari implementasi yang lebih efektif dari ide-ide yang dijelaskan di sini dalam satu atau lain bentuk. </font><font style="vertical-align: inherit;">Jika Anda diberitahu tentang sesuatu yang "revolusioner," ketahuilah bahwa mereka ingin menipu Anda.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Omong-omong, piramida tipe MMM sudah muncul di ruang bawah tanah. </font></font></p><br><p>  Terima kasih atas perhatian anda </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480220/">https://habr.com/ru/post/id480220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480210/index.html">Habr Weekly # 31 / Rambler vs Nginx, Tinkoff membayar dan “menjatuhkan” semua orang, membeli pajak lebih dari € 20, mendesain ulang Habr</a></li>
<li><a href="../id480212/index.html">Perusahaan Igor Sysoev lebih mahal daripada holding Rambler Group</a></li>
<li><a href="../id480214/index.html">Konversi PNG ke DDS dalam format DXT5 dan lihat hasilnya dengan menggunakan python</a></li>
<li><a href="../id480216/index.html">Rubicon selesai: nginx</a></li>
<li><a href="../id480218/index.html">Tahun kedua Q #</a></li>
<li><a href="../id480222/index.html">Layanan pekerja di .NET Core 3: apa itu dan mengapa itu perlu</a></li>
<li><a href="../id480226/index.html">Lanjutkan terbang dengan Xamarin. Bentuk 4.4</a></li>
<li><a href="../id480228/index.html">Posisi tim teknik Okko pada acara terkait Nginx</a></li>
<li><a href="../id480232/index.html">Sketsa modular</a></li>
<li><a href="../id480234/index.html">Ilmuwan Rusia telah mengembangkan tomograf inovatif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>