<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏿 👱 🔝 功能性React组件与基于类的组件有何不同？ 🌬️ 🎧 🙆🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="功能性React组件与基于类的组件有何不同？ 在相当长的一段时间内，对这个问题的传统答案是：“类的使用允许您使用组件的大量功能，例如状态。” 现在，随着钩子的出现，这个答案不再反映真实的情况。 

 您可能已经听说这些类型的组件中的一种具有比另一种更好的性能。 但是哪一个呢？ 多数测试此基准的基准都...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>功能性React组件与基于类的组件有何不同？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444348/"> 功能性React组件与基于类的组件有何不同？ 在相当长的一段时间内，对这个问题的传统答案是：“类的使用允许您使用组件的大量功能，例如状态。” 现在，随着<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">钩子</a>的出现，这个答案不再反映真实的情况。 <br><br> 您可能已经听说这些类型的组件中的一种具有比另一种更好的性能。 但是哪一个呢？ 多数测试此基准的基准都有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">缺陷</a> ，因此我将非常谨慎地根据其结果<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">得出结论</a> 。 性能主要取决于代码中发生的情况，而不取决于是否选择功能组件或基于类的组件来实现某些功能。 我们的研究表明，不同类型的组件之间的性能差异可以忽略不计。 但是，应注意，用于它们的优化策略略有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不同</a> 。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/x-/vn/je/x-vnjetrulggl4xjpo2jmitqjvg.jpeg"></a> <br><br> 无论如何，如果没有充分的理由，并且不介意比其他人先使用这些技术的人，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不建议您</a>使用新技术重写现有组件。  Hook仍然是一项新技术（与2014年的React库相同），并且React手册中尚未包括一些适用于它们的“最佳实践”。 <br><a name="habracut"></a><br> 我们终于到哪里去了？  React的功能组件和基于类的组件之间是否有根本的区别？ 当然也有这样的差异。 这些是使用此类组件的心理模型的差异。 在本文中，我将考虑它们之间最严重的区别。 自从2015年出现功能组件以来，它就已经存在，但是它经常被忽略。 它包含以下事实：功能组件捕获呈现的值。 让我们谈谈这到底意味着什么。 <br><br> 应当指出，该材料并不构成评估不同类型组件的尝试。 我只是描述了React中两种编程模型之间的区别。 如果您想根据创新了解更多有关功能组件的用法，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>挂钩问题列表。 <br><br><h2>  <font color="#3AC1EF">基于功能和类的组件代码的特征是什么？</font> </h2><br> 考虑以下组件： <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user);  };  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>);  };  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>  ); }</code> </pre> <br> 它显示一个按钮，该按钮通过按下<code>setTimeout</code>函数来模拟网络请求，然后显示一个确认操作的消息框。 例如，如果' <code>props.user</code> <code>'Dan'</code>存储在<code>props.user</code> ，则在消息窗口中，三秒钟后，将显示<code>'Followed Dan'</code> <code>props.user</code> <code>'Followed Dan'</code> 。 <br><br> 请注意，此处是否使用箭头函数或函数声明都没有关系。 表单<code>function handleClick()</code>构造将以完全相同的方式工作。 <br><br> 如何将此组件重写为类？ 如果仅重做刚刚检查过的代码，然后将其转换为基于类的组件代码，则会得到以下信息： <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br> 通常认为两个这样的代码片段是等效的。 在代码重构的过程中，开发人员通常是完全免费的，无需考虑可能的后果，就能将它们彼此转化。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/c7a/341/1d3c7a341ee3fcadc79df00e7d872e4b.gif"></div><br>  <i><font color="#999999">这些代码似乎是等效的</font></i> <br><br> 但是，这些代码段之间略有不同。 仔细看看它们。 看到区别了吗？ 例如，我没有立即看到她。 <br><br> 因此，对于那些想了解自己正在发生的事情的本质的人，我们将考虑这种差异，这是该代码的一个有效示例。 <br><br> 在继续之前，我想强调一下，所讨论的差异与React钩子无关。 顺便说一下，在前面的示例中，甚至没有使用钩子。 这是关于React中函数和类之间的区别。 而且，如果您打算在React应用程序中使用许多功能组件，那么您可能想了解这种区别。 <br><br> 实际上，我们将以React应用程序中经常遇到的错误为例来说明函数和类之间的差异。 <br><br><h2>  <font color="#3AC1EF">在React应用程序中常见的错误。</font> </h2><br> 打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例页面</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该页面</a>显示一个列表，您可以使用该列表选择用户配置文件，以及两个Profile按钮，分别由<code>ProfilePageFunction</code>和<code>ProfilePageClass</code> （按功能以及基于类）显示，其代码如上所示。 <br><br> 对于这些按钮中的每一个，请尝试执行以下操作序列： <br><br><ol><li> 点击按钮。 </li><li> 单击按钮后3秒钟之前更改选定的配置文件。 </li><li> 阅读消息框中显示的文本。 </li></ol><br> 完成此操作后，您将注意到以下功能： <br><br><ul><li> 当您单击具有所选<code>Dan</code>配置文件的功能组件所形成的按钮，然后切换到<code>Sophie</code>配置文件时，消息框中将显示<code>'Followed Dan'</code> 。 </li><li> 如果对由基于类的组件形成的按钮执行相同操作，将显示<code>'Followed Sophie'</code> 。 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/a44/911/386a449110202d5140d67336a0ade5a0.gif"></div><br>  <i><font color="#999999">基于类的组件功能</font></i> <br><br> 在此示例中，功能组件的行为是正确的。 如果我订阅了某人的个人资料，然后又切换到另一个个人资料，则我的组件不应怀疑我已订阅了谁的个人资料。 显然，基于类使用的机制的实现包含一个错误（顺便说一句，您肯定应该成为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sofia</a>的订阅者）。 <br><br><h2>  <font color="#3AC1EF">基于类的组件故障的原因</font> </h2><br> 为什么基于类的组件具有这种行为？ 为了理解这一点，让我们看一下我们类中的<code>showMessage</code>方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); };</code> </pre> <br> 此方法从<code>this.props.user</code>读取数据。  React中的属性是不可变的，因此它们不会更改。 但是，与往常一样，这是一个可变实体。 <br><br> 实际上，将其放在课堂上的目的在于改变的能力。  React库本身会定期执行<code>this</code>更改，从而允许使用最新版本的<code>render</code>方法和组件生命周期方法。 <br><br> 结果，如果我们的组件在执行请求期间重新渲染，则<code>this.props</code>将更改。 之后， <code>showMessage</code>方法<code>showMessage</code> “太新”的<code>props</code>实体中读取<code>user</code>值。 <br><br> 这使您可以对用户界面进行有趣的观察。 如果从概念上说用户界面是应用程序当前状态的函数，则事件处理程序是呈现结果的一部分-就像可见的呈现结果一样。 我们的事件处理程序“属于”特定的渲染操作以及特定的属性和状态。 <br><br> 但是，安排超时<code>this.props</code>读取的超时会违反此连接。  showMessage <code>showMessage</code>未“绑定”到任何特定的呈现操作；因此，它“丢失”了正确的属性。 从中读取数据会中断此连接。 <br><br><h2>  <font color="#3AC1EF">如何通过基于类的组件来解决问题？</font> </h2><br> 想象一下，React中没有功能组件。 那么如何解决这个问题呢？ <br><br> 我们需要某种机制来“恢复”具有正确属性的<code>render</code>方法与showMessage <code>showMessage</code>之间的连接，后者从属性中读取数据。 该机制应位于丢失具有正确数据的<code>props</code>本质的位置。 <br><br> 一种方法是事先在事件处理程序中读取<code>this.props</code> ，然后将读取的内容显式传递给<code>setTimeout</code>使用的回调函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {user} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage(user), <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br> 这种方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有效</a> 。 但是，随着时间的流逝，这里使用的其他构造将导致代码量的增加，并导致错误的可能性增加。 如果我们需要一个以上的财产怎么办？ 如果我们还需要与国家合作怎么办？ 如果<code>showMessage</code>方法<code>showMessage</code>另一个方法，并且此方法读取<code>this.props.something</code>或<code>this.state.something</code> ，那么我们将再次面临相同的问题。 为了解决这个问题，我们必须将<code>this.props</code>和<code>this.state</code>作为参数传递<code>this.props</code> <code>this.state</code>调用的所有方法。 <br><br> 如果确实如此，它将破坏使用基于类的组件所带来的所有便利。 您需要以这种方式使用方法的事实很难记住，也很难实现自动化，因此，开发人员经常（而不是使用类似的方法）同意他们的项目中存在错误。 <br><br> 同样，将<code>alert</code>代码嵌入<code>handleClick</code>不能解决更全局的问题。 我们需要对代码进行结构化，以便可以将其分为许多方法，而且还可以使我们读取与特定调用相关的呈现操作相对应的属性和状态。 顺便说一下，这个问题甚至不仅仅适用于React。 您可以在任何用于开发用户界面的库中播放该库，该库会将数据放入可变对象中，例如<code>this</code> 。 <br><br> 也许为了解决此问题，您可以在构造函数中将方法绑定<code>this</code>方法？ <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } showMessage() {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); } handleClick() {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br> 但这不能解决我们的问题。 请记住，这是因为我们从<code>this.props</code>中读取数据太晚了，而不是使用所使用的语法！ 但是，如果我们依靠JavaScript闭包，则将解决此问题。 <br><br> 开发人员经常尝试避免闭包，因为考虑随着时间的推移无法改变的价值<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并不容易</a> 。 但是React中的属性是不可变的！  （或者至少强烈建议这样做）。 这使您可以停止将闭包视为某种东西，因此程序员可以如他们所说的那样“自“”。 <br><br> 这意味着，如果您“锁定”了闭包中特定渲染操作的属性或状态，则始终可以指望它们保持不变。 <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-comment"><span class="hljs-comment">//  !   const props = this.props;   //    ,      render.   //   -   .   const showMessage = () =&gt; {     alert('Followed ' + props.user);   };   const handleClick = () =&gt; {     setTimeout(showMessage, 3000);   };   return &lt;button onClick={handleClick}&gt;Follow&lt;/button&gt;; } }</span></span></code> </pre> <br> 如您所见，此处我们在调用<code>render</code>方法期间“捕获”了属性。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/83d/d56/fa483dd5699aac1350c57591770a49be.gif"></div><br>  <i><font color="#999999">渲染调用捕获的属性</font></i> <br><br> 使用这种方法，可以保证<code>render</code>方法中的任何代码（包括<code>showMessage</code> ）都可以看到在对该方法的特定调用期间捕获的属性。 结果，React将不再能够阻止我们做我们需要做的事情。 <br><br> 在<code>render</code>方法中，您可以描述任意数量的辅助功能，并且所有这些功能都可以使用“捕获的”属性和状态。 这就是闭包如何解决我们的问题的方式。 <br><br><h2>  <font color="#3AC1EF">使用闭包分析问题的解决方案</font> </h2><br> 我们刚刚得到的结果使我们能够<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解决问题</a> ，但是这样的代码看起来很奇怪。 如果在<code>render</code>方法中声明了函数而不是在类方法中声明了，为什么根本需要一个类？ <br><br> 实际上，我们可以通过以包围它的类的形式摆脱“外壳”来简化此代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br> 在这里，与前面的示例一样，属性是在函数中捕获的，因为React将它们作为参数传递给它。 与<code>this</code>不同的是，React永远不会<code>props</code>对象。 <br><br> 如果在函数声明<code>props</code>销毁了<code>props</code>这将变得更加明显： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br> 当父组件使用其他属性<code>ProfilePage</code>时，React将<code>ProfilePage</code>调用<code>ProfilePage</code>函数。 但是已经被调用的事件处理程序属于该函数的上一次调用，该调用使用其自己的<code>user</code>值和其自身的showMessage <code>showMessage</code> （读取此值）。 所有这些都保持不变。 <br><br> 这就是为什么在我们的示例的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始</a>版本中，当使用功能组件时，在显示消息之前单击相应按钮后选择另一个配置文件不会更改任何内容。 如果在单击按钮之前选择了<code>Sophie</code>个人资料，无论发生什么， <code>'Followed Sophie'</code>将显示在消息窗口中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/843/96c/4b3/84396c4b3982827bead96912a947904e.gif"></div><br>  <i><font color="#999999">使用功能组件</font></i> <br><br> 此行为是正确的（您可能还想注册<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sunil</a> ）。 <br><br> 现在我们已经弄清楚React中的函数和类之间的最大区别是什么。 如前所述，我们正在谈论功能组件捕获值的事实。 现在让我们谈谈钩子。 <br><br><h2>  <font color="#3AC1EF">钩子</font> </h2><br> 使用挂钩时，“捕获值”的原理扩展到该状态。 考虑以下示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + message); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;&gt;     &lt;input value={message} onChange={handleMessageChange} /&gt;     &lt;button onClick={handleSendClick}&gt;Send&lt;/button&gt;   &lt;/&gt; ); }</code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>你可以尝试他 <br><br> 尽管这不是消息传递应用程序界面的示例，但该项目说明了相同的想法：如果用户发送了消息，则不应混淆该组件以发送哪个消息。 该功能组件的<code>message</code>常量捕获“属于”该组件的状态，该状态使浏览器获得对其调用的按钮的单击处理程序。 结果， <code>message</code>存储了单击“ <code>Send</code>按钮时输入字段中的内容。 <br><br><h2>  <font color="#3AC1EF">通过功能组件捕获属性和状态的问题</font> </h2><br> 我们知道，默认情况下，React中的功能组件会捕获属性和状态。 但是，如果我们需要从不属于特定函数调用的属性或状态中读取最新数据，该怎么办？ 如果我们想“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从未来阅读它们</a> ”怎么办？ <br><br> 在基于类的组件中，这可以简单地通过引用<code>this.props</code>或<code>this.state</code>来完成，因为<code>this</code>是可变实体。 她的变化是参与React。 功能组件还可以使用所有组件共享的可变值。 这些值称为<code>ref</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     `ref.current`. // ... }</span></span></code> </pre> <br> 但是，程序员需要独立管理这些值。 <br><br>  <code>ref</code>的本质与类的实例的字段起相同的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">作用</a> 。 这是进入可变命令世界的“紧急出口”。 您可能熟悉DOM refs的概念，但是这种想法更为笼统。 可以将其与程序员可以放入东西的盒子进行比较。 <br><br> 甚至在外部，形式<code>this.something</code>的构造看起来也像<code>something.current</code>构造的镜像。 它们代表了相同的概念。 <br><br> 默认情况下，React不会在功能组件中为最新的属性或状态值创建<code>ref</code>实体。 在许多情况下，您将不需要它们，并且自动创建它们将浪费时间。 但是，如有必要，可以与他们一起组织活动： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latestMessage = useRef(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + latestMessage.current); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value);   latestMessage.current = e.target.value; };</code> </pre> <br> 如果我们在<code>showMessage</code>阅读了该<code>message</code> ，那么在单击“ <code>Send</code>按钮时，我们将看到该字段中的消息。 但是，如果您阅读<code>latestMessage.current</code> ，则可以获得最新值-即使我们在单击“ <code>Send</code>按钮后继续在字段中输入文本。 <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将此</a>示例与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本</a>示例进行比较，以独立评估差异。  <code>ref</code>的值是“避免”渲染均匀性的一种方式，在某些情况下它可能非常有用。 <br><br> 通常，应避免在渲染过程中读取或写入<code>ref</code>值，因为这些值是可变的。 我们努力使渲染可预测。 但是，如果我们需要获取存储在属性或状态中的某些事物的最新值，则手动更新<code>ref</code>值可能是一项繁琐的任务。 可以使用以下效果使其自动化： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . const latestMessage = useRef(''); useEffect(() =&gt; {   latestMessage.current = message; }); const showMessage = () =&gt; {   alert('You said: ' + latestMessage.current); };</span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>使用此代码的示例 <br><br> 我们在效果内分配了一个值，因此， <code>ref</code>的值仅在DOM更新后才会更改。 这确保了我们的突变不会破坏依赖于渲染操作连续性的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时间切片”和“暂挂”等</a>功能。 <br><br> 经常不需要以这种方式使用<code>ref</code>值。 捕获属性或状态通常看起来是标准系统行为的更好模式。 但是，在使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令性API</a> （例如使用间隔或订阅的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令性API）</a>时，这可能很方便。 请记住，您可以使用任何值进行此操作-使用属性，状态中存储的变量，整个<code>props</code>对象甚至使用函数。 <br><br> 此外，此模式对于优化目的可能很有用。 例如，当诸如<code>useCallback</code>类的<code>useCallback</code>改变得太频繁时。 没错， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">首选解决方案</a>通常是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用减速器</a> 。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在本文中，我们研究了使用基于类的组件的错误模式之一，并讨论了如何使用闭包解决此问题。 但是，您可能会注意到，当您尝试通过指定依赖项数组来优化挂钩时，可能会遇到与过时的闭包有关的错误。 这是否意味着故障本身就是问题。 我不这么认为。 <br><br> 如上所示，闭包实际上可以帮助我们解决难以发现的小问题。 同样，它们使编写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并行</a>运行的代码变得更加容易。 这可能是由于以下事实：“内部”锁定了渲染组件的正确属性和状态。 <br><br> 到目前为止，在所有情况下，由于“功能不变”或“属性始终保持不变”的错误假设，出现了“过时的关闭”问题。 我希望阅读完这些材料后，您可以确信事实并非如此。 <br><br> 函数“捕获”它们的属性和状态-因此了解哪些函数是重要的。 这不是一个错误；它是功能组件的功能。 例如，不应将功能从<code>useEffect</code>或<code>useCalback</code>的“依赖项数组”中<code>useEffect</code> 。  （解决问题的合适工具通常是<code>useReducer</code>或<code>useRef</code> 。我们在上面已经讨论过，很快我们将准备用于选择这种方法的材料）。 <br><br> 如果我们应用程序中的大多数代码都基于功能组件，这意味着我们需要更多地了解<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码优化</a> ，以及随着时间的推移哪些值可能会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">改变</a> 。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>     : «  ,   ,    ,   ,    ,         ». <br><br>          .  ,        React    ,   .     ,    « »,     . ,         React  . <br><br>      ,      ,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc3/bdd/f6d/fc3bddf6d4ca14bc77917ac0cfad3608.gif"></div><br> <i><font color="#999999">  React —    </font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444348/">https://habr.com/ru/post/zh-CN444348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444338/index.html">Python 3中的封装</a></li>
<li><a href="../zh-CN444340/index.html">在JavaScript中使用Symbol数据类型的功能</a></li>
<li><a href="../zh-CN444342/index.html">使用Webpack和高级Web技术开发简单，现代的JavaScript应用程序</a></li>
<li><a href="../zh-CN444344/index.html">成功的Python项目的10个步骤</a></li>
<li><a href="../zh-CN444346/index.html">GraphQL和Golang</a></li>
<li><a href="../zh-CN444350/index.html">由于某些原因，MVP（最低可行产品）无法启动</a></li>
<li><a href="../zh-CN444352/index.html">Kontur.Kampus：我们邀请您参观圣彼得堡附近的工业发展免费学生营</a></li>
<li><a href="../zh-CN444356/index.html">React教程第24部分：第二形式课</a></li>
<li><a href="../zh-CN444358/index.html">可枚举：如何产生业务价值</a></li>
<li><a href="../zh-CN444360/index.html">不公正的Google Play是美好的生活体验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>