<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏾 👨🏾‍🚀 🚛 亚马逊云服务和投资组合分析 🚎 🚆 ☔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，股票市场出现了高波动性，例如，某家知名公司的稳定票据可能因对其管理层实施制裁的消息而立即损失数个百分点，反之亦然，因为积极的报告以及投资者对超利润股利的期望反而飙升。 

 如何确定给定证券的所有权是带来收入还是仅带来损失和失望？ 

 （来源） 

 在本文中，我将告诉您如何识别和可视化调整...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>亚马逊云服务和投资组合分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426027/"> 最近，股票市场出现了高波动性，例如，某家知名公司的稳定票据可能因对其管理层实施制裁的消息而立即损失数个百分点，反之亦然，因为积极的报告以及投资者对超利润股利的期望反而飙升。 <br><br> 如何确定给定证券的所有权是带来收入还是仅带来损失和失望？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q3/2q/zs/q32qzs8fmzzpilpnbmfcek6l57a.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（来源）</a> <br><br> 在本文中，我将告诉您如何识别和可视化调整后的证券财务结果。 <br><br> 通过使用客户报告Opening Broker的示例，我们将考虑分析和合并针对股票市场的经纪报告，构建云报告系统的架构，并在AWS Quicksight中进行简单，方便的分​​析。 <br><a name="habracut"></a><br><h2> 任务说明 </h2><br> 许多培训和教育课程告诉我们有关交易者日记的需求，记录所有交易参数以供进一步分析和总结交易策略。 我同意，在交易所工作的这种方法可以使您对交易者进行纪律处分，提高其意识，但是它也可能使您摆脱繁琐的过程。 <br><br> 我承认，起初我认真尝试遵循日记的建议，在Excel表中仔细记录了每个交易及其参数，构建了一些报告，摘要图表，计划的未来交易，但是……我很快就厌倦了这一切。 <br><br><div class="spoiler">  <b class="spoiler_title">为什么手动保存交易者的日志很不方便？</b> <div class="spoiler_text"><ul><li> 手动填充日志（即使使用部分自动化，也可以从交易终端卸载日常交易的形式）很快就累了； </li><li> 手动输入有很大的错误或错别字的风险； </li><li> 主动交易者可能成为被动投资者，他越来越少回到该杂志，然后完全忘记它（我的情况）； 好，最后 </li><li> 我们可以编程，为什么不利用它来使整个过程自动化呢？ 所以，走吧！ </li></ul></div></div><br> 经纪公司通常是高科技组织，可以为客户提供几乎所有感兴趣的问题的相当高质量的分析。 可以说，每次更新此报告都将越来越好，但是即使是最高级的报告也可能没有苛刻和好奇的客户希望看到的自定义和合并。 <br><br> 例如，Opening Broker允许您以个人帐户接收XML格式的经纪报告，但是如果您在莫斯科证券交易所（MOEX）上拥有IIA和常规经纪帐户，则这将是两个不同的报告，并且如果您在St.彼得斯堡证券交易所（SPB），那么前两个将再增加一个。 <br><br> 总体而言，为了获得投资者的合并日记帐，有必要处理XML格式的三个文件。 <br><br> 上述关于MOEX和SPB的报告的格式略有不同，在实现数据映射的过程中需要考虑这些报告。 <br><br><h2> 正在开发的系统架构 </h2><br> 下图显示了正在开发的系统的体系结构模型： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/uq/ed/vvuqedfvl-l8tnghx3v6vtujabc.jpeg"></div><br><h2> 解析器实现 </h2><br> 我们将在最大可能的期限内收到有关“个人帐户”中所有三个帐户的报告（每年可分为几份报告），将其保存为XML格式并将其放在一个文件夹中。 作为研究的测试数据，我们将使用虚拟的客户组合，但参数应尽可能接近市场实际情况。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/og/ig/xw/ogigxw4yganahuuzbdqecsbqmry.png"></div><br> 假设正在考虑的投资者X先生拥有五种证券的少量投资组合： <br><br><ol><li> 有关SPB交换的报告将有两篇论文：Apple和Microsoft；以及Microsoft。 </li><li> 关于MOEX交易所（经纪）的报告包含一篇论文：FGC UES； </li><li>  MOEX交易所（IIS）上的报告包含两种证券：MMK和OFZ 24019； </li></ol><br> 根据我们的五种证券，在买卖中可能会发生交易，支付股息和息票，价格可能会发生变化等。 我们希望看到当前的状况，即：财务结果，考虑到所有付款，交易和当前的市场价值。 <br><br>  Python开始发挥作用，我们将所有报告中的信息读入一个数组： <br><br><pre><code class="python hljs">my_files_list = [join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listdir(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isfile(join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f))] my_xml_data = [] <span class="hljs-comment"><span class="hljs-comment">#     for f in my_files_list: tree = ET.parse(f) root = tree.getroot() my_xml_data.append(root)</span></span></code> </pre> <br><blockquote> 为了进行分析，从报告中我们需要几个实体，即： <br><br><ul><li> 证券在投资组合中的头寸； </li><li> 达成交易； </li><li> 非交易业务和其他账户变动； </li><li> 未平仓合约的平均价格 </li></ul></blockquote> 为了准备样本，我们将使用四个字典来描述上述集合。 <br><br><pre> <code class="python hljs">dict_stocks = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost_rub'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'saldo'</span></span> : []} dict_deals = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'quantity'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'price'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'brokerage'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: []} dict_flows = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: []} dict_avg_price = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'avg_open_price'</span></span> : []}</code> </pre> <br> 关于这些词典的全部内容，请说几句话。 <br><br><div class="spoiler">  <b class="spoiler_title">Dict_stocks字典</b> <div class="spoiler_text"> 需要dict_stocks词典来存储投资组合中的常规信息： <br><br><ul><li> 纸名（stock_name）； </li><li> 帐户名称（SPB，MOEX BROK，MOEX IIS）（帐户）； </li><li> 用于本文结算的货币（货币）； </li><li> 当前值（在“个人开户经纪人”中生成报告时）（current_cost）。 在此，我想指出，对于需求量过大的客户，有可能在将来进行其他改进，并使用来自交易终端或相应交易所网站的安全报价的动态接收； </li><li> 生成报告时安全位置的当前值（current_cost_rub） <br> 与上述项目类似，在这里您还可以根据需要获取当前时刻的中央银行汇率或汇率。 </li><li> 证券当前余额（Saldo） </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">字典dict_deals</b> <div class="spoiler_text"> 需要dict_deals词典来存储有关已完成事务的以下信息： <br><br><ul><li> 纸名（stock_name）； </li><li> 帐户名称（SPB，MOEX BROK，MOEX IIS）（帐户）； </li><li> 交易日期，即  T0（date_oper）; </li><li> 操作类型（type_oper）； </li><li> 参与交易的证券数量（数量）； </li><li> 交易执行的价格（价格）； </li><li> 进行交易的货币（货币）； </li><li> 交易经纪佣金（经纪）； </li><li> 交易的财务结果（结果） </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dict_flows字典</b> <div class="spoiler_text">  dict_flows词典反映了客户帐户上资金的流动，并用于存储以下信息： <br><br><ul><li> 纸名（stock_name）； </li><li> 帐户名称（SPB，MOEX BROK，MOEX IIS）（帐户）； </li><li> 交易日期，即  T0（date_oper）; </li><li> 操作类型（type_oper）。 它可以采用多个值：div，NKD，税； </li><li> 进行交易的货币（货币）； </li><li> 运营的财务结果（结果） </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">字典dict_avg_price</b> <div class="spoiler_text">  dict_avg_price词典对于以每张纸的平均购买价提供会计信息是必需的： <br><br><ul><li> 纸名（stock_name）； </li><li> 帐户名称（SPB，MOEX BROK，MOEX IIS）（帐户）； </li><li> 未平仓合约的平均价格（avg_open_price） </li></ul></div></div><br> 我们处理一系列XML文档，并使用适当的数据填写这些词典： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       for XMLdata in my_xml_data: #      exchange_name = 'SPB' if XMLdata.get('board_list') == ' ' else 'MOEX' client_code = XMLdata.get('client_code') account_name = get_account_name(exchange_name, client_code) #   current_position, deals, flows, stock_name, \ saldo, ticketdate, price, brokerage, \ operationdate, currency, \ current_cost, current_cost_rub, \ stock_name_deal, payment_currency, currency_flows = get_allias(exchange_name) #      get_briefcase(XMLdata) df_stocks = pd.DataFrame(dict_stocks) df_stocks.set_index("stock_name", drop = False, inplace = True) #    get_deals(XMLdata) df_deals = pd.DataFrame(dict_deals) df_avg = pd.DataFrame(dict_avg_price) #       get_nontrade_operation(XMLdata) df_flows = pd.DataFrame(dict_flows)</span></span></code> </pre> <br> 所有处理都将遍历报告中的所有XML数据。 所有报告中有关交易平台，客户代码的信息都是相同的，因此您可以安全地从相同的标记中提取它，而无需使用映射。 <br><br> 但是随后我们必须使用一种特殊的设计，该设计将根据报告（SPB或MOEX）为标记提供必要的别名，因为 这些报告中本质上相同的数据被称为“不同”。 <br><br><div class="spoiler">  <b class="spoiler_title">标签差异</b> <div class="spoiler_text"><ul><li>  SBP报告中的交易经纪人佣金位于<b>经纪人</b>标签和MOEX报告中<b>-broker_commission</b> ； </li><li>  SPB报表中的非交易帐户交易日期是<b>operationdate</b> ，而在MOEX中，它是<b>operation_date</b>等。 </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">标签映射示例</b> <div class="spoiler_text"><pre> <code class="python hljs">tags_mapping = { <span class="hljs-string"><span class="hljs-string">'SPB'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'briefcase_position'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'closed_deal'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'nontrade_money_operation'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'issuername'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currencycode'</span></span> }, <span class="hljs-string"><span class="hljs-string">'MOEX'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_assets'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_main_deals_conclusion'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_non_trade_money_operations'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'security_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'price_currency_code'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currency_code'</span></span> } }</code> </pre></div></div><br>  get_allias函数以交易平台的名称作为输入，返回进行处理所需的标记的名称： <br><br><div class="spoiler">  <b class="spoiler_title">Get_allias函数</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_allias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'current_position'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'deals'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'flows'</span></span>], ... tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>] )</code> </pre></div></div><br> 函数get_briefcase负责处理有关客户组合状态的信息： <br><br><div class="spoiler">  <b class="spoiler_title">Get_briefcase函数</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#         briefcase_position briefcase_position = XMLdata.find(current_position) if not briefcase_position: return try: for child in briefcase_position: stock_name_reduce = child.get(stock_name).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_stocks['stock_name'].append(stock_name_reduce) dict_stocks['account'].append(account_name) dict_stocks['currency'].append(child.get(currency)) dict_stocks['current_cost'].append(float(child.get(current_cost))) dict_stocks['current_cost_rub'].append(float(child.get(current_cost_rub))) dict_stocks['saldo'].append(float(child.get(saldo))) except Exception as e: print('get_briefcase --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br> 接下来，get_deals函数检索有关事务的信息： <br><br><div class="spoiler">  <b class="spoiler_title">Get_deals函数</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_deals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> stock_name_proc = <span class="hljs-string"><span class="hljs-string">''</span></span> closed_deal = XMLdata.find(deals) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> closed_deal: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">#   SPB    -    , #    MOEX:  ,      #    : if exchange_name == 'SPB': sortchildrenby(closed_deal, stock_name_deal) for child in closed_deal: sortchildrenby(child, stock_name_deal) try: for child in closed_deal: stock_name_reduce = child.get(stock_name_deal).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_deals['stock_name'].append(stock_name_reduce) dict_deals['account'].append(account_name) dict_deals['date_oper'].append(to_dt(child.get(ticketdate)).strftime('%Y-%m-%d')) current_cost = get_current_cost(stock_name_reduce) #    SPB     - quantity, #   MOEX  : buy_qnty  sell_qnty if exchange_name == 'MOEX': if child.get('buy_qnty'): quantity = float(child.get('buy_qnty')) else: quantity = - float(child.get('sell_qnty')) else: quantity = float(child.get('quantity')) dict_deals['quantity'].append(quantity) dict_deals['price'].append(float(child.get('price'))) dict_deals['type_oper'].append('deal') dict_deals['currency'].append(child.get(payment_currency)) brok_comm = child.get(brokerage) if brok_comm is None: brok_comm = 0 else: brok_comm = float(brok_comm) dict_deals['brokerage'].append(float(brok_comm)) #         if stock_name_proc != stock_name_reduce: if stock_name_proc != '': put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] stock_name_proc = stock_name_reduce pnl = PnlSnapshot(stock_name_proc, float(child.get('price')), quantity) dict_deals['result'].append(-1 * brok_comm) else: pnl.update_by_tradefeed(float(child.get('price')), quantity) #  ,   if quantity &lt; 0: if pnl.m_realized_pnl &gt; 0 and exchange_name != 'SPB': pnl_sum = pnl.m_realized_pnl * 0.87 - brok_comm else: pnl_sum = pnl.m_realized_pnl - brok_comm dict_deals['result'].append(float(pnl_sum)) else: pnl.update_by_marketdata(current_cost) dict_deals['result'].append(-1 * brok_comm) put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] except Exception as e: print('get_deals --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br> 除了使用有关交易参数的信息处理数组外，此处还计算了由PNL使用FIFO方法实现的未平仓头寸的平均价格。  PnlSnapshot类负责此计算，通过稍作修改即可创建该模型，并以此处提供的代码为基础： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">损益计算</a> <br><br> 最后，最难实现的功能是获取有关非交易操作的信息的功能<b>-get_nontrade_operation</b> 。 其复杂性在于以下事实：在用于非交易操作的报告块中，没有关于交易类型和与此操作相关的安全性的明确信息。 <br><br><div class="spoiler">  <b class="spoiler_title">非交易操作的付款目的地示例</b> <div class="spoiler_text"> 股息或累积的票息收入的支付可以表示如下： <br><br><ol><li> 支付收入客户&lt;777777&gt;的<font color="#cc0000">股利</font> &lt; <font color="#cc0000">APPLE</font> INC-ao&gt;-&gt;从SPB报告中支付股利； </li><li> 支付收益客户&lt;777777&gt;的<font color="#cc0000">股息</font> &lt; <font color="#cc0000">MICROSOFTCOM</font> -&gt; </li><li> 支付客户收入777777i（NKD 2 <font color="#cc0000">OFZ 24019</font> ）预扣税0.00卢布-&gt;从MOEX报告中支付优惠券； </li><li> 向客户<font color="#cc0000">支付FGC UES</font> 777777的股息-代缴预提税XX.XX卢布-&gt;从MOEX报告中支付股息。 等 </li></ol></div></div><br> 因此，没有正则表达式将很难做到，因此我们将充分利用它们。 问题的另一面是，公司的名称并不总是与投资组合或交易中的付款名称一致。 因此，从支付目的接收到的发行者的名称必须与词典另外相关。 作为字典，我们将使用一系列交易，因为 有最完整的公司列表。 <br><br>  <b>get_company_from_str</b>函数从注释中检索发行者名称： <br><br><div class="spoiler">  <b class="spoiler_title">Get_company_from_str函数</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comment)</span></span></span><span class="hljs-function">:</span></span> company_name = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-comment"><span class="hljs-comment">#    / flows_pattern = [ '^.+\s&lt;(\w+)?.+-&gt;$', '^.+\s(.+)-.+$', '^.+\(\s\d?\s(.+)\).+$', '^.+\s(.+)-.+$' ] for pattern in flows_pattern: match = re.search(pattern, comment) if match: return match.group(1).upper() return company_name</span></span></code> </pre> </div></div><br> 如果<b>get_company_from_briefcase</b>函数在参与交易的公司之间找到匹配项，则会将公司名称引到字典中： <br><br><div class="spoiler">  <b class="spoiler_title">Get_company_from_briefcase函数</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(company_name)</span></span></span><span class="hljs-function">:</span></span> company_name_full = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> value_from_dic = df_deals[df_deals[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].str.contains(company_name)] company_arr = value_from_dic[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].unique() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(company_arr) == <span class="hljs-number"><span class="hljs-number">1</span></span>: company_name_full = company_arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> company_name_full</code> </pre> <br></div></div><br> 最后，收集非交易操作数据的最终功能是<b>get_nontrade_operation</b> ： <br><br><div class="spoiler">  <b class="spoiler_title">Get_nontrade_operation函数</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nontrade_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> nontrade_money_operation = XMLdata.find(flows) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> nontrade_money_operation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nontrade_money_operation: comment = child.get(<span class="hljs-string"><span class="hljs-string">'comment'</span></span>) type_oper_match = re.search(<span class="hljs-string"><span class="hljs-string">'||^.+.+.+$'</span></span>, comment) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type_oper_match: company_name = get_company_from_str(comment) type_oper = get_type_oper(comment) dict_flows[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].append(company_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'account'</span></span>].append(account_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>].append(to_dt(child.get(operationdate)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>)) dict_flows[<span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>].append(type_oper) dict_flows[<span class="hljs-string"><span class="hljs-string">'result'</span></span>].append(float(child.get(<span class="hljs-string"><span class="hljs-string">'amount'</span></span>))) dict_flows[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>].append(child.get(currency_flows)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'get_nontrade_operation --&gt; Oops! It seems we have a BUG!'</span></span>, e)</code> </pre> </div></div><br> 从报告中收集数据的结果将是三个数据框，大致如下： <br><br><ol><li> 带有未平仓合约平均价格信息的DataFrame： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1o/c-/qs/1oc-qs_akl5cvraaq7sg7pvfwfu.png"></div></li><li> 交易数据框： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/lp/xb/gqlpxby2utfl0ahr-fm8l_fqywc.png"></div></li><li> 包含有关非交易操作信息的DataFrame： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/-7/su/hx-7suk1zgheyiyr6ov6o0z5yd0.png"></div><br></li></ol><br> 因此，剩下要做的就是对交易表和投资组合信息表进行外部联合： <br><br><pre> <code class="python hljs">df_result = pd.merge(df_deals, df_stocks_avg, how=<span class="hljs-string"><span class="hljs-string">'outer'</span></span>, on=[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency'</span></span>]).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/wj/nz/jowjnzmldhgscs30ynz5lrdcueu.png"></div><br> 最后，处理数据数组的最后一部分是将上一步中获得的数据数组与用于非交易事务的DataFrame合并。 <br> 完成工作的结果是一张大的平台，其中包含所有需要分析的信息： <br><br><pre> <code class="python hljs">df_result_full = df_result.append(df_flows, ignore_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result_full.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>).head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jc/rh/ccjcrh4dq5auyrg3jba6csb_s0g.png"></div><br> 来自DataFrame的结果数据集（最终报告）可以轻松上传到CSV，然后可以在任何BI系统中用于详细分析。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exists(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>): makedirs(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>) report_name = <span class="hljs-string"><span class="hljs-string">'OUTPUT\my_trader_diary.csv'</span></span> df_result_full.to_csv(report_name, index = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8-sig'</span></span>)</code> </pre> <br><br><h2> 在AWS中上载和处理数据 </h2><br> 进展不会停滞不前，现在云服务和无服务器计算模型在数据处理和存储中越来越受欢迎。 这主要是由于这种方法的简单性和廉价性，当您不需要购买昂贵的设备来构建用于复杂计算或处理大数据的系统架构时，您只需在需要的时间租用云中的电源，并以相对较低的费用足够快地部署必要的资源即可。 。 <br><br> 市场上最大和最知名的云提供商之一是亚马逊。 让我们看一下Amazon Web Services（AWS）环境的示例，以构建一个分析系统来处理投资组合中的数据。 <br><br>  AWS有多种工具可供选择，但我们将使用以下工具： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Amazon S3-</a>对象存储，可让您存储几乎无限量的信息； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AWS Glue-</a>最强大的云ETL服务，它本身可以确定结构并根据给定的源数据生成ETL代码； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Amazon Athena</a>是一种无服务器的在线SQL查询服务，可让您无需进行大量准备就可以快速分析S3中的数据。 他还可以访问AWS Glue准备的元数据，这使您可以在传递ETL之后立即访问数据。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Amazon QuickSight-</a>无服务器BI服务，您可以构建任何可视化，“即时”分析报告等。 </li></ul><br> 可以使用Amazon的文档，特别是有一篇不错的文章， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《将Athena与AWS Glue一起使用时的最佳做法》</a> ，其中描述了如何使用AWS Glue创建和使用表和数据。 让我们利用本文的主要思想，并将其应用于创建我们自己的分析报告系统的体系结构。 <br><br> 我们的报告解析器准备的CSV文件将添加到S3存储桶中。 计划在每个星期六（在交易周结束时）对S3上的相应文件夹进行补充，因此，如果不能在报表的形成和处理日期之前对数据进行分区，就无法进行。 <br> 除了优化对此类数据的SQL查询操作之外，这种方法还将使我们能够进行其他分析，例如，获取每篇论文的财务结果变化的动态等。 <br><br><div class="spoiler">  <b class="spoiler_title">使用Amazon S3</b> <div class="spoiler_text"><ul><li> 在S3上创建一个存储桶，将其命名为“ report-parser”； </li><li> 在此存储区“ report-parser”中创建一个名为“ my_trader_diary”的文件夹； </li><li> 在目录“ my_trader_diary”中，创建一个包含当前报告日期的目录，例如，“ date_report = 2018-10-01”，并将CSV文件放入其中； </li><li> 仅出于实验目的和对分区的更好理解，我们将再创建两个目录：“ date_report = 2018-09-27”和“ date_report = 2018-10-08”。 我们将相同的CSV文件放入其中； </li><li> 最终的S3存储桶“报告解析器”应类似于下图所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n1/4z/c9/n14zc9odchiv6l-_dpc_qbs3s_o.png"></div></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">使用AWS Glue</b> <div class="spoiler_text"> 总的来说，您只能使用Amazon Athena来根据S3上的数据创建外部表，但是AWS Glue是一种更灵活，更方便的工具。 <br><br><ul><li> 我们进入AWS Glue并创建一个新的Crawler，它将通过报告日期从单独的CSV文件中收集一个表： <br><ul><li> 设置新的Crawler的名称； </li><li> 我们指出从何处获取数据的存储库（s3：// report-parser / my_trader_diary /） </li><li> 我们选择或创建一个新的IAM角色，该角色将有权启动Crawler并访问S3上的指定资源； </li><li> 接下来，您需要设置开始频率。 我们现在按需设置它，但是在将来，我认为这种情况将会改变，并且发布会变成每周一次。 </li><li> 保存并等待创建抓取工具。 </li></ul></li><li> 搜寻器进入“就绪”状态时，请启动它！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/xx/z9/edxxz9kurfrebky5-fuaqwzt-0e.png"></div></li><li> 一旦工作，新的my_trader_diary表将出现在AWS Glue：“数据库”-&gt;“表”选项卡中： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u6/2n/rt/u62nrttephj6m-hxxguky4il6os.png"></div></li></ul></div></div><br> 请更详细地考虑生成的表。 <br> 如果单击创建的表的名称，那么我们将转到包含元数据描述的页面。 在底部有一个表格布局，最近的是一列，该列不在源CSV文件中-date_report。  AWS Glue的此列基于源数据的各个部分的定义自动创建（在存储桶S3中，我们特别命名了文件夹date_report = YYYY-MM-DD，这使我们可以将它们用作按日期分隔的部分）。 <br><br><div class="spoiler">  <b class="spoiler_title">表分区</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/30/2v/5o302vb08y_zmylnfyaiign5us0.png"></div><br> 在右上角的同一页上，有一个“查看分区”按钮，通过单击它，我们可以看到生成的表包括哪些部分： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/82/0l/kk/820lkk4mytj34kzh0tt__ieb6me.png"></div></div></div><br><h2> 资料分析 </h2><br> 有了我们可以上载的已处理数据，我们可以轻松地开始分析它们。 首先，将Amazon Athena的功能视为执行分析查询的最简单，最快的方法。 为此，请转到Amazon Athena服务，选择我们需要的数据库（财务），然后编写以下SQL代码： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d.date_report, d.account, d.stock_name, d.currency, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.quantity) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> quantity, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.result), <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_trader_diary d <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.date_report, d.account, d.stock_name, d.currency <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.account, d.stock_name, d.date_report;</code> </pre> <br> 此请求将向我们显示每个证券在所有报告日期的净财务结果。 因为 我们在不同的日期下载了3次相同的报告，结果不会改变，当然，在实际市场中，结果会有所不同： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9o/fg/dl/9ofgdloafbrxbvctdyprolilvna.png"></div><br> 但是，如果我们想以灵活的表格或图表的形式可视化接收到的数据怎么办？ 在这里，Amazon QuickSight可以助您一臂之力，借助它，您几乎可以像编写SQL查询一样快地配置灵活的分析。 我们将转到Amazon QuickSight服务（如果您尚未在此处注册，则需要注册）。 <br><br> 单击新分析-&gt;新数据集按钮，然后在出现的窗口中选择数据集源，然后单击Athena： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kr/bv/yqkrbv144qas16af4jolsj3rnci.png"></div><br><br> 我们将为数据源命名，例如“ PNL_analysis”，然后单击“创建数据源”按钮。 <br><br> 接下来，“选择表”窗口打开，您需要在其中选择数据库和数据源表。 我们选择数据库-Financial，并选择其中的表：my_traider_diary。 默认情况下，将使用整个表，但是如果选择“使用自定义SQL”，则可以自定义和微调所需的数据样本。 例如，我们使用整个表格，然后单击“编辑/预览数据”按钮。 <br><br> 将打开一个新页面，您可以在其中进行其他设置并处理现有数据。 <br><br> 现在，我们需要向数据集中添加其他计算字段：运营季度和运营年份。 细心的读者可能会注意到，在将最终报告保存为CSV之前，在解析器方面更容易进行此类操作。 毫无疑问，我现在的目标是实时演示BI系统设置的功能和灵活性。 我们继续通过单击“新建字段”按钮来创建计算字段。 <br><br><div class="spoiler">  <b class="spoiler_title">创建一个新字段</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ax/1z/ag/ax1zagyy7nnryd62t5najdntcio.png"></div></div></div><br> 为了突出显示运营年份和季度，使用了简单的公式： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/yc/bi/pmycbiybxqtus62nkaa_5v2fu4s.png"></div><br><div class="spoiler">  <b class="spoiler_title">填写新字段的公式</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uo/e1/u1/uoe1u1uco3ygn7cljsr6qcnhwbk.png"></div></div></div><br> 成功创建计算字段并将其添加到选择后，请为我们的数据集命名，例如“ my_pnl_analyze”，然后单击“保存并可视化”按钮。 <br><br> 之后，我们将转移到Amazon QuickSight主板上，我们要做的第一件事是为报告日期设置一个过滤器（考虑到从三个部分收集了相同的数据）。 选择报告日期2018-10-01，然后单击“应用”按钮，然后转到“可视化”选项卡。 <br><br><div class="spoiler">  <b class="spoiler_title">筛选器设定</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/jo/et/anjoet5xt_divhygnebb5v9ys8k.png"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以在任何平面上可视化投资组合的结果，例如，针对交易帐户内的每种证券，然后依次按币种划分（因为结果在不同币种中不可比）和操作类型。</font><font style="vertical-align: inherit;">让我们从所有BI中最强大的工具开始-数据透视表。</font><font style="vertical-align: inherit;">为了节省空间和显示灵活性，我将货币放在单独的控件中（MS Excel中切片的类似物）</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/90/3e/it/903eitay8v9j1psyz05d8qaqh_k.png"></div><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上表显示，如果投资者决定现在出售FGC UES的所有股份，他将因此记录亏损，因为 </font><font style="vertical-align: inherit;">支付的股息为1,509.91便士。</font><font style="vertical-align: inherit;">它们不支付费用（1,763.36卢布-负汇率差，174卢布-股息个人所得税）。</font><font style="vertical-align: inherit;">等待并等待交易所上更好的时机是有意义的。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 下图是条形图： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/a7/qj/upa7qjdqjiqyo-j6tx0bnrth67m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们将形成一个表格，该表格将向我们显示我们在每张纸上投资了多少，投资组合中有多少天以及整个拥有期间的盈利能力是多少。</font><font style="vertical-align: inherit;">为此，添加两个新的计算字段：sum_investment和count_days。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段sum_investment</font></font></b> <div class="spoiler_text">   sum_investment ( )   : <br><br> ifelse({stock_name} = ' 24019',{avg_open_price} * quantity * 10,{avg_open_price} * quantity) <br><br>           ,       –     (    – 1000). <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段count_days</font></font></b> <div class="spoiler_text">   count_day (   )                : <br><br> dateDiff(parseDate({date_oper}),parseDate({date_report})) <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最终表显示在下面的屏幕快照中： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ws/dk/utwsdkbzhksrjh3wunw_w6stqr0.png"></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结论与总结 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经与您一起检查了报表解析器的实现以及使用Amazon服务“即时”分析其准备的数据的方法。我们还谈到了投资组合分析的一些业务和基本方面，例如这个主题几乎是巨大的，很难在一篇文章中进行介绍，我认为将其放在单独的出版物或什至一系列出版物中是很有意义的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至于经纪人报告处理工具的使用以及其中涉及的方法和算法，可以使用它们（进行适当的修改）来处理其他经纪人的报告。无论如何，如果您打算使代码适合您的需求，我准备提供一些提示，因此请随时提出问题-我一定会尽力回答。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我确信该系统将找到其应用并将进一步发展。例如，计划在投资组合的完整PNL的计算中增加对存入和其他费用（例如，提取资金）以及还清债券等的会计处理。...在下一版解析器中，Quicksight方面的计算字段用于演示目的，所有这些附加列都将移植到Python，并将在解析器端进行计算。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为该解决方案的架构师和主要业务客户，我看到了以下进一步升级：嗯，我不想每次都手动请求这些XML报告！</font><font style="vertical-align: inherit;">当然，到目前为止，没有其他可能性了，但是带有令牌传输和采样范围的Broker API非常适合接收每周原始报告。</font><font style="vertical-align: inherit;">随后在亚马逊方面进行全自动处理：从在AWS Glue上触发ETL-job到以Amazon QuickSight中的图形和表格形式获取现成的结果，您将可以完全自动化该过程。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的源代码可以在我的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">GitHub存储库中</font></a><font style="vertical-align: inherit;">找到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426027/">https://habr.com/ru/post/zh-CN426027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426017/index.html">如何减少动物实验次数</a></li>
<li><a href="../zh-CN426019/index.html">Arduino上的气象站，从A到Z。第5部分</a></li>
<li><a href="../zh-CN426021/index.html">libgdx和感受</a></li>
<li><a href="../zh-CN426023/index.html">公开课“ Vagrant的虚拟实验室”</a></li>
<li><a href="../zh-CN426025/index.html">使用进攻性方法丰富威胁情报</a></li>
<li><a href="../zh-CN426029/index.html">您是否放弃并想要退出任务？ 这就是有效的开发人员培训的样子</a></li>
<li><a href="../zh-CN426031/index.html">担心使用人工智能捕获世界可能是基于不科学的假设</a></li>
<li><a href="../zh-CN426033/index.html">数学泰坦在abc假设的史诗证明上发生冲突</a></li>
<li><a href="../zh-CN426039/index.html">紧急发射“联盟MS-10”（船员获救，广播结束）</a></li>
<li><a href="../zh-CN426041/index.html">使用SymPy的Laplace变换方法对线性微分方程和系统的符号解</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>