<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌛 👟 🆓 بنية متعددة الوحدات الروبوت. من الألف إلى الياء 🔇 🏴󠁧󠁢󠁥󠁮󠁧󠁿 💕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا بالجميع! 

 منذ وقت ليس ببعيد ، أدركنا أن تطبيق الهاتف المحمول ليس مجرد عميل رقيق ، ولكنه عدد كبير جدًا من المنطق المختلف للغاية الذي يحتاج إلى ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>بنية متعددة الوحدات الروبوت. من الألف إلى الياء</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kaspersky/blog/422555/" style=";text-align:right;direction:rtl"> مرحبا بالجميع! <br><br>  منذ وقت ليس ببعيد ، أدركنا أن تطبيق الهاتف المحمول ليس مجرد عميل رقيق ، ولكنه عدد كبير جدًا من المنطق المختلف للغاية الذي يحتاج إلى التبسيط.  هذا هو السبب في أننا مستوحاة من أفكار الهندسة المعمارية النظيفة ، وشعرنا بما هو DI ، وتعلمنا كيفية استخدام Dagger 2 ، والآن مع إغلاق أعيننا ، أصبحنا قادرين على كسر أي ميزة إلى طبقات. <br><br>  لكن العالم لا يقف ساكناً ، ومع حلول المشاكل القديمة تأتي مشاكل جديدة.  واسم هذه المشكلة الجديدة هو الأحادية.  عادةً ما تكتشف هذه المشكلة عندما ينتقل وقت التجميع إلى الفضاء.  هذا هو بالضبط عدد التقارير التي تبدأ عن الانتقال إلى التعددية ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واحد</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان</a> ). <br>  ولكن لسبب ما ، ينسى الجميع في نفس الوقت بطريقة ما أن الأحادية تؤثر تأثيراً قوياً ليس فقط على وقت التجميع ، ولكن أيضًا على بنيتك.  هنا أجب على الأسئلة.  ما هو حجم AppComponent الخاص بك؟  هل ترى بشكل دوري في الشفرة أن الميزة A لسبب ما تسحب مستودع الميزة B ، على الرغم من أنه لا يجب أن يبدو الأمر كذلك ، حسنًا ، أم يجب أن يكون بطريقة ما أعلى مستوى؟  هل لدى الميزات أي نوع من العقود؟  وكيف تنظم التواصل بين الميزات؟  هل هناك قواعد؟ <br>  هل تشعر أننا حللنا المشكلة مع الطبقات ، أي أن كل شيء يبدو عموديًا على ما يرام ، ولكن أفقًا ما يحدث خطأ ما؟  وفقط كسر الحزم والتحكم في المراجعة لا يحل المشكلة. <br><br>  والسؤال الأمني ​​هو الأكثر خبرة.  عندما انتقلت إلى الوحدات النمطية المتعددة ، ألم تضطر إلى تجريف نصف التطبيق ، واسحب الرمز دائمًا من وحدة إلى أخرى وتعيش فترة مناسبة من الوقت مع مشروع غير مجمع؟ <br><br>  في مقالتي ، أود أن أخبركم كيف جئت إلى التعددية الحديدة من وجهة نظر معمارية على وجه التحديد.  ما هي المشاكل التي أزعجتني وكيف حاولت حلها على مراحل.  وفي النهاية ، ستجد خوارزمية للتحول من الأحادية إلى متعددة الأشكال دون دموع وألم. <br><a name="habracut"></a><br>  بالإجابة على السؤال الأول ، ما هو حجم AppComponent ، يمكنني أن أعترف - كبير ، كبير حقًا.  وعذبتني باستمرار.  كيف حدث ذلك؟  بادئ ذي بدء ، هذا بسبب منظمة DI.  مع DI سنبدأ. <br><br><h2 style=";text-align:right;direction:rtl">  مثلما فعلت DI من قبل </h2><br>  أعتقد أن العديد من الأشخاص قد شكلوا في رؤوسهم شيئًا مثل هذا الرسم التخطيطي لتبعيات المكونات والمجالات المقابلة: <br><img src="https://habrastorage.org/webt/f1/xm/so/f1xmsoakbmgcfys9rjuys_jmnvo.png"><br><br><h4 style=";text-align:right;direction:rtl">  ماذا لدينا هنا </h4><br>  <b>AppComponent</b> ، الذي استوعب جميع التبعيات على الإطلاق مع نطاقات <i>Singleton</i> .  أعتقد أن الجميع تقريبًا لديهم هذا المكون. <br><br>  <b>الميزةالمكونات</b> .  كانت كل ميزة في نطاقها الخاص وكانت <i>مكونًا فرعيًا</i> لـ <i>AppComponent</i> أو ميزة كبيرة. <br>  دعونا نتحدث قليلاً عن الميزات.  بادئ ذي بدء ، ما هي الميزة؟  سأحاول بكلماتي الخاصة.  <b>الميزة</b> هي وحدة برامج مستقلة كاملة تمامًا ومنطقيًا تحل مشكلة مستخدم معينة ، مع تبعيات خارجية محددة بوضوح ، وهي سهلة الاستخدام نسبيًا مرة أخرى في برنامج آخر.  يمكن أن تكون الميزات كبيرة وصغيرة.  قد تحتوي الميزات على ميزات أخرى.  ويمكنهم أيضًا استخدام أو تشغيل ميزات أخرى من خلال تبعيات خارجية محددة بوضوح.  إذا أخذنا تطبيقنا (Kaspersky Internet Security for Android) ، فيمكن اعتبار الميزات مكافحة فيروسات ، ومكافحة السرقة ، وما إلى ذلك. <br><br>  <b>مكونات الشاشة</b> .  مكون لشاشة معينة ، أيضًا مع نطاقه الخاص وأيضًا مكون فرعي لمكون الميزة المقابلة. <br><br><h4 style=";text-align:right;direction:rtl">  الآن قائمة "لماذا" </h4><br>  <b>لماذا المكونات الفرعية؟</b> <br>  في تبعيات المكونات ، لم يعجبني حقيقة أن المكون يمكن أن يعتمد على عدة مكونات في وقت واحد ، والتي ، كما بدا لي ، يمكن أن تؤدي في نهاية المطاف إلى فوضى المكونات وتبعياتها.  عندما يكون لديك علاقة صارمة مع واحد إلى كثير (مكون ومكوناته الفرعية) ، تكون أكثر أمانًا وأكثر وضوحًا.  بالإضافة إلى ذلك ، بشكل افتراضي ، جميع تبعيات الأصل متاحة للمكون الفرعي ، وهو أيضًا أكثر ملاءمة. <br><br>  <b>لماذا يوجد مجال لكل ميزة؟</b> <br>  لأنني عندئذ استمريت في الاعتبارات القائلة بأن كل ميزة هي نوع من دورة حياتها الخاصة ، والتي ليست هي نفسها مثل غيرها ، لذلك فمن المنطقي إنشاء نطاقك الخاص.  هناك نقطة أخرى للعديد من الأشياء الشائكة ، والتي سأذكرها أدناه. <br><br>  نظرًا لأننا نتحدث عن Dagger 2 في سياق Clean ، سأذكر أيضًا اللحظة التي تم بها تسليم التبعيات.  تم تقديم مقدمي العروض ، والمتفاعلون ، والمستودعات ، والفئات الإضافية الأخرى من التبعيات من خلال المنشئ.  في الاختبارات ، نقوم بعد ذلك باستبدال بذرة أو moki من خلال المنشئ واختبار صفنا بهدوء. <br>  غالبًا ما يحدث إغلاق الرسم البياني للتبعية في النشاط ، والشظايا ، وأحيانًا أجهزة الاستقبال والخدمات ، بشكل عام ، إلى الأماكن الجذرية التي يمكن أن يبدأ منها Android شيئًا.  الوضع الكلاسيكي هو عندما يتم إنشاء نشاط لميزة ، يبدأ عنصر الميزة ويعيش في النشاط ، وفي الميزة نفسها هناك ثلاث شاشات يتم تنفيذها في ثلاث أجزاء. <br><br>  لذا ، يبدو أن كل شيء منطقي.  ولكن كما هو الحال دائمًا ، تجري الحياة تعديلاتها الخاصة. <br><br><h2 style=";text-align:right;direction:rtl">  مشاكل الحياة </h2><br><h3 style=";text-align:right;direction:rtl">  مهمة مثال </h3><br>  دعونا نلقي نظرة على مثال بسيط من تطبيقنا.  لدينا ميزة الماسح الضوئي وميزة الحماية ضد السرقة.  كلتا الميزتين لها زر شراء عزيز.  علاوة على ذلك ، فإن "الشراء" ليس مجرد إرسال طلب ، ولكن أيضًا الكثير من المنطق المختلف المتعلق بعملية الشراء.  هذا هو منطق الأعمال البحت مع بعض مربعات الحوار للشراء الفوري.  أي أن هناك ميزة منفصلة عن نفسها - الشراء.  وبالتالي ، في ميزتين نحتاج إلى استخدام الميزة الثالثة. <br>  من وجهة نظر واجهة المستخدم والملاحة ، لدينا الصورة التالية.  تبدأ الشاشة الرئيسية ، حيث يوجد زرين: <br><img src="https://habrastorage.org/webt/ps/1o/qj/ps1oqjtlzdybdcj21pokcadin8u.png"><br><br>  من خلال النقر على هذه الأزرار ، نحصل على ميزة الماسح الضوئي أو مكافحة السرقة. <br>  خذ بعين الاعتبار ميزة الماسح الضوئي: <br><img src="https://habrastorage.org/webt/p5/2g/yw/p52gywypiko82skvl0mn90hd5wq.png"><br><br>  من خلال النقر على "بدء فحص مكافحة الفيروسات" ، يتم إجراء نوع من أعمال المسح ، بالنقر على "اشترني" ، نريد فقط الشراء ، أي أننا نسحب ميزة المشتريات ، ولكن عن طريق "المساعدة" ، نصل إلى شاشة بسيطة بمساعدة. <br>  تبدو ميزة مكافحة السرقة متشابهة تقريبًا. <br><br><h3 style=";text-align:right;direction:rtl">  الحلول المحتملة </h3><br>  كيف نطبق هذا المثال من حيث DI؟  هناك عدة خيارات. <br><br><h4 style=";text-align:right;direction:rtl">  الخيار الأول </h4><br>  حدد ميزة شراء <i><b>كمكون مستقل</b></i> يعتمد فقط على <i>AppComponent</i> . <br><img src="https://habrastorage.org/webt/ia/aq/t2/iaaqt2fi01u1lvjixbn9uspxgyi.png"><br><br>  ولكن بعد ذلك نواجه المشكلة: كيفية حقن التبعيات من رسمين مختلفين (مكونات) في فصل واحد في وقت واحد؟  فقط من خلال العكازات القذرة ، والتي ، بالطبع ، شيء من هذا القبيل. <br><br><h4 style=";text-align:right;direction:rtl">  الخيار الثاني </h4><br>  نختار ميزة الشراء في المكون الفرعي ، والتي تعتمد على AppComponent.  ويمكن جعل مكونات الماسح الضوئي ومكافحة السرقة مكونات فرعية من مكون الشراء. <br><img src="https://habrastorage.org/webt/wh/sh/y3/whshy3v3buimdjy2sfo6w1de3ys.png"><br><br>  ولكن ، كما تفهم ، يمكن أن يكون هناك الكثير من المواقف المماثلة في التطبيقات.  وهذا يعني أن عمق تبعيات المكونات يمكن أن يكون ضخمًا ومعقدًا حقًا.  وسيكون هذا الرسم البياني أكثر إرباكًا من جعل تطبيقك أكثر تماسكًا ومفهومًا. <br><br><h4 style=";text-align:right;direction:rtl">  الخيار الثالث </h4><br>  نختار ميزة الشراء <b>ليس في مكون منفصل ، ولكن في وحدة خنجر منفصلة</b> .  طريقتان ممكنان أبعد من ذلك. <br><br>  <b>الطريقة الأولى</b> <br>  دعونا نضيف ميزات نطاقات <i>Singleton</i> إلى جميع التبعيات والاتصال بـ <i>AppComponent</i> . <br><img src="https://habrastorage.org/webt/gx/wb/3h/gxwb3hokdqdrrcypwykypnym0n8.png"><br><br>  الخيار شائع ، لكنه يؤدي إلى النفخ في <i>AppComponent</i> .  ونتيجة لذلك ، فإنه يتضخم في الحجم ، ويحتوي على جميع فئات التطبيق ، والنقطة الكاملة لاستخدام Dagger تنحصر في تقديم وسائل تبعية أكثر ملاءمة للفصول - من خلال الحقول أو المنشئ ، وليس من خلال الأغاني الفردية.  من حيث المبدأ ، هذا هو DI ، لكننا نفتقد النقاط المعمارية ، وتبين أن الجميع يعرف عن الجميع. <br>  بشكل عام ، في بداية المسار ، إذا كنت لا تعرف مكان إحالة فئة إلى معلم ، فمن الأسهل جعله عالميًا.  هذا أمر شائع جدًا عند العمل مع Legacy ومحاولة إدخال نوع من أنواع الهندسة على الأقل ، بالإضافة إلى أنك لا تعرف جميع الشفرات جيدًا حتى الآن.  وهناك ، في الواقع ، العيون واسعة ، وهذه الإجراءات لها ما يبررها.  الخطأ هو أنه عندما يكون كل شيء يلوح في الأفق بشكل أو بآخر ، فلا أحد يريد <i>معالجة AppComponent</i> . <br><br>  <b>الطريقة الثانية</b> <br>  هذا عبارة عن تقليل لجميع الميزات إلى نطاق واحد ، على سبيل المثال <i>PerFeature</i> . <br><img src="https://habrastorage.org/webt/pm/5u/og/pm5uogvwcybvetc4nrfekteyqy4.png"><br><br>  ثم يمكننا توصيل وحدة Dagger الخاصة بالتسوق بالمكونات الضرورية بسهولة وببساطة. <br>  يبدو مناسبًا.  ولكن اتضح معماريا ليس في عزلة.  تعرف ميزات الماسح الضوئي ومكافحة السرقة تمامًا كل شيء عن ميزة الشراء ، وكل مخزونها.  عن غير قصد ، قد يكون هناك شيء متورط.  أي أن ميزة الشراء لا تحتوي على واجهة برمجة تطبيقات واضحة ، والحدود بين الميزات غير واضحة ، ولا يوجد عقد واضح.  هذا سيء.  حسنًا ، في وحدات متعددة ، سيكون الريدويد صعبًا في وقت لاحق. <br><br><h3 style=";text-align:right;direction:rtl">  ألم معماري </h3><br>  بصراحة ، استخدمت <b>الخيار الثالث</b> لفترة طويلة ، <b>الطريقة الأولى</b> .  كان هذا الإجراء ضروريًا عندما بدأنا في نقل إرثنا تدريجيًا إلى القضبان العادية.  ولكن ، كما ذكرت ، مع هذا النهج ، تبدأ ميزاتك في الاختلاط قليلاً.  يمكن لأي شخص أن يعرف عن كل شيء ، عن تفاصيل التنفيذ وهذا للجميع.  وانتفاخ <i>AppComponent</i> يشير بوضوح إلى أنه يجب القيام بشيء ما. <br>  بالمناسبة ، فإن <b>الخيار الثالث</b> سيساعد في تفريغ <i>AppComponent</i> <b>. الطريقة الثانية</b> .  لكن المعرفة بالتنفيذ وخلط الميزات لن تذهب إلى أي مكان.  حسنًا ، بالطبع ، سيكون من الصعب جدًا إعادة استخدام الميزات بين التطبيقات. <br><br><h3 style=";text-align:right;direction:rtl">  استنتاجات وسيطة </h3><br>  لذا ، ماذا نريد في النهاية؟  ما هي المشاكل التي نريد حلها؟  دعنا نذهب مباشرة إلى النقطة ، بدءًا من DI والانتقال إلى الهندسة المعمارية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  آلية DI مريحة تسمح لك باستخدام الميزات داخل الميزات الأخرى (في مثالنا ، نريد استخدام ميزة Shopping داخل Scanner و Anti-Theft) ، دون عكاز وألم. </li><li style=";text-align:right;direction:rtl">  أنحف AppComponent. </li><li style=";text-align:right;direction:rtl">  لا يجب أن تكون الميزات على دراية بتنفيذ الميزات الأخرى. </li><li style=";text-align:right;direction:rtl">  لا ينبغي الوصول إلى الميزات بشكل افتراضي لأي شخص ، أريد أن يكون لدي نوع من آلية التحكم الصارمة. </li><li style=";text-align:right;direction:rtl">  من الممكن إعطاء الميزة لتطبيق آخر مع الحد الأدنى من الإيماءات. </li><li style=";text-align:right;direction:rtl">  الانتقال المنطقي إلى الوحدات النمطية المتعددة وأفضل الممارسات لهذا التحول. </li></ul><br>  تحدثت على وجه التحديد عن الوحدات النمطية المتعددة فقط في النهاية.  سنصل لها ، لن نتقدم على أنفسنا. <br><br><h2 style=";text-align:right;direction:rtl">  "العيش بطريقة جديدة" </h2><br>  سنحاول الآن تنفيذ قائمة الرغبات المذكورة أعلاه تدريجيًا. <br>  دعنا نذهب! <br><br><h3 style=";text-align:right;direction:rtl">  تحسينات DI </h3><br>  لنبدأ بنفس DI. <br><br><h4 style=";text-align:right;direction:rtl">  رفض عدد كبير من المجالات </h4><br>  كما كتبت أعلاه ، قبل أن يكون نهجي هذا: لكل ميزة نطاقها الخاص.  في الواقع ، لا توجد أرباح خاصة من هذا.  لا تحصل إلا على عدد كبير من النطاقات وكمية معينة من الصداع. <br>  هذه السلسلة كافية تمامًا: <i>Singleton</i> - <i>PerFeature</i> - <i>PerScreen</i> . <br><br><h4 style=";text-align:right;direction:rtl">  التخلي عن المكونات الفرعية لصالح تبعيات المكونات </h4><br>  بالفعل نقطة أكثر إثارة للاهتمام.  مع <i>المكونات الفرعية ،</i> يبدو أن لديك تسلسل هرمي أكثر صرامة ، ولكن في نفس الوقت كنت قد ربطت يديك تمامًا ولا توجد طريقة للمناورة بطريقة أو بأخرى.  بالإضافة إلى ذلك ، يعرف <i>AppComponent</i> جميع الميزات ، ويمكنك أيضًا الحصول على فئة <i>DaggerAppComponent</i> الضخمة المولدة. <br>  مع <i>تبعيات المكونات ،</i> يمكنك الحصول على ميزة رائعة للغاية.  في تبعيات المكونات ، لا يمكنك تحديد <b>المكونات ، ولكن واجهات نظيفة</b> (بفضل Denis و Volodya).  بفضل هذا ، يمكنك استبدال أي تطبيقات واجهة تعجبك ، سيأكل Dagger كل شيء.  حتى لو كان المكون بنفس النطاق هو هذا التطبيق: <br><pre style=";text-align:right;direction:rtl"><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>( dependencies = FeatureDependencies.class, modules = FeatureModule.class ) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } public interface FeatureDependencies { SomeDependency someDependency(); } @Component( modules = AnotherFeatureModule.class ) @PerFeature public abstract class AnotherFeatureComponent implements FeatureDependencies { // ... }</span></span></code> </pre> <br><br><h3 style=";text-align:right;direction:rtl">  من تحسينات DI إلى التحسينات المعمارية </h3><br>  دعنا نكرر تعريف الميزات.  <b>الميزة</b> هي وحدة برامج مستقلة كاملة تمامًا ومنطقيًا تحل مشكلة مستخدم معينة ، مع تبعيات خارجية محددة بوضوح ، والتي يسهل إعادة استخدامها نسبيًا في برنامج آخر.  أحد التعبيرات الرئيسية في تعريف الميزة هو "مع تبعيات خارجية محددة بوضوح".  لذلك ، دعنا نصف كل شيء نريده من العالم الخارجي للميزات ، سنصف في واجهة خاصة. <br>  هنا ، دعنا نقول ، واجهة التبعية الخارجية لميزة التسوق: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  أو واجهة التبعيات الخارجية لميزة الماسح الضوئي: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">DbClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">SomeUtils </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//       PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  كما سبق ذكره في قسم DI ، يمكن لأي شخص تنفيذ التبعيات وكما تريد ، فهذه واجهات خالصة ، ويتم تحرير ميزاتنا من هذه المعرفة الإضافية. <br><br>  هناك مكون مهم آخر لميزة "نقية" وهو وجود واجهة برمجة تطبيقات واضحة ، والتي يمكن للعالم الخارجي من خلالها الوصول إلى الميزة. <br>  فيما يلي ميزات واجهة برمجة التطبيقات للتسوق: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">PurchaseInteractor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseInteractor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  أي أنه يمكن للعالم الخارجي الحصول على <i>PurchaseInteractor</i> ومحاولة إجراء عملية شراء من خلاله.  في الواقع ، رأينا أعلاه أن الماسح الضوئي يحتاج إلى <i>PurchaseInteractor</i> لإكمال عملية الشراء. <br><br>  وإليك ميزات واجهة برمجة التطبيقات للماسح الضوئي: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ScannerStarter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scannerStarter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  وعلى الفور أحضر واجهة وتنفيذ <i>ScannerStarter</i> : <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ Class&lt;?&gt; cls = ScannerActivity.class; Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, cls); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); } }</code> </pre><br>  إنه أكثر إثارة للاهتمام هنا.  والحقيقة هي أن الماسح الضوئي ومكافحة السرقة ميزات مغلقة تمامًا ومعزولة.  في المثال الخاص بي ، يتم تشغيل هذه الميزات في أنشطة منفصلة ، مع التنقل الخاص بهم ، وما إلى ذلك. وهذا يكفي بالنسبة لنا لبدء النشاط ببساطة هنا.  يموت النشاط - تموت الميزة.  يمكنك العمل على مبدأ "نشاط واحد" ، ومن ثم من خلال ميزات واجهة برمجة التطبيقات (API) ، على سبيل المثال ، تمرير FragmentManager وبعض رد الاتصال الذي تُبلغ من خلاله الميزة أنها أكملت.  هناك العديد من الاختلافات. <br>  يمكننا أيضًا أن نقول أن لدينا الحق في اعتبار ميزات مثل Scanner و Anti-Theft كتطبيقات مستقلة.  على عكس ميزة الشراء ، التي تعد إضافة إلى ميزة لشيء ما ، فهي غير موجودة بشكل أو بآخر.  نعم ، إنه مستقل ، ولكنه مكمل منطقي لميزات أخرى. <br><br>  كما يمكنك أن تتخيل ، يجب أن تكون هناك نقطة تربط الميزات وتنفيذها والميزات الضرورية للتبعية.  هذه النقطة هي مكون خنجر. <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال على مكون ميزة الماسح الضوئي:</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = { ScannerFeatureModule.class, ScreenNavigationModule.class <span class="hljs-comment"><span class="hljs-comment">// ScannerFeatureDependencies - api    }, dependencies = ScannerFeatureDependencies.class) @PerFeature // ScannerFeatureApi - api   public abstract class ScannerFeatureComponent implements ScannerFeatureApi { private static volatile ScannerFeatureComponent sScannerFeatureComponent; //   public static ScannerFeatureApi initAndGet( ScannerFeatureDependencies scannerFeatureDependencies) { if (sScannerFeatureComponent == null) { synchronized (ScannerFeatureComponent.class) { if (sScannerFeatureComponent == null) { sScannerFeatureComponent = DaggerScannerFeatureComponent.builder() .scannerFeatureDependencies(scannerFeatureDependencies) .build(); } } } return sScannerFeatureComponent; } //           public static ScannerFeatureComponent get() { if (sScannerFeatureComponent == null) { throw new RuntimeException( "You must call 'initAndGet(ScannerFeatureDependenciesComponent scannerFeatureDependenciesComponent)' method" ); } return sScannerFeatureComponent; } //    (   ) public void resetComponent() { sScannerFeatureComponent = null; } public abstract void inject(ScannerActivity scannerActivity); //         Moxy public abstract ScannerScreenComponent scannerScreenComponent(); }</span></span></code> </pre><br></div></div><br>  أعتقد أن لا شيء جديد بالنسبة لك. <br><br><h3 style=";text-align:right;direction:rtl">  الانتقال إلى الوحدات النمطية المتعددة </h3><br>  لذا ، تمكنت أنت وأنا من تحديد حدود الميزة بوضوح من خلال واجهة برمجة التطبيقات التابعة لها والواجهة الخارجية.  اكتشفنا أيضًا كيفية تحريك كل شيء في Dagger.  والآن نصل إلى الخطوة المنطقية والمثيرة التالية - التقسيم إلى وحدات. <br>  افتح حالة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اختبار على</a> الفور - سيكون الأمر أسهل. <br>  دعونا نلقي نظرة على الصورة بشكل عام: <br><img src="https://habrastorage.org/webt/qq/uw/bg/qquwbgerknuk95cjefxfxqserxi.png"><br>  وانظر إلى بنية الحزمة في المثال: <br><img src="https://habrastorage.org/webt/cs/_a/4a/cs_a4ap7km-ivyxwzk615blftby.png"><br>  الآن لنتحدث بعناية كل عنصر. <br><br>  بادئ ذي بدء ، نرى أربع كتل كبيرة: <b>التطبيق</b> ، <b>API</b> ، <b>Impl</b> و <b>Utils</b> .  في <i>واجهات برمجة التطبيقات</i> و <i>Impl</i> و <i>Utils ،</i> قد تلاحظ أن جميع الوحدات تبدأ <b>إما</b> في <b>النواة</b> أو في <b>الميزة</b> .  فلنتحدث عنها أولاً. <br><br><h4 style=";text-align:right;direction:rtl">  الفصل في الجوهر والميزة </h4><br>  أقسم جميع الوحدات إلى فئتين: <i>الأساسية</i> <i>والميزة</i> . <br>  في <i>الميزة</i> ، كما قد تكون خمنت ، ميزاتنا.  في <b>الأساس - هناك</b> أشياء مثل المرافق ، والعمل مع شبكة ، وقواعد البيانات ، وما إلى ذلك. ولكن لا توجد واجهات ميزات هناك.  <i>والنواة</i> ليست متجانسة.  أنا من أجل كسر <i>الوحدة الأساسية</i> إلى قطع منطقية وضد تحميلها ببعض واجهات الميزات الأخرى. <br>  باسم الوحدة النمطية ، اكتب أولاً <i>النواة</i> أو <i>الميزة</i> .  يوجد في اسم الوحدة أيضًا اسم منطقي ( <i>ماسح ضوئي</i> ، <i>شبكة</i> ، إلخ). <br><br><h4 style=";text-align:right;direction:rtl">  الآن حوالي أربع كتل كبيرة: التطبيق ، API ، Impl و Utils </h4><br>  <b>API</b> <br>  تنقسم كل <i>ميزة</i> أو <i>وحدة أساسية</i> إلى <i>API</i> و <i>Impl</i> .  تحتوي <i>واجهة برمجة التطبيقات</i> على <i>واجهة برمجة تطبيقات</i> خارجية يمكنك من خلالها الوصول إلى ميزة أو مركز.  فقط هذا ، ولا شيء أكثر: <br><img src="https://habrastorage.org/webt/8_/gz/0c/8_gz0ckdfivle1avlexldnj_mdc.png"><br>  بالإضافة إلى ذلك ، لا تعرف <i>وحدة api</i> أي شيء عن أي شخص ، فهي وحدة معزولة تمامًا. <br><br>  <b>يستفيد</b> <br>  يمكن اعتبار الاستثناء الوحيد للقاعدة أعلاه بعض الأشياء النفعية تمامًا ، وهو أمر لا معنى لاقتحام واجهة برمجة التطبيقات وتنفيذها. <br><br>  <b>نفذ</b> <br>  لدينا هنا قسم فرعي إلى <i>اللب الأساسي</i> والخاص <i>بالميزة</i> . <br>  الوحدات في <i>اللب الأساسية</i> مستقلة تمامًا أيضًا.  اعتمادهم الوحيد هو <i>وحدة واجهة برمجة التطبيقات</i> .  على سبيل المثال ، ألق نظرة على <i>build.gradle من</i> <i>Core-db-impl module</i> : <br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  الآن حول <i>ميزة الميزة</i> .  هناك بالفعل حصة الأسد في منطق التطبيق.  يمكن أن تعرف وحدات <i>مجموعة ميزة الميزات</i> عن وحدات <i>واجهة برمجة التطبيقات</i> أو مجموعة <i>Utils</i> ، لكنها بالتأكيد لا تعرف أي شيء عن الوحدات الأخرى في مجموعة <i>Impl</i> . <br>  كما نتذكر ، يتم تجميع جميع التبعيات الخارجية للميزة في التبعيات الخارجية.  على سبيل المثال ، بالنسبة لميزة المسح ، يبدو هذا api كما يلي: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  وبناءً على ذلك ، <i>سيكون build.gradle feature-scanner-impl هكذا</i> : <br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  قد تسأل ، لماذا لا يوجد api التبعيات الخارجية في وحدة api؟  الحقيقة هي أن هذا هو تفاصيل التنفيذ.  أي أنه تنفيذ معين يحتاج إلى بعض التبعيات المحددة.  للماسح التبعي API هنا: <br><img src="https://habrastorage.org/webt/8y/7o/fj/8y7ofjd9oxd344hzqua8xcqtdci.png"><br><br>  <b>ملاذ معماري صغير</b> <br>  دعونا هضم كل ما سبق ونفهم لأنفسنا بعض النقاط المعمارية فيما يتعلق <i>بالميزات -...- الوحدات النمطية</i> واعتمادها على الوحدات الأخرى. <br>  قابلت اثنين من أكثر أنماط رسم خرائط التبعية شيوعًا لوحدة نمطية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يمكن للوحدة النمطية معرفة أي شخص.  لا توجد قواعد.  لا يوجد شيء للتعليق عليه. </li><li style=";text-align:right;direction:rtl">  الوحدات تعرف فقط عن <i>الوحدة الأساسية</i> .  وفي <i>الوحدة الأساسية</i> تتركز جميع الواجهات من جميع الميزات.  هذا النهج لا يجذبني كثيرًا ، حيث أن هناك خطرًا من تحويل <i>القلب</i> إلى مكب قمامة آخر.  بالإضافة إلى ذلك ، إذا أردنا نقل الوحدة الخاصة بنا إلى تطبيق آخر ، فسنحتاج إلى نسخ هذه الواجهات إلى تطبيق آخر ، ووضعها أيضًا في المركز.  إن النسخ واللصق الغبي للواجهات في حد ذاته ليس جذابًا جدًا ويمكن إعادة استخدامه في المستقبل ، عندما يمكن تحديث الواجهات. </li></ul><br>  في مثالنا ، أدعو إلى معرفة وحدات واجهة برمجة التطبيقات ووحدات واجهة برمجة التطبيقات (مجموعات الأدوات) فقط.  الميزات لا تعرف أي شيء عن عمليات التنفيذ. <br><br>  ولكن اتضح أن الميزات يمكن أن تعرف ميزات أخرى (عبر واجهة برمجة التطبيقات ، بالطبع) وتشغيلها.  هل يمكن أن تكون فوضى؟ <br>  ملاحظة عادلة.  من الصعب وضع بعض القواعد فائقة الوضوح.  يجب أن يكون هناك مقياس في كل شيء.  لقد تطرقنا بالفعل إلى هذه المشكلة أعلاه قليلاً ، وتقسيم الميزات إلى ميزات مستقلة (الماسح الضوئي ومكافحة السرقة) - مستقلة تمامًا ومنفصلة ، وميزات "في السياق" ، أي أنها يتم إطلاقها دائمًا كجزء من شيء (شراء) وعادة ما تتضمن منطقًا تجاريًا بدون واجهة مستخدم.  هذا هو السبب في أن الماسح الضوئي ومكافحة السرقة على علم بالمشتريات. <br>  مثال آخر.  تخيل أنه في Anti-Theft هناك شيء مثل مسح البيانات ، أي مسح جميع البيانات من الهاتف تمامًا.  هناك الكثير من منطق الأعمال ، واجهة المستخدم ، وهي معزولة تمامًا.  لذلك ، من المنطقي تخصيص بيانات المسح كميزة منفصلة.  ثم الشوكة.  إذا تم إطلاق بيانات المسح دائمًا فقط من Anti-Theft وكانت موجودة دائمًا في Anti-Theft ، فمن المنطقي أن تعرف Anti-Theft عن مسح البيانات وتشغيلها من تلقاء نفسها.  وستعرف الوحدة المتراكمة ، التطبيق ، بعد ذلك فقط عن مكافحة السرقة.  ولكن إذا كان مسح البيانات يمكن أن يبدأ في مكان آخر أو لا يكون موجودًا دائمًا في Anti-Theft (أي أنه يمكن أن يكون مختلفًا في تطبيقات مختلفة) ، فمن المنطقي أن Anti-theftft لا يعرف عن هذه الميزة ويقول فقط شيء خارجي (عبر جهاز التوجيه ، من خلال بعض الاستدعاء ، لا يهم) أن المستخدم قد ضغط على هذا الزر ومثل هذا ، وما يتم إطلاقه تحته هو بالفعل عمل مستهلك ميزة مكافحة السرقة (تطبيق معين ، تطبيق معين). <br><br>  هناك أيضًا سؤال مثير للاهتمام حول نقل الميزات إلى تطبيق آخر.  على سبيل المثال ، إذا أردنا نقل الماسحة الضوئية إلى تطبيق آخر ، فيجب علينا أيضًا أن ننقل بالإضافة إلى الوحدات النمطية <i>: feature-scanner-api</i> و <i>: feature-scanner-impl</i> والوحدات التي يعتمد عليها الماسح الضوئي ( <i>: core-utils،: core-network- api،: core-db-api،: feature-buy-api</i> ). <br>  نعم لكن!  أولاً ، جميع وحدات واجهة برمجة التطبيقات الخاصة بك مستقلة تمامًا ، ولا توجد سوى واجهات ونماذج بيانات.  لا منطق.  وهذه الوحدات منفصلة بشكل منطقي بوضوح ، و <i>: الأدوات الأساسية</i> عادة ما تكون وحدة مشتركة لجميع التطبيقات. <br>  ثانيًا ، يمكنك جمع وحدات api في شكل aar وتسليمها من خلال المخضر إلى تطبيق آخر ، أو يمكنك توصيلها في شكل وحدة فرعية gig.  ولكن سيكون لديك إصدار ، سيكون هناك تحكم ، سيكون هناك نزاهة. <br>  وبالتالي ، فإن إعادة استخدام الوحدة (بتعبير أدق ، وحدة التنفيذ) في تطبيق آخر تبدو أبسط وأكثر وضوحًا وأمانًا. <br><br><h4 style=";text-align:right;direction:rtl">  التطبيق </h4><br>  يبدو أن لدينا صورة رفيعة ومفهومة مع الميزات والوحدات وتبعياتها وهذا كل شيء.  الآن نصل إلى ذروة - هذا هو مزيج من api وتنفيذها ، واستبدال جميع التبعيات اللازمة ، وما إلى ذلك ، ولكن من وجهة نظر وحدات Gredloi.  عادةً ما تكون نقطة الاتصال هي <i>التطبيق</i> نفسه. <br>  بالمناسبة ، في مثالنا ، لا تزال هذه النقطة <i>مثالًا للماسح الضوئي</i> .  يتيح لك النهج أعلاه تشغيل كل من الميزات الخاصة بك كتطبيق منفصل ، مما يوفر وقت البناء بشكل كبير أثناء التطوير النشط.  جمال! <br><br>  بادئ ذي بدء ، دعنا نفكر في كيفية حدوث كل شيء من خلال <i>التطبيق</i> مع مثال الماسح الضوئي المحبوب بالفعل. <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تذكر الميزة بسرعة:</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  الخيال العلمي للاعتمادات الخارجية هو: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  لذلك <i>: تعتمد ميزة فحص الماسح الضوئي</i> على الوحدات التالية: <br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br></div></div><br>  بناءً على ذلك ، يمكننا إنشاء مكون Dagger يقوم بتنفيذ api من التبعيات الخارجية: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(dependencies = { CoreUtilsApi.class, CoreNetworkApi.class, CoreDbApi.class, PurchaseFeatureApi.class }) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependenciesComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  لقد وضعت هذه الواجهة في <i>ScannerFeatureComponent من</i> أجل الراحة: <br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">@Component(modules = { ScannerFeatureModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, ScreenNavigationModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }, dependencies = ScannerFeatureDependencies.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) @PerFeature <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ScannerFeatureComponent implements ScannerFeatureApi { // bla-bla-bla @Component(dependencies = { CoreUtilsApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreNetworkApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreDbApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, PurchaseFeatureApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }) @PerFeature interface ScannerFeatureDependenciesComponent extends ScannerFeatureDependencies { } }</code> </pre><br><br>  الآن التطبيق.  التطبيق يعرف عن جميع الوحدات التي يحتاجها ( <i>الأساسية- ، الميزة- ، api ، impl</i> ): <br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-impl'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  بعد ذلك ، قم بإنشاء فصل مساعد.  على سبيل المثال ، <i>FeatureProxyInjector</i> .  سيساعد على تهيئة جميع المكونات بشكل صحيح ، ومن خلال هذه الفئة سننتقل إلى الميزات.  دعنا نرى كيف تتم تهيئة مكون ميزة الماسح الضوئي: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureProxyInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// another... public static ScannerFeatureApi getFeatureScanner() { return ScannerFeatureComponent.initAndGet( DaggerScannerFeatureComponent_ScannerFeatureDependenciesComponent.builder() .coreDbApi(CoreDbComponent.get()) .coreNetworkApi(CoreNetworkComponent.get()) .coreUtilsApi(CoreUtilsComponent.get()) .purchaseFeatureApi(featurePurchaseGet()) .build() ); } }</span></span></code> </pre><br>  ظاهريًا ، نقدم واجهة الميزة ( <i>ScannerFeatureApi</i> ) ، <i>وداخلنا</i> فقط نقوم بتهيئة الرسم البياني لاعتماد التنفيذ بالكامل (عبر طريقة <i>ScannerFeatureComponent.initAndGet (...)</i> ). <br>  <i>DaggerPurchaseComponent_PurchaseFeatureDependenciesComponent</i> هو تنفيذ <i>PurchaseFeatureDependenciesComponent الذي تم</i> إنشاؤه بواسطة Dagger ، والذي تحدثنا عنه أعلاه ، حيث <i>نستبدل</i> تنفيذ وحدات واجهة برمجة التطبيقات في المنشئ. <br>  هذا كل شيء سحري.  انظر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المثال</a> مرة أخرى. <br><br>  بالحديث عن <i>المثال</i> .  على <i>سبيل المثال ،</i> يجب أن نرضي أيضًا كل التبعيات الخارجية <i>: ميزة الماسح الضوئي</i> .  ولكن بما أن هذا مثال ، يمكننا استبدال فئات وهمية. <br>  كيف ستبدو: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies public class ScannerFeatureDependenciesFake implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientFake(); } @Override public HttpClientApi httpClient() { return new HttpClientFake(); } @Override public SomeUtils someUtils() { return CoreUtilsComponent.get().someUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorFake(); } } //  -  Application-   public class ScannerExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); ScannerFeatureComponent.initAndGet( // ,     =) new ScannerFeatureDependenciesFake() ); } }</span></span></code> </pre><br>  <i>ويتم تشغيل</i> ميزة Scanner نفسها في <i>المثال من</i> خلال البيان ، حتى لا يتم حظر نشاط فارغ إضافي: <br><pre style=";text-align:right;direction:rtl"> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner_example"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".ScannerExampleApplication"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:roundIcon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher_round"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:supportsRtl</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner.presentation.view.ScannerActivity"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.MAIN"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.LAUNCHER"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><h2 style=";text-align:right;direction:rtl">  خوارزمية الانتقال من أحادية إلى متعددة </h2><br>  الحياة شيء قاس.  والحقيقة هي أننا جميعًا نعمل مع Legacy.  إذا كان شخص ما يشهد الآن مشروعًا جديدًا تمامًا ، حيث يمكنك أن تبارك كل شيء على الفور ، فإنني أحسدك يا ​​أخي.  ولكن هذا ليس هو الحال معي ، وهذا الرجل أيضا مخطئ =). <br><br>  كيف تترجم تطبيقك إلى وحدات متعددة؟  سمعت في الغالب عن خيارين. <br>  الأول.  تقسيم التطبيق هنا والآن.  صحيح ، قد لا يتم تجميع مشروعك لمدة شهر أو شهرين =). <br>  الثاني.  حاول سحب الميزات تدريجيًا.  ولكن في نفس الوقت ، تمتد جميع أنواع التبعيات لهذه الميزات.  وهنا يبدأ المرح.  يمكن لكود التبعية أن يسحب رمزًا آخر ، كل شيء ينتقل إلى <i>الوحدة المشتركة</i> ، إلى <i>الوحدة الأساسية</i> والعكس صحيح ، وهكذا.  ونتيجة لذلك ، يمكن أن يستدعي سحب ميزة واحدة العمل مع النصف الآخر الجيد من التطبيق.  ومرة أخرى ، في البداية ، لن يجمع مشروعك فترة زمنية مناسبة. <br><br>  أنا أدعو إلى النقل التدريجي للتطبيق إلى الوحدات النمطية المتعددة ، لأنه في موازاة ذلك ما زلنا بحاجة إلى رؤية ميزات جديدة.  الفكرة الرئيسية هي أنه <b>إذا كانت الوحدة الخاصة بك بحاجة إلى بعض التبعيات ، فلا يجب عليك سحب هذا الرمز على الفور إلى الوحدات المادية أيضًا</b> .  دعونا نلقي نظرة على خوارزمية إزالة الوحدة باستخدام الماسح كمثال: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إنشاء ميزات واجهة برمجة التطبيقات ، ووضعها في وحدة واجهة برمجة تطبيقات جديدة.  أي ، لإنشاء وحدة نمطية بالكامل <i>: ميزة الماسح الضوئي-</i> واجهة <i>برمجة التطبيقات</i> مع جميع الواجهات. </li><li style=";text-align:right;direction:rtl">  إنشاء <i>: ميزة الماسح الضوئي</i> .  نقل جميع الرموز المتعلقة بالميزة إلى هذه الوحدة.  كل شيء تعتمد عليه ميزتك ، سوف يسلط الاستوديو الضوء على الفور. </li><li style=";text-align:right;direction:rtl">  تحديد تبعيات الميزات الخارجية.  إنشاء واجهات مناسبة.  تنقسم هذه الواجهات إلى وحدات api-modules منطقية.  هذا هو ، في مثالنا ، إنشاء الوحدات النمطية <i>: core-utils ،: core-network-api ،: core-db-api ،: feature-buy-api</i> مع الواجهات المقابلة. <br>  أنصحك بالاستثمار الفوري في اسم الوحدات ومعناها.  من الواضح أنه بمرور الوقت ، يمكن أن يتم تبديل الواجهات والوحدات قليلاً ، أو انهيارها ، وما إلى ذلك ، وهذا أمر طبيعي. </li><li style=";text-align:right;direction:rtl">  إنشاء واجهة <i>برمجة تطبيقات للتبعيات</i> الخارجية ( <i>ScannerFeatureDependencies</i> ).  اعتمادًا على <i>: ميزة الماسح الضوئي ، قم</i> بتسجيل وحدات واجهة برمجة التطبيقات التي تم إنشاؤها حديثًا. </li><li style=";text-align:right;direction:rtl">  نظرًا لأن لدينا كل الإرث في <i>التطبيق</i> ، فإليك ما نقوم به.  في <i>التطبيق ،</i> نقوم بتوصيل جميع الوحدات التي تم إنشاؤها للميزة (وحدة واجهة برمجة التطبيقات المميزة ، وحدة تطبيق الميزة ، وحدات واجهة برمجة تطبيقات التبعية الخارجية). <br>  <b>نقطة فائقة الأهمية</b> .  بعد ذلك ، في <i>التطبيق ،</i> نقوم بإنشاء تطبيقات لجميع واجهات تبعية الميزات الضرورية (الماسح الضوئي في مثالنا).  من المحتمل أن تكون عمليات التنفيذ هذه مجرد وكلاء من تبعيات api الخاصة بك إلى التنفيذ الحالي لهذه التبعيات في المشروع.  عند تهيئة مكون الميزة ، استبدل بيانات التنفيذ. <br>  صعب في الكلمات ، هل تريد مثالاً؟  لذلك هو بالفعل!  في الواقع ، يوجد شيء مشابه بالفعل في مثال الماسح الضوئي للميزات.  مرة أخرى ، سأعطيها كودًا معدلاً قليلاً: <br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies  app- public class ScannerFeatureDependenciesLegacy implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientLegacy(); } @Override public HttpClientApi httpClient() { // -  // ,      return NetworkFabric.createHttpClientLegacy(); } @Override public SomeUtils someUtils() { return new SomeUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorLegacy(); } } //  -   ScannerFeatureComponent.initAndGet( new ScannerFeatureDependenciesLegacy() );</span></span></code> </pre><br>  أي أن الرسالة الرئيسية هنا هي هذه.  دع جميع الشفرات الخارجية اللازمة للميزة موجودة في <i>التطبيق</i> ، كما فعلت.  وستعمل الميزة نفسها بالفعل معها بالطريقة العادية ، من خلال api (بمعنى تبعيات api ووحدات api).  في المستقبل ، سينتقل التنفيذ تدريجيًا إلى الوحدات النمطية.  ولكن بعد ذلك سوف نتجنب لعبة لا نهاية لها بسحب من الوحدة إلى الوحدة البرمجية الشفرة الخارجية اللازمة للميزة.  يمكننا التحرك في تكرارات واضحة! </li><li style=";text-align:right;direction:rtl">  الربح </li></ul><br>  إليك خوارزمية بسيطة ولكنها فعالة تسمح لك بالتحرك نحو هدفك خطوة بخطوة. <br><br><h3 style=";text-align:right;direction:rtl">  نصائح إضافية </h3><br>  <b>إلى أي مدى يجب أن تكون الميزات كبيرة / صغيرة؟</b> <br>  كل هذا يتوقف على المشروع ، إلخ.  ولكن في بداية الانتقال إلى الوحدات النمطية المتعددة ، أنصحك بأن تنقسم إلى قطع كبيرة.  علاوة على ذلك ، إذا لزم الأمر ، ستختار المزيد من الوحدات النمطية من هذه الوحدات.  ولكن لا تطحن.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا تفعل هذا: فصل واحد / عدة صفوف = وحدة واحدة. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نقاء وحدة التطبيق</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عند التبديل إلى </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التطبيق</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> متعدد الوحدات </font><font style="vertical-align: inherit;">، سيكون لدينا الكثير جدًا ، ومن هناك ، سترتعد الميزات المميزة. من الممكن أنه في أثناء العمل ، سيكون عليك إجراء تغييرات على هذا الإرث ، لإنهاء شيء هناك ، حسنًا ، أو لديك إصدار فقط ، وأنك لا تصل إلى التخفيضات في الوحدات. في هذه الحالة ، تريد </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التطبيق</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، ومعه كل التراث ، أن يعرف عن الميزات المميزة فقط من خلال واجهة برمجة التطبيقات ، لا توجد معرفة حول عمليات التنفيذ. ولكن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التطبيق</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، في الواقع، يجمع </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">api-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> و </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl الإضافية</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، ولكن لأن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التطبيق</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يعرف كل شيء. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذه الحالة ، يمكنك إنشاء وحدة خاصة</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: محول</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، والذي سيكون مجرد نقطة اتصال لـ api و impl ، ومن ثم </font><font style="vertical-align: inherit;">سيعرف </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التطبيق</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> فقط عن api. </font><font style="vertical-align: inherit;">أعتقد أن الفكرة واضحة. </font><font style="vertical-align: inherit;">يمكنك مشاهدة مثال في فرع </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clean_app</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">سأضيف ذلك مع Moxy ، أو بالأحرى MoxyReflector ، هناك بعض المشاكل عند التقسيم إلى وحدات ، والتي اضطررت إلى إنشاء وحدة إضافية أخرى </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: stub-moxy-java</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">قليل من السحر حيث بدونه. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التعديل الوحيد. </font><font style="vertical-align: inherit;">لن يعمل هذا إلا عندما يتم بالفعل نقل الميزة والاعتمادات ذات الصلة فعليًا إلى وحدات أخرى. </font><font style="vertical-align: inherit;">إذا قمت بعمل ميزة ، ولكن التبعيات لا تزال موجودة في </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التطبيق</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، كما هو الحال في الخوارزمية أعلاه ، فلن يعمل هذا.</font></font><br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> خاتمة </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحولت المقالة إلى حد كبير. </font><font style="vertical-align: inherit;">لكني آمل أن يساعدك ذلك حقًا في محاربة الأحادية الأحادية ، وفهم كيف يجب أن يكون ، وكيفية تكوين صداقات مع DI. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا كنت مهتمًا بالوقوع في مشكلة سرعة البناء ، وكيفية قياس كل شيء ، فأنا أوصي بتقارير دينيس نيكليودوف وزينيا سوفوروف (Mobius 2018 Piter ، مقاطع الفيديو ليست متاحة للجمهور بعد). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حول جراد. </font><font style="vertical-align: inherit;">تم عرض الفرق بين واجهة برمجة التطبيقات والتنفيذ في الصف بشكل مثالي من قبل </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فوفا تاجاكوف</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">إذا كنت ترغب في تقليل الصفيحة متعددة الوحدات ، يمكنك البدء هنا </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بهذه المقالة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سأكون سعيدًا بالتعليقات والتصحيحات وكذلك الإعجابات! </font><font style="vertical-align: inherit;">كل كود نظيف!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar422555/">https://habr.com/ru/post/ar422555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar422545/index.html">طرق مزامنة علامات تبويب المتصفح</a></li>
<li><a href="../ar422547/index.html">للقضاء على Spectre و Meltdown ، قد تضطر إلى إنشاء نوع جديد تمامًا من المعالج</a></li>
<li><a href="../ar422549/index.html">كوردا: كوتلن</a></li>
<li><a href="../ar422551/index.html">كيفية سرقة الأموال من بطاقة تماس وأبل باي</a></li>
<li><a href="../ar422553/index.html">يسحب ملحق المتصفح الرسمي الضخم بيانات مشاركة الملفات والعملات المشفرة</a></li>
<li><a href="../ar422561/index.html">كيف طبقت ياندكس رؤية الكمبيوتر لتحسين جودة بث الفيديو. تقنية DeepHD</a></li>
<li><a href="../ar422565/index.html">Skillbox Friday Webinars: كل شيء للمبرمجين والمصممين</a></li>
<li><a href="../ar422569/index.html">كل ساعة ، تطبيق تتبع الوقت</a></li>
<li><a href="../ar422571/index.html">المهام الموازية مع التبعيات - مثال .NET</a></li>
<li><a href="../ar422573/index.html">الهندسة العكسية لتقديم The Witcher 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>