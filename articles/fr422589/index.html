<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏾 🤸🏽 🦎 Gérer les effets secondaires sales dans du code JavaScript pur et fonctionnel 👩‍🎓 ✌🏽 👩🏿‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous vous essayez à la programmation fonctionnelle, cela signifie que vous rencontrerez bientôt le concept de fonctions pures. Au fur et à mesure q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gérer les effets secondaires sales dans du code JavaScript pur et fonctionnel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422589/">  Si vous vous essayez à la programmation fonctionnelle, cela signifie que vous rencontrerez bientôt le concept de fonctions pures.  Au fur et à mesure que vous continuez, vous constaterez que les programmeurs qui préfèrent un style fonctionnel semblent être obsédés par ces fonctionnalités.  Ils disent que les fonctions pures vous permettent de parler de code.  Ils disent que les fonctions pures sont des entités qui ne fonctionneront probablement pas si imprévisiblement qu'elles mèneront à une guerre thermonucléaire.  Vous pouvez également apprendre de ces programmeurs que les fonctions pures offrent une transparence référentielle.  Et ainsi - à l'infini. <br><br>  Soit dit en passant, les programmeurs fonctionnels ont raison.  Les fonctions pures sont bonnes.  Mais il y a un problème ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q_/uc/lc/q_uclcvzexyauvwqhrp4c84pwpi.jpeg"></div><br>  L'auteur du document, dont nous vous présentons la traduction, souhaite parler de la manière de gérer les effets secondaires dans les fonctions pures. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Le problème des fonctions pures</font> </h2><br>  Une fonction pure est une fonction qui n'a pas d'effets secondaires (en fait, ce n'est pas une définition complète d'une fonction pure, mais nous reviendrons sur cette définition).  Cependant, si vous comprenez au moins quelque chose en programmation, alors vous savez que la chose la plus importante ici est précisément les effets secondaires.  Pourquoi calculer le nombre Pi jusqu'à la centième décimale si personne ne peut lire ce nombre?  Afin d'afficher quelque chose à l'écran ou d'imprimer sur une imprimante, ou de le présenter sous une autre forme, accessible à la perception, nous devons appeler la commande appropriée à partir du programme.  Et à quoi servent les bases de données si rien ne peut y être écrit?  Pour garantir le fonctionnement des applications, vous devez lire les données des périphériques d'entrée et demander des informations aux ressources réseau.  Tout cela ne peut se faire sans effets secondaires.  Mais malgré cet état de fait, la programmation fonctionnelle est construite autour de fonctions pures.  Alors, comment les programmeurs qui écrivent des programmes dans un style fonctionnel parviennent-ils à résoudre ce paradoxe? <br><br>  Si vous répondez à cette question en un mot, les programmeurs fonctionnels font la même chose que les mathématiciens: ils trichent.  Bien que, malgré cette accusation, il faut dire qu'ils, d'un point de vue technique, suivent simplement certaines règles.  Mais ils trouvent des failles dans ces règles et les étendent à des tailles incroyables.  Ils le font de deux manières principales: <br><br><ol><li>  Ils profitent de l'injection de dépendance.  J'appelle cela jeter un problème par-dessus une clôture. </li><li> Ils utilisent des foncteurs, ce qui me semble une forme extrême de procrastination.  Il convient de noter ici que dans Haskell, il est appelé «IO functor» ou «IO <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">monad</a> », dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PureScript, le</a> terme «Effect» est utilisé, ce qui, à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon avis</a> , est un peu mieux pour décrire l'essence des foncteurs. </li></ol><br><h2>  <font color="#3AC1EF">Injection de dépendance</font> </h2><br>  L'injection de dépendance est la première façon de gérer les effets secondaires.  En utilisant cette approche, nous prenons tout ce qui pollue le code et le mettons dans les paramètres de la fonction.  Ensuite, nous pouvons considérer tout cela comme faisant partie de la responsabilité d'une autre fonction.  Je vais l'expliquer avec l'exemple suivant: <br><br><pre><code class="hljs powershell">// logSomething :: String -&gt; String <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(something)</span></span></span></span> {    const dt = (new Date())toISOString();    console.log(`${dt}: <span class="hljs-variable"><span class="hljs-variable">$</span></span>{something}`);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something; }</code> </pre> <br>  Ici, je voudrais faire une note pour ceux qui connaissent les signatures de type.  Si nous respections strictement les règles, nous devions alors prendre en compte les effets secondaires.  Mais nous y reviendrons plus tard. <br><br>  La fonction <code>logSomething()</code> a deux problèmes qui l'empêchent d'être déclarée propre: elle crée un objet <code>Date</code> et affiche quelque chose dans la console.  Autrement dit, notre fonction effectue non seulement des opérations d'entrée-sortie, mais elle produit également, lorsqu'elle est appelée à des moments différents, des résultats différents. <br><br>  Comment rendre cette fonction propre?  En utilisant la technique d'injection de dépendances, nous pouvons prendre tout ce qui pollue la fonction et en faire des paramètres de fonction.  Par conséquent, au lieu d'accepter un paramètre, notre fonction acceptera trois paramètres: <br><br><pre> <code class="hljs powershell">// logSomething: Date -&gt; Console -&gt; String -&gt; * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d, cnsl, something)</span></span></span></span> {   const dt = d.toIsoString();   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cnsl.log(`${dt}: <span class="hljs-variable"><span class="hljs-variable">$</span></span>{something}`); }</code> </pre> <br>  Maintenant, pour appeler la fonction, nous devons lui transférer tout ce qui l'a polluée auparavant: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">"Curiouser and curiouser!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); logSomething(d, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>, something); <span class="hljs-comment"><span class="hljs-comment">//  "Curiouser and curiouser!"</span></span></code> </pre> <br>  Ici, vous pouvez penser que tout cela est absurde, que nous n'avons déplacé le problème que d'un niveau vers le haut, et cela n'a pas ajouté de la pureté à notre code.  Et vous savez, ce sont les bonnes pensées.  Il s'agit d'une faille dans sa forme la plus pure. <br><br>  Cela ressemble à un analphabétisme factice: «Je ne savais pas que l'appel de la méthode <code>log</code> de l'objet <code>cnsl</code> conduirait à l'exécution de l'instruction d'E / S.  Quelqu'un vient de me le remettre, mais je ne sais pas d'où tout cela vient. "  Cette attitude est fausse. <br><br>  Et, en fait, ce qui se passe n'est pas aussi stupide que cela puisse paraître à première vue.  <code>logSomething()</code> œil aux fonctionnalités de la fonction <code>logSomething()</code> .  Si vous voulez faire quelque chose d'impur, vous devez le faire vous-même.  Disons que vous pouvez passer différents paramètres à cette fonction: <br><br><pre> <code class="hljs coffeescript">const d = {toISOString: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'1865-11-26T16:00:00.000Z'</span></span>}; const cnsl = {   log: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      }, }; logSomething(d, cnsl, <span class="hljs-string"><span class="hljs-string">"Off with their heads!"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">"Off with their heads!"</span></span></code> </pre> <br>  Maintenant, notre fonction ne fait rien (elle ne renvoie que le paramètre <code>something</code> ).  Mais elle est complètement pure.  Si vous l'appelez plusieurs fois avec les mêmes paramètres, il retournera la même chose à chaque fois.  Et c'est tout.  Afin de rendre cette fonction impure, nous devons effectuer intentionnellement certaines actions.  Ou, pour le dire autrement, tout ce dont dépend une fonction est dans sa signature.  Il n'accède à aucun objet global comme la <code>console</code> ou la <code>Date</code> .  Cela formalise tout. <br><br>  De plus, il est important de noter que nous pouvons transférer d'autres fonctions à notre fonction, qui n'était pas auparavant propre.  Jetez un oeil à un autre exemple.  Imaginez que dans une certaine forme il y ait un nom d'utilisateur et nous devons obtenir la valeur du champ correspondant de cette forme: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> getUserNameFromDOM :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> String function getUserNameFromDOM() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#username'</span></span>).value; } const username = getUserNameFromDOM(); username; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">"mhatter"</span></span></code> </pre> <br>  Dans ce cas, nous essayons de charger certaines informations à partir du DOM.  Les fonctions pures ne le font pas, car le <code>document</code> est un objet global qui peut changer à tout moment.  Une façon de rendre une telle fonction propre est de lui passer l'objet <code>document</code> global en tant que paramètre.  Cependant, vous pouvez toujours lui passer la fonction <code>querySelector()</code> .  Cela ressemble à ceci: <br><br><pre> <code class="hljs powershell">// getUserNameFromDOM :: (String -&gt; Element) -&gt; String <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserNameFromDOM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-variable"><span class="hljs-function"><span class="hljs-params"><span class="hljs-variable">$</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>(<span class="hljs-string"><span class="hljs-string">'#username'</span></span>).value; } // qs :: String -&gt; Element const qs = document.querySelector.bind(document); const username = getUserNameFromDOM(qs); username; //   <span class="hljs-string"><span class="hljs-string">"mhatter"</span></span></code> </pre> <br>  Ici, encore une fois, vous pouvez penser que c'est stupide.  Après tout, ici, nous avons simplement supprimé de la fonction <code>getUsernameFromDOM()</code> ce qui ne nous permet pas de l'appeler propre.  Cependant, nous ne nous en sommes pas débarrassés, transférant simplement l'appel au DOM vers une autre fonction, <code>qs()</code> .  Il pourrait sembler que le seul résultat notable de cette étape était que le nouveau code était plus long que l'ancien.  Au lieu d'une fonction impure, nous avons maintenant deux fonctions, dont l'une est toujours impure. <br><br>  Attends un peu.  Imaginez que nous devons écrire un test pour la fonction <code>getUserNameFromDOM()</code> .  Maintenant, en comparant les deux options pour cette fonction, pensez à laquelle sera la plus facile à utiliser?  Pour que la version sale de la fonction fonctionne, nous avons besoin d'un objet document global.  De plus, ce document devrait avoir un élément avec l' <code>username</code> du <code>username</code> .  Si vous devez tester une fonction similaire en dehors du navigateur, vous devrez utiliser quelque chose comme JSDOM ou un navigateur sans interface utilisateur.  Veuillez noter que tout cela n'est nécessaire que pour tester une petite fonction avec une longueur de plusieurs lignes.  Et pour tester la deuxième version propre de cette fonction, il suffit de faire ce qui suit: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> qsStub = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'mhatter'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = getUserNameFromDOM(qsStub); assert.strictEqual(<span class="hljs-string"><span class="hljs-string">'mhatter'</span></span>, username, <span class="hljs-string"><span class="hljs-string">`Expected username to be </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${username}</span></span></span><span class="hljs-string">`</span></span>);</code> </pre> <br>  Bien sûr, cela ne signifie pas que pour tester de telles fonctions, des tests d'intégration effectués dans un navigateur réel (ou, du moins, en utilisant quelque chose comme JSDOM) ne sont pas nécessaires.  Mais cet exemple montre une chose très importante, c'est que maintenant la fonction <code>getUserNameFromDOM()</code> devenue complètement prévisible.  Si nous lui passons <code>qsStub()</code> , il retournera toujours <code>mhatter</code> .  L '"imprévisibilité" nous sommes passés à la petite fonction <code>qs()</code> . <br><br>  Si nécessaire, nous pouvons amener des mécanismes imprévisibles à des niveaux encore plus éloignés de la fonction principale.  Par conséquent, nous pouvons les déplacer, relativement parlant, dans les «zones frontalières» du code.  Cela nous amènera à avoir une mince couche de code impur qui entoure un noyau bien testé et prévisible.  La prévisibilité du code s'avère extrêmement précieuse lorsque la taille des projets créés par les programmeurs augmente. <br><br><h3>  <font color="#3AC1EF">▍ Inconvénients du mécanisme d'injection de dépendance</font> </h3><br>  En utilisant l'injection de dépendances, vous pouvez écrire une application volumineuse et complexe.  Je le sais, puisque j'ai moi-même écrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une telle application</a> .  Avec cette approche, les tests sont simplifiés et les dépendances de fonction deviennent clairement visibles.  Mais l'injection de dépendance n'est pas sans défauts.  Le principal est que lorsqu'il est utilisé, des signatures de fonction très longues peuvent être obtenues: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(doc, con, ftch, store, config, ga, d, random)</span></span></span></span> {   //     } app(document, console, fetch, store, <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>, ga, (new Date()), Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>);</code> </pre> <br>  En fait, ce n'est pas si mal.  Les inconvénients de telles constructions se manifestent si certains paramètres doivent être passés à certaines fonctions qui sont très profondément intégrées dans d'autres fonctions.  Cela ressemble à la nécessité de passer des paramètres à travers de nombreux niveaux d'appels de fonction.  Lorsque le nombre de ces niveaux augmente, cela commence à ennuyer.  Par exemple, il peut être nécessaire de transférer l'objet représentant la date via 5 fonctions intermédiaires, alors qu'aucune des fonctions intermédiaires n'utilise cet objet.  Bien sûr, on ne peut pas dire qu'une telle situation ressemble à une catastrophe universelle.  De plus, cela permet de voir clairement les dépendances des fonctions.  Quoi qu'il en soit, ce n'est toujours pas si agréable.  Par conséquent, nous considérons le mécanisme suivant. <br><br><h3>  <font color="#3AC1EF">▍ Fonctions paresseuses</font> </h3><br>  Jetons un coup d'œil à la deuxième faille utilisée par les adeptes de la programmation fonctionnelle.  Il consiste dans l'idée suivante: un effet secondaire n'est pas un effet secondaire jusqu'à ce qu'il se produise réellement.  Je sais que cela semble mystérieux.  Afin de comprendre cela, considérons l'exemple suivant: <br><br><pre> <code class="hljs lua">// fZero :: () -&gt; Number <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Launching nuclear missiles'</span></span>);   //          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Un exemple est peut-être stupide, je le sais.  Si nous avons besoin du numéro 0, alors pour qu'il apparaisse, il suffit de le saisir au bon endroit dans le code.  Et je sais aussi que vous n'écrirez pas de code JavaScript pour contrôler les armes nucléaires.  Mais nous avons besoin de ce code pour illustrer la technologie en question. <br><br>  Voici donc un exemple de fonction impure.  Il fournit des données à la console et est également la cause d'une guerre nucléaire.  Cependant, imaginez que nous avons besoin du zéro que cette fonction renvoie.  Imaginez un scénario dans lequel nous devons calculer quelque chose après le lancement d'une fusée.  Disons que nous pourrions avoir besoin de démarrer un compte à rebours ou quelque chose comme ça.  Dans ce cas, il serait tout à fait naturel de penser à l'avance aux calculs.  Et nous devons nous assurer que la fusée se lance exactement en cas de besoin.  Nous n'avons pas besoin d'effectuer des calculs de telle manière qu'ils pourraient conduire accidentellement au lancement de cette fusée.  Pensons donc à ce qui se passe si nous <code>fZero()</code> fonction <code>fZero()</code> dans une autre fonction qui la renvoie simplement.  Disons que ce sera quelque chose comme un wrapper de sécurité: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fZero :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number function fZero() {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Launching nuclear missiles'</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> returnZeroFunc :: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function returnZeroFunc() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fZero; }</code> </pre> <br>  Vous pouvez appeler la fonction <code>returnZeroFunc()</code> autant de fois que vous le souhaitez.  Dans ce cas, jusqu'à ce que la mise en œuvre de ce qu'il retourne soit effectuée, nous sommes (théoriquement) en sécurité.  Dans notre cas, cela signifie que l'exécution du code suivant ne conduira pas à une guerre nucléaire: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zeroFunc1 = returnZeroFunc(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zeroFunc2 = returnZeroFunc(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zeroFunc3 = returnZeroFunc(); <span class="hljs-comment"><span class="hljs-comment">//     .</span></span></code> </pre> <br>  Maintenant un peu plus strict qu'avant, approchons la définition du terme «fonction pure».  Cela nous permettra d'examiner la fonction <code>returnZeroFunc()</code> plus en détail.  Ainsi, la fonction est propre dans les conditions suivantes: <br><br><ul><li>  Aucun effet secondaire observé. </li><li>  Lien de transparence.  C'est-à-dire que l'appel d'une telle fonction avec les mêmes valeurs d'entrée conduit toujours aux mêmes résultats. </li></ul><br>  Analysons la fonction <code>returnZeroFunc()</code> . <br><br>  At-elle des effets secondaires?  Nous venons de découvrir que l'appel de <code>returnZeroFunc()</code> ne lance pas de missiles.  Si vous n'appelez pas ce que renvoie cette fonction, rien ne se passera.  Par conséquent, nous pouvons conclure que cette fonction n'a pas d'effets secondaires. <br><br>  Cette fonctionnalité est-elle référentiellement transparente?  Autrement dit, retourne-t-il toujours le même lors du passage des mêmes données d'entrée?  Nous allons vérifier cela, en profitant du fait que dans le fragment de code ci-dessus, nous avons appelé cette fonction plusieurs fois: <br><br><pre> <code class="hljs ruby">zeroFunc1 === zeroFunc2; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> zeroFunc2 === zeroFunc3; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Tout semble bien, mais la fonction <code>returnZeroFunc()</code> n'est pas encore complètement propre.  Elle se réfère à une variable qui est en dehors de sa propre portée.  Afin de résoudre ce problème, nous réécrivons la fonction: <br><br><pre> <code class="hljs powershell">// returnZeroFunc :: () -&gt; (() -&gt; Number) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnZeroFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {       console.log(<span class="hljs-string"><span class="hljs-string">'Launching nuclear missiles'</span></span>);       //              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fZero; }</code> </pre> <br>  Maintenant, la fonction peut être considérée comme propre.  Cependant, dans cette situation, les règles JavaScript jouent contre nous.  A savoir, nous ne pouvons plus utiliser l'opérateur <code>===</code> pour vérifier la transparence référentielle d'une fonction.  Cela est dû au fait que <code>returnZeroFunc()</code> renverra toujours une nouvelle référence à la fonction.  Certes, la transparence des liens peut être vérifiée en examinant le code vous-même.  Une telle analyse montrera qu'à chaque appel de fonction, elle renvoie un lien vers la même fonction. <br><br>  Devant nous se trouve une petite échappatoire soignée.  Mais peut-il être utilisé dans de vrais projets?  La réponse à cette question est positive.  Cependant, avant de parler de la façon de l'utiliser dans la pratique, nous développerons un peu notre idée.  À savoir, <code>fZero()</code> à la fonction dangereuse <code>fZero()</code> : <br><br><pre> <code class="hljs lua">// fZero :: () -&gt; Number <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Launching nuclear missiles'</span></span>);   //          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Nous allons essayer d'utiliser le zéro renvoyé par cette fonction, mais nous le ferons pour que (jusqu'à présent) une guerre nucléaire ne démarre pas.  Pour ce faire, créez une fonction qui prend le zéro renvoyé par la fonction <code>fZero()</code> et y ajoute un: <br><br><pre> <code class="hljs powershell">// fIncrement :: (() -&gt; Number) -&gt; Number <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fIncrement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f() + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fIncrement(fZero); //      //   <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  C'est pas de chance ... Nous avons accidentellement déclenché une guerre nucléaire.  Réessayons, mais cette fois, nous ne retournerons pas de chiffre.  Au lieu de cela, nous renvoyons une fonction qui un jour renvoie un nombre: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fIncrement :: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function fIncrement(f) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; f() + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fIncrement(zero); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   [Function]</code> </pre> <br>  Vous pouvez maintenant respirer facilement.  La catastrophe est évitée.  Nous poursuivons l'étude.  Grâce à ces deux fonctions, nous pouvons créer tout un tas de «nombres possibles»: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fOne   = fIncrement(zero); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fTwo   = fIncrement(one); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fThree = fIncrement(two); <span class="hljs-comment"><span class="hljs-comment">//   …</span></span></code> </pre> <br>  De plus, nous pouvons créer de nombreuses fonctions dont les noms commenceront par <code>f</code> (appelons-les fonctions <code>f*()</code> ), conçues pour fonctionner avec des «nombres possibles»: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fMultiply :: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function fMultiply(a, b) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; a() * b(); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fPow :: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function fPow(a, b) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; Math.pow(a(), b()); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fSqrt :: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) -&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Number) function fSqrt(x) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; Math.sqrt(x()); } const fFour = fPow(fTwo, fTwo); const fEight = fMultiply(fFour, fTwo); const fTwentySeven = fPow(fThree, fThree); const fNine = fSqrt(fTwentySeven); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,   . !</code> </pre> <br>  Voyez ce que nous avons fait ici?  Avec les "nombres possibles", vous pouvez faire la même chose qu'avec les nombres ordinaires.  Les mathématiciens appellent cela l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isomorphisme</a> .  Un nombre ordinaire peut toujours être transformé en "nombre possible" en le plaçant dans une fonction.  Vous pouvez obtenir le "numéro possible" en appelant la fonction.  En d'autres termes, nous avons une correspondance entre les nombres réguliers et les "nombres possibles".  En fait, cela est beaucoup plus intéressant qu'il n'y paraît.  Nous reviendrons bientôt sur cette idée. <br><br>  La technique ci-dessus utilisant la fonction wrapper est une stratégie valide.  Nous pouvons nous cacher derrière les fonctions autant que nécessaire.  Et, puisque nous n'avons encore appelé aucune de ces fonctions, toutes, théoriquement, sont pures.  Et personne ne déclenche une guerre.  Dans le code normal (non lié à la fusée), nous avons en fait besoin d'effets secondaires à la fin.  Envelopper tout ce dont nous avons besoin dans une fonction nous permet de contrôler précisément ces effets.  Nous choisissons le moment où ces effets apparaissent. <br><br>  Il convient de noter qu'il n'est pas très pratique d'utiliser des constructions uniformes avec des tas de crochets partout pour déclarer des fonctions.  Et la création de nouvelles versions de chaque fonction n'est pas non plus une activité agréable.  JavaScript a de grandes fonctions <code>Math.sqrt()</code> comme <code>Math.sqrt()</code> .  Ce serait formidable s'il existait un moyen d'utiliser ces fonctions ordinaires avec nos «valeurs en attente».  En fait, nous en parlerons maintenant. <br><br><h2>  <font color="#3AC1EF">Effet Functor</font> </h2><br>  Nous parlerons ici des foncteurs représentés par des objets contenant nos «fonctions différées».  Pour représenter le foncteur, nous utiliserons l'objet <code>Effect</code> .  Nous allons mettre notre fonction <code>fZero()</code> dans un tel objet.  Mais avant de faire cela, nous allons rendre cette fonction un peu plus sûre: <br><br><pre> <code class="hljs lua">// zero :: () -&gt; Number <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fZero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Starting with nothing'</span></span>);   //  , ,     .   //       .   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Nous décrivons maintenant la fonction constructeur pour créer des objets de type <code>Effect</code> : <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; }</code> </pre> <br>  Il n'y a rien de particulièrement intéressant ici, nous allons donc travailler sur cette fonctionnalité.  Donc, nous voulons utiliser la fonction habituelle <code>fZero()</code> avec l'objet <code>Effect</code> .  Pour fournir un tel scénario, nous écrirons une méthode qui accepte une fonction régulière et l'appliquera un jour à notre «valeur en attente».  Et nous le ferons sans appeler la fonction <code>Effect</code> .  Nous appelons une telle fonction <code>map()</code> .  Il porte un tel nom car il crée un mappage entre la fonction habituelle et la fonction d' <code>Effect</code> .  Cela peut ressembler à ceci: <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       }   } }</code> </pre> <br>  Maintenant, si vous surveillez de près ce qui se passe, vous pouvez avoir des questions sur la fonction <code>map()</code> .  Cela ressemble étrangement à la chanson.  Nous reviendrons sur ce problème plus tard, mais pour l'instant nous allons tester ce que nous avons en ce moment en action: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zero = Effect(fZero); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> increment = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   . const one = zero.map(increment);</span></span></code> </pre> <br>  Alors ... Maintenant, nous n'avons pas l'occasion d'observer ce qui s'est passé ici.  Par conséquent, modifions <code>Effect</code> afin, pour ainsi dire, d'avoir l'opportunité de "tirer sur la gâchette": <br><br><pre> <code class="hljs pgsql">// Effect :: <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> -&gt; Effect <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Effect(f) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       },       runEffects(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }   } } const zero = Effect(fZero); const <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span> = x =&gt; x + <span class="hljs-number"><span class="hljs-number">1</span></span>; //  . const one = zero.map(<span class="hljs-keyword"><span class="hljs-keyword">increment</span></span>); one.runEffects(); //       //   <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Si nécessaire, nous pouvons continuer d'appeler la fonction <code>map()</code> : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> = x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cube = x =&gt; Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(x, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> eight = Effect(fZero)   .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(increment)   .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)   .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(cube); eight.runEffects(); <span class="hljs-comment"><span class="hljs-comment">//       //   8</span></span></code> </pre> <br>  Ici, ce qui se passe commence déjà à devenir plus intéressant.  Nous l'appelons un «foncteur».  Tout cela signifie que l'objet <code>Effect</code> a une fonction <code>map()</code> et qu'il obéit à certaines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">règles</a> .  Cependant, ce ne sont pas des règles qui interdisent quoi que ce soit.  Ces règles concernent ce que vous pouvez faire.  Ce sont plutôt des privilèges.  Puisque l'objet <code>Effect</code> est un foncteur, il obéit à ces règles.  Il s'agit en particulier de la «règle de composition». <br><br>  Cela ressemble à ceci: <br><br>  S'il existe un objet <code>Effect</code> nommé <code>e</code> et deux fonctions, <code>f</code> et <code>g</code> , <code>e.map(g).map(f)</code> équivalent à <code>e.map(x =&gt; f(g(x)))</code> . <br><br>  En d'autres termes, deux méthodes <code>map()</code> consécutives équivalent à composer deux fonctions.  Cela signifie qu'un objet de type <code>Effect</code> peut effectuer des actions similaires aux suivantes (rappelez-vous l'un des exemples ci-dessus): <br><br><pre> <code class="hljs lisp">const incDoubleCube = x =&gt; cube(<span class="hljs-name"><span class="hljs-name">double</span></span>(<span class="hljs-name"><span class="hljs-name">increment</span></span>(<span class="hljs-name"><span class="hljs-name">x</span></span>)))<span class="hljs-comment"><span class="hljs-comment">; //       Ramda  lodash/fp      : // const incDoubleCube = compose(cube, double, increment); const eight = Effect(fZero).map(incDoubleCube);</span></span></code> </pre> <br>  Lorsque nous faisons ce qui est montré ici, nous sommes assurés d'obtenir le même résultat que nous obtiendrions en utilisant une version de ce code avec un triple appel à <code>map()</code> .  Nous pouvons l'utiliser lors de la refactorisation du code, et nous pouvons être sûrs que le code fonctionnera correctement.  Dans certains cas, le passage d'une approche à une autre peut même améliorer les performances. <br><br>  Maintenant, je propose d'arrêter d'expérimenter avec les nombres et de parler de ce qui ressemble davantage au code utilisé dans les projets réels. <br><br><h3>  <font color="#3AC1EF">▍Méthode de ()</font> </h3><br>  Le constructeur de l'objet <code>Effect</code> prend, comme argument, une fonction.  C'est pratique, car la plupart des effets secondaires que nous voulons reporter sont des fonctions.  Par exemple, ce sont <code>Math.random()</code> et <code>console.log()</code> .  Cependant, vous devez parfois mettre une valeur dans un objet <code>Effect</code> qui n'est pas une fonction. , ,       <code>window</code>       .      ,       .       ,       (      -, ,   ,  Haskell   <code>pure</code> ): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> :: a -&gt; Effect a Effect.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span> = function <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(val) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> val); }</code> </pre> <br>     ,      , ,     -.       , ,         .      HTML-      .       ,           .        .  Par exemple: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.myAppConf = {   selectors: {       <span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>:     <span class="hljs-string"><span class="hljs-string">'.userbio'</span></span>,       <span class="hljs-string"><span class="hljs-string">'article-list'</span></span>: <span class="hljs-string"><span class="hljs-string">'#articles'</span></span>,       <span class="hljs-string"><span class="hljs-string">'user-name'</span></span>:    <span class="hljs-string"><span class="hljs-string">'.userfullname'</span></span>,   },   templates: {       <span class="hljs-string"><span class="hljs-string">'greet'</span></span>:  <span class="hljs-string"><span class="hljs-string">'Pleased to meet you, {name}'</span></span>,       <span class="hljs-string"><span class="hljs-string">'notify'</span></span>: <span class="hljs-string"><span class="hljs-string">'You have {n} alerts'</span></span>,   } };</code> </pre> <br> ,    <code>Effect.of()</code> ,          <code>Effect</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> win = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); userBioLocator = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//   Effect('.userbio')</span></span></code> </pre> <br><h3> <font color="#3AC1EF">▍     Effect    </font> </h3><br>          .      ,   <code>Effect</code> . ,   <code>getElementLocator()</code> ,    <code>Effect</code> ,  .      DOM,    <code>document.querySelector()</code> —   ,    .    : <br><br><pre> <code class="hljs powershell">// <span class="hljs-variable"><span class="hljs-variable">$</span></span> :: String -&gt; Effect DOMElement <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> $</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(selector)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect.of(document.querySelector(s)); }</code> </pre> <br> ,      ,     <code>map()</code> : <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userBio = userBioLocator.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>($); <span class="hljs-comment"><span class="hljs-comment">//   Effect(Effect(&lt;div&gt;))</span></span></code> </pre> <br>  ,     ,   .         <code>div</code> ,    <code>map()</code>  ,    ,      . ,    <code>innerHTML</code> ,     : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> innerHTML = userBio.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">eff</span></span></span><span class="hljs-function"> =&gt;</span></span> eff.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">domEl</span></span></span><span class="hljs-function"> =&gt;</span></span> domEl.innerHTML)); <span class="hljs-comment"><span class="hljs-comment">//   Effect(Effect('&lt;h2&gt;User Biography&lt;/h2&gt;'))</span></span></code> </pre> <br>     ,    .   <code>userBio</code> ,    .    ,      ,      ,   . ,   ,      <code>Effect('user-bio')</code> .       ,  ,        ,     : <br><br><pre> <code class="hljs coffeescript">Effect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'.userbio'</span></span>);</code> </pre> <br>    —    .     : <br><br><pre> <code class="hljs coffeescript">Effect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>]);</code> </pre> <br> ,     <code>map()</code> ,          (    ).  , ,       <code>$</code> ,    : <br><br><pre> <code class="hljs lisp">Effect(() =&gt; $(<span class="hljs-name"><span class="hljs-name">window</span></span>.myAppConf.selectors['user-bio']))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>    ,   : <br><br><pre> <code class="hljs coffeescript">Effect(   <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Effect.<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>]))) );</code> </pre> <br>     <code>Effect.of</code> ,        : <br><br><pre> <code class="hljs coffeescript">Effect(   <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Effect(       <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>])   ) );</code> </pre> <br>    ,   ,    ,      .    <code>Effect</code>   . <br><br><h3> <font color="#3AC1EF">▍ join()</font> </h3><br>      ?     ,       <code>Effect</code> .     ,      ,          . <br><br>          <code>Effect</code>    <code>.runEffect()</code>   .     .     , - ,        ,   ,   ,  .      ,    .   <code>join()</code> .          <code>Effect</code> ,   <code>runEffect()</code>   ,        .       ,        . <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       },       runEffects(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       join(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }   } }</code> </pre> <br>       ,          : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userBioHTML = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>])   .map($)   .join()   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.innerHTML); <span class="hljs-comment"><span class="hljs-comment">//   Effect('&lt;h2&gt;User Biography&lt;/h2&gt;')</span></span></code> </pre> <br><h3> <font color="#3AC1EF">▍ chain()</font> </h3><br>  ,      <code>.map()</code> ,      <code>.join()</code> ,   .   ,  ,           .         ,     ,   <code>Effect</code> .         ,     <code>.map()</code>  <code>.join()</code> .  ,    ,      <code>Effect</code> : <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       },       runEffects(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       join(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       chain(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(f).map(g).join();       }   } }</code> </pre> <br>      <code>chain()</code> - ,     ,    <code>Effect</code> (  ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>      ).       HTML-        : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userBioHTML = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.myAppConf.selectors[<span class="hljs-string"><span class="hljs-string">'user-bio'</span></span>])   .chain($)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.innerHTML); <span class="hljs-comment"><span class="hljs-comment">//   Effect('&lt;h2&gt;User Biography&lt;/h2&gt;')</span></span></code> </pre> <br>          -.        . ,    <code>flatMap</code> .     ,       ,   —  ,  ,   <code>join()</code> .  Haskell, ,          <code>bind</code> . ,    -       , ,  <code>chain</code> , <code>flatMap</code>  <code>bind</code> —     . <br><br><h3> <font color="#3AC1EF">▍  Effect</font> </h3><br>        <code>Effect</code> ,      .              . ,          DOM,      ,    ?  , ,          ,  .    ,      .        —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br><pre> <code class="hljs powershell">// tpl :: String -&gt; Object -&gt; String const tpl = curry(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pattern, data)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.keys(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>).reduce(       (str, key) =&gt; str.replace(new RegExp(`{<span class="hljs-variable"><span class="hljs-variable">$</span></span>{key}}`, data[<span class="hljs-type"><span class="hljs-type">key</span></span>]),       pattern   ); });</code> </pre> <br>    .     : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> win = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.selectors[<span class="hljs-string"><span class="hljs-string">'user-name'</span></span>])   .chain($)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.innerHTML)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: str}); <span class="hljs-comment"><span class="hljs-comment">//   Effect({name: 'Mr. Hatter'}); const pattern = win.map(w =&gt; w.myAppConfig.templates('greeting')); //   Effect('Pleased to meet you, {name}');</span></span></code> </pre> <br> ,        .        .     ( <code>name</code>  <code>pattern</code> )    <code>Effect</code> .     <code>tpl()</code>    ,  ,      <code>Effect</code> . <br>    ,      <code>map()</code>  <code>Effect</code>      <code>tpl()</code> : <br><br><pre> <code class="hljs swift">pattern.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(tpl); <span class="hljs-comment"><span class="hljs-comment">//   Effect([Function])</span></span></code> </pre> <br>   ,    .     <code>map()</code>   : <br><br><pre> <code class="hljs erlang-repl">map :: Effect a ~&gt; (a -&gt; b) -&gt; Effect b</code> </pre> <br>       : <br><br><pre> <code class="hljs rust">tpl :: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; Object -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br> ,      <code>map()</code>  <code>pattern</code> ,      (  ,     <code>tpl()</code> )   <code>Effect</code> . <br><br><pre> <code class="hljs lisp">Effect (<span class="hljs-name"><span class="hljs-name">Object</span></span> -&gt; String)</code> </pre> <br>        <code>pattern</code>  <code>Effect</code> .           .       <code>Effect</code> ,    .   <code>ap()</code> : <br><br><pre> <code class="hljs powershell">// Effect :: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Effect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       map(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(x =&gt; g(f(x)));       },       runEffects(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       join(x) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(x);       }       chain(g) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Effect(f).map(g).join();       }       ap(eff) {            //  -  ap,    ,   eff   (  ).           //    map  ,    eff       (  <span class="hljs-string"><span class="hljs-string">'g'</span></span>)           //   g,     f()           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eff.map(g =&gt; g(f()));       }   } }</code> </pre> <br>    <code>.ap()</code>        : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> win = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.selectors[<span class="hljs-string"><span class="hljs-string">'user-name'</span></span>])   .chain($)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.innerHTML)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: str})); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pattern = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.templates(<span class="hljs-string"><span class="hljs-string">'greeting'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = name.ap(pattern.map(tpl)); <span class="hljs-comment"><span class="hljs-comment">//   Effect('Pleased to meet you, Mr Hatter')</span></span></code> </pre> <br>   ,       …   ,   ,   <code>.ap()</code>    .  ,  ,      <code>map()</code> ,    <code>ap()</code> . ,    ,     . <br><br>      .   ,              .  ,     ,   ,       <code>Effect</code> ,     <code>ap()</code> .    ,    : <br><br><pre> <code class="hljs powershell">// liftA2 :: (a -&gt; b -&gt; c) -&gt; (Applicative a -&gt; Applicative b -&gt; Applicative c) const liftA2 = curry(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">liftA2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y.ap(x.map(f));   //      :   // <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.map(f).chain(g =&gt; y.map(g)); });</code> </pre> <br>    <code>liftA2()</code> ,      ,    .       <code>liftA3()</code> : <br><br><pre> <code class="hljs erlang-repl">// liftA3 :: (a -&gt; b -&gt; c -&gt; d) -&gt; (Applicative a -&gt; Applicative b -&gt; Applicative c -&gt; Applicative d) const liftA3 = curry(function liftA3(f, a, b, c) {   return c.ap(b.ap(a.map(f))); });</code> </pre> <br>    ,    <code>liftA2()</code>  <code>liftA3()</code>   <code>Effect</code>   .  ,      ,    <code>ap()</code> . <br><br>      <code>liftA2()</code>   : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> win = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.selectors[<span class="hljs-string"><span class="hljs-string">'user-name'</span></span>])   .chain($)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.innerHTML)   .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: str}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pattern = win.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.templates[<span class="hljs-string"><span class="hljs-string">'greeting'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = liftA2(tpl)(pattern, user); <span class="hljs-comment"><span class="hljs-comment">//   Effect('Pleased to meet you, Mr Hatter')</span></span></code> </pre> <br><h2> <font color="#3AC1EF">  ?</font> </h2><br>      ,   ,    ,   .   ?     ,      <code>Effect</code>     <code>ap()</code>       .   ,        ?         ? <br><br>           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> : «     ,     ,     ». <br><br>       : <br><br><ul><li>     —   ? </li><li>      ,    <code>Effect</code> ,      ? </li></ul><br><h3> <font color="#3AC1EF">▍    </font> </h3><br>   —  .      ,      ,     ,    .    <code>const pattern = window.myAppConfig.templates['greeting'];</code>   ,  , , : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pattern = Effect.of(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.myAppConfig.templates(<span class="hljs-string"><span class="hljs-string">'greeting'</span></span>));</code> </pre> <br>    — ,       ,   ,  ,   .        .   —    ,   ,        .       ,    ,    , ,  ,   ,  .      ,           .         —  .     ,       ,       ,   .        ,    . <br><br>          .         . <br><br><h3> <font color="#3AC1EF">▍ Effect   </font> </h3><br> ,        ,        .    -  <code>Facebook</code>  <code>Gmail</code> .         ?     . <br><br> ,     .       .         CSV-     .     . , ,  ,        . ,         .   ,         .    ,   ,    ,     . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,         . ,      <code>map()</code>  <code>reduce()</code> ,     .     . ,    . ,   ,    ,    .      4  (,  , 8,  16,   ).    ,     ,      .     ,      . ,    -  . <br><br>      ,     ,    .    ,      .  Ça ne ressemble à rien?  ,  ,     ,     .                 .           ,     . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TensorFlow</a> ,      . <br><br>  TensorFlow,       ,    .      «». ,      ,     : <br><br><pre> <code class="hljs pgsql">node1 = tf.<span class="hljs-keyword"><span class="hljs-keyword">constant</span></span>(<span class="hljs-number"><span class="hljs-number">3.0</span></span>, tf.float32) node2 = tf.<span class="hljs-keyword"><span class="hljs-keyword">constant</span></span>(<span class="hljs-number"><span class="hljs-number">4.0</span></span>, tf.float32) node3 = tf.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(node1, node2)</code> </pre> <br>     Python,        JavaScript. ,          <code>Effect</code> ,   <code>add()</code>      ,          (        <code>sess.run()</code> ). <br><br><pre> <code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"node3: "</span></span>, node3) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"sess.run(node3): "</span></span>, sess.run(node3)) #  node3:  Tensor(<span class="hljs-string"><span class="hljs-string">"Add_2:0"</span></span>, shape=(), dtype=<span class="hljs-keyword"><span class="hljs-keyword">float32</span></span>) #  sess.run(node3):  <span class="hljs-number"><span class="hljs-number">7.0</span></span></code> </pre> <br>  ,  (7.0)      ,    <code>sess.run()</code> .  ,        .       ,  ,   ,   . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>       ,    .  ,        .       <code>Effect</code> . <br>       ,    ,    ,  ,   ,    . ,    ,      .  <code>Effect</code> ,   ,   ,     .      ,     . <br><br>    —    .         ,    .     ,  ,  .    .         .          ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br>  <b>Chers lecteurs!</b>         ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422589/">https://habr.com/ru/post/fr422589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422577/index.html">Copies et copyrights: comment les brevets et les droits d'auteur affectent le développement de l'impression 3D</a></li>
<li><a href="../fr422581/index.html">Commutateur quantique de style Schrödinger</a></li>
<li><a href="../fr422583/index.html">Tough Middling: revue du téléphone IP Snom D735</a></li>
<li><a href="../fr422585/index.html">L'utilisation pratique des réseaux de neurones</a></li>
<li><a href="../fr422587/index.html">Comment préparer et réussir l'IELTS: expérience personnelle</a></li>
<li><a href="../fr422591/index.html">Corona SDK json library anomaly</a></li>
<li><a href="../fr422593/index.html">Cachez-vous sans vous cacher. Encore une fois sur la stéganographie LSB, le chi carré et ... la singularité?</a></li>
<li><a href="../fr422595/index.html">Des scientifiques russes ont créé un moteur pour cubesat sur une solution d'alcool à 40%</a></li>
<li><a href="../fr422597/index.html">Backend United # 2: Farce</a></li>
<li><a href="../fr422601/index.html">Chrome 69 sort avec un générateur de mot de passe aléatoire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>