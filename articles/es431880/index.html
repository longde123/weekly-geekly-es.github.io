<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê™ üë† üå∏ Doom of SceneKit. Experiencia Yandex con gr√°ficos 3D en iOS üÖ∞Ô∏è üõ£Ô∏è üê™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Soy demasiado joven para morir. 


 SceneKit es un marco de gr√°ficos 3D de alto nivel en iOS que ayuda a crear escenas y efectos animados. Incluye u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Doom of SceneKit. Experiencia Yandex con gr√°ficos 3D en iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431880/"><p>  <i>- Soy demasiado joven para morir.</i> </p><br><p>  SceneKit es un marco de gr√°ficos 3D de alto nivel en iOS que ayuda a crear escenas y efectos animados.  Incluye un motor f√≠sico, un generador de part√≠culas y un conjunto de acciones simples para objetos 3D que le permiten describir la escena en t√©rminos de contenido (geometr√≠a, materiales, iluminaci√≥n, c√°maras) y animarla a trav√©s de una descripci√≥n de los cambios para estos objetos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/de8/eb3/a60/de8eb3a6080bb48be4f407c07d1b122a.gif"></p><br><p> Hoy veremos SceneKit con una mirada atenta y ligeramente severa, pero primero, repasemos lo b√°sico y veamos c√≥mo es la escena 3D y qu√© se debe hacer para crearla. <a name="habracut"></a></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1fa/7d7/138/1fa7d71381bc0f217fe6ddff8a08e77f.png" alt="La escena m√°s simple de tres nodos con geometr√≠a en ellos."><br>  <em>La escena m√°s simple de tres nodos con geometr√≠a en ellos.</em> </p><br><p>  Primero debe crear la estructura b√°sica de la escena, que consiste en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nodos</a> o nodos de la escena.  Cada nodo puede contener geometr√≠a y otros nodos.  La geometr√≠a puede ser simple, como una bola, cubo o pir√°mide, o m√°s compleja, creada en editores externos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9c/dd6/3ae/a9cdd63aeb3c662009d721feff5a2fa2.png" alt="Materiales de recubrimiento"><br>  <em>Materiales de recubrimiento</em> </p><br><p>  Luego, para esta geometr√≠a, debe especificar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">materiales</a> que determinar√°n la representaci√≥n b√°sica de los objetos.  Cada material establece su propio modelo de iluminaci√≥n y, dependiendo de √©l, utiliza un conjunto diferente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedades</a> .  Cada una de estas propiedades suele ser un color o textura, pero adem√°s de estas opciones de uso com√∫n, tambi√©n existe la opci√≥n de usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CALayer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AVPlayer</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SKScene</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0c1/ca5/831/0c1ca58318327b07263caf4f9d67ea63.png" alt="Agregar fuentes de iluminaci√≥n"><br>  <em>Agregar fuentes de iluminaci√≥n</em> </p><br><p>  Despu√©s de eso, es necesario agregar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuentes de luz</a> que determinen qu√© tan bien los objetos son visibles en una u otra parte de la escena.  Ellos, por analog√≠a con la geometr√≠a, deben estar dentro de un nodo.  SceneKit admite muchos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos</a> diferentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de iluminaci√≥n</a> , as√≠ como varios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos de sombras</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c16/a8e/f8e/c16a8ef8ebcfb7242eef1d8142b70dea.png" alt="Fuera de la caja efecto boke"><br>  <em>Fuera de la caja Efecto Boke</em> </p><br><p>  Luego, debe crear una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√°mara</a> (y colocarla en un nodo separado) y establecer los par√°metros b√°sicos para ella.  Hay muchos, pero con la ayuda de ellos puedes crear efectos geniales.  Fuera de la caja, se admiten bokeh (o desenfoque), HDR con adaptaci√≥n, brillo, SSAO y modificaciones de tono / saturaci√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/76f/62c/908/76f62c908bda6280380c922e3a1e8ca3.gif" alt="Animaciones simples en SceneKit"><br>  <em>Animaciones simples en SceneKit</em> </p><br><p>  Finalmente, SceneKit incluye un conjunto simple de acciones para objetos 3D que le permiten establecer cambios de escena con el tiempo.  SceneKit tambi√©n admite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acciones descritas en JavaScript</a> , pero este es un tema para un art√≠culo separado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/08c/0dc/2e4/08c0dc2e44e627e369af7dea6f18d27d.gif" alt="¬°La interacci√≥n de un generador de part√≠culas con un motor f√≠sico puede provocar tornados!"><br>  <em>¬°La interacci√≥n de un generador de part√≠culas con un motor f√≠sico puede provocar un tornado!</em> </p><br><p>  Adem√°s de los gr√°ficos, las caracter√≠sticas principales de SceneKit son el generador de part√≠culas y un motor f√≠sico avanzado que le permite establecer propiedades f√≠sicas reales para los objetos ordinarios y las part√≠culas del generador. </p><br><p>  Se ha escrito una gran cantidad de tutoriales detallados sobre todos estos chips.  Pero en el proceso de desarrollo, pr√°cticamente no usamos estas oportunidades ... </p><br><h2 id="hey-not-too-rough">  <strong>Oye, no muy rudo</strong> </h2><br><blockquote>  <em>Una vez que escrib√≠ un modelo de iluminaci√≥n para juegos en 3D mejor que la luz solar real, que proporciona un FPS aceptable en el Nvidia 8800, pero decid√≠ no lanzar el motor, porque Dios es amable conmigo y no quiero mostrar su incompetencia en este asunto.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Comenzaremos un estudio detallado con una tarea bastante simple que surge para casi todos los que trabajan bastante en serio con SceneKit: ¬øc√≥mo cargar un modelo con geometr√≠a compleja y materiales conectados, iluminaci√≥n e incluso animaciones? </p><br><p>  Hay varias formas, y todas tienen sus pros y sus contras: </p><br><ol><li><p>  SCNScene (named :) - obtiene una escena de un paquete, </p><br></li><li><p>  SCNScene (url: opciones :): carga la escena por URL, </p><br></li><li><p>  SCNScene (mdlAsset :): convierte una escena de diferentes formatos, </p><br></li><li><p>  SCNReferenceNode (url :) - carga perezosamente la escena. </p><br></li></ol><br><h3 id="poluchaem-scenu-iz-bandla">  Obt√©n la escena del paquete </h3><br><p>  Puede usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√©todo est√°ndar</a> : coloque nuestro modelo en formato dae o scn en el paquete scnassets y c√°rguelo desde all√≠ por analog√≠a con UIImage (llamado :). </p><br><p>  Pero, ¬øqu√© sucede si desea controlar la actualizaci√≥n de los modelos usted mismo sin publicar una actualizaci√≥n en la App Store cada vez que necesite cambiar un par de texturas?  O suponga que necesita admitir mapas y modelos creados por el usuario.  O bien, que simplemente no desea aumentar el tama√±o de la aplicaci√≥n, ya que los gr√°ficos en 3D no son la funcionalidad principal. </p><br><h3 id="zagruzhaem-scenu-po-url">  Cargando la escena por URL </h3><br><p>  Puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el constructor de escenas desde la URL del</a> archivo scn.  Este m√©todo admite la descarga no solo del sistema de archivos, sino tambi√©n de la red, pero en este √∫ltimo caso, puede olvidarse de la compresi√≥n.  Adem√°s, debe convertir el modelo al formato scn de antemano.  Puede, por supuesto, usar dae, pero viene con un conjunto de restricciones.  Por ejemplo, la falta de renderizado basado f√≠sicamente. </p><br><p>  La principal ventaja de este m√©todo es que le permite configurar de manera flexible la configuraci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">importaci√≥n</a> .  Puede, por ejemplo, modificar el ciclo de vida de las animaciones y hacer que se repitan sin cesar.  Puede especificar expl√≠citamente la fuente para cargar recursos externos como texturas, puede convertir la orientaci√≥n y la escala de la escena, crear normales faltantes para la geometr√≠a, fusionar toda la geometr√≠a de la escena en un nodo grande o descartar todos los elementos de la escena que no se ajustan al formato est√°ndar. </p><br><h3 id="konvertiruem-scenu-iz-raznyh-formatov">  Convierte una escena de diferentes formatos </h3><br><p>  La tercera opci√≥n es usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constructor con MDLAsset</a> .  Es decir, primero creamos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MDLAsset</a> , disponible en el marco ModelIO, y luego lo pasamos al constructor de la escena. </p><br><p>  Esta opci√≥n es buena porque le permite descargar muchos formatos diferentes.  Oficialmente, MDLAsset puede cargar los formatos obj, ply, stl y usd, pero despu√©s de ejecutar una lista de todos los formatos posibles, al menos de alguna manera relacionados con los gr√°ficos de computadora, encontr√© cuatro m√°s: abc, bsp, vox y md3, pero es posible que no sean totalmente compatibles o no en todos los sistemas, y para ellos debe verificar la correcci√≥n de la importaci√≥n. </p><br><p>  Tambi√©n es necesario tener en cuenta que este m√©todo tiene una sobrecarga para la conversi√≥n y usarlo con mucho cuidado. </p><br><p>  Estos m√©todos tienen una trampa com√∫n: devuelven SCNScene, no SCNNode.  La √∫nica forma de agregar contenido a una escena existente es copiar todos los nodos secundarios y, puede omitir f√°cilmente este paso, animaciones desde el nodo ra√≠z (por ejemplo, pueden aparecer all√≠ cuando se trabaja con dae).  Adem√°s, debe tener en cuenta que en la escena solo puede haber un entorno de textura (si no utiliza sombreadores personalizados para los reflejos). </p><br><h3 id="lenivo-zagruzhaem-scenu">  Perezosamente cargando la escena </h3><br><p>  La cuarta opci√≥n es usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SCNReferenceNode</a> .  No devuelve una escena, sino un nodo, que puede perezosamente (o bajo pedido) cargar en s√≠ mismo toda la jerarqu√≠a de la escena.  Por lo tanto, este m√©todo es similar al primero, pero oculta dentro de s√≠ todos los problemas de copia. </p><br><p>  Tiene una cosa m√°s: los par√°metros globales de la escena se pierden. </p><br><p>  Resulta que esta es la forma m√°s f√°cil y r√°pida de descargar su modelo, pero si necesita ajustar archivos, el primer m√©todo ser√° mejor. </p><br><p>  Como resultado, nos decidimos por la primera opci√≥n, ya que era m√°s conveniente para nosotros trabajar en formato SCN, y para los dise√±adores: convertir el formato DAE a este.  Adem√°s, necesit√°bamos animaciones de ajuste de archivos en el arranque. </p><br><h3 id="vovse-ne-prezhdevremennye-optimizacii">  Nada de optimizaciones prematuras </h3><br><p>  Despu√©s de haber jugado con este proceso durante mucho tiempo, puedo darte algunos consejos. </p><br><p>  El consejo m√°s importante es convertir los archivos a scn por adelantado.  Luego, al abrir el archivo en el editor de escenas incorporado en Xcode, puede ver c√≥mo se ver√° su objeto en SceneKit. </p><br><p>  Adem√°s, de hecho, el archivo scn es solo una representaci√≥n binaria de la escena, por lo que cargarlo tomar√° menos tiempo.  Para el mismo d√≠a, primero debe analizar el xml, luego convertir todas las mallas, animaciones y materiales.  Adem√°s, la conversi√≥n de animaciones y materiales es una fuente potencial de problemas.  Recordamos la falta de soporte PBR en dae: resulta que si desea usarlo, tendr√° que cambiar el tipo de todos los materiales despu√©s de la conversi√≥n y colocar manualmente las texturas apropiadas. </p><br><p>  Con esta operaci√≥n, puede obtener un efecto secundario muy √∫til: compresi√≥n de textura significativa.  Es suficiente abrirlos en la "Vista" y exportarlos, cambiando el formato a heic.  En promedio, esta operaci√≥n simple ahorr√≥ 5 megabytes por modelo. </p><br><p>  Adem√°s, si est√° descargando una escena de Internet, puedo aconsejarle que la descargue en el archivo, lo desempaquete y transfiera la URL del archivo SCN desempaquetado.  Esto le ahorrar√° a usted y al usuario megabytes adicionales, lo que, a su vez, acelerar√° la descarga y tambi√©n reducir√° el n√∫mero de puntos de falla.  De acuerdo: realizar una solicitud por separado para cada recurso externo, e incluso en Internet m√≥vil, no es la mejor manera de aumentar la confiabilidad. </p><br><h2 id="hurt-me-plenty">  <strong>Lastimame mucho</strong> </h2><br><blockquote>  <em>Cuando conduzco un autom√≥vil, a menudo escucho el disco duro del universo crujir, cargando la siguiente calle.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Entonces, cuando el trabajo de cargar e importar modelos se pone en marcha, surge una nueva tarea: agregar varios efectos y caracter√≠sticas a la escena.  Y cr√©eme, hay algo que contar.  Comenzamos por las diferentes constantes en SceneKit. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1e3/c0e/ffd/1e3c0effdc9c72b19d6e3d0a19a13796.png" alt="Las restricciones en SceneKit se limita inmediatamente despu√©s de la f√≠sica.  Y antes de renderizar el marco"><br>  <em>Las restricciones en SceneKit se consideran inmediatamente despu√©s de la f√≠sica.</em>  <em>Y antes de renderizar el marco</em> </p><br><p>  ¬øRestricciones, dices?  ¬øCu√°les son las constantes?  Pocas personas lo saben, y a√∫n m√°s lo hablan, pero SceneKit tiene su propio conjunto de constantes.  Y aunque no son tan flexibles como las constantes en UIkit, a√∫n puedes hacer muchas cosas interesantes con ellos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/006/c01/3a3/006c013a36d0bc0f615ca4f4378e4767.gif" alt="SCNReplicatorConstraint"><br>  <em>SCNReplicatorConstraint</em> </p><br><p>  Comencemos con una constante simple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SCNReplicatorConstraint</a> .  Todo lo que hace es duplicar la posici√≥n, rotaci√≥n y tama√±o de otro objeto con desplazamientos adicionales.  Como con todas las dem√°s constantes, puede cambiar la fuerza y ‚Äã‚Äãestablecer la bandera de incrementalidad.  Ambos par√°metros se pueden mostrar mejor en esta constante. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd7/98d/a46/dd798da468df11e71ab53c7a41e187c5.gif" alt="Fuerza reducida 10 veces"><br>  <em>Fuerza reducida 10 veces</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La fuerza</a> afecta la cantidad de transformaci√≥n que se aplica al objeto.  Y dado que la posici√≥n del objeto objetivo cambia cada cuadro, el objeto sombra se acerca a una d√©cima parte de la diferencia de distancia.  Debido a esto, aparece un efecto de retraso. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/535/ec5/0bc/535ec50bce2b4e57f30c71226bc783da.gif" alt="Incremento incrementado y fuerza reducida en 10 veces"><br>  <em>Incremento incrementado y fuerza reducida en 10 veces</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La incrementalidad</a> , a su vez, afecta si la constante se cancela despu√©s de la representaci√≥n.  Supongamos que lo apagamos.  Luego vemos que en cada cuadro, la constante se aplica antes de la representaci√≥n, y despu√©s de la representaci√≥n se cancela, por lo que se repite cada cuadro.  Como resultado, combinando estos dos par√°metros, puede obtener un efecto bastante interesante de las manecillas del reloj. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/5c5/cfd/74d5c5cfd7bde6252adf7855705ec5ad.gif" alt="El avi√≥n siempre mira a la c√°mara."><br>  <em>El avi√≥n siempre mira a la c√°mara.</em> </p><br><p>  Pasemos a una constante m√°s interesante: la llamada cartelera. </p><br><p>  Supongamos que es necesario que alg√∫n objeto est√© siempre "frente a nosotros".  Para hacer esto, simplemente use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SCNBillboardConstraint</a> , indique qu√© ejes puede rotar el objeto.  Adem√°s, antes de calcular cada cuadro (despu√©s de un paso con la f√≠sica), las posiciones y orientaciones de todos los objetos se actualizar√°n para satisfacer todas las constantes. </p><br><p>  Aqu√≠ puede mencionar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Look Restricci√≥n</a> : es similar a una valla publicitaria, solo el objeto se puede configurar frente a cualquier otro objeto en la escena en lugar de la c√°mara actual. </p><br><p>  ¬øQu√© se puede hacer con su ayuda?  Por supuesto, con mayor frecuencia estas constantes se usan para dibujar √°rboles u objetos peque√±os.  Tambi√©n crean efectos especiales como fuego o explosi√≥n.  Adem√°s, con su ayuda, puede hacer que la c√°mara siga al objeto en el escenario. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/077/6ed/96d/0776ed96d0d6116c12ababd108bfe180.gif" alt="Mantiene la distancia entre los objetos."><br>  <em>Mantiene la distancia entre los objetos.</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SCNDistanceConstraint le</a> permite establecer la distancia m√≠nima y / o m√°xima a la posici√≥n de otro objeto.  Y s√≠, puedes usarlo para hacer una serpiente.  :) Esta restricci√≥n tambi√©n se puede usar para unir la c√°mara al personaje, aunque la posici√≥n de la c√°mara suele ser m√°s complicada, y describirla solo con restricciones no es una tarea f√°cil.  El mismo efecto se puede lograr agregando un resorte en el motor f√≠sico, pero este resorte se puede complementar con una tensi√≥n en caso de que necesite evitar problemas con el estiramiento o la compresi√≥n excesiva del resorte. </p><br><p>  Muchos han visto en algunos Hitman, Fallout o Skyrim: arrastras un cuerpo contigo, toca un obst√°culo y comienza a comportarse como si un demonio hubiera entrado en √©l.  Esta constante ayudar√≠a a evitar tales errores. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f8f/578/aca/f8f578aca5e9d78034dcef18062349b8.gif" alt="SCNSliderConstraint"><br>  <em>SCNSliderConstraint</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SCNSliderConstraint le</a> permite establecer la distancia m√≠nima entre un objeto determinado y cuerpos f√≠sicos con una m√°scara de colisi√≥n adecuada.  Constante bastante divertido, pero de nuevo, intentan simularlo mediante la interacci√≥n f√≠sica.  La idea principal es establecer el radio de la zona muerta con cuerpos f√≠sicos para un objeto que no tiene un cuerpo f√≠sico. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/357/930/7df/3579307dfcf69c026734b0c35d7c6f04.gif" alt="Cinem√°tica inversa en el trabajo"><br>  <em>Cinem√°tica inversa en el trabajo</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SCNIKConstraint</a> es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constante</a> m√°s interesante, pero tambi√©n la m√°s compleja, que utiliza la llamada cinem√°tica inversa.  Utilizando una cadena de nodos principales, la cinem√°tica inversa intenta iterativamente llevar la posici√≥n del nodo a la que aplica esta constante al punto necesario.  De hecho, le permite no pensar en qu√© posici√≥n deber√≠an estar el hombro y el antebrazo, sino simplemente establecer la posici√≥n de la mano y los posibles √°ngulos de rotaci√≥n de los nodos de conexi√≥n.  El resto ser√° contado por ti.  El principal inconveniente de esta restricci√≥n es que le permite establecer solo la posici√≥n de la mano, pero no su orientaci√≥n, y las restricciones en los √°ngulos pueden hacerse globales, sin romper los ejes. </p><br><p>  Entonces, nos reunimos en detalle con las constantes y con lo que saben hacer.  Sigamos explorando efectos interesantes.  Nos ocuparemos del efecto de las sombras. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5d9/d62/4a4/5d9d624a480d96c5654a8df80be14115.gif" alt="Hay un avi√≥n, pero no es"><br>  <em>Hay un avi√≥n, pero no es</em> </p><br><p>  ¬øParecer√≠a que podr√≠a ser m√°s f√°cil en un motor que admite sombras que crear sombras?  Pero a veces las sombras deben proyectarse en un plano completamente transparente.  Esto es muy √∫til en ARKit, ya que la imagen de la c√°mara se muestra detr√°s del avi√≥n, y la sombra debe proyectarse en alg√∫n lugar.  El truco resulta ser bastante simple: primero debe habilitar las sombras diferidas y desactivar la grabaci√≥n en todos los componentes del plano en la pesta√±a de material, y la sombra continuar√° solap√°ndose.  El √∫nico problema es que este plano se superpondr√° a los objetos detr√°s de √©l. </p><br><p>  Pero las sombras no son el √∫nico efecto poco estudiado en SceneKit.  Tratemos con los espejos ahora. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/32d/75b/1ba/32d75b1ba50036e814d21bacb0104523.png" alt="SCNFloor mirror: lo que podr√≠a ser m√°s simple"><br>  <em>SCNFloor mirror: lo que podr√≠a ser m√°s simple</em> </p><br><p>  Todos los que jugaron con SceneKit probablemente sepan sobre scnfloor, que agrega reflejos de espejo al piso.  Pero por alguna raz√≥n, muy pocos lo usan para reflexiones honestas de espejos, porque puedes poner tu modelo en la geometr√≠a del piso, inclinarlo un poco y convertirlo ... en un espejo ordinario. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c4/bdf/289/1c4bdf289fd13dd45489765512bc2d2a.png"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fdd/950/d98/fdd950d9889d35a4d8e66b871c0c2767.png" alt="Goteo sobre vidrio y espejo curvo"><br>  <em>Goteo sobre vidrio y espejo curvo</em> </p><br><p>  Pero, lo que es a√∫n menos conocido, se puede establecer un mapa normal para este g√©nero.  Debido a esto, a su vez, puede crear muchos efectos interesantes diferentes, como el efecto de rayas o un espejo curvo. </p><br><h2 id="ultra-violence">  <strong>Ultravioleta</strong> </h2><br><blockquote>  <em>Una vez bes√© a una chica con los ojos abiertos.</em>  <em>La ni√±a se cort√≥ la cara con el plano de recorte.</em>  <em>Desde entonces beso solo con los ojos cerrados.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Sombras, espejos: efectos interesantes.  Pero hay un efecto que, cuando se usa con habilidad, puede resultar a√∫n m√°s interesante: las texturas de video. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/998/047/b54/998047b5496741e28e66d6faeb04f4a1.gif"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b7/91c/a6b/8b791ca6b8f464f5bd7401bdc07225ac.gif" alt="Videos ordinarios y de altura"><br>  <em>Videos ordinarios y de altura</em> </p><br><p>  Es posible que los necesites solo para mostrar el video dentro del juego.  Pero es mucho m√°s interesante que con la ayuda de texturas de video pueda modificar la geometr√≠a.  Para hacer esto, debe colocar la textura del video con un mapa de altura en la propiedad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desplazamiento</a> de su material y usar el material en un plano con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">n√∫mero</a> suficientemente grande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de segmentos</a> .  Queda por entender c√≥mo ponerlo all√≠. </p><br><p>  Mencion√© en la descripci√≥n del proceso de creaci√≥n de escenas que puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SKScene</a> como una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedad</a> material, y esta es una escena de SpriteKit.  SpriteKit es como SceneKit, pero para gr√°ficos 2D.  Tiene soporte para mostrar videos usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SKVideoNode</a> .  Solo necesita poner SKVideoNode en SKScene y SKScene en SCNMaterialProperty, y ya est√°. </p><br><p>  Pero despu√©s de exportar la escena 3D resultante y abrirla en otro lugar, veremos un cuadrado negro.  Revolviendo el archivo scn, encontr√© la raz√≥n.  Resulta que al guardar un c√≥digo de video, no guarda la URL del video.  Parece que tomas y gobiernas.  Pero no todo es tan simple: el archivo scn es un llamado plist binario, que contiene el resultado de NSKeyedArchiver.  Y el material, que es la escena SpriteKit, es el mismo plist binario, que resulta que ya se encuentra dentro de otro plist binario.  Es bueno que solo haya dos niveles de anidamiento. </p><br><p>  Bueno, ahora incluso pasaremos al efecto, pero a una herramienta que te permite crear cualquier tipo de efectos.  Estos son modificadores de sombreador. </p><br><p>  Antes de modificar algo, debe comprender lo que estamos modificando.  Un sombreador, por definici√≥n, es un programa para la GPU que se ejecuta para cada v√©rtice y para cada p√≠xel.  Por lo tanto, un sombreador es un programa que determina c√≥mo se ve un objeto en la pantalla. </p><br><p>  Bueno, los modificadores de sombreado le permiten cambiar los resultados de sombreadores est√°ndar a GLSL o lenguaje de sombreado de metal.  Tambi√©n est√°n disponibles en un editor visual, que le permite ver los cambios en el modificador en tiempo real. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/663/9d1/9a7/6639d19a72901a50caea2b969816a1ae.png"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1d1/94a/660/1d194a660488fe33aa392c0573834ca4.png" alt="Mapeo de pieles y paralaje"><br>  <em>Mapeo de pieles y paralaje</em> </p><br><p>  Con la ayuda de modificadores de sombreador, puede crear efectos visuales complejos.  Por ejemplo, algunos de los efectos m√°s famosos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mapeo de</a> pieles y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paralaje</a> . </p><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#pragma arguments texture2d bg; texture2d height; float depth; float layers; #pragma transparent #pragma body constexpr sampler sm = sampler(filter::linear, s_address::repeat, t_address::repeat); float3 bitangent = cross(_surface.tangent, _surface.normal); float2 direction = float2(-dot(_surface.view.rgb, _surface.tangent), dot(_surface.view.rgb, _surface.bitangent)); _output.color.rgba = float4(0); for(int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; int(floor(layers)); i++) { float coeff = float(i) / floor(layers); float2 defaultCoords = _surface.diffuseTexcoord + direction * (1 - coeff) * depth; float2 adjustment = float2(scn_frame.sinTime + defaultCoords.x, scn_frame.cosTime) * depth * coeff * 0.1; float2 coords = defaultCoords + adjustment; _output.color.rgb += bg.sample(sm, coords).rgb * coeff * (height.sample(sm, coords).r + 0.1) * (1.0 - coeff); _output.color.a += (height.sample(sm, coords).r + 0.1) * (1.0 - coeff); } return _output;</span></span></span></span></code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/7aa/b5f/b0e/7aab5fb0e907d2a7290f0f31e415e4be.gif" alt="Ray Casting con c√°usticos en tiempo real."><br>  <em>Ray Casting con c√°usticos en tiempo real</em> </p><br><p>  M√°s interesante a√∫n, nadie se molesta en tirar por completo los resultados de su trabajo y escribir su propio renderizador.  Por ejemplo, puede intentar implementar Ray Casting en sombreadores.  Y todo esto funciona lo suficientemente r√°pido como para proporcionar 30 FPS incluso en c√°lculos tan complejos.  Pero este es un tema para un informe separado.  ¬°Vamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mobius</a> ! </p><br><h2 id="nightmare">  <strong>Pesadilla!</strong> </h2><br><blockquote>  <em>No me gusta parpadear, porque los p√°rpados cerrados cargan bruscamente la GPU para BDPT debido a la falta de iluminaci√≥n.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Entonces, tenemos un mont√≥n de objetos con efectos geniales.  Ahora queda por aprender c√≥mo grabarlos.  Para hacer esto, pasemos a un tema m√°s complejo: c√≥mo aprendimos a grabar videos directamente desde SceneKit sin una IU externa y c√≥mo optimizamos esta grabaci√≥n decenas de veces. </p><br><p>  Primero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">veamos la</a> soluci√≥n m√°s simple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReplayKit</a> .  Descubre por qu√© no encaja.  En t√©rminos generales, esta soluci√≥n le permite crear una entrada de pantalla en varias l√≠neas de c√≥digo y guardarla a trav√©s de la vista previa del sistema.  Pero  Tiene un gran inconveniente: registra todo, la interfaz de usuario completa, incluidos todos los botones en la pantalla.  Esta fue nuestra primera decisi√≥n, pero por razones obvias fue imposible dejarla en producci√≥n: los usuarios ten√≠an que compartir el video y no compartirlo desde la vista previa del sistema. </p><br><p>  Nos encontramos en una situaci√≥n en la que la soluci√≥n necesitaba ser escrita desde cero.  Absolutamente desde cero.  Entonces, veamos c√≥mo en iOS puede crear su propio video y grabar sus cuadros all√≠.  Todo es bastante simple: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bd5/ce3/0f8/bd5ce30f8b449cba0a5fbe8d68d2a420.png" alt="Proceso de grabaci√≥n"><br>  <em>Proceso de grabaci√≥n</em> </p><br><p>  Necesitamos crear una entidad que registre archivos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AVAssetWriter</a> , agregar una transmisi√≥n de video, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AVAssetWriterInput</a> , y crear un adaptador para esta transmisi√≥n que convierta nuestro b√∫fer de p√≠xeles en el formato requerido por la transmisi√≥n: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AVAssetWriterPixelBufferAdaptor</a> . </p><br><p>  Por si acaso, le recuerdo que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫fer de p√≠xeles</a> es una entidad, que es una pieza de memoria donde los datos de los p√≠xeles se escriben de alguna manera.  Esto es esencialmente una representaci√≥n de bajo nivel de la imagen. </p><br><p>  Pero, ¬øc√≥mo obtener este b√∫fer de p√≠xeles?  La soluci√≥n es simple.  SCNView tiene una maravillosa funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.snapshot ()</a> que devuelve un UIImage.  Solo necesitamos crear un b√∫fer de p√≠xeles a partir de este UIImage. </p><br><pre> <code class="objectivec hljs">var unsafePixelBuffer: CVPixelBuffer? CVPixelBufferPoolCreatePixelBuffer(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixelBufferPool, &amp;unsafePixelBuffer) guard let pixelBuffer = maybePixelBuffer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) let data = CVPixelBufferGetBaseAddress(pixelBuffer) let rgbColorSpace = <span class="hljs-built_in"><span class="hljs-built_in">CGColorSpaceCreateDeviceRGB</span></span>() let bitmapInfo = <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapInfo</span></span>(rawValue: <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapInfo</span></span>.byteOrder32Little.rawValue | <span class="hljs-built_in"><span class="hljs-built_in">CGImageAlphaInfo</span></span>.premultipliedFirst.rawValue) let rowBytes = <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(CVPixelBufferGetBytesPerRow(pixelBuffer)) let context = <span class="hljs-built_in"><span class="hljs-built_in">CGContext</span></span>( data: data, width: image.width, height: image.height, bitsPerComponent: <span class="hljs-number"><span class="hljs-number">8</span></span>, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer), space: rgbColorSpace, bitmapInfo: bitmapInfo.rawValue ) context?.draw(image, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, width: image.width, height: image.height)) CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.appendPixelBuffer(pixelBuffer, withPresentationTime: presentationTime)</code> </pre> <br><p>  Simplemente asignamos un lugar en la memoria, describimos qu√© formato tienen estos p√≠xeles, bloqueamos el b√∫fer para cambiar, obtenemos la direcci√≥n de memoria, creamos un contexto en la direcci√≥n recibida, donde describimos c√≥mo se empaquetan los p√≠xeles, cu√°ntas l√≠neas hay en la imagen y qu√© espacio de color usamos.  Luego copiamos los p√≠xeles de UIImage all√≠, conociendo el formato final, y desbloqueamos el cambio. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ba0/e25/5a0/ba0e255a03515ee7e299bfa3d2757526.png"></p><br><p>  Ahora necesitas hacer esto cada cuadro.  Para hacer esto, creamos un enlace de pantalla que llamar√° a una devoluci√≥n de llamada para cada fotograma, donde, a su vez, llamaremos al m√©todo de instant√°nea y crearemos un b√∫fer de p√≠xeles a partir de la imagen.  ¬°Todo es simple! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab9/6fa/841/ab96fa8410458c0854d2c6b74bfb488c.gif"></p><br><p>  Pero no  Tal soluci√≥n, incluso en tel√©fonos potentes, provoca retrasos terribles y reducciones de FPS.  Hagamos la optimizaci√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b13/562/6e6/b135626e6d19559cb931b0d62e20e0d3.png"></p><br><p>  Digamos que no necesitamos 60 FPS.  Incluso estaremos encantados con el 25.  Pero, ¬øcu√°l es la forma m√°s f√°cil de lograr este resultado?  Por supuesto, solo necesita poner todo esto en un hilo de fondo.  Adem√°s, seg√∫n los desarrolladores, esta funci√≥n es segura para subprocesos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/701/d7c/a26/701d7ca267899b726966bcefacd2921e.gif"></p><br><p>  Hmm, el retraso se ha vuelto menos, pero el video ha dejado de grabar ... </p><br><p>  Todo es simple  Como dicen, si tiene un problema y lo resolver√° con la ayuda de varios hilos, tendr√° 2 problemas. </p><br><p>  Si intenta grabar un b√∫fer de p√≠xeles con una marca de tiempo inferior a la √∫ltima grabada, el video completo no ser√° v√°lido. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/643/ed3/f61/643ed3f61dd84093f38c4447952d2a8b.png"></p><br><p>  Entonces, no escribamos un nuevo b√∫fer hasta que finalice la escritura anterior. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/335/c9f/544/335c9f544b1bfd080a34cfe03847235a.gif"></p><br><p>  Hmm, se puso mucho mejor.  Pero de todos modos, ¬øpor qu√© aparecieron los retrasos inicialmente? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ef1/b9d/838/ef1b9d8381334a5b0d6c9c4952eea020.png"></p><br><p>  Resulta que la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.snapshot ()</a> , con la que obtenemos una imagen de la pantalla, crea un nuevo renderizador para cada llamada, dibuja un marco desde cero y lo devuelve, no la imagen que est√° en la pantalla.  Esto lleva a efectos divertidos.  Por ejemplo, la simulaci√≥n f√≠sica es dos veces m√°s r√°pida. </p><br><p>  Pero espere, ¬øpor qu√© tratamos de renderizar un nuevo marco cada vez?  Seguramente en alg√∫n lugar puede encontrar el b√∫fer que se muestra en la pantalla.  De hecho, hay acceso a ese b√∫fer, pero es muy no trivial.  Necesitamos obtener <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CAMetalDrawable</a> de Metal. </p><br><p>  Desafortunadamente, llegar a Metal directamente desde SCNView no es tan f√°cil por una raz√≥n bastante comprensible: en SceneKit puede elegir el tipo de API usted mismo, pero si mira debajo del cap√≥ y mira la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capa</a> , puede ver que act√∫a como tal, en el caso de Metal, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CAMetalLayer</a> . </p><br><p>  Pero aqu√≠ tambi√©n nos espera el fracaso: en CAMetalLayer, la √∫nica forma de interactuar con la vista es la funci√≥n nextDrawable, que devuelve un CAMetalDrawable desocupado.  Se entiende que escribir√° datos en √©l y llamar√° a la funci√≥n presente en √©l, que lo mostrar√° en la pantalla. </p><br><p>  La soluci√≥n realmente existe.  El hecho es que despu√©s de desaparecer de la pantalla, el b√∫fer no se desasigna, sino que solo se vuelve a colocar en el grupo.  De hecho, ¬øpor qu√© asignar memoria cada vez si dos o tres buffers son suficientes ?: uno se muestra en la pantalla, el segundo para renderizar y el tercero, por ejemplo, para el postprocesamiento, si tiene uno. </p><br><p>  Resulta que despu√©s de mostrar el b√∫fer, los datos de √©l no desaparecen en ning√∫n lugar y puede acceder a ellos de manera segura. </p><br><p>  Y si en el sucesor comenzamos en respuesta a cada llamada a nextDrawable () para guardarlo, obtenemos casi lo que necesitamos.  El problema es que el CAMetalDrawable guardado es aquel en el que se est√° dibujando la imagen en este momento. </p><br><p>  El salto a la soluci√≥n real es muy simple: guardamos tanto el Drawable actual como el anterior. </p><br><p>  Y aqu√≠ est√°, listo: acceso directo a la memoria a trav√©s de CAMetalDrawable. </p><br><pre> <code class="objectivec hljs">var unsafePixelBuffer: CVPixelBuffer? CVPixelBufferPoolCreatePixelBuffer(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixelBufferPool, &amp;unsafePixelBuffer) guard let pixelBuffer = maybePixelBuffer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) let data = CVPixelBufferGetBaseAddress(pixelBuffer) let width: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = lastDrawable.texture.width let height: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = lastDrawable.texture.height let rowBytes: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(CVPixelBufferGetBytesPerRow(pixelBuffer) lastDrawable.texture.getBytes( data, bytesPerRow: rowBytes, fromRegion: <span class="hljs-built_in"><span class="hljs-built_in">MTLRegionMake2D</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height), mipmapLevel: <span class="hljs-number"><span class="hljs-number">0</span></span> ) CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.appendPixelBuffer(pixelBuffer, withPresentationTime: presentationTime)</code> </pre> <br><p>  Entonces, ahora no creamos un contexto y dibujamos un UIImage en √©l, sino que copiamos una pieza de memoria a otra.  Surge la pregunta: ¬øqu√© pasa con el formato de p√≠xeles? .. </p><br><p>  No coincide con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deviceColorSpace</a> ... Y no coincide con espacios de color de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uso com√∫n</a> ... </p><br><p>  Este es exactamente el punto donde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el</a> autor de uno de los hogares p√∫blicos, que realiza la misma tarea, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se averi√≥</a> .  Todos los dem√°s ni siquiera llegaron aqu√≠. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/198/181/bc7/198181bc7d908bca2ec56df495010106.gif"></p><br><p>  Bueno, todos estos trucos, ¬øpor un filtro espeluznante? </p><br><p>  Pues no!  En el art√≠culo sobre ARKit, puede encontrar una menci√≥n de que la imagen de la c√°mara no utiliza el espacio de color est√°ndar, sino que se expande.  E incluso se presenta una matriz de transformaci√≥n del espacio de color.  Pero, ¬øpor qu√© participar en la transformaci√≥n, si puede intentar grabar directamente en este formato?  Queda por descubrir de qu√© formato est√° disponible entre 60 ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/75d/802/781/75d8027810eb481eaa1775bd122cb79a.gif"></p><br><p>  Y luego comenc√© a reventar.  Grab√© tres videos en diferentes transmisiones con diferentes formatos, reemplaz√°ndolos con cada grabaci√≥n. </p><br><p>  Como resultado, en aproximadamente el cuadrag√©simo formato, obtenemos su nombre.  Resulta que no es otro que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kCVPixelFormatType_30RGBLEPackedWideGamut</a> .  ¬øC√≥mo no adivin√©? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d6e/2e6/31e/d6e2e631e3dfdc690c85222a51561446.gif"></p><br><p>  Pero mi alegr√≠a dur√≥ hasta el primer probador.  No tuve palabras  Como?  Acabo de pasar mucho tiempo buscando el formato correcto.  Es bueno que el problema se haya localizado r√°pidamente: el error se reprodujo de manera estable y solo en 6s y 6s Plus.  Casi inmediatamente despu√©s de eso, record√© que las pantallas con soporte de amplia gama comenzaron a instalarse solo en s√©ptimos iPhones. </p><br><p>  ¬°Cambiando la amplia gama al viejo 32RGBA, obtengo un registro de trabajo!  Queda por comprender c√≥mo determinar que el dispositivo admite una amplia gama.  Hay iPads con diferentes tipos de pantalla, y pens√© que seguramente puede obtener el tipo de pantalla ENUM del sistema.  Hurgando en la documentaci√≥n, la encontr√©: esta es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">displayGamut</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UITraitCollection</a> . </p><br><p>  Despu√©s de entregar la asamblea a los probadores, recib√≠ buenas noticias de ellos: ¬°todo funcion√≥ sin retrasos, incluso en dispositivos viejos! </p><br><p>  En conclusi√≥n, quiero decirte: ¬°haz gr√°ficos en 3D!  En nuestra aplicaci√≥n, para la cual la realidad aumentada no es el caso de uso principal, durante el fin de semana, ¬°la gente viaj√≥ m√°s de 2,000 kil√≥metros, vio m√°s de 3,000 objetos y grab√≥ m√°s de 1,000 videos con ellos!  Imagina lo que puedes hacer si lo haces t√∫ mismo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431880/">https://habr.com/ru/post/es431880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431870/index.html">El desarrollador de libros interactivos con LED se queja del robo de ideas por parte de los empleados de Google</a></li>
<li><a href="../es431872/index.html">Gu√≠a de JavaScript Parte 9: Descripci√≥n general de los est√°ndares ES7, ES8 y ES9</a></li>
<li><a href="../es431874/index.html">Imba: lenguaje compatible con JavaScript para un trabajo r√°pido con DOM</a></li>
<li><a href="../es431876/index.html">Optimizaci√≥n de aplicaciones angulares.</a></li>
<li><a href="../es431878/index.html">Caracter√≠sticas de JavaScript poco conocidas</a></li>
<li><a href="../es431884/index.html">Microsoft super√≥ a Apple en la capitalizaci√≥n de mercado: ¬øc√≥mo sucedi√≥ esto?</a></li>
<li><a href="../es431886/index.html">Al Lowy subi√≥ su colecci√≥n de c√≥digo fuente para productos Sierra en eBay</a></li>
<li><a href="../es431888/index.html">"Creo que las ideas de equipo son las m√°s importantes al desarrollar un producto".</a></li>
<li><a href="../es431890/index.html">C√≥mo hacer un pedido en el intercambio independiente</a></li>
<li><a href="../es431892/index.html">Utilizamos Veeam Backup & Replication para probar nuevos sistemas y aplicaciones antes de actualizar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>