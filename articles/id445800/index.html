<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚛️ 🧔🏻 🤲🏻 Monads dalam 15 menit 💵 👋🏽 💅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entri 
 Di YOW! 2013 salah satu pengembang bahasa Haskell, prof. Philip Wadler menunjukkan bagaimana monad memungkinkan bahasa fungsional murni untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monads dalam 15 menit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445800/"><h2>  Entri </h2><br>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YOW!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2013</a> salah satu pengembang bahasa Haskell, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prof.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Philip Wadler</a> menunjukkan bagaimana monad memungkinkan bahasa fungsional murni untuk melakukan operasi penting pada dasarnya, seperti input-output dan penanganan pengecualian.  Tidak mengherankan, minat audiens pada topik ini telah menghasilkan pertumbuhan eksplosif dalam publikasi tentang monad di Internet.  Sayangnya, sebagian besar publikasi ini menggunakan contoh-contoh yang ditulis dalam bahasa fungsional, menyiratkan bahwa pendatang baru untuk pemrograman fungsional ingin belajar tentang monad.  Tetapi monad tidak spesifik untuk Haskell atau bahasa fungsional, dan mungkin diilustrasikan dengan contoh-contoh dalam bahasa pemrograman imperatif.  Ini adalah tujuan dari panduan ini. <br><br>  Bagaimana panduan ini berbeda dari yang lain?  Kami akan mencoba membuka monad dalam waktu tidak lebih dari 15 menit hanya dengan menggunakan intuisi dan beberapa contoh dasar kode Python.  Oleh karena itu, kita tidak akan mulai berteori dan mempelajari filosofi, berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">burrito</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://web.archive.org/web/20081206204420/">pakaian luar angkasa</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meja</a> dan endofunctor. <br><a name="habracut"></a><br><h2>  Contoh motivasi </h2><br>  Kami akan mempertimbangkan tiga masalah terkait komposisi fungsi.  Kami akan menyelesaikannya dalam dua cara: imperatif biasa dan menggunakan monad.  Kemudian kami membandingkan pendekatan yang berbeda. <br><br><h3>  1. Pencatatan </h3><br>  Misalkan kita memiliki tiga fungsi unary: <code>f1</code> , <code>f2</code> dan <code>f3</code> , yang mengambil angka dan mengembalikannya masing-masing meningkat 1, 2, dan 3.  Setiap fungsi juga menghasilkan pesan, yang merupakan laporan tentang operasi yang selesai. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + <span class="hljs-number"><span class="hljs-number">1</span></span>, str(x) + <span class="hljs-string"><span class="hljs-string">"+1"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span>, str(x) + <span class="hljs-string"><span class="hljs-string">"+2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + <span class="hljs-number"><span class="hljs-number">3</span></span>, str(x) + <span class="hljs-string"><span class="hljs-string">"+3"</span></span>)</code> </pre> <br>  Kami ingin rantai mereka bersama-sama untuk memproses parameter <code>x</code> , dengan kata lain, kami ingin menghitung <code>x+1+2+3</code> .  Selain itu, kita perlu mendapatkan penjelasan yang bisa dibaca manusia tentang apa yang masing-masing fungsi lakukan. <br><br>  Kita dapat mencapai hasil yang kita butuhkan dengan cara berikut: <br><pre> <code class="python hljs">log = <span class="hljs-string"><span class="hljs-string">"Ops:"</span></span> res, log1 = f1(x) log += log1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> res, log2 = f2(res) log += log2 + <span class="hljs-string"><span class="hljs-string">";"</span></span> res, log3 = f3(res) log += log3 + <span class="hljs-string"><span class="hljs-string">";"</span></span> print(res, log)</code> </pre> <br>  Solusi ini tidak ideal, karena terdiri dari sejumlah besar middleware monoton.  Jika kami ingin menambahkan fungsi baru ke rantai kami, kami akan dipaksa untuk mengulangi kode tautan ini.  Selain itu, manipulasi dengan variabel <code>res</code> dan <code>log</code> mengganggu pembacaan kode, sehingga sulit untuk mengikuti logika utama program. <br><br>  Idealnya, sebuah program harus terlihat seperti rangkaian fungsi sederhana, seperti <code>f3(f2(f1(x)))</code> .  Sayangnya, tipe data yang dikembalikan oleh <code>f1</code> dan <code>f2</code> tidak cocok dengan tipe parameter <code>f2</code> dan <code>f3</code> .  Tapi kita bisa menambahkan fungsi baru ke rantai: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x, <span class="hljs-string"><span class="hljs-string">"Ops:"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, f)</span></span></span><span class="hljs-function">:</span></span> res = f(t[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (res[<span class="hljs-number"><span class="hljs-number">0</span></span>], t[<span class="hljs-number"><span class="hljs-number">1</span></span>] + res[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">";"</span></span>)</code> </pre> <br>  Sekarang kita bisa menyelesaikan masalah sebagai berikut: <br><pre> <code class="python hljs">print(bind(bind(bind(unit(x), f1), f2), f3))</code> </pre> <br>  Diagram berikut menunjukkan proses komputasi yang terjadi pada <code>x=0</code> .  Di sini <code>v1</code> , <code>v2</code> dan <code>v3</code> adalah nilai yang diperoleh sebagai hasil dari panggilan ke <code>unit</code> dan <code>bind</code> . <br><br><img src="https://habrastorage.org/webt/dy/ta/f0/dytaf0ku8j3y7ctrcrhjlqbs2ck.png"><br><br>  Fungsi <code>unit</code> mengubah parameter input <code>x</code> menjadi tupel angka dan string.  Fungsi <code>bind</code> memanggil fungsi yang diteruskan kepadanya sebagai parameter dan mengakumulasikan hasilnya dalam variabel perantara <code>t</code> . <br><br>  Kami dapat menghindari pengulangan middleware dengan menempatkannya di fungsi <code>bind</code> .  Sekarang, jika kita mendapatkan fungsi <code>f4</code> , kita cukup memasukkannya dalam rantai: <br><pre> <code class="python hljs">bind(f4, bind(f3, ... ))</code> </pre> <br>  Dan kita tidak perlu melakukan perubahan lain. <br><br><h3>  2. Daftar nilai antara </h3><br>  Kami juga akan memulai contoh ini dengan fungsi unary sederhana. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Seperti pada contoh sebelumnya, kita perlu membuat fungsi-fungsi ini untuk menghitung <code>x+1+2+3</code> .  Kita juga perlu mendapatkan daftar semua nilai yang diperoleh sebagai hasil kerja fungsi kita, yaitu, <code>x</code> , <code>x+1</code> , <code>x+1+2</code> dan <code>x+1+2+3</code> . <br><br>  Tidak seperti contoh sebelumnya, fungsi kami dapat dikompilasi, yaitu, jenis parameter inputnya bertepatan dengan jenis hasilnya.  Oleh karena itu, rantai sederhana <code>f3(f2(f1(x)))</code> akan mengembalikan hasil akhir.  Namun dalam kasus ini, kami kehilangan nilai perantara. <br><br>  Mari kita selesaikan masalah "langsung": <br><pre> <code class="python hljs">lst = [x] res = f1(x) lst.append(res) res = f2(res) lst.append(res) res = f3(res) lst.append(res) print(res, lst)</code> </pre> <br>  Sayangnya, solusi ini juga mengandung banyak middleware.  Dan jika kita memutuskan untuk menambahkan <code>f4</code> , kita harus mengulangi kode ini lagi untuk mendapatkan daftar nilai perantara yang benar. <br><br>  Oleh karena itu, kami menambahkan dua fungsi tambahan, seperti pada contoh sebelumnya: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x, [x]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, f)</span></span></span><span class="hljs-function">:</span></span> res = f(t[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (res, t[<span class="hljs-number"><span class="hljs-number">1</span></span>] + [res])</code> </pre> <br>  Sekarang kami menulis ulang program sebagai rantai panggilan: <br><pre> <code class="python hljs">print(bind(bind(bind(unit(x), f1), f2), f3))</code> </pre> <br>  Diagram berikut menunjukkan proses komputasi yang terjadi pada <code>x=0</code> .  Sekali lagi, <code>v1</code> , <code>v2</code> dan <code>v3</code> menunjukkan nilai yang diperoleh dari panggilan <code>unit</code> dan <code>bind</code> . <br><br><img src="https://habrastorage.org/webt/qh/uw/7y/qhuw7yx5fo1yjlcbce34kuhejj4.png"><br><br><h3>  3. Nilai kosong </h3><br>  Mari kita coba memberikan contoh yang lebih menarik, kali ini dengan kelas dan objek.  Misalkan kita memiliki kelas <code>Employee</code> dengan dua metode: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Employee</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_boss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Return the employee's boss def get_wage(self): # Compute the wage</span></span></code> </pre> <br>  Setiap objek dari kelas <code>Employee</code> memiliki manajer (objek lain dari kelas <code>Employee</code> ) dan gaji, yang diakses melalui metode yang tepat.  Kedua metode juga dapat mengembalikan <code>None</code> (karyawan tidak memiliki manajer, gajinya tidak diketahui). <br><br>  Dalam contoh ini, kami akan membuat program yang menunjukkan gaji pimpinan karyawan ini.  Jika manajer tidak ditemukan, atau gajinya tidak dapat ditentukan, maka program tidak akan mengembalikan apa <code>None</code> . <br><br>  Idealnya, kita perlu menulis sesuatu seperti <br><pre> <code class="python hljs">print(john.get_boss().get_wage())</code> </pre> <br>  Tetapi dalam kasus ini, jika salah satu metode mengembalikan <code>None</code> , program kami akan berakhir dengan kesalahan. <br><br>  Cara yang jelas untuk menangani situasi ini mungkin terlihat seperti ini: <br><pre> <code class="python hljs">result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> john <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> john.get_boss() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> john.get_boss().get_wage() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: result = john.get_boss().get_wage() print(result)</code> </pre> <br>  Dalam hal ini, kami mengizinkan panggilan tambahan ke metode <code>get_boss</code> dan <code>get_wage</code> .  Jika metode ini cukup berat (misalnya, mengakses database), solusi kami tidak akan berhasil.  Karena itu, kami mengubahnya: <br><pre> <code class="python hljs">result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> john <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: boss = john.get_boss() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> boss <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: wage = boss.get_wage() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> wage <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: result = wage print(result)</code> </pre> <br>  Kode ini optimal dalam hal perhitungan, tetapi kurang dibaca karena tiga <code>if</code> bersarang.  Karena itu, kami akan mencoba menggunakan trik yang sama seperti pada contoh sebelumnya.  Tentukan dua fungsi: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, f)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> f(e)</code> </pre> <br>  Dan sekarang kita dapat menempatkan seluruh solusi dalam satu baris. <br><pre> <code class="python hljs">print(bind(bind(unit(john), Employee.get_boss), Employee.get_wage))</code> </pre> <br>  Seperti yang mungkin sudah Anda perhatikan, dalam hal ini kami tidak harus menulis fungsi <code>unit</code> : hanya mengembalikan parameter input.  Tetapi kita akan meninggalkannya sehingga akan lebih mudah bagi kita untuk menggeneralisasi pengalaman kita. <br><br>  Perhatikan juga bahwa dalam Python kita dapat menggunakan metode sebagai fungsi, yang memungkinkan kita untuk menulis <code>Employee.get_boss(john)</code> alih-alih <code>john.get_boss()</code> . <br><br>  Diagram berikut menunjukkan proses perhitungan ketika John tidak memiliki pemimpin, yaitu <code>john.get_boss()</code> mengembalikan <code>None</code> . <br><br><img src="https://habrastorage.org/webt/hm/ae/9r/hmae9rlrkzaorijygg-jg2u7wrq.png"><br><br><h2>  Kesimpulan </h2><br>  Misalkan kita ingin menggabungkan fungsi dengan tipe yang sama <code>f1</code> , <code>f2</code> , <code>…</code> , <code>fn</code> .  Jika parameter inputnya sama dengan hasilnya, kita dapat menggunakan rantai sederhana dari bentuk <code>fn(… f2(f1(x)) …)</code> .  Diagram berikut menunjukkan proses perhitungan umum dengan hasil antara, dilambangkan sebagai <code>v1</code> , <code>v2</code> , <code>…</code> , <code>vn</code> . <br><br><img src="https://habrastorage.org/webt/dl/yl/lp/dlyllpbpaltz_hwgjbugs8ti2zg.png"><br><br>  Seringkali pendekatan ini tidak berlaku.  Jenis nilai input dan hasil fungsi dapat bervariasi, seperti pada contoh pertama.  Atau fungsi dapat dikomposisikan, tetapi kami ingin memasukkan logika tambahan di antara panggilan, seperti dalam contoh 2 dan 3 kami memasukkan agregasi nilai antara dan masing-masing untuk memeriksa nilai kosong. <br><br><h3>  1. Keputusan penting </h3><br>  Dalam semua contoh, kami pertama kali menggunakan pendekatan yang paling mudah, yang dapat diwakili oleh diagram berikut: <br><br><img src="https://habrastorage.org/webt/bo/2i/co/bo2ico2rhkvds3jmirwyzsyd3yc.png"><br><br>  Sebelum memanggil <code>f1</code> kami melakukan inisialisasi.  Dalam contoh pertama, kami menginisialisasi variabel untuk menyimpan log umum, yang kedua untuk daftar nilai-nilai perantara.  Setelah itu, kami menyelingi panggilan fungsi dengan kode penghubung tertentu: kami menghitung nilai agregat, memeriksa hasilnya untuk <code>None</code> . <br><br><h3>  2. Monad </h3><br>  Seperti yang kita lihat dalam contoh, keputusan imperatif selalu menderita dari kata kerja, pengulangan, dan logika yang membingungkan.  Untuk mendapatkan kode yang lebih elegan, kami menggunakan pola desain tertentu, yang dengannya kami membuat dua fungsi: <code>unit</code> dan <code>bind</code> .  Template ini disebut <b>monad</b> .  Fungsi <code>bind</code> berisi middleware sementara <code>unit</code> mengimplementasikan inisialisasi.  Ini memungkinkan kami untuk menyederhanakan solusi akhir menjadi satu baris: <br><pre> <code class="python hljs">bind(bind( ... bind(bind(unit(x), f1), f2) ... fn<span class="hljs-number"><span class="hljs-number">-1</span></span>), fn)</code> </pre> <br>  Proses perhitungan dapat diwakili oleh diagram: <br><br><img src="https://habrastorage.org/webt/tw/n5/ro/twn5ro-lppmqs2rssnne7buoqxo.png"><br><br>  Panggilan ke <code>unit(x)</code> menghasilkan nilai awal <code>v1</code> .  Kemudian <code>bind(v1, f1)</code> menghasilkan nilai menengah baru <code>v2</code> , yang digunakan dalam panggilan berikutnya untuk <code>bind(v2, f2)</code> .  Proses ini berlanjut sampai hasil akhir diperoleh.  Dengan mendefinisikan berbagai <code>unit</code> dan <code>bind</code> dalam kerangka templat ini, kita dapat menggabungkan berbagai fungsi dalam satu rantai perhitungan.  Perpustakaan Monad ( <i>misalnya, PyMonad atau OSlash - sekitar Terjemahan</i> ) <i>.</i> Biasanya berisi monad yang siap digunakan (pasangan <code>unit</code> dan fungsi <code>bind</code> ) untuk menerapkan komposisi fungsi tertentu. <br><br>  Untuk fungsi rantai, nilai yang dikembalikan oleh <code>unit</code> dan <code>bind</code> harus dari jenis yang sama dengan parameter input dari <code>bind</code> .  Tipe ini disebut <b>monadik</b> .  Dalam hal diagram di atas, tipe variabel <code>v1</code> , <code>v2</code> , <code>…</code> , <code>vn</code> harus merupakan tipe monadik. <br><br>  Akhirnya, pertimbangkan bagaimana Anda dapat meningkatkan kode yang ditulis menggunakan monads.  Jelas, panggilan <code>bind</code> berulang-ulang terlihat tidak bagus.  Untuk menghindarinya, tentukan fungsi eksternal lain: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipeline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, *functions)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> functions: e = bind(e, f) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e</code> </pre> <br>  Sekarang sebagai gantinya <br><pre> <code class="python hljs">bind(bind(bind(bind(unit(x), f1), f2), f3), f4)</code> </pre> <br>  kita bisa menggunakan singkatan berikut: <br><pre> <code class="python hljs">pipeline(unit(x), f1, f2, f3, f4)</code> </pre> <br><br><h2>  Kesimpulan </h2><br>  Monads adalah pola desain sederhana dan kuat yang digunakan untuk menyusun fungsi.  Dalam bahasa pemrograman deklaratif, ini membantu untuk mengimplementasikan mekanisme imperatif seperti logging atau input / output.  Dalam bahasa imperatif <br>  ini membantu untuk menggeneralisasi dan mempersingkat kode yang menghubungkan serangkaian panggilan fungsi dengan tipe yang sama. <br><br>  Artikel ini hanya memberikan pemahaman dangkal dan intuitif tentang monad.  Anda dapat mengetahui lebih lanjut dengan menghubungi sumber-sumber berikut: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monads dengan Python (dengan sintaks yang bagus!)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kronologi tutorial Monad</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445800/">https://habr.com/ru/post/id445800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445788/index.html">Surveilans video cloud mandiri: fitur-fitur baru dari Ivideon Web SDK</a></li>
<li><a href="../id445792/index.html">Bagaimana kami mengembangkan dokumentasi dalam proyek Embox yang terbuka</a></li>
<li><a href="../id445794/index.html">Raksasa IT mengungkap solusi penyebaran cloud hybrid hybrid</a></li>
<li><a href="../id445796/index.html">Fintech Digest: Dorsey membayar dengan bitcoin, strategi blockchain Australia, Levi's IPO, walikota Chicago dan bitcoin yang tak terhindarkan</a></li>
<li><a href="../id445798/index.html">Badak di dalam kucing - jalankan firmware di emulator Kopycat</a></li>
<li><a href="../id445802/index.html">5 Hal Tren Internet yang Harus Diketahui Setiap Orang</a></li>
<li><a href="../id445804/index.html">Enkapsulasi untuk samurai asli, atau nuansa yang terkait dengan kata kunci internal di C #</a></li>
<li><a href="../id445806/index.html">Bagaimana kecerdasan buatan mengubah ilmu pengetahuan</a></li>
<li><a href="../id445808/index.html">Kami membenci dan memburu: kehidupan berbahaya seorang cracker virus yang membuat musuh yang kuat</a></li>
<li><a href="../id445814/index.html">Bagaimana robot pengiriman telah mengubah kebiasaan kuliner siswa Amerika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>