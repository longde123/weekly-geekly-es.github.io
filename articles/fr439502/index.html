<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏾 👨🏿‍💼 🚴🏽 Comportement indéfini et vérité non définie ⛱️ 🖕🏾 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le terme «comportement indéfini» dans le langage C et C ++ désigne une situation dans laquelle littéralement «ce qui ne se produit tout simplement pas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comportement indéfini et vérité non définie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/439502/">  Le terme <b>«comportement indéfini»</b> dans le langage C et C ++ désigne une situation dans laquelle littéralement «ce qui ne se produit tout simplement pas».  Historiquement, les cas où les compilateurs précédents pour C (et les architectures sur celui-ci) se comportaient de manière incompatible étaient attribués à un comportement indéfini, et le comité chargé d'élaborer la norme, dans sa sagesse illimitée, a décidé de ne rien décider à ce sujet (c'est-à-dire de ne pas donner de préférence une des implémentations concurrentes).  Les comportements indéfinis étaient également appelés situations possibles dans lesquelles la norme, généralement si exhaustive, ne prescrivait aucun comportement spécifique.  Ce terme a une troisième signification, qui à notre époque devient de plus en plus pertinente: comportement indéfini - c'est l'occasion d'optimisation.  Et les développeurs en C et C ++ <i>adorent les</i> optimisations;  ils demandent instamment aux compilateurs de tout mettre en œuvre pour accélérer le code. <br><br>  <i>Cet article a été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>publié</i></a> pour la première <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>fois</i></a> sur le site Web des services de cryptographie.</i>  <i>La traduction est publiée avec la permission de l'auteur Thomas Pornin.</i> <br><a name="habracut"></a><br>  Voici un exemple classique: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i ++) { dst[i] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)src[i]; } }</code> </pre> <br>  Nous compilerons ce code GCC sur une plate-forme x86 64 bits pour Linux (je travaille sur la dernière version d'Ubuntu 18.04, version GCC - 7.3.0).  Nous <i>activons l'</i> optimisation complète, puis examinons la liste des assembleurs, pour laquelle nous utilisons les clés <i>"-W -Wall -O9 -S</i> " (l'argument " <i>-O9</i> " définit le niveau maximal d'optimisation GCC, qui en pratique équivaut à " <i>-O3</i> ", bien que dans certaines fourches GCC définis et niveaux supérieurs).  On obtient le résultat suivant: <br><br><pre> <code class="cpp hljs"> .file <span class="hljs-string"><span class="hljs-string">"zap.c"</span></span> .text .p2align <span class="hljs-number"><span class="hljs-number">4</span></span>,,<span class="hljs-number"><span class="hljs-number">15</span></span> .globl foo .type foo, @function foo: .LFB0: .<span class="hljs-function"><span class="hljs-function">cfi_startproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movupd</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm0 movupd 16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm1 cvttpd2dq %xmm0, %xmm0 cvttpd2dq %xmm1, %xmm1 punpcklqdq %xmm1, %xmm0 movups %xmm0, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function"> ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ubuntu </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7.3</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-27u</span></span></span></span><span class="hljs-function"><span class="hljs-params">buntu1~</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">18.04</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 7.3.0" .section .note.GNU-</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">stack</span></span></span><span class="hljs-function">,"",@progbits</span></span></code> </pre> <br>  Chacune des deux <i>premières</i> instructions <i>movupd</i> déplace deux valeurs <i>doubles</i> vers le registre SSE2 128 bits (le <i>double</i> a une taille de 64 bits, de sorte que le registre SSE2 peut stocker deux valeurs <i>doubles</i> ).  En d'autres termes, quatre valeurs initiales sont lues en premier, puis elles sont <i>converties</i> en <i>int</i> (opération <i>cvttpd2dq</i> ).  L'opération <i>punpcklqdq</i> déplace les quatre entiers 32 bits reçus dans un registre SSE2 <i>(% xmm0</i> ), dont le contenu est ensuite écrit dans la RAM ( <i>movups</i> ).  Et maintenant l'essentiel: notre programme C nécessite formellement que l'accès à la mémoire se fasse dans l'ordre suivant: <br><br><ul><li>  Lisez la première valeur <i>double</i> de <i>src [0]</i> . </li><li>  Écrivez la première valeur de type <i>int</i> dans <i>dst [0]</i> . </li><li>  Lisez la deuxième valeur <i>double</i> de <i>src [1]</i> . </li><li>  Écrivez la deuxième valeur de type <i>int</i> dans <i>dst [1]</i> . </li><li>  Lisez la troisième valeur <i>double</i> de <i>src [2]</i> . </li><li>  Écrivez la troisième valeur de type <i>int</i> dans <i>dst [2]</i> . </li><li>  Lisez la quatrième valeur <i>double</i> de <i>src [3]</i> . </li><li>  Écrivez la quatrième valeur de type <i>int</i> dans <i>dst [3]</i> . </li></ul><br>  Cependant, toutes ces exigences n'ont de sens que dans le contexte d'une machine abstraite, que la norme C définit;  la procédure sur une machine réelle peut varier.  Le compilateur est libre de réorganiser ou de modifier les opérations, à condition que leur résultat ne contredit pas la sémantique de la machine abstraite (la règle dite <i>as-if</i> est «comme si»).  Dans notre exemple, l'ordre d'action est juste différent: <br><br><ul><li>  Lisez la première valeur <i>double</i> de <i>src [0]</i> . </li><li>  Lisez la deuxième valeur <i>double</i> de <i>src [1]</i> . </li><li>  Lisez la troisième valeur <i>double</i> de <i>src [2]</i> . </li><li>  Lisez la quatrième valeur <i>double</i> de <i>src [3]</i> . </li><li>  Écrivez la première valeur de type <i>int</i> dans <i>dst [0]</i> . </li><li>  Écrivez la deuxième valeur de type <i>int</i> dans <i>dst [1]</i> . </li><li>  Écrivez la troisième valeur de type <i>int</i> dans <i>dst [2]</i> . </li><li>  Écrivez la quatrième valeur de type <i>int</i> dans <i>dst [3]</i> . </li></ul><br>  Il s'agit du langage C: tous les contenus de la mémoire sont finalement des octets (c'est-à-dire des emplacements avec des valeurs de type <i>char non signé</i> , mais en pratique, des groupes de huit bits), et toute opération de pointeur arbitraire est autorisée.  En particulier, les pointeurs <i>src</i> et <i>dst</i> peuvent être utilisés pour accéder à des parties de mémoire qui se chevauchent lors de l'appel (cette situation est appelée «aliasing»).  Ainsi, l'ordre de lecture et d'écriture peut être important si des octets sont écrits puis relus.  Pour que le comportement réel du programme corresponde à l'abstrait défini par la norme C, le compilateur devrait alterner entre les opérations de lecture et d'écriture, fournissant un cycle complet d'accès à la mémoire à chaque itération.  Le code résultant serait plus grand et fonctionnerait beaucoup plus lentement.  Pour les développeurs C, ce serait un chagrin. <br><br>  Ici, heureusement, <i>un comportement indéfini</i> vient à la rescousse.  La norme C indique que les valeurs ne sont pas accessibles via des pointeurs dont le type ne correspond pas aux types actuels de ces valeurs.  Autrement dit, si la valeur est écrite dans <i>dst [0]</i> , où <i>dst est</i> un pointeur <i>int</i> , alors les octets correspondants ne peuvent pas être lus via <i>src [1]</i> , où <i>src</i> est un <i>double</i> pointeur, car dans ce cas, nous essayons d'accéder valeur, qui est maintenant de type <i>int</i> , en utilisant un pointeur d'un type incompatible.  Dans ce cas, un comportement indéfini se produirait.  Cela est indiqué au paragraphe 7 de la section 6.5 de la norme ISO 9899: 1999 («C99») (dans la nouvelle édition 9899: 2018 ou «C17», le libellé n'a pas changé).  Cette exigence est appelée la règle d'alias stricte.  Par conséquent, le compilateur C est autorisé à agir sur l'hypothèse que les opérations d'accès à la mémoire conduisant à un comportement indéfini en raison de la violation de la règle d'alias stricte ne se produisent pas.  Ainsi, le compilateur peut réorganiser les opérations de lecture et d'écriture dans n'importe quel ordre, car elles ne doivent pas accéder aux parties de mémoire qui se chevauchent.  C'est à cela que sert l'optimisation du code. <br><br>  En bref, la signification d'un comportement indéfini est la suivante: le compilateur peut supposer qu'il n'y aura pas de comportement indéfini et générer du code basé sur cette hypothèse.  Dans le cas de la règle d'aliasing stricte - à condition que l'aliasing ait lieu, le comportement indéfini permet d'importantes optimisations qui seraient autrement difficiles à implémenter.  De manière générale, chaque instruction dans les procédures de génération de code utilisées par le compilateur a des dépendances limitant l'algorithme de planification des opérations: une instruction ne peut pas être exécutée avant les instructions dont elle dépend, ou après les instructions qui en dépendent.  Dans notre exemple, un comportement non défini élimine les dépendances entre les opérations d'écriture dans <i>dst []</i> et les opérations de lecture «suivantes» de <i>src []</i> : une telle dépendance ne peut exister que dans les cas où un comportement non défini se produit lors de l'accès à la mémoire.  De même, le concept de comportement non défini permet au compilateur de supprimer simplement le code qui ne peut pas être exécuté sans entrer dans un état de comportement non défini. <br><br>  Tout cela, bien sûr, est bon, mais un tel comportement est parfois perçu comme une trahison perfide par le compilateur.  Vous pouvez souvent entendre la phrase: "Le compilateur utilise le concept de comportement indéfini comme excuse pour casser mon code."  Supposons que quelqu'un écrive un programme qui additionne des entiers et craint un débordement - rappelez-vous le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cas de Bitcoin</a> .  Il peut penser comme ceci: pour représenter des entiers, le processeur utilise du code supplémentaire, ce qui signifie que si un débordement se produit, cela se produira parce que le résultat sera tronqué à la taille du type, c'est-à-dire  32 bits  Ainsi, le résultat d'un débordement peut être prédit et vérifié par un test. <br><br>  Notre développeur conditionnel écrira ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int add(int x, int y, int *z) { int r = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; r &lt; x) { return 0; } if (x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; r &gt; x) { return 0; } *z = r; return 1; } int main(int argc, char *argv[]) { int x, y, z; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); if (add(x, y, &amp;z)) { printf("%d\n", z); } else { printf("overflow!\n"); } return 0; }</span></span></span></span></code> </pre><br>  Essayons maintenant de compiler ce code en utilisant GCC: <br><br><pre> <code class="cpp hljs">$ gcc -W -Wall -O9 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> overflow!</code> </pre><br>  Ok, ça semble marcher.  Essayez maintenant un autre compilateur, par exemple Clang (j'ai la version 6.0.0): <br><br><pre> <code class="cpp hljs">$ clang -W -Wall -O3 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> <span class="hljs-number"><span class="hljs-number">-794967296</span></span></code> </pre><br>  Quoi? <br><br>  Il s'avère que lorsqu'une opération avec des types entiers signés conduit à un résultat qui ne peut pas être représenté par le type cible, nous entrons sur le territoire d'un comportement indéfini.  Mais le compilateur peut supposer que cela ne se produit pas.  En particulier, en optimisant l'expression <i>x&gt; 0 &amp;&amp; y&gt; 0 &amp;&amp; r &lt;x</i> , le compilateur conclut que puisque les valeurs de <i>x</i> et <i>y sont</i> strictement positives, la troisième vérification ne peut pas être vraie (la somme de deux valeurs ne peut être inférieure à aucune d'entre elles), et vous pouvez ignorer toute cette opération.  En d'autres termes, le débordement étant un comportement indéfini, il «ne peut pas se produire» du point de vue du compilateur et toutes les instructions qui dépendent de cet état peuvent être supprimées.  Le mécanisme de détection des comportements indéfinis a tout simplement disparu. <br><br>  La norme n'a jamais prescrit l'hypothèse que la «sémantique signée» (qui est en fait utilisée dans les opérations du processeur) est utilisée dans les calculs avec des types signés;  cela s'est produit plutôt par tradition - même à l'époque où les compilateurs n'étaient pas assez intelligents pour optimiser le code, en se concentrant sur une plage de valeurs.  Vous pouvez forcer Clang et GCC à appliquer la sémantique d' <i>encapsulation</i> aux types signés à l'aide de l'indicateur <i>-fwrapv</i> (dans Microsoft Visual C, vous pouvez utiliser <i>-d2UndefIntOverflow-,</i> comme décrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Cependant, cette approche n'est pas fiable, le drapeau peut disparaître lorsque le code est transféré vers un autre projet ou vers une autre architecture. <br><br>  Peu de gens savent que les débordements de types de caractères impliquent un comportement indéfini.  Ceci est indiqué au paragraphe 5 de la section 6.5 des normes C99 et C17: <br><br>  <i>Si une exception se produit lors de l'évaluation d'une expression (c'est-à-dire si le résultat n'est pas défini mathématiquement ou se situe en dehors de la plage de valeurs valides d'un type donné), le comportement n'est pas défini.</i> <br><br>  Pour les types non signés, cependant, la sémantique modulaire est garantie.  Le paragraphe 9 de la section 6.2.5 dit ce qui suit: <br><br>  <i>Un débordement ne se produit jamais dans les calculs avec des opérandes non signés, puisqu'un résultat qui ne peut pas être représenté par le type entier non signé résultant est tronqué modulo un nombre qui est un de plus que la valeur maximale représentée par le type résultant.</i> <br><br>  Un autre exemple de comportement non défini dans les opérations avec des types signés est l'opération de division.  Comme tout le monde le sait, le résultat de la division par zéro n'est pas déterminé mathématiquement, par conséquent, selon la norme, cette opération entraîne un comportement indéfini.  Si le diviseur est nul dans l'opération <i>idiv</i> sur le processeur x86, une exception de processeur est levée.  Comme les demandes d'interruption, les exceptions de processeur sont gérées par le système d'exploitation.  Sur les systèmes de type Unix, tels que Linux, l'exception de processeur déclenchée par l'opération <i>idiv</i> est traduite en un signal <i>SIGFPE</i> , qui est envoyé au processus, et se termine par le gestionnaire par défaut (ne soyez pas surpris que «FPE» signifie «exception à virgule flottante» (exception dans opérations en virgule flottante), tandis que <i>idiv</i> fonctionne avec des entiers).  Mais il y a une autre situation qui conduit à un comportement indéfini.  Considérez le code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", x / y); return 0; }  : $ gcc -W -Wall -O testdiv.c $ ./a.out 42 17 2 $ ./a.out -2147483648 -1 zsh: floating point exception (core dumped) ./a.out -2147483648 -1</span></span></span></span></code> </pre> <br>  Et la vérité est: sur cette machine (le même x86 pour Linux), le type <i>int</i> représente une plage de valeurs de -2 147 483 648 à + 2 147 483 647. Si vous divisez -2 147 483 648 par -1, vous devriez obtenir + 2 147 483 648 Mais ce nombre n'est pas dans la plage des valeurs <i>int</i> .  Par conséquent, le comportement n'est pas défini.  Tout peut arriver.  Dans ce cas, le processus est interrompu de force.  Sur un autre système, en particulier avec un petit processeur qui n'a pas d'opération de division, le résultat peut varier.  Dans de telles architectures, la division est effectuée par programme - en utilisant la procédure généralement fournie par le compilateur, et maintenant il peut faire tout ce qui lui plaît avec un comportement indéfini, car c'est ce qu'il est. <br><br>  Je note que <i>SIGFPE</i> peut être obtenu dans les mêmes conditions et avec l'aide de l'opérateur modulo ( <i>%</i> ).  Et en fait: en dessous se trouve la même opération <i>idiv</i> , qui calcule à la fois le quotient et le reste, de sorte que la même exception de processeur est déclenchée.  Fait intéressant, la norme C99 dit que l'expression <i>INT_MIN% -1</i> ne peut pas conduire à un comportement indéfini, car le résultat est défini mathématiquement (zéro) et tombe uniquement dans la plage de valeurs du type cible.  Dans la version C17, le texte du paragraphe 6 de la section 6.5.5 a été modifié, et maintenant ce cas est également pris en compte, ce qui rapproche la norme de la situation réelle sur les plates-formes matérielles courantes. <br><br>  Il existe de nombreuses situations non évidentes qui conduisent également à un comportement indéfini.  Jetez un oeil à ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned short mul(unsigned short x, unsigned short y) { return x * y; } int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", mul(x, y)); return 0; }</span></span></span></span></code> </pre> <br>  Pensez-vous qu'un programme, suivant la norme C, devrait s'imprimer si nous transmettons les facteurs 45 000 et 50 000 à la fonction? <br><br><ul><li>  18 048 </li><li>  2 250 000 000 </li><li>  Dieu sauve la reine! </li></ul><br>  La bonne réponse ... oui, toutes ces réponses!  Vous avez peut-être argumenté comme ceci: comme un <i>court non signé</i> est un type non signé, il devrait prendre en charge le sémantique de wrapper modulo 65 536, car sur un processeur x86, la taille de ce type, en règle générale, est exactement de 16 bits (la norme autorise également une taille plus grande, mais en pratique, il s'agit toujours d'un type 16 bits).  Puisque mathématiquement le produit est 2 250 000 000, il sera tronqué modulo 65 536, ce qui donne une réponse de 18 048. Cependant, en pensant de cette façon, nous oublions l'extension des types entiers.  Selon la norme C (section 6.3.1.1, paragraphe 2), si les opérandes sont d'un type dont la taille est strictement inférieure à la taille de <i>int</i> , et les valeurs de ce type peuvent être représentées par le type <i>int</i> sans perte de bits (et nous avons juste ce cas: sur mon x86 sous Linux a une taille <i>int</i> de 32 bits, et il peut explicitement stocker des valeurs de 0 à 65 535), puis les deux opérandes sont convertis en <i>int</i> et l'opération est déjà effectuée sur les valeurs converties.  A savoir: le produit est calculé comme une valeur de type <i>int,</i> et seulement en revenant de la fonction il est ramené en <i>short non signé</i> (c'est-à-dire, c'est à ce moment que la troncature modulo 65 536 se produit).  Le problème est que mathématiquement le résultat avant la transformation inverse est de 2,250 millions, et cette valeur dépasse la plage de <i>int</i> , qui est un type signé.  En conséquence, nous obtenons un comportement indéfini.  Après cela, tout peut arriver, y compris des accès soudains de patriotisme anglais. <br><br>  Cependant, dans la pratique, avec des compilateurs ordinaires, le résultat est de 18 048, car il n'y a toujours pas d'optimisation qui pourrait tirer parti du comportement indéfini de ce programme particulier (on pourrait imaginer des scénarios plus artificiels où cela causerait vraiment des problèmes). <br><br>  Enfin, un autre exemple, maintenant en C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;array&gt; int main(int argc, char *argv[]) { std::array&lt;char, 16&gt; tmp; int i; if (argc &lt; 2) { return EXIT_FAILURE; } memset(tmp.data(), 0, 16); if (strlen(argv[1]) &lt; 16) { strcpy(tmp.data(), argv[1]); } for (i = 0; i &lt; 17; i ++) { printf(" %02x", tmp[i]); } printf("\n"); }</span></span></span></span></code> </pre> <br>  Ce n'est pas le typique «mauvais horrible <i>strcpy ()</i> !» Pour vous.  En effet, ici la fonction <i>strcpy ()</i> n'est exécutée que si la taille de la chaîne source, y compris le zéro terminal, est suffisamment petite.  De plus, les éléments du tableau sont explicitement initialisés à zéro, donc tous les octets du tableau ont une valeur donnée, indépendamment du fait qu'une grande ou une petite chaîne soit passée à la fonction.  En même temps, la boucle à la fin est incorrecte: elle lit un octet de plus qu'elle ne devrait. <br><br>  Exécutez le code: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O9 testvec.c $ ./a.out foo <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ff ffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> ffffff99 <span class="hljs-number"><span class="hljs-number">07</span></span> ffffffba ff ffffea ffffffd0 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ffffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff97 <span class="hljs-number"><span class="hljs-number">7b</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">1b</span></span> ffffffa1 <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffffd8 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> (...) <span class="hljs-number"><span class="hljs-number">62</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> zsh: <span class="hljs-function"><span class="hljs-function">segmentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(core dumped)</span></span></span><span class="hljs-function"> ./a.out foo ++?</span></span></code> </pre> <br>  Vous pouvez naïvement vous opposer: eh bien, il lit un octet supplémentaire au-delà des limites du tableau;  mais ce n'est pas si effrayant, car sur la pile cet octet est toujours là, il est mappé en mémoire, donc le seul problème ici est le dix-septième élément supplémentaire avec une valeur inconnue.  Le cycle imprimera toujours exactement 17 entiers (au format hexadécimal) et se terminera sans aucune plainte. <br><br>  Mais le compilateur a sa propre opinion à ce sujet.  Il est bien conscient que la dix-septième lecture provoque un comportement indéfini.  Selon sa logique, toute instruction ultérieure est dans les limbes: il n'y a aucune exigence qu'après un comportement indéfini quelque chose devrait exister du tout (formellement, même les instructions précédentes peuvent être attaquées, car le comportement indéfini fonctionne également dans la direction opposée).  Dans notre cas, le compilateur ignorera simplement la vérification de condition dans la boucle, et il tournera pour toujours, ou plutôt, jusqu'à ce qu'il commence à lire en dehors de la mémoire allouée à la pile, après quoi le signal <i>SIGSEGV</i> fonctionnera. <br><br>  C'est drôle, mais si GCC démarre avec des paramètres d'optimisation moins agressifs, il donnera un avertissement: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O1 testvec.c testvec.c: In function <span class="hljs-string"><span class="hljs-string">'int main(int, char**)'</span></span>: testvec.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>: warning: iteration <span class="hljs-number"><span class="hljs-number">16</span></span> invokes undefined behavior [-Waggressive-loop-optimizations] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" %02x"</span></span>, tmp[i]); ~~~~~~^~~~~~~~~~~~~~~~~ testvec.c:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>: note: <span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> loop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">17</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i ++)</span></span></span><span class="hljs-function"> </span></span>{ ~~^~~~</code> </pre> <br>  À <i>-O9,</i> cet avertissement disparaît en quelque sorte.  Le fait est peut-être qu'à des niveaux d'optimisation élevés, le compilateur applique de manière plus agressive le déploiement de la boucle.  Il est possible (mais inexact) qu'il s'agit d'un bogue GCC (dans le sens d'une perte d'avertissement; ainsi, les actions de GCC ne contredisent en aucun cas la norme, car il ne nécessite pas l'émission de «diagnostics» dans cette situation). <br><br>  Conclusion: si vous écrivez du code en C ou C ++, soyez extrêmement prudent et évitez les situations qui conduisent à un comportement indéfini, même quand il semble que «ça va». <br><br>  Les types entiers non signés sont une bonne aide dans les calculs arithmétiques, car ils garantissent une sémantique modulaire (mais vous pouvez toujours rencontrer des problèmes liés à l'extension des types entiers).  Une autre option - pour une raison impopulaire - est de ne pas écrire du tout en C et C ++.  Pour plusieurs raisons, cette solution n'est pas toujours adaptée.  Mais si vous pouvez choisir la langue dans laquelle écrire le programme, c'est-à-dire  lorsque vous venez de démarrer un nouveau projet sur une plate-forme prenant en charge Go, Rust, Java ou d'autres langages, il peut être plus rentable de refuser d'utiliser C comme «langage par défaut».  Le choix des outils, dont un langage de programmation, est toujours un compromis.  Les pièges de C, en particulier le comportement indéfini dans les opérations avec des types signés, entraînent des coûts supplémentaires pour la maintenance ultérieure du code, qui sont souvent sous-estimés. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439502/">https://habr.com/ru/post/fr439502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439490/index.html">Types de référence .NET vs types de valeur. 2e partie</a></li>
<li><a href="../fr439492/index.html">10 conseils pour être un bon leader technologique</a></li>
<li><a href="../fr439496/index.html">Comment la facturation se fait-elle: lorsque le client et le développeur parlent des langues différentes</a></li>
<li><a href="../fr439498/index.html">Sur quel matériel analyser un énorme puits d'informations?</a></li>
<li><a href="../fr439500/index.html">Pourquoi les captchas sont-ils devenus si compliqués</a></li>
<li><a href="../fr439504/index.html">Votre équipe a-t-elle besoin d'un Data Engineer?</a></li>
<li><a href="../fr439506/index.html">9 alternatives à une mauvaise équipe (modèle de conception)</a></li>
<li><a href="../fr439508/index.html">Mitap sur le développement Open Source à Moscou</a></li>
<li><a href="../fr439510/index.html">Système de contrôle distribué hautement chargé d'une centrale nucléaire moderne</a></li>
<li><a href="../fr439512/index.html">L'âge des dinosaures ou la réassurance légalement vérifiée?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>