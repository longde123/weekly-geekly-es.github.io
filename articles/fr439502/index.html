<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèæ üë®üèø‚Äçüíº üö¥üèΩ Comportement ind√©fini et v√©rit√© non d√©finie ‚õ±Ô∏è üñïüèæ üë®üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le terme ¬´comportement ind√©fini¬ª dans le langage C et C ++ d√©signe une situation dans laquelle litt√©ralement ¬´ce qui ne se produit tout simplement pas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comportement ind√©fini et v√©rit√© non d√©finie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/439502/">  Le terme <b>¬´comportement ind√©fini¬ª</b> dans le langage C et C ++ d√©signe une situation dans laquelle litt√©ralement ¬´ce qui ne se produit tout simplement pas¬ª.  Historiquement, les cas o√π les compilateurs pr√©c√©dents pour C (et les architectures sur celui-ci) se comportaient de mani√®re incompatible √©taient attribu√©s √† un comportement ind√©fini, et le comit√© charg√© d'√©laborer la norme, dans sa sagesse illimit√©e, a d√©cid√© de ne rien d√©cider √† ce sujet (c'est-√†-dire de ne pas donner de pr√©f√©rence une des impl√©mentations concurrentes).  Les comportements ind√©finis √©taient √©galement appel√©s situations possibles dans lesquelles la norme, g√©n√©ralement si exhaustive, ne prescrivait aucun comportement sp√©cifique.  Ce terme a une troisi√®me signification, qui √† notre √©poque devient de plus en plus pertinente: comportement ind√©fini - c'est l'occasion d'optimisation.  Et les d√©veloppeurs en C et C ++ <i>adorent les</i> optimisations;  ils demandent instamment aux compilateurs de tout mettre en ≈ìuvre pour acc√©l√©rer le code. <br><br>  <i>Cet article a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>publi√©</i></a> pour la premi√®re <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>fois</i></a> sur le site Web des services de cryptographie.</i>  <i>La traduction est publi√©e avec la permission de l'auteur Thomas Pornin.</i> <br><a name="habracut"></a><br>  Voici un exemple classique: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i ++) { dst[i] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)src[i]; } }</code> </pre> <br>  Nous compilerons ce code GCC sur une plate-forme x86 64 bits pour Linux (je travaille sur la derni√®re version d'Ubuntu 18.04, version GCC - 7.3.0).  Nous <i>activons l'</i> optimisation compl√®te, puis examinons la liste des assembleurs, pour laquelle nous utilisons les cl√©s <i>"-W -Wall -O9 -S</i> " (l'argument " <i>-O9</i> " d√©finit le niveau maximal d'optimisation GCC, qui en pratique √©quivaut √† " <i>-O3</i> ", bien que dans certaines fourches GCC d√©finis et niveaux sup√©rieurs).  On obtient le r√©sultat suivant: <br><br><pre> <code class="cpp hljs"> .file <span class="hljs-string"><span class="hljs-string">"zap.c"</span></span> .text .p2align <span class="hljs-number"><span class="hljs-number">4</span></span>,,<span class="hljs-number"><span class="hljs-number">15</span></span> .globl foo .type foo, @function foo: .LFB0: .<span class="hljs-function"><span class="hljs-function">cfi_startproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movupd</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm0 movupd 16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm1 cvttpd2dq %xmm0, %xmm0 cvttpd2dq %xmm1, %xmm1 punpcklqdq %xmm1, %xmm0 movups %xmm0, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function"> ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ubuntu </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7.3</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-27u</span></span></span></span><span class="hljs-function"><span class="hljs-params">buntu1~</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">18.04</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 7.3.0" .section .note.GNU-</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">stack</span></span></span><span class="hljs-function">,"",@progbits</span></span></code> </pre> <br>  Chacune des deux <i>premi√®res</i> instructions <i>movupd</i> d√©place deux valeurs <i>doubles</i> vers le registre SSE2 128 bits (le <i>double</i> a une taille de 64 bits, de sorte que le registre SSE2 peut stocker deux valeurs <i>doubles</i> ).  En d'autres termes, quatre valeurs initiales sont lues en premier, puis elles sont <i>converties</i> en <i>int</i> (op√©ration <i>cvttpd2dq</i> ).  L'op√©ration <i>punpcklqdq</i> d√©place les quatre entiers 32 bits re√ßus dans un registre SSE2 <i>(% xmm0</i> ), dont le contenu est ensuite √©crit dans la RAM ( <i>movups</i> ).  Et maintenant l'essentiel: notre programme C n√©cessite formellement que l'acc√®s √† la m√©moire se fasse dans l'ordre suivant: <br><br><ul><li>  Lisez la premi√®re valeur <i>double</i> de <i>src [0]</i> . </li><li>  √âcrivez la premi√®re valeur de type <i>int</i> dans <i>dst [0]</i> . </li><li>  Lisez la deuxi√®me valeur <i>double</i> de <i>src [1]</i> . </li><li>  √âcrivez la deuxi√®me valeur de type <i>int</i> dans <i>dst [1]</i> . </li><li>  Lisez la troisi√®me valeur <i>double</i> de <i>src [2]</i> . </li><li>  √âcrivez la troisi√®me valeur de type <i>int</i> dans <i>dst [2]</i> . </li><li>  Lisez la quatri√®me valeur <i>double</i> de <i>src [3]</i> . </li><li>  √âcrivez la quatri√®me valeur de type <i>int</i> dans <i>dst [3]</i> . </li></ul><br>  Cependant, toutes ces exigences n'ont de sens que dans le contexte d'une machine abstraite, que la norme C d√©finit;  la proc√©dure sur une machine r√©elle peut varier.  Le compilateur est libre de r√©organiser ou de modifier les op√©rations, √† condition que leur r√©sultat ne contredit pas la s√©mantique de la machine abstraite (la r√®gle dite <i>as-if</i> est ¬´comme si¬ª).  Dans notre exemple, l'ordre d'action est juste diff√©rent: <br><br><ul><li>  Lisez la premi√®re valeur <i>double</i> de <i>src [0]</i> . </li><li>  Lisez la deuxi√®me valeur <i>double</i> de <i>src [1]</i> . </li><li>  Lisez la troisi√®me valeur <i>double</i> de <i>src [2]</i> . </li><li>  Lisez la quatri√®me valeur <i>double</i> de <i>src [3]</i> . </li><li>  √âcrivez la premi√®re valeur de type <i>int</i> dans <i>dst [0]</i> . </li><li>  √âcrivez la deuxi√®me valeur de type <i>int</i> dans <i>dst [1]</i> . </li><li>  √âcrivez la troisi√®me valeur de type <i>int</i> dans <i>dst [2]</i> . </li><li>  √âcrivez la quatri√®me valeur de type <i>int</i> dans <i>dst [3]</i> . </li></ul><br>  Il s'agit du langage C: tous les contenus de la m√©moire sont finalement des octets (c'est-√†-dire des emplacements avec des valeurs de type <i>char non sign√©</i> , mais en pratique, des groupes de huit bits), et toute op√©ration de pointeur arbitraire est autoris√©e.  En particulier, les pointeurs <i>src</i> et <i>dst</i> peuvent √™tre utilis√©s pour acc√©der √† des parties de m√©moire qui se chevauchent lors de l'appel (cette situation est appel√©e ¬´aliasing¬ª).  Ainsi, l'ordre de lecture et d'√©criture peut √™tre important si des octets sont √©crits puis relus.  Pour que le comportement r√©el du programme corresponde √† l'abstrait d√©fini par la norme C, le compilateur devrait alterner entre les op√©rations de lecture et d'√©criture, fournissant un cycle complet d'acc√®s √† la m√©moire √† chaque it√©ration.  Le code r√©sultant serait plus grand et fonctionnerait beaucoup plus lentement.  Pour les d√©veloppeurs C, ce serait un chagrin. <br><br>  Ici, heureusement, <i>un comportement ind√©fini</i> vient √† la rescousse.  La norme C indique que les valeurs ne sont pas accessibles via des pointeurs dont le type ne correspond pas aux types actuels de ces valeurs.  Autrement dit, si la valeur est √©crite dans <i>dst [0]</i> , o√π <i>dst est</i> un pointeur <i>int</i> , alors les octets correspondants ne peuvent pas √™tre lus via <i>src [1]</i> , o√π <i>src</i> est un <i>double</i> pointeur, car dans ce cas, nous essayons d'acc√©der valeur, qui est maintenant de type <i>int</i> , en utilisant un pointeur d'un type incompatible.  Dans ce cas, un comportement ind√©fini se produirait.  Cela est indiqu√© au paragraphe 7 de la section 6.5 de la norme ISO 9899: 1999 (¬´C99¬ª) (dans la nouvelle √©dition 9899: 2018 ou ¬´C17¬ª, le libell√© n'a pas chang√©).  Cette exigence est appel√©e la r√®gle d'alias stricte.  Par cons√©quent, le compilateur C est autoris√© √† agir sur l'hypoth√®se que les op√©rations d'acc√®s √† la m√©moire conduisant √† un comportement ind√©fini en raison de la violation de la r√®gle d'alias stricte ne se produisent pas.  Ainsi, le compilateur peut r√©organiser les op√©rations de lecture et d'√©criture dans n'importe quel ordre, car elles ne doivent pas acc√©der aux parties de m√©moire qui se chevauchent.  C'est √† cela que sert l'optimisation du code. <br><br>  En bref, la signification d'un comportement ind√©fini est la suivante: le compilateur peut supposer qu'il n'y aura pas de comportement ind√©fini et g√©n√©rer du code bas√© sur cette hypoth√®se.  Dans le cas de la r√®gle d'aliasing stricte - √† condition que l'aliasing ait lieu, le comportement ind√©fini permet d'importantes optimisations qui seraient autrement difficiles √† impl√©menter.  De mani√®re g√©n√©rale, chaque instruction dans les proc√©dures de g√©n√©ration de code utilis√©es par le compilateur a des d√©pendances limitant l'algorithme de planification des op√©rations: une instruction ne peut pas √™tre ex√©cut√©e avant les instructions dont elle d√©pend, ou apr√®s les instructions qui en d√©pendent.  Dans notre exemple, un comportement non d√©fini √©limine les d√©pendances entre les op√©rations d'√©criture dans <i>dst []</i> et les op√©rations de lecture ¬´suivantes¬ª de <i>src []</i> : une telle d√©pendance ne peut exister que dans les cas o√π un comportement non d√©fini se produit lors de l'acc√®s √† la m√©moire.  De m√™me, le concept de comportement non d√©fini permet au compilateur de supprimer simplement le code qui ne peut pas √™tre ex√©cut√© sans entrer dans un √©tat de comportement non d√©fini. <br><br>  Tout cela, bien s√ªr, est bon, mais un tel comportement est parfois per√ßu comme une trahison perfide par le compilateur.  Vous pouvez souvent entendre la phrase: "Le compilateur utilise le concept de comportement ind√©fini comme excuse pour casser mon code."  Supposons que quelqu'un √©crive un programme qui additionne des entiers et craint un d√©bordement - rappelez-vous le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cas de Bitcoin</a> .  Il peut penser comme ceci: pour repr√©senter des entiers, le processeur utilise du code suppl√©mentaire, ce qui signifie que si un d√©bordement se produit, cela se produira parce que le r√©sultat sera tronqu√© √† la taille du type, c'est-√†-dire  32 bits  Ainsi, le r√©sultat d'un d√©bordement peut √™tre pr√©dit et v√©rifi√© par un test. <br><br>  Notre d√©veloppeur conditionnel √©crira ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int add(int x, int y, int *z) { int r = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; r &lt; x) { return 0; } if (x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; r &gt; x) { return 0; } *z = r; return 1; } int main(int argc, char *argv[]) { int x, y, z; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); if (add(x, y, &amp;z)) { printf("%d\n", z); } else { printf("overflow!\n"); } return 0; }</span></span></span></span></code> </pre><br>  Essayons maintenant de compiler ce code en utilisant GCC: <br><br><pre> <code class="cpp hljs">$ gcc -W -Wall -O9 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> overflow!</code> </pre><br>  Ok, √ßa semble marcher.  Essayez maintenant un autre compilateur, par exemple Clang (j'ai la version 6.0.0): <br><br><pre> <code class="cpp hljs">$ clang -W -Wall -O3 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> <span class="hljs-number"><span class="hljs-number">-794967296</span></span></code> </pre><br>  Quoi? <br><br>  Il s'av√®re que lorsqu'une op√©ration avec des types entiers sign√©s conduit √† un r√©sultat qui ne peut pas √™tre repr√©sent√© par le type cible, nous entrons sur le territoire d'un comportement ind√©fini.  Mais le compilateur peut supposer que cela ne se produit pas.  En particulier, en optimisant l'expression <i>x&gt; 0 &amp;&amp; y&gt; 0 &amp;&amp; r &lt;x</i> , le compilateur conclut que puisque les valeurs de <i>x</i> et <i>y sont</i> strictement positives, la troisi√®me v√©rification ne peut pas √™tre vraie (la somme de deux valeurs ne peut √™tre inf√©rieure √† aucune d'entre elles), et vous pouvez ignorer toute cette op√©ration.  En d'autres termes, le d√©bordement √©tant un comportement ind√©fini, il ¬´ne peut pas se produire¬ª du point de vue du compilateur et toutes les instructions qui d√©pendent de cet √©tat peuvent √™tre supprim√©es.  Le m√©canisme de d√©tection des comportements ind√©finis a tout simplement disparu. <br><br>  La norme n'a jamais prescrit l'hypoth√®se que la ¬´s√©mantique sign√©e¬ª (qui est en fait utilis√©e dans les op√©rations du processeur) est utilis√©e dans les calculs avec des types sign√©s;  cela s'est produit plut√¥t par tradition - m√™me √† l'√©poque o√π les compilateurs n'√©taient pas assez intelligents pour optimiser le code, en se concentrant sur une plage de valeurs.  Vous pouvez forcer Clang et GCC √† appliquer la s√©mantique d' <i>encapsulation</i> aux types sign√©s √† l'aide de l'indicateur <i>-fwrapv</i> (dans Microsoft Visual C, vous pouvez utiliser <i>-d2UndefIntOverflow-,</i> comme d√©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Cependant, cette approche n'est pas fiable, le drapeau peut dispara√Ætre lorsque le code est transf√©r√© vers un autre projet ou vers une autre architecture. <br><br>  Peu de gens savent que les d√©bordements de types de caract√®res impliquent un comportement ind√©fini.  Ceci est indiqu√© au paragraphe 5 de la section 6.5 des normes C99 et C17: <br><br>  <i>Si une exception se produit lors de l'√©valuation d'une expression (c'est-√†-dire si le r√©sultat n'est pas d√©fini math√©matiquement ou se situe en dehors de la plage de valeurs valides d'un type donn√©), le comportement n'est pas d√©fini.</i> <br><br>  Pour les types non sign√©s, cependant, la s√©mantique modulaire est garantie.  Le paragraphe 9 de la section 6.2.5 dit ce qui suit: <br><br>  <i>Un d√©bordement ne se produit jamais dans les calculs avec des op√©randes non sign√©s, puisqu'un r√©sultat qui ne peut pas √™tre repr√©sent√© par le type entier non sign√© r√©sultant est tronqu√© modulo un nombre qui est un de plus que la valeur maximale repr√©sent√©e par le type r√©sultant.</i> <br><br>  Un autre exemple de comportement non d√©fini dans les op√©rations avec des types sign√©s est l'op√©ration de division.  Comme tout le monde le sait, le r√©sultat de la division par z√©ro n'est pas d√©termin√© math√©matiquement, par cons√©quent, selon la norme, cette op√©ration entra√Æne un comportement ind√©fini.  Si le diviseur est nul dans l'op√©ration <i>idiv</i> sur le processeur x86, une exception de processeur est lev√©e.  Comme les demandes d'interruption, les exceptions de processeur sont g√©r√©es par le syst√®me d'exploitation.  Sur les syst√®mes de type Unix, tels que Linux, l'exception de processeur d√©clench√©e par l'op√©ration <i>idiv</i> est traduite en un signal <i>SIGFPE</i> , qui est envoy√© au processus, et se termine par le gestionnaire par d√©faut (ne soyez pas surpris que ¬´FPE¬ª signifie ¬´exception √† virgule flottante¬ª (exception dans op√©rations en virgule flottante), tandis que <i>idiv</i> fonctionne avec des entiers).  Mais il y a une autre situation qui conduit √† un comportement ind√©fini.  Consid√©rez le code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", x / y); return 0; }  : $ gcc -W -Wall -O testdiv.c $ ./a.out 42 17 2 $ ./a.out -2147483648 -1 zsh: floating point exception (core dumped) ./a.out -2147483648 -1</span></span></span></span></code> </pre> <br>  Et la v√©rit√© est: sur cette machine (le m√™me x86 pour Linux), le type <i>int</i> repr√©sente une plage de valeurs de -2 147 483 648 √† + 2 147 483 647. Si vous divisez -2 147 483 648 par -1, vous devriez obtenir + 2 147 483 648 Mais ce nombre n'est pas dans la plage des valeurs <i>int</i> .  Par cons√©quent, le comportement n'est pas d√©fini.  Tout peut arriver.  Dans ce cas, le processus est interrompu de force.  Sur un autre syst√®me, en particulier avec un petit processeur qui n'a pas d'op√©ration de division, le r√©sultat peut varier.  Dans de telles architectures, la division est effectu√©e par programme - en utilisant la proc√©dure g√©n√©ralement fournie par le compilateur, et maintenant il peut faire tout ce qui lui pla√Æt avec un comportement ind√©fini, car c'est ce qu'il est. <br><br>  Je note que <i>SIGFPE</i> peut √™tre obtenu dans les m√™mes conditions et avec l'aide de l'op√©rateur modulo ( <i>%</i> ).  Et en fait: en dessous se trouve la m√™me op√©ration <i>idiv</i> , qui calcule √† la fois le quotient et le reste, de sorte que la m√™me exception de processeur est d√©clench√©e.  Fait int√©ressant, la norme C99 dit que l'expression <i>INT_MIN% -1</i> ne peut pas conduire √† un comportement ind√©fini, car le r√©sultat est d√©fini math√©matiquement (z√©ro) et tombe uniquement dans la plage de valeurs du type cible.  Dans la version C17, le texte du paragraphe 6 de la section 6.5.5 a √©t√© modifi√©, et maintenant ce cas est √©galement pris en compte, ce qui rapproche la norme de la situation r√©elle sur les plates-formes mat√©rielles courantes. <br><br>  Il existe de nombreuses situations non √©videntes qui conduisent √©galement √† un comportement ind√©fini.  Jetez un oeil √† ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned short mul(unsigned short x, unsigned short y) { return x * y; } int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", mul(x, y)); return 0; }</span></span></span></span></code> </pre> <br>  Pensez-vous qu'un programme, suivant la norme C, devrait s'imprimer si nous transmettons les facteurs 45 000 et 50 000 √† la fonction? <br><br><ul><li>  18 048 </li><li>  2 250 000 000 </li><li>  Dieu sauve la reine! </li></ul><br>  La bonne r√©ponse ... oui, toutes ces r√©ponses!  Vous avez peut-√™tre argument√© comme ceci: comme un <i>court non sign√©</i> est un type non sign√©, il devrait prendre en charge le s√©mantique de wrapper modulo 65 536, car sur un processeur x86, la taille de ce type, en r√®gle g√©n√©rale, est exactement de 16 bits (la norme autorise √©galement une taille plus grande, mais en pratique, il s'agit toujours d'un type 16 bits).  Puisque math√©matiquement le produit est 2 250 000 000, il sera tronqu√© modulo 65 536, ce qui donne une r√©ponse de 18 048. Cependant, en pensant de cette fa√ßon, nous oublions l'extension des types entiers.  Selon la norme C (section 6.3.1.1, paragraphe 2), si les op√©randes sont d'un type dont la taille est strictement inf√©rieure √† la taille de <i>int</i> , et les valeurs de ce type peuvent √™tre repr√©sent√©es par le type <i>int</i> sans perte de bits (et nous avons juste ce cas: sur mon x86 sous Linux a une taille <i>int</i> de 32 bits, et il peut explicitement stocker des valeurs de 0 √† 65 535), puis les deux op√©randes sont convertis en <i>int</i> et l'op√©ration est d√©j√† effectu√©e sur les valeurs converties.  A savoir: le produit est calcul√© comme une valeur de type <i>int,</i> et seulement en revenant de la fonction il est ramen√© en <i>short non sign√©</i> (c'est-√†-dire, c'est √† ce moment que la troncature modulo 65 536 se produit).  Le probl√®me est que math√©matiquement le r√©sultat avant la transformation inverse est de 2,250 millions, et cette valeur d√©passe la plage de <i>int</i> , qui est un type sign√©.  En cons√©quence, nous obtenons un comportement ind√©fini.  Apr√®s cela, tout peut arriver, y compris des acc√®s soudains de patriotisme anglais. <br><br>  Cependant, dans la pratique, avec des compilateurs ordinaires, le r√©sultat est de 18 048, car il n'y a toujours pas d'optimisation qui pourrait tirer parti du comportement ind√©fini de ce programme particulier (on pourrait imaginer des sc√©narios plus artificiels o√π cela causerait vraiment des probl√®mes). <br><br>  Enfin, un autre exemple, maintenant en C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;array&gt; int main(int argc, char *argv[]) { std::array&lt;char, 16&gt; tmp; int i; if (argc &lt; 2) { return EXIT_FAILURE; } memset(tmp.data(), 0, 16); if (strlen(argv[1]) &lt; 16) { strcpy(tmp.data(), argv[1]); } for (i = 0; i &lt; 17; i ++) { printf(" %02x", tmp[i]); } printf("\n"); }</span></span></span></span></code> </pre> <br>  Ce n'est pas le typique ¬´mauvais horrible <i>strcpy ()</i> !¬ª Pour vous.  En effet, ici la fonction <i>strcpy ()</i> n'est ex√©cut√©e que si la taille de la cha√Æne source, y compris le z√©ro terminal, est suffisamment petite.  De plus, les √©l√©ments du tableau sont explicitement initialis√©s √† z√©ro, donc tous les octets du tableau ont une valeur donn√©e, ind√©pendamment du fait qu'une grande ou une petite cha√Æne soit pass√©e √† la fonction.  En m√™me temps, la boucle √† la fin est incorrecte: elle lit un octet de plus qu'elle ne devrait. <br><br>  Ex√©cutez le code: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O9 testvec.c $ ./a.out foo <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ff ffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> ffffff99 <span class="hljs-number"><span class="hljs-number">07</span></span> ffffffba ff ffffea ffffffd0 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ffffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff97 <span class="hljs-number"><span class="hljs-number">7b</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">1b</span></span> ffffffa1 <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffffd8 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> (...) <span class="hljs-number"><span class="hljs-number">62</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> zsh: <span class="hljs-function"><span class="hljs-function">segmentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(core dumped)</span></span></span><span class="hljs-function"> ./a.out foo ++?</span></span></code> </pre> <br>  Vous pouvez na√Øvement vous opposer: eh bien, il lit un octet suppl√©mentaire au-del√† des limites du tableau;  mais ce n'est pas si effrayant, car sur la pile cet octet est toujours l√†, il est mapp√© en m√©moire, donc le seul probl√®me ici est le dix-septi√®me √©l√©ment suppl√©mentaire avec une valeur inconnue.  Le cycle imprimera toujours exactement 17 entiers (au format hexad√©cimal) et se terminera sans aucune plainte. <br><br>  Mais le compilateur a sa propre opinion √† ce sujet.  Il est bien conscient que la dix-septi√®me lecture provoque un comportement ind√©fini.  Selon sa logique, toute instruction ult√©rieure est dans les limbes: il n'y a aucune exigence qu'apr√®s un comportement ind√©fini quelque chose devrait exister du tout (formellement, m√™me les instructions pr√©c√©dentes peuvent √™tre attaqu√©es, car le comportement ind√©fini fonctionne √©galement dans la direction oppos√©e).  Dans notre cas, le compilateur ignorera simplement la v√©rification de condition dans la boucle, et il tournera pour toujours, ou plut√¥t, jusqu'√† ce qu'il commence √† lire en dehors de la m√©moire allou√©e √† la pile, apr√®s quoi le signal <i>SIGSEGV</i> fonctionnera. <br><br>  C'est dr√¥le, mais si GCC d√©marre avec des param√®tres d'optimisation moins agressifs, il donnera un avertissement: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O1 testvec.c testvec.c: In function <span class="hljs-string"><span class="hljs-string">'int main(int, char**)'</span></span>: testvec.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>: warning: iteration <span class="hljs-number"><span class="hljs-number">16</span></span> invokes undefined behavior [-Waggressive-loop-optimizations] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" %02x"</span></span>, tmp[i]); ~~~~~~^~~~~~~~~~~~~~~~~ testvec.c:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>: note: <span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> loop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">17</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i ++)</span></span></span><span class="hljs-function"> </span></span>{ ~~^~~~</code> </pre> <br>  √Ä <i>-O9,</i> cet avertissement dispara√Æt en quelque sorte.  Le fait est peut-√™tre qu'√† des niveaux d'optimisation √©lev√©s, le compilateur applique de mani√®re plus agressive le d√©ploiement de la boucle.  Il est possible (mais inexact) qu'il s'agit d'un bogue GCC (dans le sens d'une perte d'avertissement; ainsi, les actions de GCC ne contredisent en aucun cas la norme, car il ne n√©cessite pas l'√©mission de ¬´diagnostics¬ª dans cette situation). <br><br>  Conclusion: si vous √©crivez du code en C ou C ++, soyez extr√™mement prudent et √©vitez les situations qui conduisent √† un comportement ind√©fini, m√™me quand il semble que ¬´√ßa va¬ª. <br><br>  Les types entiers non sign√©s sont une bonne aide dans les calculs arithm√©tiques, car ils garantissent une s√©mantique modulaire (mais vous pouvez toujours rencontrer des probl√®mes li√©s √† l'extension des types entiers).  Une autre option - pour une raison impopulaire - est de ne pas √©crire du tout en C et C ++.  Pour plusieurs raisons, cette solution n'est pas toujours adapt√©e.  Mais si vous pouvez choisir la langue dans laquelle √©crire le programme, c'est-√†-dire  lorsque vous venez de d√©marrer un nouveau projet sur une plate-forme prenant en charge Go, Rust, Java ou d'autres langages, il peut √™tre plus rentable de refuser d'utiliser C comme ¬´langage par d√©faut¬ª.  Le choix des outils, dont un langage de programmation, est toujours un compromis.  Les pi√®ges de C, en particulier le comportement ind√©fini dans les op√©rations avec des types sign√©s, entra√Ænent des co√ªts suppl√©mentaires pour la maintenance ult√©rieure du code, qui sont souvent sous-estim√©s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439502/">https://habr.com/ru/post/fr439502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439490/index.html">Types de r√©f√©rence .NET vs types de valeur. 2e partie</a></li>
<li><a href="../fr439492/index.html">10 conseils pour √™tre un bon leader technologique</a></li>
<li><a href="../fr439496/index.html">Comment la facturation se fait-elle: lorsque le client et le d√©veloppeur parlent des langues diff√©rentes</a></li>
<li><a href="../fr439498/index.html">Sur quel mat√©riel analyser un √©norme puits d'informations?</a></li>
<li><a href="../fr439500/index.html">Pourquoi les captchas sont-ils devenus si compliqu√©s</a></li>
<li><a href="../fr439504/index.html">Votre √©quipe a-t-elle besoin d'un Data Engineer?</a></li>
<li><a href="../fr439506/index.html">9 alternatives √† une mauvaise √©quipe (mod√®le de conception)</a></li>
<li><a href="../fr439508/index.html">Mitap sur le d√©veloppement Open Source √† Moscou</a></li>
<li><a href="../fr439510/index.html">Syst√®me de contr√¥le distribu√© hautement charg√© d'une centrale nucl√©aire moderne</a></li>
<li><a href="../fr439512/index.html">L'√¢ge des dinosaures ou la r√©assurance l√©galement v√©rifi√©e?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>