<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔘 🧘🏼 👈🏼 Sudut tanpa zone.js: kinerja maksimum 📚 🌨️ 👩🏾‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengembang sudut berutang banyak ke zone.js. Dia, misalnya, membantu mencapai kemudahan yang hampir ajaib dalam bekerja dengan Angular. Bahkan, hampir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sudut tanpa zone.js: kinerja maksimum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/476956/">  Pengembang sudut berutang banyak ke zone.js.  Dia, misalnya, membantu mencapai kemudahan yang hampir ajaib dalam bekerja dengan Angular.  Bahkan, hampir selalu, ketika Anda hanya perlu mengubah beberapa properti, dan kami mengubahnya tanpa memikirkan apa pun, Angular merender ulang komponen yang sesuai.  Akibatnya, apa yang dilihat pengguna selalu berisi informasi terbaru.  Ini bagus sekali. <br><br>  Di sini saya ingin mengeksplorasi beberapa aspek tentang bagaimana penggunaan kompiler Ivy baru (yang muncul di Angular 9) dapat sangat membantu penolakan penggunaan zone.js. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/476956/"><img src="https://habrastorage.org/webt/9m/ql/xa/9mqlxapag9joinziuleg8frnslm.jpeg"></a> <br><br>  Dengan meninggalkan perpustakaan ini, saya dapat secara signifikan meningkatkan kinerja aplikasi Angular yang berjalan di bawah beban berat.  Pada saat yang sama, saya berhasil menerapkan mekanisme yang saya butuhkan menggunakan dekorator TypeScript, yang menyebabkan biaya tambahan yang sangat kecil dari sumber daya sistem. <br><br>  Harap dicatat bahwa pendekatan untuk mengoptimalkan aplikasi Angular, yang disajikan dalam artikel ini, hanya dimungkinkan karena Angular Ivy dan AOT diaktifkan secara default.  Artikel ini ditulis untuk tujuan pendidikan, tidak bertujuan mempromosikan pendekatan yang disajikan di dalamnya untuk pengembangan proyek Angular. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mengapa Anda perlu menggunakan Angular tanpa zone.js?</font> </h2><br>  Sebelum kita melanjutkan, mari kita ajukan satu pertanyaan penting: "Apakah layak menyingkirkan zone.js, mengingat perpustakaan ini membantu kita membuat kembali templat dengan sedikit usaha?"  Tentu saja perpustakaan ini sangat bermanfaat.  Tetapi, seperti biasa, Anda harus membayar semuanya. <br><br>  Jika aplikasi Anda memiliki persyaratan kinerja tertentu, menonaktifkan zone.js dapat membantu memenuhi persyaratan itu.  Contoh aplikasi di mana kinerja sangat penting adalah proyek yang antarmuka-nya sering diperbarui.  Dalam kasus saya, proyek semacam itu ternyata merupakan aplikasi perdagangan waktu-nyata.  Bagian kliennya secara konstan menerima pesan melalui protokol WebSocket.  Data dari pesan-pesan ini harus ditampilkan secepat mungkin. <br><br><h2>  <font color="#3AC1EF">Hapus zone.js dari Angular</font> </h2><br>  Sudut dapat dengan mudah dibuat untuk bekerja tanpa zone.js.  Untuk melakukan ini, Anda harus terlebih dahulu mengomentari atau menghapus perintah impor yang sesuai, yang terletak di file <code>polyfills.ts</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/f95/17e/7a4f9517eb4898e51240862c08e4faa9.png"></div><br>  <i><font color="#999999">Mengomentari perintah impor zone.js</font></i> <br><br>  Berikutnya - Anda perlu melengkapi modul root dengan opsi berikut: <br><br><pre> <code class="javascript hljs">platformBrowserDynamic()  .bootstrapModule(AppModule, {    <span class="hljs-attr"><span class="hljs-attr">ngZone</span></span>: <span class="hljs-string"><span class="hljs-string">'noop'</span></span>  })  .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br><h2>  <font color="#3AC1EF">Angular Ivy: Perubahan deteksi otomatis dengan ɵdetectChanges dan ɵmarkDirty</font> </h2><br>  Sebelum kita dapat mulai membuat dekorator TypeScript, kita perlu belajar tentang bagaimana Ivy memungkinkan Anda untuk memohon proses mendeteksi perubahan komponen, membuatnya kotor, dan melewati zone.js dan DI. <br><br>  Dua fungsi tambahan sekarang tersedia untuk kami, diekspor dari <code>@angular/core</code> .  Ini adalah <code>ɵdetectChanges</code> dan <code>ɵmarkDirty</code> .  Kedua fungsi ini masih ditujukan untuk penggunaan internal dan tidak stabil - simbol <code>ɵ</code> terletak di awal nama mereka. <br><br>  Mari kita lihat cara menggunakan fitur-fitur ini. <br><br><h3>  <font color="#3AC1EF">▍ Fungsi ɵmarkDirty</font> </h3><br>  Fungsi ini memungkinkan Anda untuk menandai komponen, membuatnya "kotor," yaitu, perlu dirender ulang.  Dia, jika komponen itu tidak ditandai "kotor" sebelum dipanggil, berencana untuk memulai proses deteksi perubahan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ɵmarkDirty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> markDirty } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    markDirty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ ɵdetectChanges Function</font> </h3><br>  Dokumentasi internal sudut mengatakan bahwa, untuk alasan kinerja, Anda tidak boleh menggunakan <code>ɵdetectChanges</code> .  Sebagai gantinya, disarankan untuk menggunakan fungsi <code>ɵmarkDirty</code> .  Fungsi <code>ɵdetectChanges</code> serempak memanggil proses mendeteksi perubahan dalam suatu komponen dan subkomponennya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ɵdetectChanges <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> detectChanges } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    detectChanges(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h2>  <font color="#3AC1EF">Secara otomatis mendeteksi perubahan menggunakan dekorator TypeScript</font> </h2><br>  Meskipun fungsi-fungsi yang disediakan oleh Angular meningkatkan kegunaan pengembangan dengan membiarkan DI berputar, programmer masih bisa frustrasi oleh kenyataan bahwa ia perlu mengimpor dan memanggil fungsi-fungsi ini sendiri untuk memulai proses deteksi perubahan. <br><br>  Untuk menyederhanakan dimulainya deteksi perubahan, Anda dapat menulis dekorator TypeScript, yang secara mandiri akan memecahkan masalah ini.  Tentu saja, ada beberapa batasan di sini, yang akan kita bahas di bawah ini, tetapi dalam kasus saya pendekatan ini ternyata tepat seperti yang saya butuhkan. <br><br><h3>  <font color="#3AC1EF">▍ Memperkenalkan dekorator yang diobservasi @</font> </h3><br>  Untuk mendeteksi perubahan, berusaha sesedikit mungkin, kami akan membuat dekorator yang dapat diterapkan dalam tiga cara.  Yaitu, itu berlaku untuk entitas berikut: <br><br><ul><li>  Untuk metode sinkron. </li><li>  Benda yang bisa diamati. </li><li>  Untuk benda biasa. </li></ul><br>  Pertimbangkan beberapa contoh kecil.  Dalam fragmen kode berikut, kami menerapkan dekorator <code>@observed</code> ke objek <code>state</code> dan ke metode <code>changeTitle</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">''</span></span>;    @observed() state = {        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>    };    @observed()    changeTitle(title: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    }    changeName(name: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name = name;    } }</code> </pre> <br><ul><li>  Untuk memeriksa perubahan pada objek <code>state</code> , kami menggunakan objek proxy yang memotong perubahan pada objek dan memanggil prosedur untuk mendeteksi perubahan. </li><li>  Kami mengganti metode <code>changeTitle</code> dengan menerapkan fungsi yang pertama kali memanggil metode ini dan kemudian memulai proses deteksi perubahan. </li></ul><br>  Dan berikut ini adalah contoh dengan <code>BehaviorSubject</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{    @observed() show$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);    toggle() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.next(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.value);    } }</code> </pre> <br>  Dalam hal objek yang Dapat Diobservasi, menggunakan dekorator terlihat sedikit lebih rumit.  Yaitu, Anda perlu berlangganan objek yang diamati dan menandai komponen sebagai "kotor" dalam langganan, tetapi Anda juga harus menghapus langganan.  Untuk melakukan ini, kami menetapkan kembali <code>ngOnInit</code> dan <code>ngOnDestroy</code> untuk berlangganan dan membersihkannya nanti. <br><br><h3>  <font color="#3AC1EF">▍Membuat dekorator</font> </h3><br>  Berikut adalah tanda tangan dekorator yang <code>observed</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  </span></span></span><span class="hljs-function">) </span></span>{} }</code> </pre> <br>  Seperti yang Anda lihat, <code>descriptor</code> adalah parameter opsional.  Ini karena kita membutuhkan dekorator untuk diterapkan pada metode dan properti.  Jika parameter ada, ini berarti bahwa dekorator diterapkan ke metode.  Dalam hal ini, kami melakukan ini: <br><br><ul><li>  Simpan properti <code>descriptor.</code>  <code>value</code> . </li><li>  Kami mendefinisikan kembali metode sebagai berikut: panggil fungsi asli, lalu panggil <code>markDirty(this)</code> untuk memulai proses deteksi perubahan.  Begini tampilannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor) {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value; <span class="hljs-comment"><span class="hljs-comment">//     descriptor.value = function(...args: any[]) {    original.apply(this, args); //       markDirty(this);  }; } else {  //   }</span></span></code> </pre> </li></ul><br>  Selanjutnya, Anda perlu memeriksa jenis properti apa yang kami hadapi.  Ini bisa menjadi objek yang bisa diamati atau objek biasa.  Di sini kita akan menggunakan API Angular internal lain.  Saya percaya, ini tidak dimaksudkan untuk digunakan dalam aplikasi reguler (maaf!). <br><br>  Kita berbicara tentang properti <code>ɵcmp</code> , yang memberikan akses ke properti yang diproses oleh Angular setelah didefinisikan.  Kita dapat menggunakannya untuk mengganti metode <code>onDestroy</code> <code>onInit</code> dan <code>onDestroy</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCmp = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> (type).ɵcmp; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cmp = getCmp(target.constructor); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onInit = cmp.onInit || noop; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onDestroy = cmp.onDestroy || noop;</code> </pre> <br>  Untuk menandai properti sebagai yang akan dimonitor, kami menggunakan <code>ReflectMetadata</code> dan menetapkan nilainya menjadi <code>true</code> .  Akibatnya, kita akan tahu bahwa kita perlu mengamati properti ketika komponen diinisialisasi: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, propertyKey, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Sekarang saatnya untuk mengganti pengait <code>onInit</code> dan memeriksa properti ketika membuat instance komponen: <br><br><pre> <code class="javascript hljs">cmp.onInit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  checkComponentProperties(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  onInit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre> <br>  Kami mendefinisikan fungsi <code>checkComponentProperties</code> , yang akan mem-bypass properti komponen, memfilternya sesuai dengan nilai yang ditetapkan sebelumnya menggunakan <code>Reflect.set</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkComponentProperties = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> props = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(ctx);  props.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, prop);  }).filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    checkProperty.call(ctx, propertyKey);  }); };</code> </pre> <br>  Fungsi <code>checkProperty</code> akan bertanggung jawab untuk mendekorasi properti individual.  Pertama, kami memeriksa apakah properti itu objek yang Dapat Diamati atau biasa.  Jika ini adalah objek yang dapat Diobservasi, kami berlangganan dan menambahkan langganan ke daftar langganan yang disimpan dalam komponen untuk kebutuhan internalnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkProperty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name: string</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[name] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Observable) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscriptions = getSubscriptions(ctx);    subscriptions.add(ctx[name].subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {      markDirty(ctx);    }));  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//    } };</span></span></code> </pre> <br>  Jika properti adalah objek biasa, maka kami akan mengonversinya menjadi objek Proxy dan memanggil <code>markDirty</code> dalam fungsi <code>handler</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {  set(obj, prop, value) {    obj[prop] = value;    ɵmarkDirty(ctx);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;  } }; ctx[name] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(ctx, handler);</code> </pre> <br>  Terakhir, Anda perlu menghapus langganan setelah menghancurkan komponen: <br><br><pre> <code class="javascript hljs">cmp.onDestroy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[subscriptionsSymbol]) {    ctx[subscriptionsSymbol].unsubscribe();  }  onDestroy.call(ctx); };</code> </pre> <br>  Kemungkinan dekorator ini tidak dapat disebut komprehensif.  Mereka tidak mencakup semua kemungkinan penggunaan yang mungkin muncul dalam aplikasi besar.  Misalnya, ini adalah panggilan ke fungsi templat yang mengembalikan objek yang dapat diobservasi.  Tapi saya sedang mengusahakannya. <br><br>  Meskipun demikian, dekorator di atas sudah cukup untuk proyek kecil saya.  Anda akan menemukan kode lengkapnya di akhir materi. <br><br><h2>  <font color="#3AC1EF">Analisis hasil percepatan aplikasi</font> </h2><br>  Sekarang kita telah berbicara sedikit tentang mekanisme internal Ivy, dan bagaimana membuat dekorator menggunakan mekanisme ini, saatnya untuk menguji apa yang kita dapatkan dalam aplikasi nyata. <br><br>  Saya, untuk mengetahui pengaruh menyingkirkan zone.js pada kinerja aplikasi Angular, menggunakan proyek hobi <a href="https://github.com/gbuomprisco/cryptofolio">Cryptofolio</a> saya. <br><br>  Saya menerapkan dekorator ke semua tautan yang diperlukan yang digunakan dalam templat dan dinonaktifkan zone.js.  Sebagai contoh, pertimbangkan komponen berikut: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetPricerComponent</span></span></span><span class="hljs-class"> </span></span>{  @observed() price$: Observable&lt;string&gt;;  @observed() trend$: Observable&lt;Trend&gt;;   <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Dua variabel digunakan dalam templat: <code>price</code> (harga aset akan ditempatkan di sini) dan <code>trend</code> (variabel ini dapat mengambil nilai <code>up</code> , <code>stale</code> dan <code>down</code> , menunjukkan arah perubahan harga).  Saya menghiasnya dengan <code>@observed</code> . <br><br><h3>  <font color="#3AC1EF">▍ Ukuran bundel proyek</font> </h3><br>  Untuk memulainya, mari kita lihat seberapa besar ukuran bundel proyek telah berkurang sementara menyingkirkan zone.js.  Di bawah ini adalah hasil dari membangun proyek dengan zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/cb3/7e8/a0bcb37e870dfdcafa1c49a80aeaeb04.png"></div><br>  <i><font color="#999999">Hasil membangun proyek dengan zone.js</font></i> <br><br>  Dan di sini adalah perakitan tanpa zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/6ae/adc/7d56aeadce675e6953e5e603b3594c2c.png"></div><br>  <i><font color="#999999">Hasil membangun proyek tanpa zone.js</font></i> <br><br>  Perhatikan <code>polyfills-es2015.xxx.js</code> .  Jika proyek menggunakan zone.js, maka ukurannya sekitar 35 Kb.  Tetapi tanpa zone.js - hanya 130 byte. <br><br><h3>  <font color="#3AC1EF">OotingBooting</font> </h3><br>  Saya meneliti dua opsi aplikasi menggunakan Mercusuar.  Hasil penelitian ini diberikan di bawah ini.  Perlu dicatat bahwa saya tidak akan menganggapnya terlalu serius.  Faktanya adalah ketika mencoba mencari nilai rata-rata, saya mendapat hasil yang sangat berbeda dengan melakukan beberapa pengukuran untuk versi aplikasi yang sama. <br><br>  Mungkin perbedaan dalam mengevaluasi dua opsi aplikasi hanya tergantung pada ukuran bundel. <br><br>  Jadi, inilah hasil yang diperoleh untuk aplikasi yang menggunakan zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfd/922/5f3/dfd9225f368de1f7c3e43d47bddbad16.png"></div><br>  <i><font color="#999999">Hasil analisis untuk aplikasi yang menggunakan zone.js</font></i> <br><br>  Dan inilah yang terjadi setelah menganalisis aplikasi di mana zone.js tidak digunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/684/9ba/f416849ba2f210d1ed48345e607a3d8f.png"></div><br>  <i><font color="#999999">Hasil analisis untuk aplikasi yang tidak menggunakan zone.js</font></i> <br><br><h3>  <font color="#3AC1EF">▍ Kinerja</font> </h3><br>  Dan sekarang kita sampai pada yang paling menarik.  Ini adalah kinerja aplikasi yang berjalan di bawah beban.  Kami ingin mempelajari tentang bagaimana perasaan prosesor ketika aplikasi menampilkan pembaruan harga untuk ratusan aset beberapa kali per detik. <br><br>  Untuk memuat aplikasi, saya membuat 100 entitas yang menyediakan data bersyarat dengan harga yang berubah setiap 250 ms.  Jika harga naik, itu ditampilkan dalam warna hijau.  Jika dikurangi - merah.  Semua ini dengan serius dapat memuat MacBook Pro saya. <br><br>  Perlu dicatat bahwa ketika bekerja di sektor keuangan pada beberapa aplikasi yang dirancang untuk transmisi fragmen data frekuensi tinggi, saya telah menemukan situasi yang sama beberapa kali. <br><br>  Untuk menganalisis perbedaan versi aplikasi menggunakan sumber daya prosesor, saya menggunakan alat pengembang Chrome. <br><br>  Seperti apa tampilan aplikasi yang menggunakan zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/11b/56f/fbf11b56ffe060d5bcdc4680a0ddd347.gif"></div><br>  <i><font color="#999999">Pemuatan sistem dibuat oleh aplikasi yang menggunakan zone.js</font></i> <br><br>  Dan inilah cara aplikasi bekerja di mana zone.js tidak digunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/657/240/8fb65724082e810619f061cb238c76da.gif"></div><br>  <i><font color="#999999">Pemuatan sistem dibuat oleh aplikasi yang tidak menggunakan zone.js</font></i> <br><br>  Kami menganalisis hasil ini, memperhatikan grafik beban prosesor (kuning): <br><br><ul><li>  Seperti yang Anda lihat, aplikasi yang menggunakan zone.js terus-menerus memuat prosesor hingga 70-100%!  Jika Anda menahan tab browser terbuka untuk waktu yang lama, membuat beban seperti itu pada sistem, maka aplikasi yang berjalan di dalamnya mungkin gagal. </li><li>  Dan versi aplikasi di mana zone.js tidak digunakan menciptakan beban yang stabil pada prosesor dalam kisaran 30 hingga 40%.  Hebat! </li></ul><br>  Harap perhatikan bahwa hasil ini diperoleh dengan jendela Alat Pengembang Chrome terbuka, yang juga membuat sistem tegang dan memperlambat aplikasi. <br><br><h3>  <font color="#3AC1EF">▍ peningkatan beban</font> </h3><br>  Saya mencoba memastikan bahwa setiap entitas yang bertanggung jawab untuk memperbarui harga akan mengeluarkan 4 pembaruan lagi setiap detik selain apa yang sudah dihasilkannya. <br><br>  Inilah yang berhasil kami ketahui tentang aplikasi di mana zone.js tidak digunakan: <br><br><ul><li>  Aplikasi ini biasanya diatasi dengan beban, sekarang menggunakan sekitar 50% dari sumber daya prosesor. </li><li>  Dia berhasil memuat prosesor sebanyak aplikasi dengan zone.js, hanya ketika harga diperbarui setiap 10 ms (data baru, seperti sebelumnya, berasal dari 100 entitas). </li></ul><br><h3>  <font color="#3AC1EF">▍ Analisis Kinerja dengan Benchpress Sudut</font> </h3><br>  Analisis kinerja yang saya lakukan di atas tidak dapat disebut sangat ilmiah.  Untuk studi yang lebih serius tentang kinerja berbagai kerangka kerja, saya akan merekomendasikan menggunakan <a href="https://krausest.github.io/js-framework-benchmark/current.html">tolok ukur ini</a> .  Untuk penelitian, Angular harus memilih versi biasa dari kerangka ini dan versinya tanpa zone.js. <br><br>  Saya, terinspirasi oleh beberapa ide tolok ukur ini, menciptakan sebuah <a href="https://github.com/Gbuomprisco/zoneless-angular">proyek</a> yang melakukan perhitungan berat.  Saya menguji kinerjanya dengan <a href="https://github.com/angular/angular/tree/master/packages/benchpress">Angular Benchpress</a> . <br><br>  Berikut adalah kode komponen yang diuji: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{  public data = [];  @observed()  run(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  append(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  removeAll() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();  }  @observed()  remove(item) {    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; i &lt; l; i++) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[i].id === item.id) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>);        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;      }    }  }  trackById(item) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.id;  }  private clear() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = [];  }  private buildData(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = start + length;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = start; n &lt;= end; n++) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.push({        <span class="hljs-attr"><span class="hljs-attr">id</span></span>: n,        <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()      });    }  } }</code> </pre> <br>  Saya meluncurkan satu set tolok ukur kecil menggunakan Protractor dan Benchpress.  Operasi dilakukan beberapa kali. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/167/a7b/5c2167a7bae21093e5e7cdc9f2482361.gif"></div><br>  <i><font color="#999999">Benchpress beraksi</font></i> <br><br><h4>  Hasil </h4><br>  Berikut adalah contoh hasil yang diperoleh dengan menggunakan Benchpress. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5a/467/0f0/f5a4670f0af5b461a1f0fad2d7f982b3.png"></div><br>  <i><font color="#999999">Hasil Benchpress</font></i> <br><br>  Berikut ini penjelasan indikator yang disajikan dalam tabel ini: <br><br><ul><li>  <code>gcAmount</code> : volume operasi gc (pengumpulan sampah), Kb. </li><li>  <code>gcTime</code> : waktu operasi gc, ms. </li><li>  <code>majorGcTime</code> : waktu operasi utama gc, ms. </li><li>  <code>pureScriptTime</code> : waktu eksekusi skrip dalam ms, tidak termasuk operasi gc dan rendering. </li><li>  <code>renderTime</code> : waktu render, ms. </li><li>  <code>scriptTime</code> : waktu pelaksanaan skrip dengan mempertimbangkan operasi dan rendering gc akun. </li></ul><br>  Sekarang kita akan mempertimbangkan analisis kinerja beberapa operasi di berbagai varian aplikasi.  Hijau menunjukkan hasil aplikasi yang menggunakan zone.js, oranye menunjukkan hasil aplikasi tanpa zone.js.  Harap dicatat bahwa hanya waktu rendering dianalisis di sini.  Jika Anda tertarik dengan semua hasil tes, periksa di <a href="https://github.com/Gbuomprisco/zoneless-angular">sini</a> . <br><br><h4>  Uji: membuat 1000 baris </h4><br>  Dalam tes pertama, 1000 baris dibuat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/d48/745/944d48745c79b697bececc092c78c9be.png"></div><br>  <i><font color="#999999">Hasil tes</font></i> <br><br><h4>  Uji: membuat 10.000 baris </h4><br>  Seiring bertambahnya beban pada aplikasi, begitu pula perbedaan dalam kinerjanya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/971/8aa/7e19718aadeec04390f1f4b7fa408f89.png"></div><br>  <i><font color="#999999">Hasil tes</font></i> <br><br><h4>  Uji: gabung 1000 baris </h4><br>  Dalam tes ini, 1000 baris ditambahkan ke 10.000 baris. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/682/d30/3f3682d3064b9158ef95146426d2638b.png"></div><br>  <i><font color="#999999">Hasil tes</font></i> <br><br><h4>  Uji: menghapus 10.000 baris </h4><br>  Di sini, 10.000 baris dibuat, yang kemudian dihapus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f85/d5d/bb7/f85d5dbb78b094bd9bb9afccbce148e3.png"></div><br>  <i><font color="#999999">Hasil tes</font></i> <br><br><h2>  <font color="#3AC1EF">Kode Sumber Dekorator TypeScript</font> </h2><br>  Di bawah ini adalah kode sumber dekorator TypeScript yang dibahas di sini.  Kode ini juga dapat ditemukan di <a href="">sini</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tslint:disable import { Observable, Subscription } from 'rxjs'; import { Type, ɵComponentType as ComponentType, ɵmarkDirty as markDirty } from '@angular/core'; interface ComponentDefinition {  onInit(): void;  onDestroy(): void; } const noop = () =&gt; { }; const getCmp = &lt;T&gt;(type: Function) =&gt; (type as any).ɵcmp as ComponentDefinition; const subscriptionsSymbol = Symbol('__ng__subscriptions'); export function observed() {  return function(    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  ) {    if (descriptor) {      const original = descriptor.value;      descriptor.value = function(...args: any[]) {        original.apply(this, args);        markDirty(this);      };    } else {      const cmp = getCmp(target.constructor);      if (!cmp) {        throw new Error(`Property ɵcmp is undefined`);      }      const onInit = cmp.onInit || noop;      const onDestroy = cmp.onDestroy || noop;      const getSubscriptions = (ctx) =&gt; {        if (ctx[subscriptionsSymbol]) {          return ctx[subscriptionsSymbol];        }        ctx[subscriptionsSymbol] = new Subscription();        return ctx[subscriptionsSymbol];      };      const checkProperty = function(name: string) {        const ctx = this;        if (ctx[name] instanceof Observable) {          const subscriptions = getSubscriptions(ctx);          subscriptions.add(ctx[name].subscribe(() =&gt; markDirty(ctx)));        } else {          const handler = {            set(obj: object, prop: string, value: unknown) {              obj[prop] = value;              markDirty(ctx);              return true;            }          };          ctx[name] = new Proxy(ctx, handler);        }      };      const checkComponentProperties = (ctx) =&gt; {        const props = Object.getOwnPropertyNames(ctx);        props.map((prop) =&gt; {          return Reflect.get(target, prop);        }).filter(Boolean).forEach(() =&gt; {          checkProperty.call(ctx, propertyKey);        });      };      cmp.onInit = function() {        const ctx = this;        onInit.call(ctx);        checkComponentProperties(ctx);      };      cmp.onDestroy = function() {        const ctx = this;        onDestroy.call(ctx);        if (ctx[subscriptionsSymbol]) {          ctx[subscriptionsSymbol].unsubscribe();        }      };      Reflect.set(target, propertyKey, true);    }  }; }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Meskipun saya berharap Anda menyukai cerita saya tentang mengoptimalkan kinerja proyek Angular, saya juga berharap bahwa saya tidak akan membuat Anda terburu-buru untuk menghapus zone.js dari proyek Anda.  Strategi yang dijelaskan di sini harus menjadi pilihan terakhir yang dapat Anda gunakan untuk meningkatkan kinerja aplikasi Angular Anda. <br><br>  Pertama, Anda perlu mencoba pendekatan seperti menggunakan strategi deteksi perubahan OnPush, menerapkan <code>trackBy</code> , menonaktifkan komponen, mengeksekusi kode di luar zone.js, peristiwa blacklisting zone.js (daftar metode optimasi ini dapat dilanjutkan).  Pendekatan yang diperlihatkan di sini cukup mahal, dan saya tidak yakin semua orang mau membayar dengan harga tinggi untuk kinerja. <br><br>  Bahkan, pengembangan tanpa zone.js mungkin bukan hal yang paling menarik.  Mungkin ini tidak hanya untuk mereka yang terlibat dalam proyek di bawah kendali penuhnya.  Artinya - itu adalah pemilik dependensi dan memiliki kemampuan dan waktu untuk membawa semuanya ke bentuk yang semestinya. <br><br>  Jika ternyata Anda telah mencoba segalanya dan percaya bahwa hambatan proyek Anda adalah zone.js, maka mungkin Anda harus mencoba mempercepat Angular dengan mendeteksi perubahan secara independen. <br><br>  Saya harap artikel ini memungkinkan Anda untuk melihat apa yang diharapkan Angular di masa depan, apa yang mampu dilakukan Ivy, dan apa yang dapat dilakukan dengan zone.js untuk memaksimalkan kecepatan aplikasi. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda mengoptimalkan proyek Sudut Anda yang membutuhkan kinerja maksimal? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476956/">https://habr.com/ru/post/id476956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476938/index.html">Kemewahan yang tidak dapat diakses dari Intel: Core i9-9990XE dengan 14 core pada frekuensi 5,0 GHz (2 bagian)</a></li>
<li><a href="../id476940/index.html">Semaphore pada Acara C ++</a></li>
<li><a href="../id476944/index.html">Otak perusahaan. Mulai</a></li>
<li><a href="../id476948/index.html">Lintasan kuantum dan apa yang mereka makan</a></li>
<li><a href="../id476954/index.html">Bekerja bukan serigala, bagian 3. Pemula - tumbuh atau bertahan?</a></li>
<li><a href="../id476958/index.html">Omega Red + PS1 Emulator = Kojima Genius</a></li>
<li><a href="../id476970/index.html">Rapat EkbDotNet No. 1 - Yekaterinburg Bergabung dengan Komunitas DotNet.Ru</a></li>
<li><a href="../id476972/index.html">Deno: Node.JS waktunya hampir habis?</a></li>
<li><a href="../id476974/index.html">Pelajari Desain Web Responsif dalam 5 Menit</a></li>
<li><a href="../id476976/index.html">6 kesalahan berbicara di depan umum di konferensi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>