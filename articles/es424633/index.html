<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèø ‚õπÔ∏è ‚èπÔ∏è C√≥mo STACKLEAK mejora la seguridad del kernel de Linux üö¥ üà∑Ô∏è üçæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="STACKLEAK es una caracter√≠stica de seguridad del kernel de Linux desarrollada originalmente por los creadores de Grsecurity / PaX. Decid√≠ llevar STACK...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo STACKLEAK mejora la seguridad del kernel de Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424633/">  STACKLEAK es una caracter√≠stica de seguridad del kernel de Linux desarrollada originalmente por los creadores de Grsecurity / PaX.  Decid√≠ llevar STACKLEAK al n√∫cleo oficial de vainilla (l√≠nea principal del n√∫cleo de Linux).  Este art√≠culo hablar√° sobre la estructura interna, las propiedades de esta funci√≥n de seguridad y su ruta muy larga y dif√≠cil en la l√≠nea principal. <br><br><img src="https://habrastorage.org/webt/px/95/j_/px95j_edhs60awthgfeytj9uz84.png"><br><br><a name="habracut"></a><br><br>  STACKLEAK protege contra varias clases de vulnerabilidades en el kernel de Linux, a saber: <br><br><ul><li>  reduce la informaci√≥n que es √∫til para el atacante, que puede filtrarse de la pila nuclear al espacio del usuario; </li><li>  bloquea algunos ataques a variables no inicializadas en la pila del kernel; </li><li>  proporciona herramientas de detecci√≥n de desbordamiento de pila din√°mica. </li></ul><br>  Esta caracter√≠stica de seguridad encaja perfectamente con el concepto de Kernel Self Protection Project (KSPP): la seguridad es m√°s que solo corregir errores.  Absolutamente todos los errores en el c√≥digo no pueden repararse y, por lo tanto, el kernel de Linux deber√≠a funcionar de manera segura en situaciones de error, incluso al tratar de explotar vulnerabilidades.  M√°s detalles sobre KSPP est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">disponibles en la wiki del proyecto</a> . <br><br>  STACKLEAK est√° presente como PAX_MEMORY_STACKLEAK en el parche grsecurity / PaX.  Sin embargo, el parche grsecurity / PaX ha dejado de distribuirse libremente desde abril de 2017.  Por lo tanto, la aparici√≥n de STACKLEAK en el kernel de vainilla ser√≠a valiosa para los usuarios de Linux con mayores requisitos de seguridad de la informaci√≥n. <br><br>  Orden de trabajo: <br><br><ul><li>  seleccione STACKLEAK del parche grsecurity / PaX, </li><li>  estudia el c√≥digo cuidadosamente y forma un parche, </li><li>  enviar a LKML, obtener comentarios, mejorar, repetir nuevamente antes de ser aceptado en la l√≠nea principal. </li></ul><br>  Al momento de escribir (25 de septiembre de 2018), se envi√≥ la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n 15 de una serie de parches</a> .  Contiene una parte y un c√≥digo arquitect√≥nicamente independientes para x86_64 y x86_32.  El soporte de STACKLEAK para arm64, desarrollado por Laura Abbott de Red Hat, ya ha logrado ingresar al n√∫cleo de vainilla 4.19. <cut></cut><br><br><h2>  STACKLEAK: caracter√≠sticas de seguridad </h2><br><h3>  Borrar informaci√≥n residual en la pila del n√∫cleo </h3><br>  Esta medida reduce la informaci√≥n √∫til que pueden producir algunas fugas de la pila nuclear al espacio del usuario. <br><br>  Un ejemplo de fuga de informaci√≥n de la pila del n√∫cleo se presenta en la Figura 1. <br><br><img src="https://habrastorage.org/webt/kt/d2/6v/ktd26vqpdxlk4vk8lobb7ixrybc.png"><br><br>  <i>Esquema 1.</i> <br><br>  Sin embargo, las fugas de este tipo se vuelven in√∫tiles si, al final de una llamada al sistema, la parte utilizada de la pila del n√∫cleo se llena con un valor fijo (Figura 2). <br><br><img src="https://habrastorage.org/webt/fy/rr/w4/fyrrw4y-hyyms3pqjlumc_4k01w.png"><br><br>  Esquema 2. <br><br>  Como resultado, STACKLEAK bloquea algunos ataques a variables no inicializadas en la pila del kernel.  Ejemplos de tales vulnerabilidades: CVE-2017-17712, CVE-2010-2963.  Se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una</a> descripci√≥n de la metodolog√≠a de explotaci√≥n para CVE-2010-2963 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un art√≠culo de</a> Kees Cook. <br><br>  La figura 3 muestra la esencia del ataque a una variable no inicializada en la pila del kernel. <br><br><img src="https://habrastorage.org/webt/8j/0p/po/8j0pposbamjhyq2jlsmuxpoqhfq.png"><br><br>  <i>Esquema 3.</i> <br><br>  STACKLEAK bloquea los ataques de este tipo, ya que el valor que llena la pila nuclear al final de una llamada al sistema indica un √°rea no utilizada en el espacio de direcciones virtuales (Figura 4). <br><br><img src="https://habrastorage.org/webt/-t/zp/ok/-tzpokwwsamgqqe0ij7tafszzps.png"><br><br>  <i>Esquema 4.</i> <br><br>  Una limitaci√≥n importante es que STACKLEAK no protege contra ataques similares realizados en una sola llamada al sistema. <br><br><h3>  Detecci√≥n de desbordamiento de pila central en el n√∫cleo </h3><br>  En el n√∫cleo de vainilla (l√≠nea principal del n√∫cleo de Linux), STACKLEAK es eficaz contra el desbordamiento de la profundidad de la pila del n√∫cleo solo junto con CONFIG_THREAD_INFO_IN_TASK y CONFIG_VMAP_STACK.  Ambas medidas son implementadas por Andy Lutomirski. <br><br>  La versi√≥n m√°s simple de explotar este tipo de vulnerabilidad se muestra en la Figura 5. <br><br><img src="https://habrastorage.org/webt/1a/vd/ft/1avdft3jdwd9utgtpletdnv_nuu.png"><br><br>  <i>Esquema 5.</i> <br><br>  Sobrescribir ciertos campos en la estructura thread_info en la parte inferior de la pila nuclear puede aumentar los privilegios del proceso.  Sin embargo, cuando la opci√≥n CONFIG_THREAD_INFO_IN_TASK est√° habilitada, esta estructura se elimina de la pila nuclear, lo que elimina el m√©todo descrito para explotar la vulnerabilidad. <br><br>  Una versi√≥n m√°s avanzada de este ataque es sobrescribir los datos en una regi√≥n de memoria vecina saliendo del borde de la pila.  M√°s sobre este enfoque: <br><br><ul><li>  en la presentaci√≥n de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Stack is Back</a> " de John Oberheide, </li><li>  en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Explotaci√≥n de la recursi√≥n en el kernel de Linux</a> " de Jann Horn. </li></ul><br>  Este tipo de ataque se refleja en la Figura 6. <br><br><img src="https://habrastorage.org/webt/un/zy/3s/unzy3s_w29yrpp020kyj8bokvtw.png"><br><br>  <i>Esquema 6.</i> <br><br>  La protecci√≥n en este caso es CONFIG_VMAP_STACK.  Cuando esta opci√≥n est√° habilitada, se coloca una p√°gina de memoria especial (p√°gina de protecci√≥n) junto a la pila nuclear, cuyo acceso conduce a una excepci√≥n (Figura 7). <br><br><img src="https://habrastorage.org/webt/9w/4b/ht/9w4bht4brf9z7zu6t8udygbr48q.png"><br><br>  <i>Esquema 7.</i> <br><br>  Finalmente, la opci√≥n m√°s interesante de desbordar la pila en profundidad es un ataque como Stack Clash.  La idea fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentada por</a> Gael Delalleau en 2005. <br><br>  En 2017, los investigadores de la compa√±√≠a Qualys lo repensaron, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamando a</a> esta t√©cnica Choque de pila.  El hecho es que hay una manera de saltar sobre la p√°gina de protecci√≥n y sobrescribir los datos de una regi√≥n de memoria vecina (Figura 8).  Esto se hace utilizando una matriz de longitud variable (VLA), cuyo tama√±o es controlado por el atacante. <br><br><img src="https://habrastorage.org/webt/vs/si/z2/vssiz2shuuuswmz96rmjongjjbs.png"><br><br>  <i>Esquema 8.</i> <br><br>  Para obtener m√°s informaci√≥n sobre STACKLEAK y Stack Clash, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consulte el blog de grsecurity</a> . <br><br>  ¬øC√≥mo protege STACKLEAK contra Stack Clash en la pila nuclear?  Antes de cada llamada a alloca (), se realiza una verificaci√≥n en profundidad del desbordamiento de la pila.  Aqu√≠ est√° el c√≥digo correspondiente de la versi√≥n 14 de la serie de parches: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-function">used </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stackleak_check_alloca</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sp = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)&amp;sp; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack_info</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack_info</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> visit_mask = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> stack_left; BUG_ON(get_stack_info(&amp;sp, current, &amp;stack_info, &amp;visit_mask)); stack_left = sp - (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)stack_info.begin; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt;= stack_left) { <span class="hljs-comment"><span class="hljs-comment">/* * Kernel stack depth overflow is detected, let's report that. * If CONFIG_VMAP_STACK is enabled, we can safely use BUG(). * If CONFIG_VMAP_STACK is disabled, BUG() handling can corrupt * the neighbour memory. CONFIG_SCHED_STACK_END_CHECK calls * panic() in a similar situation, so let's do the same if that * option is on. Otherwise just use BUG() and hope for the best. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(CONFIG_VMAP_STACK) &amp;&amp; defined(CONFIG_SCHED_STACK_END_CHECK) panic(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"alloca() over the kernel stack boundary\n"</span></span></span><span class="hljs-meta">); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> BUG(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } }</span></span></code> </pre> <br>  Sin embargo, esta funcionalidad se excluy√≥ de la versi√≥n 15.  Esto se debi√≥ principalmente a la pol√©mica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prohibici√≥n de</a> Linus Torvalds <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de</a> usar BUG_ON () en parches de seguridad del kernel de Linux. <br><br>  Adem√°s, la novena versi√≥n de la serie de parches condujo a una discusi√≥n, como resultado de lo cual se decidi√≥ eliminar todas las matrices variables del n√∫cleo de la l√≠nea principal.  Alrededor de 15 desarrolladores participaron en este trabajo, y se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">terminar√°</a> pronto. <br><br><h2>  Impacto en el rendimiento de STACKLEAK </h2><br>  Doy los resultados de las pruebas de rendimiento en x86_64.  Equipo: Intel Core i7-4770, 16 GB de RAM. <br><br>  Prueba n. ¬∞ 1, atractiva: construir un kernel de Linux en un solo n√∫cleo de procesador <br><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># time make   4.18: real 12m14.124s user 11m17.565s sys 1m6.943s   4.18+stackleak: real 12m20.335s (+0.85%) user 11m23.283s sys 1m8.221s</span></span></code> </pre> <br>  Prueba n. ¬∞ 2, poco atractiva: <br><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># hackbench -s 4096 -l 2000 -g 15 -f 25 -P    4.18: 9.08     4.18+stackleak: 9.47  (+4.3%)</span></span></code> </pre><br>  Por lo tanto, el efecto de STACKLEAK en el rendimiento del sistema depende del tipo de carga.  En particular, una gran cantidad de llamadas cortas al sistema aumentan los gastos generales.  T.O.  El rendimiento de STACKLEAK debe evaluarse para la carga planificada antes de la producci√≥n. <br><br><h2>  Dispositivo interno STACKLEAK </h2><br>  STACKLEAK consiste en: <br><br><ul><li>  El c√≥digo que borra la pila del n√∫cleo al final de la llamada al sistema (originalmente escrito en ensamblador), </li><li>  Complemento GCC para compilaci√≥n instrumental de c√≥digo de kernel. </li></ul><br>  La eliminaci√≥n de la pila del kernel se realiza en la funci√≥n stackleak_erase ().  Esta funci√≥n se cumple antes de volver al espacio del usuario despu√©s de una llamada al sistema.  STACKLEAK_POISON (-0xBEEF) se escribe en la parte utilizada de la pila de subprocesos.  La variable lower_stack, constantemente actualizada en stackleak_track_stack (), apunta al punto de inicio de la limpieza. <br><br>  Las etapas de stackleak_erase () se reflejan en los esquemas 9 y 10. <br><br><img src="https://habrastorage.org/webt/o0/qu/ar/o0quaropj1l3lcpm_wkucohbrwq.png"><br><br>  <i>Esquema 9.</i> <br><br><img src="https://habrastorage.org/webt/vb/qg/2v/vbqg2vqqzsqrstwaqew21svaids.png"><br><br>  <i>Esquema 10.</i> <br><br>  T.O.  stackleak_erase () borra solo la parte utilizada de la pila nuclear.  Es por eso que STACKLEAK es tan r√°pido.  Y si borra los 16 kB de la pila del kernel en x86_64 al final de cada llamada al sistema, hackbench muestra una ca√≠da de rendimiento del 40%. <br><br>  La instrumentaci√≥n del c√≥digo del n√∫cleo en la etapa de compilaci√≥n se realiza en el complemento STACKLEAK GCC. <br><br>  Los complementos de GCC son m√≥dulos descargables espec√≠ficos del proyecto para el compilador de GCC.  Registran nuevos pases con el GCC Pass Manager, proporcionando devoluciones de llamada para estos pases. <br><br>  Entonces, para la operaci√≥n completa de STACKLEAK, las llamadas a stackleak_track_stack () se insertan en el c√≥digo de funciones con un marco de pila grande (marco de pila).  Adem√°s, antes de cada alloca (), se inserta una llamada al ya mencionado stackleak_check_alloca (), y despu√©s de eso, se inserta una llamada a stackleak_track_stack (). <br><br>  Como ya se mencion√≥, en la versi√≥n 15 de la serie de parches, la inserci√≥n de llamadas a stackleak_check_alloca () se excluy√≥ del complemento GCC. <br><br><h2>  Ruta en la l√≠nea principal del kernel de Linux </h2><br>  La ruta STACKLEAK en la l√≠nea principal es muy larga y dif√≠cil (Figura 11). <br><br><img src="https://habrastorage.org/webt/px/95/j_/px95j_edhs60awthgfeytj9uz84.png"><br><br>  <i>Esquema 11. Progreso en la implementaci√≥n de STACKLEAK en la l√≠nea principal del kernel de Linux.</i> <br><br>  En abril de 2017, los creadores de grsecurity cerraron sus parches para la comunidad, comenzando a distribuirlos solo sobre una base comercial.  En mayo de 2017, decid√≠ asumir la tarea de introducir STACKLEAK en el n√∫cleo de vainilla.  As√≠ comenz√≥ un viaje de m√°s de un a√±o.  La empresa Positive Technologies, en la que trabajo, me da la oportunidad de ocuparme de esta tarea durante parte de mi tiempo de trabajo.  Pero b√°sicamente, paso tiempo "libre" en ello. <br><br>  Desde mayo pasado, mi serie de parches ha sufrido m√∫ltiples revisiones, ha sufrido cambios significativos, ha sido criticada dos veces por Linus Torvalds.  Quer√≠a dejar todo esto muchas veces.  Pero en cierto momento hubo un firme deseo de llegar al final.  En el momento de la redacci√≥n (25 de septiembre de 2018), la decimoquinta versi√≥n de la serie de parches se encuentra en la rama Linux-next, cumple con todos los requisitos establecidos por Linus y est√° lista para la ventana de fusi√≥n del kernel 4.20 / 5.0. <br><br>  Hace un mes, di una charla sobre este trabajo en la Cumbre de Seguridad de Linux.  Proporciono enlaces a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diapositivas</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">videos</a> : <br><iframe width="560" height="315" src="https://www.youtube.com/embed/5wIniiWSgUc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Conclusi√≥n </h2><br>  STACKLEAK es una caracter√≠stica de seguridad del kernel de Linux muy √∫til que bloquea la explotaci√≥n de varios tipos de vulnerabilidades a la vez.  Adem√°s, el autor original de PaX Team pudo hacerlo r√°pido y hermoso en ingenier√≠a.  Por lo tanto, la aparici√≥n de STACKLEAK en el kernel de vainilla ser√≠a valiosa para los usuarios de Linux con mayores requisitos de seguridad de la informaci√≥n.  Adem√°s, trabajar en esta direcci√≥n llama la atenci√≥n de la comunidad de desarrolladores de Linux sobre las herramientas de defensa personal del kernel. <br><br><h2>  PS </h2><br>  STACKLEAK fue finalmente adoptado por el n√∫cleo Linux 4.20: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2d6bb6adb714b133db92ccd4bfc9c20f75f71f3f</a> <br><br>  Las arquitecturas compatibles son x86_64, x86_32 y arm64. <br><br>  Adem√°s, se ha completado el trabajo para eliminar las matrices de longitud variable del c√≥digo del kernel de Linux.  La advertencia del compilador Gcc "-Wvla" se incluye en la versi√≥n 4.20 del kernel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lkml.org/lkml/2018/10/28/189</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424633/">https://habr.com/ru/post/es424633/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424621/index.html">Superh√©roes no cinematogr√°ficos. ¬øQui√©n y c√≥mo protege el sitio de construcci√≥n del Centro Lakhta de los incendios?</a></li>
<li><a href="../es424623/index.html">Procesemos el sonido en Go</a></li>
<li><a href="../es424625/index.html">Fuga del c√≥digo fuente de Aeroflot Web Services</a></li>
<li><a href="../es424627/index.html">Alteraci√≥n de cajas registradoras. Parte 1</a></li>
<li><a href="../es424629/index.html">¬øC√≥mo aumentan las startups sus posibilidades de invertir cuando se comunican con un inversor?</a></li>
<li><a href="../es424635/index.html">Bienvenido a Sberbank Data Science Journey 2018 - Carrera de algoritmos de aprendizaje autom√°tico</a></li>
<li><a href="../es424637/index.html">C√≥digo de barras m√°gico</a></li>
<li><a href="../es424639/index.html">Google tiene 20 a√±os</a></li>
<li><a href="../es424641/index.html">Cambio de marca: truco de la vida c√≥mo no convertirse en objeto de burla</a></li>
<li><a href="../es424645/index.html">Como hicimos la encuesta interna m√°s masiva en el banco</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>