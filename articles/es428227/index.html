<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçñ üÜò ‚ò†Ô∏è Aprendizaje autom√°tico: predicci√≥n de precios de acciones en el mercado de valores üëê ü§∞üèΩ üï•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La traductora Polina Kabirova espec√≠ficamente para Netologia adapt√≥ un art√≠culo del ingeniero de la Universidad de Cambridge Vivek Palaniappan sobre c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprendizaje autom√°tico: predicci√≥n de precios de acciones en el mercado de valores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/netologyru/blog/428227/">  <i>La traductora Polina Kabirova espec√≠ficamente para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Netologia</a> adapt√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo</a> del ingeniero de la Universidad de Cambridge Vivek Palaniappan sobre c√≥mo crear un modelo utilizando redes neuronales que puedan predecir los precios de las acciones en una bolsa de valores.</i> <br><br>  El aprendizaje autom√°tico y profundo se ha convertido en una nueva estrategia efectiva que muchos fondos de inversi√≥n utilizan para aumentar los ingresos.  En el art√≠culo, explicar√© c√≥mo las redes neuronales ayudan a predecir la situaci√≥n en el mercado de valores, por ejemplo, el precio de las acciones (o el √≠ndice).  El texto est√° basado en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> escrito en Python.  El c√≥digo completo y la gu√≠a del programa se pueden encontrar en GitHub.  Lea otros art√≠culos relacionados en el Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Medio</a> . <br><a name="habracut"></a><br><h2>  Redes neuronales en economia </h2><br>  Los cambios en el campo de las finanzas no son lineales y, a veces, puede parecer que los precios de las acciones se forman completamente al azar.  Los m√©todos tradicionales de series temporales, como los modelos ARIMA y GARCH, son efectivos cuando la serie es estacionaria; sus propiedades b√°sicas no cambian con el tiempo.  Y esto requiere que la serie haya sido preprocesada utilizando <code>log returns</code> o llevada a la estacionariedad de manera diferente.  Sin embargo, el principal problema surge cuando estos modelos se implementan en un sistema comercial real, ya que la estacionariedad no est√° garantizada al agregar nuevos datos. <br><br>  La soluci√≥n a este problema puede ser redes neuronales que no requieren estacionariedad.  Las redes neuronales son inicialmente muy efectivas para encontrar relaciones entre datos y son capaces de predecir (o clasificar) nuevos datos basados ‚Äã‚Äãen ellos. <br><br>  Por lo general, un proyecto de ciencia de datos consta de las siguientes operaciones: <br><br><ol><li>  Recopilaci√≥n de datos: proporciona un conjunto de propiedades necesarias. </li><li>  El preprocesamiento de datos suele ser un paso aterrador pero necesario antes de utilizar los datos. </li><li>  El desarrollo e implementaci√≥n del modelo es la elecci√≥n del tipo de red neuronal y sus par√°metros. </li><li>  Los modelos de backtesting (pruebas en datos hist√≥ricos) son un paso clave en cualquier estrategia comercial. </li><li>  Optimizaci√≥n: busque los par√°metros adecuados. </li></ol><br>  Entrada para nuestra red neuronal: datos sobre los precios de las acciones de los √∫ltimos 10 d√≠as.  Con su ayuda, predeciremos los precios al d√≠a siguiente. <br><br><h2>  Recogida de datos </h2><br>  Afortunadamente, los datos necesarios para este proyecto se pueden encontrar en Yahoo Finance.  Los datos se pueden recopilar utilizando su API de Python <code>pdr.get_yahoo_data(ticker, start_date, end_date)</code> o directamente desde el sitio. <br><br><h2>  Preprocesamiento de datos </h2><br>  En nuestro caso, los datos deben dividirse en conjuntos de capacitaci√≥n que consisten en 10 precios pasados ‚Äã‚Äãy precios al d√≠a siguiente.  Para hacer esto, <code>Preprocessing</code> clase de <code>Preprocessing</code> , que funcionar√° con datos de entrenamiento y prueba.  Dentro de la clase, <code>get_train(self, seq_len)</code> el <code>get_train(self, seq_len)</code> , que convierte los datos de entrada y salida de entrenamiento en matrices <code>NumPy</code> , estableciendo una longitud de ventana espec√≠fica (en nuestro caso 10).  Todo el c√≥digo se ve as√≠: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen_train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, seq_len)</span></span></span><span class="hljs-function">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""  Generates training data  :param seq_len: length of window  :return: X_train and Y_train  """</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range((len(self.stock_train)//seq_len)*seq_len - seq_len - <span class="hljs-number"><span class="hljs-number">1</span></span>):      x = np.array(self.stock_train.iloc[i: i + seq_len, <span class="hljs-number"><span class="hljs-number">1</span></span>])      y = np.array([self.stock_train.iloc[i + seq_len + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]], np.float64)      self.input_train.append(x)      self.output_train.append(y)  self.X_train = np.array(self.input_train)  self.Y_train = np.array(self.output_train)</code> </pre> <br>  Del mismo modo, he definido un m√©todo que convierte los datos de prueba <code>X_test</code> e <code>Y_test</code> . <br><br><h2>  Modelos de redes neuronales </h2><br>  Para el proyecto, utilic√© dos modelos de redes neuronales: el Perceptr√≥n Multicapa (MLP) y el Modelo a Corto Plazo (LSTM).  Hablar√© brevemente sobre c√≥mo funcionan estos modelos.  Lea m√°s sobre MLP en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otro art√≠culo</a> , y sobre el trabajo de LSTM en Jacob Aungiers. <br><br>  MLP es la forma m√°s simple de redes neuronales.  Los datos de entrada entran en el modelo y, al usar ciertos pesos, los valores se transmiten a trav√©s de capas ocultas para obtener datos de salida.  Aprender el algoritmo proviene de la propagaci√≥n hacia atr√°s a trav√©s de capas ocultas para cambiar los valores de peso de cada neurona.  El problema con este modelo es la falta de "memoria".  Es imposible determinar cu√°les fueron los datos anteriores y c√≥mo pueden y deben afectar los nuevos.  En el contexto de nuestro modelo, las diferencias de 10 d√≠as entre los datos de dos conjuntos de datos pueden ser importantes, pero los MLP no pueden analizar tales relaciones. <br><br>  Para hacer esto, use LSTM o redes neuronales recurrentes (RNN).  Los RNN almacenan cierta informaci√≥n de datos para su uso posterior, esto ayuda a la red neuronal a analizar la estructura compleja de las relaciones entre los datos del precio de las acciones.  Pero con RNN, surge el problema de un gradiente de desvanecimiento.  El gradiente disminuye porque aumenta el n√∫mero de capas y el nivel de entrenamiento (un valor menor que la unidad) se multiplica varias veces.  Resuelva este problema de LSTM aumentando la eficiencia. <br><br><h2>  Implementaci√≥n del modelo </h2><br>  Para implementar el modelo, utilic√© <code>Keras</code> , porque all√≠ se agregan capas gradualmente y no definen toda la red a la vez.  Por lo tanto, podemos cambiar r√°pidamente el n√∫mero y el tipo de capas, optimizando la red neuronal. <br><br>  Un paso importante para trabajar con los precios de las acciones es la normalizaci√≥n de datos.  Por lo general, para esto se resta el error promedio y se divide por el error est√°ndar.  Pero necesitamos que este sistema se use en el comercio real durante un cierto per√≠odo de tiempo.  Por lo tanto, el uso de estad√≠sticas puede no ser la forma m√°s precisa de normalizar los datos.  As√≠ que acabo de dividir todos los datos en 200 (un n√∫mero arbitrario en comparaci√≥n con el cual todos los otros n√∫meros son peque√±os).  Y aunque parece que tal normalizaci√≥n no est√° justificada y no tiene sentido, es efectivo asegurarse de que los pesos en la red neuronal no sean demasiado grandes. <br><br>  Comencemos con un modelo m√°s simple: MLP.  Keras construye una secuencia y agrega capas densas encima.  El c√≥digo completo se ve as√≠: <br><br><pre> <code class="python hljs">model = tf.keras.models.Sequential() model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, activation=tf.nn.relu)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, activation=tf.nn.relu)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=tf.nn.relu)) model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">"adam"</span></span>, loss=<span class="hljs-string"><span class="hljs-string">"mean_squared_error"</span></span>)</code> </pre> <br>  Usando Keras en cinco l√≠neas de c√≥digo, creamos MLP con capas ocultas, cien neuronas en cada una.  Y ahora un poco sobre el optimizador.  El m√©todo Adam (estimaci√≥n de momento adaptativo) est√° ganando popularidad: un algoritmo de optimizaci√≥n m√°s eficiente en comparaci√≥n con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el descenso de gradiente estoc√°stico</a> .  Hay otras dos extensiones del descenso de gradiente estoc√°stico: las ventajas de Adam son inmediatamente visibles en su contexto: <br><br>  <b>AdaGrad</b> : mantiene una velocidad de aprendizaje establecida, que mejora los resultados cuando los gradientes divergen (por ejemplo, con problemas con el lenguaje natural y la visi√≥n por computadora). <br><br>  <b>RMSProp</b> : mantiene una velocidad de entrenamiento establecida, que puede variar seg√∫n los valores promedio de los gradientes recientes para el peso (por ejemplo, qu√© tan r√°pido cambia).  Esto significa que el algoritmo resuelve bien los problemas no estacionarios (por ejemplo, ruido). <br><br>  Adam combina los beneficios de estas extensiones, as√≠ que lo eleg√≠. <br><br>  Ahora ajustamos el modelo a nuestros datos de entrenamiento.  Keras simplifica la tarea nuevamente, solo se necesita el siguiente c√≥digo: <br><br><pre> <code class="python hljs">model.fit(X_train, Y_train, epochs=<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Cuando el modelo est√© listo, debe verificarlo en los datos de prueba para determinar qu√© tan bien funcion√≥.  Esto se hace as√≠: <br><br><pre> <code class="python hljs">model.evaluate(X_test, Y_test)</code> </pre> <br>  La informaci√≥n obtenida de la verificaci√≥n se puede utilizar para evaluar la capacidad del modelo para predecir los precios de las acciones. <br><br>  Se utiliza un procedimiento similar para el modelo LSTM, por lo que mostrar√© el c√≥digo y lo explicar√© un poco: <br><br><pre> <code class="python hljs">model = tf.keras.Sequential() model.add(tf.keras.layers.LSTM(<span class="hljs-number"><span class="hljs-number">20</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), return_sequences=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)) model.add(tf.keras.layers.LSTM(<span class="hljs-number"><span class="hljs-number">20</span></span>)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=tf.nn.relu)) model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">"adam"</span></span>, loss=<span class="hljs-string"><span class="hljs-string">"mean_squared_error"</span></span>) model.fit(X_train, Y_train, epochs=<span class="hljs-number"><span class="hljs-number">50</span></span>) model.evaluate(X_test, Y_test)</code> </pre> <br>  Tenga en cuenta que Keras necesita datos de cierto tama√±o, dependiendo de su modelo.  Es muy importante cambiar la forma de la matriz con NumPy. <br><br><h2>  Modelos de backtesting </h2><br>  Cuando preparamos nuestros modelos usando datos de entrenamiento y los probamos en datos de prueba, podemos probar el modelo en datos hist√≥ricos.  Esto se hace de la siguiente manera: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">back_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strategy, seq_len, ticker, start_date, end_date, dim)</span></span></span><span class="hljs-function">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""  A simple back test for a given date period  :param strategy: the chosen strategy. Note to have already formed the model, and fitted with training data.  :param seq_len: length of the days used for prediction  :param ticker: company ticker  :param start_date: starting date  :type start_date: "YYYY-mm-dd"  :param end_date: ending date  :type end_date: "YYYY-mm-dd"  :param dim: dimension required for strategy: 3dim for LSTM and 2dim for MLP  :type dim: tuple  :return: Percentage errors array that gives the errors for every test in the given date range  """</span></span>  data = pdr.get_data_yahoo(ticker, start_date, end_date)  stock_data = data[<span class="hljs-string"><span class="hljs-string">"Adj Close"</span></span>]  errors = []  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range((len(stock_data)//<span class="hljs-number"><span class="hljs-number">10</span></span>)*<span class="hljs-number"><span class="hljs-number">10</span></span> - seq_len - <span class="hljs-number"><span class="hljs-number">1</span></span>):      x = np.array(stock_data.iloc[i: i + seq_len, <span class="hljs-number"><span class="hljs-number">1</span></span>]).reshape(dim) / <span class="hljs-number"><span class="hljs-number">200</span></span>      y = np.array(stock_data.iloc[i + seq_len + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) / <span class="hljs-number"><span class="hljs-number">200</span></span>      predict = strategy.predict(x)      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> predict == <span class="hljs-number"><span class="hljs-number">0</span></span>:          predict = strategy.predict(x)      error = (predict - y) / <span class="hljs-number"><span class="hljs-number">100</span></span>      errors.append(error)      total_error = np.array(errors)  print(<span class="hljs-string"><span class="hljs-string">f"Average error = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{total_error.mean()}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br>  Sin embargo, esta es una versi√≥n simplificada de las pruebas.  Para un sistema de backtesting completo, se deben considerar factores como el "sesgo de supervivencia", el sesgo (sesgo de anticipaci√≥n), las condiciones cambiantes del mercado y los costos de transacci√≥n.  Dado que este es solo un proyecto educativo, basta una simple prueba de respaldo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/_9/hy/qw_9hyxncpkhgxv_rvsxxtxrhlk.png"></div><br>  <i>Pron√≥stico de mi modelo LSTM para los precios de las acciones de Apple en febrero</i> <br><br>  Para un modelo LSTM simple sin optimizaci√≥n, este es un muy buen resultado.  Muestra que las redes neuronales y los modelos de aprendizaje autom√°tico son capaces de construir conexiones complejas y estables entre los par√°metros. <br><br><h2>  Optimizaci√≥n de hiperpar√°metros </h2><br>  La optimizaci√≥n a menudo es necesaria para mejorar los resultados del modelo despu√©s de la prueba.  No lo inclu√≠ en la versi√≥n de c√≥digo abierto para que los lectores puedan intentar optimizar el modelo ellos mismos.  Aquellos que no saben c√≥mo optimizar tendr√°n que encontrar hiperpar√°metros que mejorar√°n el rendimiento del modelo.  Existen varios m√©todos para encontrar hiperpar√°metros: desde la selecci√≥n de par√°metros en una cuadr√≠cula hasta los m√©todos estoc√°sticos. <br><br>  Estoy seguro de que con la optimizaci√≥n de modelos, el conocimiento en el campo del aprendizaje autom√°tico va a un nuevo nivel.  Intenta optimizar el modelo para que funcione mejor que el m√≠o.  Compara el resultado con el gr√°fico de arriba. <br><br><h2>  Conclusi√≥n </h2><br>  El aprendizaje autom√°tico est√° en constante evoluci√≥n: todos los d√≠as aparecen nuevos m√©todos, por lo que es muy importante aprender constantemente.  La mejor manera de hacer esto es crear proyectos interesantes, por ejemplo, construir modelos para pronosticar los precios de las acciones.  Y aunque mi modelo LSTM no es lo suficientemente bueno para su uso en el comercio real, la base establecida en el desarrollo de dicho modelo puede ayudar en el futuro. <br><br><h2>  De los editores </h2><br>  Cursos de Netolog√≠a sobre el tema: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analista de datos</a> Profesi√≥n en l√≠nea </li><li>  Profesi√≥n en l√≠nea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Data Scientist</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428227/">https://habr.com/ru/post/es428227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428217/index.html">Millones de videollamadas por d√≠a o "¬°Llama a mam√°!"</a></li>
<li><a href="../es428219/index.html">¬øDe d√≥nde viene la pr√°ctica de la reubicaci√≥n masiva de personal calificado?</a></li>
<li><a href="../es428221/index.html">Generaci√≥n AI de caras realistas</a></li>
<li><a href="../es428223/index.html">Ciudades y sus Big Data</a></li>
<li><a href="../es428225/index.html">C√≥mo hacer an√°lisis web para SaaS a trav√©s de Google Analytics: introducci√≥n y seguimiento de un embudo</a></li>
<li><a href="../es428229/index.html">C√≥mo Lisp se convirti√≥ en un lenguaje de programaci√≥n para Dios</a></li>
<li><a href="../es428231/index.html">Hermoso y limpio: herramientas que lo ayudan a lograr un c√≥digo casi perfecto</a></li>
<li><a href="../es428233/index.html">Cinco razones para amar las fiestas regionales de TI</a></li>
<li><a href="../es428235/index.html">¬øPor qu√© me llamaron desde la NSA en medio de la noche y preguntaron por la fuente?</a></li>
<li><a href="../es428237/index.html">Scrum-mitap con juego de mesa: invitar a Scrum Values ‚Äã‚ÄãGame</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>