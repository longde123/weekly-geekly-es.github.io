<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì® üö¥üèΩ üê∂ Wie Prozessoren entworfen und hergestellt werden: die Grundlagen der Computerarchitektur üßóüèø üíÖ üõ§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir nehmen den Zentralprozessor als das ‚ÄûGehirn‚Äú eines Computers wahr, aber was bedeutet das wirklich? Was genau passiert in den Milliarden von Transi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Prozessoren entworfen und hergestellt werden: die Grundlagen der Computerarchitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456922/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/582/2e1/7725822e1e2ef8975b16770b48a0e199.jpg" alt="Bild"></div><br>  Wir nehmen den Zentralprozessor als das ‚ÄûGehirn‚Äú eines Computers wahr, aber was bedeutet das wirklich?  Was genau passiert in den Milliarden von Transistoren, die einen Computer zum Laufen bringen?  In unserer neuen Miniserie mit vier Artikeln werden wir den Prozess der Erstellung der Architektur von Computerger√§ten betrachten und √ºber die Prinzipien ihrer Funktionsweise sprechen. <br><br>  In dieser Reihe werden wir √ºber Computerarchitektur, Design von Prozessorkarten, VLSI (Very-Large-Scale-Integration), Chipherstellung und zuk√ºnftige Trends auf dem Gebiet der Computertechnologie sprechen.  Wenn Sie die Details der Prozessoren verstehen m√∂chten, ist es besser, die Studie mit dieser Artikelserie zu beginnen. <br><br>  Wir beginnen mit einer sehr allgemeinen Erkl√§rung, was der Prozessor tut und wie sich die Bausteine ‚Äã‚Äãzu einer funktionierenden Struktur verbinden.  Insbesondere werden Prozessorkerne, Speicherhierarchie, Verzweigungsvorhersage und mehr ber√ºcksichtigt.  Zun√§chst m√ºssen wir einfach definieren, was die CPU tut.  Die einfachste Erkl√§rung: Der Prozessor folgt einer Reihe von Anweisungen, um eine bestimmte Operation f√ºr viele eingehende Daten auszuf√ºhren.  Beispielsweise kann ein Wert aus dem Speicher gelesen, dann zu einem anderen Wert hinzugef√ºgt und das Ergebnis schlie√ülich unter einer anderen Adresse im Speicher gespeichert werden.  Es kann etwas komplizierter sein, zum Beispiel die Division zweier Zahlen, wenn das Ergebnis der vorherigen Berechnung gr√∂√üer als Null ist. <br><br>  Programme wie ein Betriebssystem oder ein Spiel sind selbst Befehlsfolgen, die die CPU ausf√ºhren muss.  Diese Anweisungen werden aus dem Speicher geladen und nacheinander in einem einfachen Prozessor ausgef√ºhrt, bis das Programm beendet wird.  Softwareentwickler schreiben Programme in Hochsprachen wie C ++ oder Python, aber der Prozessor kann sie nicht verstehen.  Er versteht nur Einsen und Nullen, daher m√ºssen wir den Code in diesem Format irgendwie darstellen. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/9ea/109/0959ea1090226766b43f20c46c8ed6d1.png"></div><br>  Programme werden zu einer Reihe von Anweisungen auf niedriger Ebene kompiliert, die als <em>Assemblersprache bezeichnet werden</em> und Teil der Befehlssatzarchitektur (ISA) sind.  Dies ist eine Reihe von Anweisungen, die die CPU verstehen und ausf√ºhren muss.  Einige der h√§ufigsten ISAs sind x86, MIPS, ARM, RISC-V und PowerPC.  Ebenso wie sich die Syntax zum Schreiben einer Funktion in C ++ von der Funktion unterscheidet, die dieselbe Aktion in Python ausf√ºhrt, hat jede ISA ihre eigene Syntax. <br><br>  Diese ISAs k√∂nnen in zwei Hauptkategorien unterteilt werden: feste und variable L√§nge.  ISA RISC-V verwendet Befehle mit fester L√§nge, was bedeutet, dass eine vorbestimmte Anzahl von Bits in jedem Befehl bestimmt, welcher Typ der Befehl ist.  In x86 ist alles anders, es werden Anweisungen variabler L√§nge verwendet.  In x86 k√∂nnen Anweisungen auf unterschiedliche Weise mit unterschiedlicher Anzahl von Bits f√ºr verschiedene Teile codiert werden.  Aufgrund dieser Komplexit√§t ist der Befehlsdecoder auf dem x86-Prozessor normalerweise der komplexeste Teil des gesamten Ger√§ts. <br><br>  Befehle mit fester L√§nge bieten aufgrund einer konstanten Struktur eine einfache Dekodierung, begrenzen jedoch die Gesamtzahl der Befehle, die von ISA unterst√ºtzt werden k√∂nnen.  W√§hrend die g√§ngigen Versionen der RISC-V-Architektur ungef√§hr 100 Anweisungen enthalten und alle Open Source sind, ist die x86-Architektur propriet√§r und niemand wei√ü, wie viele Anweisungen darin enthalten sind.  Es wird allgemein angenommen, dass es mehrere tausend x86-Anweisungen gibt, aber niemand ver√∂ffentlicht die genaue Anzahl.  Trotz der Unterschiede zwischen ISAs haben alle die gleiche Grundfunktionalit√§t. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/0a8/074/acc0a807407b41b94459d8202b0c6b4e.png"></div><br>  <i>Ein Beispiel f√ºr einige RISC-V-Anweisungen.</i>  <i>Der Opcode rechts ist 7 Bit lang und bestimmt die Art des Befehls.</i>  <i>Zus√§tzlich enth√§lt jeder Befehl Bits, die die verwendeten Register und die ausgef√ºhrten Funktionen definieren.</i>  <i>Assembler-Anweisungen werden also in Bin√§rcode unterteilt, damit der Prozessor ihn versteht.</i> <br><br>  Jetzt k√∂nnen wir den Computer einschalten und mit der Ausf√ºhrung von Programmen beginnen.  Die Ausf√ºhrung des Befehls besteht aus mehreren grundlegenden Teilen, die in viele Stufen des Prozessors unterteilt sind. <br><br>  Die erste Stufe ist die √úbertragung von Anweisungen vom Speicher zum Prozessor, um die Ausf√ºhrung zu starten.  Im zweiten Schritt wird der Befehl decodiert, damit die CPU verstehen kann, um welchen Befehlstyp es sich handelt.  Es gibt viele Typen, einschlie√ülich arithmetischer Anweisungen, Verzweigungsanweisungen und Speicheranweisungen.  Nachdem die CPU herausgefunden hat, welche Art von Befehl sie ausf√ºhrt, werden die Operanden f√ºr den Befehl aus dem Speicher oder den internen CPU-Registern entnommen.  Wenn Sie die Nummer A und die Nummer B hinzuf√ºgen m√∂chten, k√∂nnen Sie diese erst hinzuf√ºgen, wenn Sie die Werte von A und B kennen. Die meisten modernen Prozessoren sind 64-Bit-Prozessoren, dh die Gr√∂√üe jedes Datenwerts betr√§gt 64 Bit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/105/5cd/f55/1055cdf5560f78a1bbe61b6acbfb4d4d.png"></div><br>  <i>64 Bit ist die Breite des Prozessorregisters, des Datenkanals und / oder der Speicheradresse.</i>  <i>F√ºr normale Benutzer bedeutet dies, wie viele Informationen ein Computer gleichzeitig verarbeiten kann. Dies l√§sst sich am besten im Vergleich zu einem j√ºngeren Architekturverwandten - einem 32-Bit-Prozessor - verstehen.</i>  <i>Die 64-Bit-Architektur kann doppelt so viele Informationsbits gleichzeitig verarbeiten (64 Bit gegen√ºber 32 Bit).</i> <br><br>  Nachdem der Prozessor die Operanden f√ºr den Befehl empfangen hat, √ºbertr√§gt er sie an die Ausf√ºhrungsstufe, wo die Operation an den eingehenden Daten ausgef√ºhrt wird.  Dies kann das Hinzuf√ºgen von Zahlen, das Ausf√ºhren logischer Manipulationen mit Zahlen oder das einfache √úbergeben von Zahlen sein, ohne diese zu √§ndern.  Nach der Berechnung des Ergebnisses kann ein Speicherzugriff erforderlich sein, um es zu speichern, oder der Prozessor kann den Wert einfach in einem seiner internen Register speichern.  Nach dem Speichern des Ergebnisses aktualisiert die CPU den Status der verschiedenen Elemente und f√§hrt mit dem n√§chsten Befehl fort. <br><br>  Diese Erkl√§rung ist nat√ºrlich stark vereinfacht, und die meisten modernen Prozessoren unterteilen diese verschiedenen Stufen in 20 oder noch mehr kleine Stufen, um die Effizienz zu steigern.  Dies bedeutet, dass der Prozessor zwar mit mehreren Befehlen in jedem Zyklus beginnt und endet, es jedoch 20 oder mehr Zyklen dauern kann, um einen Befehl von Anfang bis Ende auszuf√ºhren.  Ein solches Modell wird normalerweise als Pipeline ("Pipeline", normalerweise ins Russische √ºbersetzt als "F√∂rderer") bezeichnet, da es einige Zeit dauert, die Pipeline mit Fl√ºssigkeit zu f√ºllen und ihren Durchgang abzuschlie√üen, aber nach dem Bef√ºllen ist die Durchflussrate (Datenausgabe) konstant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f4/94c/b7f/5f494cb7fea80ae36c741da698beb07c.png"></div><br>  <i>Ein Beispiel f√ºr einen 4-stufigen F√∂rderer.</i>  <i>Mehrfarbige Rechtecke kennzeichnen voneinander unabh√§ngige Anweisungen.</i> <br><br>  Der gesamte Zyklus, den die Anweisung durchl√§uft, ist ein sehr sorgf√§ltig koordinierter Prozess, aber nicht alle Anweisungen k√∂nnen gleichzeitig ausgef√ºhrt werden.  Zum Beispiel ist das Hinzuf√ºgen sehr schnell und das Teilen oder Laden aus dem Speicher kann Tausende von Zyklen dauern.  Anstatt den gesamten Prozessor bis zum Abschluss eines langsamen Befehls anzuhalten, f√ºhren die meisten modernen Prozessoren diese mit einer √Ñnderung der Reihenfolge aus.  Das hei√üt, sie bestimmen, welche der Anweisungen im Moment am vorteilhaftesten auszuf√ºhren ist, und puffern andere Anweisungen, die noch nicht bereit sind.  Wenn der aktuelle Befehl noch nicht fertig ist, kann der Prozessor im Code vorw√§rts springen, um zu sehen, ob etwas anderes bereit ist. <br><br>  Moderne Prozessoren f√ºhren nicht nur eine Abfolge von √Ñnderungen aus, sondern verwenden auch eine Technologie, die als <em>superskalare Architektur bezeichnet wird</em> .  Dies bedeutet, dass der Prozessor zu jeder Zeit gleichzeitig viele Anweisungen in jeder Phase der Pipeline ausf√ºhrt.  Er kann auch erwarten, dass Hunderte weitere mit ihrer Ausf√ºhrung beginnen. Um mehrere Anweisungen gleichzeitig in den Prozessoren ausf√ºhren zu k√∂nnen, gibt es mehrere Kopien jeder Stufe der Pipeline.  Wenn der Prozessor feststellt, dass zwei Befehle zur Ausf√ºhrung bereit sind und keine Abh√§ngigkeit zwischen ihnen besteht, wartet er nicht, bis sie separat ausgef√ºhrt werden, sondern f√ºhrt sie gleichzeitig aus.  Eine beliebte Implementierung dieser Architektur hei√üt Simultaneous Multithreading (SMT) und wird auch als Hyper-Threading bezeichnet.  Intel- und AMD-Prozessoren unterst√ºtzen jetzt doppelseitiges SMT, w√§hrend IBM Chips entwickelt hat, die bis zu acht SMTs unterst√ºtzen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/279/f3d/7ff/279f3d7fffe891e166b1a4547223363c.png"></div><br>  Um diese sorgf√§ltig koordinierte Ausf√ºhrung abzuschlie√üen, verf√ºgt der Prozessor neben dem Basiskern √ºber viele zus√§tzliche Elemente.  Der Prozessor verf√ºgt √ºber Hunderte von separaten Modulen, von denen jedes eine bestimmte Funktion hat. Wir werden jedoch nur die Grundlagen ber√ºcksichtigen.  Die wichtigsten und profitabelsten sind Caches und der Pr√§diktor f√ºr √úberg√§nge.  Es gibt andere zus√§tzliche Strukturen, die wir nicht ber√ºcksichtigen werden: Neuanordnen von Puffern, Registrieren von Umbenennungstabellen und Sicherungsstationen. <br><br>  Die Notwendigkeit von Caches kann manchmal verwirrend sein, da sie Daten wie RAM oder SSD speichern.  Caches unterscheiden sich jedoch in Latenz und Zugriffsgeschwindigkeit.  Obwohl der RAM-Speicher extrem schnell ist, ist er um Gr√∂√üenordnungen langsamer als die CPU ben√∂tigt.  M√∂glicherweise sind Hunderte von Zyklen erforderlich, um auf die √úbertragung von RAM-Daten zu reagieren, und der Prozessor hat zu diesem Zeitpunkt nichts zu tun.  Und wenn sich keine Daten im RAM befinden, kann es Zehntausende von Zyklen dauern, um von der SSD auf diese zuzugreifen.  Ohne Caches w√ºrden Prozessoren st√§ndig anhalten. <br><br>  Prozessoren haben normalerweise drei Cache-Ebenen, aus denen die sogenannte <em>Speicherhierarchie besteht</em> .  Der L1-Cache ist der kleinste und schnellste, L2 befindet sich in der Mitte und L3 ist der gr√∂√üte und langsamste aller Caches.  √úber den Caches in der Hierarchie befinden sich kleine Register, in denen der einzige Datenwert w√§hrend der Berechnungen gespeichert wird.  In der Gr√∂√üenordnung sind diese Register die schnellsten Speicherger√§te im System.  Wenn der Compiler ein √ºbergeordnetes Programm in Assemblersprache konvertiert, bestimmt er, wie diese Register am besten verwendet werden k√∂nnen. <br><br>  Wenn die CPU Daten aus dem Speicher anfordert, pr√ºft sie zun√§chst, ob diese Daten bereits im L1-Cache gespeichert sind.  Wenn ja, k√∂nnen Sie in nur wenigen Zyklen darauf zugreifen.  Wenn sie nicht vorhanden sind, √ºberpr√ºft der Prozessor L2 und dann den L3-Cache.  Caches werden so implementiert, dass sie im Allgemeinen f√ºr den Kernel transparent sind.  Der Kernel fordert einfach Daten an der angegebenen Speicheradresse an, und die Ebene in der Hierarchie, auf der er existiert, antwortet darauf.  Beim √úbergang zu nachfolgenden Ebenen in der Speicherhierarchie nehmen Gr√∂√üe und Verz√∂gerungen normalerweise um Gr√∂√üenordnungen zu.  Wenn die CPU am Ende keine Daten in einem der Caches findet, greift sie auf den Hauptspeicher (RAM) zu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/bfa/d08/36abfad0814a507d82b857f0de29b96e.png"></div><br>  In einem normalen Prozessor verf√ºgt jeder Kern √ºber zwei L1-Caches: einen f√ºr Daten und einen f√ºr Anweisungen.  L1-Caches haben normalerweise eine Gesamtkapazit√§t von etwa 100 Kilobyte und die Gr√∂√üe variiert stark in Abh√§ngigkeit von der Chip- und Prozessorgeneration.  Dar√ºber hinaus verf√ºgt normalerweise jeder Kern √ºber einen eigenen L2-Cache, obwohl dies in einigen Architekturen zwei Kernen gemeinsam sein kann.  L2-Caches sind normalerweise mehrere hundert Kilobyte gro√ü.  Schlie√ülich gibt es einen einzigen L3-Cache, der allen Kernen gemeinsam ist und eine Gr√∂√üe in der Gr√∂√üenordnung von zehn Megabyte aufweist. <br><br>  Wenn der Prozessor den Code ausf√ºhrt, werden die am h√§ufigsten verwendeten Anweisungen und Datenwerte zwischengespeichert.  Dies beschleunigt die Ausf√ºhrung erheblich, da der Prozessor nicht st√§ndig in den Hauptspeicher gehen muss, um die erforderlichen Daten zu erhalten.  Im zweiten und dritten Teil der Serie werden wir mehr dar√ºber sprechen, wie diese Speichersysteme implementiert sind. <br><br>  Einer der wichtigsten Bausteine ‚Äã‚Äãeines modernen Prozessors ist neben Caches ein genauer <em>√úbergangspr√§diktor</em> .  √úbergangsanweisungen (Verzweigungsbefehle) √§hneln den if-Konstrukten f√ºr den Prozessor.  Ein Befehlssatz wird ausgef√ºhrt, wenn die Bedingung wahr ist, und der andere, wenn sie falsch ist.  Zum Beispiel m√ºssen wir zwei Zahlen vergleichen, und wenn sie gleich sind, f√ºhren Sie eine Funktion aus, und wenn sie nicht gleich sind, f√ºhren Sie eine andere aus.  Diese Verzweigungsanweisungen sind sehr h√§ufig und k√∂nnen etwa 20% aller Anweisungen in einem Programm ausmachen. <br><br>  Auf den ersten Blick scheint es, dass diese Verzweigungsanweisungen keine Probleme verursachen sollten, aber ihre ordnungsgem√§√üe Ausf√ºhrung kann f√ºr den Prozessor sehr schwierig sein.  Zu jedem Zeitpunkt kann der Prozessor dabei sein, zehn oder zwanzig Befehle gleichzeitig auszuf√ºhren, daher ist es sehr wichtig zu wissen, <em>welche</em> Befehle ausgef√ºhrt werden sollen.  Es kann 5 Zyklen dauern, um festzustellen, ob der aktuelle Befehl ein √úbergang ist, und weitere 10 Zyklen, um festzustellen, ob die Bedingung erf√ºllt ist.  Zu diesem Zeitpunkt kann der Prozessor bereits Dutzende zus√§tzlicher Anweisungen ausf√ºhren, ohne zu wissen, ob diese Anweisungen wirklich f√ºr die Ausf√ºhrung geeignet sind. <br><br>  Um dieses Problem zu umgehen, verwenden alle modernen Hochleistungsprozessoren eine Technik namens Spekulation.  Dies bedeutet, dass der Prozessor Verzweigungsbefehle verfolgt und sich fragt, ob die bedingte Verzweigung ausgef√ºhrt wird oder nicht.  Wenn die Vorhersage korrekt ist, hat der Prozessor bereits begonnen, die folgenden Anweisungen auszuf√ºhren, und dies f√ºhrt zu einer Leistungssteigerung.  Wenn die Vorhersage falsch ist, stoppt der Prozessor die Ausf√ºhrung, l√∂scht alle falschen Anweisungen, die er ausgef√ºhrt hat, und startet erneut am richtigen Punkt. <br><br>  Solche Verzweigungspr√§diktoren sind einige der einfachsten Arten des maschinellen Lernens, da der Pr√§diktor das Verhalten von Verzweigungen w√§hrend der Ausf√ºhrung untersucht.  Wenn er zu oft falsch vorhersagt, beginnt er, das richtige Verhalten zu lernen.  Jahrzehntelange Forschungen zu √úbergangsvorhersagetechniken haben in modernen Prozessoren zu einer Vorhersagegenauigkeit von mehr als 90% gef√ºhrt. <br><br>  Die Antizipation f√ºhrt zwar zu einer enormen Leistungssteigerung, da der Prozessor bereits fertige Anweisungen ausf√ºhren kann, anstatt in der Warteschlange auf die Ausf√ºhrung zu warten, sondern auch Sicherheitsl√ºcken schafft.  Der ber√ºhmte Spectre-Angriff nutzt Fehler aus, um √úberg√§nge vorherzusagen und zu antizipieren.  Der Angreifer verwendet speziell ausgew√§hlten Code, um den Prozessor zu zwingen, den Code proaktiv auszuf√ºhren, was zu einem Verlust von Werten aus dem Speicher f√ºhrt.  Um Datenlecks zu vermeiden, mussten bestimmte Aspekte der Antizipation √ºberarbeitet werden, was zu einem leichten Leistungsabfall f√ºhrte. <br><br>  In den letzten Jahrzehnten hat die in modernen Prozessoren verwendete Architektur einen langen Weg zur√ºckgelegt.  Innovation und die Entwicklung einer durchdachten Struktur haben zu einer h√∂heren Produktivit√§t und einem optimaleren Einsatz von Hardware gef√ºhrt.  Die Entwickler der Zentralprozessoren bewahren die Geheimnisse ihrer Technologien jedoch sorgf√§ltig auf, sodass wir nicht genau herausfinden k√∂nnen, was in ihnen geschieht.  Die Grundprinzipien der Prozessoren sind jedoch f√ºr alle Architekturen und Modelle standardisiert.  Intel kann seine geheimen Zutaten hinzuf√ºgen, um den Anteil der Cache-Treffer zu erh√∂hen, und AMD kann einen verbesserten √úbergangspr√§diktor hinzuf√ºgen, aber die Prozessoren beider Unternehmen f√ºhren dieselbe Aufgabe aus. <br><br>  In diesem ersten Blick und R√ºckblick haben wir die Grundlagen der Funktionsweise von Prozessoren behandelt.  Im n√§chsten Teil erfahren Sie, wie Sie die Komponenten der Prozessoren entwickeln, √ºber Logikelemente, Taktfrequenzen, Energieverwaltung, Schaltkreise und vieles mehr sprechen. <br><br><h5>  Empfohlene Lekt√ºre </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Geschichte des Mikroprozessors und des Personal Computers</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Display Tech im Vergleich: TN vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VA vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4GHz CPU Battle: AMD 2. Generation Ryzen vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Core der 8. Generation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist thermische Drosselung und wie kann man dies verhindern?</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456922/">https://habr.com/ru/post/de456922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456908/index.html">Wie Telegramm Sie zu Rostelecom zusammenf√ºhrt</a></li>
<li><a href="../de456910/index.html">Internetprojekt security.txt - Kennenlernen einer anderen bekannten Datei</a></li>
<li><a href="../de456912/index.html">So erstellen Sie Websites im Jahr 2019</a></li>
<li><a href="../de456916/index.html">Cross Compilation im Docker. Warum nicht?</a></li>
<li><a href="../de456920/index.html">Sony Xperia 1 in Russland - Preis- und Vorbestellungsboni</a></li>
<li><a href="../de456926/index.html">Wie wir Sportmaster machen</a></li>
<li><a href="../de456928/index.html">JMeter - Schweizer Pr√ºfmesser (Teil 1)</a></li>
<li><a href="../de456930/index.html">IoT in die Massen bringen: Ergebnisse des ersten IoT-Hackathons von GeekBrains und Rostelecom</a></li>
<li><a href="../de456932/index.html">Ultramodernes OpenGL. Teil 1</a></li>
<li><a href="../de456936/index.html">Animierte Karten auf SwiftUI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>