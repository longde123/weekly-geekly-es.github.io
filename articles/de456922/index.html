<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📨 🚴🏽 🐶 Wie Prozessoren entworfen und hergestellt werden: die Grundlagen der Computerarchitektur 🧗🏿 💅 🛤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir nehmen den Zentralprozessor als das „Gehirn“ eines Computers wahr, aber was bedeutet das wirklich? Was genau passiert in den Milliarden von Transi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Prozessoren entworfen und hergestellt werden: die Grundlagen der Computerarchitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456922/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/582/2e1/7725822e1e2ef8975b16770b48a0e199.jpg" alt="Bild"></div><br>  Wir nehmen den Zentralprozessor als das „Gehirn“ eines Computers wahr, aber was bedeutet das wirklich?  Was genau passiert in den Milliarden von Transistoren, die einen Computer zum Laufen bringen?  In unserer neuen Miniserie mit vier Artikeln werden wir den Prozess der Erstellung der Architektur von Computergeräten betrachten und über die Prinzipien ihrer Funktionsweise sprechen. <br><br>  In dieser Reihe werden wir über Computerarchitektur, Design von Prozessorkarten, VLSI (Very-Large-Scale-Integration), Chipherstellung und zukünftige Trends auf dem Gebiet der Computertechnologie sprechen.  Wenn Sie die Details der Prozessoren verstehen möchten, ist es besser, die Studie mit dieser Artikelserie zu beginnen. <br><br>  Wir beginnen mit einer sehr allgemeinen Erklärung, was der Prozessor tut und wie sich die Bausteine ​​zu einer funktionierenden Struktur verbinden.  Insbesondere werden Prozessorkerne, Speicherhierarchie, Verzweigungsvorhersage und mehr berücksichtigt.  Zunächst müssen wir einfach definieren, was die CPU tut.  Die einfachste Erklärung: Der Prozessor folgt einer Reihe von Anweisungen, um eine bestimmte Operation für viele eingehende Daten auszuführen.  Beispielsweise kann ein Wert aus dem Speicher gelesen, dann zu einem anderen Wert hinzugefügt und das Ergebnis schließlich unter einer anderen Adresse im Speicher gespeichert werden.  Es kann etwas komplizierter sein, zum Beispiel die Division zweier Zahlen, wenn das Ergebnis der vorherigen Berechnung größer als Null ist. <br><br>  Programme wie ein Betriebssystem oder ein Spiel sind selbst Befehlsfolgen, die die CPU ausführen muss.  Diese Anweisungen werden aus dem Speicher geladen und nacheinander in einem einfachen Prozessor ausgeführt, bis das Programm beendet wird.  Softwareentwickler schreiben Programme in Hochsprachen wie C ++ oder Python, aber der Prozessor kann sie nicht verstehen.  Er versteht nur Einsen und Nullen, daher müssen wir den Code in diesem Format irgendwie darstellen. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/9ea/109/0959ea1090226766b43f20c46c8ed6d1.png"></div><br>  Programme werden zu einer Reihe von Anweisungen auf niedriger Ebene kompiliert, die als <em>Assemblersprache bezeichnet werden</em> und Teil der Befehlssatzarchitektur (ISA) sind.  Dies ist eine Reihe von Anweisungen, die die CPU verstehen und ausführen muss.  Einige der häufigsten ISAs sind x86, MIPS, ARM, RISC-V und PowerPC.  Ebenso wie sich die Syntax zum Schreiben einer Funktion in C ++ von der Funktion unterscheidet, die dieselbe Aktion in Python ausführt, hat jede ISA ihre eigene Syntax. <br><br>  Diese ISAs können in zwei Hauptkategorien unterteilt werden: feste und variable Länge.  ISA RISC-V verwendet Befehle mit fester Länge, was bedeutet, dass eine vorbestimmte Anzahl von Bits in jedem Befehl bestimmt, welcher Typ der Befehl ist.  In x86 ist alles anders, es werden Anweisungen variabler Länge verwendet.  In x86 können Anweisungen auf unterschiedliche Weise mit unterschiedlicher Anzahl von Bits für verschiedene Teile codiert werden.  Aufgrund dieser Komplexität ist der Befehlsdecoder auf dem x86-Prozessor normalerweise der komplexeste Teil des gesamten Geräts. <br><br>  Befehle mit fester Länge bieten aufgrund einer konstanten Struktur eine einfache Dekodierung, begrenzen jedoch die Gesamtzahl der Befehle, die von ISA unterstützt werden können.  Während die gängigen Versionen der RISC-V-Architektur ungefähr 100 Anweisungen enthalten und alle Open Source sind, ist die x86-Architektur proprietär und niemand weiß, wie viele Anweisungen darin enthalten sind.  Es wird allgemein angenommen, dass es mehrere tausend x86-Anweisungen gibt, aber niemand veröffentlicht die genaue Anzahl.  Trotz der Unterschiede zwischen ISAs haben alle die gleiche Grundfunktionalität. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/0a8/074/acc0a807407b41b94459d8202b0c6b4e.png"></div><br>  <i>Ein Beispiel für einige RISC-V-Anweisungen.</i>  <i>Der Opcode rechts ist 7 Bit lang und bestimmt die Art des Befehls.</i>  <i>Zusätzlich enthält jeder Befehl Bits, die die verwendeten Register und die ausgeführten Funktionen definieren.</i>  <i>Assembler-Anweisungen werden also in Binärcode unterteilt, damit der Prozessor ihn versteht.</i> <br><br>  Jetzt können wir den Computer einschalten und mit der Ausführung von Programmen beginnen.  Die Ausführung des Befehls besteht aus mehreren grundlegenden Teilen, die in viele Stufen des Prozessors unterteilt sind. <br><br>  Die erste Stufe ist die Übertragung von Anweisungen vom Speicher zum Prozessor, um die Ausführung zu starten.  Im zweiten Schritt wird der Befehl decodiert, damit die CPU verstehen kann, um welchen Befehlstyp es sich handelt.  Es gibt viele Typen, einschließlich arithmetischer Anweisungen, Verzweigungsanweisungen und Speicheranweisungen.  Nachdem die CPU herausgefunden hat, welche Art von Befehl sie ausführt, werden die Operanden für den Befehl aus dem Speicher oder den internen CPU-Registern entnommen.  Wenn Sie die Nummer A und die Nummer B hinzufügen möchten, können Sie diese erst hinzufügen, wenn Sie die Werte von A und B kennen. Die meisten modernen Prozessoren sind 64-Bit-Prozessoren, dh die Größe jedes Datenwerts beträgt 64 Bit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/105/5cd/f55/1055cdf5560f78a1bbe61b6acbfb4d4d.png"></div><br>  <i>64 Bit ist die Breite des Prozessorregisters, des Datenkanals und / oder der Speicheradresse.</i>  <i>Für normale Benutzer bedeutet dies, wie viele Informationen ein Computer gleichzeitig verarbeiten kann. Dies lässt sich am besten im Vergleich zu einem jüngeren Architekturverwandten - einem 32-Bit-Prozessor - verstehen.</i>  <i>Die 64-Bit-Architektur kann doppelt so viele Informationsbits gleichzeitig verarbeiten (64 Bit gegenüber 32 Bit).</i> <br><br>  Nachdem der Prozessor die Operanden für den Befehl empfangen hat, überträgt er sie an die Ausführungsstufe, wo die Operation an den eingehenden Daten ausgeführt wird.  Dies kann das Hinzufügen von Zahlen, das Ausführen logischer Manipulationen mit Zahlen oder das einfache Übergeben von Zahlen sein, ohne diese zu ändern.  Nach der Berechnung des Ergebnisses kann ein Speicherzugriff erforderlich sein, um es zu speichern, oder der Prozessor kann den Wert einfach in einem seiner internen Register speichern.  Nach dem Speichern des Ergebnisses aktualisiert die CPU den Status der verschiedenen Elemente und fährt mit dem nächsten Befehl fort. <br><br>  Diese Erklärung ist natürlich stark vereinfacht, und die meisten modernen Prozessoren unterteilen diese verschiedenen Stufen in 20 oder noch mehr kleine Stufen, um die Effizienz zu steigern.  Dies bedeutet, dass der Prozessor zwar mit mehreren Befehlen in jedem Zyklus beginnt und endet, es jedoch 20 oder mehr Zyklen dauern kann, um einen Befehl von Anfang bis Ende auszuführen.  Ein solches Modell wird normalerweise als Pipeline ("Pipeline", normalerweise ins Russische übersetzt als "Förderer") bezeichnet, da es einige Zeit dauert, die Pipeline mit Flüssigkeit zu füllen und ihren Durchgang abzuschließen, aber nach dem Befüllen ist die Durchflussrate (Datenausgabe) konstant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f4/94c/b7f/5f494cb7fea80ae36c741da698beb07c.png"></div><br>  <i>Ein Beispiel für einen 4-stufigen Förderer.</i>  <i>Mehrfarbige Rechtecke kennzeichnen voneinander unabhängige Anweisungen.</i> <br><br>  Der gesamte Zyklus, den die Anweisung durchläuft, ist ein sehr sorgfältig koordinierter Prozess, aber nicht alle Anweisungen können gleichzeitig ausgeführt werden.  Zum Beispiel ist das Hinzufügen sehr schnell und das Teilen oder Laden aus dem Speicher kann Tausende von Zyklen dauern.  Anstatt den gesamten Prozessor bis zum Abschluss eines langsamen Befehls anzuhalten, führen die meisten modernen Prozessoren diese mit einer Änderung der Reihenfolge aus.  Das heißt, sie bestimmen, welche der Anweisungen im Moment am vorteilhaftesten auszuführen ist, und puffern andere Anweisungen, die noch nicht bereit sind.  Wenn der aktuelle Befehl noch nicht fertig ist, kann der Prozessor im Code vorwärts springen, um zu sehen, ob etwas anderes bereit ist. <br><br>  Moderne Prozessoren führen nicht nur eine Abfolge von Änderungen aus, sondern verwenden auch eine Technologie, die als <em>superskalare Architektur bezeichnet wird</em> .  Dies bedeutet, dass der Prozessor zu jeder Zeit gleichzeitig viele Anweisungen in jeder Phase der Pipeline ausführt.  Er kann auch erwarten, dass Hunderte weitere mit ihrer Ausführung beginnen. Um mehrere Anweisungen gleichzeitig in den Prozessoren ausführen zu können, gibt es mehrere Kopien jeder Stufe der Pipeline.  Wenn der Prozessor feststellt, dass zwei Befehle zur Ausführung bereit sind und keine Abhängigkeit zwischen ihnen besteht, wartet er nicht, bis sie separat ausgeführt werden, sondern führt sie gleichzeitig aus.  Eine beliebte Implementierung dieser Architektur heißt Simultaneous Multithreading (SMT) und wird auch als Hyper-Threading bezeichnet.  Intel- und AMD-Prozessoren unterstützen jetzt doppelseitiges SMT, während IBM Chips entwickelt hat, die bis zu acht SMTs unterstützen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/279/f3d/7ff/279f3d7fffe891e166b1a4547223363c.png"></div><br>  Um diese sorgfältig koordinierte Ausführung abzuschließen, verfügt der Prozessor neben dem Basiskern über viele zusätzliche Elemente.  Der Prozessor verfügt über Hunderte von separaten Modulen, von denen jedes eine bestimmte Funktion hat. Wir werden jedoch nur die Grundlagen berücksichtigen.  Die wichtigsten und profitabelsten sind Caches und der Prädiktor für Übergänge.  Es gibt andere zusätzliche Strukturen, die wir nicht berücksichtigen werden: Neuanordnen von Puffern, Registrieren von Umbenennungstabellen und Sicherungsstationen. <br><br>  Die Notwendigkeit von Caches kann manchmal verwirrend sein, da sie Daten wie RAM oder SSD speichern.  Caches unterscheiden sich jedoch in Latenz und Zugriffsgeschwindigkeit.  Obwohl der RAM-Speicher extrem schnell ist, ist er um Größenordnungen langsamer als die CPU benötigt.  Möglicherweise sind Hunderte von Zyklen erforderlich, um auf die Übertragung von RAM-Daten zu reagieren, und der Prozessor hat zu diesem Zeitpunkt nichts zu tun.  Und wenn sich keine Daten im RAM befinden, kann es Zehntausende von Zyklen dauern, um von der SSD auf diese zuzugreifen.  Ohne Caches würden Prozessoren ständig anhalten. <br><br>  Prozessoren haben normalerweise drei Cache-Ebenen, aus denen die sogenannte <em>Speicherhierarchie besteht</em> .  Der L1-Cache ist der kleinste und schnellste, L2 befindet sich in der Mitte und L3 ist der größte und langsamste aller Caches.  Über den Caches in der Hierarchie befinden sich kleine Register, in denen der einzige Datenwert während der Berechnungen gespeichert wird.  In der Größenordnung sind diese Register die schnellsten Speichergeräte im System.  Wenn der Compiler ein übergeordnetes Programm in Assemblersprache konvertiert, bestimmt er, wie diese Register am besten verwendet werden können. <br><br>  Wenn die CPU Daten aus dem Speicher anfordert, prüft sie zunächst, ob diese Daten bereits im L1-Cache gespeichert sind.  Wenn ja, können Sie in nur wenigen Zyklen darauf zugreifen.  Wenn sie nicht vorhanden sind, überprüft der Prozessor L2 und dann den L3-Cache.  Caches werden so implementiert, dass sie im Allgemeinen für den Kernel transparent sind.  Der Kernel fordert einfach Daten an der angegebenen Speicheradresse an, und die Ebene in der Hierarchie, auf der er existiert, antwortet darauf.  Beim Übergang zu nachfolgenden Ebenen in der Speicherhierarchie nehmen Größe und Verzögerungen normalerweise um Größenordnungen zu.  Wenn die CPU am Ende keine Daten in einem der Caches findet, greift sie auf den Hauptspeicher (RAM) zu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/bfa/d08/36abfad0814a507d82b857f0de29b96e.png"></div><br>  In einem normalen Prozessor verfügt jeder Kern über zwei L1-Caches: einen für Daten und einen für Anweisungen.  L1-Caches haben normalerweise eine Gesamtkapazität von etwa 100 Kilobyte und die Größe variiert stark in Abhängigkeit von der Chip- und Prozessorgeneration.  Darüber hinaus verfügt normalerweise jeder Kern über einen eigenen L2-Cache, obwohl dies in einigen Architekturen zwei Kernen gemeinsam sein kann.  L2-Caches sind normalerweise mehrere hundert Kilobyte groß.  Schließlich gibt es einen einzigen L3-Cache, der allen Kernen gemeinsam ist und eine Größe in der Größenordnung von zehn Megabyte aufweist. <br><br>  Wenn der Prozessor den Code ausführt, werden die am häufigsten verwendeten Anweisungen und Datenwerte zwischengespeichert.  Dies beschleunigt die Ausführung erheblich, da der Prozessor nicht ständig in den Hauptspeicher gehen muss, um die erforderlichen Daten zu erhalten.  Im zweiten und dritten Teil der Serie werden wir mehr darüber sprechen, wie diese Speichersysteme implementiert sind. <br><br>  Einer der wichtigsten Bausteine ​​eines modernen Prozessors ist neben Caches ein genauer <em>Übergangsprädiktor</em> .  Übergangsanweisungen (Verzweigungsbefehle) ähneln den if-Konstrukten für den Prozessor.  Ein Befehlssatz wird ausgeführt, wenn die Bedingung wahr ist, und der andere, wenn sie falsch ist.  Zum Beispiel müssen wir zwei Zahlen vergleichen, und wenn sie gleich sind, führen Sie eine Funktion aus, und wenn sie nicht gleich sind, führen Sie eine andere aus.  Diese Verzweigungsanweisungen sind sehr häufig und können etwa 20% aller Anweisungen in einem Programm ausmachen. <br><br>  Auf den ersten Blick scheint es, dass diese Verzweigungsanweisungen keine Probleme verursachen sollten, aber ihre ordnungsgemäße Ausführung kann für den Prozessor sehr schwierig sein.  Zu jedem Zeitpunkt kann der Prozessor dabei sein, zehn oder zwanzig Befehle gleichzeitig auszuführen, daher ist es sehr wichtig zu wissen, <em>welche</em> Befehle ausgeführt werden sollen.  Es kann 5 Zyklen dauern, um festzustellen, ob der aktuelle Befehl ein Übergang ist, und weitere 10 Zyklen, um festzustellen, ob die Bedingung erfüllt ist.  Zu diesem Zeitpunkt kann der Prozessor bereits Dutzende zusätzlicher Anweisungen ausführen, ohne zu wissen, ob diese Anweisungen wirklich für die Ausführung geeignet sind. <br><br>  Um dieses Problem zu umgehen, verwenden alle modernen Hochleistungsprozessoren eine Technik namens Spekulation.  Dies bedeutet, dass der Prozessor Verzweigungsbefehle verfolgt und sich fragt, ob die bedingte Verzweigung ausgeführt wird oder nicht.  Wenn die Vorhersage korrekt ist, hat der Prozessor bereits begonnen, die folgenden Anweisungen auszuführen, und dies führt zu einer Leistungssteigerung.  Wenn die Vorhersage falsch ist, stoppt der Prozessor die Ausführung, löscht alle falschen Anweisungen, die er ausgeführt hat, und startet erneut am richtigen Punkt. <br><br>  Solche Verzweigungsprädiktoren sind einige der einfachsten Arten des maschinellen Lernens, da der Prädiktor das Verhalten von Verzweigungen während der Ausführung untersucht.  Wenn er zu oft falsch vorhersagt, beginnt er, das richtige Verhalten zu lernen.  Jahrzehntelange Forschungen zu Übergangsvorhersagetechniken haben in modernen Prozessoren zu einer Vorhersagegenauigkeit von mehr als 90% geführt. <br><br>  Die Antizipation führt zwar zu einer enormen Leistungssteigerung, da der Prozessor bereits fertige Anweisungen ausführen kann, anstatt in der Warteschlange auf die Ausführung zu warten, sondern auch Sicherheitslücken schafft.  Der berühmte Spectre-Angriff nutzt Fehler aus, um Übergänge vorherzusagen und zu antizipieren.  Der Angreifer verwendet speziell ausgewählten Code, um den Prozessor zu zwingen, den Code proaktiv auszuführen, was zu einem Verlust von Werten aus dem Speicher führt.  Um Datenlecks zu vermeiden, mussten bestimmte Aspekte der Antizipation überarbeitet werden, was zu einem leichten Leistungsabfall führte. <br><br>  In den letzten Jahrzehnten hat die in modernen Prozessoren verwendete Architektur einen langen Weg zurückgelegt.  Innovation und die Entwicklung einer durchdachten Struktur haben zu einer höheren Produktivität und einem optimaleren Einsatz von Hardware geführt.  Die Entwickler der Zentralprozessoren bewahren die Geheimnisse ihrer Technologien jedoch sorgfältig auf, sodass wir nicht genau herausfinden können, was in ihnen geschieht.  Die Grundprinzipien der Prozessoren sind jedoch für alle Architekturen und Modelle standardisiert.  Intel kann seine geheimen Zutaten hinzufügen, um den Anteil der Cache-Treffer zu erhöhen, und AMD kann einen verbesserten Übergangsprädiktor hinzufügen, aber die Prozessoren beider Unternehmen führen dieselbe Aufgabe aus. <br><br>  In diesem ersten Blick und Rückblick haben wir die Grundlagen der Funktionsweise von Prozessoren behandelt.  Im nächsten Teil erfahren Sie, wie Sie die Komponenten der Prozessoren entwickeln, über Logikelemente, Taktfrequenzen, Energieverwaltung, Schaltkreise und vieles mehr sprechen. <br><br><h5>  Empfohlene Lektüre </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Geschichte des Mikroprozessors und des Personal Computers</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Display Tech im Vergleich: TN vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VA vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4GHz CPU Battle: AMD 2. Generation Ryzen vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel Core der 8. Generation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist thermische Drosselung und wie kann man dies verhindern?</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456922/">https://habr.com/ru/post/de456922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456908/index.html">Wie Telegramm Sie zu Rostelecom zusammenführt</a></li>
<li><a href="../de456910/index.html">Internetprojekt security.txt - Kennenlernen einer anderen bekannten Datei</a></li>
<li><a href="../de456912/index.html">So erstellen Sie Websites im Jahr 2019</a></li>
<li><a href="../de456916/index.html">Cross Compilation im Docker. Warum nicht?</a></li>
<li><a href="../de456920/index.html">Sony Xperia 1 in Russland - Preis- und Vorbestellungsboni</a></li>
<li><a href="../de456926/index.html">Wie wir Sportmaster machen</a></li>
<li><a href="../de456928/index.html">JMeter - Schweizer Prüfmesser (Teil 1)</a></li>
<li><a href="../de456930/index.html">IoT in die Massen bringen: Ergebnisse des ersten IoT-Hackathons von GeekBrains und Rostelecom</a></li>
<li><a href="../de456932/index.html">Ultramodernes OpenGL. Teil 1</a></li>
<li><a href="../de456936/index.html">Animierte Karten auf SwiftUI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>