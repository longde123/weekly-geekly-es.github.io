<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏤 👨‍⚕️ 👨🏻‍🎓 Accepter et décoder la télévision analogique en utilisant SDR et Python 👩🏾‍🤝‍👨🏻 🔽 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. 

 Aujourd'hui, nous continuons le sujet de la réception SDR et du traitement du signal. Je me suis intéressé à la réception de la télévi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Accepter et décoder la télévision analogique en utilisant SDR et Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482014/">  Salut, Habr. <br><br>  Aujourd'hui, nous continuons le sujet de la réception SDR et du traitement du signal.  Je me suis intéressé à la réception de la télévision analogique tout à fait par accident, après une question d'un des lecteurs.  Cependant, cela s'est avéré pas si simple, en raison du manque banal d'échantillons de signal - dans de nombreux endroits, la télévision analogique a déjà été désactivée.  Le lecteur a même envoyé un enregistrement avec RTL-SDR, cependant, la largeur de l'enregistrement à RTL est d'environ 2 MHz, tandis que la bande passante du signal TV est d'environ 8 MHz, et rien n'était clair sur l'enregistrement.  En conséquence, le sujet a été abandonné pendant longtemps, et enfin, tout à l'heure, lors de mon prochain voyage chez mes proches, j'ai pris SDRPlay avec moi et réglé les fréquences des chaînes de télévision, j'ai vu le signal souhaité sur l'écran. <br><br>  Un petit programme Python, et tout fonctionne: <br><br><img src="https://habrastorage.org/webt/o4/t9/y4/o4t9y4lcex9vssgmpgc2vssujvu.jpeg"><br><br>  Pour ceux qui sont intéressés par les détails, continue sous la coupe. <a name="habracut"></a><br><br><h2>  Théorie </h2><br>  Dans les anciennes années d'après-guerre, lorsque les laboratoires numériques ne connaissaient la transmission du signal numérique que dans des laboratoires secrets, mais que les gens voulaient déjà regarder la télévision, il y avait trois normes analogiques concurrentes.  Le premier était l'American <a href="https://en.wikipedia.org/wiki/NTSC">NTSC</a> (National Television System System Committee), qui a été développé depuis les années 40, a été «affûté» pour la fréquence du réseau américain de 60 Hz et avait une résolution verticale de seulement 486 lignes.  Un peu plus tard en Allemagne, la norme <a href="https://en.wikipedia.org/wiki/PAL">PAL</a> (Phase Alternating Line) a commencé à être développée, qui était légèrement meilleure que la norme américaine (résolution des 576 lignes «entières» et focalisation sur la fréquence du réseau européen de 50 Hz), et un peu plus tard le <a href="https://en.wikipedia.org/wiki/SECAM">SECAM</a> français (Séquentiel couleur à mémoire) est apparu.  Il a éliminé certaines des lacunes du PAL liées à la reproduction des couleurs, et il existe une version selon laquelle l'adoption de deux normes était également une décision politique, de sorte que les résidents de certains pays ne pouvaient pas regarder les programmes d'autres pays (c'était environ 50 ans avant l'Union européenne unie et Schengen) .  D'une manière ou d'une autre, mais le monde entier était divisé comme ceci: <br><br><img src="https://habrastorage.org/webt/i3/w7/qy/i3w7qyt3opicaz0prpryn9-9ha4.png"><br><br>  Parce que  Habr est toujours un site en langue russe, alors à l'avenir, nous considérerons SECAM, bien que si quelqu'un envoie un échantillon de signal PAL, ce serait également intéressant. <br><br>  Le spectre SECAM, <s>selon les anciens parchemins</s> , est le suivant: <br><br><img src="https://habrastorage.org/webt/m-/t1/l9/m-t1l9ntpksl9ul6zoi4evslxac.png"><br><br>  À gauche, à la fréquence F0, se trouve le signal de luminance modulé en amplitude (L).  Il s'agit en fait d'une image en noir et blanc, qui peut toujours être affichée sur un vieux téléviseur noir et blanc <s>chaud et lampe</s> .  Le problème de Legacy et la présence d'anciens appareils parmi les utilisateurs existaient déjà à l'époque, de sorte que le canal de couleur a été ajouté séparément, sans perdre la compatibilité avec les anciens téléviseurs.  Deux canaux de couleur ont été transmis alternativement en modulation de fréquence à des fréquences de 4,25 et 4,406 MHz.  Et enfin, encore plus haut en fréquence, le son était transmis séparément, également en modulation de fréquence. <br><br>  Soit dit en passant, avec la réception de la télévision à Saint-Pétersbourg, il y a un moment amusant.  Comme l'ont rapporté les médias russes, la télévision analogique a été désactivée en octobre: <br><br><img src="https://habrastorage.org/webt/e_/ql/pm/e_qlpmgp7ukmcw5ag9ial0gozic.png"><br><br>  Cependant, cela ne s'applique qu'aux <i>chaînes d'État</i> ; personne n'oblige les <i>chaînes</i> commerciales <i>à</i> désactiver leurs émissions.  Au moins au moment de la rédaction (décembre 2019), environ 5-6 chaînes sont toujours disponibles dans le «analogique» en plein centre de Saint-Pétersbourg.  Mais combien de temps cela durera est inconnu, donc ceux qui veulent enregistrer des échantillons de signaux «pour l'histoire» devraient toujours être pressés. <br><br>  Enfin, il est temps d'activer le SDR et de voir ce que nous avons dans la vie réelle: <br><br><img src="https://habrastorage.org/webt/gl/pc/6m/glpc6midlpecggjb4nknxhcvdkc.png"><br><br>  Le canal audio n'est pas difficile, vous pouvez simplement le survoler avec la «souris» en HDSDR, sélectionner FM avec une bande passante d'environ 50 KHz et écouter.  Nous allons commencer le décodage à partir du canal de luminosité, cela nous permettra d'obtenir une «image» prête à l'emploi. <br><br><h2>  Décodage </h2><br>  Comme décrit ci-dessus, les signaux de luminance sont transmis à AM.  Afin de ne pas écrire le décodeur vous-même, nous utilisons GNU Radio - nous transférons le spectre à une fréquence nulle, démarrons le décodeur AM et enregistrons le résultat dans un fichier. <br><br><img src="https://habrastorage.org/webt/xp/n2/wf/xpn2wfbovg--y915lex2kesd1we.png"><br><br>  Maintenant, nous pouvons ouvrir le fichier enregistré en Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt lum_data = np.fromfile(<span class="hljs-string"><span class="hljs-string">"pal_lum.raw"</span></span>, dtype=<span class="hljs-string"><span class="hljs-string">'int32'</span></span>) lum_data = -lum_data - <span class="hljs-number"><span class="hljs-number">4700</span></span> fs = <span class="hljs-number"><span class="hljs-number">9000000</span></span>//<span class="hljs-number"><span class="hljs-number">2</span></span> x_time = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(lum_data)/fs, num=len(lum_data)) plt.plot(x_time, lum_data)</code> </pre> <br>  Nous voyons une séquence de 4 images sur l'écran. <br><br><img src="https://habrastorage.org/webt/f5/yq/4a/f5yq4aeks144gso4-_73qcmn0t8.png"><br><br>  La longueur d'une trame 0,02 s - ce n'est que 1/50 - est un multiple de la fréquence réseau de 50 Hz, dont les signaux servent de «générateur d'horloge» (n'oubliez pas que le signal est analogique).  Pour chaque image, 320 lignes sont transmises - nous avons un balayage entrelacé, donc la fréquence d'images finale est de 25 Hz. <br><br>  Voyons les lignes individuelles plus en détail: <br><br><img src="https://habrastorage.org/webt/j6/ly/7g/j6ly7gfmqmev6rlumkfudjgc8k4.png"><br><br>  Comme vous pouvez le voir, le début de chaque ligne correspond à une «horloge», puis le swing du signal correspond aux valeurs de luminosité actuelles de cette ligne.  Tout est assez simple, et probablement sans pratiquement aucun changement, un tel signal a été appliqué au tube cathodique du téléviseur. <br><br>  Le reste est une question de technologie.  Nous créons une image dans la mémoire et copions deux images dedans, car  nous avons entrelacé.  La portée du signal ne dépasse pas +200, ce qui nous permet d'écrire ces valeurs directement en couleurs RVB. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Output image frame_size = fs*1//50 img_x, img_y = 320, 650 img_size = (img_y, img_x, 3) img_data = np.zeros(img_size, dtype=np.uint8) img_data.fill(255) frame_num = 0 # Frame #1 pos_x, pos_y = 0, 0 for px in range(frame_num*frame_size, (frame_num+1)*frame_size): val = lum_data[px] if val &lt; 0: val = 0 if val &gt; 255: val = 255 img_data[pos_y][pos_x] = (0, val, 0) pos_x += 1 if lum_data[px] &lt;= 0 and lum_data[px+1] &gt; 0: pos_x = 0 pos_y += 2 print("Scan lines 1:", pos_y) # Frame #2 pos_x, pos_y = 0, 0 for px in range((frame_num+1)*frame_size, (frame_num+2)*frame_size): val = lum_data[px] if val &lt; 0: val = 0 if val &gt; 255: val = 255 img_data[pos_y+1][pos_x] = (0, val, 0) pos_x += 1 if lum_data[px] &lt;= 0 and lum_data[px+1] &gt; 0: pos_x = 0 pos_y += 2 img_resized = cv2.resize(img_data, dsize=(3*img_x, img_y), interpolation=cv2.INTER_CUBIC) plt.imshow(img_resized, interpolation='nearest')</span></span></code> </pre><br>  Comme vous pouvez le voir, j'utilise le passage à zéro pour détecter le début d'une nouvelle ligne.  L'image s'est avérée compressée verticalement, dans ce cas cela dépend de la fréquence d'échantillonnage du SDR, au final je viens de la redimensionner large. <br><br>  Le résultat final sur l'animation de 10 images (n'accepte plus l'archive de fichiers Habr): <br><br><img src="https://habrastorage.org/webt/k0/ah/ri/k0ahrixczcntxnwflutgq-aihpy.gif"><br><br><h2>  Conclusion </h2><br>  Il est intéressant d'analyser de telles normes, car  d'une part, leur mise en œuvre est assez simple et, d'autre part, leur étude présente également un intérêt historique.  Bien sûr, je n'avais pas pour objectif de créer un tuner TV logiciel complet, donc le code est affiché sous une forme minimale. <br><br>  Si les notes de l'article sont positives, dans la deuxième partie, il sera possible d'envisager de travailler avec la couleur et d'afficher une image couleur à part entière. <br><br>  Pour ceux qui souhaitent expérimenter par eux-mêmes, le fichier IQ peut être téléchargé <a href="https://cloud.mail.ru/public/2gSx/5LfQSJwDZ">ici</a> . <br><br>  Toutes les expériences réussies. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482014/">https://habr.com/ru/post/fr482014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482002/index.html">Rédaction d'un blog sur les microservices - Partie 3 «Utilisateur»</a></li>
<li><a href="../fr482004/index.html">Nous testons 1C sur le serveur VPS</a></li>
<li><a href="../fr482008/index.html">Constructeur LEGO et zéro absolu</a></li>
<li><a href="../fr482010/index.html">"Nouvelles épopées". Pour les développeurs, les ops et les curieux</a></li>
<li><a href="../fr482012/index.html">Raspberry Pi et iperf - testeur de bande passante pour les appareils Smart Home et IoT</a></li>
<li><a href="../fr482020/index.html">Tâches R, Monte Carlo et entreprise</a></li>
<li><a href="../fr482022/index.html">Regardez! 20 films sur la science et les scientifiques</a></li>
<li><a href="../fr482030/index.html">Vue.js: hooks du cycle de vie de vos composants et des composants tiers</a></li>
<li><a href="../fr482032/index.html">On joue avec le feu: on exécute du code arbitraire sur le développement iPhone 7</a></li>
<li><a href="../fr482034/index.html">Yandex: il y a tout ... sur les utilisateurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>