<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêì üåø üë¥üèæ Yew - Rust & WebAssembly-Frontend-Framework ü§ûüèø üíë üõ∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yew ist ein Analogon von React and Elm, vollst√§ndig in Rust geschrieben und zu einer ehrlichen WebAssembly zusammengestellt. In dem Artikel spricht De...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Yew - Rust & WebAssembly-Frontend-Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422253/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yew</a> ist ein Analogon von React and Elm, vollst√§ndig in Rust geschrieben und zu einer ehrlichen WebAssembly zusammengestellt.  In dem Artikel spricht Denis Kolodin, Yew-Entwickler, dar√ºber, wie Sie ein Framework ohne Garbage Collector erstellen, effektiv unver√§nderlich sicherstellen k√∂nnen, ohne dass der Status aufgrund der Eigentumsregeln f√ºr Rust-Daten kopiert werden muss, und welche Funktionen bei der √úbersetzung von Rust in WebAssembly vorhanden sind. <br><br><img src="https://habrastorage.org/webt/dc/ro/wt/dcrowtesfnjfmpr7wl9j0suzjug.jpeg"><br><br>  <i>Der Beitrag wurde auf der Grundlage von Denis 'Bericht auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS 2018 Piter-</a> Konferenz vorbereitet.</i>  <i>Unter dem Schnitt - Video- und Textprotokoll des Berichts.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OqFOXMIwzTc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Denis Kolodin arbeitet f√ºr die Bitfury Group, ein Unternehmen, das verschiedene Blockchain-L√∂sungen entwickelt.</i>  <i>Seit √ºber zwei Jahren codiert es in Rust, einer Programmiersprache von Mozilla Research.</i>  <i>W√§hrend dieser Zeit gelang es Denis, diese Sprache gr√ºndlich zu studieren und damit verschiedene Systemanwendungen, ein Backend, zu entwickeln.</i>  <i>Im Zusammenhang mit dem Aufkommen des WebAssembly-Standards begann ich nun, auf das Front-End zu schauen.</i> <br><br><h2>  Agenda </h2><br>  Heute erfahren wir, was Eibe ist (der Name des Frameworks lautet genauso wie das englische Wort "Sie" - Sie; "Eibe" ist eine aus dem Englischen √ºbersetzte Eibe). <br><br>  Lassen Sie uns ein wenig √ºber architektonische Aspekte sprechen, dar√ºber, auf welchen Ideen das Framework basiert, √ºber die darin eingebetteten M√∂glichkeiten sowie √ºber die Funktionen, die Rust uns im Vergleich zu anderen Sprachen zus√§tzlich bietet. <br><br>  Am Ende werde ich Ihnen zeigen, wie Sie Yew und WebAssembly heute verwenden k√∂nnen. <br><br><h2>  Was ist Eibe? </h2><br>  Zuallererst ist dies WebAssembly, d.h.  ausf√ºhrbarer Bytecode, der in Browsern funktioniert.  Es wird ben√∂tigt, um komplexe Algorithmen auf der Benutzerseite auszuf√ºhren, z. B. Kryptographie, Codierung / Decodierung.  Es ist einfacher, dies in Systemsprachen zu implementieren, als Kr√ºcken zu schrauben. <br><br>  WebAssembly ist ein Standard, der von allen modernen Browsern klar beschrieben, verstanden und unterst√ºtzt wird.  Sie k√∂nnen verschiedene Programmiersprachen verwenden.  Dies ist vor allem deshalb interessant, weil Sie von der Community erstellten Code in anderen Sprachen wiederverwenden k√∂nnen. <br><br>  Wenn Sie m√∂chten, k√∂nnen Sie eine Anwendung vollst√§ndig in WebAssembly schreiben, und Yew erm√∂glicht Ihnen dies. Es ist jedoch wichtig, nicht zu vergessen, dass JavaScript auch in diesem Fall im Browser verbleibt.  WebAssembly muss vorbereitet werden. Nehmen Sie das Modul (WASM), f√ºgen Sie die Umgebung hinzu und f√ºhren Sie es aus.  Das hei√üt,  JavaScript ist unverzichtbar.  Daher ist WebAssembly eher eine Erweiterung als eine revolution√§re Alternative zu JS. <br><br><h3>  Wie die Entwicklung aussieht </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/9ef/8d5/b7f/9ef8d5b7ffb36029d2a4d840f9432980.png"><br><br>  Sie haben eine Quelle, es gibt einen Compiler.  Sie √ºbersetzen dies alles in ein Bin√§rformat und f√ºhren es in einem Browser aus.  Wenn der Browser alt ist und keine WebAssembly-Unterst√ºtzung bietet, ist emscripten erforderlich.  Dies ist ungef√§hr ein WebAssembly-Emulator f√ºr einen Browser. <br><br><h3>  Eibe - gebrauchsfertiges Wasm-Framework </h3><br>  Gehen wir weiter zu Yew.  Ich habe dieses Framework Ende letzten Jahres entwickelt.  Dann schrieb ich eine Art Kryptow√§hrungsanwendung auf Elm und sah mich mit der Tatsache konfrontiert, dass ich aufgrund von Sprachbeschr√§nkungen keine rekursive Struktur erstellen kann.  Und in diesem Moment dachte ich: In Rust w√§re mein Problem sehr leicht zu l√∂sen.  Und da ich 99% der Zeit in Rust schreibe und diese Sprache genau wegen ihrer Funktionen liebe, habe ich mich entschlossen zu experimentieren - um die Anwendung mit derselben Update-Funktion in Rust zu kompilieren. <br><br>  Die erste Skizze dauerte mehrere Stunden, ich musste herausfinden, wie man WebAssembly kompiliert.  Ich startete es und stellte fest, dass es in nur wenigen Stunden den Kern gelegt hatte, der sehr einfach zu entwickeln ist.  Ich habe nur ein paar Tage gebraucht, um alles auf das Minimum der Framework-Engine zu bringen. <br><br>  Ich habe es in Open Source gepostet, aber nicht erwartet, dass es popul√§r wird.  Heute hat er jedoch mehr als viertausend Sterne auf GitHub gesammelt.  Sie k√∂nnen das Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> anzeigen.  Es gibt viele Beispiele. <br><br>  Das Framework ist vollst√§ndig in Rust geschrieben.  Yew unterst√ºtzt das direkte Kompilieren in WebAssembly (wasm32-unknown-unknown target) ohne Emscripten.  Bei Bedarf k√∂nnen Sie emscripten durcharbeiten. <br><br><h2>  Architektur </h2><br>  Nun ein paar Worte dar√ºber, wie sich das Framework von traditionellen Ans√§tzen in der JavaScript-Welt unterscheidet. <br><br>  Zun√§chst zeige ich Ihnen, auf welche Spracheinschr√§nkungen ich in Elm gesto√üen bin.  Nehmen Sie den Fall, wenn es ein Modell gibt und es eine Meldung gibt, mit der Sie dieses Modell transformieren k√∂nnen. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Model =    { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>    }  <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Msg    = <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span>    | Decrement</code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> -&gt;     { value = model.value + <span class="hljs-number"><span class="hljs-number">1</span></span> }   Decrement -&gt;     { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = model.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  In Elm erstellen wir einfach ein neues Modell und zeigen es auf dem Bildschirm an.  Die vorherige Version des Modells bleibt unver√§ndert.  Warum konzentriere ich mich darauf?  Denn in Yew ist das Modell ver√§nderlich, und dies ist eine der h√§ufigsten Fragen.  Als n√§chstes werde ich erkl√§ren, warum dies getan wird. <br><br>  Anfangs folgte ich dem klassischen Pfad, als das Modell neu erstellt wurde.  Als sich das Framework entwickelte, sah ich, dass es keinen Sinn macht, die vorherige Version des Modells zu speichern.  Mit Rust k√∂nnen Sie die Lebensdauer aller Daten verfolgen, unabh√§ngig davon, ob sie ge√§ndert wurden oder nicht.  Und so kann ich das Modell sicher √§ndern, da ich wei√ü, dass Rust die Abwesenheit von Konflikten kontrolliert. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span></span> {   value: <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span></span> {   Increment,   Decrement, }</code> </pre><br><pre> <code class="hljs php">match msg {   Msg::Increment =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value += <span class="hljs-number"><span class="hljs-number">1</span></span>;   }   Msg::Decrement =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value -= <span class="hljs-number"><span class="hljs-number">1</span></span>;   } }</code> </pre><br>  Dies ist der erste Moment.  Der zweite Punkt: Warum brauchen wir die alte Version des Modells?  In derselben Ulme gibt es kaum ein Problem mit einem wettbewerbsf√§higen Zugang.  Das alte Modell wird nur ben√∂tigt, um zu verstehen, wann gerendert werden muss.  Das Bewusstsein dieses Augenblicks erlaubte mir, unver√§nderlich loszuwerden und die alte Version nicht beizubehalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/ff5/d94/c98ff5d946992d46ba910e36375b4fc7.png"><br><br>  Schauen Sie sich die Option an, wenn wir die <code>update</code> und zwei Felder haben - <code>value</code> und <code>name</code> .  Es gibt einen Wert, der gespeichert wird, wenn wir Daten in das <code>input</code> eingeben.  Das Modell √§ndert sich. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/a12/d41/140a12d4106fb15b17204d547de29b82.png"><br><br>  Es ist wichtig, dass der <code>value</code> beim Rendern nicht ber√ºcksichtigt wird.  Und so k√∂nnen wir es so oft √§ndern, wie wir m√∂chten.  Wir m√ºssen den DOM-Baum jedoch nicht beeinflussen und diese √Ñnderungen nicht initiieren. <br><br>  Dies f√ºhrte mich zu der Idee, dass nur der Entwickler den richtigen Moment kennen kann, in dem das Rendern wirklich initiiert werden muss.  Zum Initiieren begann ich, das Flag - nur einen booleschen Wert - <code>ShouldRender</code> , das signalisiert, dass sich das Modell ge√§ndert hat und wir mit dem Rendern beginnen m√ºssen.  Gleichzeitig gibt es keinen Overhead f√ºr st√§ndige Vergleiche, es gibt keinen Speicherverbrauch - in Yew geschriebene Anwendungen sind am effektivsten. <br><br>  Im obigen Beispiel gab es √ºberhaupt keine Speicherzuordnung au√üer der Nachricht, die generiert und gesendet wurde.  Das Modell behielt seinen Zustand bei, was sich nur mit Hilfe einer Flagge im Rendering widerspiegelte. <br><br><h2>  Die M√∂glichkeiten </h2><br>  Das Schreiben eines Frameworks, das in WebAssembly funktioniert, ist keine leichte Aufgabe.  Wir haben JavaScript, aber es sollte eine Art Umgebung schaffen, mit der interagiert werden muss, und dies ist eine enorme Menge an Arbeit.  Die urspr√ºngliche Version dieser Bundles sah ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ab/5aa/f25/3ab5aaf257e0a6a9f611e885dba4bd8d.png"><br><br>  Ich habe eine Demo von einem anderen Projekt genommen.  Es gibt viele Projekte, die diesen Weg gehen, aber es f√ºhrt schnell zu einer Sackgasse.  Immerhin ist das Framework eine ziemlich gro√üe Entwicklung und Sie m√ºssen viel Docking-Code schreiben.  Ich fing an, Bibliotheken in Rust zu benutzen, die Kisten genannt werden, insbesondere die <code>Stdweb</code> . <br><br><h3>  Integriertes JS </h3><br>  Mit Hilfe von Rust-Makros k√∂nnen Sie die Sprache erweitern - wir k√∂nnen JavaScript-Teile in den Rust-Code einbetten. Dies ist eine sehr n√ºtzliche Funktion der Sprache. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = js! {   var callback = @{callback};   var action = function() {       callback();   };   var delay = @{ms};   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       interval_id: setInterval(action, delay),       callback: callback,   }; };</code> </pre><br>  Durch die Verwendung von Makros und Stdweb konnte ich schnell und effizient alle erforderlichen Links schreiben. <br><br><h3>  Jsx-Vorlagen </h3><br>  Zuerst ging ich den Elm-Pfad entlang und begann, Vorlagen zu verwenden, die mit Code implementiert wurden. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {   nav(<span class="hljs-string"><span class="hljs-string">"nav"</span></span>, (<span class="hljs-string"><span class="hljs-string">"menu"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[       button(<span class="hljs-string"><span class="hljs-string">"button"</span></span>, (), (<span class="hljs-string"><span class="hljs-string">"onclick"</span></span>, || Msg::Clicked)),       tag(<span class="hljs-string"><span class="hljs-string">"section"</span></span>, (<span class="hljs-string"><span class="hljs-string">"ontop"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[           p(<span class="hljs-string"><span class="hljs-string">"My text..."</span></span>)       ])   ]) }</code> </pre><br>  Ich war noch nie ein Unterst√ºtzer von React.  Aber als ich anfing, mein Framework zu schreiben, wurde mir klar, dass JSX in React eine sehr coole Sache ist.  Hier finden Sie eine sehr praktische Darstellung von Codevorlagen. <br><br>  Als Ergebnis habe ich ein Makro f√ºr Rust verwendet und direkt in Rust die M√∂glichkeit implementiert, HTML-Markups zu schreiben, die sofort virtuelle Baumelemente generieren. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Renderable&lt;Context, Model&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Model {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {       html! {           &lt;div&gt;               &lt;nav class=<span class="hljs-string"><span class="hljs-string">"menu"</span></span>,&gt;                   &lt;button onclick=|_| Msg::Increment,&gt;{ <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> }&lt;/button&gt;                   &lt;button onclick=|_| Msg::Decrement,&gt;{ <span class="hljs-string"><span class="hljs-string">"Decrement"</span></span> }&lt;/button&gt;               &lt;/nav&gt;               &lt;p&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value }&lt;/p&gt;               &lt;p&gt;{ Local::now() }&lt;/p&gt;           &lt;/div&gt;       }   } }</code> </pre><br>  Wir k√∂nnen sagen, dass JSX-√§hnliche Vorlagen reine Codevorlagen sind, aber auf Steroiden.  Sie werden in einem praktischen Format dargestellt.  Beachten Sie auch, dass ich hier einen Rust-Ausdruck direkt in die Schaltfl√§che einf√ºge (Rust-Ausdruck kann in diese Vorlagen eingef√ºgt werden).  Dies erm√∂glicht Ihnen eine sehr enge Integration. <br><br><h3>  Ziemlich strukturierte Komponenten </h3><br>  Dann begann ich Vorlagen zu entwickeln und erkannte die M√∂glichkeit, Komponenten zu verwenden.  Dies ist das erste Problem, das im Repository aufgetreten ist.  Ich habe Komponenten implementiert, die im Vorlagencode verwendet werden k√∂nnen.  Sie deklarieren einfach eine ehrliche Struktur in Rust und schreiben einige Eigenschaften daf√ºr.  Diese Eigenschaften k√∂nnen direkt aus der Vorlage festgelegt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b9/3d0/d37/9b93d0d3797e46f73650b00689315009.png"><br><br>  Ich stelle noch einmal fest, dass es wichtig ist, dass diese Vorlagen ehrlich generierter Rust-Code sind.  Daher wird jeder Fehler hier vom Compiler bemerkt.  Das hei√üt,  Sie k√∂nnen sich nicht irren, wie es bei der JavaScript-Entwicklung h√§ufig der Fall ist. <br><br><h3>  Typisierte Bereiche </h3><br>  Ein weiteres interessantes Feature ist, dass eine Komponente, wenn sie in einer anderen Komponente platziert wird, den Nachrichtentyp des √ºbergeordneten Elements sehen kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/933/831/4cb/9338314cb1560b2172c6ab11bbff7977.png"><br><br>  Der Compiler bindet diese Typen starr und l√§sst Sie keinen Fehler machen.  Bei der Verarbeitung von Ereignissen m√ºssen Nachrichten, die die Komponente erwartet oder senden kann, vollst√§ndig mit dem √ºbergeordneten Element √ºbereinstimmen. <br><br><h3>  Weitere Funktionen </h3><br>  Ich habe eine Implementierung von Rust direkt auf das Framework √ºbertragen, mit dem Sie bequem verschiedene Serialisierungs- / Deserialisierungsformate verwenden k√∂nnen (mit zus√§tzlichen Wrappern).  Unten sehen Sie ein Beispiel: Wir gehen zum lokalen Speicher und geben beim Wiederherstellen der Daten einen bestimmten Wrapper an - was wir hier erwarten, ist json. <br><br><pre> <code class="rust hljs">Msg::Store =&gt; {   context.local_storage.store(KEY, Json(&amp;model.clients)); } Msg::Restore =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Json(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(clients)) = context.local_storage.restore(KEY) {        model.clients = clients;   } }</code> </pre><br>  Es kann ein beliebiges Format sein, einschlie√ülich Bin√§rformat.  Dementsprechend werden Serialisierung und Deserialisierung transparent und bequem. <br><br>  Die Idee einer weiteren Gelegenheit, die ich implementiert habe, kam von Benutzern des Frameworks.  Sie baten um Fragmente.  Und hier bin ich auf eine interessante Sache gesto√üen.  Als ich in JavaScript die M√∂glichkeit sah, Fragmente in den DOM-Baum einzuf√ºgen, entschied ich zun√§chst, dass es sehr einfach sein w√ºrde, eine solche Funktion in meinem Framework zu implementieren.  Aber ich habe diese Option ausprobiert und es stellte sich heraus, dass sie nicht funktioniert.  Ich musste es herausfinden, auf diesem Baum gehen, sehen, was sich dort ge√§ndert hatte usw. <br><br>  Das Yew-Framework verwendet einen virtuellen DOM-Baum, in dem zun√§chst alles vorhanden ist.  Wenn einige √Ñnderungen an der Vorlage vorgenommen werden, werden diese zu Patches, die den gerenderten DOM-Baum bereits √§ndern. <br><br><pre> <code class="hljs xml">html! {   <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/&gt;</span></span> }</code> </pre><br><h2>  Zus√§tzliche Vorteile </h2><br>  Rust bietet viel mehr verschiedene leistungsstarke Funktionen, ich werde nur √ºber die wichtigsten sprechen. <br><br><h3>  Dienstleistungen: Interaktion mit der Au√üenwelt </h3><br>  Die erste Gelegenheit, √ºber die ich sprechen m√∂chte, sind Dienstleistungen.  Sie k√∂nnen die erforderlichen Funktionen in Form eines Dienstes beschreiben, als Kiste ver√∂ffentlichen und wiederverwenden. <br><br>  In Rust ist die F√§higkeit zum Erstellen von Bibliotheken, deren Integration, Andocken und Kleben sehr gut implementiert.  Tats√§chlich k√∂nnen Sie verschiedene APIs f√ºr die Interaktion mit Ihrem Dienst erstellen, einschlie√ülich JavaScript-APIs.  Gleichzeitig kann das Framework mit der Au√üenwelt interagieren, obwohl es innerhalb der WebAssembly-Laufzeit funktioniert. <br><br>  Beispiele f√ºr Dienstleistungen: <br><br><ul><li>  TimeOutService; <br></li><li>  IntervalService; <br></li><li>  FetchService; <br></li><li>  WebSocketService; <br></li><li>  Kundenspezifische Dienstleistungen ... <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rostdienste</a> und Kisten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">crates.io</a> . <br><br><h3>  Kontext: Zustandsanforderungen </h3><br>  Eine andere Sache, die ich im Framework implementiert habe, ist nicht ganz traditionell, ist der Kontext.  React hat eine Kontext-API, aber ich habe Context in einem anderen Sinne verwendet.  Das Yew-Framework besteht aus den Komponenten, die Sie erstellen, und Context ist ein globaler Status.  Komponenten ber√ºcksichtigen diesen globalen Status m√∂glicherweise nicht, stellen jedoch m√∂glicherweise einige Anforderungen, sodass die globale Entit√§t einige Kriterien erf√ºllt. <br><br>  Angenommen, unsere abstrakte Komponente erfordert die F√§higkeit, etwas in S3 hochzuladen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f6/477/776/3f6477776d227c4b7abcf64be2f17f5c.png"><br><br>  Es ist unten zu sehen, dass es diesen Upload verwendet, d.h.  sendet Daten an S3.  Ein solches Bauteil kann in Form eines Racks ausgelegt werden.  Der Benutzer, der diese Komponente herunterl√§dt und in der Vorlage zu seiner Anwendung hinzuf√ºgt, wird auf einen Fehler sto√üen. Der Compiler fragt ihn, wo die S3-Unterst√ºtzung ist.  Der Benutzer muss diese Unterst√ºtzung implementieren.  Danach beginnt die Komponente automatisch ein erf√ºlltes Leben zu f√ºhren. <br><br>  Wo wird es gebraucht?  Stellen Sie sich vor: Sie erstellen eine Komponente mit cleverer Kryptografie.  Er hat Anforderungen, dass der umgebende Kontext es ihm erm√∂glichen soll, sich irgendwo anzumelden.  Sie m√ºssen lediglich ein Autorisierungsformular in die Vorlage einf√ºgen und in Ihrem Kontext die Verbindung mit Ihrem Dienst implementieren.  Das hei√üt,  Es werden buchst√§blich drei Codezeilen sein.  Danach beginnt die Komponente zu arbeiten. <br><br>  Stellen Sie sich vor, wir haben Dutzende verschiedener Komponenten.  Und alle haben die gleichen Anforderungen.  Auf diese Weise k√∂nnen Sie eine Funktion einmal implementieren, um alle Komponenten wiederzubeleben und die ben√∂tigten Daten abzurufen.  Direkt aus dem Zusammenhang.  Und der Compiler l√§sst Sie keinen Fehler machen: Wenn Sie keine Schnittstelle haben, f√ºr die eine Komponente erforderlich ist, funktioniert nichts. <br><br>  Daher k√∂nnen Sie leicht sehr knifflige Schaltfl√§chen erstellen, die nach einer API oder anderen Funktionen fragen.  Dank Rust und dem System dieser Schnittstellen (in Rust werden sie als Merkmal bezeichnet) k√∂nnen Komponentenanforderungen deklariert werden. <br><br><h3>  Der Compiler l√§sst Sie keinen Fehler machen </h3><br>  Stellen Sie sich vor, wir erstellen eine Komponente mit einigen Eigenschaften, von denen eine die M√∂glichkeit ist, den R√ºckruf zur√ºckzusetzen.  Zum Beispiel haben wir die Eigenschaft festgelegt und einen Buchstaben im Namen √ºbersehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/829/d84/93d/829d8493d52ccff0299dc030661c5b37.png"><br><br>  Rust versucht zu kompilieren und reagiert schnell.  Er sagt, dass wir uns geirrt haben und es keine solche Eigenschaft gibt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02d/08d/ef7/02d08def74b01670bc6b4b0695f5cc2f.png"><br><br>  Wie Sie sehen, verwendet Rust diese Vorlage direkt und kann alle Fehler im Makro rendern.  Er sagt Ihnen, wie die Immobilie wirklich hei√üen soll.  Wenn Sie den Compiler bestanden haben, treten keine dummen Laufzeitfehler wie Tippfehler auf. <br><br>  Stellen Sie sich nun vor, wir haben eine Schaltfl√§che, die unseren globalen Kontext auffordert, eine Verbindung zu S3 herstellen zu k√∂nnen.  Erstellen Sie einen Kontext, der keine S3-Unterst√ºtzung implementiert.  Mal sehen, was passiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a50/8d6/c7e/a508d6c7e4470c16f7890f36f0bd4135.png"><br><br>  Der Compiler meldet, dass wir eine Schaltfl√§che eingef√ºgt haben, diese Schnittstelle jedoch nicht f√ºr den Kontext implementiert ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/63b/4f9/790/63b4f97902e2460ced9cbbdd0f820f23.png"><br><br>  Es bleibt nur, in den Editor zu gehen, im Kontext einen Link zu Amazon hinzuzuf√ºgen, und alles wird beginnen.  Sie k√∂nnen vorgefertigte Services mit einer Art API erstellen, dann einfach zum Kontext hinzuf√ºgen, einen Link dazu ersetzen und die Komponente wird sofort zum Leben erweckt.  Auf diese Weise k√∂nnen Sie sehr coole Dinge tun: Sie f√ºgen Komponenten hinzu, erstellen einen Kontext und f√ºllen ihn mit Diensten.  Und das alles funktioniert vollautomatisch, es sind nur minimale Anstrengungen erforderlich, um alles zusammenzubinden. <br><br><h2>  Wie fange ich mit Yew an? </h2><br>  Wo soll ich anfangen, wenn Sie versuchen m√∂chten, eine WebAssembly-Anwendung zu kompilieren?  Und wie kann dies mit dem Yew-Framework erreicht werden? <br><br><h3>  Rust-to-Wasm-Zusammenstellung </h3><br>  Zuerst m√ºssen Sie den Compiler installieren.  Hierf√ºr gibt es ein Rostup-Tool: <br><br> <code>curl https://sh.rustup.rs -sSf | sh <br></code> <br>  Au√üerdem ben√∂tigen Sie m√∂glicherweise Emscripten.  Wof√ºr kann es n√ºtzlich sein?  Die meisten Bibliotheken, die f√ºr Systemprogrammiersprachen geschrieben wurden, insbesondere f√ºr Rust (urspr√ºnglich ein System), wurden f√ºr Linux, Windows und andere vollwertige Betriebssysteme entwickelt.  Offensichtlich hat der Browser nicht viele Funktionen. <br><br>  Beispielsweise erfolgt die Zufallszahlengenerierung in einem Browser nicht auf die gleiche Weise wie unter Linux.  emscripten ist n√ºtzlich, wenn Sie Bibliotheken verwenden m√∂chten, f√ºr die eine System-API erforderlich ist. <br><br>  Bibliotheken und die gesamte Infrastruktur wechseln leise zu einer ehrlichen WebAssembly, und emscripten ist nicht mehr erforderlich (Sie verwenden JavaScript-basierte Funktionen, um Zufallszahlen und andere Dinge zu generieren). Wenn Sie jedoch etwas erstellen m√ºssen, das im Browser √ºberhaupt nicht unterst√ºtzt wird, k√∂nnen Sie nicht auf emscripten verzichten . <br><br>  Ich empfehle auch die Verwendung von Cargo-Web: <br><br> <code>cargo install cargo-web <br></code> <br>  Es ist m√∂glich, WebAssembly ohne zus√§tzliche Dienstprogramme zu kompilieren.  Cargo-Web ist jedoch ein cooles Tool, das verschiedene Dinge bietet, die f√ºr JavaScript-Entwickler n√ºtzlich sind.  Insbesondere werden die Dateien √ºberwacht: Wenn Sie √Ñnderungen vornehmen, wird sofort mit dem Kompilieren begonnen (der Compiler bietet solche Funktionen nicht an).  In diesem Fall k√∂nnen Sie mit Cargo-Web die Entwicklung beschleunigen.  Es gibt verschiedene Build-Systeme f√ºr Rust, aber die Fracht macht 99,9% aller Projekte aus. <br><br>  Ein neues Projekt wird wie folgt erstellt: <br><br> <code>cargo new --bin my-project <br></code> <br> <code>[package] <br> name = "my-project" <br> version = "0.1.0" <br> <br> [dependencies] <br> yew = "0.3.0" <br></code> <br>  Dann starten Sie einfach das Projekt: <br><br> <code>cargo web start --target wasm32-unknown-unknown <br></code> <br>  Ich gab ein Beispiel f√ºr ehrliche WebAssembly.  Wenn Sie unter emscripten kompilieren m√ºssen (der Rost-Compiler kann emscripten selbst verbinden), k√∂nnen Sie das Wort <code>emscripten</code> in das allerletzte <code>unknown</code> Element einf√ºgen, wodurch Sie mehr Kisten verwenden k√∂nnen.  Vergessen Sie nicht, dass emscripten ein ziemlich gro√ües zus√§tzliches Kit f√ºr Ihre Datei ist.  Daher ist es besser, ehrlichen WebAssembly-Code zu schreiben. <br><br><h3>  Bestehende Einschr√§nkungen </h3><br>  Jeder, der Erfahrung im Codieren in Systemprogrammiersprachen hat, kann durch die im Framework vorhandenen Einschr√§nkungen frustriert sein.  Nicht alle Bibliotheken k√∂nnen in WebAssembly verwendet werden.  In einer JavaScript-Umgebung gibt es beispielsweise keine Threads.  WebAssembly deklariert dies im Prinzip nicht, und nat√ºrlich k√∂nnen Sie es in einer Umgebung mit mehreren Threads verwenden (dies ist eine offene Frage), aber JavaScript ist immer noch eine Umgebung mit einem Thread.  Ja, es gibt Arbeiter, aber das ist Isolation, also wird es dort keine Str√∂me geben. <br><br>  Es scheint, dass Sie ohne Fl√ºsse leben k√∂nnen.  Wenn Sie jedoch threadbasierte Bibliotheken verwenden m√∂chten, z. B. eine Laufzeit hinzuf√ºgen m√∂chten, wird dies m√∂glicherweise nicht gestartet. <br><br>  Au√üerdem gibt es keine System-API, au√üer der, die Sie von JavaScript nach WebAssembly √ºbertragen.  Daher werden viele Bibliotheken nicht portiert.  Sie k√∂nnen keine Dateien direkt schreiben und lesen, Sockets k√∂nnen nicht ge√∂ffnet werden und Sie k√∂nnen nicht in das Netzwerk schreiben.  Wenn Sie beispielsweise einen Web-Socket erstellen m√∂chten, m√ºssen Sie ihn aus JavaScript ziehen. <br><br>  Ein weiterer Nachteil ist, dass der WASM-Debugger vorhanden ist, aber niemand ihn gesehen hat.  Es befindet sich immer noch in einem so rohen Zustand, dass es f√ºr Sie wahrscheinlich nicht n√ºtzlich ist.  Das Debuggen von WebAssembly ist daher eine schwierige Frage. <br><br>  Bei Verwendung von Rust sind fast alle Laufzeitprobleme mit Fehlern in der Gesch√§ftslogik verbunden und k√∂nnen leicht behoben werden.  Es treten jedoch sehr selten Fehler auf niedriger Ebene auf - beispielsweise f√ºhrt eine der Bibliotheken das falsche Andocken durch - und dies ist bereits eine schwierige Frage.  Zum Beispiel gibt es im Moment ein solches Problem: Wenn ich das Framework mit emscripten kompiliere und es eine variable Speicherzelle gibt, deren Besitz weggenommen wird, wird sie verschenkt, emscripten f√§llt irgendwo in der Mitte auseinander (und ich bin mir nicht einmal sicher, ob es emscripten ist).  Wenn Sie irgendwo in der Middleware auf einem niedrigen Level auf ein Problem sto√üen, ist es im Moment schwierig, es zu beheben. <br><br><h2>  Die Zukunft des Frameworks </h2><br>  Wie wird sich Yew weiterentwickeln?  Ich sehe seinen Hauptzweck in der Schaffung monolithischer Komponenten.  Sie haben eine kompilierte WebAssembly-Datei und f√ºgen sie einfach in die Anwendung ein.  Beispielsweise kann es kryptografische Funktionen, Rendering oder Bearbeitung bereitstellen. <br><br><h3>  JS-Integration </h3><br>  Die Integration mit JavaScript wird verst√§rkt.  JavaScript hat eine gro√üe Anzahl cooler Bibliotheken geschrieben, die einfach zu bedienen sind.  Und es gibt Beispiele im Repository, in denen ich zeige, wie Sie die vorhandene JavaScript-Bibliothek direkt aus dem Yew-Framework verwenden k√∂nnen. <br><br><h3>  Typisiertes CSS </h3><br>  Da Rust verwendet wird, ist es offensichtlich, dass Sie typisiertes CSS hinzuf√ºgen k√∂nnen, das mit demselben Makro wie im Beispiel einer JSX-√§hnlichen Vorlagen-Engine generiert werden kann.  In diesem Fall pr√ºft der Compiler beispielsweise, ob Sie anstelle der Farbe ein anderes Attribut zugewiesen haben.  Dies spart Tonnen Ihrer Zeit. <br><br><h3>  Fertige Komponenten </h3><br>  Ich m√∂chte auch gebrauchsfertige Komponenten erstellen.  Auf dem Framework k√∂nnen Sie Risse machen, die beispielsweise eine Reihe von Schaltfl√§chen oder Elementen enthalten, die als Bibliothek verbunden, zu den Vorlagen hinzugef√ºgt und verwendet werden. <br><br><h3>  Leistungsverbesserung in privaten F√§llen </h3><br>  Leistung ist ein sehr heikles und komplexes Thema.  Ist WebAssembly schneller als JavaScript?  Ich habe keinen Beweis f√ºr eine positive oder negative Antwort.  Es f√ºhlt sich so an und nach einigen sehr einfachen Tests, die ich durchgef√ºhrt habe, ist WebAssembly sehr schnell.  Und ich bin voll und ganz davon √ºberzeugt, dass die Leistung h√∂her sein wird als die von JavaScript, nur weil es sich um einen Bytecode auf niedriger Ebene handelt, bei dem keine Speicherzuweisung erforderlich ist und viele andere Momente Ressourcen erfordern. <br><br><h3>  Weitere Mitwirkende </h3><br>  Ich m√∂chte mehr Mitwirkende gewinnen.  Die T√ºren zur Teilnahme am Framework sind immer offen.  Jeder, der etwas aktualisieren, den Kernel verstehen und die Tools, mit denen eine gro√üe Anzahl von Entwicklern arbeitet, transformieren m√∂chte, kann problemlos eine Verbindung herstellen und seine eigenen √Ñnderungen anbieten. <br><br>  Das Projekt wurde bereits von vielen Mitwirkenden besucht.  Derzeit gibt es jedoch keine Core-Mitwirkenden, da Sie hierf√ºr den Entwicklungsvektor des Frameworks verstehen m√ºssen, der jedoch noch nicht klar formuliert wurde.  Aber es gibt ein R√ºckgrat, Leute, die sich mit Eibe sehr gut auskennen - ungef√§hr 30 Leute.  Wenn Sie dem Framework auch etwas hinzuf√ºgen m√∂chten, senden Sie bitte immer eine Pull-Anfrage. <br><br><h3>  Die Dokumentation </h3><br>  Ein obligatorischer Punkt in meinen Pl√§nen ist die Erstellung einer gro√üen Menge an Dokumentation zum Schreiben von Anwendungen auf Yew.  Offensichtlich unterscheidet sich der Entwicklungsansatz in diesem Fall von dem, was wir in React and Elm gesehen haben. <br><br>  Manchmal zeigen mir Jungs interessante F√§lle, wie man das Framework benutzt.  Das Erstellen eines Frameworks ist jedoch nicht dasselbe wie professionelles Schreiben.  Praktiken zur Verwendung des Frameworks werden noch entwickelt. <br><br>  Probieren Sie es aus, installieren Sie Rust und erweitern Sie Ihre F√§higkeiten als Entwickler.  Das Beherrschen von WebAssembly wird f√ºr jeden von uns n√ºtzlich sein, da die Erstellung sehr komplexer Anwendungen der Moment ist, auf den wir lange gewartet haben.  Mit anderen Worten, bei WebAssembly handelt es sich nicht nur um einen Webbrowser, sondern im Allgemeinen um eine Laufzeit, die sich definitiv entwickelt und noch aktiver entwickelt. <br><br><blockquote>  Wenn Ihnen der Bericht gefallen hat, achten Sie darauf: Am 24. und 25. November findet in Moskau ein neues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS</a> statt, und es wird dort auch viele interessante Dinge geben.      ‚Äî  ,       ( <b>  </b>  ). </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422253/">https://habr.com/ru/post/de422253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422239/index.html">So starten Sie die Bereitstellung f√ºr Millionen von Benutzern</a></li>
<li><a href="../de422241/index.html">KPI - Drei stolpernde Buchstaben</a></li>
<li><a href="../de422243/index.html">CRM f√ºr kleine Unternehmen. Ben√∂tigen Sie es</a></li>
<li><a href="../de422247/index.html">OK Instant Games Cup. Wettbewerb f√ºr HTML5-Spieleentwickler</a></li>
<li><a href="../de422251/index.html">"Ein hohes Ma√ü an Selbstdisziplin." Jeffrey Richter √ºber das Codieren, Schreiben von B√ºchern und das Erstellen eigener Unternehmen</a></li>
<li><a href="../de422255/index.html">Charaktererstellung in Blender und Unity</a></li>
<li><a href="../de422257/index.html">PocketBook 627 Reader Review: Mittelklasse mit Hintergrundbeleuchtung, WLAN und Cloud-Service</a></li>
<li><a href="../de422259/index.html">Grundlegende Datenstrukturen. Materiel. Die Grundlagen</a></li>
<li><a href="../de422261/index.html">Zextras Powerstore- und Tiering-Systeme</a></li>
<li><a href="../de422263/index.html">"Dormammu, ich war einverstanden": ein Algorithmus f√ºr die f√ºr beide Seiten vorteilhafte Zusammenarbeit mit einer Person</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>