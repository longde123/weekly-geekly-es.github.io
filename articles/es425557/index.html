<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛰️ 😉 ☪️ Curso MIT "Seguridad de sistemas informáticos". Lección 10: Ejecución simbólica, parte 1 🐅 🖐🏻 ♑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnología de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas informáticos". Nikolai Zeldovich, James Mickens. Año 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas informáticos". Lección 10: Ejecución simbólica, parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425557/"><h3>  Instituto de Tecnología de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas informáticos".  Nikolai Zeldovich, James Mickens.  Año 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementación de sistemas informáticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y técnicas de seguridad basadas en trabajos científicos recientes.  Los temas incluyen seguridad del sistema operativo (SO), características, gestión del flujo de información, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lección 1: "Introducción: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 3: “Desbordamientos del búfer: exploits y protección” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 4: “Separación de privilegios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 5: “¿De dónde vienen los sistemas de seguridad?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> <br>  Lección 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 7: “Sandbox de cliente nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 8: "Modelo de seguridad de red" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 9: "Seguridad de aplicaciones web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 10: “Ejecución simbólica” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Buenos días a todos, soy Armando Solar-Lesam y hoy daré una conferencia sobre actuación simbólica.  ¿Quién de los presentes aquí está familiarizado con este término o ha oído hablar de esto antes?  Solo quiero tener una idea de nuestra audiencia.  Entonces comencemos.  Dejé caer mi computadora portátil varias veces, por lo que lleva mucho tiempo cargarla. <br><br><img src="https://habrastorage.org/webt/t1/d0/ik/t1d0ikzwlt1dcgcg-1ifxfv-z3w.jpeg"><br><br>  La ejecución simbólica es el caballo de batalla del análisis moderno de programas.  Este es uno de los métodos que surgió de la investigación y luego comenzó a usarse en muchas aplicaciones.  Por ejemplo, hoy en Microsoft hay un sistema llamado SAGE, que funciona con una gran cantidad de software importante de Microsoft, que va desde Power Point y termina con el propio Windows, para encontrar realmente problemas de seguridad y vulnerabilidades. <br><br>  Hay muchos proyectos académicos que han tenido un gran impacto en el mundo real, como la detección de errores importantes en el software de código abierto mediante la ejecución simbólica.  Y la belleza de la ejecución simbólica como técnica es que, en comparación con las pruebas, le brinda la oportunidad de imaginar cómo se comportará su programa con un conjunto potencialmente interminable de posibles datos de entrada.  Esto nos permite investigar conjuntos de datos de entrada, lo que sería completamente poco práctico y poco práctico de investigar, por ejemplo, mediante pruebas aleatorias, incluso si hay una gran cantidad de evaluadores.  Por otro lado, en comparación con los métodos más tradicionales de análisis estático, tiene la siguiente ventaja.  Al investigar un problema, la ejecución simbólica puede crear entradas y trazas, una ruta de ejecución que se puede ejecutar en un programa real y ejecutar este programa en función de esta entrada.  Y después de eso, podemos identificar el error real y comenzar a solucionarlo utilizando los mecanismos de depuración tradicionales.  Y esto es especialmente valioso cuando se encuentra en un entorno de desarrollo industrial donde probablemente no tenga tiempo para ocuparse de cada pequeño problema en su código. <br><br>  Por ejemplo, realmente desea poder distinguir entre problemas reales y falsos positivos.  ¿Cómo funciona esto? <br><br>  Para comprender realmente cómo funciona esto, es útil comenzar con la ejecución normal.  Si pensamos en la ejecución simbólica como una generalización de la ejecución simple y tradicional, tiene sentido saber cómo se ve.  Por lo tanto, voy a usar este programa muy simple como una ilustración de muchas cosas de las que hablaremos hoy. <br><br><img src="https://habrastorage.org/webt/1-/rv/gy/1-rvgymnpffellnl2jnb55j790i.jpeg"><br><br>  Aquí tenemos un extracto de un código muy simple de varias ramas y la declaración de que si, bajo alguna condición, el valor t &lt;x, entonces esta es una declaración falsa.  Queremos averiguar si alguna vez se puede plantear esta afirmación.  ¿Es posible?  ¿Hay alguna entrada que haga que esta declaración falle? <br><br>  Una de las cosas que puedo hacer es verificar la ejecución de este programa utilizando valores específicos de datos de entrada como ejemplo.  Supongamos que usamos una entrada para la cual X = 4 e Y = 4. El valor de T es cero, como se anunció al comienzo del programa. <br><br>  Entonces, antes de llegar a la ejecución normal, descubramos cuál es el punto importante aquí.  Necesitamos tener una idea del estado del programa, ¿verdad?  Ya sea que estemos realizando una ejecución normal o una ejecución simbólica, necesitamos tener alguna forma de caracterizar el estado del programa.  En este caso, es un programa tan simple que no usa el montón, no usa la pila y no hay llamadas de función aquí. <br><br>  Por lo tanto, el estado puede caracterizarse completamente por estas tres variables, junto con saber dónde estoy en el programa.  Por lo tanto, si comienzo la ejecución desde 4, 4 y 0 y llego al final de la rama, entonces comprobaré la expresión: ¿4 es mayor que 4?  Obviamente no. <br>  Ahora voy a ejecutar el programa en T = Y, es decir, T ya no es 0, pero tiene un valor de 4. Este es el estado actual de mi programa, y ​​ahora puedo evaluar esta rama. <br><br><img src="https://habrastorage.org/webt/xw/j1/pb/xwj1pbkpvyvv3vc_b3urir5ob-g.jpeg"><br><br>  ¿Es cierto que T &lt;X?  No  Esquivamos la bala, la declaración falsa no funcionó.  No hubo problemas en esta ejecución privada. <br><br>  Pero esto no nos dice nada sobre ninguna otra ejecución.  Sabemos que con los valores X = 4 e Y = 4, el programa no fallará.  Pero esto no nos dice nada sobre lo que sucederá si los valores de entrada son 2 y 1. <br><br><img src="https://habrastorage.org/webt/8w/lv/vf/8wlvvfh7n43vvl2jaajhjd2opcy.jpeg"><br><br>  Con estos valores de entrada, la ejecución será diferente.  Esta vez vemos que T = X, y después de ejecutar esta línea T tomará un valor igual a 2. ¿Hay algún problema en esta ejecución?  ¿Habrá un error de aserción con tal entrada? <br><br>  Bueno, veamos.  Entonces, si T es 2 y X es 2, entonces T no es menor que X. Parece que nuevamente esquivamos la bala.  Derecho?  Entonces, aquí tenemos dos valores de entrada específicos en los que el programa funciona sin errores.  Pero en realidad, no nos dice nada sobre ningún otro valor de entrada. <br><br>  Entonces, la idea de la ejecución simbólica es que queremos ir más allá de la ejecución de un programa con un conjunto de datos de entrada.  Queremos poder hablar sobre el comportamiento del programa cuando se utiliza un conjunto de datos muy grande, en algunos casos, un número infinito de posibles valores de entrada.  La idea principal de esto es la siguiente. <br><br><img src="https://habrastorage.org/webt/wn/k5/fs/wnk5fs-evom1hqqeh8vnpppxezk.jpeg"><br><br>  Para un programa como este, su estado está determinado por el valor de estas tres variables diferentes: X, Y y T, y saber dónde estoy en este momento en el programa.  Pero ahora, en lugar de los valores específicos para X e Y, tendré un valor simbólico, solo una variable.  Una variable que me permite nombrar este valor, que el usuario usa como entrada.  Esto significa que el estado de mi programa ya no se caracteriza por hacer coincidir nombres de variables con valores específicos.  Ahora esta es una asignación de nombres de variables a estos valores simbólicos. <br><br>  El valor simbólico se puede considerar como una fórmula.  En este caso, la fórmula para X es igual a X y la fórmula para Y es simplemente Y, y para T en realidad es igual a 0. Sabemos que para cada valor de entrada no importa lo que haga.  El valor de T después de la primera instrucción será 0. <br><br>  Ahí es donde se pone interesante ahora.  Llegamos a esta rama, que dice que si X es mayor que Y, iremos en una dirección.  Si X es menor o igual que Y, iremos en la otra dirección. <br><br>  ¿Sabemos algo sobre X e Y?  ¿Qué sabemos sobre ellos?  Al menos sabemos su tipo, sabemos que variarán de min int a max int, pero eso es todo lo que sabemos sobre ellos.  Resulta que la información que conocemos sobre ellos no es suficiente para decir en qué dirección puede ir esta rama.  Ella puede ir en cualquier dirección <br>  Hay muchas cosas que podemos hacer, pero ¿qué podemos hacer en este momento?  Intenta hacer la suposición más salvaje. <br><br><img src="https://habrastorage.org/webt/eu/a9/c-/eua9c-jo64thlkjghlaj3e9x6rs.jpeg"><br><br>  <b>Audiencia:</b> podemos rastrear la ejecución del programa en ambas ramas. <br><br>  <b>Profesor:</b> sí, podemos seguir el progreso en ambas ramas.  Lanza una moneda y, según cómo caiga, elige una u otra rama. <br><br>  Entonces, si queremos seguir ambas ramas, primero debemos seguir una y luego la otra, ¿verdad?  Supongamos que comenzamos con esta rama - T = X.  Sabemos que si llegamos a este lugar, T tendrá el mismo significado que X. No sabemos cuál es este valor, pero tenemos un nombre, este es el guión X. <br><br><img src="https://habrastorage.org/webt/2l/zy/mx/2lzymxorfsurzuz_bjon1hr4kdi.jpeg"><br><br>  Si tomamos la rama opuesta, ¿qué pasará?  El valor de T será igual a otra cosa, ¿verdad?  En esta rama, el valor de T será el valor simbólico de Y. <br><br><img src="https://habrastorage.org/webt/q9/e6/fw/q9e6fwx1kg2llxhp3ci7rfzvwym.jpeg"><br><br>  Entonces, ¿qué significa este valor T cuando llegamos a este punto en el programa?  Tal vez sea X, tal vez sea Y. No sabemos exactamente cuál es este valor, pero ¿por qué no le damos un nombre?  Llámalo t <sub>0</sub> .  ¿Y qué sabemos sobre t <sub>0</sub> ?  ¿En qué casos t <sub>0</sub> será igual a X? <br><br>  Esencialmente, sabemos que si X es mayor que Y, entonces la variable es igual a X, y si X es menor o igual que Y, entonces la variable es igual a Y. Por lo tanto, tenemos un valor que definimos, llamémoslo t <sub>0</sub> , y tiene estos propiedades lógicas <br><br><img src="https://habrastorage.org/webt/6l/ux/93/6lux93kqkmnz63fjddelibxu3ma.jpeg"><br><br>  Entonces, en este punto del programa, tenemos un nombre para el valor de T, esto es t <sub>0</sub> .  Que hemos hecho aqui  Tomamos ambas ramas de la instrucción if, y luego calculamos el valor simbólico, viendo bajo qué condiciones se ejecutaría una rama del programa y bajo qué otra. <br>  Ahora llega el punto de que deberíamos preguntarnos si T puede ser menor que X. Ahora el valor de T es t <sub>0</sub> , y queremos saber si es posible que t <sub>0</sub> sea ​​menor que X.  Recuerde la primera rama que examinamos: hicimos una pregunta sobre X e Y y no sabíamos nada sobre ellas, excepto que eran del tipo int. <br><br>  Pero teniendo t <sub>0</sub> , realmente sabemos mucho al respecto.  Sabemos que en algunos casos será igual a X, y en algunos casos será igual a Y. Así que ahora nos da un conjunto de ecuaciones que podemos resolver.  Entonces, ¿podemos decir si es posible que t <sub>0 sea</sub> menor que X, sabiendo que t <sub>0</sub> satisface todas estas condiciones?  Por lo tanto, podemos expresar esto como una restricción, mostrando si es posible que t <sub>0</sub> sea ​​menor que X. Y si X es mayor que Y, entonces t <sub>0</sub> es igual a X, y si X es menor o igual que Y, esto significa que t <sub>0</sub> = Y. <br><br><img src="https://habrastorage.org/webt/kw/go/1p/kwgo1pvhy86moreg7j9vnwlybsi.jpeg"><br><br>  Entonces tenemos una ecuación.  Si tiene una solución, si es posible encontrar el valor de t <sub>0</sub> , el valor de X y el valor de Y que satisfacen esta ecuación, entonces reconocemos estos valores, y cuando los ingresamos en el programa, cuando se ejecuta irá a lo largo de esta rama si t &lt;x y " explotará ”cuando caiga en afirmar falso. <br><br>  Entonces, ¿qué hemos hecho aquí?  Ejecutamos el programa, pero en lugar de asignar nombres de variables a valores específicos, les dimos valores simbólicos a estos nombres de variables.  De hecho, les dieron otros nombres de variables.  Y en este caso, nuestros otros nombres de variables son script X, script Y, t <sub>0</sub> , y además, tenemos un conjunto de ecuaciones que muestran cómo se relacionan estos valores.  Tenemos una ecuación que nos dice cómo t <sub>0</sub> está relacionado con X e Y en este caso. <br><br>  La solución de esta ecuación nos permite responder a la pregunta de si esta rama se puede ejecutar o no.  Eche un vistazo a la ecuación: ¿es posible tomar esta rama o no?  Parece que no, porque estamos buscando casos donde t <sub>0 es</sub> menor que X, pero si en la primera condición t <sub>0</sub> = X, entonces la expresión t <sub>0</sub> &lt;X no será verdadera. <br><br>  Por lo tanto, esto significa que cuando X&gt; Y, esto no puede suceder, porque t <sub>0</sub> = X y no puede ser igual o menor que X al mismo tiempo. <br><br>  Pero, ¿qué sucede si t <sub>0</sub> = Y?  ¿Puede t <sub>0</sub> ser menor que X en este caso? <br><br>  No, definitivamente no puede, porque sabemos que X &lt;Y. Entonces, si t <sub>0</sub> es menor que X, entonces también será menor que Y. Pero sabemos que en este caso t <sub>0</sub> = Y. Y por lo tanto, nuevamente , esta condición no puede ser satisfecha.  Entonces, aquí tenemos una ecuación que no tiene solución, y no importa qué valores incluya en esta ecuación. <br><br>  No puede resolverlo, y esto nos dice que no importa qué entrada X e Y pasemos al programa, no bajará la rama if t &lt;x. <br><br>  Ahora note que al crear este argumento aquí, básicamente insinué su intuición sobre enteros, sobre enteros matemáticos.  En la práctica, sabemos que las entradas de máquina no se comportan exactamente como las entradas matemáticas.  Hay casos en que las leyes aplicadas a los tipos de datos enteros matemáticos no son aplicables a las entradas programáticas. <br><br>  Por lo tanto, debemos tener mucho cuidado al resolver estas ecuaciones, porque debemos recordar que estos no son los enteros de los que nos hablaron en la escuela primaria.  Estos son los enteros de 32 bits utilizados por la máquina.  Y hay muchos casos de errores que ocurrieron porque los programadores pensaron en su código en términos de enteros matemáticos, sin darse cuenta de que hay cosas como desbordamientos que pueden causar un comportamiento diferente del programa para la entrada matemática. <br><br>  Otra cosa que describí aquí es un argumento puramente intuitivo.  Te guiaré a través del proceso, mostrando cómo hacerlo manualmente, pero esto no es un algoritmo.  La belleza de esta idea de ejecución simbólica, sin embargo, es que puede codificarse en un algoritmo.  Y puede resolverlo mecánicamente, lo que le permite hacer esto no solo para un programa de 10 líneas, sino para millones de programas.  Esto nos permite usar el mismo razonamiento intuitivo que usamos en este caso y hablar sobre lo que sucede cuando ejecutamos este programa con diferentes valores de entrada.  Y estas consideraciones pueden escalarse y extenderse a programas muy grandes. <br><br><img src="https://habrastorage.org/webt/b0/of/jr/b0ofjrqh-vesxglsfrxpikk8yb0.jpeg"><br><br>  <b>Audiencia:</b> ¿qué sucede si el programa no admite la entrada de un cierto tipo de variable? <br><br>  <b>Profesor:</b> esta es una muy buena pregunta!  Supongamos que tenemos el mismo programa, pero en lugar de t = x tendremos t = (x-1).  Entonces, intuitivamente, podemos imaginar que ahora este programa puede "explotar", ¿verdad? <br><br><img src="https://habrastorage.org/webt/_k/sk/9v/_ksk9vik_mk_xno9mkjqkvoli3k.jpeg"><br><br>  Porque cuando el programa va de esta manera, t realmente será menor que x.  ¿Qué pasará con tal programa?  ¿Cómo será nuestro estado simbólico?  ¿Cuál será t <sub>0</sub> cuando x es mayor que y?  Corregimos las líneas en nuestras ecuaciones de acuerdo con otro valor cuando t = (x-1).  Ahora el programa puede fallar, y usted va al desarrollador y le dice: "¡Oye, esta función puede explotar cuando x es mayor que y"! <br><br>  El desarrollador mira esto y dice: “Oh, olvidé decirte que, de hecho, esta función nunca se llamará con parámetros, donde x es mayor que y.  "Lo acabo de escribir por razones históricas, así que no te preocupes, no lo recordaría si no me lo hubieras dicho". <br><br>  Supongamos que tenemos una suposición de que x será menor o igual que y. <br><br><img src="https://habrastorage.org/webt/il/iu/un/iliuunmfbjyqdw1dxw7ugemm0go.jpeg"><br><br>  Esta es una condición previa o acuerdo para nuestra función.  La función promete hacer algo, pero solo si el valor satisface esta suposición.  Pero si no está satisfecho, la función dice: "No me importa lo que pase.  Prometo que no habrá ningún error solo si se cumple esta suposición ". <br><br>  Entonces, ¿cómo codificamos esta restricción cuando resolvemos las ecuaciones?  Esencialmente, tenemos un conjunto de restricciones que nos dicen si esta rama es factible.  Y además de las limitaciones, también debemos asegurarnos de que se cumpla la condición previa o suposición. <br><br>  La pregunta es, ¿puedo encontrar xey que satisfagan todas estas restricciones y al mismo tiempo posean las propiedades requeridas?  Puede ver que esta restricción X ≤ Y representa la diferencia entre el caso cuando se cumple esta restricción y el caso cuando no se cumple. <br><br>  Este es un tema muy importante cuando se trabaja con análisis, especialmente cuando se quiere hacer esto simultáneamente a nivel de funciones individuales.  Es recomendable saber qué tenía en mente el programador al escribir esta función.  Porque si no tiene idea de estas suposiciones, puede pensar que hay alguna información de que el programa fallará. <br><br>  ¿Cómo hacer esto de forma mecánica?  Hay dos aspectos para este problema.  Aspecto número uno: ¿cómo se te ocurrieron estas fórmulas? <br><br>  En este caso, es intuitivamente claro cómo llegamos a estas fórmulas, simplemente las compusimos manualmente.  ¿Pero cómo crear estas fórmulas mecánicamente? <br><br>  Y el segundo aspecto: ¿cómo resuelve estas fórmulas después de tenerlas?  ¿Es posible resolver realmente estas fórmulas que describen si su programa falla o no? <br>  Comencemos con la segunda pregunta.  Podemos reducir nuestro problema con estas fórmulas, que incluyen el razonamiento de enteros y los vectores de bits.  Cuando crea programas, se ocupa de las matrices, las funciones y, como resultado, obtiene fórmulas gigantes.  ¿Es posible resolverlos mecánicamente? <br><br><img src="https://habrastorage.org/webt/fb/wg/mp/fbwgmprqfh03wmz73pz3s5cfrv0.jpeg"><br><br>  Las muchas tecnologías de las que estamos hablando hoy son herramientas prácticas relacionadas con los enormes avances en el desarrollo de soluciones para preguntas lógicas.  En particular, existe una clase muy importante de solucionadores, llamada SMT, o el "solucionador de soluciones de teorías modulares".  El solucionador SMT es la capacidad de solución de las fórmulas lógicas teniendo en cuenta las teorías subyacentes. <br><br>  Muchas personas afirman que este nombre no es particularmente bueno, pero se ha corregido como el más utilizado. <br><br>  SMT-solver es un algoritmo debido al cual esta fórmula lógica en la salida le dará una de dos opciones: cumple su propósito o no satisface.   ,        ,     . <br><br>         .   ,    SMT,  NP- ,      «»  «». <br>     ,           NP- ?     -,    ?   ,    SMT –       : «  ». <br><br><img src="https://habrastorage.org/webt/wp/se/q9/wpseq9oqvluas4nkjsstzagwpva.jpeg"><br><br>         , ,        ,    ,   : «  ».      ,           ,        . <br><br> 27:30  <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> MIT «  ».  10: « »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La versión completa del curso está disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps hasta diciembre de forma gratuita</b> al pagar por un período de seis meses, puede ordenar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425557/">https://habr.com/ru/post/es425557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425547/index.html">Qt: dibujo basado en gráficos vectoriales</a></li>
<li><a href="../es425549/index.html">Supermicro se desploma en medio de una investigación sobre el despliegue de chips espías chinos</a></li>
<li><a href="../es425551/index.html">¿Quién debería recibir dinero de la venta de una obra de arte creada por AI?</a></li>
<li><a href="../es425553/index.html">Lo que el conde de Montecristo puede decirnos sobre la ciberseguridad</a></li>
<li><a href="../es425555/index.html">Charles Nutter sobre lenguajes dinámicos en la JVM en jug.msk.ru</a></li>
<li><a href="../es425559/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 10: Ejecución simbólica, parte 3</a></li>
<li><a href="../es425561/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 10: Ejecución simbólica, parte 2</a></li>
<li><a href="../es425563/index.html">California prohíbe la venta de dispositivos IoT con o sin contraseñas simples</a></li>
<li><a href="../es425565/index.html">Matemáticas rápidas de punto fijo para aplicaciones financieras en Java</a></li>
<li><a href="../es425569/index.html">Pruebas funcionales de PCB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>