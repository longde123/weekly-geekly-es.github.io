<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¸ ğŸ‘¨ğŸ¿â€âš•ï¸ ğŸ§—ğŸ» Cara memotong monolit ke dalam layanan dan mempertahankan kinerja cache dalam memori tanpa kehilangan konsistensi ğŸ§“ğŸ½ ğŸš½ ğŸ‘©ğŸ¼â€ğŸš’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Nama saya Alexander, saya adalah pengembang Java di grup perusahaan Tinkoff. 

 Dalam artikel ini saya ingin berbagi pengalaman saya da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara memotong monolit ke dalam layanan dan mempertahankan kinerja cache dalam memori tanpa kehilangan konsistensi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/474994/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/io/g8/yg/iog8ygcpquu5zvi7xmlsecbbwmu.png"></div><br>  Halo semuanya.  Nama saya Alexander, saya adalah pengembang Java di grup perusahaan Tinkoff. <br><br>  Dalam artikel ini saya ingin berbagi pengalaman saya dalam memecahkan masalah yang terkait dengan sinkronisasi kondisi cache dalam sistem terdistribusi.  Kami bertemu mereka, memecah aplikasi monolitik menjadi layanan <s>mikro</s> .  Jelas, kita akan berbicara tentang caching data di level JVM, karena dengan cache eksternal, masalah sinkronisasi diselesaikan di luar konteks aplikasi. <br><br>  Dalam artikel ini, saya akan berbicara tentang pengalaman kami beralih ke arsitektur berorientasi layanan, disertai dengan kepindahan ke Kubernetes, dan tentang penyelesaian masalah terkait.  Kami akan mempertimbangkan pendekatan untuk mengorganisasikan sistem penyimpanan terdistribusi In-Memory Data Grid (IMDG), kelebihan dan kekurangannya, karena itu kami memutuskan untuk menulis solusi kami sendiri. <br><br>  Artikel ini membahas proyek backend yang ditulis dalam Java.  Oleh karena itu, kami juga akan berbicara tentang standar di bidang caching sementara di memori.  Mari kita bahas spesifikasi JSR-107, spesifikasi JSR-347 yang gagal, dan fitur caching di Spring.  Selamat datang di kucing! <br><a name="habracut"></a><br><br><h1>  Dan mari kita potong aplikasi menjadi layanan ... </h1><br>  Kami akan beralih ke arsitektur berorientasi layanan dan pindah ke Kubernetes - itulah yang kami putuskan sedikit lebih dari 6 bulan lalu.  Untuk waktu yang lama, proyek kami adalah monolit, banyak masalah yang berkaitan dengan akumulasi utang teknis, dan kami menulis modul aplikasi baru sama sekali sebagai layanan terpisah.  Akibatnya, transisi ke arsitektur berorientasi layanan dan pemotongan monolit tidak bisa dihindari. <br><br>  Aplikasi kami dimuat, rata-rata 500 rps datang ke layanan web (pada puncaknya mencapai 900 rps).  Untuk mengumpulkan seluruh model data dalam menanggapi setiap permintaan, Anda harus membuka berbagai cache beberapa ratus kali. <br><br>  Kami mencoba untuk pergi ke cache jarak jauh tidak lebih dari tiga kali per permintaan, tergantung pada set data yang diperlukan, dan pada cache JVM internal, bebannya mencapai 90.000 rps per cache.  Kami memiliki sekitar 30 cache seperti itu untuk berbagai entitas dan DTO-shki.  Pada beberapa cache yang dimuat, kami bahkan tidak mampu menghapus nilainya, karena hal ini dapat menyebabkan peningkatan pada waktu respons layanan web dan crash pada aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mn/db/2v/mndb2vp6ot9byy_fqysaooom6j0.png"></div><br>  Ini adalah bagaimana pemantauan beban terlihat, dihapus dari cache internal pada setiap node di siang hari.  Menurut profil pemuatan, mudah untuk melihat bahwa sebagian besar permintaan adalah data yang dibaca.  Beban tulis yang seragam adalah karena memperbarui nilai dalam cache pada frekuensi yang diberikan. <br><br>  Waktu henti tidak berlaku untuk aplikasi kami.  Oleh karena itu, untuk tujuan penyebaran yang mulus, kami selalu menyeimbangkan semua lalu lintas masuk ke dua node dan menggunakan aplikasi menggunakan metode Pembaruan Bergulir.  Kubernetes menjadi solusi infrastruktur ideal kami saat beralih ke layanan.  Jadi, kami memecahkan beberapa masalah sekaligus. <br><br><h3>  Masalah terus-menerus memesan dan menyiapkan infrastruktur untuk layanan baru </h3><br>  Kami diberi namespace di cluster untuk setiap sirkuit, yang kami miliki tiga: dev - untuk pengembang, qa - untuk penguji, prod - untuk klien. <br><br>  Dengan namespace disorot, menambahkan layanan atau aplikasi baru bermula untuk menulis empat manifes: Penempatan, Layanan, Masuk, dan ConfigMap. <br><br><h3>  Toleransi beban tinggi </h3><br>  Bisnis ini berkembang dan terus tumbuh - setahun yang lalu beban rata-rata dua kali lebih sedikit dari yang sekarang. <br><br>  Penskalaan horisontal di Kubernetes memungkinkan Anda untuk meratakan skala ekonomis dengan meningkatnya beban kerja proyek yang dikembangkan. <br><br><h3>  Pemeliharaan, pengumpulan dan pemantauan log </h3><br>  Hidup menjadi jauh lebih mudah ketika tidak perlu menambahkan log ke sistem logging ketika menambahkan setiap node, mengkonfigurasi pagar metrik (kecuali Anda memiliki sistem pemantauan push), melakukan pengaturan jaringan dan cukup menginstal perangkat lunak yang diperlukan untuk operasi. <br><br>  Tentu saja, semua ini dapat diotomatisasi menggunakan Ansible atau Terraform, tetapi pada akhirnya, menulis banyak manifes untuk setiap layanan jauh lebih mudah. <br><br><h3>  Keandalan tinggi </h3><br>  Mekanisme built-in k8s sampel Liveness- dan Readiness-memungkinkan Anda untuk tidak khawatir bahwa aplikasi mulai melambat atau sepenuhnya berhenti merespons. <br><br>  Kubernetes sekarang mengontrol siklus hidup pod perapian berisi kontainer aplikasi dan lalu lintas yang diarahkan ke sana. <br><br>  Seiring dengan fasilitas yang dijelaskan, kami perlu menyelesaikan sejumlah masalah untuk membuat layanan yang sesuai untuk penskalaan horizontal dan penggunaan model data umum untuk banyak layanan.  Itu perlu untuk memecahkan dua masalah: <br><br><ol><li>  <b>Status aplikasi.</b>  Ketika proyek ditempatkan di kluster k8s, pod dengan wadah versi baru dari aplikasi mulai dibuat yang tidak terkait dengan keadaan pod dari versi sebelumnya.  Pod aplikasi baru dapat dinaikkan pada server cluster sewenang-wenang yang memenuhi batasan yang ditentukan.  Juga, sekarang setiap kontainer aplikasi yang berjalan di dalam pod Kubernetes dapat dimusnahkan kapan saja jika probe Liveness mengatakan bahwa itu perlu dimulai ulang. </li><li>  <b>Konsistensi data.</b>  Hal ini diperlukan untuk menjaga konsistensi dan integritas data satu sama lain di semua node.  Ini terutama benar jika banyak node bekerja dalam model data tunggal.  Tidak dapat diterima bahwa ketika permintaan ke simpul aplikasi yang berbeda dalam respons, data yang tidak konsisten datang ke klien. </li></ol><br>  Dalam pengembangan modern dari sistem yang dapat diskalakan, arsitektur Stateless adalah solusi untuk masalah di atas.  Kami menyingkirkan masalah pertama dengan memindahkan semua statika ke penyimpanan cloud S3. <br><br>  Namun, karena kebutuhan untuk menggabungkan model data yang kompleks dan menghemat waktu respons layanan web kami, kami tidak dapat menolak untuk menyimpan data dalam cache di-memori.  Untuk mengatasi masalah kedua, mereka menulis perpustakaan untuk menyinkronkan keadaan cache internal masing-masing node. <br><br><h1>  Kami menyinkronkan cache pada node yang terpisah </h1><br>  Sebagai data awal kami memiliki sistem terdistribusi yang terdiri dari N node.  Setiap node memiliki sekitar 20 cache dalam memori, data yang diperbarui beberapa kali per jam. <br><br>  Sebagian besar cache memiliki kebijakan refresh data TTL (time-to-live), beberapa data diperbarui dengan operasi CRON setiap 20 menit karena beban yang tinggi.  Beban kerja pada cache bervariasi dari beberapa ribu rps di malam hari hingga beberapa puluh ribu di siang hari.  Beban puncak, sebagai suatu peraturan, tidak melebihi 100.000 rps.  Jumlah catatan dalam penyimpanan sementara tidak melebihi beberapa ratus ribu dan ditempatkan di tumpukan satu node. <br><br>  Tugas kami adalah mencapai konsistensi data antara cache yang sama pada node yang berbeda, serta waktu respons sesingkat mungkin.  Pertimbangkan apa yang umumnya ada cara untuk menyelesaikan masalah ini. <br><br>  Solusi pertama dan paling sederhana yang terlintas dalam pikiran adalah untuk meletakkan semua informasi dalam cache jarak jauh.  Dalam hal ini, Anda dapat sepenuhnya menghilangkan status aplikasi, tidak memikirkan masalah dalam mencapai konsistensi dan memiliki satu jalur akses ke gudang data sementara. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/zm/bg/ezzmbg3cuvhczrwpwmh5hg5a0-o.png"></div><br>  Metode penyimpanan data sementara ini cukup sederhana, dan kami menggunakannya.  Kami men-cache bagian dari data di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redis</a> , yang merupakan penyimpanan data NoSQL dalam RAM.  Di Redis, kami biasanya merekam kerangka respons layanan web, dan untuk setiap permintaan kami perlu memperkaya data ini dengan informasi yang relevan, yang mengharuskan pengiriman beberapa ratus permintaan ke cache lokal. <br><br>  Jelas, kami tidak dapat mengambil data cache internal untuk penyimpanan jarak jauh, karena biaya pengiriman volume lalu lintas melalui jaringan tidak akan memungkinkan kami untuk memenuhi waktu respons yang diperlukan. <br><br>  Opsi kedua adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">In-Memory Data Grid</a> (IMDG), yang merupakan cache In-memory terdistribusi.  Skema solusi semacam itu adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/ku/k9/l7kuk9uaiuydck1hs1boeykflys.png"></div><br>  Arsitektur IMDG didasarkan pada prinsip Partisi Data dari cache internal masing-masing node.  Bahkan, ini bisa disebut tabel hash yang didistribusikan pada sekelompok node.  IMDG dianggap sebagai salah satu implementasi tercepat penyimpanan terdistribusi sementara. <br><br>  Ada banyak implementasi IMDG, yang paling populer adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hazelcast</a> .  Cache terdistribusi memungkinkan Anda untuk menyimpan data dalam RAM pada beberapa node aplikasi dengan tingkat keandalan dan pemeliharaan konsistensi yang dapat diterima, yang dicapai dengan replikasi data. <br><br>  Tugas membangun cache terdistribusi seperti itu tidak mudah, namun, menggunakan solusi IMDG yang sudah jadi bagi kita bisa menjadi pengganti yang baik untuk cache JVM dan menghilangkan masalah replikasi, konsistensi dan distribusi data antara semua node aplikasi. <br><br>  Sebagian besar vendor IMDG untuk aplikasi Java menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSR-107</a> , API Java standar untuk bekerja dengan cache internal.  Secara umum, standar ini memiliki cerita yang agak besar, yang akan saya bahas secara lebih rinci di bawah ini. <br><br>  Sekali waktu ada ide untuk mengimplementasikan antarmuka Anda untuk berinteraksi dengan IMDG - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSR 347</a> .  Tetapi implementasi API semacam itu tidak menerima dukungan yang memadai dari komunitas Java, dan sekarang kami memiliki antarmuka tunggal untuk berinteraksi dengan cache dalam memori, terlepas dari arsitektur aplikasi kami.  Baik atau buruk adalah pertanyaan lain, tetapi ini memungkinkan kita untuk sepenuhnya mengabaikan semua kesulitan dalam mengimplementasikan cache dalam-memori terdistribusi dan bekerja dengannya sebagai cache dari aplikasi monolitik. <br><br>  Meskipun ada keuntungan jelas menggunakan IMDG, solusi ini masih lebih lambat dari cache JVM standar, karena overhead memastikan replikasi data yang berkelanjutan didistribusikan antara beberapa node JVM, serta membuat cadangan data ini.  Dalam kasus kami, jumlah data untuk penyimpanan sementara tidak begitu besar, data dengan margin sesuai dalam memori satu aplikasi, sehingga alokasi mereka untuk beberapa JVM sepertinya solusi yang tidak perlu.  Dan lalu lintas jaringan tambahan antara node aplikasi di bawah beban berat dapat sangat memengaruhi kinerja dan meningkatkan waktu respons layanan web.  Pada akhirnya, kami memutuskan untuk menulis solusi kami sendiri untuk masalah ini. <br><br>  Kami meninggalkan cache dalam memori sebagai penyimpanan sementara data, dan untuk menjaga konsistensi kami menggunakan manajer antrian RabbitMQ.  Kami mengadopsi pola desain perilaku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penerbit-Pelanggan</a> , dan mempertahankan relevansi data dengan menghapus entri yang dimodifikasi dari cache setiap node.  Skema solusinya adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/05/y9/di/05y9dihavtlltrsgxxnkvuj5bhs.png"></div><br>  Diagram menunjukkan sekelompok N node, masing-masing memiliki cache In-memory standar.  Semua node menggunakan model data umum dan harus konsisten.  Pada akses pertama ke cache dengan kunci sewenang-wenang, nilai dalam cache tidak ada, dan kami memasukkan nilai aktual dari database ke dalamnya.  Dengan perubahan apa pun - hapus catatan. <br><br>  Informasi aktual dalam respons cache di sini disediakan dengan menyinkronkan penghapusan entri ketika diubah pada salah satu node.  Setiap node dalam sistem memiliki antrian di manajer antrian RabbitMQ.  Perekaman ke semua antrian dilakukan melalui titik akses Jenis-topik umum.  Ini berarti bahwa pesan yang dikirim ke Topik termasuk dalam semua antrian yang terkait dengannya.  Jadi, ketika mengubah nilai pada setiap simpul sistem, nilai ini akan dihapus dari penyimpanan sementara setiap node, dan akses selanjutnya akan memulai penulisan nilai saat ini ke cache dari database. <br><br>  Omong-omong, mekanisme PUB / SUB serupa ada di Redis.  Tapi, menurut saya, masih lebih baik menggunakan manajer antrian untuk bekerja dengan antrian, dan RabbitMQ sempurna untuk tugas kami. <br><br><h1>  JSR 107 standar dan implementasinya </h1><br>  API Java Cache standar untuk penyimpanan sementara data dalam memori (spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSR-107</a> ) memiliki sejarah yang agak panjang, telah dikembangkan selama 12 tahun. <br><br>  Selama sekian lama, pendekatan untuk pengembangan perangkat lunak telah berubah, monolit telah digantikan oleh arsitektur layanan mikro.  Karena kurangnya spesifikasi untuk Cache API, bahkan ada permintaan untuk mengembangkan cache API untuk sistem terdistribusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSR-347</a> (Grid Data untuk Platform Java).  Tetapi setelah rilis lama JSR-107 dan rilis JCache, permintaan untuk membuat spesifikasi terpisah untuk sistem terdistribusi ditarik. <br><br>  Selama 12 tahun di pasaran, tempat penyimpanan data sementara telah berubah dari HashMap ke ConcurrentHashMap dengan rilis Java 1.5, dan kemudian banyak implementasi open source siap pakai dari caching dalam memori muncul. <br><br>  Setelah rilis JSR-107, solusi vendor mulai secara bertahap mengimplementasikan spesifikasi baru.  Untuk JCache, bahkan ada penyedia yang berspesialisasi dalam caching terdistribusi - Data Grids, spesifikasi yang belum pernah diterapkan. <br><br>  Pertimbangkan untuk apa paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javax.cache terdiri</a> , dan bagaimana cara mendapatkan instance cache untuk aplikasi kita: <br><pre><code class="java hljs">CachingProvider provider = Caching.getCachingProvider(<span class="hljs-string"><span class="hljs-string">"org.cache2k.jcache.provider.JCacheProvider"</span></span>); CacheManager cacheManager = provider.getCacheManager(); CacheConfiguration&lt;Integer, String&gt; config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MutableConfiguration&lt;Integer, String&gt;() .setTypes(Integer.class, String.class) .setReadThrough(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) . . .; Cache&lt;Integer, String&gt; cache = cacheManager.createCache(cacheName, config);</code> </pre> <br>  Di sini Caching adalah boot loader untuk CachingProvider. <br><br>  Dalam kasus kami, JCacheProvider, yang merupakan implementasi cache2k dari penyedia JSR-107 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SPI</a> , akan dimuat dari ClassLoader.  Untuk loader, Anda tidak bisa menentukan implementasi penyedia, tetapi kemudian akan mencoba memuat implementasi yang ada di dalamnya <br><blockquote>  META-INF / services / javax.cache.spi.CachingProvider </blockquote><br>  Bagaimanapun, di ClassLoader harus ada satu implementasi CachingProvider. <br><br>  Jika Anda menggunakan pustaka javax.cache tanpa implementasi apa pun, pengecualian akan muncul saat Anda mencoba membuat JCache.  Tujuan penyedia adalah untuk membuat dan mengelola siklus hidup CacheManager, yang, pada gilirannya, bertanggung jawab untuk mengelola dan mengkonfigurasi cache.  Jadi, untuk membuat cache, Anda harus pergi dengan cara berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/lp/fs/fxlpfsdfmlifqegpwtaynhiakt8.png"></div><br>  Tembolok standar yang dibuat menggunakan CacheManager harus memiliki konfigurasi yang kompatibel dengan implementasi.  Konfigurasi Cache parameterized standar yang disediakan oleh javax.cache dapat diperluas ke implementasi CacheProvider tertentu. <br><br>  Hari ini, ada lusinan implementasi berbeda dari spesifikasi JSR-107: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ehcache</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Guava</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">caffeine</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cache2k</a> .  Banyak implementasinya adalah In-Memory Data Grid dalam sistem terdistribusi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hazelcast</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oracle Coherence</a> . <br><br>  Ada juga banyak implementasi penyimpanan sementara yang tidak mendukung API standar.  Untuk waktu yang lama dalam proyek kami, kami menggunakan Ehcache 2, yang tidak kompatibel dengan JCache (implementasi spesifikasi muncul dengan Ehcache 3).  Kebutuhan untuk transisi ke implementasi yang kompatibel dengan JCache muncul dengan kebutuhan untuk memantau status cache dalam memori.  Menggunakan standar MetricRegistry, dimungkinkan untuk mempercepat pemantauan hanya dengan bantuan implementasi JCacheGaugeSet, yang mengumpulkan metrik dari JCache standar. <br><br>  Bagaimana memilih implementasi cache Dalam-memori yang sesuai untuk proyek Anda?  Mungkin Anda harus memperhatikan hal-hal berikut: <br><br><ol><li>  Apakah Anda memerlukan dukungan untuk spesifikasi JSR-107. </li><li>  Perlu juga diperhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kecepatan</a> implementasi yang dipilih.  Di bawah beban berat, kinerja cache internal dapat memiliki dampak signifikan pada waktu respons sistem Anda. </li><li>  Dukungan di Musim Semi.  Jika Anda menggunakan kerangka kerja terkenal di proyek Anda, perlu mempertimbangkan fakta bahwa tidak setiap implementasi cache JVM memiliki CacheManager yang kompatibel di Spring. </li></ol><br>  Jika Anda secara aktif menggunakan Spring dalam proyek Anda, seperti kami, maka untuk caching data Anda kemungkinan besar mengikuti pendekatan berorientasi aspek (AOP) dan menggunakan penjelasan @Cacheable.  Spring menggunakan SPI CacheManager miliknya sendiri agar aspek-aspeknya berfungsi.  Kacang berikut ini diperlukan agar cache musim semi bekerja: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> org.springframework.cache.<span class="hljs-function"><span class="hljs-function">CacheManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CachingProvider provider = Caching.getCachingProvider(); CacheManager cacheManager = provider.getCacheManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JCacheCacheManager(cacheManager); }</code> </pre><br>  Untuk bekerja dengan cache dalam paradigma AOP, pertimbangan transaksional juga harus dipertimbangkan.  Cache musim semi harus mendukung manajemen transaksi.  Untuk tujuan ini, pegas CacheManager mewarisi properti AbstractTransactionSupportingCacheManager, yang dapat digunakan untuk menyinkronkan operasi put- / mengusir yang dilakukan dalam transaksi dan hanya menjalankannya setelah transaksi yang berhasil dilakukan. <br><br>  Contoh di atas menunjukkan penggunaan pembungkus JCacheCacheManager untuk manajer spesifikasi cache.  Ini berarti bahwa implementasi JSR-107 juga memiliki kompatibilitas dengan Spring CacheManager.  Ini adalah alasan lain untuk memilih cache dalam memori dengan dukungan untuk spesifikasi JSR untuk proyek Anda.  Tetapi jika Anda masih tidak membutuhkan dukungan ini, tetapi saya benar-benar ingin menggunakan @Cacheable, maka Anda memiliki dukungan untuk dua solusi cache internal lagi: EhCacheCacheManager dan CaffeineCacheManager. <br><br>  Saat memilih implementasi cache Dalam-memori, kami tidak memperhitungkan dukungan IMDG untuk sistem terdistribusi, seperti yang disebutkan sebelumnya.  Untuk menjaga kinerja cache JVM pada sistem kami, kami menulis solusi kami sendiri. <br><br><h1>  Menghapus Cache dalam Sistem Terdistribusi </h1><br>  IMDG modern yang digunakan dalam proyek-proyek dengan arsitektur microservice memungkinkan Anda untuk mendistribusikan data dalam memori antara semua simpul kerja sistem menggunakan partisi data yang dapat diskalakan dengan tingkat redundansi yang diperlukan. <br><br>  Dalam hal ini, ada banyak masalah yang terkait dengan sinkronisasi, konsistensi data, dan sebagainya, belum lagi peningkatan waktu akses ke penyimpanan sementara.  Skema seperti itu berlebihan jika jumlah data yang digunakan cocok dengan RAM satu simpul, dan untuk menjaga konsistensi data, cukup dengan menghapus entri ini pada semua node untuk setiap perubahan dalam nilai cache. <br><br>  Saat mengimplementasikan solusi seperti itu, ide pertama yang muncul di pikiran adalah menggunakan beberapa EventListener, di JCache ada CacheEntryRemovedListener untuk acara menghapus entri dari cache.  Tampaknya cukup untuk menambahkan implementasi Listener Anda sendiri, yang akan mengirim pesan ke topik ketika catatan dihapus, dan cache eutektik pada semua node siap - asalkan setiap node mendengarkan peristiwa dari antrian yang terkait dengan topik umum, seperti yang ditunjukkan pada diagram di atas. <br><br>  Saat menggunakan solusi seperti itu, data pada node yang berbeda akan menjadi tidak konsisten karena fakta bahwa EventLists dalam proses implementasi JCache setelah peristiwa terjadi.  Artinya, jika tidak ada catatan dalam cache lokal untuk kunci yang diberikan, dan ada catatan untuk kunci yang sama pada simpul lain, acara tidak akan dikirim ke topik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_a/ev/5c/_aev5cw333ni_cnstj5elxbowhw.png"></div><br>  Pertimbangkan cara-cara lain apa yang ada untuk menangkap peristiwa nilai yang dihapus dari cache lokal. <br><br>  Dalam paket javax.cache.event, di sebelah EventListeners ada juga CacheEntryEventFilter, yang, menurut JavaDoc, digunakan untuk memeriksa acara CacheEntryEvent apa pun sebelum meneruskan acara ini ke CacheEntryListener, apakah itu catatan, penghapusan, pembaruan, atau peristiwa yang berkaitan dengan catatan kadaluwarsa dari catatan kadaluwarsa. dalam cache.  Saat menggunakan filter, masalah kita akan tetap ada, karena logika akan dieksekusi setelah peristiwa CacheEntryEvent dicatat dan setelah operasi CRUD dilakukan dalam cache. <br><br>  Namun demikian, dimungkinkan untuk menangkap inisiasi suatu peristiwa untuk menghapus catatan dari cache.  Untuk melakukan ini, gunakan alat bawaan di JCache yang memungkinkan Anda untuk menggunakan spesifikasi API untuk menulis dan memuat data dari sumber eksternal, jika mereka tidak ada dalam cache.  Ada dua antarmuka untuk ini dalam paket javax.cache.integration: <br><br><ul><li>  CacheLoader - untuk memuat data yang diminta oleh kunci, jika tidak ada entri dalam cache. </li><li>  CacheWriter - untuk menggunakan penulisan, penghapusan, dan pembaruan data pada sumber daya eksternal saat menjalankan operasi cache yang sesuai. </li></ul><br>  Untuk memastikan konsistensi, metode CacheWriter adalah atomik sehubungan dengan operasi cache yang sesuai.  Kami tampaknya telah menemukan solusi untuk masalah kami. <br><br>  Sekarang kita dapat menjaga konsistensi respon cache In-memory pada node ketika menggunakan implementasi CacheWriter, yang mengirimkan peristiwa ke topik RabbitMQ setiap kali ada perubahan dalam catatan dalam cache lokal. <br><br><h1>  Kesimpulan </h1><br>  Dalam pengembangan proyek apa pun, ketika mencari solusi yang cocok untuk masalah yang muncul, perlu untuk mempertimbangkan kekhususannya.  Dalam kasus kami, fitur karakteristik model data proyek, kode warisan yang diwariskan, dan sifat beban tidak memungkinkan menggunakan solusi apa pun yang ada untuk masalah caching terdistribusi. <br><br>  Sangat sulit untuk membuat implementasi universal yang berlaku untuk sistem yang dikembangkan.  Untuk setiap implementasi seperti itu, ada kondisi optimal untuk digunakan.  Dalam kasus kami, spesifikasi proyek menyebabkan solusi yang dijelaskan dalam artikel ini.  Jika seseorang memiliki masalah yang sama, kami akan dengan senang hati membagikan solusi kami dan menerbitkannya di GitHub. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474994/">https://habr.com/ru/post/id474994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474982/index.html">Tutorial JavaFX: FXML dan SceneBuilder</a></li>
<li><a href="../id474984/index.html">RabbitMQ vs Kafka: Kegagalan dan Ketersediaan Tinggi</a></li>
<li><a href="../id474988/index.html">Selamat Datang di Mitap: Karier di Ilmu Data untuk Pemula</a></li>
<li><a href="../id474990/index.html">Praktik keras: cara membuat jaringan Wi-Fi di taman kota</a></li>
<li><a href="../id474992/index.html">Analisis baterai laptop rusak. Catatan Pengendara Motor Listrik</a></li>
<li><a href="../id474996/index.html">Intisari acara TI pada bulan November (bagian dua)</a></li>
<li><a href="../id475000/index.html">Mengujicoba Ethereum Cloud dan Solusi Privasi dan Skalabilitas Cloud untuk umum</a></li>
<li><a href="../id475002/index.html">Bekerja bukan serigala, bagian 2. Lewati bos dan bertahan dalam masa percobaan</a></li>
<li><a href="../id475004/index.html">Berapa penghasilan pengembang dengan kualifikasi berbeda pada paruh pertama 2019</a></li>
<li><a href="../id475006/index.html">Cara membuat layanan perbandingan dokumen prototipe dalam 28 jam dan menangkan hackathon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>