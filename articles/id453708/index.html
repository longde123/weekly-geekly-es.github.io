<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌱 👩‍👧‍👧 🥃 OS real-time AQUA RTOS untuk MK AVR di lingkungan BASCOM AVR 😏 ◀️ 📨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika menulis untuk kode MK lebih rumit daripada "berkedip cahaya", pengembang dihadapkan pada keterbatasan yang melekat dalam pemrograman linier dal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS real-time AQUA RTOS untuk MK AVR di lingkungan BASCOM AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453708/">  Ketika menulis untuk kode MK lebih rumit daripada "berkedip cahaya", pengembang dihadapkan pada keterbatasan yang melekat dalam pemrograman linier dalam gaya "supercycle plus interrupts".  Pemrosesan interupsi membutuhkan kecepatan dan keringkasan, yang mengarah pada penambahan flag pada kode dan menjadikan gaya proyek “super cycle dengan interupsi dan flag”. <br><br>  Jika kompleksitas sistem bertambah, maka jumlah flag yang saling tergantung tumbuh secara eksponensial, dan proyek dengan cepat berubah menjadi “kode pasta” yang sulit dibaca dan dikelola. <br><br>  Penggunaan sistem operasi real-time membantu untuk menyingkirkan "kode pasta" dan mengembalikan fleksibilitas dan pengelolaan ke proyek MK yang kompleks. <br>  Beberapa sistem operasi real-time koperasi telah dikembangkan dan cukup populer untuk mikrokontroler AVR.  Namun, semuanya ditulis dalam C atau Assembler dan tidak cocok untuk mereka yang memprogram MK di lingkungan BASCOM AVR, merampas mereka dari alat yang berguna untuk menulis aplikasi serius. <br><br>  Untuk memperbaiki kekurangan ini, saya mengembangkan RTOS sederhana untuk lingkungan pemrograman BASCOM AVR, yang saya bawa ke perhatian pembaca. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/0be/c64/cd60bec64b2a0b96ed562770a9063355.jpg" alt="gambar"><br><a name="habracut"></a><br>  Bagi banyak orang, gaya pemrograman MK yang akrab adalah yang disebut  <i>sepeda super</i> .  Kode dalam hal ini terdiri dari serangkaian fungsi, prosedur, dan deskriptor (konstanta, variabel), mungkin yang perpustakaan, umumnya disebut "kode latar belakang", serta loop tak terbatas besar yang terlampir dalam konstruk <b>do-loop</b> .  Saat start up, peralatan dari MK itu sendiri dan perangkat eksternal diinisialisasi terlebih dahulu, konstanta dan nilai awal variabel diatur, dan kemudian kontrol ditransfer ke supercycle tak terbatas ini. <br>  Kesederhanaan supercycle sudah jelas.  Sebagian besar tugas dilakukan oleh MK, karena satu atau lain cara siklus.  Kerugiannya juga jelas: jika beberapa perangkat atau sinyal membutuhkan reaksi segera, MK akan memberikannya tidak lebih cepat dari siklus yang berputar.  Jika durasi sinyal lebih pendek dari periode siklus, sinyal seperti itu akan dilewati. <br><br>  Pada contoh di bawah ini, kami ingin memeriksa apakah tombolnya <b>ditekan</b> : <br><br><pre><code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">' -  if button = 1 then '     '  -  loop</span></span></code> </pre> <br>  Tentunya, jika "beberapa kode" bekerja cukup lama, MK mungkin tidak memperhatikan tombol yang ditekan sebentar. <br><br>  Untungnya, MK dilengkapi dengan sistem interupsi yang dapat menyelesaikan masalah ini: semua sinyal kritis dapat "digantung" pada interupsi dan pawang dapat ditulis untuk masing-masingnya.  Jadi tingkat berikutnya muncul: <i>siklus super dengan gangguan</i> . <br>  Contoh di bawah ini menunjukkan struktur program dengan supercycle dan interupsi yang memproses klik tombol: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">on</span></span> button button_isr <span class="hljs-comment"><span class="hljs-comment">'    enable interrupts ' ***  *** do ' -  loop end '   button_isr: '  -    return</span></span></code> </pre> <br>  Namun, menggunakan interupsi menimbulkan masalah baru: kode interrupt handler harus secepat dan sesingkat mungkin;  di dalam interupsi, fungsionalitas MK terbatas.  Karena AVR MK tidak memiliki sistem interupsi hierarkis, interupsi lain tidak dapat terjadi di dalam interupsi - AVR mereka dinonaktifkan pada saat ini.  Jadi interupsi harus dieksekusi secepat mungkin, jika tidak interupsi lain (dan mungkin yang lebih penting) akan dilewati dan tidak diproses. <br><br><div class="spoiler">  <b class="spoiler_title">Memori interupsi</b> <div class="spoiler_text">  Bahkan, karena berada di dalam interupsi, MK dapat mencatat fakta interupsi lain dalam register khusus, yang memungkinkannya untuk diproses nanti.  Namun, gangguan ini tidak dapat segera diproses. <br></div></div><br>  Oleh karena itu, kita tidak dapat menulis sesuatu yang rumit dalam interrupt handler, terutama jika kode ini harus mengalami penundaan - karena sampai penundaan bekerja, MK tidak akan kembali ke program utama (supercycle) dan akan menjadi tuli terhadap gangguan lain. <br><br>  Karena itu, di dalam interrupt handler Anda seringkali hanya perlu menandai fakta acara dengan bendera - milik Anda untuk setiap acara - dan kemudian memeriksa dan memproses bendera di dalam siklus super.  Ini, tentu saja, memperpanjang waktu reaksi terhadap peristiwa tersebut, tetapi setidaknya kita tidak melewatkan sesuatu yang penting. <br><br>  Dengan demikian, tingkat kerumitan berikutnya muncul - <i>supercycle dengan interupsi dan bendera</i> . <br><br>  Kode berikut ditunjukkan: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">on</span></span> button button_isr <span class="hljs-comment"><span class="hljs-comment">'    enable interrupts ' ***  *** do ' -  if button_flag = 1 then '     button_flag = 0 '     end if '  -  loop end ' ***    *** button_isr: button_flag = 1 return</span></span></code> </pre> <br>  Sejumlah besar program untuk MK dibatasi oleh hal ini.  Namun, program semacam itu biasanya masih kurang lebih sederhana.  Jika Anda menulis sesuatu yang lebih rumit, maka jumlah bendera mulai tumbuh seperti bola salju, dan kodenya menjadi semakin membingungkan dan tidak terbaca.  Selain itu, dalam contoh di atas, masalah dengan keterlambatan belum terselesaikan.  Tentu saja, Anda dapat "menggantung" interupsi terpisah pada timer, dan di dalamnya ... juga mengontrol berbagai flag.  Tetapi ini membuat program ini benar-benar jelek, jumlah bendera yang saling bergantung tumbuh secara eksponensial, dan bahkan pengembang sendiri hampir tidak dapat menemukan "kode pasta" semacam itu dengan segera.  Mencoba untuk menemukan kesalahan atau memodifikasi kode seringkali menjadi sama dalam upaya mengembangkan proyek baru. <br><br>  Bagaimana mengatasi masalah "kode pasta" dan membuatnya lebih mudah dibaca dan dikelola?  Sistem <i>operasi</i> (OS) datang untuk menyelamatkan.  Di dalamnya, fungsionalitas yang harus dilaksanakan MK dibagi menjadi tugas-tugas yang operasinya dikendalikan oleh OS. <br><br><h2>  Jenis sistem operasi untuk MK </h2><br>  Sistem operasi untuk MK dapat dibagi menjadi dua kelas besar: OS dengan crowding out dan OS kooperatif.  Dalam salah satu dari sistem operasi ini, tugas dikontrol oleh prosedur khusus yang disebut <i>dispatcher</i> .  Dalam OS dengan <i>crowding out,</i> operator secara independen setiap saat mengalihkan eksekusi dari satu tugas ke tugas lain, mengalokasikan masing-masing sejumlah siklus clock (mungkin berbeda, tergantung pada prioritas tugas).  Pendekatan ini secara keseluruhan berfungsi dengan baik, memungkinkan Anda untuk tidak melihat konten tugas sama sekali: Anda dapat menulis setidaknya kode tugas <br><br><pre> <code class="vbscript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  - dan masih sisa tugas (termasuk yang ini) akan dilakukan.  Namun, OS preemptive membutuhkan banyak sumber daya (memori prosesor dan siklus jam), karena setiap switch harus benar-benar menyimpan konteks tugas yang akan dinonaktifkan dan memuat konteks resume.  Konteks di sini mengacu pada isi register mesin dan tumpukan (BASCOM menggunakan dua tumpukan - satu perangkat keras untuk alamat pengirim subprogram dan satu perangkat lunak untuk melewati argumen).  Tidak hanya beban seperti itu yang membutuhkan banyak siklus prosesor, tetapi juga konteks dari setiap tugas perlu disimpan di suatu tempat untuk sementara waktu hingga bekerja.  Dalam prosesor "besar", awalnya berorientasi pada multitasking, fungsi-fungsi ini sering didukung dalam perangkat keras, dan mereka memiliki lebih banyak sumber daya.  Dalam AVR MK tidak ada dukungan perangkat keras untuk multitasking (semuanya perlu dilakukan "secara manual"), dan memori yang tersedia kecil.  Oleh karena itu, mengganti OS, meskipun ada, tidak terlalu cocok untuk MK sederhana. <br><br>  Hal lain adalah <i>OS kooperatif</i> .  Di sini tugas itu sendiri mengontrol pada titik apa untuk mentransfer kontrol ke operator, yang memungkinkannya untuk memulai tugas lain.  Selain itu, tugas di sini diperlukan untuk melakukan ini - jika tidak, eksekusi kode akan macet.  Di satu sisi, tampaknya pendekatan ini mengurangi keandalan keseluruhan: jika suatu tugas macet, ia tidak akan pernah memanggil operator, dan seluruh sistem akan berhenti merespons.  Di sisi lain, kode linier atau supercycle tidak lebih baik dalam hal ini - karena mereka dapat membeku dengan risiko yang persis sama. <br><br>  Namun, OS kooperatif memiliki keunggulan penting.  Karena di sini programmer menentukan momen perpindahan dirinya, itu tidak dapat terjadi secara tiba-tiba, misalnya, ketika tugasnya bekerja dengan beberapa sumber daya atau di tengah menghitung ekspresi aritmatika.  Oleh karena itu, dalam OS kooperatif, dalam banyak kasus, Anda dapat melakukannya tanpa mempertahankan konteksnya.  Ini secara signifikan menghemat waktu dan memori prosesor, dan karenanya terlihat jauh lebih cocok untuk implementasi pada AVR MK. <br><br><h2>  Peralihan tugas dalam BASCOM AVR </h2><br>  Untuk mengimplementasikan pengalihan tugas dalam lingkungan BASCOM AVR, kode tugas, yang masing-masing diimplementasikan sebagai prosedur normal, di suatu tempat harus memanggil dispatcher - juga diimplementasikan sebagai prosedur normal. <br>  Bayangkan bahwa kita memiliki dua tugas, yang masing-masing di beberapa tempat kodenya disebut oleh operator. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> task1() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">'  1 '  loop end sub ' ---------------------------------- sub task2() do '  2 '  loop end sub</span></span></code> </pre> <br>  Misalkan tugas 1 dieksekusi. Mari kita lihat apa yang terjadi pada stack ketika menjalankan "panggilan dispatcher": <br><br><blockquote>  kembalikan alamat ke kode utama (2 byte) <br>  atas tumpukan -&gt; kembalikan alamat ke Tugas 1 yang disebut dispatcher (2 byte) </blockquote><br>  Bagian atas tumpukan akan menunjuk ke alamat instruksi di Tugas 1, yang mengikuti panggilan dispatcher (instruksi <b>loop</b> dalam contoh kita). <br><br>  Tujuan dari dispatcher dalam kasus paling sederhana adalah untuk mentransfer kontrol ke Tugas 2. Pertanyaannya adalah bagaimana melakukan ini?  (misalkan operator sudah tahu alamat Tugas 2). <br><br>  Untuk melakukan ini, operator harus menarik alamat pengembalian ke Tugas 1 dari tumpukan (dan di suatu tempat untuk diingat), dan meletakkan alamat Tugas 2 di tempat ini di tumpukan, dan kemudian memberikan perintah kembali.  Prosesor akan mengekstrak alamat yang ditempatkan di sana dari tumpukan dan, alih-alih kembali ke Tugas 1, akan melanjutkan ke pelaksanaan Tugas 2. <br><br>  Pada gilirannya, ketika Tugas 2 memanggil operator, kami juga menarik tumpukan dan menyimpan alamat yang memungkinkan untuk kembali ke Tugas 2, dan memuat alamat tugas 1 yang disimpan sebelumnya ke tumpukan. Berikan perintah <b>kembali</b> dan kami akan berada pada titik kelanjutan dari Tugas 1 . <br><br>  Akibatnya, kami jadi berantakan: <br><br><blockquote>  Tugas 1 -&gt; Dispatcher -&gt; Tugas 2 -&gt; Dispatcher -&gt; Tugas 1 .... </blockquote><br>  Tidak buruk!  Dan itu berhasil.  Tapi, tentu saja, ini tidak cukup untuk OS yang secara praktis dapat digunakan.  Lagi pula, tidak selalu dan tidak semua tugas harus bekerja - misalnya, mereka dapat <i>mengharapkan</i> sesuatu (berakhirnya waktu tunda, penampilan beberapa sinyal, dll.).  Jadi, tugas harus memiliki <i>status</i> (KARYA, SIAP, DIHARAPKAN, dll.).  Selain itu, alangkah baiknya jika tugas diberikan <i>prioritas</i> .  Kemudian, jika lebih dari satu tugas siap untuk dieksekusi, operator akan melanjutkan tugas yang memiliki prioritas tertinggi. <br><br><h2>  AQUA RTOS </h2><br>  Untuk mengimplementasikan ide yang diuraikan, koperasi OS AQUA RTOS dikembangkan, yang menyediakan layanan yang diperlukan untuk tugas-tugas dan memungkinkan penerapan multitasking koperasi dalam lingkungan AVR BASCOM. <br><br><div class="spoiler">  <b class="spoiler_title">Pemberitahuan Penting Mengenai Mode Prosedur di BASCOM AVR</b> <div class="spoiler_text">  Sebelum memulai deskripsi AUQA RTOS, harus dicatat bahwa lingkungan BASCOM AVR mendukung dua jenis prosedur pengalamatan.  Ini diatur oleh submode config = new |  tua <br>  Dalam hal menentukan opsi lama, kompiler, pertama, akan mengkompilasi semua kode secara linear, terlepas dari apakah itu digunakan di suatu tempat atau tidak, dan kedua, prosedur tanpa argumen yang dirancang dalam gaya sub nama / sub akhir akan dianggap sebagai prosedur , ditata dengan gaya nama: / kembali.  Ini memungkinkan kita untuk mengirimkan alamat prosedur sebagai label sebagai argumen ke prosedur lain dengan menggunakan pengubah bylabel.  Ini juga berlaku untuk prosedur yang dirancang dalam gaya sub nama / gaya akhir sub (Anda harus memberikan nama prosedur sebagai label). <br>  Pada saat yang sama, submode = mode lama memberlakukan beberapa batasan: prosedur tugas tidak boleh berisi argumen;  kode file yang terhubung melalui $ include dimasukkan dalam proyek umum secara linier, oleh karena itu, bypass harus disediakan dalam file yang terhubung - mulai dari awal hingga akhir menggunakan goto dan label. <br>  Dengan demikian, dalam AQUA RTOS, pengguna harus menggunakan hanya notasi prosedur lama dalam gaya task_name: / kembali untuk tugas, atau menggunakan sub nama / sub akhir yang lebih umum, menambahkan submode pengubah = tua pada awal kodenya, dan memotong di file yang disertakan label goto / sertakan kode file / label:. <br></div></div><br><h3>  Status tugas AQUA RTOS </h3><br>  Status berikut didefinisikan untuk tugas-tugas dalam AQUA RTOS: <br><br><pre> <code class="vbscript hljs">OSTS_UNDEFINE OSTS_READY OSTS_RUN OSTS_DELAY OSTS_STOP OSTS_WAIT OSTS_PAUSE OSTS_RESTART</code> </pre> <br>  Jika tugas belum diinisialisasi, tugas ini diberikan status <b>OSTS_UNDEFINE</b> . <br>  Setelah inisialisasi, tugas memiliki status <b>OSTS_STOP</b> . <br>  Jika tugas <i>siap untuk dieksekusi</i> , tugas itu diberikan status <b>OSTS_READY</b> . <br>  Tugas yang sedang berjalan memiliki status <b>OSTS_RUN</b> . <br>  Dari sana, ia dapat pergi ke status <b>OSTS_STOP, OSTS_READY, OSTS_DELAY, OSTS_WAIT, OSTS_PAUSE</b> . <br>  Status <b>OSTS_DELAY</b> memiliki tugas yang memenuhi <i>penundaan</i> . <br>  Status <b>OSTS_WAIT</b> ditugaskan untuk tugas-tugas yang <i>menunggu semafor, acara, atau pesan</i> (lebih banyak tentang mereka di bawah). <br><br>  Apa perbedaan antara <b>status OSTS_STOP</b> dan <b>OSTS_PAUSED</b> ? <br>  Jika karena alasan tertentu tugas menerima status <b>OSTS_STOP</b> , maka dimulainya kembali tugas tersebut (setelah menerima status <b>OSTS_READY</b> ) akan dilakukan dari titik masuknya, yaitu.  dari awal.  Dari status <b>OSTS_PAUSE,</b> tugas akan terus bekerja di tempat ditangguhkan. <br><br><h3>  Manajemen Status Tugas </h3><br>  Baik OS itu sendiri dapat secara otomatis mengelola tugas, serta pengguna, dengan memanggil layanan OS.  Ada beberapa layanan manajemen tugas (nama-nama semua layanan OS dimulai dengan awalan <b>OS_</b> ): <br><br><pre> <code class="vbscript hljs">OS_InitTask(task_label, task_prio) OS_Stop() OS_StopTask(task_label) OS_Pause() OS_PauseTask(task_label) OS_Resume() OS_ResumeTask(task_label) OS_Restart()</code> </pre> <br>  Masing-masing dari mereka memiliki dua opsi: <b>OS_service</b> dan <b>OS_serviceTask</b> (kecuali untuk layanan <b>OS_InitTask</b> , yang hanya memiliki satu opsi; layanan <b>OS_Init</b> menginisialisasi OS itu sendiri). <br><br>  Apa perbedaan antara <b>OS_service</b> dan <b>OS_serviceTask</b> ?  Metode pertama bertindak pada tugas itu sendiri yang menyebabkannya;  yang kedua memungkinkan Anda untuk mengatur sebagai argumen penunjuk ke tugas lain dan, dengan demikian, untuk mengelola yang lain dari satu tugas. <br><br><div class="spoiler">  <b class="spoiler_title">Tentang OS_Resume</b> <div class="spoiler_text">  Semua layanan manajemen tugas, kecuali OS_Resume dan OS_ResumeTask, secara otomatis memanggil pengelola tugas setelah pemrosesan.  Sebaliknya, layanan OS_Resume * hanya mengatur status tugas ke OSTS_READY.  Status ini akan diproses hanya ketika operator secara eksplisit dipanggil. <br></div></div><br><h3>  Prioritas dan antrian tugas </h3><br>  Seperti disebutkan di atas, dalam sistem nyata, beberapa tugas mungkin lebih penting, sementara yang lain mungkin sekunder.  Oleh karena itu, fitur yang berguna dari OS adalah kemampuan untuk menetapkan prioritas tugas.  Dalam hal ini, jika ada beberapa tugas <i>siap pakai</i> pada saat yang sama, OS pertama akan memilih tugas dengan prioritas tertinggi.  Jika <b>semua</b> tugas jadi memiliki prioritas yang sama, OS akan menjalankannya dalam lingkaran, dalam urutan yang disebut "carousel" atau round-robin. <br><br>  Dalam AQUA RTOS, prioritas diberikan ke tugas ketika <b>diparaf</b> melalui panggilan ke layanan <b>OS_InitTask</b> , yang <b>menerima</b> alamat tugas sebagai argumen pertama dan angka dari 1 hingga 15 sebagai argumen kedua. <i>Angka yang lebih rendah berarti prioritas yang lebih tinggi</i> .  Selama pengoperasian OS, perubahan prioritas yang ditugaskan untuk tugas tidak disediakan. <br><br><h3>  Keterlambatan </h3><br>  Dalam setiap tugas, penundaan diproses secara terpisah dari tugas-tugas lain. <br>  Jadi, sementara OS sedang mengerjakan penundaan satu tugas, yang lain dapat dieksekusi. <br>  Untuk organisasi keterlambatan disediakan layanan <b>OS_Delay |</b>  <b>OS_DelayTask</b> .  Argumennya adalah jumlah milidetik yang tugasnya <i>ditunda</i> .  Karena dimensi argumen adalah <b>dword</b> , penundaan maksimum adalah 4294967295 ms, atau sekitar 120 jam, yang tampaknya cukup untuk sebagian besar aplikasi.  Setelah memanggil layanan penundaan, operator dipanggil secara otomatis, yang mentransfer kontrol ke tugas-tugas lain selama durasi penundaan. <br><br><h3>  Semafor </h3><br>  Semafor dalam AQUA RTOS adalah sesuatu seperti flag dan variabel yang tersedia untuk tugas.  Mereka ada dua jenis - biner dan dapat dihitung.  Yang pertama hanya memiliki dua status: gratis dan tertutup.  Yang kedua adalah byte counter (layanan penghitungan semaphores dalam versi AQUA RTOS saat ini tidak diterapkan (saya seorang pemalas), jadi semua yang dikatakan di bawah ini hanya berlaku untuk semaphore biner). <br><br>  Perbedaan antara semafor dan bendera sederhana adalah bahwa tugas dapat dibuat untuk <i>menunggu rilis</i> semafor yang ditentukan.  Dalam beberapa hal, penggunaan semaphore benar-benar menyerupai jalur kereta api: setelah mencapai semaphore, komposisi (tugas) akan memeriksa semaphore, dan jika tidak terbuka, itu akan menunggu sinyal yang memungkinkan untuk muncul untuk melangkah lebih jauh.  Pada saat ini, kereta lain (tugas) dapat terus bergerak (lari). <br><br>  Dalam hal ini, semua pekerjaan hitam ditugaskan ke operator.  Segera setelah tugas disuruh menunggu semafor, kontrol secara otomatis ditransfer ke operator, dan dia dapat memulai tugas lain - tepat sampai semafor yang ditentukan dibebaskan.  Segera setelah status semafor berubah menjadi <i>bebas</i> , operator akan memberikan semua tugas yang menunggu semafor ini menjadi status <i>siap</i> ( <b>OSTS_READY</b> ), dan tugas tersebut akan dieksekusi dalam urutan prioritas dan prioritas. <br>  Secara total, AQUA RTOS menyediakan 16 semaphore biner (angka ini pada prinsipnya dapat ditingkatkan dengan mengubah dimensi variabel di unit kontrol tugas, karena di dalamnya diimplementasikan sebagai bit flags). <br>  Semaphore biner bekerja melalui layanan berikut: <br><br><pre> <code class="vbscript hljs">hBSem OS_CreateBSemaphore() OS_WaitBSemaphore(hBSem) OS_WaitBSemaphoreTask(task_label, hBSem) OS_BusyBSemaphore(hBSem) OS_FreeBSemaphore(hBSem)</code> </pre> <br>  Sebelum menggunakan semaphore harus <i>dibuat</i> .  Ini dilakukan dengan memanggil layanan <b>OS_CreateBSemaphore</b> , yang mengembalikan pengidentifikasi byte unik (pegangan) dari semaphore <b>hBSem yang</b> dibuat, atau melalui handler yang ditentukan pengguna menghasilkan kesalahan <b>OSERR_BSEM_MAX_REACHED</b> , yang menunjukkan bahwa jumlah semafor biner biner maksimum yang mungkin telah dicapai. <br><br>  Anda dapat bekerja dengan pengenal yang diterima dengan mengirimkannya sebagai argumen ke layanan semafor lainnya. <br><br>  Layanan <b>OS_WaitBSemaphore |</b>  <b>OS_WaitBSemaphoreTask</b> menempatkan tugas (saat ini | ditentukan) dalam keadaan untuk <i>menunggu rilis semafor</i> <b>hBSem</b> jika semafor ini sibuk, dan kemudian mentransfer kontrol ke operator sehingga dapat memulai tugas-tugas lain.  Jika semaphore gratis, kontrol transfer tidak terjadi, dan tugas hanya berlanjut. <br><br>  Layanan <b>OS_BusyBSemaphore</b> dan <b>OS_FreeBSemaphore</b> mengatur semaphore <b>hBSem</b> menjadi <i>sibuk</i> atau <i>bebas,</i> masing-masing. <br><br>  Penghancuran semaphores untuk menyederhanakan OS dan mengurangi jumlah kode tidak disediakan.  Dengan demikian, semua semaphores yang dibuat bersifat statis. <br><br><h3>  Acara </h3><br>  Selain semafor, tugas dapat didorong oleh peristiwa.  Satu tugas dapat diinstruksikan untuk <i>mengharapkan peristiwa tertentu</i> , dan tugas lain (serta kode latar belakang) dapat <i>memberi sinyal</i> acara ini.  Pada saat yang sama, semua tugas yang menunggu acara ini akan menerima status <i>siap dieksekusi</i> ( <b>OSTS_READY</b> ) dan akan ditetapkan oleh operator untuk dieksekusi dalam urutan prioritas dan prioritas. <br><br>  Peristiwa apa yang bisa ditanggapi tugas?  Nah, misalnya: <br><ul><li>  gangguan; </li><li>  terjadinya kesalahan; </li><li>  pelepasan sumber daya (kadang-kadang lebih mudah untuk menggunakan semaphore untuk ini); </li><li>  mengubah status jalur I / O atau menekan tombol pada keyboard; </li><li>  menerima atau mengirim karakter melalui RS-232; </li><li>  transfer informasi dari satu bagian aplikasi ke yang lain (lihat juga pesan). </li></ul><br>  Sistem acara diimplementasikan melalui layanan berikut: <br><br><pre> <code class="vbscript hljs">hEvent OS_CreateEvent() OS_WaitEvent(hEvent) OS_WaitEventTask(task_label, hEvent) OS_WaitEventTO(hEvent, dwTimeout) OS_SignalEvent(hEvent)</code> </pre> <br>  Sebelum menggunakan suatu acara, Anda harus <i>membuatnya</i> .  Ini dilakukan dengan memanggil fungsi <b>OS_CreateEvent</b> , yang mengembalikan pengidentifikasi byte unik (handle) untuk acara <b>hEvent</b> , atau melempar kesalahan <b>OSERR_EVENT_MAX_REACHED</b> melalui handler yang ditentukan pengguna, menunjukkan bahwa batas jumlah kejadian yang dapat dihasilkan dalam OS telah tercapai (maksimum 255 peristiwa berbeda). <br><br>  Untuk membuat tugas menunggu acara <b>hEvent</b> , panggil <b>OS_WaitEvent</b> dalam kodenya, dengan meneruskan gagang acara sebagai argumen.  Setelah memanggil layanan ini, kontrol akan ditransfer secara otomatis ke operator. <br><br>  Berbeda dengan layanan semaphore, layanan acara menyediakan opsi untuk menunggu acara dengan <i>batas waktu</i> .  Untuk melakukan ini, gunakan layanan <b>OS_WaitEventTO</b> .  Argumen kedua di sini Anda dapat menentukan jumlah milidetik yang tugasnya harapkan terjadi.  Jika waktu yang ditentukan telah kedaluwarsa, tugas akan menerima status <i>siap untuk dieksekusi</i> seolah-olah acara telah terjadi, dan akan ditetapkan oleh operator untuk melanjutkan eksekusi dalam urutan prioritas dan prioritas.  Tugas tersebut dapat mempelajari tentang fakta bahwa itu bukan peristiwa, tetapi batas waktu, dengan memeriksa bendera global <b>OS_TIMEOUT</b> . <br><br> <i></i>             <b>OS_SignalEvent</b> ,       .    ,   ,    <i>  </i> ,           . <br><br><h3>  </h3><br>        ,       :         ,           –   . <br>     : <br><br><pre> <code class="vbscript hljs">hTopic OS_CreateMessage() OS_WaitMessage(hTopic) OS_WaitMessageTask(task_label, hTopic) OS_WaitMessageTO(hTopic, dwTimeout) OS_SendMessage(hTopic, wMessage) word_ptr OS_GetMessage(hTopic) word_ptr OS_PeekMessage(hTopic) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> OS_GetMessageString(hTopic) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> OS_PeekMessageString(hTopic)</code> </pre> <br>    ,    <i> </i> .     <b>OS_CreateMessage</b> ,      <b>hTopic</b> ,       <b>OSERR_TOPIC_MAX_REACHED</b> ,   ,       ,     . <br><br>        <b>hTopic</b> ,      <b>OS_WaitMessage</b> ,      .          .  ,        <i>    <b>hTopic</b></i> . <br><br>     <b>OS_WaitMessageTO</b>    <b>OS_WaitEventTO</b>  . <br><br>      <b>OS_SendMessage</b> .     ,     ,   –   <b>word</b> .      ,   <i>  </i> , ,   ,    . <br><br>    ,     BASCOM  <b>varptr</b> , , : <br><br><pre> <code class="vbscript hljs">strMessage = <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span> OS_SendMessage hTopic, varptr (strMessage)</code> </pre> <br>     <b>OS_WaitMessage</b> ,  ,    ,          ,     —      .        .      <b>word</b> ,      ,    ,   .   <b>OS_GetMessage</b>   ,  <b>OS_PeekMessage</b>  . <br><br>     ,   ,    <b>OS_GetMessageString</b>  <b>OS_PeekMessageString</b> ,     ,   ,     . <br><br><h3>    </h3><br>        AQUA RTOS       <b>TIMER0</b> .  ,   (  )     .      , ..          .    1 . <br><br><h2>    AQUA RTOS </h2><br><h3>   </h3><br>       ,           .   <b>OS_SIM = TRUE | FALSE</b> ,    . <br><br>  ,      <b>OS_MAX_TASK</b> ,       .    ,     (  ),      .        ,   . <i>    ,    .</i> <br><br><h3>   </h3><br>    AQUA RTOS   .      <b>OS_Init</b> .      .    ,     –     .  ,   ,    –  . <br><br>         (    ) –      ,            .          ,      -    . <br><br> ,     AQUA RTOS            : <br><br><pre> <code class="vbscript hljs">OS_Init my_err_trap <span class="hljs-comment"><span class="hljs-comment">'... '... '... sub my_err_trap(err_code as byte) print err_code end sub</span></span></code> </pre> <br><h3>   </h3><br>     ,     : <br><br><pre> <code class="vbscript hljs">OS_InitTask task_1, <span class="hljs-number"><span class="hljs-number">1</span></span> OS_InitTask task_2 , <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">'... OS_InitTask task_N , 1</span></span></code> </pre> <br><h2>   </h2><br><h3>   </h3><br> ,    ,       Arduino Nano V3.       -  (, test),     bas-: <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_1() declare sub task_2() '       led_1 alias portd.4 led_2 alias portd.5 config portd.4 = output config portd.5 = output ' ***    *** '   OS_Init my_err_trap '   OS_InitTask task_1, 1 OS_InitTask task_2 , 1 '      «» (OSTS_STOP) '    ,     ' «  » (OSTS_READY)   OS_ResumeTask OS_ResumeTask task_1 OS_ResumeTask task_2 '      OS_Sheduler end ' ***  *** sub task_1 () do toogle led_1 '   1 OS_delay 1000 '   1000  loop end sub sub task_2 () do toogle led_2 '   2 OS_delay 333 '   333  loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br>      <b>D4</b>  <b>D5</b>  Arduino (   ,   -  ).     100...500     <b>GND</b> .      .       2  0,66 . <br><br>   . ,     (  ,      aliases),  –  ,   – . <br><br>         «»,     «  » (,       –  -           ,        ,      ;          ).        <b>OS_ResumeTask</b> . <br><br>     ,    .    ? , !          . ,    ,      ,         <b>end</b> . <br><br>    .    ,         <b>do – loop</b> .    –            ,   ,      –       ,      .       <b>OS_Delay</b> .        ,       . <br><br>       <b>OS_SIM = TRUE</b>       ,   ,   ,   . <br><br> ,   , ,      «  »,       .   ,    «   »,         . <br><br>  ,    (, <b>task_1</b> ),       (     <b>end</b>   )     <b>task_1</b> ,       ,    <b>return</b> ,             –  ,    <b>task_1</b> ( <b>do</b>   <b>task_1</b> ). <br><br>  <b>task_1</b> ,   ,   <b>OS_delay</b> , ,   ,   . <br><br>   ,    ,     <b>task_1</b> (  ,    <b>OS_delay</b> , ..  <b>loop</b> ),  , « », ,      <b>task_2</b> .       <b>task_2</b> (      <b>do</b>    <b>task_2</b> )    <b>return</b> ,             –  ,    <b>task_2</b> . <br><br>  <b>task_2</b> ,   ,   <b>OS_delay</b> , ,   ,   . <br><br>   ,    ,     <b>task_1</b> (  ,    <b>OS_delay</b> , ..  <b>loop</b> ),  , « », ,      <b>task_2</b> .       ,       <b>task_1</b>     ,   ,      .  (  <b>loop</b>    <b>task_1</b> ),    . <br><br>  <b>task_1</b>   <b>loop</b> ,     « 1 –  –  2 – »   . <br><br><h3>   </h3><br>         . <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_1() declare sub task_2() const OS_SIM = TURE '       '   dim hTopic as byte '     dim task_1_cnt as byte '    1 dim strMessage as string * 16 '  ' ***    *** OS_CreateMessage hTopic OS_Init my_err_trap OS_InitTask task_1 , 1 OS_InitTask task_2 , 1 OS_ResumeTask task_1 OS_ResumeTask task_2 OS_Sheduler end ' ***  *** sub task_1() do print "task 1" OS_Sheduler incr task_1_cnt '    1 if task_1_cnt &gt; 3 then print "task 1 is sending message to task 2" strMessage = "Hello, task 2!" '    2 OS_SendMessage hTopic , varptr(strMessage) task_1_cnt = 0 end if loop end sub sub task_2() do print "task 2 is waiting messages..." '      1 OS_WaitMessage hTopic print "message recieved: " ; OS_GetMessageString (hTopic) loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br>           : <br><br><blockquote> task 1 <br> task 2 is waiting messages… <br> task 1 <br> task 1 <br> task 1 <br> task 1 is sending message to task 2 <br> task 1 <br> message recieved: Hello, task 2! <br> task 2 is waiting messages… <br> task 1 <br> task 1 <br>  ... <br></blockquote><br>  ,        .    1  <b>task 1</b> ,     ,      .  2  <b>task 2 is waiting messages...</b> ,        <b>hTopic</b> ,     ,     1.    <b>task 1</b>     . ,   ,   2   ,     1   <b>incr</b> ,    . <br>   <b>task_1_cnt</b>   1   ,   ,    –   <b>loop</b>    <b>task 1</b> .     ,   ,    2  ,    .    . <br><br><h3>   </h3><br>             : <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_scankeys() declare sub task_led_1() declare sub task_led_2() '        led_1 alias portd.4 led_2 alias portd.5 config portd.4 = output config portd.5 = output button_1 alias pind.6 button_2 alias pind.7 config portd.6 = input config portd.7 = input '   dim eventButton_1 as byte dim eventButton_2 as byte ' ***    *** eventButton_1 = OS_CreateEvent '       eventButton_2 = OS_CreateEvent OS_Init my_err_trap OS_InitTask task_scankeys , 1 OS_InitTask task_led_1 , 1 OS_InitTask task_led_2 , 1 OS_ResumeTask task_scankeys OS_ResumeTask task_led_1 OS_ResumeTask task_led_2 OS_Sheduler end ' ***  *** sub task_scankeys() do debounce button_1 , 0 , btn_1_click , sub debounce button_2 , 0 , btn_2_click , sub OS_Sheduler loop btn_1_click: OS_SignalEvent eventButton_1 return btn_2_click: OS_SignalEvent eventButton_2 return end sub sub task_led_1() do OS_WaitEvent eventButton_1 toggle led_1 loop end sub sub task_led_2() do OS_WaitEvent eventButton_2 toggle led_2 loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br><h2>     AQUA RTOS </h2><br><br>   ,         .           ;     ,   ,  .  ,     : ,      95…97°;               (,  GSM-),      . <br><br><h3>    </h3><br>         « +  + »  ,     .     ,    . <br>        : <br><br><ul><li>     – <b>ControlHeater()</b> </li><li>      – <b>ShowGoods()</b> </li><li>  /    – <b>AcceptMoney()</b> </li><li>   – <b>ScanKeys()</b> </li><li>   – <b>MakeChange()</b> </li><li>   – <b>ReleaseCoffee()</b> </li><li>    – <b>Alarm()</b> </li></ul><br>        . <br> <b>ControlHeater()</b>  ,        .       ,      ,    .      .     5. <br> <b>ShowGoods()</b>   .       ,   -   .      8,             . <br> <b>ScanKeys()</b>     ,       .     3,      40 . <br> <b>AcceptMoney()</b>     .      ,   <b>ScanKeys(),</b>     20 . <br> <b>MakeChange ()</b>     .     <b>ReleaseCoffee()</b>    10. <br> <b>ReleaseCoffee()</b>   ,           .       2. <br>   –    ,  <b>Alarm()</b>      – 1,     ,      . <br><br>  ,       .  ,      EEPROM   ,       . <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    declare sub ControlHeater() declare sub ShowGoods() declare sub AcceptMoney() declare sub ScanKeys() declare sub MakeChange () declare sub ReleaseCoffee() declare sub Alarm()</span></span></code> </pre> <br>     RTOS      :          (  ,    ) –      . <br><br> , <b>ReleaseCoffee()</b>    : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> ReleaseCoffee() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> OS_WaitMessage bCoffeeSelection wItem = OS_GetMessage(bCoffeeSelection) Release wItem <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span></code> </pre> <br>  <b>ReleaseCoffee</b>        <b>bCoffeeSelection</b>    ,     (   ,      ).    , <b>ReleaseCoffee()</b>    ,    ,     (  ) <b>wItem</b>    <b>OS_GetMessage</b>    .  <b>ReleaseCoffee()</b>   ,       : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> bCoffeeSelection as byte bCoffeeSelection = OS_CreateMessage()</code> </pre> <br>    , <b>ShowGoods()</b>            .       <b>ReleaseCoffee()</b> ,   .       : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> bGoodsReliased as byte bGoodsReliased = OS_CreateEvent()</code> </pre> <br>    <b>ReleaseCoffee()</b>   <b>Release wItem</b>     <b>bGoodsReliased</b> : <br><br><pre> <code class="vbscript hljs">OS_SignalEvent bGoodsReliased</code> </pre> <br><h3>   </h3><br>  ,     ,    ,      ,     .      <b>OS_Init</b> : <br><br><pre> <code class="vbscript hljs">OS_Init Mailfuncion</code> </pre> <br>       – ,      : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> Mailfuncion (bCoffeeErr) print <span class="hljs-string"><span class="hljs-string">"Mailfunction! Error #: "</span></span>; bCoffeeErr <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isErrCritical (bCoffeeErr) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallService(bCoffeeErr) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span></code> </pre><br>      (    -  :  ,  GSM-  ..),   ,   ,    . <br><br><h3>   </h3><br>   ,  ,   ..     ,   .  ,           <b>OS_InitTask</b> : <br><br><pre> <code class="vbscript hljs">OS_InitTask ControlHeater , <span class="hljs-number"><span class="hljs-number">5</span></span> OS_InitTask ShowGoods , <span class="hljs-number"><span class="hljs-number">8</span></span> OS_InitTask AcceptMoney , <span class="hljs-number"><span class="hljs-number">3</span></span> OS_InitTask ScanKeys , <span class="hljs-number"><span class="hljs-number">3</span></span> OS_InitTask MakeChange, <span class="hljs-number"><span class="hljs-number">10</span></span> OS_InitTask ReleaseCoffee , <span class="hljs-number"><span class="hljs-number">2</span></span> OS_InitTask Alarm , <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>      , ,    , ,         .          .     ,      <b>OS_ResumeTask</b>    «  »: <br><br><pre> <code class="vbscript hljs">OS_ResumeTask ControlHeater OS_ResumeTask ShowGoods OS_ResumeTask AcceptMoney OS_ResumeTask ScanKeys OS_ResumeTask MakeChange OS_ResumeTask ReleaseCoffee OS_ResumeTask Alarm</code> </pre> <br>   ,         ;          «»       .  <b>OS_ResumeTask</b>           (  ),    . ,  ,    ,   . <br><br><h3>   </h3><br>     ,   .     : <br><br><pre> <code class="vbscript hljs">OS_Sheduler</code> </pre> <br>          <b>end</b> –         . <br><br>     : <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $include "coffee_hardware.bas" '      '       Coffee_ $regfile = "m328pdef.dat" ' Arduino Nano v3 $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 Coffee_InitHardware '    '   declare sub Mailfuncion (byval bCoffeeErr as byte) '   declare sub ControlHeater () '   declare sub ShowGoods () '    declare sub AcceptMoney () '   declare sub ScanKeys () '   declare sub MakeChange () '      declare sub ReleaseCoffee () '   declare sub Alarm () '    '     Coffee_InitHardware () '   dim wMoney as long '    dim wGoods as long '   ' ***    *** '   OS_Init Mailfuncion '       dim bCoffeeSelection as byte bCoffeeSelection = OS_CreateMessage() '     dim bGoodsReliased as byte bGoodsReliased = OS_CreateEvent() '   OS_InitTask ControlHeater , 5 OS_InitTask ShowGoods , 8 OS_InitTask AcceptMoney , 3 OS_InitTask ScanKeys , 3 OS_InitTask MakeChange, 10 OS_InitTask ReleaseCoffee , 2 OS_InitTask Alarm , 1 '     OS_ResumeTask ControlHeater OS_ResumeTask ShowGoods OS_ResumeTask AcceptMoney OS_ResumeTask ScanKeys OS_ResumeTask MakeChange OS_ResumeTask ReleaseCoffee OS_ResumeTask Alarm '   OS_Sheduler end ' ***   *** ' ----------------------------------- sub ControlHeater() do select case GetWaterTemp() case is &gt; 97 Coffee_HeaterOff '   case is &lt; 95 Coffee_HeaterOn '   case is &lt; 5 CallServce (WARNING_WATER_FROZEN) '   end select OS_Delay 60000 '  1  loop end sub ' ----------------------------------- sub ShowGoods() do LEDS = Coffee_GetDrinkSupplies() '    D, '         '   LEDS OS_WaitEvent bGoodsReliased '   " " loop end sub ' ----------------------------------- sub AcceptMoney() do wMoney = wMoney + ReadMoneyAcceptor() OS_Delay 20 loop end sub ' ----------------------------------- sub ScanKeys() do wGoods = ButtonPressed() if wMoney &gt;= GostOf(wGoods) then OS_SendMessage bCoffeeSelection, wGoods '     bCoffeeSelection,  '     end if OS_Delay 40 loop end sub ' ----------------------------------- sub MakeChange() do OS_WaitEvent bGoodsReliased '   " " Refund wMoney loop end sub ' ----------------------------------- sub ReleaseCoffee() do OS_WaitMessage bCoffeeSelection '  bCoffeeSelection wItem = OS_GetMessage(bCoffeeSelection) '   Release wItem '    wMoney = wMoney – CostOf (wItem) '     OS_SignalEvent bGoodsReliased '     '  ,       : ' MakeChange  ShowGoods '  ,  ,     loop end sub ' ----------------------------------- sub Alarm() do OS_Delay 1000 if Hijack() = 1 then CallPolice() end if loop end sub ' ----------------------------------- ' ***    *** sub Mailfuncion (bCoffeeErr) print "Mailfunction! Error #: "; bCoffeeErr if isErrCritical (bCoffeeErr) = 1 then CallService() end if end sub</span></span></code> </pre> <br> ,             ,    .              <b>OS_SendMessage()</b>  ,        /.     .  ,   ,  ,  ,     . <br><br><h2>   AQUA RTOS </h2><br> <a href=""><b>   1.05     </b></a> <br><br><h2>  </h2><br> <i>Q:  AQUA?</i> <br> A: ,    ,   « »,   ,   .   ,   ,     ,  ,  « »   WiFi-.   ,  ,  ,     EEPROM  ,  , - .            .      –       « »,    ,  .    ,    .    AQUA. <br><br> <i>Q:        ?</i> <br> A: . ,  ,          ,      ,    ,    .   ,        .    ,   ,      ,       ,    ,  , -,  .   ,         . , -     ( ? –   )    .         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453708/">https://habr.com/ru/post/id453708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453694/index.html">Terhubung ke Windows melalui SSH seperti di Linux</a></li>
<li><a href="../id453696/index.html">Ikatan dua arah sudut, sedikit lebih pengertian</a></li>
<li><a href="../id453698/index.html">Informasi kuantum dalam kesadaran kuantum</a></li>
<li><a href="../id453700/index.html">Pelajaran tentang SDL 2: Pelajaran 1 - Halo, SDL 2</a></li>
<li><a href="../id453706/index.html">Bagaimana Saya Lulus dari Ujian Sertifikasi Insinyur Data Google Cloud Professional</a></li>
<li><a href="../id453710/index.html">Praktik pengembangan dalam proyek-proyek besar: mitp SberPractice iOS # 1</a></li>
<li><a href="../id453712/index.html">Bagaimana eBay melakukan pemindai barcode di WebAssembly</a></li>
<li><a href="../id453714/index.html">Klien uji TON (Telegram Open Network) dan bahasa Fift baru untuk kontrak pintar</a></li>
<li><a href="../id453716/index.html">Rekan kerja negara untuk keluarga orang IT - adakah orang?</a></li>
<li><a href="../id453720/index.html">Subtleties dari Ekspresi Lambda di C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>