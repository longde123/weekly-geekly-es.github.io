<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèª üë®üèº‚Äçüè´ üí† C√≥mo funciona CPU Manager en Kubernetes üë©üèª‚Äç‚öñÔ∏è üöÖ üë©üèº‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : Este art√≠culo fue publicado en el blog oficial de Kubernetes y fue escrito por dos empleados de Intel que est√°n directamente involucrado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona CPU Manager en Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/418269/">  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: Este art√≠culo fue publicado en el blog oficial de Kubernetes y fue escrito por dos empleados de Intel que est√°n directamente involucrados en el desarrollo de CPU Manager, una nueva caracter√≠stica en Kubernetes sobre la que escribimos en la revisi√≥n de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n 1.8</a> .</i>  <i>En este momento (es decir, para K8s 1.11), esta caracter√≠stica tiene estado beta y m√°s informaci√≥n sobre su prop√≥sito m√°s adelante en la nota.</i> <br><br>  La publicaci√≥n habla sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administrador de CPU</a> , una funci√≥n beta en Kubernetes.  CPU Manager le permite distribuir mejor las cargas de trabajo en Kubelet, es decir  en el agente host de Kubernetes, asignando CPU dedicadas a contenedores de un hogar espec√≠fico. <br><br><img src="https://habrastorage.org/webt/h-/5g/yo/h-5gyocq5lrz2vsvso7ioblnb3q.png"><a name="habracut"></a><br><br><h2>  Suena genial!  ¬øPero el CPU Manager me ayudar√°? </h2><br>  Depende de la carga de trabajo.  El √∫nico nodo de c√≥mputo en el cl√∫ster de Kubernetes puede ejecutar muchos hogares, y algunos de ellos pueden ejecutar cargas que est√°n activas en el consumo de CPU.  En este escenario, los hogares pueden competir por los recursos de proceso disponibles en este nodo.  Cuando esta competencia se intensifica, la carga de trabajo puede cambiar a otras CPU dependiendo de si se <i>estrangul√≥</i> y qu√© CPU estaban disponibles en el momento de la planificaci√≥n.  Adem√°s, puede haber casos en los que la carga de trabajo sea sensible a los cambios de contexto.  En todos estos escenarios, el rendimiento de la carga de trabajo puede verse afectado. <br><br>  Si su carga de trabajo es sensible a tales escenarios, puede habilitar CPU Manager para proporcionar un mejor aislamiento del rendimiento al asignar CPU espec√≠ficas a la carga. <br><br>  CPU Manager puede ayudar con cargas con las siguientes caracter√≠sticas: <br><br><ul><li>  Sensible a los efectos de aceleraci√≥n de la CPU </li><li>  sensible a los cambios de contexto; </li><li>  el cach√© del procesador falla; </li><li>  Beneficiarse de dividir los recursos del procesador (por ejemplo, cach√© de datos e instrucciones); </li><li>  memoria sensible a la memoria entre los z√≥calos del procesador <i>(se proporciona una explicaci√≥n detallada de lo que los autores tienen en mente en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unix Stack Exchange</a> - <b>traducci√≥n aprox.</b> )</i> ; </li><li>  hyperthreads sensibles o que requieren el mismo n√∫cleo f√≠sico de la CPU. </li></ul><br><h2>  Ok!  ¬øC√≥mo usarlo? </h2><br>  Usar CPU Manager es f√°cil.  Primero, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habil√≠telo utilizando la Pol√≠tica est√°tica</a> en Kubelet que se ejecuta en los nodos de proceso del cl√∫ster.  Luego configure la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Calidad de servicio <i>garantizada</i> (QoS)</a> para el hogar.  Solicite un n√∫mero entero de n√∫cleos de CPU (por ejemplo, <code>1000m</code> o <code>4000m</code> ) para contenedores que necesitan n√∫cleos dedicados.  Cree bajo el m√©todo anterior (por ejemplo, <code>kubectl create -f pod.yaml</code> ) ... y listo, el Administrador de CPU asignar√° n√∫cleos de procesador dedicados a cada contenedor de solera seg√∫n sus necesidades de CPU. <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod metadata: name: exclusive-2 spec: containers: - image: quay.io/connordoyle/cpuset-visualizer name: exclusive-2 resources: # Pod is in the Guaranteed QoS class because requests == limits requests: # CPU request is an integer cpu: 2 memory: "256M" limits: cpu: 2 memory: "256M"</code> </pre> <br>  <i>Especificaci√≥n de un hogar que solicita 2 CPU dedicadas.</i> <br><br><h2>  ¬øC√≥mo funciona el Administrador de CPU? </h2><br>  Consideramos tres tipos de control de recursos de CPU disponibles en la mayor√≠a de las distribuciones de Linux, que ser√°n relevantes para Kubernetes y los prop√≥sitos de esta publicaci√≥n.  Los dos primeros son recursos compartidos de CFS (cu√°l es mi parte "honesta" ponderada del tiempo de CPU en el sistema) y la cuota de CFS (cu√°l es el tiempo m√°ximo de CPU que me asignaron para el per√≠odo).  CPU Manager tambi√©n usa un tercero, que se llama afinidad de CPU (en las cuales las CPU l√≥gicas me permiten realizar c√°lculos). <br><br>  De forma predeterminada, todos los pods y contenedores que se ejecutan en el nodo del cl√∫ster de Kubernetes pueden ejecutarse en cualquier n√∫cleo del sistema disponible.  El n√∫mero total de recursos compartidos y la cuota asignada est√° limitado por los recursos de CPU reservados para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes y los demonios del sistema</a> .  Sin embargo, los l√≠mites en el tiempo de CPU utilizado pueden determinarse utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">l√≠mites en la CPU en la especificaci√≥n de hogar</a> .  Kubernetes usa la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuota CFS</a> para imponer los l√≠mites de CPU en los contenedores de hogar. <br><br>  Cuando habilita el Administrador de CPU con una pol√≠tica <i>est√°tica</i> , administra un grupo dedicado de CPU.  Inicialmente, este grupo contiene toda la CPU del nodo de proceso.  Cuando Kubelet crea un contenedor en el hogar con un n√∫mero garantizado de n√∫cleos de procesador dedicados, las CPU asignadas a este contenedor se le asignan durante toda su vida √∫til y se eliminan del grupo compartido.  Las cargas de los contenedores restantes se transfieren de estos n√∫cleos dedicados a otros. <br><br>  Todos los contenedores sin CPU dedicadas ( <i>Burstable</i> , <i>BestEffort</i> y <i>Garantizado con CPU no enteras</i> ) se ejecutan en los n√∫cleos que quedan en el grupo compartido.  Cuando un contenedor con CPU dedicadas deja de funcionar, sus n√∫cleos regresan al grupo compartido. <br><br><h2>  M√°s detalles, por favor ... </h2><br><img src="https://habrastorage.org/webt/cr/w-/-8/crw--8xnqnkcu8fl18xxbbeyfzk.png"><br><br>  El diagrama de arriba muestra la anatom√≠a del Administrador de CPU.  Utiliza el m√©todo <code>UpdateContainerResources</code> de la Interfaz de tiempo de ejecuci√≥n de contenedor (CRI) para cambiar las CPU en las que se ejecutan los contenedores.  <i>El administrador</i> hace <code>cgroupfs</code> peri√≥dicamente <code>cgroupfs</code> con el estado actual de los recursos de la CPU para cada contenedor en ejecuci√≥n. <br><br>  El Administrador de CPU utiliza <a href=""><i>pol√≠ticas</i></a> para decidir la asignaci√≥n de n√∫cleos de CPU.  Se implementan dos pol√≠ticas: <i>Ninguna</i> y <i>Est√°tica</i> .  Por defecto, comenzando con Kubernetes versi√≥n 1.10, est√° habilitado con la pol√≠tica <i>Ninguno</i> . <br><br>  La pol√≠tica <i>est√°tica</i> asigna contenedores de pod asignados a la CPU a la clase de QoS garantizada, que solicita un n√∫mero entero de n√∫cleos.  La pol√≠tica <i>est√°tica</i> intenta designar la CPU de la mejor manera topol√≥gica y en el siguiente orden: <br><br><ul><li>  Asigne todas las CPU a un z√≥calo de procesador, si est√° disponible y el contenedor requiere una CPU en la cantidad de al menos un z√≥calo de CPU completo. </li><li>  Asigne todas las CPU l√≥gicas (hyperthreads) de un n√∫cleo de CPU f√≠sico, si est√° disponible, y el contenedor requiere una CPU de al menos todo el n√∫cleo. </li><li>  Asigne cualquier CPU l√≥gica disponible con preferencia para CPU de un solo socket. </li></ul><br><h2>  ¬øC√≥mo CPU Manager mejora el aislamiento de c√≥mputo? </h2><br>  Con la pol√≠tica <i>est√°tica</i> habilitada en el Administrador de CPU, las cargas de trabajo pueden funcionar mejor por uno de los siguientes motivos: <br><br><ul><li>  Las CPU dedicadas se pueden asignar a un contenedor con una carga de trabajo, pero no a otros contenedores.  Estos (otros) contenedores no usan los mismos recursos de CPU.  Como resultado, esperamos un mejor rendimiento debido al aislamiento en casos de aparici√≥n de un "agresor" <i>(procesos exigentes de la CPU - <b>aprox. Transl.</b> )</i> O carga de trabajo adyacente. </li><li>  Hay menos competencia por los recursos utilizados por la carga de trabajo, ya que podemos dividir la CPU por la carga de trabajo misma.  Estos recursos pueden incluir no solo la CPU, sino tambi√©n jerarqu√≠as de cach√© y ancho de banda de memoria.  Esto mejora el rendimiento general de la carga de trabajo. </li><li>  El Administrador de CPU asigna la CPU en un orden topol√≥gico basado en las mejores opciones disponibles.  Si todo el socket est√° libre, asignar√° todas sus CPU a la carga de trabajo.  Esto mejora el rendimiento de la carga de trabajo debido a la falta de tr√°fico entre sockets. </li><li>  Los contenedores en c√°psulas con QoS <i>garantizada</i> est√°n sujetos al l√≠mite de cuota CFS.  Las cargas de trabajo propensas a explosiones repentinas pueden planificarse y exceder su cuota antes del final de su per√≠odo asignado, como resultado de lo cual se <i>estrangulan</i> .  Las CPU involucradas en este momento pueden tener un trabajo significativo y no muy √∫til.  Sin embargo, dichos contenedores no estar√°n sujetos a la limitaci√≥n de CFS cuando la CPU de cuota se complementa con una pol√≠tica de asignaci√≥n de CPU dedicada. </li></ul><br><h2>  Ok!  ¬øTienes alg√∫n resultado? </h2><br>  Para ver las mejoras de rendimiento y el aislamiento proporcionados por la inclusi√≥n del Administrador de CPU en Kubelet, realizamos experimentos en un nodo de c√≥mputo con dos sockets (Intel Xeon CPU E5-2680 v3) y hyperthreading habilitado.  El nodo consta de 48 CPU l√≥gicas (24 n√∫cleos f√≠sicos, cada uno con hyperthreading).  A continuaci√≥n se muestran los beneficios de rendimiento y aislamiento del Administrador de CPU capturados por las cargas de trabajo de referencia y de la vida real en tres escenarios diferentes. <br><br><h3>  ¬øC√≥mo interpretar gr√°ficos? </h3><br>  Para cada escenario, se muestran gr√°ficos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diagramas de tramo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diagramas de</a> caja) que ilustran el tiempo de ejecuci√≥n normalizado y su variabilidad al iniciar un punto de referencia o una carga real con el Administrador de CPU encendido y apagado.  El tiempo de ejecuci√≥n se normaliza a los mejores lanzamientos (1.00 en el eje Y representa el mejor tiempo de inicio: cuanto menor sea el valor del gr√°fico, mejor).  La altura del gr√°fico en el gr√°fico muestra la variabilidad en el rendimiento.  Por ejemplo, si el sitio es una l√≠nea, entonces no hay variaci√≥n en el rendimiento de estos lanzamientos.  En estas √°reas, la l√≠nea media es la mediana, la superior es el percentil 75 y la inferior es el percentil 25.  La altura del gr√°fico (es decir, la diferencia entre los percentiles 75 y 25) se define como el rango intercuartil (IQR).  "Bigote" muestra datos fuera de este intervalo, y los puntos muestran valores at√≠picos.  Las emisiones se definen como cualquier dato que difiere del IQR en 1,5 veces, menos o m√°s que el cuartil correspondiente.  Cada experimento se llev√≥ a cabo 10 veces. <br><br><h3>  Protecci√≥n agresiva </h3><br>  Lanzamos seis benchmark'ov desde un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de PARSEC</a> (cargas de trabajo - "v√≠ctimas") <i>[se puede leer m√°s sobre las cargas de trabajo de las v√≠ctimas, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> - <b>aprox.</b></i>  <i><b>perev.</b></i>  <i>]</i> junto al contenedor que carga la CPU (carga de trabajo "agresor") con el Administrador de CPU activado y desactivado. <br><br>  El contenedor del agresor se inicia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como debajo</a> con la clase de QoS de <i>Burstable que</i> solicita el indicador de CPU 23 <code>--cpus 48</code> .  Los puntos de referencia se ejecutan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como pods</a> con la clase QoS <i>garantizada</i> , que requiere un conjunto de CPU de un socket completo (es decir, 24 CPU en este sistema).  Los gr√°ficos a continuaci√≥n muestran el tiempo de inicio del pod normalizado con un punto de referencia junto al agresor del pod, con la pol√≠tica <i>est√°tica de</i> CPU Manager y sin ella.  En todos los casos de prueba, puede ver un rendimiento mejorado y una variabilidad de rendimiento reducida con la pol√≠tica habilitada. <br><br><img src="https://habrastorage.org/webt/tb/aj/gu/tbajgurqlbubtzm3il4d9vzoh8i.png"><br><br><h3>  Aislamiento para cargas adyacentes. </h3><br>  Esto demuestra cu√°n √∫til puede ser el Administrador de CPU para muchas cargas de trabajo ubicadas conjuntamente.  Los diagramas de intervalo a continuaci√≥n muestran el rendimiento de dos puntos de referencia del conjunto PARSEC ( <i>Blackscholes</i> y <i>Canneal</i> ) lanzado para las clases de QoS <i>Garantizadas</i> (Gu) y <i>Burstable</i> (Bu) adyacentes entre s√≠, con la pol√≠tica <i>est√°tica</i> activada y desactivada. <br><br>  Siguiendo en el sentido de las agujas del reloj desde el gr√°fico superior izquierdo, vemos el rendimiento de <i>Blackscholes</i> para Bu QoS (arriba a la izquierda), <i>Canneal</i> para Bu QoS (arriba a la derecha), <i>Canneal</i> para Gu QoS (abajo a la derecha) y <i>Blackscholes</i> para Gu QoS (abajo a la izquierda).  En cada gr√°fico, se ubican (en sentido horario nuevamente) junto con <i>Canneal</i> para Gu QoS (arriba a la izquierda), <i>Blackscholes</i> para Gu QoS (arriba a la derecha), <i>Blackscholes</i> para Bu QoS (abajo a la derecha) y <i>Canneal</i> para Bu QoS (abajo a la izquierda) en consecuencia  Por ejemplo, el <i>gr√°fico Bu-blackscholes-Gu-canneal</i> (arriba a la izquierda) muestra el rendimiento de <i>Blackscholes</i> con Bu QoS y ubicado junto a <i>Canneal</i> con la clase Gu QoS.  En cada caso, debajo de la clase Gu QoS requiere un n√∫cleo de socket completo (es decir, 24 CPU), y debajo de la clase Bu QoS - 23 CPU. <br><br>  Hay un mejor rendimiento y menos variaci√≥n en el rendimiento para ambas cargas de trabajo adyacentes en todas las pruebas.  Por ejemplo, mire <i>Bu-blackscholes-Gu-canneal</i> (arriba a la izquierda) y <i>Gu-canneal-Bu-blackscholes</i> (abajo a la derecha).  Muestran el rendimiento de ejecutar <i>Blackscholes</i> y <i>Canneal</i> con el Administrador de CPU activado y desactivado.  En este caso, <i>Canneal</i> recibe m√°s n√∫cleos dedicados del Administrador de CPU, ya que pertenece a la clase Gu QoS y solicita un n√∫mero entero de n√∫cleos de CPU.  Sin embargo, <i>Blackscholes tambi√©n</i> obtiene un conjunto dedicado de CPU, ya que esta es la √∫nica carga de trabajo en el grupo compartido.  Como resultado, tanto <i>Blackscholes</i> como <i>Canneal</i> aprovechan el aislamiento de carga cuando usan CPU Manager. <br><br><img src="https://habrastorage.org/webt/et/wj/93/etwj93f4gv4pbjyoq8-6_nfmtmm.png"><br><br><h3>  Aislamiento para cargas independientes </h3><br>  Demuestra cu√°n √∫til puede ser CPU Manager para cargas de trabajo independientes de la vida real.  Tomamos dos cargas de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelos oficiales de TensorFlow</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ancho y profundo</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ResNet</a> .  Se utilizan conjuntos de datos t√≠picos para ellos (censo y CIFAR10, respectivamente).  En ambos casos, los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hogares</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ancho y profundo</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ResNet</a> ) requieren 24 CPU, que corresponde a un z√≥calo completo.  Como se muestra en los gr√°ficos, en ambos casos el Administrador de CPU proporciona un mejor aislamiento. <br><br><img src="https://habrastorage.org/webt/ln/hv/a6/lnhva6g-1coouyustgjq-ziwybk.png"><br><br><h2>  Limitaciones </h2><br>  Los usuarios pueden querer que las CPU se asignen en un z√≥calo cercano al bus que se conecta a un dispositivo externo, como un acelerador o una tarjeta de red de alto rendimiento para evitar el tr√°fico entre los z√≥calos.  Este tipo de configuraci√≥n a√∫n no es compatible con el Administrador de CPU.  Dado que el Administrador de CPU proporciona la mejor asignaci√≥n posible de CPU que pertenecen a un socket o n√∫cleo f√≠sico, es sensible a casos extremos y puede conducir a la fragmentaci√≥n.  El Administrador de CPU no tiene en cuenta el par√°metro de arranque del kernel <code>isolcpus</code> Linux, aunque se usa como pr√°ctica popular en algunos casos <i>(para obtener m√°s detalles sobre este par√°metro, consulte, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , <b>aprox. Transl.</b> )</i> . <br><br><h2>  PD del traductor </h2><br>  Lea tambi√©n en nuestro blog: <br><br><ul><li>  ‚Äú¬øQu√© sucede en Kubernetes cuando comienza la ejecuci√≥n de kubectl?‚Äù: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øC√≥mo funciona realmente el planificador de Kubernetes?"</a>  "; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes: La vida del hogar</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CRI-O: una alternativa a Docker para lanzar contenedores en Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuestra experiencia con Kubernetes en peque√±os proyectos</a> " <i>(informe en video, que incluye una introducci√≥n al dispositivo t√©cnico de Kubernetes);</i> </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Infraestructura con Kubernetes como un servicio asequible</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418269/">https://habr.com/ru/post/es418269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418257/index.html">Github.com se niega a usar jQuery y cambia a JavaScript puro</a></li>
<li><a href="../es418261/index.html">Guante casero de pistola el√©ctrica: un arma para un geek</a></li>
<li><a href="../es418263/index.html">Cient√≠ficos rusos est√°n desarrollando un sistema MEG compacto y econ√≥mico</a></li>
<li><a href="../es418265/index.html">Organizaci√≥n de la interacci√≥n de red entre m√°quinas f√≠sicas y virtuales.</a></li>
<li><a href="../es418267/index.html">Resumen de eventos de TI de agosto</a></li>
<li><a href="../es418271/index.html">Rompe una l√≠nea por un separador. Un poco sobre CONECTAR POR</a></li>
<li><a href="../es418273/index.html">Las herramientas de desarrollo para la plataforma Baikal-T1 cambiaron a la distribuci√≥n rusa ALT</a></li>
<li><a href="../es418275/index.html">Lecciones de impresi√≥n 3D. Impresi√≥n de modelos de paredes delgadas desde 3Dtool</a></li>
<li><a href="../es418277/index.html">Dispositivo de sombras de caja</a></li>
<li><a href="../es418279/index.html">Restablecimiento de contrase√±a en Cisco ASA sin tiempo de inactividad para el circuito de conmutaci√≥n por error activo / en espera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>