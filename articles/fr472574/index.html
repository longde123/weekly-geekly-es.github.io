<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏿 👩🏻‍🤝‍👨🏼 🧔 Créez votre Minecraft: générez des niveaux 3D à partir de cubes 🤨 🐯 👨🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En partie en raison de la popularité de Minecraft , l'idée d'un jeu qui se déroule dans un monde en cubes construit en relief 3D et rempli d'éléments ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Créez votre Minecraft: générez des niveaux 3D à partir de cubes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472574/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jj/va/ccjjvazyarduee258az9-bbggkq.png"></div><br>  En partie en raison de la popularité de <b>Minecraft</b> , l'idée d'un jeu qui se déroule dans un monde en cubes construit en relief 3D et rempli d'éléments tels que des grottes, des falaises, etc., a récemment suscité un intérêt croissant.  Un tel monde est une application idéale pour le bruit généré dans le style de ma bibliothèque <b>ANL</b> .  Cet article est né de discussions sur mes précédentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tentatives de</a> mise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en</a> œuvre de cette technique.  Depuis lors, des changements mineurs sont apparus dans la structure de la bibliothèque. <br><br>  Dans les articles précédents, j'ai parlé de l'utilisation de fonctionnalités de bruit 3D pour implémenter un terrain de style Minecraft.  Après cela, la bibliothèque a évolué un peu, j'ai donc décidé de revenir sur ce sujet.  Comme j'ai dû répondre à de nombreuses questions sur ce système, je vais essayer de parler davantage des concepts impliqués.  Pour rendre les concepts de base plus clairs, je vais commencer par l'idée de générer un terrain 2D utilisé dans des jeux comme Terraria et King Arthur's Gold, puis étendre le système à des exemples 3D comme Minecraft.  Cela me permettra de démontrer plus efficacement les concepts en utilisant des images comme exemple. <br><br>  Ce système a été développé en tenant compte de l'objectif abstrait suivant: nous devrions être en mesure de transmettre les coordonnées d'un certain point ou d'une certaine cellule au système, et déterminer quel type de bloc devrait être à cet emplacement.  Nous voulons que le système soit une «boîte noire»: nous lui passons un point, retournons le type de bloc.  Bien sûr, cela ne s'applique qu'à la génération initiale du monde.  Les blocs de ces jeux peuvent être modifiés par les actions du joueur, et il sera peu pratique d'essayer de décrire ces changements en utilisant le même système.  Ces changements doivent être suivis d'une autre manière.  Ce système génère le monde d'origine, vierge et intact par les mains du joueur et d'autres personnages. <br><a name="habracut"></a><br>  Cette technique n'est peut-être pas adaptée à la modélisation de systèmes tels que l'herbe ou d'autres entités biologiques, étant donné que ces systèmes eux-mêmes sont des entités complexes qui ne sont pas si faciles à modéliser implicitement.  Il en va de même pour les systèmes tels que les chutes de neige, la formation de glace, etc. ... La technique décrite dans l'article est une <i>méthode implicite</i> , c'est-à-dire  celui qui peut être estimé en un point, et dont la valeur en un point donné ne dépend pas des valeurs environnantes.  Les types de systèmes biologiques et autres pour effectuer des simulations précises doivent généralement tenir compte des valeurs environnementales.  Par exemple: combien de soleil tombe sur un bloc?  Y a-t-il de l'eau à proximité?  Il faut répondre à ces questions et à d'autres pour simuler la croissance et la propagation des systèmes biologiques, ainsi que, dans une moindre mesure, d'autres types de systèmes liés au climat.  De plus, cette technique n'est pas adaptée à la modélisation de l'eau.  Dans ce système, il n'y a pas de concept d'écoulement, de connaissance de la mécanique des fluides ou de la gravité.  L'eau est un sujet complexe qui nécessite de nombreux calculs complexes. <br><br>  Donc, nous modélisons simplement la terre et les pierres.  Nous avons besoin d'une fonction qui vous indique quel doit être l'emplacement donné: terre, sable, air, or, fer, charbon, etc. ... Mais nous allons commencer par le plus simple.  Nous avons besoin d'une fonction qui dira si le bloc est solide ou creux (rempli d'air).  Cette fonction devrait simuler la terre qui nous entoure.  Autrement dit, le ciel est au-dessus, la terre est en dessous.  Alors, prenons la tâche biblique et séparons le ciel de la terre.  Pour ce faire, nous étudions la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gradient</a> .  La fonction Gradient reçoit un segment de ligne dans un espace à N dimensions (c'est-à-dire dans n'importe quel espace de coordonnées, qu'il soit 2D, 3D ou supérieur), et elle calcule le champ de gradient le long de ce segment.  Les coordonnées entrantes sont projetées sur ce segment et leur valeur de gradient est calculée en fonction de leur position par rapport aux points d'extrémité du segment.  Les points projetés reçoivent des valeurs dans l'intervalle (-1,1).  Et ce sera un bon début pour nous.  Nous pouvons définir la fonction Gradient le long de l'axe Y. En haut de l'intervalle, nous comparons le champ de gradient avec -1 (air), et en bas avec 1 (terre). <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1}
 } </pre><br>  (Je vais expliquer brièvement l'entrée. Le code des exemples est écrit dans le tableau de déclaration Lua. Pour plus d'informations sur le format, consultez la section sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégration Lua</a> . En substance, le format est conçu pour être analysé par une classe spéciale qui lit les annonces et les transforme en arborescences d'instance de module de bruit. Je préfère cela le format C ++ est plus détaillé étape par étape, car il est plus compact et plus propre. À mon avis, le code source est plus lisible et compressé que le code C ++. Pour la plupart, les déclarations sont faciles à lire et à comprendre. Les modules ont des noms, les sources sont spécifiées  nom ou valeur. Le code Lua utilisé pour analyser les déclarations de table est inclus dans le code source au cas où vous souhaiteriez utiliser ces déclarations directement.) <br><br>  Dans le cas de 2D, la fonction Dégradé reçoit un segment de ligne droite sous la forme (x1, x2, y1, y2), et dans le cas de 3D, le format est étendu à (x1, x2, y1, y2, z1, z2).  Le point formé par (x1, y1) indique le début du segment de ligne associé à 0. Le point formé (x2, y2) est la fin du segment associé à 1. Autrement dit, nous cartographions le segment de ligne (0,1) -&gt; ( 0,0) avec un gradient.  Par conséquent, le gradient sera compris entre les régions de la fonction Y = 1 et Y = 0.  C'est-à-dire que cette bande forme les dimensions du monde en Y. N'importe quelle partie du monde sera dans cette bande.  Nous pouvons accrocher n'importe quelle région le long de X (presque à l'infini, mais ici la <code>double</code> précision nous limite), mais tout est intéressant, c'est-à-dire  la surface de la terre sera dans cette bande.  Ce comportement peut être changé, mais en son sein, nous avons une grande flexibilité.  N'oubliez pas que toutes les valeurs supérieures ou inférieures à cette bande sont les plus susceptibles d'être inintéressantes, car les valeurs ci-dessus sont le plus souvent l'air et les valeurs ci-dessous sont au sol.  (Comme vous le verrez bientôt, cette déclaration pourrait bien s'avérer erronée.) Pour la plupart des images de cette série, je correspondrai à la région carrée donnée par le carré (0,1) -&gt; (1,0) dans l'espace 2D.  Par conséquent, au début, notre monde ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f6/09d/543/5f609d54326fa4c746b5b391b1f75c6a.jpg"></div><br>  Rien d'intéressant jusqu'à présent;  De plus, cette image ne répond pas à la question «le point donné est-il solide ou creux?».  Pour répondre à cette question, nous devons appliquer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction Step</a> (fonction définie par morceaux).  Au lieu d'un dégradé lisse, nous avons besoin d'une séparation claire, dans laquelle tous les emplacements d'un côté sont creux et tous les emplacements de l'autre côté sont solides.  Dans <b>ANL,</b> cela peut être implémenté à l'aide de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select</a> .  La fonction Select reçoit deux fonctions ou valeurs entrantes (dans ce cas, elles seront égales à «solide» et «Hollow» (ouvert)), et les sélectionne en fonction de la valeur de la fonction de contrôle (dans ce cas, Gradient).  Le module Select a deux paramètres supplémentaires, <b>seuil</b> et <b>atténuation</b> , qui affectent ce processus.  À ce stade, l' <b>atténuation n'est</b> pas souhaitable, nous allons donc la rendre égale à 0. Le paramètre de <b>seuil</b> décide où ira la ligne de démarcation entre Solid et Open.  Tout ce qui sera supérieur à cette valeur dans la fonction Dégradé deviendra Solide et tout ce qui est inférieur au seuil deviendra Ouvert.  Étant donné que Gradient compare l'intervalle avec des valeurs de 0 et 1, il serait logique de placer le seuil à 0,5.  Nous divisons donc l'espace exactement en deux.  La valeur 1 sera un emplacement solide et la valeur 0 sera creuse.  Autrement dit, nous définissons la fonction du plan terrestre comme suit: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_select", type = "select", low = 0, high = 1, threshold = 0.5, control = "ground_gradient"}
 }
</pre><br>  En comparant la même zone de la fonction que précédemment, nous obtenons quelque chose de similaire: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/d9c/4b5/35ad9c4b583840222252f7c136ba983a.jpg"></div><br>  Cette image répond clairement à la question de savoir si le point donné est solide ou creux.  Nous pouvons appeler la fonction avec n'importe quelle coordonnée possible de l'espace 2D, et son résultat sera soit 1 ou 0, selon l'endroit où le point est relatif à la surface de la terre.  Cependant, une telle fonction n'est pas particulièrement intéressante, c'est juste une ligne plate s'étendant à l'infini.  Pour raviver l'image, nous utilisons une technique appelée «turbulence». <br><br>  La «turbulence» est une désignation complexe du concept d'ajout de valeurs aux coordonnées entrantes d'une fonction.  Imaginez que nous appelons la fonction ci-dessus de la Terre avec la coordonnée (0,1).  Il se situe au-dessus du plan du sol, car à Y = 1, le gradient a une valeur de 0, ce qui est inférieur au seuil = 0,5.  Autrement dit, ce point sera calculé comme ouvert.  Mais que se passe-t-il si, avant d'invoquer la fonction de la terre, nous transformons en quelque sorte ce point?  Supposons que nous soustrayions une valeur aléatoire de la coordonnée Y, par exemple 3. Nous soustrayons 3 et obtenons la coordonnée (0, -2).  Si nous appelons maintenant la fonction sol pour ce point, alors le point sera considéré comme solide, car Y = -2 se situe en dessous du segment Gradient correspondant à 1. Soudain, le point creux (0,1) se transforme en solide.  Nous obtiendrons un bloc de pierre solide suspendu dans l'air.  Cela peut être fait avec n'importe quel point de la fonction en ajoutant ou en soustrayant un nombre aléatoire de la coordonnée Y du point entrant avant d'appeler la fonction ground_select.  Voici une image de la fonction ground_select montrant cela.  Avant d'appeler la fonction ground_select, la valeur de l'intervalle (-0,25, 0,25) est ajoutée à la coordonnée Y de chaque point. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f28/273/32e/f2827332ed068acf376b4b6cfbf0853d.jpg"></div><br>  C'est plus intéressant qu'une ligne plate, mais pas très similaire à la terre, car chaque point se déplace vers une valeur complètement aléatoire, ce qui crée un motif chaotique.  Cependant, si nous utilisons une fonction aléatoire continue, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fractal</a> de la bibliothèque <b>ANL</b> , alors au lieu d'un modèle aléatoire, nous obtenons quelque chose de plus contrôlable.  Par conséquent, connectons une fractale au plan de la terre et voyons ce qui se passe. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fréquence = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_perturb", type = "translomain", source = "ground_gradient", ty = "ground_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "ground_perturb"}
 }
</pre><br>  Ici, il convient de noter quelques aspects.  Tout d'abord, nous définissons le module Fractal et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaînons au</a> module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ScaleOffset</a> .  Le module ScaleOffset met à l'échelle les valeurs fractales de sortie à un niveau plus pratique.  Une partie du relief peut être montagneuse et nécessiter une plus grande échelle, et une autre partie - plus plate et à plus petite échelle.  Nous parlerons plus tard de différents types de terrain, mais pour l'instant nous les utiliserons pour la démonstration.  Les valeurs de sortie de la fonction donneront maintenant l'image suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/56e/b55/8ca56eb55e7febec86f3dd80fcea2d0e.jpg"></div><br>  C'est plus intéressant qu'un simple bruit aléatoire, non?  Au moins, cela ressemble plus à de la terre, bien qu'une partie du paysage semble inhabituelle, et les îles volantes sont complètement étranges.  La raison en était que chaque point individuel de la carte de sortie est décalé de manière aléatoire d'une valeur différente déterminée par la fractale.  Pour illustrer cela, montrez la sortie fractale qui effectue la distorsion: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/67d/b62/fbd67db6235a14fdf6d734d2ac73f560.jpg"></div><br>  Dans l'image ci-dessus, tous les points noirs ont une valeur de -0,25 et tous les points blancs ont une valeur de 0,25.  Autrement dit, lorsque la fractale est noire, le point correspondant de la fonction de la Terre sera décalé "vers le bas" de 0,25.  (0,25 signifie 1/4 de l'écran.) Puisqu'un point peut être légèrement déplacé et que l'autre point au-dessus de lui dans l'espace peut être déplacé davantage, il existe une possibilité de protubérances de roches et d'îles volantes.  Les saillies dans la nature sont assez naturelles, contrairement aux îles volantes.  (À moins que nous ne soyons dans le film "Avatar".) Si votre jeu a besoin d'un paysage aussi fantastique, c'est génial, mais si vous avez besoin d'un modèle plus réaliste, nous devons ajuster un peu la fonction fractale.  Heureusement, la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ScaleDomain</a> peut le faire. <br><br>  Nous voulons que la fonction se comporte comme une fonction de carte de hauteur.  Imaginez une carte de hauteur 2D où chaque point de la carte représente la hauteur d'un point dans la grille de points de grille qui sont relevés vers le haut ou vers le bas.  Les valeurs blanches de la carte indiquent de hautes collines, des vallées noires à basses.  Nous avons besoin d'un comportement similaire, mais pour y parvenir, nous devons essentiellement nous débarrasser de l'une des dimensions.  Dans le cas d'une carte de hauteur, nous créons une élévation 3D à partir d'une carte de hauteur 2D.  De même, dans le cas d'un terrain 2D, nous avons besoin d'une carte de hauteur 1D.  Après avoir fait en sorte que tous les points d'une fractale avec la même coordonnée Y aient la même valeur, nous pouvons déplacer tous les points avec la même coordonnée X de la même quantité, de sorte que les îles volantes disparaissent.  Pour ce faire, vous pouvez utiliser ScaleDomain, en réinitialisant le coefficient scaley.  Autrement dit, avant d'appeler la fonction ground_shape_fractal, nous appelons ground_scale_y pour définir la coordonnée y sur 0. Cela garantit que la valeur Y n'affecte pas la sortie de la fractale, la transformant essentiellement en une fonction de bruit 1D.  Pour ce faire, nous apporterons les modifications suivantes: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fréquence = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translomain", source = "ground_gradient", ty = "ground_scale_y"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "ground_perturb"}
 }
</pre><br>  Nous enchaînerons la fonction ScaleDomain avec ground_scale, puis modifierons les données ground_perturb d'origine pour qu'elles soient une fonction ScaleDomain.  Cela changera la fractale qui déplace la terre et la transforme en quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca7/e79/4dc/ca7e794dc19c6922c6278cfdf3437caf.jpg"></div><br>  Maintenant, si nous regardons la sortie, nous obtenons le résultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/31a/5d6/bb231a5d6c2e0cfb1f8181ba6de1dc61.jpg"></div><br>  Bien mieux.  Les îles volantes ont complètement disparu et le relief ressemble plus à des montagnes et des collines.  Malheureusement, nous avons perdu des saillies et des falaises.  Maintenant, la terre entière est continue et en pente.  Si vous le souhaitez, vous pouvez résoudre ce problème de plusieurs manières. <br><br>  Tout d'abord, vous pouvez utiliser une autre fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TranslateDomain</a> , couplée à une autre fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fractal</a> .  Si nous appliquons une petite quantité de turbulence fractale à la direction X, nous pouvons légèrement déformer les bords et les surfaces des montagnes, et cela sera probablement suffisant pour former des précipices et des rebords.  Regardons-le en action. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fréquence = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translomain", source = "ground_gradient", ty = "ground_scale_y"},
	 {name = "ground_overhang_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fréquence = 2},
	 {name = "ground_overhang_scale", type = "scaleoffset", source = "ground_overhang_fractal", scale = 0,2, offset = 0},
	 {name = "ground_overhang_perturb", type = "translomain", source = "ground_perturb", tx = "ground_overhang_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "ground_overhang_perturb"}
 }
</pre><br>  Et voici le résultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c3/09f/c4e/4c309fc4e22125fa2083d5bf33e4dc20.jpg"></div><br>  La deuxième façon: vous pouvez simplement définir le paramètre <b>scaley</b> de la fonction <b>ground_scale_y</b> <b>à une</b> valeur supérieure à 0. Si vous laissez une petite échelle en Y, nous obtiendrons une fraction de la variabilité, cependant, plus l'échelle est grande, plus le relief ressemblera à la version précédente sans mise à l'échelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/f3f/746/225f3f7462f1c78bb48a3603363643aa.jpg"></div><br>  Les résultats semblent beaucoup plus intéressants que les montagnes en pente ordinaires.  Cependant, peu importe leur intérêt, le joueur s'ennuiera toujours à explorer le relief avec le même motif, s'étendant sur plusieurs kilomètres.  De plus, un tel soulagement serait très irréaliste.  Dans le monde réel, il y a beaucoup de variabilité qui rend le terrain plus intéressant.  Voyons ce qui peut être fait pour rendre le monde plus diversifié. <br><br>  En regardant l'exemple de code précédent, vous pouvez y voir un modèle spécifique.  Nous avons une fonction de gradient, qui est contrôlée par des fonctions qui donnent à la terre une forme, après quoi une fonction définie par morceaux est appliquée et la terre devient pleine.  Autrement dit, il sera plus logique de compliquer le relief au stade de la mise en forme de la terre.  Au lieu d'un fractal se déplaçant le long de Y et d'un autre se déplaçant le long de X, nous pouvons atteindre le degré de complexité requis (en tenant compte des performances: chaque fractale nécessite des coûts de calcul supplémentaires, nous devons donc essayer d'être conservateurs.) Nous pouvons spécifier les formes de la terre, qui sont des montagnes, des contreforts. , plaines plates, friches, etc ... et utilisez la sortie des différentes fonctions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select</a> enchaînées avec des fractales basse fréquence pour délimiter les zones de chaque type.  Voyons donc comment mettre en œuvre différents types de terrain. <br><br>  Pour illustrer le principe, nous distinguons trois types de relief: les plateaux (collines à pente douce), les montagnes et les plaines (principalement plates).  Pour basculer entre eux, nous utilisons un système basé sur la sélection et les combinons dans un canevas complexe.  Alors c'est parti ... <br><br>  <b>Contreforts:</b> <br><br>  Avec eux, tout est simple.  Nous pouvons prendre le schéma utilisé ci-dessus, réduire légèrement l'amplitude des collines, peut-être même les rendre plus soustractives qu'additives.  pour abaisser les hauteurs moyennes.  Nous pouvons également réduire le nombre d'octaves pour les lisser. <br><br><pre> {name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fréquence = 1},
 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0.2, offset = -0.25},
 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
 {name = "lowland_terrain", type = "translomain", source = "ground_gradient", ty = "lowland_y_scale"},
</pre><br>  <b>Highlands:</b> <br><br>  Avec eux aussi, tout est simple.  (En fait, aucun de ces types de terrain n'est difficile.) Cependant, nous utilisons une base différente pour faire ressembler les collines aux dunes. <br><br><pre> {name = "highland_shape_fractal", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fréquence = 2},
 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0.45, offset = 0},
 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
 {name = "highland_terrain", type = "translomain", source = "ground_gradient", ty = "highland_y_scale"},
</pre><br>  <b>Montagnes:</b> <br><br><pre> {name = "mountain_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 4, fréquence = 1},
 {name = "mountain_autocorrect", type = "autocorrect", source = "mountain_shape_fractal", low = 0, high = 1},
 {name = "mountain_scale", type = "scaleoffset", source = "mountain_autocorrect", scale = 0,75, offset = 0,25},
 {name = "mountain_y_scale", type = "scaledomain", source = "mountain_scale", scaley = 0,1},
 {name = "mountain_terrain", type = "translomain", source = "ground_gradient", ty = "mountain_y_scale"},
</pre><br>  Bien sûr, vous pouvez aborder ce processus de manière encore plus créative, mais en général, le modèle sera le même.  Nous mettons en évidence les caractéristiques du type de relief et sélectionnons pour elles des fonctions de bruit.  Pour tout cela, les mêmes principes s'appliquent;  Les principales différences sont l'échelle.  Maintenant, pour les connecter ensemble, nous allons préparer des fractales supplémentaires qui contrôleront la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select</a> .  Ensuite, nous enchaînons les modules Select pour générer tout le terrain. <br><br><pre> {name = "terrain_type_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 3, fréquence = 0,5},
 {name = "terrain_autocorrect", type = "autocorrect", source = "terrain_type_fractal", faible = 0, élevé = 1},
 {name = "terrain_type_cache", type = "cache", source = "terrain_autocorrect"},
 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrain_type_cache", seuil = 0,55, falloff = 0,15},
 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrain_type_cache", seuil = 0,25, falloff = 0,15},
</pre><br>  Nous définissons donc ici trois types principaux de terrain: les plaines, les hautes terres et les montagnes.  Nous utilisons une fractale pour en sélectionner une, afin qu'il y ait des transitions naturelles (plaines-&gt; hautes terres-&gt; montagnes).  Ensuite, nous utilisons une autre fractale pour insérer au hasard des badlands dans la carte.  Voici à quoi ressemble la chaîne de modules terminée: <br><br><pre> terraintree =
 {
	 {name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fréquence = 1},
	 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
	 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0.2, offset = -0.25},
	 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
	 {name = "lowland_terrain", type = "translomain", source = "ground_gradient", ty = "lowland_y_scale"},
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "highland_shape_fractal", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fréquence = 2},
	 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
	 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0.45, offset = 0},
	 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
	 {name = "highland_terrain", type = "translomain", source = "ground_gradient", ty = "highland_y_scale"},<font></font>
<font></font>
	 {name = "mountain_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 4, fréquence = 1},
	 {name = "mountain_autocorrect", type = "autocorrect", source = "mountain_shape_fractal", low = 0, high = 1},
	 {name = "mountain_scale", type = "scaleoffset", source = "mountain_autocorrect", scale = 0,75, offset = 0,25},
	 {name = "mountain_y_scale", type = "scaledomain", source = "mountain_scale", scaley = 0,1},
	 {name = "mountain_terrain", type = "translomain", source = "ground_gradient", ty = "mountain_y_scale"},<font></font>
<font></font>
	 {name = "terrain_type_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 3, fréquence = 0,5},
	 {name = "terrain_autocorrect", type = "autocorrect", source = "terrain_type_fractal", faible = 0, élevé = 1},
	 {name = "terrain_type_cache", type = "cache", source = "terrain_autocorrect"},
	 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrain_type_cache", seuil = 0,55, falloff = 0,15},
	 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrain_type_cache", seuil = 0,25, falloff = 0,15},
	 {name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "highland_lowland_select"}
 }
</pre><br>  Voici quelques exemples des reliefs résultants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/60f/afe/4c460fafe39eec4680ac6eb3c341beef.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/241/869/9c8241869337938b628d0b9a53a3e756.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/538/67a/f3a/53867af3a00abb26d5b0f32f5f728694.jpg"></div><br>  Vous remarquerez peut-être qu'une variabilité assez élevée est obtenue.  Dans certains endroits, des montagnes brisées imposantes apparaissent, dans d'autres il y a des plaines en pente douce.  Maintenant, nous devons ajouter des grottes pour pouvoir explorer les merveilles des enfers. <br><br>  Pour les grottes, j'utilise le système multiplicatif appliqué à <b>ground_select</b> .  Autrement dit, je crée une fonction qui génère 1 ou 0 et je les multiplie par la sortie de <b>ground_select</b> .  Grâce à cela, tout point de la fonction devient creux pour lequel la valeur de la fonction des grottes est 0. Autrement dit, là où je veux obtenir la grotte, la fonction des grottes devrait retourner 0, et où la grotte ne devrait pas être, la fonction devrait être 1. Quant à la forme grottes, je veux établir un système de grottes basé sur le 1 octave <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ridged Multifractal</a> . <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, fréquence = 2},
</pre><br>  Le résultat est quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/bf0/297/31cbf02975f1852907bb3a0f24ffd43a.jpg"></div><br>  Si nous appliquons la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select en</a> tant que fonction définie par morceaux, comme nous l'avons fait avec le gradient terrestre, en l'implémentant de sorte que la partie inférieure du seuil de sélection soit 1 (il n'y a pas de grotte) et la partie supérieure est 0 (il y a une grotte), le résultat ressemblera à ceci : <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, fréquence = 2},
 {name = "cave_select", type = "select", low = 1, high = 0, control = "cave_shape", threshold = 0.8, falloff = 0},
</pre><br>  Résultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/55a/c47/1d855ac477dd48ba59d20ed30d89bde6.jpg"></div><br>  Bien sûr, il semble assez lisse, alors ajoutez du bruit fractal pour déformer la zone. <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, fréquence = 2},
 {name = "cave_select", type = "select", low = 1, high = 0, control = "cave_shape", threshold = 0.8, falloff = 0},
 {name = "cave_perturb_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fréquence = 3},
 {name = "cave_perturb_scale", type = "scaleoffset", source = "cave_perturb_fractal", scale = 0,25, offset = 0},<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "cave_perturb", type = "translomain", source = "cave_select", tx = "cave_perturb_scale"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Résultat: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ec/deb/4fa/0ecdeb4faf32eea11c05a7a76b7c6225.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela rend les grottes un peu bruyantes et les rend moins douces. </font><font style="vertical-align: inherit;">Voyons maintenant ce qui se passe si vous appliquez les grottes au relief:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d34/974/278/d34974278435e239ad7eb9193adc9672.jpg"></div><br><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">En</font></b><font style="vertical-align: inherit;"> expérimentant la valeur de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seuil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous pouvons rendre les grottes plus minces ou plus épaisses. Mais l'essentiel que nous devons essayer est de nous assurer que les grottes ne rongent pas ces énormes fragments du relief de surface. Pour ce faire, nous pouvons revenir à la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui, rappelons-le, est la dernière fonction de relief qui déforme le gradient de la terre. Ce qui est utile dans cette fonction, c'est qu'il s'agit toujours d'un gradient, augmentant la valeur lorsque la fonction s'approfondit dans le sol. Nous pouvons utiliser le gradient pour affaiblir la fonction des grottes afin que les grottes augmentent à mesure qu'elles s'enfoncent dans le sol. Heureusement pour nous, cette atténuation peut être obtenue simplement en multipliant la sortie de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la sortie de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis passez le résultat au reste de la chaîne de fonctions. Ensuite, nous apporterons un changement important ici - nous ajouterons la fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La fonction de mise en cache enregistre le résultat de la fonction pour une coordonnée entrante donnée, et si la fonction est appelée à plusieurs reprises avec la même coordonnée, elle renverra une copie en cache et ne calculera plus le résultat. Ceci est utile dans les situations où une fonction complexe ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dans une chaîne de fonctions est appelée plusieurs fois. Sans cache, toute la chaîne d'une fonction complexe est recalculée à chaque appel. Pour ajouter le cache, nous devons d'abord apporter les modifications suivantes:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrain_type_cache", seuil = 0,25, falloff = 0,15},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "highland_lowland_select_cache", type = "cache", source = "highland_lowland_select"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "highland_lowland_select_cache"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc ajouté Cache, puis redirigé l'entrée vers </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ground_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin qu'elle soit prise dans le cache, et non directement dans la fonction. </font><font style="vertical-align: inherit;">Ensuite, nous pouvons changer le code des grottes pour ajouter une atténuation:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, fréquence = 4},</font></font><font></font>
{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous avons ajouté la fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bias</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . C'est pour plus de commodité, car cela nous permet d'ajuster l'intervalle de la fonction d'atténuation du gradient. Ensuite, la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape_attenuate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><b><font style="vertical-align: inherit;">ajoutée</font></b><font style="vertical-align: inherit;"> , qui est un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">combinateur de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anl :: MULT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Elle multiplie le gradient par </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le résultat de cette opération est ensuite transmis à la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_perturb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le résultat ressemble à ceci:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f8/55d/fd3/8f855dfd376c5d8049a075d28066f72c.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous voyons que plus près de la surface de la terre est devenue plus mince. </font><font style="vertical-align: inherit;">(Ne faites pas attention au sommet, ce n'est qu'un artefact de valeurs de gradient négatives, cela n'affecte pas les grottes finies. Si cela devient un problème - disons que si nous utilisons cette fonction pour autre chose, nous pouvons limiter le gradient à l'intervalle (0, 1).) Il est un peu difficile de voir comment cela fonctionne par rapport au terrain, alors continuons et mettons tout en place pour voir ce qui se passe. </font><font style="vertical-align: inherit;">Voici toute la chaîne de fonctions que nous avons créées jusqu'à présent.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terraintree =
</font></font> {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fréquence = 0,25},</font></font><font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_shape", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
	{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
	{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
	{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
	{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "cave_select", source_1 = "ground_select"}</font></font><font></font>
 }
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici des exemples de cartes randomisées dérivées de cette fonction: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/1a5/ca8/9f81a5ca8f1b739c03721b6a5ba280a5.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/5ec/b69/c865ecb69a1701a1b757535f289c6c0a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a82/332/1e3/a823321e389de00947e695424497f2e9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, tout semble plutôt bien. Toutes les grottes sont des cavernes assez grandes et profondément souterraines, mais plus près de la surface, elles se transforment généralement en petits tunnels. Cela contribue à créer une atmosphère de mystère. En explorant la surface, vous trouvez une petite entrée dans la grotte. Où va-t-elle? Quelle est sa profondeur? Nous ne pouvons pas le savoir, mais au cours de son étude, il commence à s'étendre, se transformant en un vaste système de cavernes remplies d'obscurité et de dangers. Et le butin, bien sûr. Il y a toujours beaucoup de butin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez modifier ce système de différentes manières et obtenir des résultats différents. Nous pouvons changer les paramètres de seuil pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les paramètres de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_attenuate_bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou remplacer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_attenuate_bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'autres fonctions pour faire correspondre l'intervalle de gradient à d'autres valeurs mieux adaptées à vos besoins. Vous pouvez également ajouter une autre fractale qui déforme le système de grottes le long de l'axe Y pour éliminer la possibilité de tunnels anormalement lisses le long de l'axe X (causés par le fait que la forme de la grotte n'est déformée que le long de l'axe X). Vous pouvez également ajouter une nouvelle fractale comme source d'atténuation supplémentaire, définir une troisième source pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape_attenuate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui met à l'échelle l'atténuation en fonction des régions, afin que les grottes dans certaines zones soient plus denses (par exemple, dans les montagnes), et moins souvent ou complètement absentes dans d'autres. Cette sélection régionale peut être créée à partir de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terrain_type_fractal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour savoir où se trouvent les zones de montagne. Tout se résume à penser à ce que vous voulez, à déterminer quel effet les différentes fonctions auront sur la sortie et à expérimenter les paramètres jusqu'à ce que vous obteniez le résultat souhaité. Ce n'est pas une science exacte, et souvent l'effet souhaité peut être atteint de différentes manières.</font></font><br><br><h2>  Inconvénients </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette méthode de génération de terrain présente des inconvénients. </font><font style="vertical-align: inherit;">Le processus de génération de bruit peut être assez lent. </font><font style="vertical-align: inherit;">Il est important de réduire le nombre de fractales, le nombre d'octaves de ces fractales que vous utilisez et d'autres opérations lentes, si possible. </font><font style="vertical-align: inherit;">Essayez d'utiliser les fractales plusieurs fois et mettez en cache toutes les fonctions appelées plusieurs fois. </font><font style="vertical-align: inherit;">Dans cet exemple, j'ai librement utilisé des fractales, en créant une pour chacun des trois types de relief. </font><font style="vertical-align: inherit;">En utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScaleOffset</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour changer les intervalles et en prenant une fractale comme base pour tous, je gagnerais beaucoup de temps processeur. </font><font style="vertical-align: inherit;">En 2D, tout n'est pas si mal, mais lorsque vous arrivez en 3D et essayez de comparer les quantités de données, le temps de traitement augmentera considérablement.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aller en 3D </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout cela est super si vous créez un jeu comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">King Arthur's Gold</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais que faire si vous avez besoin de quelque chose comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minecraft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infiniminer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Quels changements devons-nous apporter à la chaîne de fonctions? En fait, il n'y en a pas beaucoup. La fonction ci-dessus fonctionnera presque sans modification pour le relief 3D. Il vous suffira de comparer le volume 3D en utilisant les variations 3D du générateur, et aussi de comparer l'axe Y avec l'axe vertical du volume, et non la région 2D. Cependant, un changement sera néanmoins nécessaire, à savoir un moyen de réaliser les grottes. Comme vous l'avez vu, Ridged Multifractal est idéal pour un système de grottes 2D, mais en 3D, il coupe beaucoup de coquilles incurvées, pas de tunnels, et son effet se révèle être faux. Autrement dit, en 3D, il est nécessaire de spécifier deux formes fractales de grottes, les deux sont des bruits multifractaux à 1 octave, mais avec des germes différents. À l'aide de Select, définissez-les sur 1 ou 0 et multipliez-les. Ainsi, à l'intersection des fractales, une grotte apparaîtra,et tout le reste restera solide, et l'apparence des tunnels deviendra plus naturelle que l'utilisation d'une seule fractale.</font></font><br><br><pre>terraintree3d=
 {<font></font>
	{name="ground_gradient", type="gradient", x1=0, x2=0, y1=0, y2=1},<font></font>
	<font></font>
	{name="lowland_shape_fractal", type="fractal", fractaltype=anl.BILLOW, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=2, frequency=0.25},<font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape1", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape2", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape1", source_1="cave_attenuate_bias", source_2="cave_shape2"},             <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fréquence = 3},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb_scale", type = "scaleoffset", source = "cave_perturb_fractal", scale = 0.5, offset = 0},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb", type = "translomain", source = "cave_shape_attenuate", tx = "cave_perturb_scale"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_select", type = "select", bas = 1, haut = 0, control = "cave_perturb", seuil = 0,48, chute = 0},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "cave_select", source_1 = "ground_select"}</font></font><font></font>
 }
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exemples de résultats: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/484/3fa/8e9/4843fa8e95e46162345f36edcf767fbe.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b91/671/848/b91671848dac9a42f371d549adf07181.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que certains paramètres nécessitent un réglage. </font><font style="vertical-align: inherit;">Il peut être utile de réduire l'atténuation ou d'amincir les grottes, de réduire le nombre d'octaves dans la fractale du relief, de sorte que le relief devienne plus lisse, etc. ... Je répète, tout dépend du résultat que vous souhaitez obtenir.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472574/">https://habr.com/ru/post/fr472574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472562/index.html">Tendances financières: les grandes entreprises ont besoin de plus en plus de professionnels de l'informatique</a></li>
<li><a href="../fr472566/index.html">L'enfer personnel de l'écrivain Fraerman, ou le conte du premier amour</a></li>
<li><a href="../fr472568/index.html">Déploiement d'Apache Ignite Zero: exactement zéro?</a></li>
<li><a href="../fr472570/index.html">Intel Xeon W Big Update</a></li>
<li><a href="../fr472572/index.html">DevOps et Chaos: livraison de logiciels dans un monde décentralisé</a></li>
<li><a href="../fr472576/index.html">XVIe conférence des développeurs de logiciels libres ou où trouver des contributeurs gratuits</a></li>
<li><a href="../fr472580/index.html">Gestion des services d'entreprise: pourquoi étendre la gestion des services au-delà de l'informatique</a></li>
<li><a href="../fr472582/index.html">Histoire d'Internet: l'ordinateur comme appareil de communication</a></li>
<li><a href="../fr472586/index.html">Analyse du haut-parleur: ce qu'il y a à l'intérieur et comment cela fonctionne</a></li>
<li><a href="../fr472588/index.html">Tout ce que vous vouliez savoir sur le pendule inversé</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>