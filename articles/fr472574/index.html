<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèø üë©üèª‚Äçü§ù‚Äçüë®üèº üßî Cr√©ez votre Minecraft: g√©n√©rez des niveaux 3D √† partir de cubes ü§® üêØ üë®üèº‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En partie en raison de la popularit√© de Minecraft , l'id√©e d'un jeu qui se d√©roule dans un monde en cubes construit en relief 3D et rempli d'√©l√©ments ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ez votre Minecraft: g√©n√©rez des niveaux 3D √† partir de cubes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472574/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jj/va/ccjjvazyarduee258az9-bbggkq.png"></div><br>  En partie en raison de la popularit√© de <b>Minecraft</b> , l'id√©e d'un jeu qui se d√©roule dans un monde en cubes construit en relief 3D et rempli d'√©l√©ments tels que des grottes, des falaises, etc., a r√©cemment suscit√© un int√©r√™t croissant.  Un tel monde est une application id√©ale pour le bruit g√©n√©r√© dans le style de ma biblioth√®que <b>ANL</b> .  Cet article est n√© de discussions sur mes pr√©c√©dentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tentatives de</a> mise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en</a> ≈ìuvre de cette technique.  Depuis lors, des changements mineurs sont apparus dans la structure de la biblioth√®que. <br><br>  Dans les articles pr√©c√©dents, j'ai parl√© de l'utilisation de fonctionnalit√©s de bruit 3D pour impl√©menter un terrain de style Minecraft.  Apr√®s cela, la biblioth√®que a √©volu√© un peu, j'ai donc d√©cid√© de revenir sur ce sujet.  Comme j'ai d√ª r√©pondre √† de nombreuses questions sur ce syst√®me, je vais essayer de parler davantage des concepts impliqu√©s.  Pour rendre les concepts de base plus clairs, je vais commencer par l'id√©e de g√©n√©rer un terrain 2D utilis√© dans des jeux comme Terraria et King Arthur's Gold, puis √©tendre le syst√®me √† des exemples 3D comme Minecraft.  Cela me permettra de d√©montrer plus efficacement les concepts en utilisant des images comme exemple. <br><br>  Ce syst√®me a √©t√© d√©velopp√© en tenant compte de l'objectif abstrait suivant: nous devrions √™tre en mesure de transmettre les coordonn√©es d'un certain point ou d'une certaine cellule au syst√®me, et d√©terminer quel type de bloc devrait √™tre √† cet emplacement.  Nous voulons que le syst√®me soit une ¬´bo√Æte noire¬ª: nous lui passons un point, retournons le type de bloc.  Bien s√ªr, cela ne s'applique qu'√† la g√©n√©ration initiale du monde.  Les blocs de ces jeux peuvent √™tre modifi√©s par les actions du joueur, et il sera peu pratique d'essayer de d√©crire ces changements en utilisant le m√™me syst√®me.  Ces changements doivent √™tre suivis d'une autre mani√®re.  Ce syst√®me g√©n√®re le monde d'origine, vierge et intact par les mains du joueur et d'autres personnages. <br><a name="habracut"></a><br>  Cette technique n'est peut-√™tre pas adapt√©e √† la mod√©lisation de syst√®mes tels que l'herbe ou d'autres entit√©s biologiques, √©tant donn√© que ces syst√®mes eux-m√™mes sont des entit√©s complexes qui ne sont pas si faciles √† mod√©liser implicitement.  Il en va de m√™me pour les syst√®mes tels que les chutes de neige, la formation de glace, etc. ... La technique d√©crite dans l'article est une <i>m√©thode implicite</i> , c'est-√†-dire  celui qui peut √™tre estim√© en un point, et dont la valeur en un point donn√© ne d√©pend pas des valeurs environnantes.  Les types de syst√®mes biologiques et autres pour effectuer des simulations pr√©cises doivent g√©n√©ralement tenir compte des valeurs environnementales.  Par exemple: combien de soleil tombe sur un bloc?  Y a-t-il de l'eau √† proximit√©?  Il faut r√©pondre √† ces questions et √† d'autres pour simuler la croissance et la propagation des syst√®mes biologiques, ainsi que, dans une moindre mesure, d'autres types de syst√®mes li√©s au climat.  De plus, cette technique n'est pas adapt√©e √† la mod√©lisation de l'eau.  Dans ce syst√®me, il n'y a pas de concept d'√©coulement, de connaissance de la m√©canique des fluides ou de la gravit√©.  L'eau est un sujet complexe qui n√©cessite de nombreux calculs complexes. <br><br>  Donc, nous mod√©lisons simplement la terre et les pierres.  Nous avons besoin d'une fonction qui vous indique quel doit √™tre l'emplacement donn√©: terre, sable, air, or, fer, charbon, etc. ... Mais nous allons commencer par le plus simple.  Nous avons besoin d'une fonction qui dira si le bloc est solide ou creux (rempli d'air).  Cette fonction devrait simuler la terre qui nous entoure.  Autrement dit, le ciel est au-dessus, la terre est en dessous.  Alors, prenons la t√¢che biblique et s√©parons le ciel de la terre.  Pour ce faire, nous √©tudions la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gradient</a> .  La fonction Gradient re√ßoit un segment de ligne dans un espace √† N dimensions (c'est-√†-dire dans n'importe quel espace de coordonn√©es, qu'il soit 2D, 3D ou sup√©rieur), et elle calcule le champ de gradient le long de ce segment.  Les coordonn√©es entrantes sont projet√©es sur ce segment et leur valeur de gradient est calcul√©e en fonction de leur position par rapport aux points d'extr√©mit√© du segment.  Les points projet√©s re√ßoivent des valeurs dans l'intervalle (-1,1).  Et ce sera un bon d√©but pour nous.  Nous pouvons d√©finir la fonction Gradient le long de l'axe Y. En haut de l'intervalle, nous comparons le champ de gradient avec -1 (air), et en bas avec 1 (terre). <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1}
 } </pre><br>  (Je vais expliquer bri√®vement l'entr√©e. Le code des exemples est √©crit dans le tableau de d√©claration Lua. Pour plus d'informations sur le format, consultez la section sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">int√©gration Lua</a> . En substance, le format est con√ßu pour √™tre analys√© par une classe sp√©ciale qui lit les annonces et les transforme en arborescences d'instance de module de bruit. Je pr√©f√®re cela le format C ++ est plus d√©taill√© √©tape par √©tape, car il est plus compact et plus propre. √Ä mon avis, le code source est plus lisible et compress√© que le code C ++. Pour la plupart, les d√©clarations sont faciles √† lire et √† comprendre. Les modules ont des noms, les sources sont sp√©cifi√©es  nom ou valeur. Le code Lua utilis√© pour analyser les d√©clarations de table est inclus dans le code source au cas o√π vous souhaiteriez utiliser ces d√©clarations directement.) <br><br>  Dans le cas de 2D, la fonction D√©grad√© re√ßoit un segment de ligne droite sous la forme (x1, x2, y1, y2), et dans le cas de 3D, le format est √©tendu √† (x1, x2, y1, y2, z1, z2).  Le point form√© par (x1, y1) indique le d√©but du segment de ligne associ√© √† 0. Le point form√© (x2, y2) est la fin du segment associ√© √† 1. Autrement dit, nous cartographions le segment de ligne (0,1) -&gt; ( 0,0) avec un gradient.  Par cons√©quent, le gradient sera compris entre les r√©gions de la fonction Y = 1 et Y = 0.  C'est-√†-dire que cette bande forme les dimensions du monde en Y. N'importe quelle partie du monde sera dans cette bande.  Nous pouvons accrocher n'importe quelle r√©gion le long de X (presque √† l'infini, mais ici la <code>double</code> pr√©cision nous limite), mais tout est int√©ressant, c'est-√†-dire  la surface de la terre sera dans cette bande.  Ce comportement peut √™tre chang√©, mais en son sein, nous avons une grande flexibilit√©.  N'oubliez pas que toutes les valeurs sup√©rieures ou inf√©rieures √† cette bande sont les plus susceptibles d'√™tre inint√©ressantes, car les valeurs ci-dessus sont le plus souvent l'air et les valeurs ci-dessous sont au sol.  (Comme vous le verrez bient√¥t, cette d√©claration pourrait bien s'av√©rer erron√©e.) Pour la plupart des images de cette s√©rie, je correspondrai √† la r√©gion carr√©e donn√©e par le carr√© (0,1) -&gt; (1,0) dans l'espace 2D.  Par cons√©quent, au d√©but, notre monde ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f6/09d/543/5f609d54326fa4c746b5b391b1f75c6a.jpg"></div><br>  Rien d'int√©ressant jusqu'√† pr√©sent;  De plus, cette image ne r√©pond pas √† la question ¬´le point donn√© est-il solide ou creux?¬ª.  Pour r√©pondre √† cette question, nous devons appliquer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction Step</a> (fonction d√©finie par morceaux).  Au lieu d'un d√©grad√© lisse, nous avons besoin d'une s√©paration claire, dans laquelle tous les emplacements d'un c√¥t√© sont creux et tous les emplacements de l'autre c√¥t√© sont solides.  Dans <b>ANL,</b> cela peut √™tre impl√©ment√© √† l'aide de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select</a> .  La fonction Select re√ßoit deux fonctions ou valeurs entrantes (dans ce cas, elles seront √©gales √† ¬´solide¬ª et ¬´Hollow¬ª (ouvert)), et les s√©lectionne en fonction de la valeur de la fonction de contr√¥le (dans ce cas, Gradient).  Le module Select a deux param√®tres suppl√©mentaires, <b>seuil</b> et <b>att√©nuation</b> , qui affectent ce processus.  √Ä ce stade, l' <b>att√©nuation n'est</b> pas souhaitable, nous allons donc la rendre √©gale √† 0. Le param√®tre de <b>seuil</b> d√©cide o√π ira la ligne de d√©marcation entre Solid et Open.  Tout ce qui sera sup√©rieur √† cette valeur dans la fonction D√©grad√© deviendra Solide et tout ce qui est inf√©rieur au seuil deviendra Ouvert.  √âtant donn√© que Gradient compare l'intervalle avec des valeurs de 0 et 1, il serait logique de placer le seuil √† 0,5.  Nous divisons donc l'espace exactement en deux.  La valeur 1 sera un emplacement solide et la valeur 0 sera creuse.  Autrement dit, nous d√©finissons la fonction du plan terrestre comme suit: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_select", type = "select", low = 0, high = 1, threshold = 0.5, control = "ground_gradient"}
 }
</pre><br>  En comparant la m√™me zone de la fonction que pr√©c√©demment, nous obtenons quelque chose de similaire: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/d9c/4b5/35ad9c4b583840222252f7c136ba983a.jpg"></div><br>  Cette image r√©pond clairement √† la question de savoir si le point donn√© est solide ou creux.  Nous pouvons appeler la fonction avec n'importe quelle coordonn√©e possible de l'espace 2D, et son r√©sultat sera soit 1 ou 0, selon l'endroit o√π le point est relatif √† la surface de la terre.  Cependant, une telle fonction n'est pas particuli√®rement int√©ressante, c'est juste une ligne plate s'√©tendant √† l'infini.  Pour raviver l'image, nous utilisons une technique appel√©e ¬´turbulence¬ª. <br><br>  La ¬´turbulence¬ª est une d√©signation complexe du concept d'ajout de valeurs aux coordonn√©es entrantes d'une fonction.  Imaginez que nous appelons la fonction ci-dessus de la Terre avec la coordonn√©e (0,1).  Il se situe au-dessus du plan du sol, car √† Y = 1, le gradient a une valeur de 0, ce qui est inf√©rieur au seuil = 0,5.  Autrement dit, ce point sera calcul√© comme ouvert.  Mais que se passe-t-il si, avant d'invoquer la fonction de la terre, nous transformons en quelque sorte ce point?  Supposons que nous soustrayions une valeur al√©atoire de la coordonn√©e Y, par exemple 3. Nous soustrayons 3 et obtenons la coordonn√©e (0, -2).  Si nous appelons maintenant la fonction sol pour ce point, alors le point sera consid√©r√© comme solide, car Y = -2 se situe en dessous du segment Gradient correspondant √† 1. Soudain, le point creux (0,1) se transforme en solide.  Nous obtiendrons un bloc de pierre solide suspendu dans l'air.  Cela peut √™tre fait avec n'importe quel point de la fonction en ajoutant ou en soustrayant un nombre al√©atoire de la coordonn√©e Y du point entrant avant d'appeler la fonction ground_select.  Voici une image de la fonction ground_select montrant cela.  Avant d'appeler la fonction ground_select, la valeur de l'intervalle (-0,25, 0,25) est ajout√©e √† la coordonn√©e Y de chaque point. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f28/273/32e/f2827332ed068acf376b4b6cfbf0853d.jpg"></div><br>  C'est plus int√©ressant qu'une ligne plate, mais pas tr√®s similaire √† la terre, car chaque point se d√©place vers une valeur compl√®tement al√©atoire, ce qui cr√©e un motif chaotique.  Cependant, si nous utilisons une fonction al√©atoire continue, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fractal</a> de la biblioth√®que <b>ANL</b> , alors au lieu d'un mod√®le al√©atoire, nous obtenons quelque chose de plus contr√¥lable.  Par cons√©quent, connectons une fractale au plan de la terre et voyons ce qui se passe. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fr√©quence = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_perturb", type = "translomain", source = "ground_gradient", ty = "ground_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "ground_perturb"}
 }
</pre><br>  Ici, il convient de noter quelques aspects.  Tout d'abord, nous d√©finissons le module Fractal et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cha√Ænons au</a> module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ScaleOffset</a> .  Le module ScaleOffset met √† l'√©chelle les valeurs fractales de sortie √† un niveau plus pratique.  Une partie du relief peut √™tre montagneuse et n√©cessiter une plus grande √©chelle, et une autre partie - plus plate et √† plus petite √©chelle.  Nous parlerons plus tard de diff√©rents types de terrain, mais pour l'instant nous les utiliserons pour la d√©monstration.  Les valeurs de sortie de la fonction donneront maintenant l'image suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/56e/b55/8ca56eb55e7febec86f3dd80fcea2d0e.jpg"></div><br>  C'est plus int√©ressant qu'un simple bruit al√©atoire, non?  Au moins, cela ressemble plus √† de la terre, bien qu'une partie du paysage semble inhabituelle, et les √Æles volantes sont compl√®tement √©tranges.  La raison en √©tait que chaque point individuel de la carte de sortie est d√©cal√© de mani√®re al√©atoire d'une valeur diff√©rente d√©termin√©e par la fractale.  Pour illustrer cela, montrez la sortie fractale qui effectue la distorsion: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/67d/b62/fbd67db6235a14fdf6d734d2ac73f560.jpg"></div><br>  Dans l'image ci-dessus, tous les points noirs ont une valeur de -0,25 et tous les points blancs ont une valeur de 0,25.  Autrement dit, lorsque la fractale est noire, le point correspondant de la fonction de la Terre sera d√©cal√© "vers le bas" de 0,25.  (0,25 signifie 1/4 de l'√©cran.) Puisqu'un point peut √™tre l√©g√®rement d√©plac√© et que l'autre point au-dessus de lui dans l'espace peut √™tre d√©plac√© davantage, il existe une possibilit√© de protub√©rances de roches et d'√Æles volantes.  Les saillies dans la nature sont assez naturelles, contrairement aux √Æles volantes.  (√Ä moins que nous ne soyons dans le film "Avatar".) Si votre jeu a besoin d'un paysage aussi fantastique, c'est g√©nial, mais si vous avez besoin d'un mod√®le plus r√©aliste, nous devons ajuster un peu la fonction fractale.  Heureusement, la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ScaleDomain</a> peut le faire. <br><br>  Nous voulons que la fonction se comporte comme une fonction de carte de hauteur.  Imaginez une carte de hauteur 2D o√π chaque point de la carte repr√©sente la hauteur d'un point dans la grille de points de grille qui sont relev√©s vers le haut ou vers le bas.  Les valeurs blanches de la carte indiquent de hautes collines, des vall√©es noires √† basses.  Nous avons besoin d'un comportement similaire, mais pour y parvenir, nous devons essentiellement nous d√©barrasser de l'une des dimensions.  Dans le cas d'une carte de hauteur, nous cr√©ons une √©l√©vation 3D √† partir d'une carte de hauteur 2D.  De m√™me, dans le cas d'un terrain 2D, nous avons besoin d'une carte de hauteur 1D.  Apr√®s avoir fait en sorte que tous les points d'une fractale avec la m√™me coordonn√©e Y aient la m√™me valeur, nous pouvons d√©placer tous les points avec la m√™me coordonn√©e X de la m√™me quantit√©, de sorte que les √Æles volantes disparaissent.  Pour ce faire, vous pouvez utiliser ScaleDomain, en r√©initialisant le coefficient scaley.  Autrement dit, avant d'appeler la fonction ground_shape_fractal, nous appelons ground_scale_y pour d√©finir la coordonn√©e y sur 0. Cela garantit que la valeur Y n'affecte pas la sortie de la fractale, la transformant essentiellement en une fonction de bruit 1D.  Pour ce faire, nous apporterons les modifications suivantes: <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fr√©quence = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translomain", source = "ground_gradient", ty = "ground_scale_y"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "ground_perturb"}
 }
</pre><br>  Nous encha√Ænerons la fonction ScaleDomain avec ground_scale, puis modifierons les donn√©es ground_perturb d'origine pour qu'elles soient une fonction ScaleDomain.  Cela changera la fractale qui d√©place la terre et la transforme en quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca7/e79/4dc/ca7e794dc19c6922c6278cfdf3437caf.jpg"></div><br>  Maintenant, si nous regardons la sortie, nous obtenons le r√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/31a/5d6/bb231a5d6c2e0cfb1f8181ba6de1dc61.jpg"></div><br>  Bien mieux.  Les √Æles volantes ont compl√®tement disparu et le relief ressemble plus √† des montagnes et des collines.  Malheureusement, nous avons perdu des saillies et des falaises.  Maintenant, la terre enti√®re est continue et en pente.  Si vous le souhaitez, vous pouvez r√©soudre ce probl√®me de plusieurs mani√®res. <br><br>  Tout d'abord, vous pouvez utiliser une autre fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TranslateDomain</a> , coupl√©e √† une autre fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fractal</a> .  Si nous appliquons une petite quantit√© de turbulence fractale √† la direction X, nous pouvons l√©g√®rement d√©former les bords et les surfaces des montagnes, et cela sera probablement suffisant pour former des pr√©cipices et des rebords.  Regardons-le en action. <br><br><pre> terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fr√©quence = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translomain", source = "ground_gradient", ty = "ground_scale_y"},
	 {name = "ground_overhang_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fr√©quence = 2},
	 {name = "ground_overhang_scale", type = "scaleoffset", source = "ground_overhang_fractal", scale = 0,2, offset = 0},
	 {name = "ground_overhang_perturb", type = "translomain", source = "ground_perturb", tx = "ground_overhang_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "ground_overhang_perturb"}
 }
</pre><br>  Et voici le r√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c3/09f/c4e/4c309fc4e22125fa2083d5bf33e4dc20.jpg"></div><br>  La deuxi√®me fa√ßon: vous pouvez simplement d√©finir le param√®tre <b>scaley</b> de la fonction <b>ground_scale_y</b> <b>√† une</b> valeur sup√©rieure √† 0. Si vous laissez une petite √©chelle en Y, nous obtiendrons une fraction de la variabilit√©, cependant, plus l'√©chelle est grande, plus le relief ressemblera √† la version pr√©c√©dente sans mise √† l'√©chelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/f3f/746/225f3f7462f1c78bb48a3603363643aa.jpg"></div><br>  Les r√©sultats semblent beaucoup plus int√©ressants que les montagnes en pente ordinaires.  Cependant, peu importe leur int√©r√™t, le joueur s'ennuiera toujours √† explorer le relief avec le m√™me motif, s'√©tendant sur plusieurs kilom√®tres.  De plus, un tel soulagement serait tr√®s irr√©aliste.  Dans le monde r√©el, il y a beaucoup de variabilit√© qui rend le terrain plus int√©ressant.  Voyons ce qui peut √™tre fait pour rendre le monde plus diversifi√©. <br><br>  En regardant l'exemple de code pr√©c√©dent, vous pouvez y voir un mod√®le sp√©cifique.  Nous avons une fonction de gradient, qui est contr√¥l√©e par des fonctions qui donnent √† la terre une forme, apr√®s quoi une fonction d√©finie par morceaux est appliqu√©e et la terre devient pleine.  Autrement dit, il sera plus logique de compliquer le relief au stade de la mise en forme de la terre.  Au lieu d'un fractal se d√©pla√ßant le long de Y et d'un autre se d√©pla√ßant le long de X, nous pouvons atteindre le degr√© de complexit√© requis (en tenant compte des performances: chaque fractale n√©cessite des co√ªts de calcul suppl√©mentaires, nous devons donc essayer d'√™tre conservateurs.) Nous pouvons sp√©cifier les formes de la terre, qui sont des montagnes, des contreforts. , plaines plates, friches, etc ... et utilisez la sortie des diff√©rentes fonctions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select</a> encha√Æn√©es avec des fractales basse fr√©quence pour d√©limiter les zones de chaque type.  Voyons donc comment mettre en ≈ìuvre diff√©rents types de terrain. <br><br>  Pour illustrer le principe, nous distinguons trois types de relief: les plateaux (collines √† pente douce), les montagnes et les plaines (principalement plates).  Pour basculer entre eux, nous utilisons un syst√®me bas√© sur la s√©lection et les combinons dans un canevas complexe.  Alors c'est parti ... <br><br>  <b>Contreforts:</b> <br><br>  Avec eux, tout est simple.  Nous pouvons prendre le sch√©ma utilis√© ci-dessus, r√©duire l√©g√®rement l'amplitude des collines, peut-√™tre m√™me les rendre plus soustractives qu'additives.  pour abaisser les hauteurs moyennes.  Nous pouvons √©galement r√©duire le nombre d'octaves pour les lisser. <br><br><pre> {name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fr√©quence = 1},
 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0.2, offset = -0.25},
 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
 {name = "lowland_terrain", type = "translomain", source = "ground_gradient", ty = "lowland_y_scale"},
</pre><br>  <b>Highlands:</b> <br><br>  Avec eux aussi, tout est simple.  (En fait, aucun de ces types de terrain n'est difficile.) Cependant, nous utilisons une base diff√©rente pour faire ressembler les collines aux dunes. <br><br><pre> {name = "highland_shape_fractal", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fr√©quence = 2},
 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0.45, offset = 0},
 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
 {name = "highland_terrain", type = "translomain", source = "ground_gradient", ty = "highland_y_scale"},
</pre><br>  <b>Montagnes:</b> <br><br><pre> {name = "mountain_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 4, fr√©quence = 1},
 {name = "mountain_autocorrect", type = "autocorrect", source = "mountain_shape_fractal", low = 0, high = 1},
 {name = "mountain_scale", type = "scaleoffset", source = "mountain_autocorrect", scale = 0,75, offset = 0,25},
 {name = "mountain_y_scale", type = "scaledomain", source = "mountain_scale", scaley = 0,1},
 {name = "mountain_terrain", type = "translomain", source = "ground_gradient", ty = "mountain_y_scale"},
</pre><br>  Bien s√ªr, vous pouvez aborder ce processus de mani√®re encore plus cr√©ative, mais en g√©n√©ral, le mod√®le sera le m√™me.  Nous mettons en √©vidence les caract√©ristiques du type de relief et s√©lectionnons pour elles des fonctions de bruit.  Pour tout cela, les m√™mes principes s'appliquent;  Les principales diff√©rences sont l'√©chelle.  Maintenant, pour les connecter ensemble, nous allons pr√©parer des fractales suppl√©mentaires qui contr√¥leront la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select</a> .  Ensuite, nous encha√Ænons les modules Select pour g√©n√©rer tout le terrain. <br><br><pre> {name = "terrain_type_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 3, fr√©quence = 0,5},
 {name = "terrain_autocorrect", type = "autocorrect", source = "terrain_type_fractal", faible = 0, √©lev√© = 1},
 {name = "terrain_type_cache", type = "cache", source = "terrain_autocorrect"},
 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrain_type_cache", seuil = 0,55, falloff = 0,15},
 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrain_type_cache", seuil = 0,25, falloff = 0,15},
</pre><br>  Nous d√©finissons donc ici trois types principaux de terrain: les plaines, les hautes terres et les montagnes.  Nous utilisons une fractale pour en s√©lectionner une, afin qu'il y ait des transitions naturelles (plaines-&gt; hautes terres-&gt; montagnes).  Ensuite, nous utilisons une autre fractale pour ins√©rer au hasard des badlands dans la carte.  Voici √† quoi ressemble la cha√Æne de modules termin√©e: <br><br><pre> terraintree =
 {
	 {name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fr√©quence = 1},
	 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
	 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0.2, offset = -0.25},
	 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
	 {name = "lowland_terrain", type = "translomain", source = "ground_gradient", ty = "lowland_y_scale"},
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "highland_shape_fractal", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fr√©quence = 2},
	 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
	 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0.45, offset = 0},
	 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
	 {name = "highland_terrain", type = "translomain", source = "ground_gradient", ty = "highland_y_scale"},<font></font>
<font></font>
	 {name = "mountain_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 4, fr√©quence = 1},
	 {name = "mountain_autocorrect", type = "autocorrect", source = "mountain_shape_fractal", low = 0, high = 1},
	 {name = "mountain_scale", type = "scaleoffset", source = "mountain_autocorrect", scale = 0,75, offset = 0,25},
	 {name = "mountain_y_scale", type = "scaledomain", source = "mountain_scale", scaley = 0,1},
	 {name = "mountain_terrain", type = "translomain", source = "ground_gradient", ty = "mountain_y_scale"},<font></font>
<font></font>
	 {name = "terrain_type_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 3, fr√©quence = 0,5},
	 {name = "terrain_autocorrect", type = "autocorrect", source = "terrain_type_fractal", faible = 0, √©lev√© = 1},
	 {name = "terrain_type_cache", type = "cache", source = "terrain_autocorrect"},
	 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "mountain_terrain", control = "terrain_type_cache", seuil = 0,55, falloff = 0,15},
	 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrain_type_cache", seuil = 0,25, falloff = 0,15},
	 {name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "highland_lowland_select"}
 }
</pre><br>  Voici quelques exemples des reliefs r√©sultants: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/60f/afe/4c460fafe39eec4680ac6eb3c341beef.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/241/869/9c8241869337938b628d0b9a53a3e756.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/538/67a/f3a/53867af3a00abb26d5b0f32f5f728694.jpg"></div><br>  Vous remarquerez peut-√™tre qu'une variabilit√© assez √©lev√©e est obtenue.  Dans certains endroits, des montagnes bris√©es imposantes apparaissent, dans d'autres il y a des plaines en pente douce.  Maintenant, nous devons ajouter des grottes pour pouvoir explorer les merveilles des enfers. <br><br>  Pour les grottes, j'utilise le syst√®me multiplicatif appliqu√© √† <b>ground_select</b> .  Autrement dit, je cr√©e une fonction qui g√©n√®re 1 ou 0 et je les multiplie par la sortie de <b>ground_select</b> .  Gr√¢ce √† cela, tout point de la fonction devient creux pour lequel la valeur de la fonction des grottes est 0. Autrement dit, l√† o√π je veux obtenir la grotte, la fonction des grottes devrait retourner 0, et o√π la grotte ne devrait pas √™tre, la fonction devrait √™tre 1. Quant √† la forme grottes, je veux √©tablir un syst√®me de grottes bas√© sur le 1 octave <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ridged Multifractal</a> . <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, fr√©quence = 2},
</pre><br>  Le r√©sultat est quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/bf0/297/31cbf02975f1852907bb3a0f24ffd43a.jpg"></div><br>  Si nous appliquons la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select en</a> tant que fonction d√©finie par morceaux, comme nous l'avons fait avec le gradient terrestre, en l'impl√©mentant de sorte que la partie inf√©rieure du seuil de s√©lection soit 1 (il n'y a pas de grotte) et la partie sup√©rieure est 0 (il y a une grotte), le r√©sultat ressemblera √† ceci : <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, fr√©quence = 2},
 {name = "cave_select", type = "select", low = 1, high = 0, control = "cave_shape", threshold = 0.8, falloff = 0},
</pre><br>  R√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/55a/c47/1d855ac477dd48ba59d20ed30d89bde6.jpg"></div><br>  Bien s√ªr, il semble assez lisse, alors ajoutez du bruit fractal pour d√©former la zone. <br><br><pre> {name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, fr√©quence = 2},
 {name = "cave_select", type = "select", low = 1, high = 0, control = "cave_shape", threshold = 0.8, falloff = 0},
 {name = "cave_perturb_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fr√©quence = 3},
 {name = "cave_perturb_scale", type = "scaleoffset", source = "cave_perturb_fractal", scale = 0,25, offset = 0},<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "cave_perturb", type = "translomain", source = "cave_select", tx = "cave_perturb_scale"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sultat: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ec/deb/4fa/0ecdeb4faf32eea11c05a7a76b7c6225.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela rend les grottes un peu bruyantes et les rend moins douces. </font><font style="vertical-align: inherit;">Voyons maintenant ce qui se passe si vous appliquez les grottes au relief:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d34/974/278/d34974278435e239ad7eb9193adc9672.jpg"></div><br><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">En</font></b><font style="vertical-align: inherit;"> exp√©rimentant la valeur de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seuil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous pouvons rendre les grottes plus minces ou plus √©paisses. Mais l'essentiel que nous devons essayer est de nous assurer que les grottes ne rongent pas ces √©normes fragments du relief de surface. Pour ce faire, nous pouvons revenir √† la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui, rappelons-le, est la derni√®re fonction de relief qui d√©forme le gradient de la terre. Ce qui est utile dans cette fonction, c'est qu'il s'agit toujours d'un gradient, augmentant la valeur lorsque la fonction s'approfondit dans le sol. Nous pouvons utiliser le gradient pour affaiblir la fonction des grottes afin que les grottes augmentent √† mesure qu'elles s'enfoncent dans le sol. Heureusement pour nous, cette att√©nuation peut √™tre obtenue simplement en multipliant la sortie de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la sortie de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis passez le r√©sultat au reste de la cha√Æne de fonctions. Ensuite, nous apporterons un changement important ici - nous ajouterons la fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La fonction de mise en cache enregistre le r√©sultat de la fonction pour une coordonn√©e entrante donn√©e, et si la fonction est appel√©e √† plusieurs reprises avec la m√™me coordonn√©e, elle renverra une copie en cache et ne calculera plus le r√©sultat. Ceci est utile dans les situations o√π une fonction complexe ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dans une cha√Æne de fonctions est appel√©e plusieurs fois. Sans cache, toute la cha√Æne d'une fonction complexe est recalcul√©e √† chaque appel. Pour ajouter le cache, nous devons d'abord apporter les modifications suivantes:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "terrain_type_cache", seuil = 0,25, falloff = 0,15},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "highland_lowland_select_cache", type = "cache", source = "highland_lowland_select"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "ground_select", type = "select", bas = 0, haut = 1, seuil = 0,5, control = "highland_lowland_select_cache"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc ajout√© Cache, puis redirig√© l'entr√©e vers </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ground_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin qu'elle soit prise dans le cache, et non directement dans la fonction. </font><font style="vertical-align: inherit;">Ensuite, nous pouvons changer le code des grottes pour ajouter une att√©nuation:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "cave_shape", type = "fractal", fractaltype = anl.RIDGEDMULTI, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 1, fr√©quence = 4},</font></font><font></font>
{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous avons ajout√© la fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bias</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . C'est pour plus de commodit√©, car cela nous permet d'ajuster l'intervalle de la fonction d'att√©nuation du gradient. Ensuite, la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape_attenuate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><b><font style="vertical-align: inherit;">ajout√©e</font></b><font style="vertical-align: inherit;"> , qui est un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">combinateur de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anl :: MULT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Elle multiplie le gradient par </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le r√©sultat de cette op√©ration est ensuite transmis √† la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_perturb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le r√©sultat ressemble √† ceci:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f8/55d/fd3/8f855dfd376c5d8049a075d28066f72c.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous voyons que plus pr√®s de la surface de la terre est devenue plus mince. </font><font style="vertical-align: inherit;">(Ne faites pas attention au sommet, ce n'est qu'un artefact de valeurs de gradient n√©gatives, cela n'affecte pas les grottes finies. Si cela devient un probl√®me - disons que si nous utilisons cette fonction pour autre chose, nous pouvons limiter le gradient √† l'intervalle (0, 1).) Il est un peu difficile de voir comment cela fonctionne par rapport au terrain, alors continuons et mettons tout en place pour voir ce qui se passe. </font><font style="vertical-align: inherit;">Voici toute la cha√Æne de fonctions que nous avons cr√©√©es jusqu'√† pr√©sent.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terraintree =
</font></font> {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "lowland_shape_fractal", type = "fractal", fractaltype = anl.BILLOW, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 2, fr√©quence = 0,25},</font></font><font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_shape", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
	{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
	{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
	{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
	{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "cave_select", source_1 = "ground_select"}</font></font><font></font>
 }
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici des exemples de cartes randomis√©es d√©riv√©es de cette fonction: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/1a5/ca8/9f81a5ca8f1b739c03721b6a5ba280a5.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/5ec/b69/c865ecb69a1701a1b757535f289c6c0a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a82/332/1e3/a823321e389de00947e695424497f2e9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, tout semble plut√¥t bien. Toutes les grottes sont des cavernes assez grandes et profond√©ment souterraines, mais plus pr√®s de la surface, elles se transforment g√©n√©ralement en petits tunnels. Cela contribue √† cr√©er une atmosph√®re de myst√®re. En explorant la surface, vous trouvez une petite entr√©e dans la grotte. O√π va-t-elle? Quelle est sa profondeur? Nous ne pouvons pas le savoir, mais au cours de son √©tude, il commence √† s'√©tendre, se transformant en un vaste syst√®me de cavernes remplies d'obscurit√© et de dangers. Et le butin, bien s√ªr. Il y a toujours beaucoup de butin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez modifier ce syst√®me de diff√©rentes mani√®res et obtenir des r√©sultats diff√©rents. Nous pouvons changer les param√®tres de seuil pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les param√®tres de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_attenuate_bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou remplacer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_attenuate_bias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'autres fonctions pour faire correspondre l'intervalle de gradient √† d'autres valeurs mieux adapt√©es √† vos besoins. Vous pouvez √©galement ajouter une autre fractale qui d√©forme le syst√®me de grottes le long de l'axe Y pour √©liminer la possibilit√© de tunnels anormalement lisses le long de l'axe X (caus√©s par le fait que la forme de la grotte n'est d√©form√©e que le long de l'axe X). Vous pouvez √©galement ajouter une nouvelle fractale comme source d'att√©nuation suppl√©mentaire, d√©finir une troisi√®me source pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cave_shape_attenuate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui met √† l'√©chelle l'att√©nuation en fonction des r√©gions, afin que les grottes dans certaines zones soient plus denses (par exemple, dans les montagnes), et moins souvent ou compl√®tement absentes dans d'autres. Cette s√©lection r√©gionale peut √™tre cr√©√©e √† partir de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terrain_type_fractal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour savoir o√π se trouvent les zones de montagne. Tout se r√©sume √† penser √† ce que vous voulez, √† d√©terminer quel effet les diff√©rentes fonctions auront sur la sortie et √† exp√©rimenter les param√®tres jusqu'√† ce que vous obteniez le r√©sultat souhait√©. Ce n'est pas une science exacte, et souvent l'effet souhait√© peut √™tre atteint de diff√©rentes mani√®res.</font></font><br><br><h2>  Inconv√©nients </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette m√©thode de g√©n√©ration de terrain pr√©sente des inconv√©nients. </font><font style="vertical-align: inherit;">Le processus de g√©n√©ration de bruit peut √™tre assez lent. </font><font style="vertical-align: inherit;">Il est important de r√©duire le nombre de fractales, le nombre d'octaves de ces fractales que vous utilisez et d'autres op√©rations lentes, si possible. </font><font style="vertical-align: inherit;">Essayez d'utiliser les fractales plusieurs fois et mettez en cache toutes les fonctions appel√©es plusieurs fois. </font><font style="vertical-align: inherit;">Dans cet exemple, j'ai librement utilis√© des fractales, en cr√©ant une pour chacun des trois types de relief. </font><font style="vertical-align: inherit;">En utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScaleOffset</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour changer les intervalles et en prenant une fractale comme base pour tous, je gagnerais beaucoup de temps processeur. </font><font style="vertical-align: inherit;">En 2D, tout n'est pas si mal, mais lorsque vous arrivez en 3D et essayez de comparer les quantit√©s de donn√©es, le temps de traitement augmentera consid√©rablement.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aller en 3D </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout cela est super si vous cr√©ez un jeu comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">King Arthur's Gold</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais que faire si vous avez besoin de quelque chose comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minecraft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infiniminer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Quels changements devons-nous apporter √† la cha√Æne de fonctions? En fait, il n'y en a pas beaucoup. La fonction ci-dessus fonctionnera presque sans modification pour le relief 3D. Il vous suffira de comparer le volume 3D en utilisant les variations 3D du g√©n√©rateur, et aussi de comparer l'axe Y avec l'axe vertical du volume, et non la r√©gion 2D. Cependant, un changement sera n√©anmoins n√©cessaire, √† savoir un moyen de r√©aliser les grottes. Comme vous l'avez vu, Ridged Multifractal est id√©al pour un syst√®me de grottes 2D, mais en 3D, il coupe beaucoup de coquilles incurv√©es, pas de tunnels, et son effet se r√©v√®le √™tre faux. Autrement dit, en 3D, il est n√©cessaire de sp√©cifier deux formes fractales de grottes, les deux sont des bruits multifractaux √† 1 octave, mais avec des germes diff√©rents. √Ä l'aide de Select, d√©finissez-les sur 1 ou 0 et multipliez-les. Ainsi, √† l'intersection des fractales, une grotte appara√Ætra,et tout le reste restera solide, et l'apparence des tunnels deviendra plus naturelle que l'utilisation d'une seule fractale.</font></font><br><br><pre>terraintree3d=
 {<font></font>
	{name="ground_gradient", type="gradient", x1=0, x2=0, y1=0, y2=1},<font></font>
	<font></font>
	{name="lowland_shape_fractal", type="fractal", fractaltype=anl.BILLOW, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=2, frequency=0.25},<font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape1", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape2", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape1", source_1="cave_attenuate_bias", source_2="cave_shape2"},             <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb_fractal", type = "fractal", fractaltype = anl.FBM, basistype = anl.GRADIENT, interptype = anl.QUINTIC, octaves = 6, fr√©quence = 3},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb_scale", type = "scaleoffset", source = "cave_perturb_fractal", scale = 0.5, offset = 0},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_perturb", type = "translomain", source = "cave_shape_attenuate", tx = "cave_perturb_scale"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "cave_select", type = "select", bas = 1, haut = 0, control = "cave_perturb", seuil = 0,48, chute = 0},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "cave_select", source_1 = "ground_select"}</font></font><font></font>
 }
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exemples de r√©sultats: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/484/3fa/8e9/4843fa8e95e46162345f36edcf767fbe.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b91/671/848/b91671848dac9a42f371d549adf07181.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que certains param√®tres n√©cessitent un r√©glage. </font><font style="vertical-align: inherit;">Il peut √™tre utile de r√©duire l'att√©nuation ou d'amincir les grottes, de r√©duire le nombre d'octaves dans la fractale du relief, de sorte que le relief devienne plus lisse, etc. ... Je r√©p√®te, tout d√©pend du r√©sultat que vous souhaitez obtenir.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472574/">https://habr.com/ru/post/fr472574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472562/index.html">Tendances financi√®res: les grandes entreprises ont besoin de plus en plus de professionnels de l'informatique</a></li>
<li><a href="../fr472566/index.html">L'enfer personnel de l'√©crivain Fraerman, ou le conte du premier amour</a></li>
<li><a href="../fr472568/index.html">D√©ploiement d'Apache Ignite Zero: exactement z√©ro?</a></li>
<li><a href="../fr472570/index.html">Intel Xeon W Big Update</a></li>
<li><a href="../fr472572/index.html">DevOps et Chaos: livraison de logiciels dans un monde d√©centralis√©</a></li>
<li><a href="../fr472576/index.html">XVIe conf√©rence des d√©veloppeurs de logiciels libres ou o√π trouver des contributeurs gratuits</a></li>
<li><a href="../fr472580/index.html">Gestion des services d'entreprise: pourquoi √©tendre la gestion des services au-del√† de l'informatique</a></li>
<li><a href="../fr472582/index.html">Histoire d'Internet: l'ordinateur comme appareil de communication</a></li>
<li><a href="../fr472586/index.html">Analyse du haut-parleur: ce qu'il y a √† l'int√©rieur et comment cela fonctionne</a></li>
<li><a href="../fr472588/index.html">Tout ce que vous vouliez savoir sur le pendule invers√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>