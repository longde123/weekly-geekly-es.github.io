<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📧 🧘🏾 📦 Panduan otentikasi Node.js tanpa passport.js dan layanan pihak ketiga 🐃 🤸🏽 📭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis artikel, terjemahan yang kami terbitkan hari ini, mengatakan bahwa sekarang Anda dapat mengamati semakin populernya layanan otentikasi seperti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan otentikasi Node.js tanpa passport.js dan layanan pihak ketiga</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457700/">  Penulis artikel, terjemahan yang kami terbitkan hari ini, mengatakan bahwa sekarang Anda dapat mengamati semakin populernya layanan otentikasi seperti Google Firebase Authentication, AWS Cognito dan Auth0.  Solusi umum seperti passport.js telah menjadi standar industri.  Namun, mengingat situasi saat ini, sudah menjadi hal biasa bahwa pengembang tidak pernah sepenuhnya memahami mekanisme mana yang terlibat dalam pengoperasian sistem otentikasi. <br><br>  Materi ini dikhususkan untuk masalah pengorganisasian otentikasi pengguna di Node.js.  Di dalamnya, pada contoh praktis, organisasi pendaftaran pengguna dalam sistem dan organisasi masuknya mereka ke dalam sistem dipertimbangkan.  Ini akan mengangkat masalah seperti bekerja dengan teknologi JWT dan peniruan pengguna. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/8q/s0/uv/8qs0uvft-oqo_nmhu1vwlpf4rjw.jpeg"></a> <br><br>  Juga, perhatikan repositori GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , yang berisi kode untuk proyek Node.js, beberapa contohnya diberikan dalam artikel ini.  Anda dapat menggunakan repositori ini sebagai dasar untuk eksperimen Anda sendiri. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Persyaratan proyek</font> </h2><br>  Berikut adalah persyaratan untuk proyek yang akan kami tangani di sini: <br><br><ul><li>  Kehadiran database di mana alamat email dan kata sandi pengguna akan disimpan, baik clientId dan clientSecret, atau semacam kombinasi kunci pribadi dan publik. </li><li>  Menggunakan algoritma kriptografi yang kuat dan efisien untuk mengenkripsi kata sandi. </li></ul><br>  Saat ini ketika saya sedang menulis materi ini, saya percaya bahwa yang terbaik dari algoritma kriptografi yang ada adalah Argon2.  Saya meminta Anda untuk tidak menggunakan algoritma kriptografi sederhana seperti SHA256, SHA512 atau MD5. <br><br>  Selain itu, saya sarankan Anda melihat materi yang luar biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , di mana Anda dapat menemukan detail tentang memilih algoritma untuk hashing password. <br><br><h2>  <font color="#3AC1EF">Registrasi pengguna dalam sistem</font> </h2><br>  Ketika pengguna baru dibuat dalam sistem, kata sandinya harus diacak dan disimpan dalam database.  Kata sandi disimpan dalam database bersama dengan alamat email dan informasi lain tentang pengguna (misalnya, di antaranya adalah profil pengguna, waktu pendaftaran, dan sebagainya). <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{   public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> SignUp(email, password, name): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> passwordHashed = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.hash(password);     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.create({       <span class="hljs-attr"><span class="hljs-attr">password</span></span>: passwordHashed,       email,       name,     });     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       <span class="hljs-comment"><span class="hljs-comment">//    - !!!       user: {         email: userRecord.email,         name: userRecord.name,       },       }</span></span></code> </pre> <br>  Informasi akun pengguna akan terlihat seperti berikut ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/df3/027/2b3df30272e36e256f719b93ddf1197c.jpg"></div><br>  <i><font color="#999999">Data pengguna diambil dari MongoDB menggunakan Robo3T</font></i> <br><br><h2>  <font color="#3AC1EF">Login Pengguna</font> </h2><br>  Berikut adalah diagram tindakan yang dilakukan ketika pengguna mencoba masuk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/449/370/7e2/4493707e27d80de68619e12f8e7a8639.png"></div><br>  <i><font color="#999999">Login Pengguna</font></i> <br><br>  Inilah yang terjadi ketika pengguna masuk: <br><br><ul><li>  Klien mengirimkan kombinasi server dari pengidentifikasi publik dan kunci pribadi pengguna.  Ini biasanya alamat email dan kata sandi. </li><li>  Server mencari pengguna dalam database berdasarkan alamat email. </li><li>  Jika pengguna ada di database, server hash kata sandi yang dikirim kepadanya dan membandingkan apa yang terjadi dengan hash kata sandi yang disimpan dalam database. </li><li>  Jika verifikasi berhasil, server menghasilkan apa yang disebut token atau token otentikasi - JSON Web Token (JWT). </li></ul><br>  JWT adalah kunci sementara.  Klien harus mengirim kunci ini ke server dengan setiap permintaan ke titik akhir yang diautentikasi. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Login(email, password): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ email });    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!userRecord) {      <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>)    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> correctPassword = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.verify(userRecord.password, password);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!correctPassword) {        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Incorrect password'</span></span>)            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {      <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {        <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name,      },      <span class="hljs-attr"><span class="hljs-attr">token</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateJWT(userRecord),    }</code> </pre> <br>  Verifikasi kata sandi dilakukan menggunakan pustaka argon2.  Ini untuk mencegah apa yang disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangan waktu</a> ".  Ketika melakukan serangan seperti itu, seorang penyerang mencoba untuk memecahkan kata sandi dengan kekerasan, berdasarkan pada analisis berapa lama waktu yang dibutuhkan server untuk membentuk respons. <br><br>  Sekarang mari kita bicara tentang cara menghasilkan JWT. <br><br><h2>  <font color="#3AC1EF">Apa itu JWT?</font> </h2><br>  JSON Web Token (JWT) adalah objek JSON yang disandikan dalam bentuk string.  Token dapat diambil sebagai pengganti cookie, yang memiliki beberapa keunggulan dibandingkan cookie. <br><br>  Token terdiri dari tiga bagian.  Ini tajuk, payload, dan tanda tangan.  Gambar berikut menunjukkan penampilannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/a11/08d/f16a1108de7e0a5d8e4754725aacc830.jpg"></div><br>  <i><font color="#999999">Jwt</font></i> <br><br>  Data token dapat didekodekan pada sisi klien tanpa menggunakan kunci rahasia atau tanda tangan. <br><br>  Ini bisa berguna untuk mentransfer, misalnya, metadata yang disandikan di dalam token.  Metadata tersebut dapat menggambarkan peran pengguna, profilnya, durasi token, dan sebagainya.  Mereka dapat dimaksudkan untuk digunakan dalam aplikasi front-end. <br><br>  Inilah yang terlihat seperti token yang diterjemahkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/734/5fa/3e57345fafedf8eaa0d326190aa03b47.jpg"></div><br>  <i><font color="#999999">Token Terdekode</font></i> <br><br><h2>  <font color="#3AC1EF">Menghasilkan JWT di Node.js</font> </h2><br>  Mari kita buat fungsi <code>generateToken</code> yang kita perlukan untuk menyelesaikan pekerjaan pada layanan otentikasi pengguna. <br><br>  Anda dapat membuat JWT menggunakan perpustakaan jsonwebtoken.  Anda dapat menemukan perpustakaan ini di npm. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'jsonwebtoken'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  private generateToken(user) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = {      <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: user._id,      <span class="hljs-attr"><span class="hljs-attr">name</span></span>: user.name,      <span class="hljs-attr"><span class="hljs-attr">email</span></span>: user.email    };    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signature = <span class="hljs-string"><span class="hljs-string">'MySuP3R_z3kr3t'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expiration = <span class="hljs-string"><span class="hljs-string">'6h'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jwt.sign({ data, }, signature, { <span class="hljs-attr"><span class="hljs-attr">expiresIn</span></span>: expiration }); }</code> </pre> <br>  Yang paling penting di sini adalah data yang disandikan.  Jangan mengirim informasi pengguna rahasia di token. <br><br>  Tanda tangan (di sini adalah <code>signature</code> konstan) adalah data rahasia yang digunakan untuk menghasilkan JWT.  Sangat penting untuk memastikan bahwa tanda tangan tidak jatuh ke tangan yang salah.  Jika tanda tangan dikompromikan, penyerang akan dapat menghasilkan token atas nama pengguna dan mencuri sesi mereka. <br><br><h2>  <font color="#3AC1EF">Perlindungan Endpoint dan Validasi JWT</font> </h2><br>  Sekarang kode klien perlu mengirim JWT di setiap permintaan ke titik akhir yang aman. <br><br>  Disarankan agar Anda memasukkan JWT dalam header permintaan.  Mereka biasanya dimasukkan dalam header Otorisasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/4dd/19d/b5c4dd19dfd705c210c9b4f5ce5212cf.jpg"></div><br>  <i><font color="#999999">Header Otorisasi</font></i> <br><br>  Sekarang, di server, Anda perlu membuat kode yang middleware untuk rute ekspres.  Masukkan kode ini ke file <code>isAuth.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express-jwt'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ,  JWT      Authorization,        req.body,    ,      ,     . const getTokenFromHeader = (req) =&gt; {  if (req.headers.authorization &amp;&amp; req.headers.authorization.split(' ')[0] === 'Bearer') {    return req.headers.authorization.split(' ')[1]; } export default jwt({  secret: 'MySuP3R_z3kr3t', //      ,     JWT  userProperty: 'token', //       ,     services/auth:generateToken -&gt; 'req.token'  getToken: getTokenFromHeader, //        })</span></span></code> </pre> <br>  Berguna untuk memperoleh informasi lengkap tentang akun pengguna dari basis data dan melampirkannya pada permintaan.  Dalam kasus kami, fitur ini diimplementasikan menggunakan middleware dari file <code>attachCurrentUser.ts</code> .  Berikut ini kode yang disederhanakan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (req, res, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> decodedTokenData = req.tokenData; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: decodedTokenData._id })  req.currentUser = userRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).end(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next(); }</code> </pre> <br>  Setelah menerapkan mekanisme ini, rute akan dapat menerima informasi tentang pengguna yang mengeksekusi permintaan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ItemsModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/items'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.get(<span class="hljs-string"><span class="hljs-string">'/inventory/personal-items'</span></span>, isAuth, attachCurrentUser, (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = req.currentUser;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userItems = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ItemsModel.find({ <span class="hljs-attr"><span class="hljs-attr">owner</span></span>: user._id });      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json(userItems).status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  Rute <code>inventory/personal-items</code> sekarang dilindungi.  Untuk mengaksesnya, pengguna harus memiliki JWT yang valid.  Rute, di samping itu, dapat menggunakan informasi pengguna untuk mencari di database untuk informasi yang dibutuhkan. <br><br><h2>  <font color="#3AC1EF">Mengapa token dilindungi dari penyusup?</font> </h2><br>  Setelah membaca tentang menggunakan JWT, Anda dapat bertanya pada diri sendiri pertanyaan berikut: "Jika data JWT dapat diterjemahkan pada sisi klien, apakah mungkin untuk memproses token sedemikian rupa untuk mengubah ID pengguna atau data lainnya?". <br><br>  Dekode Token - operasi ini sangat sederhana.  Namun, Anda tidak dapat "mengulang" token ini tanpa memiliki tanda tangan itu, data rahasia yang digunakan saat menandatangani JWT di server. <br><br>  Itulah sebabnya perlindungan data sensitif ini sangat penting. <br><br>  Server kami memverifikasi tanda tangan di middleware isAuth.  Perpustakaan express-jwt bertanggung jawab untuk memeriksa. <br><br>  Sekarang, setelah kami menemukan cara kerja teknologi JWT, mari kita bicara tentang beberapa fitur tambahan menarik yang diberikannya kepada kita. <br><br><h2>  <font color="#3AC1EF">Bagaimana cara menyamar sebagai pengguna?</font> </h2><br>  Peniruan pengguna adalah teknik yang digunakan untuk masuk ke sistem sebagai pengguna tertentu tanpa mengetahui kata sandinya. <br><br>  Fitur ini sangat berguna untuk administrator super, pengembang, atau staf pendukung.  Peniruan memungkinkan mereka untuk memecahkan masalah yang muncul hanya saat pengguna bekerja dengan sistem. <br><br>  Anda dapat bekerja dengan aplikasi atas nama pengguna tanpa mengetahui kata sandinya.  Untuk melakukan ini, cukup menghasilkan JWT dengan tanda tangan yang benar dan dengan metadata yang diperlukan yang menggambarkan pengguna. <br><br>  Buat titik akhir yang dapat menghasilkan token untuk memasuki sistem dengan kedok pengguna tertentu.  Hanya super-administrator sistem yang dapat menggunakan titik akhir ini. <br><br>  Sebagai permulaan, kami harus menetapkan peran pengguna ini dengan tingkat hak istimewa yang lebih tinggi daripada pengguna lain.  Ini dapat dilakukan dengan berbagai cara.  Misalnya, cukup menambahkan bidang <code>role</code> ke informasi pengguna yang disimpan dalam database. <br><br>  Mungkin terlihat seperti yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/c19/30e/f69c1930ec89fdf649d73772cc7754bc.jpg"></div><br>  <i><font color="#999999">Bidang baru dalam informasi pengguna</font></i> <br><br>  Nilai bidang <code>role</code> <code>super-admin</code> adalah <code>super-admin</code> . <br><br>  Selanjutnya, Anda perlu membuat middleware baru yang memeriksa peran pengguna: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (requiredRole) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(req.currentUser.role === requiredRole) {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next();    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).send(<span class="hljs-string"><span class="hljs-string">'Action not allowed'</span></span>);    }</code> </pre> <br>  Itu harus ditempatkan setelah isAuth dan attachCurrentUser.  Sekarang buat titik akhir yang menghasilkan JWT untuk pengguna atas nama siapa super administrator ingin login: <br><br><pre> <code class="javascript hljs">  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> roleRequired <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlwares/roleRequired'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/user'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.post(<span class="hljs-string"><span class="hljs-string">'/auth/signin-as-user'</span></span>, isAuth, attachCurrentUser, roleRequired(<span class="hljs-string"><span class="hljs-string">'super-admin'</span></span>), (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userEmail = req.body.email;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userEmail });      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">404</span></span>).send(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>);           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json({        <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {          <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,          <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name        },        <span class="hljs-attr"><span class="hljs-attr">jwt</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateToken(userRecord)      })      .status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  Seperti yang Anda lihat, tidak ada yang misterius.  Administrator super tahu alamat email pengguna atas nama siapa Anda ingin masuk.  Logika kode di atas sangat mengingatkan pada bagaimana kode bekerja, memberikan input ke sistem pengguna biasa.  Perbedaan utama adalah bahwa kata sandi tidak diperiksa di sini. <br>  Kata sandi tidak diverifikasi di sini karena memang tidak diperlukan di sini.  Keamanan endpoint disediakan oleh middleware. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Tidak ada yang salah dengan mengandalkan layanan otentikasi dan perpustakaan pihak ketiga.  Ini membantu pengembang menghemat waktu.  Tetapi mereka juga perlu tahu tentang prinsip-prinsip yang menjadi dasar pengoperasian sistem otentikasi, dan apa yang memastikan berfungsinya sistem tersebut. <br><br>  Pada artikel ini, kami mengeksplorasi kemungkinan otentikasi JWT, berbicara tentang pentingnya memilih algoritma kriptografi yang baik untuk hashing password.  Kami memeriksa pembuatan mekanisme peniruan pengguna. <br><br>  Melakukan hal yang sama dengan sesuatu seperti passport.js jauh dari mudah.  Otentikasi adalah topik yang sangat besar.  Mungkin kita akan kembali padanya. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda membuat sistem otentikasi untuk proyek Node.js Anda? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457700/">https://habr.com/ru/post/id457700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457690/index.html">Video paranoid dari Yandex.Money metap</a></li>
<li><a href="../id457692/index.html">Refleksi Standar NB-Fi Nasional dan Sistem Penagihan</a></li>
<li><a href="../id457694/index.html">Bahaya menggunakan konstanta multi-karakter</a></li>
<li><a href="../id457696/index.html">Bahaya menggunakan konstanta multi-karakter</a></li>
<li><a href="../id457698/index.html">Eksperimen: kami menggunakan proxy sebagai alat untuk memerangi serangan DoS</a></li>
<li><a href="../id457702/index.html">Bekerja dengan API KOMPAS-3D → Pelajaran 16 → Kontrol karakter</a></li>
<li><a href="../id457704/index.html">Bagaimana GPU menangani percabangan</a></li>
<li><a href="../id457706/index.html">Robot menguji SAP ERP</a></li>
<li><a href="../id457710/index.html">Fitur luar biasa dari jaringan saraf 2019</a></li>
<li><a href="../id457712/index.html">Bagaimana Verizon dan BGP Optimizer diatur secara offline</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>