<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏼 🕥 🍖 Memprediksi churn pengguna menggunakan metode RFM 🤵🏾 🐠 🎺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bayangkan: panggilan telepon jam tiga pagi, Anda mengangkat telepon dan mendengar teriakan bahwa tidak ada orang lain yang menggunakan produk Anda. Me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memprediksi churn pengguna menggunakan metode RFM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/431520/">  Bayangkan: panggilan telepon jam tiga pagi, Anda mengangkat telepon dan mendengar teriakan bahwa tidak ada orang lain yang menggunakan produk Anda.  Menakutkan  Dalam kehidupan, tentu saja, tidak demikian, tetapi jika Anda tidak memperhatikan masalah arus keluar pengguna, Anda mungkin menemukan diri Anda dalam situasi yang sama. <br><br>  Kami telah menjelaskan secara terperinci apa itu outflow: kami mempelajari teori dan menunjukkan cara mengubah jaringan saraf menjadi oracle digital.  Para ahli di Plarium Krasnodar tahu cara lain untuk memprediksi.  Kami akan membicarakannya. <br><br><img src="https://habrastorage.org/webt/p6/pg/wx/p6pgwxi7gim6qn_uyrb3vbcihn8.jpeg"><a name="habracut"></a><br><br><h2>  Ini bukan RFM yang kita butuhkan. </h2><br>  RFM adalah metode yang digunakan untuk mensegmentasi pelanggan dan menganalisis perilaku mereka.  Berdasarkan data yang diperoleh, Anda dapat membuat program loyalitas untuk setiap grup, membangun distribusi pengguna dan memperkirakan kapan mereka akan kembali untuk pembelian. <br><br>  Sejarah pengembangan RFM dimulai pada tahun 1987 ketika artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghitung Pelanggan Anda: Siapa Mereka dan Apa yang Akan Mereka Lakukan Selanjutnya</a> diterbitkan.  Ini menggambarkan metode analisis berdasarkan distribusi Pareto (keluarga dua parameter dari distribusi yang benar-benar kontinu). <br><br>  Model itu disebut Pareto / NBD dan hanya memperhitungkan riwayat pembelian pengguna.  Dalam interpretasi klasik, karya metode ini dibangun di atas lima pilar, atau perkiraan: <br><br><ol><li>  Selama pengguna aktif, jumlah transaksi yang dilakukan oleh pembeli selama periode t mematuhi distribusi Pareto dengan rata-rata λt. </li><li>  Heterogenitas dari parameter λ (tingkat transaksi) mengikuti distribusi gamma dengan parameter r dan α. </li><li>  Setiap pembeli memiliki periode waktu "kehidupan" tanpa batas τ.  Titik di mana pengguna menjadi tidak aktif didistribusikan secara eksponensial dengan parameter μ (angka putus sekolah). </li><li>  Heterogenitas parameter μ di antara pengguna mengikuti distribusi gamma dengan parameter s (bentuk) dan β (skala). </li><li>  Parameter λ dan μ dapat bervariasi secara independen di antara pembeli. </li></ol><br>  Kerugian dari model ini adalah kompleksitas yang tinggi dalam menghitung fungsi hypergeometrik Gauss dan pencarian fungsi kemungkinan maksimum. <br><br>  Dalam artikel 2003, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Menghitung Pelanggan Anda," Cara Mudah: Sebuah Alternatif untuk Model Pareto / NBD</a> , ide model yang lebih baik diterbitkan.  Selain riwayat pembelian, dua parameter lagi digunakan di dalamnya: frekuensi dan resep.  Perbedaan utama dari Pareto / NBD adalah bagaimana saat pelanggan pergi ditentukan. <br><br>  Dalam pengaturan klasik, diasumsikan bahwa pengguna dapat pergi kapan saja, terlepas dari frekuensi dan pola pembeliannya di masa lalu.  Pendekatan baru didasarkan pada hipotesis bahwa pembeli dapat mulai kehilangan minat segera setelah transaksi selesai. <br><br>  Ini menyederhanakan perhitungan dan mengarah ke model beta-geometric (BG / NBD).  Ini menggunakan tiga parameter utama: kebaruan, frekuensi, moneter, - serta empat parameter tambahan: r, α, a, b (parameter a dan b ditambahkan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">distribusi beta</a> ). <br><br>  RFM membantu memprediksi jika pelanggan akan melakukan pembelian di masa depan.  Spesialis Plarium Krasnodar memodifikasi metode ini. <br><br><h2>  Prediksi arus keluar dengan sederhana dan penuh selera </h2><br>  Untuk perhitungan, kita membutuhkan berbagai data tentang sesi permainan.  Ini dihitung ulang menjadi matriks yang terdiri dari parameter RFM, dan menjadi empat koefisien lagi, yang dipilih oleh model dalam proses pembelajaran. <br><br>  Dalam konteks permainan, parameter memperoleh makna berikut: <br><ul><li>  <b>R</b> ecency - berapa lama pengguna bermain pada saat login terakhir; </li><li>  Frekuensi - seberapa sering pengguna memasukkan kembali game; </li><li>  <b>M</b> onetary - berapa lama pengguna telah bermain (waktu "hidup"). </li></ul><br>  Parameter digabungkan menjadi sebuah matriks.  Kemudian dimasukkan ke dalam model yang menghitung kemungkinan "kehidupan" pengguna - peluang bahwa mereka akan terus bermain. <br><br>  Perhitungan dilakukan sesuai dengan rumus: <br><img src="https://habrastorage.org/webt/kb/jm/xf/kbjmxfailrdkmvgzugmuofr8wa8.jpeg"><br><br>  Jelas, untuk pengguna tanpa entri ulang, probabilitas "hidup" akan menjadi satu.  Pada tahun 2008, penulis artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komputasi P (hidup) Menggunakan Model BG / NBD</a> mengusulkan solusi untuk masalah ini.  Perusahaan game dapat menggunakan dua opsi yang memberikan hasil serupa. <br><br>  <b>Metode 1</b> - π parameter dimasukkan untuk semua pengguna.  Ini menunjukkan pemain mana yang dianggap tidak aktif. <br>  <b>Metode 2</b> - unit ditambahkan ke parameter Frekuensi.  Ukuran ini menghindari degenerasi rumus pada Frekuensi = 0, tetapi secara artifisial menambahkan satu entri lagi ke dalam game untuk setiap pengguna. <br><br><h2>  Cara mengadaptasi metode RFM untuk pengembang game </h2><br>  Misalkan kita memiliki pengguna baru.  Dia baru saja memasuki game.  Parameter <i>F</i> = 1 (atau 0, tergantung pada perhitungan), karena entri pertama tidak dipertimbangkan, dan pemain belum mengulangi entri. <br><br>  Pengguna bermain tiga hari.  Parameter berubah: <i>F</i> hanya memperhitungkan input harian, oleh karena itu nilainya 2, dan indikator <i>M</i> dan <i>R</i> adalah 3. Dengan menggunakan data ini, kami mendapatkan probabilitas "masa pakai" mendekati kesatuan. <br><br>  Hari berikutnya, pengguna tidak memasuki game.  Parameter <i>M</i> diperbarui, sementara <i>F</i> dan <i>R</i> tetap sama.  Mengganti semua nilai dalam rumus, kita melihat bahwa indikator probabilitas menjadi lebih rendah. <br><br>  Jika pengguna tidak bermain selama seminggu, maka indikator <i>M</i> diperbarui lagi dan kemungkinan "hidup" semakin turun. <br><img src="https://habrastorage.org/webt/jp/ai/mi/jpaimiwjacq7q6vqssvudkrdrv4.jpeg"><br>  Grafik pengguna aktif terlihat berbeda.  Kemungkinan "hidup" akan berkurang tergantung pada sejarahnya.  Jika dia masuk ke permainan setiap hari dan tiba-tiba berhenti, maka nilai indikator akan turun jauh lebih cepat daripada jika dia bermain setiap dua hari. <br><img src="https://habrastorage.org/webt/sv/mb/7g/svmb7gce0q3ng_9jn9gyxj2ymfm.jpeg"><br><h2>  Pro Penting dan Kontra Yang Tidak Terlihat dari RFM </h2><br>  Keuntungan utama dari metode ini adalah kesederhanaannya: <br><br><ul><li>  untuk perhitungan Anda tidak perlu menggunakan alat matematika yang kompleks; </li><li>  indikator dihitung menggunakan rumus yang relatif sederhana; </li><li>  Anda dapat melakukannya tanpa saluran pipa yang rumit untuk data; </li><li>  semua parameter model optimal dipilih secara otomatis. </li></ul><br>  Selain itu, data RFM mudah ditafsirkan.  Mempelajari sejarah pengguna, orang dapat memahami mengapa ia memiliki probabilitas "kehidupan" seperti itu.  Seringkali, ketika bekerja dengan metode yang lebih kompleks, lebih sulit untuk menarik kesimpulan spesifik. <br><br>  RFM juga memiliki kekurangan.  <b>Pertama</b> , ini bukan metode yang paling akurat.  Ini berfungsi dengan baik, tetapi sejumlah parameter tidak digunakan dalam perhitungan.  Misalnya, banyak pengguna mulai kehilangan minat karena kebiasaan memasuki permainan.  Artinya, jumlah rata-rata sesi permainan per hari berkurang, dan frekuensi entri ulang tidak berubah. <br><br>  <b>Kedua</b> , metode ini tidak memperhitungkan aktivitas pengguna: berapa banyak sumber daya yang ia transfer, apakah ia menyerang musuh, atau menciptakan pasukan.  Jika kita mengambil semua pemain dengan probabilitas "hidup" sama dengan ~ 0.8, maka tergantung pada parameter dan riwayat mereka, selain yang aktif, akan ada yang masuk setiap tiga hari. <br><br>  <b>Ketiga</b> , pengguna yang pergi menjadi "hidup" ketika ia memulai permainan lagi.  Apa yang harus dia lakukan ini sebulan setelah login terakhir.  Situasi seperti itu menyulitkan deteksi pemain dengan jeda besar di antara sesi.  Secara umum, ini tidak kritis, meskipun memperkenalkan ketidakseimbangan tertentu ketika kami mencoba memahami apakah pengguna "hidup" atau tidak. <br><br><h2>  Bukankah lebih baik menggunakan jaringan saraf? </h2><br>  Lebih baik, tetapi pertama-tama, Anda perlu memahami bagaimana menerapkan proyek: untuk menyelesaikan tugas-tugas skala besar dengan cepat atau secara bertahap bergerak menuju tujuan. <br><br>  Analisis RFM menunjukkan probabilitas "kehidupan" pengguna pada saat perhitungan dilakukan.  Kami tidak akan dapat memahami apakah pemain akan pergi dalam dua atau tiga minggu, dan jaringan saraf akan dapat.  Mengingat seluruh infrastruktur, menciptakan sistem terintegrasi untuk menganalisis perilaku pemain dari awal jauh lebih sulit.  Selain itu, Anda memerlukan garis dasar, yang dengannya Anda dapat membandingkan kualitas jaringan saraf.  Pendekatan semacam itu kemungkinan akan menghasilkan kerugian finansial jika Anda tidak menghitung kekuatannya. <br><br>  Pengalaman kami menunjukkan bahwa tugas global perlu diimplementasikan secara bertahap.  Membuat prototipe yang berfungsi tidak sulit, tetapi mengumpulkan dan memproses data, mengatur dan melatih jaringan saraf adalah masalah lain.  Proses-proses ini dapat bertahan lama, yang selalu kurang. <br><br>  Itulah mengapa kami memutuskan untuk menggunakan model yang lebih sederhana: kami melakukan penelitian, mengidentifikasi pro dan kontra, dan mengujinya dalam pekerjaan.  Hasilnya cocok untuk kita.  RFM memiliki kekurangan, tetapi mereka dengan murah hati diimbangi dengan kemudahan penggunaan.  Dan jaringan saraf adalah langkah selanjutnya menuju perbaikan sistem. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431520/">https://habr.com/ru/post/id431520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431510/index.html">Cara mengumpulkan informasi dari Kontur. Membeli dengan Selenium</a></li>
<li><a href="../id431512/index.html">Sebuah studi kecil tentang sifat-sifat U-net sederhana, jaringan konvolusional klasik untuk segmentasi</a></li>
<li><a href="../id431514/index.html">Wawancara untuk pewawancara</a></li>
<li><a href="../id431516/index.html">Suatu hari dalam kehidupan seorang Penasihat Keuangan</a></li>
<li><a href="../id431518/index.html">Microsoft Connect (); Pertemuan di Moskow</a></li>
<li><a href="../id431524/index.html">Serialisasi di Jawa. Tidak sesederhana itu</a></li>
<li><a href="../id431526/index.html">Pengaruh korup: bagaimana Stasi membela Jerman Timur dari video game</a></li>
<li><a href="../id431528/index.html">Jenius matematika misterius dan penulis mempromosikan solusi masalah permutasi</a></li>
<li><a href="../id431530/index.html">Buka pelajaran "Desain Material Android: pembaruan ikhtisar"</a></li>
<li><a href="../id431532/index.html">Memristor terdiri dari bagian tebal 2 nm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>