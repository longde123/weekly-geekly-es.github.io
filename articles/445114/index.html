<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéì üë©üèΩ‚Äçü§ù‚Äçüë®üèø üèáüèº Sandboxing mejorado para scripts geniales üõÄüèæ üçÇ üßëüèΩ‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De un traductor: Al desarrollar la Plataforma CUBA, ponemos en este marco la capacidad de ejecutar scripts personalizados para una configuraci√≥n m√°s f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sandboxing mejorado para scripts geniales</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/445114/"><p><img src="https://habrastorage.org/webt/l7/d9/cg/l7d9cgoh4tjgptdfr68phnooab4.jpeg"></p><br><p>  <em>De un traductor: Al desarrollar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Plataforma CUBA,</a> ponemos en este marco la capacidad de ejecutar scripts personalizados para una configuraci√≥n m√°s flexible de la l√≥gica empresarial de la aplicaci√≥n.</em>  <em>Si esta oportunidad es buena o mala (y estamos hablando no solo de CUBA) se debate durante mucho tiempo, sino que el hecho de que el control sobre la ejecuci√≥n de los scripts de usuario sea necesario no plantea dudas.</em>  <em>Una de las caracter√≠sticas √∫tiles de Groovy para administrar la ejecuci√≥n de scripts personalizados se presenta en esta traducci√≥n de C√©dric Champeau.</em>  <em>A pesar de que recientemente dej√≥ el equipo de desarrollo de Groovy, la comunidad de programadores parece estar aprovechando su trabajo durante mucho tiempo.</em> </p><br><p>  Una de las formas m√°s utilizadas para usar Groovy es a trav√©s de secuencias de comandos, ya que Groovy facilita la ejecuci√≥n din√°mica de c√≥digo en tiempo de ejecuci√≥n.  Dependiendo de la aplicaci√≥n, los scripts se pueden ubicar en diferentes lugares: el sistema de archivos, la base de datos, los servicios remotos ... pero lo m√°s importante, el desarrollador de la aplicaci√≥n que ejecuta los scripts no necesariamente los escribe.  Adem√°s, los scripts pueden funcionar en un entorno limitado (memoria limitada, l√≠mite en la cantidad de descriptores de archivos, tiempo de ejecuci√≥n ...), o puede querer evitar que el usuario use todas las funciones de lenguaje en el script. </p><br><p>  <strong>Esta publicaci√≥n te lo dir√°.</strong> </p><br><ul><li>  por qu√© groovy es bueno para escribir dsl interno </li><li>  ¬øCu√°les son sus caracter√≠sticas en t√©rminos de seguridad de su aplicaci√≥n? </li><li>  C√≥mo configurar la compilaci√≥n para mejorar DSL </li><li> sobre el valor de <code>SecureASTCustomizer</code> </li><li>  acerca de las extensiones de control de tipo </li><li>  c√≥mo usar extensiones de control de tipo para hacer efectivo el sandboxing </li></ul><a name="habracut"></a><br><p>  Por ejemplo, imagine lo que necesita hacer para que el usuario pueda calcular expresiones matem√°ticas.  Una opci√≥n de implementaci√≥n es incrustar un DSL interno, crear un analizador y finalmente un int√©rprete para estas expresiones.  Para hacer esto, por supuesto, tendr√° que trabajar, pero si necesita aumentar la productividad, por ejemplo, generando bytecode para expresiones en lugar de calcularlas en el int√©rprete o usando el almacenamiento en cach√© de clases generadas en tiempo de ejecuci√≥n, entonces Groovy es una gran opci√≥n. </p><br><p>  Hay muchas opciones descritas en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> , pero el ejemplo m√°s simple es usar la clase <code>Eval</code> : </p><br><p> <code>Example.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = (Integer) Eval.me(<span class="hljs-string"><span class="hljs-string">"1+1"</span></span>);</code> </pre> <br><p>  El c√≥digo <code>1+1</code> es analizado, compilado en bytecode, cargado y ejecutado por Groovy en tiempo de ejecuci√≥n.  Por supuesto, el c√≥digo en este ejemplo es muy simple, y necesitar√° agregar par√°metros, pero la idea es que el c√≥digo ejecutable puede ser arbitrario.  Y eso puede no ser exactamente lo que necesita.  En la calculadora debe permitir algo como esto: </p><br><pre> <code class="plaintext hljs">1+1 x+y 1+(2*x)**y cos(alpha)*r v=1+x</code> </pre> <br><p>  pero ciertamente no </p><br><pre> <code class="plaintext hljs">println 'Hello' (0..100).each { println 'Blah' } Pong p = new Pong() println(new File('/etc/passwd').text) System.exit(-1) Eval.me('System.exit(-1)') // a script within a script!</code> </pre> <br><p>  Es aqu√≠ donde comienzan las dificultades, y tambi√©n queda claro que necesitamos resolver varios problemas: </p><br><ul><li>  limitar la gram√°tica de un idioma a un subconjunto de sus capacidades </li><li>  evitar que los usuarios ejecuten el c√≥digo que no se proporciona </li><li>  evitar la ejecuci√≥n de c√≥digo malicioso </li></ul><br><p>  El ejemplo de la calculadora es bastante simple, pero para DSL m√°s complejas, las personas pueden no darse cuenta de que est√°n escribiendo c√≥digo problem√°tico, especialmente si DSL es tan simple que puede ser utilizado por personas que <em>no son desarrolladores</em> . </p><br><p>  Hace unos a√±os estaba en esta situaci√≥n.  Desarroll√© un motor que ejecutaba "guiones" Groovy escritos por ling√ºistas.  Un problema, por ejemplo, era que sin darse cuenta pod√≠an crear un bucle sin fin.  El c√≥digo se ejecut√≥ en el servidor y apareci√≥ un subproceso que devoraba el 100% de la CPU, despu√©s de lo cual fue necesario reiniciar el servidor de aplicaciones.  Tuve que buscar una manera de resolver el problema sin afectar el DSL, las herramientas o el rendimiento de la aplicaci√≥n. </p><br><p>  De hecho, muchas personas tienen necesidades similares.  En los √∫ltimos 4 a√±os, he estado hablando con muchas personas que han tenido la misma pregunta: <em>¬øc√≥mo puedo evitar que los usuarios hagan tonter√≠as en los scripts Groovy?</em> </p><br><h2 id="kastomayzery-kompilyacii">  Compiladores de personalizaci√≥n </h2><br><p>  En ese momento, ya ten√≠a mi propia decisi√≥n y sab√≠a que otras personas tambi√©n desarrollaron algo similar.  Al final, Guillaume Laforge sugiri√≥ que creara un mecanismo en el n√∫cleo Groovy para ayudar a resolver estos problemas.  Apareci√≥ en Groovy 1.8.0 como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">personalizadores de compilaci√≥n</a> . </p><br><p>  Los personalizadores de compilaci√≥n son un conjunto de clases que modifican el proceso de compilaci√≥n de los scripts Groovy.  Puede escribir su propio personalizador, pero Groovy proporciona: </p><br><ul><li>  Importar personalizador que impl√≠citamente agrega importaciones a los scripts para que los usuarios no necesiten agregar descripciones de importaci√≥n </li><li>  Personalizar transformaciones AST (√Årbol de sintaxis abstracta), lo que le permite agregar transformaciones AST directamente a los scripts </li><li>  Personalizador AST seguro que restringe las construcciones de gram√°tica y sintaxis de un idioma </li></ul><br><p>  El personalizador de las transformaciones AST me ayud√≥ a resolver el problema del bucle sin fin con la transformaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>@ThreadInterrupt</code></a> , pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SecureASTCustomizer</a> es lo que probablemente se malinterpreta en la gran mayor√≠a de los casos. </p><br><p>  Deber√≠a disculparme por eso.  Entonces no pude encontrar un mejor nombre.  La parte m√°s importante del nombre "SecureASTCustomizer" es el <strong>AST</strong> .  El prop√≥sito de este mecanismo era limitar el acceso a ciertas funciones AST.  La palabra "seguro" en el t√≠tulo es generalmente superflua, y explicar√© por qu√©.  Incluso hay una publicaci√≥n de blog del famoso Kosuke Kawaguchi de Jenkins, titulada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Fatal Groovy SecureASTCustomizer"</a> .  Y todo est√° escrito muy correctamente all√≠.  SecureASTCustomizer no fue dise√±ado para sandboxing.  Fue creado para limitar el idioma en tiempo de compilaci√≥n, pero no la ejecuci√≥n.  Ahora creo que el mejor nombre ser√≠a <em>GrammarCustomizer</em> .  Pero, como seguramente sabe, hay tres dificultades en inform√°tica: invalidaci√≥n de cach√©, inventar nombres y un error por unidad. </p><br><p>  Ahora imagine que est√° considerando el personalizador AST seguro como un medio para garantizar la seguridad de su script, y su tarea es evitar que el usuario <code>System.exit</code> desde el script.  La documentaci√≥n dice que las llamadas pueden prohibirse en receptores especiales creando listas negras o blancas.  Si se necesita seguridad, siempre recomiendo listas blancas que indiquen estrictamente lo que est√° permitido, pero no listas negras que proh√≠ban cualquier cosa.  Porque los hackers siempre piensan en lo que quiz√°s no hayas considerado.  Dar√© un ejemplo. </p><br><p>  Aqu√≠ le mostramos c√≥mo configurar un motor de script de sandbox primitivo con <code>SecureASTCustomizer</code> .  Aunque podr√≠a escribirlos en Groovy, doy ejemplos de configuraci√≥n de Java para que la diferencia entre el c√≥digo de integraci√≥n y los scripts sea m√°s expl√≠cita. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); SecureASTCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureASTCustomizer(); customizer.setReceiversBlackList(Arrays.asList(System.class.getName())); conf.addCompilationCustomizers(customizer); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(conf); Object v = shell.evaluate(<span class="hljs-string"><span class="hljs-string">"System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Result = "</span></span> +v); } }</code> </pre> <br><ol><li>  crear configuraci√≥n del compilador </li><li>  crear un personalizador AST seguro </li><li>  declarar que la clase del <code>System</code> como receptor de llamadas a m√©todos est√° en la lista negra </li><li>  agregar personalizador a la configuraci√≥n del compilador </li><li>  enlazar la configuraci√≥n con el script de shell, es decir, intentar crear un sandbox </li><li>  ejecutar el script "malo" </li><li>  muestra el resultado de ejecutar el script </li></ol><br><p>  Si ejecuta esta clase, se producir√° un error durante la ejecuci√≥n del script: </p><br><pre> <code class="plaintext hljs">General error during canonicalization: Method calls not allowed on [java.lang.System] java.lang.SecurityException: Method calls not allowed on [java.lang.System]</code> </pre> <br><p>  Esta conclusi√≥n es emitida por una aplicaci√≥n con un personalizador AST seguro, que no permite la ejecuci√≥n de m√©todos de la clase <code>System</code> .  √âxito!  ¬°As√≠ que hemos protegido nuestro gui√≥n!  Pero espera un minuto ... </p><br><h2 id="secureastcustomizer-vzloman">  ¬°SecureASTCustomizer est√° pirateado! </h2><br><p>  Protecci√≥n, digamos?  Pero qu√© pasa si hago esto: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Si vuelve a ejecutar el programa, ver√° que se bloquea <strong>sin</strong> error y <strong>sin</strong> mostrar el resultado en la pantalla.  El c√≥digo de salida del proceso es -1, lo que significa que se ha ejecutado el script de usuario.  Que paso  En el momento de la compilaci√≥n, el personalizador seguro de AST no puede reconocer que <code>c.exit</code> es, en principio, una llamada al m√©todo del <code>System</code> porque funciona en el nivel de AST.  Analiza la llamada al m√©todo, y en este caso, la llamada al m√©todo es <code>c.exit(-1)</code> , luego determina el receptor y verifica si est√° en la lista blanca (o negra).  En este caso, el receptor es <code>c</code> , esta variable se <strong>declara a trav√©s de def</strong> , y esto es lo mismo que declararlo como un <code>Object</code> , y el personalizador AST seguro pensar√° que el tipo de la variable <code>c</code> es <code>Object</code> , ¬°no <code>System</code> ! </p><br><p>  En general, hay <strong>muchas</strong> formas de sortear las diversas configuraciones creadas en el personalizador AST seguro.  Aqu√≠ hay algunos geniales: </p><br><pre> <code class="java hljs">((Object)System).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) Class.forName(<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span> as Class).exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.<span class="hljs-function"><span class="hljs-function">exit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  y puede haber <strong>muchos</strong> m√°s  La naturaleza din√°mica de Groovy impide la capacidad de solucionar estos problemas en tiempo de compilaci√≥n.  Sin embargo, existe una soluci√≥n.  Una opci√≥n es confiar en el administrador de seguridad JVM est√°ndar.  Sin embargo, esta es una soluci√≥n pesada y voluminosa de inmediato para todo el sistema, y ‚Äã‚Äãesto es equivalente a disparar un ca√±√≥n a los gorriones.  Adem√°s, no funciona en todos los casos, por ejemplo, si desea prohibir la lectura de archivos, pero no crear ... </p><br><p>  Esta limitaci√≥n, m√°s bien un disgusto para muchos de nosotros, llev√≥ a la creaci√≥n de una soluci√≥n basada en <strong>controles en tiempo de ejecuci√≥n</strong> .  Este tipo de verificaci√≥n no tiene tales problemas.  Por ejemplo, porque sabr√° el tipo de receptor real del mensaje antes de comenzar la validaci√≥n de la llamada al m√©todo.  De particular inter√©s son las siguientes implementaciones: </p><br><ul><li>  <a href="">SecureScript</a> de Jim White </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Groovy Sandbox</a> por Kosuke Kawaguchi </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Groovy Sandbox</a> de Simon Temple </li></ul><br><p>  Sin embargo, ninguna de estas implementaciones es completamente confiable y segura.  Por ejemplo, la versi√≥n de Kosuke se basa en el pirateo de la implementaci√≥n interna del sitio de llamadas en cach√©.  El problema es que no es compatible con la versi√≥n din√°mica invocada de Groovy, y estas clases internas no estar√°n en versiones futuras de Groovy.  La versi√≥n de Simon, por otro lado, se basa en transformaciones AST, pero deja muchos agujeros potenciales. </p><br><p>  Como resultado, mis amigos Corinne Crisch, Fabrice Matrat y Sebastian Blanc, y yo decidimos crear un nuevo mecanismo de sandboxing en tiempo de ejecuci√≥n, que no tendr√° problemas como estos proyectos.  Comenzamos a implementarlo en un hackathon en Niza, y en la conferencia de Greach el a√±o pasado hicimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un informe al respecto</a> .  Este mecanismo se basa en las transformaciones AST y esencialmente reescribe el c√≥digo para verificar antes de cada llamada al m√©todo, intentar acceder al campo de clase, incrementar una variable, expresi√≥n binaria ... Esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementaci√≥n</a> a√∫n no est√° lista, y no se ha hecho mucho trabajo al respecto, por lo que como me di cuenta de que el problema con los m√©todos y par√°metros llamados a trav√©s de "esto impl√≠cito" a√∫n no se ha resuelto, como, por ejemplo, en los constructores: </p><br><pre> <code class="plaintext hljs">xml { cars { // cars is a method call on an implicit this: "this".cars(...) car(make:'Renault', model: 'Clio') } }</code> </pre> <br><p>  Hasta la fecha, todav√≠a no he encontrado una manera de resolver este problema debido a la arquitectura del protocolo de metaobjetos en Groovy, que se basa en el hecho de que el receptor lanza una excepci√≥n cuando no puede encontrar el m√©todo antes de cambiar a otro receptor.  En resumen, esto significa que no puede averiguar el tipo de receptor antes de la llamada al m√©todo real.  Y si la llamada ha pasado, entonces es demasiado tarde ... </p><br><p>  Y hasta hace poco, no ten√≠a una soluci√≥n √≥ptima para este problema para el caso en que el script ejecutable usa las propiedades din√°micas del lenguaje.  Pero ahora es el momento de explicar c√≥mo puede mejorar significativamente la situaci√≥n si est√° dispuesto a sacrificar un poco el dinamismo del lenguaje. </p><br><h2 id="proverka-tipov">  Comprobaci√≥n de tipo </h2><br><p>  Volvamos al problema principal con SecureASTCustomizer: funciona con un √°rbol de sintaxis abstracta y no tiene informaci√≥n sobre tipos de mensajes y receptores espec√≠ficos.  Pero con Groovy 2, Groovy ha agregado compilaci√≥n, y en Groovy 2.1 hemos agregado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extensiones para la verificaci√≥n de tipos</a> . </p><br><p>  Las extensiones para la verificaci√≥n de tipos son muy poderosas: permiten que el desarrollador de Groovy DSL ayude al compilador con la inferencia de tipos, y tambi√©n permiten la generaci√≥n de errores de compilaci√≥n en los casos en que generalmente no ocurren.  Groovy utiliza estas extensiones internamente para admitir un compilador est√°tico, por ejemplo, al implementar rasgos o un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de plantillas de marcado</a> . </p><br><p>  ¬øQu√© pasar√≠a si, en lugar de utilizar los resultados del analizador, pudi√©ramos confiar en la informaci√≥n del mecanismo de verificaci√≥n de tipo?  Tome el c√≥digo que nuestro hacker intent√≥ escribir: </p><br><p> <code>((Object)System).exit(-1)</code> </p> <br><p>  Si activa las verificaciones de tipo, el c√≥digo no compila: </p><br><pre> <code class="plaintext hljs">1 compilation error: [Static type checking] - Cannot find matching method java.lang.Object#exit(java.lang.Integer). Please check if the declared type is right and if the method exists.</code> </pre> <br><p>  Entonces este c√≥digo ya no se compila.  Y qu√© pasa si tomamos este c√≥digo: </p><br><pre> <code class="java hljs">def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Como puede ver, pasa la verificaci√≥n de tipo, se envuelve en un m√©todo y se ejecuta utilizando el comando <code>groovy</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@groovy</span></span>.transform.TypeChecked <span class="hljs-comment"><span class="hljs-comment">// or even @CompileStatic void foo() { def c = System c.exit(-1) } foo()</span></span></code> </pre> <br><p>  El verificador de tipo detecta que el m√©todo de <code>exit</code> se llama desde la clase <code>System</code> y es v√°lido.  Esto no nos ayudar√° aqu√≠.  Pero lo que sabemos es que si este c√≥digo pasa la verificaci√≥n de tipo, significa que el compilador reconoce la llamada al receptor con el tipo <code>System</code> .  En general, la idea es prohibir una llamada con una extensi√≥n para la verificaci√≥n de tipos. </p><br><h2 id="prostoe-rasshirenie-dlya-proverki-tipov">  Extensi√≥n simple para verificaci√≥n de tipo </h2><br><p>  Antes de profundizar en el sandboxing en detalle, intentemos "asegurar" nuestro script con la ayuda de una extensi√≥n est√°ndar para la verificaci√≥n de tipos.  Registrar una extensi√≥n de este tipo es f√°cil: simplemente configure el par√°metro de <code>extensions</code> para la anotaci√≥n <code>@TypeChecked</code> (o <code>@CompileStatic</code> si est√° utilizando una compilaci√≥n est√°tica): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TypeChecked</span></span>(extensions=[<span class="hljs-string"><span class="hljs-string">'SecureExtension1.groovy'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ def c = System c.exit(-<span class="hljs-number"><span class="hljs-number">1</span></span>) } foo()</code> </pre> <br><p>  La b√∫squeda de extensiones se llevar√° a cabo en el classpath en el formato de c√≥digo fuente (puede hacer extensiones precompiladas para la verificaci√≥n de tipos, pero no las consideraremos en este art√≠culo): </p><br><p> <code>SecureExtension1.groovy</code> </p> <br><pre> <code class="java hljs">onMethodSelection { expr, methodNode -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodNode.declaringClass.name==<span class="hljs-string"><span class="hljs-string">'java.lang.System'</span></span>) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"Method call is not allowed!"</span></span>, expr) } }</code> </pre> <br><ol><li>  cuando el verificador de tipos selecciona un m√©todo para llamar </li><li>  si el m√©todo pertenece a la clase <code>System</code> </li><li>  luego deje que el verificador de tipos genere un error </li></ol><br><p>  Eso es todo lo que necesitas.  ¬°Ahora ejecute el c√≥digo nuevamente y ver√° un error de compilaci√≥n! </p><br><pre> <code class="plaintext hljs">/home/cchampeau/tmp/securetest.groovy: 6: [Static type checking] - Method call is not allowed! @ line 6, column 3. c.exit(-1) ^ 1 error</code> </pre> <br><p>  Esta vez, gracias al comprobador de tipos, <code>c</code> reconoce como una instancia de la clase <code>System</code> , y podemos prohibir la llamada.  Este es un ejemplo muy simple y no demuestra todo lo que se puede hacer con el personalizador AST seguro en t√©rminos de configuraci√≥n.  En la extensi√≥n que <strong>escribimos</strong> , los cheques est√°n <strong>codificados</strong> , pero podr√≠a ser mejor hacerlos personalizables.  As√≠ que hagamos el ejemplo m√°s complicado. </p><br><p>  Suponga que su aplicaci√≥n calcula ciertas m√©tricas para un documento y permite a los usuarios personalizarlas.  En este caso, DSL: </p><br><ul><li>  operar√° (al menos) la variable de <code>score</code> </li><li>  permite a los usuarios realizar operaciones matem√°ticas (incluidos los m√©todos <em>cos</em> , <em>abs</em> , ...) </li><li>  debe prohibir todos los dem√°s m√©todos </li></ul><br><p>  Script de usuario de muestra: </p><br><p> <code>abs(cos(1+score))</code> </p> <br><p>  Este DSL es f√°cil de configurar.  Esta es una variante de lo que definimos anteriormente: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs">CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding,conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score))"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore);</code> </pre> <br><ol><li>  agregue el personalizador de importaci√≥n que agregar√° <code>import static java.lang.Math.*</code> a todos los scripts </li><li>  hacer variable de <code>score</code> disponible para script </li><li>  ejecutar script </li></ol><br><p>  <em>Hay formas de almacenar en cach√© los scripts en lugar de analizarlos y compilarlos cada vez.</em>  <em>Consulte la documentaci√≥n para m√°s detalles.</em> </p><br><p>  Entonces, nuestro script funciona, pero nada impide que el hacker inicie c√≥digo malicioso.  Como planeamos usar la verificaci√≥n de tipo, recomendar√≠a usar la transformaci√≥n <code>@CompileStatic</code> : </p><br><ul><li>  activa la verificaci√≥n de tipo en el script, y podremos realizar verificaciones adicionales gracias a la extensi√≥n para la verificaci√≥n de tipo </li><li>  mejorar el rendimiento del script </li></ul><br><p>  <code>@CompileStatic</code> impl√≠citamente la anotaci√≥n <code>@CompileStatic</code> a sus scripts es bastante simple.  Solo necesita actualizar la configuraci√≥n del compilador: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer(CompileStatic.class); conf.addCompilationCustomizers(astcz);</code> </pre> <br><p>  Ahora, si intentas ejecutar el script nuevamente, ver√°s un error de compilaci√≥n: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - The variable [score] is undeclared. @ line 1, column 11. abs(cos(1+score)) ^ Script1.groovy: 1: [Static type checking] - Cannot find matching method int#plus(java.lang.Object). Please check if the declared type is right and if the method exists. @ line 1, column 9. abs(cos(1+score)) ^ 2 errors</code> </pre> <br><p>  Que paso  Si lee el gui√≥n desde el punto de vista del compilador, queda claro que √©l no sabe nada acerca de la variable "puntaje".  Pero <strong>usted,</strong> como desarrollador, sabe que esta es una variable <code>double</code> , pero el compilador no puede generarla.  Para esto, se crean extensiones para la verificaci√≥n de tipos: puede proporcionar informaci√≥n adicional al compilador, y la compilaci√≥n funcionar√° bien.  En este caso, debemos indicar que la variable de <code>score</code> es de tipo <code>double</code> . </p><br><p>  Por lo tanto, puede cambiar ligeramente la forma en que se <code>@CompileStatic</code> anotaci√≥n <code>@CompileStatic</code> : </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension2.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  Esto "emula" el c√≥digo anotado por <code>@CompileStatic(extensions=['SecureExtension2.groovy'])</code> .  Ahora, por supuesto, necesitamos escribir una extensi√≥n que reconozca la variable de <code>score</code> : </p><br><p> <code>SecureExtension2.groovy</code> </p> <br><pre> <code class="java hljs">unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name==<span class="hljs-string"><span class="hljs-string">'score'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, double_TYPE) } }</code> </pre> <br><ol><li>  en caso de que el verificador de tipos no pueda determinar la variable </li><li>  si el nombre de la variable es <code>score</code> </li><li>  deje que el compilador defina la variable din√°micamente con el tipo <code>double</code> </li></ol><br><p>  Puede encontrar una descripci√≥n completa de las extensiones DSL para la verificaci√≥n de tipos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en esta secci√≥n de la documentaci√≥n</a> , pero hay un ejemplo de un modo de compilaci√≥n combinado: el compilador no puede definir una variable de <code>score</code> .  Usted, como desarrollador de DSL, <strong>sabe</strong> que la variable es en realidad su tipo: <code>double</code> , por lo que la llamada a <code>makeDynamic</code> aqu√≠ para decir: "ok, no se preocupe, s√© lo que estoy haciendo, esta variable se puede definir din√°micamente con el tipo <code>double</code> "  Eso es todo! </p><br><h2 id="pervoe-zavershennoe-secure-rasshirenie">  Primera extensi√≥n "segura" completada </h2><br><p>  Ahora pongamos todo junto.  Escribimos una extensi√≥n de verificaci√≥n de tipo que evita las llamadas a m√©todos de la clase <code>System</code> por un lado y otra que define la variable de <code>score</code> por el otro.  Entonces, si los conectamos, obtenemos la primera extensi√≥n completa para la verificaci√≥n de tipos: </p><br><p> <code>SecureExtension3.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// disallow calls on System onMethodSelection { expr, methodNode -&gt; if (methodNode.declaringClass.name=='java.lang.System') { addStaticTypeError("Method call is not allowed!", expr) } } // resolve the score variable unresolvedVariable { var -&gt; if (var.name=='score') { return makeDynamic(var, double_TYPE) } }</span></span></code> </pre> <br><p>  Recuerde actualizar la configuraci√≥n en su clase Java para usar la nueva extensi√≥n para la verificaci√≥n de tipos: </p><br><pre> <code class="java hljs">ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension3.groovy"</span></span>)), CompileStatic.class);</code> </pre> <br><p>  Ejecute el c√≥digo nuevamente, a√∫n funciona.  Ahora intenta esto: </p><br><pre> <code class="plaintext hljs">abs(cos(1+score)) System.exit(-1)</code> </pre> <br><p>  La compilaci√≥n del script se bloquear√° con un error: </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - Method call is not allowed! @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p>  ¬°Felicitaciones, acaba de escribir la primera extensi√≥n de verificaci√≥n de tipo que evita que se ejecute c√≥digo malicioso! </p><br><h2 id="uluchshenie-konfiguracii-rasshireniya">  Configuraci√≥n de extensi√≥n mejorada </h2><br><p>  Entonces, todo va bien, podemos prohibir las llamadas a m√©todos de la clase <code>System</code> , pero parece que pronto se descubrir√°n nuevas vulnerabilidades y tendremos que evitar el lanzamiento de c√≥digo malicioso.  Entonces, en lugar de codificar todo en la extensi√≥n, intentaremos que nuestra extensi√≥n sea universal y personalizable.  Este es probablemente el m√°s dif√≠cil, porque no hay una forma directa de pasar el contexto a la extensi√≥n para la verificaci√≥n de tipos.  La idea, por lo tanto, se basa en el uso de una variable local de subproceso (m√©todo de curva, s√≠) para pasar los datos de configuraci√≥n a los correctores de tipo. </p><br><p>  En primer lugar, haremos que la lista de variables sea personalizable.  As√≠ se ver√° el c√≥digo Java: </p><br><p> <code>Sandbox.java</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String VAR_TYPES = <span class="hljs-string"><span class="hljs-string">"sandboxing.variable.types"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadLocal&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CompilerConfiguration conf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); ImportCustomizer customizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImportCustomizer(); customizer.addStaticStars(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>); ASTTransformationCustomizer astcz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ASTTransformationCustomizer( singletonMap(<span class="hljs-string"><span class="hljs-string">"extensions"</span></span>, singletonList(<span class="hljs-string"><span class="hljs-string">"SecureExtension4.groovy"</span></span>)), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(); binding.setVariable(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>d); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Map&lt;String,ClassNode&gt; variableTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, ClassNode&gt;(); variableTypes.put(<span class="hljs-string"><span class="hljs-string">"score"</span></span>, ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, Object&gt;(); options.put(VAR_TYPES, variableTypes); COMPILE_OPTIONS.set(options); GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate(<span class="hljs-string"><span class="hljs-string">"abs(cos(1+score));System.exit(-1)"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"userScore = "</span></span> + userScore); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { COMPILE_OPTIONS.remove(); } } }</code> </pre> <br><ol><li>  <code>ThreadLocal</code> ,          </li><li>    ‚Äî <code>SecureExtension4.groovy</code> </li><li> <code>variableTypes</code> ‚Äî   ‚Äú  ‚Üí  ‚Äù </li><li>      <code>score</code> </li><li> <code>options</code> ‚Äî     </li><li>   "variable types"     VAR_TYPES </li><li>     thread local </li><li> ,    ,     thread local </li></ol><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>        thread local </li><li>      ,      , </li><li>   type checker       </li></ol><br><p>         thread local,    ,  type checker  . ,      <code>unresolvedVariable</code> ,    ,  ,    type checker,   .  ,     .   ! </p><br><p>           .        ,       . </p><br><h2 id="konfiguraciya-belogo-spiska-metodov">     </h2><br><p>    .   ,       .      ,         ,     . ,  <code>System.exit</code> ,   : </p><br><pre> <code class="plaintext hljs">java.lang.System#exit(int)</code> </pre> <br><p> ,     Java,    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sandbox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String WHITELIST_PATTERNS = <span class="hljs-string"><span class="hljs-string">"sandboxing.whitelist.patterns"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... public static void main(String[] args) { // ... try { Map&lt;String,ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String,Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); patterns.add("java\\.lang\\.Math#"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Double userScore = (Double) shell.evaluate("abs(cos(1+score));System.exit(-1)"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><ol><li>    </li><li>    <code>java.lang.Math</code>   </li><li>        </li></ol><br><p>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!whiteList.any { descr =~ it }) { addStaticTypeError(<span class="hljs-string"><span class="hljs-string">"You tried to call a method which is not allowed, what did you expect?: $descr"</span></span>, expr) } } unresolvedVariable { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> makeDynamic(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, typesOfVariables[<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.name]) } }</code> </pre> <br><ol><li>       <code>MethodNode</code> </li><li>     thread local </li><li>       </li><li>        ,   </li></ol><br><p>      ,    : </p><br><pre> <code class="plaintext hljs">Script1.groovy: 1: [Static type checking] - You tried to call a method which is not allowed, what did you expect?: java.lang.System#exit(int) @ line 1, column 19. abs(cos(1+score));System.exit(-1) ^ 1 error</code> </pre> <br><p> ,  !        ,   <strong>  </strong> , <strong>  </strong>  .    ,      !     ,       ,       . ,   (  <code>foo.text</code> ,     <code>foo.getText()</code> ). </p><br><h2 id="sobiraem-vse-vmeste">    </h2><br><p>     ,    type checker'    "property selection", ,   .      ,         ,  .         ,     ,       ‚Äî    .     . </p><br><p> <code>SandboxingTypeCheckingExtension.groovy</code> </p> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> groovy.transform.CompileStatic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassCodeVisitorSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassHelper <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.ClassNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.MethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.Parameter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.ast.expr.PropertyExpression <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.control.SourceUnit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.ExtensionMethodNode <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Sandbox.* <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SandboxingTypeCheckingExtension</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyTypeCheckingExtensionSupport</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeCheckingDSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prettyPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassNode node)</span></span></span><span class="hljs-function"> </span></span>{ node.isArray()?<span class="hljs-string"><span class="hljs-string">"${prettyPrint(node.componentType)}[]"</span></span>:node.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@CompileStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toMethodDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExtensionMethodNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toMethodDescriptor(node.extensionMethodNode) } def sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() sb.append(node.declaringClass.toString(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) sb.append(node.name) sb.append(<span class="hljs-string"><span class="hljs-string">'('</span></span>) sb.append(node.parameters.collect { Parameter it -&gt; prettyPrint(it.originType) }.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)) sb.append(<span class="hljs-string"><span class="hljs-string">')'</span></span>) sb } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Fetch white list of regular expressions of authorized method calls def whiteList = COMPILE_OPTIONS.get()[WHITELIST_PATTERNS] def typesOfVariables = COMPILE_OPTIONS.get()[VAR_TYPES] onMethodSelection { expr, MethodNode methodNode -&gt; def descr = toMethodDescriptor(methodNode) if (!whiteList.any { descr =~ it }) { addStaticTypeError("You tried to call a method which is not allowed, what did you expect?: $descr", expr) } } unresolvedVariable { var -&gt; if (isDynamic(var) &amp;&amp; typesOfVariables[var.name]) { storeType(var, typesOfVariables[var.name]) handled = true } } // handling properties (like foo.text) is harder because the type checking extension // does not provide a specific hook for this. Harder, but not impossible! afterVisitMethod { methodNode -&gt; def visitor = new PropertyExpressionChecker(context.source, whiteList) visitor.visitMethod(methodNode) } } private class PropertyExpressionChecker extends ClassCodeVisitorSupport { private final SourceUnit unit private final List&lt;String&gt; whiteList PropertyExpressionChecker(final SourceUnit unit, final List&lt;String&gt; whiteList) { this.unit = unit this.whiteList = whiteList } @Override protected SourceUnit getSourceUnit() { unit } @Override void visitPropertyExpression(final PropertyExpression expression) { super.visitPropertyExpression(expression) ClassNode owner = expression.objectExpression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER) if (owner) { if (expression.spreadSafe &amp;&amp; StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(owner, classNodeFor(Collection))) { owner = typeCheckingVisitor.inferComponentType(owner, ClassHelper.int_TYPE) } def descr = "${prettyPrint(owner)}#${expression.propertyAsString}" if (!whiteList.any { descr =~ it }) { addStaticTypeError("Property is not allowed: $descr", expression) } } } } }```     sandbox',     assert' ,  ,     : ``Sandbox.java`` ```java public class Sandbox { public static final String WHITELIST_PATTERNS = "sandboxing.whitelist.patterns"; public static final String VAR_TYPES = "sandboxing.variable.types"; public static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; COMPILE_OPTIONS = new ThreadLocal&lt;Map&lt;String, Object&gt;&gt;(); public static void main(String[] args) { CompilerConfiguration conf = new CompilerConfiguration(); ImportCustomizer customizer = new ImportCustomizer(); customizer.addStaticStars("java.lang.Math"); ASTTransformationCustomizer astcz = new ASTTransformationCustomizer( singletonMap("extensions", singletonList("SandboxingTypeCheckingExtension.groovy")), CompileStatic.class); conf.addCompilationCustomizers(astcz); conf.addCompilationCustomizers(customizer); Binding binding = new Binding(); binding.setVariable("score", 2.0d); try { Map&lt;String, ClassNode&gt; variableTypes = new HashMap&lt;String, ClassNode&gt;(); variableTypes.put("score", ClassHelper.double_TYPE); Map&lt;String, Object&gt; options = new HashMap&lt;String, Object&gt;(); List&lt;String&gt; patterns = new ArrayList&lt;String&gt;(); // allow method calls on Math patterns.add("java\\.lang\\.Math#"); // allow constructors calls on File patterns.add("File#&lt;init&gt;"); // because we let the user call each/times/... patterns.add("org\\.codehaus\\.groovy\\.runtime\\.DefaultGroovyMethods"); options.put(VAR_TYPES, variableTypes); options.put(WHITELIST_PATTERNS, patterns); COMPILE_OPTIONS.set(options); GroovyShell shell = new GroovyShell(binding, conf); Object result; try { result = shell.evaluate("Eval.me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("System.exit(-1)"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("((Object)Eval).me('1')"); // error assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').getText()"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } try { result = shell.evaluate("new File('/etc/passwd').text"); // getText is not allowed assert false; } catch (MultipleCompilationErrorsException e) { System.out.println("Successful sandboxing: "+e.getMessage()); } Double userScore = (Double) shell.evaluate("abs(cos(1+score))"); System.out.println("userScore = " + userScore); } finally { COMPILE_OPTIONS.remove(); } } }</span></span></code> </pre> <br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>      Groovy       JVM.        ,      . ,    ,    ,      .  ,    Groovy,      sandboxing'          (,       ,   ). </p><br><p>  ,            ,          .      ,            .  ,      ,        . </p><br><p>    ,   sandboxing',   , ‚Äî  <strong></strong>  <code>SecureASTCustomizer</code> .    <strong> ,  </strong> ,       : secure AST customizer    ,      (,       ),              (   ,   ). </p><br><p> ,    : ,   , .   Groovy   .          Groovy,   ,  -      pull request,      -  ! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445114/">https://habr.com/ru/post/445114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445104/index.html">Una breve historia de la marca de audio Klipsch</a></li>
<li><a href="../445106/index.html">Mesa redonda: tecnolog√≠a aditiva como alternativa a la fabricaci√≥n tradicional</a></li>
<li><a href="../445108/index.html">Ni un halc√≥n: proyectos reutilizables de ESA y ULA fundamentalmente diferentes</a></li>
<li><a href="../445110/index.html">Una computadora con una unidad de terminal de estilo Fallout</a></li>
<li><a href="../445112/index.html">Desentra√±ar una mara√±a de vulnerabilidades en los sitios</a></li>
<li><a href="../445116/index.html">La Fuerza A√©rea de EE. UU. Est√° trabajando en un dron de inteligencia artificial llamado Skyborg</a></li>
<li><a href="../445118/index.html">En un chat privado de Telegram, puede eliminar cualquier mensaje, incluso extra√±os (se ha agregado un resultado de votaci√≥n)</a></li>
<li><a href="../445120/index.html">Frontend Weekly Digest (18-24 de marzo de 2019)</a></li>
<li><a href="../445122/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 357 (18 al 24 de marzo de 2019)</a></li>
<li><a href="../445124/index.html">Endurecimiento moderado para Firefox</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>