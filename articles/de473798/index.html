<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê∂ üöº üë©üèº‚Äçü§ù‚Äçüë®üèΩ Protokollorientierte Programmierung. Teil 1 ‚ÜóÔ∏è üêú üèØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schauen wir uns das Thema protokollorientierte Programmierung genauer an. Der Einfachheit halber wurde das Material in drei Teile geteilt. 


 Dieses ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokollorientierte Programmierung. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473798/"><p>  Schauen wir uns das Thema protokollorientierte Programmierung genauer an.  Der Einfachheit halber wurde das Material in drei Teile geteilt. </p><br><p>  Dieses Material ist eine Kommentar√ºbersetzung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation der WWDC 2016</a> .  Entgegen der allgemeinen √úberzeugung, dass Dinge "unter der Haube" dort bleiben sollten, ist es manchmal √§u√üerst n√ºtzlich, herauszufinden, was dort passiert.  Dies hilft, den Artikel korrekt und f√ºr den vorgesehenen Zweck zu verwenden. </p><a name="habracut"></a><br><p>  In diesem Teil werden wichtige Probleme der objektorientierten Programmierung und deren L√∂sung durch POP behandelt.  Alles wird in den Realit√§ten der Swift-Sprache ber√ºcksichtigt, die Details werden als "Haube" der Protokolle betrachtet. </p><br><h2 id="problemy-oop-i-zachem-nam-nuzhno-pop">  OOP Probleme und warum brauchen wir POP </h2><br><p>  Es ist bekannt, dass es in OOP eine Reihe von Schwachstellen gibt, die die Programmausf√ºhrung ‚Äû√ºberlasten‚Äú k√∂nnen.  Betrachten Sie die explizitesten und h√§ufigsten: </p><br><ol><li>  Zuordnung: Stapel oder Haufen? </li><li>  Referenzz√§hlung: mehr oder weniger? </li><li>  Methodenversand: statisch oder dynamisch? </li></ol><br><h3 id="11-allocation---stack">  1.1 Zuordnung - Stapel </h3><br><p>  Stack ist eine ziemlich einfache und primitive Datenstruktur.  Wir k√∂nnen oben auf den Stapel legen (dr√ºcken), wir k√∂nnen von oben auf den Stapel nehmen (Pop).  Die Einfachheit ist, dass dies alles ist, was wir damit machen k√∂nnen. </p><br><p>  Nehmen wir der Einfachheit halber an, dass jeder Stapel eine Variable (Stapelzeiger) hat.  Es wird verwendet, um den oberen Rand des Stapels zu verfolgen und eine Ganzzahl (Integer) zu speichern.  Daraus folgt, dass die Geschwindigkeit der Operationen mit dem Stapel gleich der Geschwindigkeit ist, mit der Integer in diese Variable umgeschrieben wird. </p><br><p>  Dr√ºcken Sie - setzen Sie auf die Oberseite des Stapels, erh√∂hen Sie den Stapelzeiger; </p><br><p>  pop - Stapelzeiger reduzieren. </p><br><h3 id="tipy-znacheniy">  Werttypen </h3><br><p>  Betrachten wir die Prinzipien der Stapeloperation in Swift unter Verwendung von Strukturen (struct). </p><br><p>  In Swift sind Werttypen Strukturen (struct) und Enumerationen (enum), und Referenztypen sind Klassen (class) und Funktionen / Verschl√ºsse (func).  Werttypen werden auf dem Stapel gespeichert, Referenztypen werden auf dem Heap gespeichert. </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/tq/vj/8y/tqvj8yfygyvbneaqfwwuiig8on0.png"></p><br><ol><li>  Wir platzieren die erste Struktur auf Stack </li><li>  Kopieren Sie den Inhalt der ersten Struktur </li><li>  √Ñndern Sie den Speicher der zweiten Struktur (die erste bleibt erhalten) </li><li>  Ende der Nutzung.  Freier Speicher </li></ol><br><h3 id="12-allocation---heap">  1.2 Zuordnung - Haufen </h3><br><p>  Heap ist eine baumartige Datenstruktur.  Das Thema der Heap-Implementierung ist hier nicht betroffen, aber wir werden versuchen, es mit dem Stack zu vergleichen. </p><br><p>  Warum lohnt es sich, wenn m√∂glich, Stack anstelle von Heap zu verwenden?  Deshalb: </p><br><ul><li>  Referenzz√§hlung </li><li>  freie Speicherverwaltung und Suche nach Zuordnung </li><li>  Speicher f√ºr Freigabe neu schreiben </li></ul><br><p>  All dies ist nur ein kleiner Teil dessen, was Heap zum Funktionieren bringt und es im Vergleich zu Stack deutlich belastet. </p><br><p>  Wenn wir beispielsweise freien Speicher auf dem Stapel ben√∂tigen, nehmen wir einfach den Wert des Stapelzeigers und erh√∂hen ihn (weil alles √ºber dem Stapelzeiger im Stapel freier Speicher ist) - O (1) ist eine Operation, die zeitlich konstant ist. </p><br><p>  Wenn wir freien Speicher auf Heap ben√∂tigen, beginnen wir mit dem entsprechenden Suchalgorithmus in der Datenbaumstruktur danach zu suchen. Im besten Fall haben wir eine O (logn) -Operation, die zeitlich nicht konstant ist und von bestimmten Implementierungen abh√§ngt. <br>  Tats√§chlich ist Heap viel komplizierter: Seine Arbeit wird von einer Vielzahl anderer Mechanismen bereitgestellt, die im Darm von Betriebssystemen leben. </p><br><p>  Es ist auch erw√§hnenswert, dass die Verwendung von Heap im Multithreading-Modus die Situation erheblich versch√§rft, da die Synchronisation der gemeinsam genutzten Ressource (Speicher) f√ºr verschiedene Threads sichergestellt werden muss.  Dies wird durch die Verwendung von Sperren (Semaphoren, Spinlocks usw.) erreicht. </p><br><h3 id="ssylochnye-tipy">  Referenztypen </h3><br><p>  Schauen wir uns an, wie Heap in Swift mithilfe von Klassen funktioniert. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/o4/ct/y3/o4cty3n_4gizx4o0-amtg2f5tqm.png"></p><br><p>  1. Legen Sie den Klassenk√∂rper auf Heap.  Platzieren Sie den Zeiger auf diesen K√∂rper auf dem Stapel. </p><br><ol><li>  Kopieren Sie den Zeiger, der sich auf den Hauptteil der Klasse bezieht </li><li>  Wir ver√§ndern einen K√∂rper einer Klasse </li><li>  Ende der Nutzung.  Freier Speicher </li></ol><br><h3 id="13-allocation---nebolshoy-i-realnyy-primer">  1.3 Zuordnung - Ein kleines und "echtes" Beispiel </h3><br><p>  In einigen Situationen vereinfacht die Auswahl von Stapel nicht nur die Speicherbehandlung, sondern verbessert auch die Codequalit√§t.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> red, green, blue } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, tail, bubble } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBalloon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color: Color, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation: Orientation, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tail: Tail)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIImage</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-string"><span class="hljs-string">"\(color):\(orientation):\(tail)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = cache[key] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image } ... }</code> </pre> <br><p>  Wenn das Cache-W√∂rterbuch einen Wert mit dem Schl√ºssel hat, gibt die Funktion einfach das zwischengespeicherte UIImage zur√ºck. </p><br><h3 id="problemy-etogo-koda">  Die Probleme dieses Codes sind: </h3><br><p>  Es ist keine gute Praxis, String als Schl√ºssel im Cache zu verwenden, da String am Ende "sich als alles herausstellen kann". </p><br><p>  String ist eine Copy-on-Write-Struktur. Um ihre Dynamik zu implementieren, werden alle Zeichen auf dem Heap gespeichert.  Daher ist String eine Struktur und wird im Stapel gespeichert, speichert jedoch den gesamten Inhalt auf dem Heap. </p><br><p>  Dies ist erforderlich, um die Zeile √§ndern zu k√∂nnen (einen Teil der Zeile entfernen, dieser Zeile eine neue Zeile hinzuf√ºgen).  Wenn alle Zeichen der Zeichenfolge auf dem Stapel gespeichert w√§ren, w√§ren solche Manipulationen unm√∂glich.  In C sind Zeichenfolgen beispielsweise statisch. Dies bedeutet, dass die Gr√∂√üe einer Zeichenfolge zur Laufzeit nicht erh√∂ht werden kann, da der gesamte Inhalt auf dem Stapel gespeichert ist.  Klicken Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , um die Zeilen in Swift zu kopieren und detaillierter zu analysieren. </p><br><h3 id="reshenie">  L√∂sung: </h3><br><ol><li><p>  Verwenden Sie die hier ganz offensichtliche Struktur anstelle der Zeichenfolge: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color: <span class="hljs-type"><span class="hljs-type">Color</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation: <span class="hljs-type"><span class="hljs-type">Orientation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tail: <span class="hljs-type"><span class="hljs-type">Tail</span></span> }</code> </pre> <br></li><li><p>  √Ñndern Sie das W√∂rterbuch in: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">Attributes</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = []</code> </pre> <br></li><li><p>  String loswerden </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-type"><span class="hljs-type">Attributes</span></span>(color: color, orientation: orientation, tail: tail)</code> </pre> <br></li></ol><br><p>  In der Attributstruktur werden alle Eigenschaften im Stapel gespeichert, da die Aufz√§hlung im Stapel gespeichert ist.  Dies bedeutet, dass Heap hier nicht implizit verwendet wird und jetzt die Schl√ºssel f√ºr das Cache-W√∂rterbuch sehr genau definiert sind, was die Sicherheit und Klarheit dieses Codes erh√∂ht.  Wir haben auch die implizite Verwendung von Heap beseitigt. </p><br><p>  <strong>Fazit:</strong> Stack ist viel einfacher und schneller als Heap - die Wahl f√ºr die meisten Situationen liegt auf der Hand. </p><br><h3 id="2-podschet-ssylok">  2. Referenzz√§hlung </h3><br><p>  Wof√ºr? </p><br><p>  Swift sollte wissen, wann es m√∂glich ist, ein St√ºck Speicher auf dem Heap freizugeben, das beispielsweise von einer Instanz einer Klasse oder Funktion belegt wird.  Dies wird durch einen Linkz√§hlmechanismus implementiert. Jede auf Heap gehostete Instanz (Klasse oder Funktion) verf√ºgt √ºber eine Variable, in der die Anzahl der Links gespeichert ist.  Wenn keine Links zu einer Instanz vorhanden sind, gibt Swift einen daf√ºr zugewiesenen Speicher frei. </p><br><p>  Es ist zu beachten, dass f√ºr eine ‚Äûqualitativ hochwertige‚Äú Implementierung dieses Mechanismus viel mehr Ressourcen ben√∂tigt werden als zum Erh√∂hen und Verringern des Stapelzeigers.  Dies liegt an der Tatsache, dass der Wert der Anzahl der Links von verschiedenen Threads aus zunehmen kann (weil Sie auf eine Klasse oder Funktion von verschiedenen Threads verweisen k√∂nnen).  Vergessen Sie auch nicht, die Synchronisierung einer gemeinsam genutzten Ressource (variable Anzahl von Links) f√ºr verschiedene Threads (Spinlocks, Semaphoren usw.) sicherzustellen. </p><br><p>  Stapel: freien Speicher finden und verwendeten Speicher freigeben - Stapelzeigeroperation </p><br><p>  Heap: Suche nach freiem Speicher und Freigabe des verwendeten Speichers - Baumsuchalgorithmus und Referenzz√§hlung. </p><br><p>  In der Attributstruktur werden alle Eigenschaften im Stapel gespeichert, da die Aufz√§hlung im Stapel gespeichert ist.  Dies bedeutet, dass Heap hier nicht implizit verwendet wird und jetzt die Schl√ºssel f√ºr das Cache-W√∂rterbuch sehr genau definiert sind, was die Sicherheit und Klarheit dieses Codes erh√∂ht.  Wir haben auch die implizite Verwendung von Heap beseitigt. </p><br><h3 id="psevdokod">  Pseudocode </h3><br><p>  Betrachten Sie einen kleinen Pseudocode, um zu demonstrieren, wie die Linkz√§hlung funktioniert: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(...) { ... <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point2 = point1 retain(point2) <span class="hljs-comment"><span class="hljs-comment">// retain() -  refCount  1    point2.x = 5 //  `point1` release(point1) // release() -  refCount  1 //  `point2` release(point2)</span></span></code> </pre> <br><h3 id="struct">  Struct </h3><br><p>  Bei der Arbeit mit Strukturen ist ein Mechanismus wie die Referenzz√§hlung einfach nicht erforderlich: </p><br><ol><li>  Struktur nicht auf Heap gespeichert </li><li>  Struktur - bei Zuordnung kopiert, daher keine Referenzen </li></ol><br><h3 id="kopirovanie-ssylok">  Links kopieren </h3><br><p>  Auch hier werden struct und alle anderen Werttypen in Swift bei der Zuweisung kopiert.  Wenn die Struktur Links in sich selbst speichert, werden sie auch kopiert: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> font: <span class="hljs-type"><span class="hljs-type">UIFont</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { ... text.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> font.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label = <span class="hljs-type"><span class="hljs-type">Label</span></span>(text: <span class="hljs-string"><span class="hljs-string">"Hi"</span></span>, font: font) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label2 = label retain(label2.text._storage) <span class="hljs-comment"><span class="hljs-comment">//    `String`       Heap retain(label2.font) //  label release(label.text._storage) release(label.font) //  label2 release(label2.text._storage) release(label2.font)</span></span></code> </pre> <br><p>  label und label2 haben gemeinsame Instanzen, die auf Heap gehostet werden: </p><br><ul><li>  Textinhalt </li><li>  und Schriftart </li></ul><br><p>  Wenn also die Struktur Links in sich selbst speichert, verdoppelt sich beim Kopieren dieser Struktur die Anzahl der Links, was sich, falls nicht erforderlich, negativ auf die "Leichtigkeit" des Programms auswirkt. </p><br><h3 id="i-snova-realnyy-primer">  Und wieder das "echte" Beispiel: </h3><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attachment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileUrl: <span class="hljs-type"><span class="hljs-type">URL</span></span> <span class="hljs-comment"><span class="hljs-comment">//   HEAP  let uuid: String //    HEAP  let mimeType: String //    HEAP  init?(fileUrl: URL, uuid: String, mimeType: String) { guard mimeType.isMimeType else { return nil } self.fileUrl = fileUrl self.uuid = uuid self.mimeType = mimeType } }</span></span></code> </pre> <br><p>  Die Probleme dieser Struktur sind, dass sie hat: </p><br><ol><li>  3 Heap-Zuordnung </li><li>  Da String eine beliebige Zeichenfolge sein kann, sind Sicherheit und Codeklarheit betroffen. </li></ol><br><p>  Gleichzeitig sind uuid und mimeType streng definierte Dinge: </p><br><p>  uuid ist eine Zeichenfolge im Format xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx <br>  mimeType ist eine Zeichenfolge im Typ- / Erweiterungsformat. </p><br><h3 id="reshenie-1">  L√∂sung </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uuid: <span class="hljs-type"><span class="hljs-type">UUID</span></span> <span class="hljs-comment"><span class="hljs-comment">// UUID  ,    Foundation</span></span></code> </pre> <br><p>  Im Fall von mimeType funktioniert enum einwandfrei: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(rawValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> rawValue { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .jpeg <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/png"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .png <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .gif <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg, png, gif }</code> </pre> <br><p>  Oder besser und einfacher: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg = <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> png = <span class="hljs-string"><span class="hljs-string">"image/png"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> gif = <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span> }</code> </pre> <br><p>  Und vergessen Sie nicht zu √§ndern: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mimeType: <span class="hljs-type"><span class="hljs-type">MimeType</span></span></code> </pre> <br><h3 id="31-method-dispatch">  3.1 Methodenversand </h3><br><ul><li>  Dies ist ein Algorithmus, der nach dem aufgerufenen Methodencode sucht </li></ul><br><p>  Bevor auf die Implementierung dieses Mechanismus eingegangen wird, sollte festgelegt werden, was eine ‚ÄûNachricht‚Äú und eine ‚ÄûMethode‚Äú in diesem Zusammenhang sind: </p><br><ul><li>  Eine Nachricht ist der Name, den wir an das Objekt senden.  Argumente k√∂nnen weiterhin zusammen mit dem Namen gesendet werden. </li></ul><br><pre> <code class="swift hljs">circle.draw(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: origin)</code> </pre> <br><p>  Die Nachricht lautet draw - der Name der Methode.  Das Empf√§ngerobjekt ist ein Kreis.  Origin ist auch ein Argument √ºbergeben. </p><br><ul><li>  Methode ist der Code, der als Antwort auf die Nachricht zur√ºckgegeben wird. </li></ul><br><p>  Dann ist Method Dispatch ein Algorithmus, der entscheidet, welche Methode einer bestimmten Nachricht gegeben werden soll. </p><br><h2 id="bolee-konkretno-o-method-dispatch-v-swift">  Genauer gesagt zum Methodenversand in Swift </h2><br><p>  Da wir von der √ºbergeordneten Klasse erben und ihre Methoden √ºberschreiben k√∂nnen, muss Swift genau wissen, welche Implementierung dieser Methode in einer bestimmten Situation aufgerufen werden muss. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"parent"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"child"</span></span>) } }</code> </pre> <br><p>  Erstellen Sie einige Instanzen und rufen Sie die me-Methode auf: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parent = <span class="hljs-type"><span class="hljs-type">Parent</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child = <span class="hljs-type"><span class="hljs-type">Child</span></span>() parent.me() <span class="hljs-comment"><span class="hljs-comment">// "parent" child.me() // "child"</span></span></code> </pre> <br><p>  Ein ziemlich offensichtliches und einfaches Beispiel.  Und was ist, wenn: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array: [<span class="hljs-type"><span class="hljs-type">Parent</span></span>] = [<span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Parent</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>()] array.forEach { $<span class="hljs-number"><span class="hljs-number">0</span></span>.me() <span class="hljs-comment"><span class="hljs-comment">// "child" "child" "parent" "child" }</span></span></code> </pre> <br><p>  Dies ist nicht so offensichtlich und erfordert Ressourcen und einen bestimmten Mechanismus, um die korrekte Implementierung der me-Methode zu bestimmen.  Ressourcen sind der Prozessor und RAM.  Ein Mechanismus ist ein Methodenversand. </p><br><p>  Mit anderen Worten, beim Methodenversand bestimmt das Programm, welche Methodenimplementierung aufgerufen werden soll. </p><br><p>  Wenn eine Methode im Code aufgerufen wird, muss ihre Implementierung bekannt sein.  Wenn sie es wei√ü <br>  Zum Zeitpunkt der Kompilierung ist dies dann Static Dispatch.  Wenn die Implementierung unmittelbar vor dem Aufruf festgelegt wird (zur Laufzeit zum Zeitpunkt der Codeausf√ºhrung), handelt es sich um Dynamic Dispatch. </p><br><h3 id="32-method-dispatch---static-dispatch">  3.2 Methodenversand - Statischer Versand </h3><br><p>  Das Optimalste, da: </p><br><ol><li>  Der Compiler wei√ü, welcher Codeblock (Methodenimplementierung) aufgerufen wird.  Dank dessen kann er diesen Code so weit wie m√∂glich optimieren und auf einen Mechanismus wie Inlining zur√ºckgreifen. </li><li>  Au√üerdem f√ºhrt das Programm zum Zeitpunkt der Codeausf√ºhrung einfach diesen dem Compiler bekannten Codeblock aus.  Es werden keine Ressourcen und Zeit aufgewendet, um die korrekte Implementierung der Methode zu bestimmen, was die Ausf√ºhrung des Programms beschleunigt. </li></ol><br><h3 id="33-method-dispatch---dynamic-dispatch">  3.3 Methodenversand - Dynamischer Versand </h3><br><p>  Nicht das Optimalste, da: </p><br><ol><li>  Die korrekte Implementierung der Methode wird zum Zeitpunkt der Programmausf√ºhrung festgelegt, was Ressourcen und Zeit erfordert </li><li>  Keine Compiler-Optimierungen kommen nicht in Frage </li></ol><br><h3 id="34-method-dispatch---inlining">  3.4 Methodenversand - Inlining </h3><br><p>  Ein Mechanismus wie Inlining wurde erw√§hnt, aber was ist das?  Betrachten Sie ein Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation } } func drawAPoint(_ param: Point) { param.draw() } let point = Point(x: 0, y: 0) drawAPoint(point)</span></span></code> </pre> <br><ul><li>  Die point.draw () -Methode und die drawAPoint-Funktion werden √ºber Static Dispatch verarbeitet, da es keine Schwierigkeiten gibt, die richtige Implementierung f√ºr den Compiler zu ermitteln (da keine Vererbung vorliegt und eine Neudefinition nicht m√∂glich ist). </li><li>  Da der Compiler wei√ü, was zu tun ist, kann er dies optimieren.  Optimiert zun√§chst drawAPoint und ersetzt einfach den Funktionsaufruf durch seinen Code: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) point.draw()</code> </pre> <br><ul><li>  optimiert dann point.draw, da die Implementierung dieser Methode auch bekannt ist: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation</span></span></code> </pre> <br><p>  Wir haben einen Punkt erstellt, den Code der Zeichenmethode ausgef√ºhrt - der Compiler hat diese Funktionen einfach durch den erforderlichen Code ersetzt, anstatt sie aufzurufen.  In Dynamic Dispatch ist dies etwas komplizierter. </p><br><h3 id="35-method-dispatch---inheritance-based-polymorphism">  3.5 Methodenversand - Vererbungsbasierter Polymorphismus </h3><br><p>  Warum brauche ich Dynamic Dispatch?  Ohne sie ist es unm√∂glich, Methoden zu definieren, die von untergeordneten Klassen √ºberschrieben werden.  Polymorphismus w√§re nicht m√∂glich.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { d.draw() }</code> </pre> <br><ul><li>  Drawables-Array kann Punkt und Linie enthalten </li><li>  Intuitiv ist hier kein statischer Versand m√∂glich.  d in der for-Schleife kann Line oder Point sein.  Der Compiler kann dies nicht bestimmen, und jeder Typ hat seine eigene Implementierung von draw </li></ul><br><p>  Wie funktioniert dann Dynamic Dispatch?  Jedes Objekt hat ein Typfeld.  Punkt (...). Typ ist gleich Punkt und Linie (...). Typ ist gleich Linie.  Ebenfalls irgendwo im (statischen) Speicher des Programms befindet sich eine Tabelle (virtuelle Tabelle), in der f√ºr jeden Typ eine Liste mit seinen Methodenimplementierungen vorhanden ist. </p><br><p>  In Objective-C wird das Typfeld als isa-Feld bezeichnet.  Es ist auf jedem Objective-C-Objekt (NSObject) vorhanden. </p><br><p>  Die Klassenmethode wird in einer virtuellen Tabelle gespeichert und hat keine Ahnung von sich selbst.  Um self innerhalb dieser Methode zu verwenden, muss es dort √ºbergeben werden (self). </p><br><p>  Daher √§ndert der Compiler diesen Code in: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Point)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Line)</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { vtable[d.type].draw(d) }</code> </pre> <br><p>  Zum Zeitpunkt der Codeausf√ºhrung m√ºssen Sie in die virtuelle Tabelle schauen, dort die Klasse d finden, die Zeichenmethode aus der resultierenden Liste nehmen und ihr ein Objekt vom Typ d als self √ºbergeben.  Dies ist eine anst√§ndige Arbeit f√ºr einen einfachen Methodenaufruf, aber es muss sichergestellt werden, dass der Polymorphismus funktioniert.  √Ñhnliche Mechanismen werden in jeder OOP-Sprache verwendet. </p><br><h2 id="method-dispatch---itog">  Methodenversand - Zusammenfassung </h2><br><ul><li>  Klassenmethoden werden standardm√§√üig √ºber Dynamic Dispatch verarbeitet.  Es m√ºssen jedoch nicht alle Klassenmethoden √ºber Dynamic Dispatch verarbeitet werden.  Wenn die Methode nicht √ºberschrieben wird, k√∂nnen Sie sie mit dem letzten Schl√ºsselwort √ºberschreiben. Der Compiler wei√ü dann, dass diese Methode nicht √ºberschrieben werden kann, und verarbeitet sie √ºber Static Dispatch </li><li>  Nicht-Klassen-Methoden k√∂nnen nicht √ºberschrieben werden (da struct und enum die Vererbung nicht unterst√ºtzen) und werden √ºber Static Dispatch verarbeitet </li></ul><br><h2 id="problemy-oop---itog">  OOP-Probleme - Zusammenfassung </h2><br><p>  Es ist notwendig, auf Kleinigkeiten zu achten wie: </p><br><ol><li>  Beim Erstellen einer Instanz: Wo befindet sie sich? </li><li>  Wenn Sie mit dieser Instanz arbeiten: Wie funktioniert die Linkz√§hlung? </li><li>  Beim Aufruf einer Methode: Wie wird sie verarbeitet? </li></ol><br><p>  Wenn wir f√ºr Dynamik bezahlen, ohne sie zu realisieren und ohne sie zu ben√∂tigen, wirkt sich dies negativ auf das implementierte Programm aus. </p><br><p>  Polymorphismus ist eine sehr wichtige und n√ºtzliche Sache.  Derzeit ist nur bekannt, dass der Polymorphismus in Swift in direktem Zusammenhang mit Klassen und Referenztypen steht.  Wir wiederum sagen, dass der Unterricht langsam und schwer ist und die Struktur einfach und leicht ist.  Ist Polymorphismus durch Strukturen m√∂glich?  Eine protokollorientierte Programmierung kann eine Antwort auf diese Frage geben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473798/">https://habr.com/ru/post/de473798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473786/index.html">Die Registrierung f√ºr den Hackathon in Riga endet. Preis - Kurzzeittraining bei PhysTech</a></li>
<li><a href="../de473788/index.html">Mikroproteine ‚Äã‚Äãentdecken unbekannte Aspekte der modernen Biologie</a></li>
<li><a href="../de473790/index.html">Splines in 3D-Grafiken, die am meisten automatisierte Option</a></li>
<li><a href="../de473794/index.html">Mobile Phishing - Endlose Bedrohungen</a></li>
<li><a href="../de473796/index.html">Optischer HDMI Extender. 300 Meter</a></li>
<li><a href="../de473800/index.html">Bio-Radar, Pappdrohne und Flugwurst - Nikita Kalinovsky √ºber gute und schlechte Suchtechnologien</a></li>
<li><a href="../de473802/index.html">Alain Bombar - Fall nach Triumph</a></li>
<li><a href="../de473804/index.html">Was ist das Gehalt von Junior QA?</a></li>
<li><a href="../de473806/index.html">Dies ist die Art von Internet, die wir wollen: Wie Social Media zu einer t√∂dlichen Waffe wurde</a></li>
<li><a href="../de473812/index.html">Die Zusammenfassung der Ereignisse f√ºr HR-Experten im Bereich IT im November 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>