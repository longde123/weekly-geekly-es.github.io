<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐶 🚼 👩🏼‍🤝‍👨🏽 Protokollorientierte Programmierung. Teil 1 ↗️ 🐜 🏯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schauen wir uns das Thema protokollorientierte Programmierung genauer an. Der Einfachheit halber wurde das Material in drei Teile geteilt. 


 Dieses ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokollorientierte Programmierung. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473798/"><p>  Schauen wir uns das Thema protokollorientierte Programmierung genauer an.  Der Einfachheit halber wurde das Material in drei Teile geteilt. </p><br><p>  Dieses Material ist eine Kommentarübersetzung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Präsentation der WWDC 2016</a> .  Entgegen der allgemeinen Überzeugung, dass Dinge "unter der Haube" dort bleiben sollten, ist es manchmal äußerst nützlich, herauszufinden, was dort passiert.  Dies hilft, den Artikel korrekt und für den vorgesehenen Zweck zu verwenden. </p><a name="habracut"></a><br><p>  In diesem Teil werden wichtige Probleme der objektorientierten Programmierung und deren Lösung durch POP behandelt.  Alles wird in den Realitäten der Swift-Sprache berücksichtigt, die Details werden als "Haube" der Protokolle betrachtet. </p><br><h2 id="problemy-oop-i-zachem-nam-nuzhno-pop">  OOP Probleme und warum brauchen wir POP </h2><br><p>  Es ist bekannt, dass es in OOP eine Reihe von Schwachstellen gibt, die die Programmausführung „überlasten“ können.  Betrachten Sie die explizitesten und häufigsten: </p><br><ol><li>  Zuordnung: Stapel oder Haufen? </li><li>  Referenzzählung: mehr oder weniger? </li><li>  Methodenversand: statisch oder dynamisch? </li></ol><br><h3 id="11-allocation---stack">  1.1 Zuordnung - Stapel </h3><br><p>  Stack ist eine ziemlich einfache und primitive Datenstruktur.  Wir können oben auf den Stapel legen (drücken), wir können von oben auf den Stapel nehmen (Pop).  Die Einfachheit ist, dass dies alles ist, was wir damit machen können. </p><br><p>  Nehmen wir der Einfachheit halber an, dass jeder Stapel eine Variable (Stapelzeiger) hat.  Es wird verwendet, um den oberen Rand des Stapels zu verfolgen und eine Ganzzahl (Integer) zu speichern.  Daraus folgt, dass die Geschwindigkeit der Operationen mit dem Stapel gleich der Geschwindigkeit ist, mit der Integer in diese Variable umgeschrieben wird. </p><br><p>  Drücken Sie - setzen Sie auf die Oberseite des Stapels, erhöhen Sie den Stapelzeiger; </p><br><p>  pop - Stapelzeiger reduzieren. </p><br><h3 id="tipy-znacheniy">  Werttypen </h3><br><p>  Betrachten wir die Prinzipien der Stapeloperation in Swift unter Verwendung von Strukturen (struct). </p><br><p>  In Swift sind Werttypen Strukturen (struct) und Enumerationen (enum), und Referenztypen sind Klassen (class) und Funktionen / Verschlüsse (func).  Werttypen werden auf dem Stapel gespeichert, Referenztypen werden auf dem Heap gespeichert. </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/tq/vj/8y/tqvj8yfygyvbneaqfwwuiig8on0.png"></p><br><ol><li>  Wir platzieren die erste Struktur auf Stack </li><li>  Kopieren Sie den Inhalt der ersten Struktur </li><li>  Ändern Sie den Speicher der zweiten Struktur (die erste bleibt erhalten) </li><li>  Ende der Nutzung.  Freier Speicher </li></ol><br><h3 id="12-allocation---heap">  1.2 Zuordnung - Haufen </h3><br><p>  Heap ist eine baumartige Datenstruktur.  Das Thema der Heap-Implementierung ist hier nicht betroffen, aber wir werden versuchen, es mit dem Stack zu vergleichen. </p><br><p>  Warum lohnt es sich, wenn möglich, Stack anstelle von Heap zu verwenden?  Deshalb: </p><br><ul><li>  Referenzzählung </li><li>  freie Speicherverwaltung und Suche nach Zuordnung </li><li>  Speicher für Freigabe neu schreiben </li></ul><br><p>  All dies ist nur ein kleiner Teil dessen, was Heap zum Funktionieren bringt und es im Vergleich zu Stack deutlich belastet. </p><br><p>  Wenn wir beispielsweise freien Speicher auf dem Stapel benötigen, nehmen wir einfach den Wert des Stapelzeigers und erhöhen ihn (weil alles über dem Stapelzeiger im Stapel freier Speicher ist) - O (1) ist eine Operation, die zeitlich konstant ist. </p><br><p>  Wenn wir freien Speicher auf Heap benötigen, beginnen wir mit dem entsprechenden Suchalgorithmus in der Datenbaumstruktur danach zu suchen. Im besten Fall haben wir eine O (logn) -Operation, die zeitlich nicht konstant ist und von bestimmten Implementierungen abhängt. <br>  Tatsächlich ist Heap viel komplizierter: Seine Arbeit wird von einer Vielzahl anderer Mechanismen bereitgestellt, die im Darm von Betriebssystemen leben. </p><br><p>  Es ist auch erwähnenswert, dass die Verwendung von Heap im Multithreading-Modus die Situation erheblich verschärft, da die Synchronisation der gemeinsam genutzten Ressource (Speicher) für verschiedene Threads sichergestellt werden muss.  Dies wird durch die Verwendung von Sperren (Semaphoren, Spinlocks usw.) erreicht. </p><br><h3 id="ssylochnye-tipy">  Referenztypen </h3><br><p>  Schauen wir uns an, wie Heap in Swift mithilfe von Klassen funktioniert. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/o4/ct/y3/o4cty3n_4gizx4o0-amtg2f5tqm.png"></p><br><p>  1. Legen Sie den Klassenkörper auf Heap.  Platzieren Sie den Zeiger auf diesen Körper auf dem Stapel. </p><br><ol><li>  Kopieren Sie den Zeiger, der sich auf den Hauptteil der Klasse bezieht </li><li>  Wir verändern einen Körper einer Klasse </li><li>  Ende der Nutzung.  Freier Speicher </li></ol><br><h3 id="13-allocation---nebolshoy-i-realnyy-primer">  1.3 Zuordnung - Ein kleines und "echtes" Beispiel </h3><br><p>  In einigen Situationen vereinfacht die Auswahl von Stapel nicht nur die Speicherbehandlung, sondern verbessert auch die Codequalität.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> red, green, blue } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, tail, bubble } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBalloon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color: Color, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation: Orientation, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tail: Tail)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIImage</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-string"><span class="hljs-string">"\(color):\(orientation):\(tail)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = cache[key] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image } ... }</code> </pre> <br><p>  Wenn das Cache-Wörterbuch einen Wert mit dem Schlüssel hat, gibt die Funktion einfach das zwischengespeicherte UIImage zurück. </p><br><h3 id="problemy-etogo-koda">  Die Probleme dieses Codes sind: </h3><br><p>  Es ist keine gute Praxis, String als Schlüssel im Cache zu verwenden, da String am Ende "sich als alles herausstellen kann". </p><br><p>  String ist eine Copy-on-Write-Struktur. Um ihre Dynamik zu implementieren, werden alle Zeichen auf dem Heap gespeichert.  Daher ist String eine Struktur und wird im Stapel gespeichert, speichert jedoch den gesamten Inhalt auf dem Heap. </p><br><p>  Dies ist erforderlich, um die Zeile ändern zu können (einen Teil der Zeile entfernen, dieser Zeile eine neue Zeile hinzufügen).  Wenn alle Zeichen der Zeichenfolge auf dem Stapel gespeichert wären, wären solche Manipulationen unmöglich.  In C sind Zeichenfolgen beispielsweise statisch. Dies bedeutet, dass die Größe einer Zeichenfolge zur Laufzeit nicht erhöht werden kann, da der gesamte Inhalt auf dem Stapel gespeichert ist.  Klicken Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , um die Zeilen in Swift zu kopieren und detaillierter zu analysieren. </p><br><h3 id="reshenie">  Lösung: </h3><br><ol><li><p>  Verwenden Sie die hier ganz offensichtliche Struktur anstelle der Zeichenfolge: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color: <span class="hljs-type"><span class="hljs-type">Color</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation: <span class="hljs-type"><span class="hljs-type">Orientation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tail: <span class="hljs-type"><span class="hljs-type">Tail</span></span> }</code> </pre> <br></li><li><p>  Ändern Sie das Wörterbuch in: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">Attributes</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = []</code> </pre> <br></li><li><p>  String loswerden </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-type"><span class="hljs-type">Attributes</span></span>(color: color, orientation: orientation, tail: tail)</code> </pre> <br></li></ol><br><p>  In der Attributstruktur werden alle Eigenschaften im Stapel gespeichert, da die Aufzählung im Stapel gespeichert ist.  Dies bedeutet, dass Heap hier nicht implizit verwendet wird und jetzt die Schlüssel für das Cache-Wörterbuch sehr genau definiert sind, was die Sicherheit und Klarheit dieses Codes erhöht.  Wir haben auch die implizite Verwendung von Heap beseitigt. </p><br><p>  <strong>Fazit:</strong> Stack ist viel einfacher und schneller als Heap - die Wahl für die meisten Situationen liegt auf der Hand. </p><br><h3 id="2-podschet-ssylok">  2. Referenzzählung </h3><br><p>  Wofür? </p><br><p>  Swift sollte wissen, wann es möglich ist, ein Stück Speicher auf dem Heap freizugeben, das beispielsweise von einer Instanz einer Klasse oder Funktion belegt wird.  Dies wird durch einen Linkzählmechanismus implementiert. Jede auf Heap gehostete Instanz (Klasse oder Funktion) verfügt über eine Variable, in der die Anzahl der Links gespeichert ist.  Wenn keine Links zu einer Instanz vorhanden sind, gibt Swift einen dafür zugewiesenen Speicher frei. </p><br><p>  Es ist zu beachten, dass für eine „qualitativ hochwertige“ Implementierung dieses Mechanismus viel mehr Ressourcen benötigt werden als zum Erhöhen und Verringern des Stapelzeigers.  Dies liegt an der Tatsache, dass der Wert der Anzahl der Links von verschiedenen Threads aus zunehmen kann (weil Sie auf eine Klasse oder Funktion von verschiedenen Threads verweisen können).  Vergessen Sie auch nicht, die Synchronisierung einer gemeinsam genutzten Ressource (variable Anzahl von Links) für verschiedene Threads (Spinlocks, Semaphoren usw.) sicherzustellen. </p><br><p>  Stapel: freien Speicher finden und verwendeten Speicher freigeben - Stapelzeigeroperation </p><br><p>  Heap: Suche nach freiem Speicher und Freigabe des verwendeten Speichers - Baumsuchalgorithmus und Referenzzählung. </p><br><p>  In der Attributstruktur werden alle Eigenschaften im Stapel gespeichert, da die Aufzählung im Stapel gespeichert ist.  Dies bedeutet, dass Heap hier nicht implizit verwendet wird und jetzt die Schlüssel für das Cache-Wörterbuch sehr genau definiert sind, was die Sicherheit und Klarheit dieses Codes erhöht.  Wir haben auch die implizite Verwendung von Heap beseitigt. </p><br><h3 id="psevdokod">  Pseudocode </h3><br><p>  Betrachten Sie einen kleinen Pseudocode, um zu demonstrieren, wie die Linkzählung funktioniert: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(...) { ... <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point2 = point1 retain(point2) <span class="hljs-comment"><span class="hljs-comment">// retain() -  refCount  1    point2.x = 5 //  `point1` release(point1) // release() -  refCount  1 //  `point2` release(point2)</span></span></code> </pre> <br><h3 id="struct">  Struct </h3><br><p>  Bei der Arbeit mit Strukturen ist ein Mechanismus wie die Referenzzählung einfach nicht erforderlich: </p><br><ol><li>  Struktur nicht auf Heap gespeichert </li><li>  Struktur - bei Zuordnung kopiert, daher keine Referenzen </li></ol><br><h3 id="kopirovanie-ssylok">  Links kopieren </h3><br><p>  Auch hier werden struct und alle anderen Werttypen in Swift bei der Zuweisung kopiert.  Wenn die Struktur Links in sich selbst speichert, werden sie auch kopiert: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> font: <span class="hljs-type"><span class="hljs-type">UIFont</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { ... text.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> font.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label = <span class="hljs-type"><span class="hljs-type">Label</span></span>(text: <span class="hljs-string"><span class="hljs-string">"Hi"</span></span>, font: font) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label2 = label retain(label2.text._storage) <span class="hljs-comment"><span class="hljs-comment">//    `String`       Heap retain(label2.font) //  label release(label.text._storage) release(label.font) //  label2 release(label2.text._storage) release(label2.font)</span></span></code> </pre> <br><p>  label und label2 haben gemeinsame Instanzen, die auf Heap gehostet werden: </p><br><ul><li>  Textinhalt </li><li>  und Schriftart </li></ul><br><p>  Wenn also die Struktur Links in sich selbst speichert, verdoppelt sich beim Kopieren dieser Struktur die Anzahl der Links, was sich, falls nicht erforderlich, negativ auf die "Leichtigkeit" des Programms auswirkt. </p><br><h3 id="i-snova-realnyy-primer">  Und wieder das "echte" Beispiel: </h3><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attachment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileUrl: <span class="hljs-type"><span class="hljs-type">URL</span></span> <span class="hljs-comment"><span class="hljs-comment">//   HEAP  let uuid: String //    HEAP  let mimeType: String //    HEAP  init?(fileUrl: URL, uuid: String, mimeType: String) { guard mimeType.isMimeType else { return nil } self.fileUrl = fileUrl self.uuid = uuid self.mimeType = mimeType } }</span></span></code> </pre> <br><p>  Die Probleme dieser Struktur sind, dass sie hat: </p><br><ol><li>  3 Heap-Zuordnung </li><li>  Da String eine beliebige Zeichenfolge sein kann, sind Sicherheit und Codeklarheit betroffen. </li></ol><br><p>  Gleichzeitig sind uuid und mimeType streng definierte Dinge: </p><br><p>  uuid ist eine Zeichenfolge im Format xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx <br>  mimeType ist eine Zeichenfolge im Typ- / Erweiterungsformat. </p><br><h3 id="reshenie-1">  Lösung </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uuid: <span class="hljs-type"><span class="hljs-type">UUID</span></span> <span class="hljs-comment"><span class="hljs-comment">// UUID  ,    Foundation</span></span></code> </pre> <br><p>  Im Fall von mimeType funktioniert enum einwandfrei: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(rawValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> rawValue { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .jpeg <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/png"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .png <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .gif <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg, png, gif }</code> </pre> <br><p>  Oder besser und einfacher: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg = <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> png = <span class="hljs-string"><span class="hljs-string">"image/png"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> gif = <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span> }</code> </pre> <br><p>  Und vergessen Sie nicht zu ändern: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mimeType: <span class="hljs-type"><span class="hljs-type">MimeType</span></span></code> </pre> <br><h3 id="31-method-dispatch">  3.1 Methodenversand </h3><br><ul><li>  Dies ist ein Algorithmus, der nach dem aufgerufenen Methodencode sucht </li></ul><br><p>  Bevor auf die Implementierung dieses Mechanismus eingegangen wird, sollte festgelegt werden, was eine „Nachricht“ und eine „Methode“ in diesem Zusammenhang sind: </p><br><ul><li>  Eine Nachricht ist der Name, den wir an das Objekt senden.  Argumente können weiterhin zusammen mit dem Namen gesendet werden. </li></ul><br><pre> <code class="swift hljs">circle.draw(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: origin)</code> </pre> <br><p>  Die Nachricht lautet draw - der Name der Methode.  Das Empfängerobjekt ist ein Kreis.  Origin ist auch ein Argument übergeben. </p><br><ul><li>  Methode ist der Code, der als Antwort auf die Nachricht zurückgegeben wird. </li></ul><br><p>  Dann ist Method Dispatch ein Algorithmus, der entscheidet, welche Methode einer bestimmten Nachricht gegeben werden soll. </p><br><h2 id="bolee-konkretno-o-method-dispatch-v-swift">  Genauer gesagt zum Methodenversand in Swift </h2><br><p>  Da wir von der übergeordneten Klasse erben und ihre Methoden überschreiben können, muss Swift genau wissen, welche Implementierung dieser Methode in einer bestimmten Situation aufgerufen werden muss. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"parent"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"child"</span></span>) } }</code> </pre> <br><p>  Erstellen Sie einige Instanzen und rufen Sie die me-Methode auf: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parent = <span class="hljs-type"><span class="hljs-type">Parent</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child = <span class="hljs-type"><span class="hljs-type">Child</span></span>() parent.me() <span class="hljs-comment"><span class="hljs-comment">// "parent" child.me() // "child"</span></span></code> </pre> <br><p>  Ein ziemlich offensichtliches und einfaches Beispiel.  Und was ist, wenn: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array: [<span class="hljs-type"><span class="hljs-type">Parent</span></span>] = [<span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Parent</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>()] array.forEach { $<span class="hljs-number"><span class="hljs-number">0</span></span>.me() <span class="hljs-comment"><span class="hljs-comment">// "child" "child" "parent" "child" }</span></span></code> </pre> <br><p>  Dies ist nicht so offensichtlich und erfordert Ressourcen und einen bestimmten Mechanismus, um die korrekte Implementierung der me-Methode zu bestimmen.  Ressourcen sind der Prozessor und RAM.  Ein Mechanismus ist ein Methodenversand. </p><br><p>  Mit anderen Worten, beim Methodenversand bestimmt das Programm, welche Methodenimplementierung aufgerufen werden soll. </p><br><p>  Wenn eine Methode im Code aufgerufen wird, muss ihre Implementierung bekannt sein.  Wenn sie es weiß <br>  Zum Zeitpunkt der Kompilierung ist dies dann Static Dispatch.  Wenn die Implementierung unmittelbar vor dem Aufruf festgelegt wird (zur Laufzeit zum Zeitpunkt der Codeausführung), handelt es sich um Dynamic Dispatch. </p><br><h3 id="32-method-dispatch---static-dispatch">  3.2 Methodenversand - Statischer Versand </h3><br><p>  Das Optimalste, da: </p><br><ol><li>  Der Compiler weiß, welcher Codeblock (Methodenimplementierung) aufgerufen wird.  Dank dessen kann er diesen Code so weit wie möglich optimieren und auf einen Mechanismus wie Inlining zurückgreifen. </li><li>  Außerdem führt das Programm zum Zeitpunkt der Codeausführung einfach diesen dem Compiler bekannten Codeblock aus.  Es werden keine Ressourcen und Zeit aufgewendet, um die korrekte Implementierung der Methode zu bestimmen, was die Ausführung des Programms beschleunigt. </li></ol><br><h3 id="33-method-dispatch---dynamic-dispatch">  3.3 Methodenversand - Dynamischer Versand </h3><br><p>  Nicht das Optimalste, da: </p><br><ol><li>  Die korrekte Implementierung der Methode wird zum Zeitpunkt der Programmausführung festgelegt, was Ressourcen und Zeit erfordert </li><li>  Keine Compiler-Optimierungen kommen nicht in Frage </li></ol><br><h3 id="34-method-dispatch---inlining">  3.4 Methodenversand - Inlining </h3><br><p>  Ein Mechanismus wie Inlining wurde erwähnt, aber was ist das?  Betrachten Sie ein Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation } } func drawAPoint(_ param: Point) { param.draw() } let point = Point(x: 0, y: 0) drawAPoint(point)</span></span></code> </pre> <br><ul><li>  Die point.draw () -Methode und die drawAPoint-Funktion werden über Static Dispatch verarbeitet, da es keine Schwierigkeiten gibt, die richtige Implementierung für den Compiler zu ermitteln (da keine Vererbung vorliegt und eine Neudefinition nicht möglich ist). </li><li>  Da der Compiler weiß, was zu tun ist, kann er dies optimieren.  Optimiert zunächst drawAPoint und ersetzt einfach den Funktionsaufruf durch seinen Code: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) point.draw()</code> </pre> <br><ul><li>  optimiert dann point.draw, da die Implementierung dieser Methode auch bekannt ist: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation</span></span></code> </pre> <br><p>  Wir haben einen Punkt erstellt, den Code der Zeichenmethode ausgeführt - der Compiler hat diese Funktionen einfach durch den erforderlichen Code ersetzt, anstatt sie aufzurufen.  In Dynamic Dispatch ist dies etwas komplizierter. </p><br><h3 id="35-method-dispatch---inheritance-based-polymorphism">  3.5 Methodenversand - Vererbungsbasierter Polymorphismus </h3><br><p>  Warum brauche ich Dynamic Dispatch?  Ohne sie ist es unmöglich, Methoden zu definieren, die von untergeordneten Klassen überschrieben werden.  Polymorphismus wäre nicht möglich.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { d.draw() }</code> </pre> <br><ul><li>  Drawables-Array kann Punkt und Linie enthalten </li><li>  Intuitiv ist hier kein statischer Versand möglich.  d in der for-Schleife kann Line oder Point sein.  Der Compiler kann dies nicht bestimmen, und jeder Typ hat seine eigene Implementierung von draw </li></ul><br><p>  Wie funktioniert dann Dynamic Dispatch?  Jedes Objekt hat ein Typfeld.  Punkt (...). Typ ist gleich Punkt und Linie (...). Typ ist gleich Linie.  Ebenfalls irgendwo im (statischen) Speicher des Programms befindet sich eine Tabelle (virtuelle Tabelle), in der für jeden Typ eine Liste mit seinen Methodenimplementierungen vorhanden ist. </p><br><p>  In Objective-C wird das Typfeld als isa-Feld bezeichnet.  Es ist auf jedem Objective-C-Objekt (NSObject) vorhanden. </p><br><p>  Die Klassenmethode wird in einer virtuellen Tabelle gespeichert und hat keine Ahnung von sich selbst.  Um self innerhalb dieser Methode zu verwenden, muss es dort übergeben werden (self). </p><br><p>  Daher ändert der Compiler diesen Code in: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Point)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Line)</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { vtable[d.type].draw(d) }</code> </pre> <br><p>  Zum Zeitpunkt der Codeausführung müssen Sie in die virtuelle Tabelle schauen, dort die Klasse d finden, die Zeichenmethode aus der resultierenden Liste nehmen und ihr ein Objekt vom Typ d als self übergeben.  Dies ist eine anständige Arbeit für einen einfachen Methodenaufruf, aber es muss sichergestellt werden, dass der Polymorphismus funktioniert.  Ähnliche Mechanismen werden in jeder OOP-Sprache verwendet. </p><br><h2 id="method-dispatch---itog">  Methodenversand - Zusammenfassung </h2><br><ul><li>  Klassenmethoden werden standardmäßig über Dynamic Dispatch verarbeitet.  Es müssen jedoch nicht alle Klassenmethoden über Dynamic Dispatch verarbeitet werden.  Wenn die Methode nicht überschrieben wird, können Sie sie mit dem letzten Schlüsselwort überschreiben. Der Compiler weiß dann, dass diese Methode nicht überschrieben werden kann, und verarbeitet sie über Static Dispatch </li><li>  Nicht-Klassen-Methoden können nicht überschrieben werden (da struct und enum die Vererbung nicht unterstützen) und werden über Static Dispatch verarbeitet </li></ul><br><h2 id="problemy-oop---itog">  OOP-Probleme - Zusammenfassung </h2><br><p>  Es ist notwendig, auf Kleinigkeiten zu achten wie: </p><br><ol><li>  Beim Erstellen einer Instanz: Wo befindet sie sich? </li><li>  Wenn Sie mit dieser Instanz arbeiten: Wie funktioniert die Linkzählung? </li><li>  Beim Aufruf einer Methode: Wie wird sie verarbeitet? </li></ol><br><p>  Wenn wir für Dynamik bezahlen, ohne sie zu realisieren und ohne sie zu benötigen, wirkt sich dies negativ auf das implementierte Programm aus. </p><br><p>  Polymorphismus ist eine sehr wichtige und nützliche Sache.  Derzeit ist nur bekannt, dass der Polymorphismus in Swift in direktem Zusammenhang mit Klassen und Referenztypen steht.  Wir wiederum sagen, dass der Unterricht langsam und schwer ist und die Struktur einfach und leicht ist.  Ist Polymorphismus durch Strukturen möglich?  Eine protokollorientierte Programmierung kann eine Antwort auf diese Frage geben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473798/">https://habr.com/ru/post/de473798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473786/index.html">Die Registrierung für den Hackathon in Riga endet. Preis - Kurzzeittraining bei PhysTech</a></li>
<li><a href="../de473788/index.html">Mikroproteine ​​entdecken unbekannte Aspekte der modernen Biologie</a></li>
<li><a href="../de473790/index.html">Splines in 3D-Grafiken, die am meisten automatisierte Option</a></li>
<li><a href="../de473794/index.html">Mobile Phishing - Endlose Bedrohungen</a></li>
<li><a href="../de473796/index.html">Optischer HDMI Extender. 300 Meter</a></li>
<li><a href="../de473800/index.html">Bio-Radar, Pappdrohne und Flugwurst - Nikita Kalinovsky über gute und schlechte Suchtechnologien</a></li>
<li><a href="../de473802/index.html">Alain Bombar - Fall nach Triumph</a></li>
<li><a href="../de473804/index.html">Was ist das Gehalt von Junior QA?</a></li>
<li><a href="../de473806/index.html">Dies ist die Art von Internet, die wir wollen: Wie Social Media zu einer tödlichen Waffe wurde</a></li>
<li><a href="../de473812/index.html">Die Zusammenfassung der Ereignisse für HR-Experten im Bereich IT im November 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>