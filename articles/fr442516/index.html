<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçö üë®üèæ‚Äçü§ù‚Äçüë®üèº üìÖ Pandas Guide to Big Data Analysis üë®üèø‚ÄçüöÄ ü§ôüèΩ ü§∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque vous utilisez la biblioth√®que pandas pour analyser de petits ensembles de donn√©es, dont la taille ne d√©passe pas 100 m√©gaoctets, les performan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pandas Guide to Big Data Analysis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/"> Lorsque vous utilisez la biblioth√®que pandas pour analyser de petits ensembles de donn√©es, dont la taille ne d√©passe pas 100 m√©gaoctets, les performances deviennent rarement un probl√®me.  Mais en ce qui concerne l'√©tude des ensembles de donn√©es, dont la taille peut atteindre plusieurs gigaoctets, les probl√®mes de performances peuvent entra√Æner une augmentation significative de la dur√©e de l'analyse des donn√©es et peuvent m√™me entra√Æner l'impossibilit√© d'effectuer une analyse en raison d'un manque de m√©moire. <br><br>  Alors que des outils comme Spark peuvent traiter efficacement des ensembles de donn√©es volumineux (de centaines de gigaoctets √† plusieurs t√©raoctets), afin d'utiliser pleinement leurs capacit√©s, vous avez g√©n√©ralement besoin d'un mat√©riel assez puissant et co√ªteux.  Et, par rapport aux pandas, ils ne diff√®rent pas par de riches ensembles d'outils pour le nettoyage, la recherche et l'analyse des donn√©es de haute qualit√©.  Pour les ensembles de donn√©es de taille moyenne, il est pr√©f√©rable d'essayer d'utiliser les pandas plus efficacement, plut√¥t que de passer √† d'autres outils. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br>  Dans l'article, dont nous publions la traduction aujourd'hui, nous parlerons des particularit√©s du travail avec la m√©moire lors de l'utilisation de pandas, et comment r√©duire simplement la consommation de m√©moire de pr√®s de 90% en s√©lectionnant simplement les types de donn√©es appropri√©s stock√©s dans les colonnes des structures de donn√©es de table du <code>DataFrame</code> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Travailler avec des donn√©es sur des jeux de baseball</font> </h2><br>  Nous travaillerons avec des donn√©es sur les matchs de baseball de la Major League collect√©es sur 130 ans et extraites de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Retrosheet</a> . <br><br>  Initialement, ces donn√©es √©taient pr√©sent√©es sous la forme de 127 fichiers CSV, mais nous les avons combin√©es en un seul ensemble de donn√©es √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">csvkit</a> et ajout√©, comme premi√®re ligne du tableau r√©sultant, une ligne avec les noms des colonnes.  Si vous le souhaitez, vous pouvez t√©l√©charger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre version de</a> ces donn√©es et l'exp√©rimenter en lisant l'article. <br><br>  Commen√ßons par importer un jeu de donn√©es et jetons un ≈ìil √† ses cinq premi√®res lignes.  Vous pouvez les trouver dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> tableau, sur le <code>   </code> feuille de <code>   </code> . <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br>  Vous trouverez ci-dessous des informations sur les colonnes les plus importantes du tableau contenant ces donn√©es.  Si vous souhaitez lire les explications de toutes les colonnes, vous trouverez ici un dictionnaire de donn√©es pour l'ensemble des donn√©es. <br><br><ul><li>  <code>date</code> - Date de la partie. </li><li>  <code>v_name</code> - Le nom de l'√©quipe invit√©e. </li><li>  <code>v_league</code> - Ligue de l'√©quipe visiteuse. </li><li>  <code>h_name</code> - Le nom de l'√©quipe locale. </li><li>  <code>h_league</code> - La ligue de l'√©quipe √† domicile. </li><li>  <code>v_score</code> - Points de l'√©quipe √† l'ext√©rieur. </li><li>  <code>h_score</code> - Points de l'√©quipe √† domicile. </li><li>  <code>v_line_score</code> - Un r√©sum√© des points de l'√©quipe invit√©e, par exemple - <code>010000(10)00</code> . </li><li>  <code>h_line_score</code> - Un r√©sum√© des points de l'√©quipe √† domicile, par exemple - <code>010000(10)0X</code> . </li><li>  <code>park_id</code> - L'identifiant du champ sur lequel le jeu a √©t√© jou√©. </li><li>  <code>attendance</code> - Le nombre de t√©l√©spectateurs. </li></ul><br>  Afin de trouver des informations g√©n√©rales sur l'objet <code>DataFrame</code> , vous pouvez utiliser la m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DataFrame.info ()</a> .  Gr√¢ce √† cette m√©thode, vous pouvez en apprendre davantage sur la taille d'un objet, sur les types de donn√©es et sur l'utilisation de la m√©moire. <br><br>  Par d√©faut, les pandas, pour gagner du temps, <code>DataFrame</code> informations approximatives sur l'utilisation de la m√©moire d'un <code>DataFrame</code> .  Nous souhaitons des informations pr√©cises, nous allons donc d√©finir le param√®tre <code>memory_usage</code> sur <code>'deep'</code> . <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br>  Voici les informations que nous avons r√©ussi √† obtenir: <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br>  Il s'est av√©r√© que nous avons 171 907 lignes et 161 colonnes.  La biblioth√®que pandas a d√©tect√© automatiquement les types de donn√©es.  Il y a 83 colonnes avec des donn√©es num√©riques et 78 colonnes avec des objets.  Les colonnes d'objets sont utilis√©es pour stocker des donn√©es de cha√Æne et dans les cas o√π la colonne contient des donn√©es de diff√©rents types. <br><br>  Maintenant, afin de mieux comprendre comment vous pouvez optimiser l'utilisation de la m√©moire avec ce <code>DataFrame</code> , parlons de la fa√ßon dont les pandas stockent les donn√©es en m√©moire. <br><br><h2>  <font color="#3AC1EF">Vue interne d'un DataFrame</font> </h2><br>  √Ä l'int√©rieur des pandas, les colonnes de donn√©es sont regroup√©es en blocs avec des valeurs du m√™me type.  Voici un exemple de la fa√ßon dont les 12 premi√®res colonnes d'un <code>DataFrame</code> sont stock√©es dans des pandas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">Repr√©sentation interne de diff√©rents types de donn√©es dans les pandas</font></i> <br><br>  Vous pouvez remarquer que les blocs ne stockent pas les informations de nom de colonne.  Cela est d√ª au fait que les blocs sont optimis√©s pour stocker les valeurs disponibles dans les cellules du tableau de l'objet <code>DataFrame</code> .  La classe <code>BlockManager</code> est charg√©e de stocker des informations sur la correspondance entre les index de ligne et de colonne de l'ensemble de donn√©es et ce qui est stock√© dans des blocs du m√™me type de donn√©es.  Il joue le r√¥le d'une API qui donne acc√®s aux donn√©es de base.  Lorsque nous lisons, <code>DataFrame</code> valeurs, la classe <code>DataFrame</code> interagit avec la classe <code>BlockManager</code> pour convertir nos requ√™tes en appels de fonction et de m√©thode. <br><br>  Chaque type de donn√©es a une classe sp√©cialis√©e dans le module <code>pandas.core.internals</code> .  Par exemple, pandas utilise la classe <code>ObjectBlock</code> pour repr√©senter des blocs contenant des colonnes de cha√Ænes et la classe <code>FloatBlock</code> pour repr√©senter des blocs contenant des colonnes contenant <code>FloatBlock</code> nombres √† virgule flottante.  Pour les blocs repr√©sentant des valeurs num√©riques qui ressemblent √† des entiers ou √† des nombres √† virgule flottante, pandas combine les colonnes et les stocke en tant que <code>ndarray</code> donn√©es <code>ndarray</code> la biblioth√®que NumPy.  Cette structure de donn√©es est bas√©e sur le tableau C, les valeurs sont stock√©es dans un bloc de m√©moire continu.  Gr√¢ce √† ce sch√©ma de stockage des donn√©es, l'acc√®s aux fragments de donn√©es est tr√®s rapide. <br><br>  √âtant donn√© que les donn√©es de diff√©rents types sont stock√©es s√©par√©ment, nous examinons l'utilisation de la m√©moire de diff√©rents types de donn√©es.  Commen√ßons par l'utilisation moyenne de la m√©moire pour diff√©rents types de donn√©es. <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br>  En cons√©quence, il s'av√®re que les indicateurs moyens d'utilisation de la m√©moire pour des donn√©es de diff√©rents types ressemblent √† ceci: <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br>  Ces informations nous font comprendre que la majeure partie de la m√©moire est consacr√©e √† 78 colonnes stockant des valeurs d'objet.  Nous en parlerons plus tard, mais r√©fl√©chissons maintenant √† l'am√©lioration de l'utilisation de la m√©moire avec des colonnes qui stockent des donn√©es num√©riques. <br><br><h2>  <font color="#3AC1EF">Sous-types</font> </h2><br>  Comme nous l'avons d√©j√† dit, les pandas repr√©sentent des valeurs num√©riques sous <code>ndarray</code> structures de donn√©es <code>ndarray</code> NumPy et les stockent dans des blocs de m√©moire contigus.  Ce mod√®le de stockage de donn√©es vous permet d'√©conomiser de la m√©moire et d'acc√©der rapidement aux valeurs.  √âtant donn√© que les pandas repr√©sentent chaque valeur du m√™me type en utilisant le m√™me nombre d'octets et <code>ndarray</code> structures <code>ndarray</code> stockent des informations sur le nombre de valeurs, les pandas peuvent <code>ndarray</code> rapidement et avec pr√©cision la quantit√© de m√©moire consomm√©e par les colonnes stockant des valeurs num√©riques. <br><br>  De nombreux types de donn√©es dans les pandas ont de nombreux sous-types qui peuvent utiliser moins d'octets pour repr√©senter chaque valeur.  Par exemple, le type <code>float</code> a les sous-types <code>float16</code> , <code>float32</code> et <code>float64</code> .  Le nombre dans le nom du type indique le nombre de bits que le sous-type utilise pour repr√©senter les valeurs.  Par exemple, dans les sous-types juste √©num√©r√©s, 2, 4, 8 et 16 octets sont utilis√©s respectivement pour le stockage des donn√©es.  Le tableau suivant montre les sous-types des types de donn√©es les plus couramment utilis√©s chez les pandas. <br><table><tbody><tr><td>  <sup>Utilisation de la m√©moire, octets</sup> <sup><br></sup> </td><td>  <sup>Num√©ro √† virgule flottante</sup> <sup><br></sup> </td><td>  <sup>Entier</sup> <sup><br></sup> </td><td>  <sup>Entier non sign√©</sup> <sup><br></sup> </td><td>  <sup>Date et heure</sup> <sup><br></sup> </td><td>  <sup>Valeur bool√©enne</sup> <sup><br></sup> </td><td width="75">  <sup>Objet</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>bool</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>datetime64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>Capacit√© de m√©moire variable</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>objet</sup> <sup><br></sup> </td></tr></tbody></table><br>  Une valeur de type <code>int8</code> utilise 1 octet (8 bits) pour stocker un nombre et peut repr√©senter 256 valeurs binaires (puissance de 2 √† 8).  Cela signifie que ce sous-type peut √™tre utilis√© pour stocker des valeurs dans la plage de -128 √† 127 (dont 0). <br><br>  Pour v√©rifier les valeurs minimales et maximales appropri√©es pour le stockage √† l'aide de chaque sous-type entier, vous pouvez utiliser la m√©thode <code>numpy.iinfo()</code> .  Prenons un exemple: <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br>  En ex√©cutant ce code, nous obtenons les donn√©es suivantes: <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br>  Ici, vous pouvez faire attention √† la diff√©rence entre les types <code>uint</code> (entier non sign√©) et <code>int</code> (entier sign√©).  Les deux types ont la m√™me capacit√©, mais lorsqu'ils stockent uniquement des valeurs positives dans des colonnes, les types non sign√©s permettent une utilisation plus efficace de la m√©moire. <br><br><h2>  <font color="#3AC1EF">Optimisation du stockage des donn√©es num√©riques √† l'aide de sous-types</font> </h2><br>  La fonction <code>pd.to_numeric()</code> peut √™tre utilis√©e pour convertir des types num√©riques.  Pour s√©lectionner des colonnes enti√®res, nous utilisons la m√©thode <code>DataFrame.select_dtypes()</code> , puis nous les optimisons et comparons l'utilisation de la m√©moire avant et apr√®s l'optimisation. <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br>  Voici le r√©sultat d'une √©tude de la consommation de m√©moire: <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td>  √Ä <br></td><td>  Apr√®s <br></td></tr><tr><td>  uint8 <br></td><td>  NaN <br></td><td>  5,0 <br></td></tr><tr><td>  uint32 <br></td><td>  NaN <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  En cons√©quence, vous pouvez constater une baisse de l'utilisation de la m√©moire de 7,9 √† 1,5 m√©gaoctets, c'est-√†-dire que nous avons r√©duit la consommation de m√©moire de plus de 80%.  L'impact global de cette optimisation sur le <code>DataFrame</code> origine, cependant, n'est pas particuli√®rement fort car il a tr√®s peu de colonnes enti√®res. <br><br>  Faisons de m√™me avec les colonnes contenant des nombres √† virgule flottante. <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br>  Le r√©sultat est le suivant: <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td>  √Ä <br></td><td>  Apr√®s <br></td></tr><tr><td>  float32 <br></td><td>  NaN <br></td><td>  77,0 <br></td></tr><tr><td>  float64 <br></td><td>  77,0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Par cons√©quent, toutes les colonnes qui stockaient des nombres √† virgule flottante avec le type de donn√©es <code>float64</code> stockent d√©sormais des nombres de type <code>float32</code> , ce qui nous a permis de r√©duire de 50% l'utilisation de la m√©moire. <br><br>  Cr√©ez une copie du <code>DataFrame</code> origine, utilisez ces colonnes num√©riques optimis√©es au lieu de celles qui y √©taient initialement pr√©sentes et examinez l'utilisation globale de la m√©moire apr√®s l'optimisation. <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br>  Voici ce que nous avons obtenu: <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br>  Bien que nous ayons consid√©rablement r√©duit la consommation de m√©moire par les colonnes stockant des donn√©es num√©riques, en g√©n√©ral, sur l'ensemble du <code>DataFrame</code> , la consommation de m√©moire n'a diminu√© que de 7%.  L'optimisation du stockage des types d'objets peut devenir une source d'am√©lioration beaucoup plus s√©rieuse d'une situation. <br><br>  Avant de proc√©der √† cette optimisation, nous allons examiner de plus pr√®s comment les cha√Ænes sont stock√©es dans les pandas et comparer cela avec la fa√ßon dont les nombres sont stock√©s ici. <br><br><h2>  <font color="#3AC1EF">Comparaison des m√©canismes de stockage des nombres et des cha√Ænes</font> </h2><br>  Le type d' <code>object</code> repr√©sente des valeurs √† l'aide d'objets cha√Æne Python.  Cela est d√ª en partie au fait que NumPy ne prend pas en charge la repr√©sentation des valeurs de cha√Æne manquantes.  √âtant donn√© que Python est un langage interpr√©t√© de haut niveau, il ne fournit pas au programmeur d'outils pour affiner la fa√ßon dont les donn√©es sont stock√©es en m√©moire. <br><br>  Cette limitation conduit au fait que les cha√Ænes ne sont pas stock√©es dans des fragments de m√©moire contigus; leur repr√©sentation en m√©moire est fragment√©e.  Cela entra√Æne une augmentation de la consommation de m√©moire et un ralentissement de la vitesse de travail avec les valeurs de cha√Æne.  Chaque √©l√©ment de la colonne stockant le type de donn√©es d'objet est en fait un pointeur qui contient ¬´l'adresse¬ª √† laquelle la valeur r√©elle est situ√©e en m√©moire. <br><br>  Ce qui suit est un diagramme bas√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> mat√©riel qui compare le stockage de donn√©es num√©riques en utilisant les types de donn√©es NumPy et le stockage de cha√Ænes en utilisant les types de donn√©es int√©gr√©s de Python. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">Stockage de donn√©es num√©riques et de cha√Ænes</font></i> <br><br>  Ici, vous vous souvenez que dans l'un des tableaux ci-dessus, il a √©t√© montr√© qu'une quantit√© variable de m√©moire est utilis√©e pour stocker des donn√©es de types d'objets.  Bien que chaque pointeur occupe 1 octet de m√©moire, chaque valeur de cha√Æne particuli√®re occupe la m√™me quantit√© de m√©moire qui serait utilis√©e pour stocker une seule cha√Æne en Python.  Afin de confirmer cela, nous utiliserons la m√©thode <code>sys.getsizeof()</code> .  Tout d'abord, jetez un ≈ìil aux lignes individuelles, puis √† l'objet pandas de <code>Series</code> qui stocke les donn√©es de cha√Æne. <br><br>  Donc, nous examinons d'abord les lignes habituelles: <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br>  Ici, les donn√©es d'utilisation de la m√©moire ressemblent √† ceci: <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br>  Voyons maintenant √† quoi ressemble l'utilisation de cha√Ænes dans l'objet <code>Series</code> : <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br>  Ici, nous obtenons ce qui suit: <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br>  Ici, vous pouvez voir que les tailles des lignes stock√©es dans les objets pandas <code>Series</code> sont similaires √† leurs tailles lorsque vous travaillez avec eux en Python et lorsque vous les repr√©sentez en tant qu'entit√©s distinctes. <br><br><h2>  <font color="#3AC1EF">Optimisation du stockage des donn√©es de type objet √† l'aide de variables cat√©gorielles</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les variables cat√©gorielles sont</a> apparues dans la version 0.15 de pandas.  Le type correspondant, <code>category</code> , utilise des valeurs enti√®res dans ses m√©canismes internes, au lieu des valeurs d'origine stock√©es dans les colonnes du tableau.  Pandas utilise un dictionnaire s√©par√© qui d√©finit la correspondance des valeurs enti√®res et initiales.  Cette approche est utile lorsque les colonnes contiennent des valeurs d'un ensemble limit√©.  Lorsque les donn√©es stock√©es dans une colonne sont converties en type de <code>category</code> , pandas utilise le sous-type <code>int</code> , qui permet l'utilisation la plus efficace de la m√©moire et est capable de repr√©senter toutes les valeurs uniques trouv√©es dans la colonne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">Donn√©es source et donn√©es cat√©gorielles utilisant le sous-type int8</font></i> <br><br>  Afin de comprendre exactement o√π nous pouvons utiliser des donn√©es cat√©gorielles pour r√©duire la consommation de m√©moire, nous trouvons le nombre de valeurs uniques dans les colonnes qui stockent les valeurs des types d'objets: <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br>  Vous pouvez trouver ce que nous avons dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> tableau, sur la feuille <code>    </code> . <br><br>  Par exemple, dans la colonne <code>day_of_week</code> , qui est le jour de la semaine o√π le jeu a √©t√© jou√©, il y a 171907 valeurs.  Parmi eux, seuls 7 sont uniques.  Dans l'ensemble, un seul coup d'≈ìil sur ce rapport suffit pour comprendre que plusieurs valeurs uniques sont utilis√©es dans de nombreuses colonnes pour repr√©senter les donn√©es d'environ 172 000 jeux. <br><br>  Avant de proc√©der √† l'optimisation √† grande √©chelle, s√©lectionnons une colonne qui stocke les donn√©es d'objet, au moins <code>day_of_week</code> , et voyons ce qui se passe √† l'int√©rieur du programme lorsqu'il est converti en un type cat√©gorique. <br><br>  Comme d√©j√† mentionn√©, cette colonne ne contient que 7 valeurs uniques.  Pour le convertir en un type cat√©goriel, nous utilisons la m√©thode <code>.astype()</code> . <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br>  Voici ce que nous avons obtenu: <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br>  Comme vous pouvez le voir, bien que le type de la colonne ait chang√©, les donn√©es qui y sont stock√©es ont la m√™me apparence qu'auparavant.  Voyons maintenant ce qui se passe √† l'int√©rieur du programme. <br><br>  Dans le code suivant, nous utilisons l'attribut <code>Series.cat.codes</code> pour d√©terminer les valeurs enti√®res que le type de <code>category</code> utilise pour repr√©senter chaque jour de la semaine: <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br>  Nous r√©ussissons √† d√©couvrir ce qui suit: <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br>  Ici, vous pouvez voir que chaque valeur unique se voit attribuer une valeur enti√®re et que la colonne est d√©sormais de type <code>int8</code> .  Il n'y a pas de valeurs manquantes, mais si c'√©tait le cas, -1 serait utilis√© pour indiquer ces valeurs. <br><br>  Comparons maintenant la consommation de m√©moire avant et apr√®s la conversion de la colonne <code>day_of_week</code> en type de <code>category</code> . <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br>  Voici le r√©sultat: <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br>  Comme vous pouvez le voir, au d√©but, 9,84 m√©gaoctets de m√©moire ont √©t√© consomm√©s, et apr√®s optimisation, seulement 0,16 m√©gaoctets, ce qui signifie une am√©lioration de 98% de cet indicateur.  Veuillez noter que l'utilisation de cette colonne illustre probablement l'un des sc√©narios d'optimisation les plus rentables lorsque seules 7 valeurs uniques sont utilis√©es dans une colonne contenant environ 172 000 √©l√©ments. <br><br>  Bien que l'id√©e de convertir toutes les colonnes en ce type de donn√©es semble int√©ressante, avant de le faire, consid√©rez les effets secondaires n√©gatifs d'une telle conversion.  Ainsi, le plus grave inconv√©nient de cette transformation est l'impossibilit√© d'effectuer des op√©rations arithm√©tiques sur des donn√©es cat√©gorielles.  Cela s'applique √©galement aux op√©rations arithm√©tiques ordinaires et √† l'utilisation de m√©thodes telles que <code>Series.min()</code> et <code>Series.max()</code> sans d'abord convertir les donn√©es en un type de nombre r√©el. <br><br>  Nous devons limiter l'utilisation du type de <code>category</code> √† principalement des colonnes qui stockent des donn√©es de type <code>object</code> , dans lesquelles moins de 50% des valeurs sont uniques.  Si toutes les valeurs d'une colonne sont uniques, l'utilisation du type de <code>category</code> augmentera le niveau d'utilisation de la m√©moire.  Cela est d√ª au fait qu'en m√©moire, vous devez stocker, en plus des codes de cat√©gorie num√©riques, les valeurs de cha√Æne d'origine.  Les d√©tails sur les restrictions de type de <code>category</code> peuvent √™tre trouv√©s dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation des</a> pandas. <br><br>  Cr√©ons une boucle qui it√®re sur toutes les colonnes stockant des donn√©es d' <code>object</code> type, d√©couvre si le nombre de valeurs uniques dans les colonnes d√©passe 50% et, si tel est le cas, les convertit en <code>category</code> type. <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br>  Comparez maintenant ce qui s'est pass√© apr√®s l'optimisation avec ce qui s'est pass√© avant: <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br>  Nous obtenons ce qui suit: <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td>  √Ä <br></td><td>  Apr√®s <br></td></tr><tr><td>  objet <br></td><td>  78,0 <br></td><td>  NaN <br></td></tr><tr><td>  cat√©gorie <br></td><td>  NaN <br></td><td>  78,0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     ‚Äî  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>Chers lecteurs!</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">eugene_bb</a> .    -  ,    ‚Äî    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442516/">https://habr.com/ru/post/fr442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442504/index.html">Proxy PHP Xdebug: lorsque les fonctionnalit√©s standard de Xdebug ne suffisent pas</a></li>
<li><a href="../fr442506/index.html">La Russie est-elle punie pour commerce ill√©gal de donn√©es personnelles?</a></li>
<li><a href="../fr442508/index.html">Comment udalenka acc√©l√®re l'innovation sur GitLab</a></li>
<li><a href="../fr442512/index.html">Personnalisation de Django ORM sur l'exemple de ZomboDB</a></li>
<li><a href="../fr442514/index.html">Syst√®mes distribu√©s. Mod√®les de conception. Critique de livre</a></li>
<li><a href="../fr442518/index.html">Top 10 des techniques de piratage Web 2018</a></li>
<li><a href="../fr442520/index.html">Affaire. √âconomie de 300 000 p. par mois sur la publicit√© contextuelle</a></li>
<li><a href="../fr442522/index.html">Intuitive RL (Reinforcement Learning): Introduction √† Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../fr442524/index.html">Comment accro√Ætre la s√©curit√© des syst√®mes d'identification personnelle et de contr√¥le d'acc√®s</a></li>
<li><a href="../fr442526/index.html">L'histoire des cassettes sovi√©tiques (deuxi√®me partie): le boom des Walkmen, un gadget pour le KGB et des magn√©tophones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>