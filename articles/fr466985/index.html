<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🚀 🏈 💧 À propos des nouvelles normes C ++ 👩‍🏫 👨‍👧 👧🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, j'ai un post assez court. Je ne l’écrirais probablement pas, mais sur Habré dans les commentaires, vous pouvez souvent trouver l’opinion ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>À propos des nouvelles normes C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466985/"><p>  Aujourd'hui, j'ai un post assez court.  Je ne l’écrirais probablement pas, mais sur Habré dans les commentaires, vous pouvez souvent trouver l’opinion que les pros empirent, le comité ne sait pas ce qui n’est pas clair pourquoi, et me rend généralement mon 2007e.  Et puis un exemple aussi clair est soudainement apparu. </p><br><p> Il y a presque exactement cinq ans, j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrit</a> sur la façon de faire du curry en C ++.  Eh bien, si vous pouviez écrire <code>foo(bar, baz, quux)</code> , alors vous pourriez écrire <code>Curry(foo)(bar)(baz)(quux)</code> .  Ensuite, C ++ 14 vient de sortir et était à peine pris en charge par les compilateurs, donc le code n'utilisait que des puces C ++ 11 (plus quelques béquilles pour simuler les fonctions de bibliothèque à partir de C ++ 14). </p><br><p>  Et puis je suis encore tombé sur ce code, et mes yeux me font mal à quel point il est verbeux.  De plus, j'ai tourné le calendrier il n'y a pas si longtemps et j'ai remarqué que c'est maintenant l'année 2019, et vous pouvez voir comment C ++ 17 peut nous faciliter la vie. </p><br><p>  Verrons-nous? </p><a name="habracut"></a><br><p>  Ok, voyons. </p><br><p>  L'implémentation originale, à partir de laquelle nous allons danser, ressemble à ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... PrevArgs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurryImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> F m_f; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;PrevArgs...&gt; m_prevArgs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CurryImpl (F f, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">result_of_t</span></span>&lt;F (PrevArgs..., T)&gt; invoke (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; arg, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeIndexed (arg, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::index_sequence_for&lt;PrevArgs...&gt; {}); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IF&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoke</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... IArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IF fr, IArgs... args)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fr (args...))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fr (args...); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoke</span></span></span><span class="hljs-class">&lt;R (C::*) (Args...)&gt; {</span></span> <span class="hljs-function"><span class="hljs-function">R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (C::*ptr) (Args...), C c, Args... rest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.*ptr) (rest...); } <span class="hljs-function"><span class="hljs-function">R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (C::*ptr) (Args...), C *c, Args... rest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c-&gt;*ptr) (rest...); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>... Is&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeIndexed</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::index_sequence&lt;Is...&gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Invoke&lt;F&gt; {} (m_f, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::get&lt;Is&gt; (m_prevArgs)..., arg))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Invoke&lt;F&gt; {} (m_f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;Is&gt; (m_prevArgs)..., arg); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg, ...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> -&gt; CurryImpl&lt;F, PrevArgs..., T&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { m_f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat (m_prevArgs, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T&gt; { arg }) }; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(invoke (arg, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invoke (arg, <span class="hljs-number"><span class="hljs-number">0</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; CurryImpl&lt;F&gt; Curry (F f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { f, {} }; }</code> </pre> <br><p>  Dans <code>m_f</code> se trouve le foncteur stocké, dans <code>m_prevArgs</code> - les arguments stockés lors des appels précédents. </p><br><p>  Ici, <code>operator()</code> doit déterminer s'il est déjà possible d'appeler le foncteur enregistré, ou s'il est nécessaire de continuer à accumuler des arguments, donc il fait un SFINAE assez standard en utilisant l'aide <code>invoke</code> .  De plus, afin d'appeler le foncteur (ou vérifier son appelabilité), nous couvrons le tout avec encore une autre couche SFINAE pour comprendre comment le faire (parce que nous devons appeler le pointeur sur le membre et, par exemple, la fonction libre de différentes manières), et pour cela nous utilisons la structure d'aide <code>Invoke</code> , qui est probablement incomplète ... Bref, beaucoup de choses. </p><br><p>  Eh bien, cette chose fonctionne de manière absolument dégoûtante avec la sémantique des mouvements, la transmission parfaite et d'autres mots doux au cœur du signe plus de notre temps.  La réparation sera un peu plus difficile que nécessaire, car en plus de la tâche directement résolue, il existe également un tas de code qui ne lui est pas tout à fait lié. </p><br><p>  Eh bien, encore une fois, en C ++ 11, il n'y a rien de tel que <code>std::index_sequence</code> et des choses connexes, ou l'alias <code>std::result_of_t</code> , donc le code C ++ 11 pur serait encore plus difficile. </p><br><p>  Alors, enfin, passons au C ++ 17. </p><br><p>  Tout d'abord, nous n'avons pas besoin de spécifier l' <code>operator()</code> type de retour <code>operator()</code> , nous pouvons écrire simplement: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invoke (arg, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  Techniquement, ce n'est pas exactement la même chose ("relier" est affiché de différentes manières), mais dans le cadre de notre tâche ce n'est pas essentiel. </p><br><p>  De plus, nous n'avons pas besoin de faire SFINAE avec nos mains pour vérifier l' <code>m_f</code> avec les arguments stockés.  C ++ 17 nous offre deux fonctionnalités intéressantes: <code>constexpr if</code> et <code>std::is_invocable</code> .  Jetez tout ce que nous avions avant et écrivez le squelette du nouvel <code>operator()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_invocable_v&lt;F, PrevArgs..., T&gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   else //       arg }</span></span></span></span></code> </pre> <br><p>  La deuxième branche est triviale, vous pouvez copier le code qui était déjà: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_invocable_v&lt;F, PrevArgs..., T&gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   else return CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, std::tuple_cat (m_prevArgs, std::tuple&lt;T&gt; { arg }) }; }</span></span></span></span></code> </pre> <br><p>  La première branche sera plus intéressante.  Nous devons appeler <code>m_f</code> , en passant tous les arguments stockés dans <code>m_prevArgs</code> , plus <code>arg</code> .  Heureusement, nous n'avons plus besoin de <code>integer_sequence</code> : en C ++ 17, il existe une fonction de bibliothèque standard <code>std::apply</code> pour appeler une fonction avec des arguments stockés dans <code>tuple</code> .  Seulement, nous devons mettre un autre argument ( <code>arg</code> ) à la fin du mannequin, afin que nous puissions soit créer <code>std::tuple_cat</code> , soit simplement décompresser <code>std::apply</code> ', nous pouvons utiliser le lambda générique factice existant (une autre fonctionnalité apparue après C ++ 11, mais pas dans le 17!).  D'après mon expérience, l'instanciation des mannequins est lente (en temps de calcul, bien sûr), je vais donc choisir la deuxième option.  Dans le lambda lui-même, j'ai besoin d'appeler <code>m_f</code> , et pour le faire correctement, je peux utiliser la fonction de bibliothèque qui est apparue en C ++ 17, <code>std::invoke</code> , en lançant l'assistant <code>Invoke</code> écrit à la main: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_invocable_v&lt;F, PrevArgs..., T&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wrapper = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;arg] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp;... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invoke (m_f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (args)&gt; (args)..., arg); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move (wrapper), m_prevArgs); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat (m_prevArgs, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T&gt; { arg }) }; }</code> </pre> <br><p>  Il est utile de noter comment le type de retour déduit <code>auto</code> vous permet de renvoyer des valeurs de différents types dans différentes branches <code>if constexpr</code> . </p><br><p>  En tout cas, c'est essentiellement tout.  Ou avec le harnais nécessaire: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... PrevArgs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurryImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> F m_f; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;PrevArgs...&gt; m_prevArgs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CurryImpl (F f, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;PrevArgs...&gt;&amp; prev) : m_f { f } , m_prevArgs { prev } { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_invocable_v&lt;F, PrevArgs..., T&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wrapper = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;arg] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp;... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::invoke (m_f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (args)&gt; (args)..., arg); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move (wrapper), m_prevArgs); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CurryImpl&lt;F, PrevArgs..., T&gt; { m_f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat (m_prevArgs, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T&gt; { arg }) }; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; CurryImpl&lt;F, Args...&gt; Curry (F f, Args&amp;&amp;... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward_as_tuple (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt; (args)...) }; }</code> </pre> <br><p>  Je pense que c'est une amélioration significative par rapport à la version originale.  Et c'est plus facile à lire.  Même ennuyeux, <em>pas de défi</em> . </p><br><p>  De plus, nous pourrions également nous débarrasser de la fonction <code>Curry</code> et utiliser <code>CurryImpl</code> directement, en nous appuyant sur des guides de déduction, mais cela est préférable lorsque nous traitons un transfert parfait, etc.  Ce qui nous amène en douceur ... </p><br><p>  Maintenant, il est assez évident à quel point c'est terrible en termes de copie d'arguments, de malheureuse transmission parfaite, etc.  Mais plus important encore, la réparer est maintenant beaucoup plus facile.  Mais nous le ferons en quelque sorte dans le prochain post. </p><br><h1>  Au lieu d'une conclusion </h1><br><p>  Premièrement, en C ++ 20, <code>std::bind_front</code> apparaîtra, ce qui couvrira la part du lion de mes cas d'utilisateurs dans lesquels j'ai besoin d'une telle chose.  Vous pouvez généralement le jeter.  Triste </p><br><p>  Deuxièmement, écrire sur les pros devient plus facile, même si vous écrivez une sorte de code de modèle avec une métaprogrammation.  Vous n'avez plus à penser à l'option SFINAE à choisir, comment déballer le mannequin, comment appeler la fonction.  Il suffit de prendre et d'écrire <code>if constexpr</code> , <code>std::apply</code> , <code>std::invoke</code> .  D'une part, c'est bien, je ne veux pas revenir au C ++ 14 ou, surtout, au 11.  D'un autre côté, il semble que la couche de compétences d'un lion devienne inutile.  Non, il est toujours utile de pouvoir visser quelque chose comme ça sur des modèles et de comprendre comment toute cette magie de bibliothèque fonctionne en vous, mais si vous en aviez besoin tout le temps, maintenant c'est beaucoup moins courant.  Cela provoque des émotions étranges. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466985/">https://habr.com/ru/post/fr466985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466965/index.html">Présentation Apple 10 septembre 2019</a></li>
<li><a href="../fr466967/index.html">Devinez-moi si vous le pouvez: prédire la cote d'un film avant sa sortie</a></li>
<li><a href="../fr466973/index.html">Leisya, Fanta: une nouvelle tactique pour un vieux cheval de Troie Android</a></li>
<li><a href="../fr466979/index.html">Renommer des fichiers avec des variables - Code Visual Studio</a></li>
<li><a href="../fr466983/index.html">Pourquoi personne ne peut battre la course de Tesla</a></li>
<li><a href="../fr466987/index.html">Les «ls» atypiques ou comment les linuxoïdes sont divertis</a></li>
<li><a href="../fr466993/index.html">Configuration du plugin Warnings Next Generation pour l'intégration avec PVS-Studio</a></li>
<li><a href="../fr466995/index.html">Configuration du plug-in Warnings Next Generation pour l'intégration PVS-Studio</a></li>
<li><a href="../fr466999/index.html">Comparaison des bibliothèques CLI populaires pour Python: clic, ciment, feu et autres</a></li>
<li><a href="../fr467003/index.html">Menu rapide, pratique et adaptatif pour 1075 catégories (36000 produits)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>