<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå∏ üßôüèø üöî Unity3D: Ubah Delegasi Aplikasi iOS üõåüèº ‚úñÔ∏è üë®üèº‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya pikir banyak orang dalam proses mengembangkan game untuk iOS harus menghadapi kenyataan bahwa menjadi perlu untuk menggunakan satu atau beberapa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity3D: Ubah Delegasi Aplikasi iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430118/">  Saya pikir banyak orang dalam proses mengembangkan game untuk iOS harus menghadapi kenyataan bahwa menjadi perlu untuk menggunakan satu atau beberapa fungsi asli.  Mengenai Unity3D, banyak masalah dapat muncul dalam masalah ini: untuk menerapkan beberapa jenis fitur, Anda harus melihat ke arah plugin asli yang ditulis dalam Objective-C.  Seseorang pada saat ini segera putus asa dan meninggalkan ide itu.  Seseorang mencari solusi yang sudah jadi di AssetStore atau di forum, berharap solusi yang sudah jadi sudah ada.  Jika tidak ada solusi siap pakai, maka yang paling gigih dari kita tidak melihat cara lain selain terjun ke jurang pemrograman iOS dan interaksi Unity3D dengan kode Objective-C. <br><br>  Mereka yang memilih jalan terakhir (walaupun, saya pikir, mereka sendiri tahu), akan menghadapi banyak masalah di jalan yang sulit dan sulit ini: <br><br><ul><li>  iOS adalah ekosistem yang benar-benar asing dan terisolasi, berkembang dengan caranya sendiri.  Minimal, Anda harus meluangkan banyak waktu untuk memahami bagaimana Anda bisa sampai ke aplikasi, dan di mana di kedalaman proyek Xcode yang dihasilkan secara otomatis adalah kode untuk mesin Unity3D untuk berinteraksi dengan komponen asli aplikasi. </li><li>  Objective-C adalah bahasa pemrograman yang agak terpisah dan mirip.  Dan ketika berinteraksi dengan kode C ++ dari aplikasi Unity3D, "dialek" bahasa ini, yang disebut Objective-C ++, memasuki adegan.  Ada sangat sedikit informasi tentang dia, sebagian besar adalah kuno dan arsip. </li><li>  Protokol interaksi antara aplikasi Unity3D dan iOS tidak dijelaskan dengan baik.  Anda harus mengandalkan tutorial para penggemar jaringan yang menulis cara mengembangkan plugin asli yang paling sederhana.  Pada saat yang sama, hanya sedikit orang yang menyinggung masalah yang lebih dalam dan masalah yang timbul dari kebutuhan untuk melakukan sesuatu yang rumit. </li></ul><br>  Mereka yang ingin belajar tentang mekanisme interaksi Unity3D dengan aplikasi iOS, silakan, di bawah cat. <br><a name="habracut"></a><br>  Untuk memperjelas hambatan ketat interaksi Unity3D dengan kode asli, artikel ini menjelaskan aspek interaksi dari delegasi aplikasi iOS dengan kode Unity3D, di mana C ++ dan Objective-C alat itu diimplementasikan, dan bagaimana memodifikasi delegasi aplikasi sendiri.  Informasi ini dapat berguna baik untuk pemahaman yang lebih baik tentang mekanisme pertautan Unity3D + iOS, dan untuk penggunaan praktis. <br><br><h3>  Interaksi antara iOS dan aplikasi </h3><br>  Sebagai pengantar, mari kita lihat bagaimana interaksi aplikasi dengan sistem diimplementasikan di iOS dan sebaliknya.  Secara skematis, peluncuran aplikasi iOS terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/jd/vm/oi/jdvmoimtygqdsc095abusfopdao.png" alt="gambar"><br><br>  Untuk mempelajari mekanisme ini dari sudut pandang kode, aplikasi baru yang dibuat dalam Xcode menggunakan templat "Aplikasi Tampilan Tunggal" cocok. <br><br><img src="https://habrastorage.org/webt/du/_z/75/du_z75efp4bdgv_fvb02x-mjfis.png"><br><br>  Memilih template ini, hasilnya akan memberi Anda aplikasi iOS paling sederhana yang dapat berjalan di perangkat atau emulator dan menampilkan layar putih.  Xcode akan membantu membuat proyek di mana hanya akan ada 5 file dengan kode sumber (dengan 2 di antaranya adalah file header .h) dan beberapa file tambahan yang tidak menarik bagi kami (pengaturan huruf, konfigurasi, ikon). <br><br><img src="https://habrastorage.org/webt/jt/mz/ov/jtmzov95oshddmprhby9wkqigve.png"><br><br>  Mari kita lihat apa yang bertanggung jawab atas file kode sumber: <br><br><ul><li>  <i>ViewController.m</i> / <i>ViewController.h</i> - kode sumber tidak terlalu menarik bagi kami.  Karena aplikasi Anda memiliki Tampilan (yang tidak diwakili oleh kode, tetapi menggunakan Storyboard), Anda akan memerlukan kelas Controller, yang akan mengontrol Tampilan ini.  Secara umum, cara ini Xcode sendiri mendorong kita untuk menggunakan pola MVC.  Proyek yang menghasilkan Unity3D tidak akan memiliki file sumber ini. </li><li>  <i>AppDelegate.m</i> / <i>AppDelegate.h</i> adalah delegasi aplikasi Anda.  Tempat menarik dalam aplikasi tempat kerja kode aplikasi khusus dimulai. </li><li>  <i>main.m</i> - titik awal aplikasi.  Dengan cara aplikasi C / C ++ apa pun, ini berisi fungsi utama, yang dengannya program dimulai. </li></ul><br>  Sekarang, mari kita lihat kode yang dimulai dengan file <i>main.m</i> : <br><br><pre><code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * argv[]) { <span class="hljs-comment"><span class="hljs-comment">//1 @autoreleasepool { //2 return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); // 3 } }</span></span></code> </pre> <br>  Dengan baris 1, semuanya jelas dan tanpa penjelasan, mari beralih ke jalur 2. Ini menunjukkan bahwa siklus hidup aplikasi akan terjadi di dalam kumpulan Autorelease.  Menggunakan kumpulan autorelease memberi tahu kami bahwa kami akan mempercayakan pengelolaan memori aplikasi ke kumpulan khusus ini, yaitu, ia akan menangani masalah ketika perlu membebaskan memori untuk variabel tertentu.  Cerita tentang manajemen memori pada iOS berada di luar cakupan cerita ini, jadi tidak ada gunanya mempelajari topik ini.  Bagi mereka yang tertarik dengan topik ini, Anda dapat menemukan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> . <br><br>  Mari kita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beralih</a> ke jalur 3. Ini memanggil fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UIApplicationMain</a> .  Parameter startup program (argc, argv) diteruskan ke sana.  Kemudian, dalam fungsi ini, ditunjukkan kelas mana yang akan digunakan sebagai kelas utama aplikasi, instance-nya dibuat.  Dan, akhirnya, ditunjukkan kelas mana yang akan digunakan sebagai delegasi aplikasi, instansasinya dibuat, koneksi antara instance kelas aplikasi dan delegasinya dikonfigurasikan. <br><br>  Dalam contoh kita, nil dilewatkan sebagai kelas yang akan mewakili contoh aplikasi - secara kasar, analog lokal adalah nol.  Selain nil, Anda dapat lulus kelas khusus yang diwarisi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi UIA di sana</a> .  Jika nihil ditentukan, maka aplikasi UIA akan digunakan.  Kelas ini adalah titik terpusat untuk mengelola dan mengoordinasi pekerjaan aplikasi pada iOS dan merupakan singleton.  Dengannya, Anda dapat mempelajari hampir semua hal tentang kondisi aplikasi saat ini, pemberitahuan, jendela, peristiwa yang terjadi dalam sistem itu sendiri yang mempengaruhi aplikasi ini dan banyak lagi.  Kelas ini hampir tidak pernah mewarisi.  Kami akan membahas penciptaan kelas Delegasi Aplikasi lebih detail. <br><br><h3>  Buat Delegasi Aplikasi </h3><br>  Indikasi kelas mana yang digunakan sebagai delegasi aplikasi terjadi dalam panggilan fungsi <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSStringFromClass</span></span>([AppDelegate <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>])</code> </pre> <br>  Mari kita menganalisis panggilan ini dalam beberapa bagian. <br><br><pre> <code class="objectivec hljs">[AppDelegate <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konstruk ini</a> mengembalikan objek dari kelas AppDelegate (yang dideklarasikan di AppDelegate.h / .m), dan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NSStringFromClass</a> mengembalikan nama kelas sebagai string.  Kami hanya meneruskan nama string dari kelas yang akan dibuat dan digunakan sebagai delegasi ke fungsi UIApplicationMain.  Untuk pemahaman yang lebih baik, baris 3 di file <i>main.m</i> bisa diganti dengan yang berikut: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIApplicationMain</span></span>(argc, argv, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">@"AppDelegate"</span></span>);</code> </pre> <br>  Dan hasil implementasinya akan identik dengan versi aslinya.  Rupanya, para pengembang memutuskan untuk datang ke pendekatan ini agar tidak menggunakan string konstan.  Dengan pendekatan standar, jika Anda mengganti nama kelas delegasi, parser akan segera melempar kesalahan.  Jika Anda menggunakan baris yang biasa, kode akan berhasil dikompilasi, dan Anda akan menerima kesalahan hanya dengan memulai aplikasi. <br><br>  Mekanisme serupa untuk membuat kelas, hanya menggunakan nama string kelas, dapat mengingatkan Anda tentang Refleksi dari C #.  Objective-C dan runtime-nya jauh lebih kuat daripada Refleksi di C #.  Ini adalah poin yang cukup penting dalam konteks artikel ini, tetapi akan membutuhkan banyak waktu untuk menggambarkan semua fitur.  Namun, kita masih akan bertemu dengan "Refleksi" di Objective-C di bawah ini.  Masih memahami konsep delegasi aplikasi dan fungsinya. <br><br><h3>  Delegasi aplikasi </h3><br>  Semua interaksi aplikasi dengan iOS terjadi di kelas aplikasi UIA.  Kelas ini mengambil banyak tanggung jawab - memberitahukan tentang asal mula acara, status aplikasi, dan banyak lagi lainnya.  Sebagian besar, perannya adalah memberi tahu.  Tetapi ketika sesuatu terjadi dalam sistem, kita harus dapat menanggapi perubahan ini, entah bagaimana, melakukan semacam fungsi khusus.  Jika sebuah instance dari kelas aplikasi UIA melakukan ini, praktik ini akan mulai menyerupai pendekatan yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Obyek Ilahi</a> .  Karena itu, ada baiknya memikirkan membebaskan kelas ini dari bagian dari tanggung jawabnya. <br><br>  Untuk tujuan inilah ekosistem iOS menggunakan hal semacam itu sebagai delegasi aplikasi.  Dari namanya sendiri, kita dapat menyimpulkan bahwa kita berurusan dengan pola desain seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Delegasi</a> .  Singkatnya, kami hanya memindahkan tanggung jawab untuk memproses respons terhadap peristiwa aplikasi tertentu ke delegasi aplikasi.  Untuk tujuan ini, dalam contoh kita, kelas AppDelegate dibuat di mana kita dapat menulis fungsionalitas khusus, sementara meninggalkan kelas aplikasi UIA untuk bekerja dalam mode kotak hitam.  Pendekatan ini mungkin tampak kontroversial bagi seseorang dalam hal keindahan desain arsitektur, tetapi penulis iOS sendiri mendorong kami untuk pendekatan ini dan sebagian besar pengembang (jika tidak semua) menggunakannya. <br><br>  Untuk memverifikasi secara visual seberapa sering selama pekerjaan aplikasi, delegasi aplikasi menerima pesan tertentu, lihat diagram: <br><br><img src="https://habrastorage.org/webt/md/61/bc/md61bc9my4focy1suoy5qn9om2s.png" alt="gambar"><br><br>  Kotak kuning menunjukkan panggilan dari satu atau lain metode delegasi dalam menanggapi peristiwa tertentu kehidupan aplikasi (siklus hidup aplikasi).  Diagram ini hanya mengilustrasikan peristiwa yang terkait dengan perubahan status aplikasi dan tidak menampilkan banyak aspek lain dari tanggung jawab delegasi, seperti menerima pemberitahuan atau berinteraksi dengan kerangka kerja. <br><br>  Berikut adalah beberapa contoh di mana kita mungkin memerlukan akses ke delegasi aplikasi dari Unity3D: <br><br><ol><li>  menangani pemberitahuan push dan lokal </li><li>  mencatat peristiwa peluncuran aplikasi ke analytics </li><li>  penentuan cara meluncurkan aplikasi - "bersih" atau keluar dari latar belakang </li><li>  bagaimana aplikasi diluncurkan - dengan tach untuk notifikasi, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tindakan Cepat Layar Utama</a> atau hanya dengan tach on incon </li><li>  interaksi dengan WatchKit atau HealthKit </li><li>  membuka dan memproses URL dari aplikasi lain.  Jika URL ini berlaku untuk aplikasi Anda, Anda dapat memprosesnya di aplikasi Anda alih-alih membiarkan sistem membuka URL itu di browser </li></ol><br>  Ini bukan daftar seluruh skenario.  Selain itu, perlu dicatat bahwa delegasi memodifikasi banyak analitik dan sistem periklanan di plugin asli mereka. <br><br><h3>  Bagaimana Unity3D mengimplementasikan delegasi aplikasi </h3><br>  Sekarang mari kita lihat proyek Xcode yang dihasilkan oleh Unity3D dan cari tahu bagaimana delegasi aplikasi diimplementasikan di Unity3D.  Saat membangun untuk platform iOS, Unity3D secara otomatis menghasilkan proyek Xcode untuk Anda, yang menggunakan banyak kode boilerplate.  Kode templat ini juga termasuk kode Delegasi Aplikasi.  Di dalam proyek yang dibuat, Anda dapat menemukan file <i>UnityAppController.h</i> dan <i>UnityAppController.mm</i> .  File-file ini berisi kode kelas UnityAppController yang menarik minat kami. <br><br>  Bahkan, Unity3D menggunakan versi modifikasi dari template "Aplikasi Tampilan Tunggal".  Hanya dalam templat ini, Unity3D menggunakan delegasi aplikasi tidak hanya untuk menangani acara iOS, tetapi juga untuk menginisialisasi mesin itu sendiri, menyiapkan komponen grafis, dan banyak lagi.  Ini sangat mudah dimengerti jika Anda melihat metodenya. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)application:(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>*)application didFinishLaunchingWithOptions:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>*)launchOptions</code> </pre><br>  dalam kode kelas UnityAppController.  Metode ini dipanggil pada saat inisialisasi aplikasi, ketika Anda dapat mentransfer kontrol ke kode kustom Anda.  Di dalam metode ini, misalnya, Anda dapat menemukan baris berikut: <br><br><pre> <code class="objectivec hljs">UnityInitApplicationNoGraphics([[[<span class="hljs-built_in"><span class="hljs-built_in">NSBundle</span></span> mainBundle] bundlePath] UTF8String]); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selectRenderingAPI]; [UnityRenderingView InitializeForAPI: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.renderingAPI]; _window = [[<span class="hljs-built_in"><span class="hljs-built_in">UIWindow</span></span> alloc] initWithFrame: [<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span> mainScreen].bounds]; _unityView = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> createUnityView]; [DisplayManager Initialize]; _mainDisplay = [DisplayManager Instance].mainDisplay; [_mainDisplay createWithWindow: _window andView: _unityView]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> createUI]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> preStartUnity];</code> </pre><br>  Tanpa merinci apa yang menjadi tantangan ini, Anda dapat menebak bahwa itu terkait dengan persiapan Unity3D untuk bekerja.  Ternyata skenario berikut: <br><br><ol><li>  Fungsi utama dipanggil dari <i>main.mm</i> </li><li>  Kelas instance aplikasi dan delegasinya dibuat. </li><li>  Delegasi aplikasi mempersiapkan dan meluncurkan mesin Unity3D </li><li>  Kode khusus Anda mulai berfungsi.  Jika Anda menggunakan il2cpp, maka kode Anda diterjemahkan dari C # ke IL dan kemudian ke kode C ++, yang langsung masuk ke proyek Xcode. </li></ol><br>  Skrip ini terdengar sangat sederhana dan logis, tetapi membawa masalah potensial: bagaimana kita dapat memodifikasi delegasi aplikasi jika kita tidak memiliki akses ke kode sumber saat bekerja di Unity3D? <br><br><h3>  Unity3D yang terkena dampak untuk memodifikasi delegasi aplikasi </h3><br>  Kita dapat melihat file <i>AppDelegateListener.mm/.h</i> .  Mereka berisi makro yang memungkinkan Anda untuk mendaftarkan kelas apa pun sebagai pendengar acara untuk delegasi aplikasi.  Ini adalah pendekatan yang baik, kita tidak perlu mengubah kode yang ada, tetapi tambahkan saja yang baru.  Tetapi memiliki kelemahan yang signifikan: tidak semua acara aplikasi didukung dan tidak ada cara untuk mendapatkan informasi tentang peluncuran aplikasi. <br><br>  Namun, jalan keluar yang paling jelas adalah untuk mengubah kode sumber delegasi dengan tangan setelah Unity3D membangun proyek Xcode.  Masalah dengan pendekatan ini jelas - opsi ini cocok jika Anda membuat rakitan dengan tangan Anda dan Anda tidak bingung dengan kebutuhan untuk memodifikasi kode secara manual setelah setiap rakitan.  Dalam hal menggunakan pembangun (Unity Cloud Build atau mesin build lainnya), opsi ini benar-benar tidak dapat diterima.  Untuk tujuan ini, pengembang Unity3D memberi kami celah. <br><br>  File <i>UnityAppController.h</i> , selain mendeklarasikan variabel dan metode, juga mengandung definisi makro: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define IMPL_APP_CONTROLLER_SUBCLASS(ClassName) ...</span></span></code> </pre> <br>  Makro ini hanya memungkinkan untuk mengabaikan delegasi aplikasi.  Untuk melakukan ini, Anda perlu mengambil beberapa langkah sederhana: <br><br><ol><li>  Tuliskan delegasi aplikasi Anda sendiri di Objective-C </li><li>  Di suatu tempat di dalam kode sumber tambahkan baris berikut <pre> <code class="objectivec hljs">IMPL_APP_CONTROLLER_SUBCLASS(___)</code> </pre> </li><li>  Masukkan sumber ini ke dalam folder Plugins / iOS proyek Unity3D Anda </li></ol><br>  Sekarang Anda akan menerima proyek di mana delegasi aplikasi Unity3D standar akan diganti dengan proyek khusus Anda. <br><br><h3>  Bagaimana cara kerja delegasi pengganti makro </h3><br>  Mari kita lihat kode sumber lengkap makro: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define IMPL_APP_CONTROLLER_SUBCLASS(ClassName) ... @interface ClassName(OverrideAppDelegate) \ { \ } \ +(void)load; \ @end \ @implementation ClassName(OverrideAppDelegate) \ +(void)load \ { \ extern const char* AppControllerClassName; \ AppControllerClassName = #ClassName; \ } \ @end</span></span></code> </pre> <br>  Menggunakan makro ini di sumber Anda akan menambahkan kode yang dijelaskan dalam makro ke tubuh sumber Anda pada tahap kompilasi.  Makro ini melakukan hal berikut.  Pertama, ini akan menambahkan metode memuat ke antarmuka kelas Anda.  Antarmuka dalam konteks Objective-C dapat dianggap sebagai kumpulan bidang dan metode publik.  Di C #, metode beban statis akan muncul di kelas Anda yang tidak menghasilkan apa-apa.  Selanjutnya, implementasi metode pemuatan ini akan ditambahkan ke kode kelas Anda.  Dalam metode ini, variabel AppControllerClassName akan dideklarasikan, yang merupakan array dari tipe char dan kemudian variabel ini akan diberi nilai.  Nilai ini adalah nama string kelas Anda.  Jelas, informasi ini tidak cukup untuk memahami mekanisme operasi makro ini, oleh karena itu, kita harus memahami apa metode "memuat" ini dan mengapa suatu variabel dinyatakan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> mengatakan bahwa load adalah metode khusus yang dipanggil satu kali untuk setiap kelas (khususnya kelas, bukan instansnya) pada tahap awal peluncuran aplikasi, bahkan sebelum fungsi utama dipanggil.  Lingkungan runtime Objective-c (runtime) pada saat startup aplikasi akan mendaftarkan semua kelas yang akan digunakan selama operasi aplikasi dan akan memanggil metode load di dalamnya, jika diimplementasikan.  Ternyata bahkan sebelum dimulainya kode apa pun dalam aplikasi kita, variabel AppControllerClassName akan ditambahkan ke kelas Anda. <br><br>  Maka Anda mungkin berpikir: "Dan apa gunanya memiliki variabel ini jika dinyatakan di dalam metode dan akan dihapus dari memori ketika Anda keluar dari metode ini?".  Jawaban atas pertanyaan ini terletak sedikit di luar batas Objective-C. <br><br><h3>  Dan di mana C ++? </h3><br>  Mari kita lihat lagi deklarasi variabel ini <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* AppControllerClassName;</code> </pre> <br>  Satu-satunya hal yang mungkin tidak dapat dipahami dalam deklarasi ini adalah pengubah eksternal.  Jika Anda mencoba menggunakan pengubah ini di Objective-C murni, maka Xcode akan melempar kesalahan.  Faktanya adalah bahwa pengubah ini bukan bagian dari Objective-C, melainkan diimplementasikan dalam C ++.  Objective-C dapat secara ringkas dijelaskan dengan mengatakan bahwa itu adalah "bahasa C dengan kelas."  Ini adalah ekstensi dari bahasa C dan memungkinkan penggunaan kode C tanpa batas diselingi dengan kode Objective-C. <br><br>  Namun, untuk menggunakan fitur extern dan C ++ lainnya, Anda perlu melakukan beberapa trik - gunakan Objective-C ++.  Praktis tidak ada informasi tentang bahasa ini, karena fakta bahwa itu hanya kode Objective-C yang memungkinkan penyisipan kode C ++.  Agar kompiler mempertimbangkan bahwa beberapa file sumber harus dikompilasi sebagai Objective-C ++, dan bukan Objective-C, Anda hanya perlu mengubah ekstensi file ini dari <i>.m</i> ke <i>.mm</i> . <br><br>  Pengubah extern itu sendiri digunakan untuk mendeklarasikan variabel global.  Lebih tepatnya, untuk memberitahu kompiler ‚ÄúPercayalah, variabel seperti itu ada, tetapi memori untuk itu dialokasikan tidak di sini, tetapi di sumber lain.  Dan dia juga memiliki nilai, saya jamin. ‚Äù  Dengan demikian, baris kode kita hanya menciptakan variabel global dan menyimpan nama kelas khusus kita di dalamnya.  Tetap hanya untuk memahami di mana variabel ini dapat digunakan. <br><br><h3>  Kembali ke utama </h3><br>  Kami ingat apa yang dikatakan sebelumnya - delegasi aplikasi dibuat dengan menentukan nama kelas.  Jika delegasi dibuat menggunakan nilai konstan [kelas myClass] dalam template proyek Xcode biasa, maka, tampaknya, orang-orang dari Unity memutuskan bahwa nilai ini harus dibungkus dalam variabel.  Menggunakan metode poke ilmiah, kami mengambil proyek Xcode yang dihasilkan oleh Unity3D dan pergi ke file <i>main.mm.</i> <br><br>  Di dalamnya kita melihat kode yang lebih kompleks daripada sebelumnya, bagian dari kode ini hilang sebagai tidak perlu: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// WARNING: this MUST be c decl (NSString ctor will be called after +load, so we cant really change its value) const char* AppControllerClassName = "UnityAppController"; int main(int argc, char* argv[]) { ... UIApplicationMain(argc, argv, nil, [NSString stringWithUTF8String: AppControllerClassName]); } return 0; }</span></span></code> </pre> <br>  Di sini kita melihat deklarasi dari variabel ini, dan pembuatan delegasi aplikasi dengan bantuannya. <br>  Jika kami membuat delegasi khusus, maka variabel yang diperlukan ada dan sudah penting - nama kelas kami.  Mendeklarasikan dan menginisialisasi variabel sebelum fungsi utama memastikan bahwa ia memiliki nilai default - UnityAppController. <br><br>  Sekarang dengan keputusan ini semuanya harus sangat jelas. <br><br><h3>  Masalah makro </h3><br>  Tentu saja, untuk sebagian besar situasi, menggunakan makro ini adalah solusi yang bagus.  Tetapi perlu dicatat bahwa ada jebakan besar di dalamnya: Anda tidak dapat memiliki lebih dari satu delegasi khusus.  Ini terjadi karena jika 2 kelas atau lebih menggunakan makro IMPL_APP_CONTROLLER_SUBCLASS (ClassName), maka untuk yang pertama nilai dari variabel yang kita perlukan akan ditugaskan, dan penugasan lebih lanjut akan diabaikan.  Dan variabel ini adalah string, yaitu, tidak dapat ditetapkan lebih dari satu nilai. <br><br>  Anda mungkin berpikir bahwa masalah ini merosot dan tidak mungkin dalam praktiknya.  Tetapi, artikel ini tidak akan terjadi jika masalah seperti itu tidak benar-benar terjadi, dan bahkan dalam keadaan yang sangat aneh.  Situasinya mungkin sebagai berikut.  Anda memiliki proyek di mana Anda menggunakan banyak analitik dan layanan iklan.  Banyak dari layanan ini memiliki komponen Objective-C.  Mereka telah berada di proyek Anda untuk waktu yang lama dan Anda tidak tahu masalah dengan mereka.  Di sini Anda perlu menulis delegasi khusus.  Anda menggunakan makro ajaib yang dirancang untuk menyelamatkan Anda dari masalah, membangun proyek, dan mendapatkan laporan tentang keberhasilan perakitan.  Jalankan proyek di perangkat, dan fungsionalitas Anda tidak berfungsi dan Anda tidak menerima satu kesalahan pun. <br><br>  Dan masalahnya mungkin bahwa salah satu plugin iklan atau analitik menggunakan makro yang sama.  Misalnya, dalam plugin dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsFlyer</a> , makro ini digunakan. <br><br><h3>  Berapa nilai variabel extern dalam kasus deklarasi berganda? </h3><br>  Sangat menarik untuk mengetahui apakah variabel ekstern yang sama dideklarasikan dalam beberapa file, dan mereka diinisialisasi dengan cara makro kita (dalam metode memuat), lalu bagaimana kita bisa memahami nilai apa yang akan diambil oleh variabel?  Untuk memahami polanya, aplikasi uji sederhana telah dibuat, kode yang dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Inti dari aplikasi ini sederhana.  Ada 2 kelas A dan B, di kedua kelas variabel extern AexternVar dideklarasikan, ditugaskan nilai tertentu.  Nilai-nilai variabel di kelas diatur secara berbeda.  Dalam fungsi utama, nilai variabel ini dicatat.  Ditemukan secara eksperimental bahwa nilai variabel tergantung pada urutan sumber ditambahkan ke proyek.  Urutan runtime Objective-C mendaftarkan kelas selama eksekusi aplikasi tergantung pada ini.  Jika Anda ingin mengulangi percobaan, buka proyek dan pilih tab Bangun Fase di pengaturan proyek.  Karena proyek ini uji dan kecil, ia hanya memiliki 8 kode sumber.  Semuanya ada di tab Bangun Fase di daftar Sumber Kompilasi. <br><br><img src="https://habrastorage.org/webt/oi/ly/ln/oilylnhxdyjg3cvgcrj5nzhjvwy.png"><br><br>  Jika dalam daftar ini sumber kelas A lebih tinggi dari sumber kelas B, maka variabel akan mengambil nilai dari kelas B. Jika tidak, variabel akan mengambil nilai dari kelas A. <br><br>  Bayangkan saja berapa banyak masalah yang secara teoritis dapat menyebabkan ini adalah nuansa kecil.  Terutama jika proyek ini sangat besar, dihasilkan secara otomatis dan Anda tidak tahu di kelas mana variabel seperti itu dideklarasikan. <br><br><h3>  Pemecahan masalah </h3><br>  Sebelumnya dalam artikel tersebut, dikatakan bahwa Objective-C akan memberikan C # Reflection sebagai permulaan.  Khususnya, untuk menyelesaikan masalah kami, Anda dapat menggunakan mekanisme yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode Swizzling</a> .  Inti dari mekanisme ini adalah bahwa kita memiliki kesempatan untuk mengganti implementasi metode kelas mana pun dengan yang lain selama aplikasi.  Dengan demikian, kita dapat mengganti metode yang diminati di UnityAppController dengan yang kustom.  Kami mengambil implementasi yang ada dan melengkapi kode yang kami butuhkan.  Kami menulis kode yang menggantikan implementasi metode yang ada dengan yang kami butuhkan.  Selama pekerjaan aplikasi, delegasi yang menggunakan makro akan bekerja seperti sebelumnya, menyebut implementasi dasar UnityAppController, dan di sana metode kustom kami akan ikut bermain dan kami akan mencapai hasil yang diinginkan.  Pendekatan ini ditulis dengan baik dan diilustrasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> .  Dengan teknik ini, kita dapat membuat kelas tambahan - analog dari delegasi khusus.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di kelas ini, kita akan menulis semua kode khusus, menjadikan kelas khusus semacam Wrapper untuk memanggil fungsionalitas kelas lain. </font><font style="vertical-align: inherit;">Pendekatan ini akan berhasil, tetapi sangat implisit karena fakta bahwa sulit untuk melacak di mana metode tersebut diganti dan apa konsekuensi yang akan ditimbulkannya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solusi lain untuk masalah ini </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aspek utama dari masalah yang terjadi adalah bahwa ada banyak delegasi khusus, atau Anda hanya dapat memiliki satu, atau sebagian menggantinya dengan yang kedua. </font><font style="vertical-align: inherit;">Pada saat yang sama, tidak ada cara untuk memastikan bahwa kode delegasi khusus tidak masuk ke file sumber yang berbeda. </font><font style="vertical-align: inherit;">Ternyata situasinya dapat dianggap sebagai referensi ketika hanya ada satu delegasi dalam aplikasi, Anda harus dapat membuat kelas kustom sebanyak yang Anda suka, sementara tidak satu pun dari kelas ini menggunakan makro untuk menghindari masalah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya kecil, masih untuk menentukan bagaimana hal ini dapat dilakukan menggunakan Unity3D, sambil meninggalkan kemampuan untuk membangun proyek menggunakan mesin build. </font><font style="vertical-align: inherit;">Algoritma solusinya adalah sebagai berikut:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menulis delegasi khusus dalam jumlah yang diperlukan, membagi logika plugin ke dalam kelas yang berbeda, mengamati prinsip-prinsip SOLID dan tidak menggunakan kecanggihan. </font></font></li><li>       UnityAppController   XCode      .         UnityAppController   . </li><li>    UnityAppController     Unity . </li><li>     XCode     UnityAppController  ,       </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barang yang paling sulit dari daftar ini tidak diragukan lagi adalah yang terakhir. Namun, fitur ini dapat diimplementasikan di Unity3D menggunakan skrip build post-process. Skrip semacam itu ditulis pada suatu malam yang indah, Anda dapat menontonnya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasca proses ini cukup mudah digunakan, pilihlah dalam proyek Unity. Lihat di jendela Inspektur dan lihat bidang di sana bernama NewDelegateFile. Seret dan letakkan UnityAppController Anda yang dimodifikasi ke dalam bidang ini dan simpan.</font></font><br><br><img src="https://habrastorage.org/webt/zs/sb/l2/zssbl2ttito42xsbqwcpqzqfezs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat membangun proyek iOS, delegasi standar akan diganti dengan yang dimodifikasi, dan tidak diperlukan intervensi manual. </font><font style="vertical-align: inherit;">Sekarang, ketika menambahkan delegasi khusus ke proyek, Anda hanya perlu mengubah opsi UnityAppController yang ada di proyek Unity Anda.</font></font><br><br><h4>  PS </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih kepada semua orang yang sampai pada akhirnya, artikelnya ternyata sangat panjang. </font><font style="vertical-align: inherit;">Saya harap informasi yang dilukis sangat membantu.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430118/">https://habr.com/ru/post/id430118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430106/index.html">Baru di XYZprinting di IMTS 2018: Printer 3D dan Robot</a></li>
<li><a href="../id430108/index.html">Mengapa "Teknisi Muda" tidak akan bisa membuat laser</a></li>
<li><a href="../id430112/index.html">Bagaimana kami mengajar mobil berbicara dengan jutaan orang</a></li>
<li><a href="../id430114/index.html">Cara membuat mekanik game yang andal di Excel. Bagian 2</a></li>
<li><a href="../id430116/index.html">Komputer menulis prosa, tetapi masih kalah dengan orang. Mengapa</a></li>
<li><a href="../id430120/index.html">Menjinakkan binatang buas. Apa yang kami hadapi ketika mengembangkan aplikasi buku harian pribadi tentang React Native</a></li>
<li><a href="../id430122/index.html">Workaholism adalah kondisi menyakitkan yang tidak biasa untuk dibicarakan.</a></li>
<li><a href="../id430126/index.html">Daftar proyek lain untuk dipraktikkan</a></li>
<li><a href="../id430128/index.html">Pengembangan melalui pengujian: meningkatkan keterampilan</a></li>
<li><a href="../id430132/index.html">Apa yang kami pelajari tentang keamanan ME Intel dalam beberapa tahun terakhir: 7 fakta tentang subsistem misterius</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>