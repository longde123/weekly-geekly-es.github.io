<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘§ ğŸ‘¨ğŸ»â€ğŸ”¬ ğŸˆ·ï¸ .NET Core 3.0 (Pratinjau 6) Dirilis ğŸ‘¶ğŸ» ğŸ“¶ ğŸ¤ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pekan lalu, .NET Core 3.0 (Pratinjau 6) dirilis . Ini mencakup pembaruan kompilasi perakitan untuk meningkatkan peluncuran, meningkatkan optimasi ukur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET Core 3.0 (Pratinjau 6) Dirilis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/456218/"><p>  Pekan lalu, <a href="" rel="nofollow">.NET Core 3.0 (Pratinjau 6) dirilis</a> .  Ini mencakup pembaruan kompilasi perakitan untuk meningkatkan peluncuran, meningkatkan optimasi ukuran aplikasi dengan perbaikan pada tautan dan EventPipe.  Kami juga merilis gambar Docker baru untuk Alpine di ARM64. </p><br><ul><li><p>  <a href="" rel="nofollow">Unduh .NET Core 3.0 (Pratinjau 6)</a> di Windows, macOS, dan Linux. </p></li><li><p>  <a href="">Catatan rilis</a> diterbitkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnet / core</a> .  <a href="">Perbedaan API antara Pratinjau 5 dan 6</a> juga tersedia. </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASP.NET Core</a> dan EF Core juga dirilis minggu lalu. </p></li><li><p>  Jika Anda tidak terjawab, lihat pembaruan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">.NET Core 3.0 (Pratinjau 5)</a> bulan lalu. </p></li></ul><br><img src="https://habrastorage.org/webt/m8/il/ym/m8ilymhs6vkajgs1wfbpnzud3lw.jpeg"><a name="habracut"></a><br><br><h2>  Pembaruan Formulir WPF dan Windows </h2><br><p>  Tim WPF telah menyelesaikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proses penerbitan sebagian besar kode WPF di GitHub</a> .  Bahkan, mereka hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerbitkan kode sumber untuk lima belas build</a> .  Bagi mereka yang terbiasa dengan WPF, nama majelis harus sangat akrab. </p><br><p>  Dalam beberapa kasus, tes masih dalam tumpukan dan harus diterbitkan pada atau sebelum 3,0 GA.  Namun, memiliki semua kode ini harus memungkinkan komunitas WPF untuk sepenuhnya berpartisipasi dalam membuat perubahan ke WPF.  Setelah membaca beberapa masalah dengan GitHub, menjadi jelas bahwa komunitas memiliki tumpukan produk baru yang ingin Anda terapkan.  Apa pendapat Anda tentang topik gelap? </p><br><h2>  Gambar Alpine Docker </h2><br><p>  Gambar Docker sekarang tersedia untuk .NET Core dan ASP.NET Core di ARM64.  Sebelumnya, mereka hanya tersedia untuk x64. </p><br><p> Gambar-gambar berikut dapat digunakan di <code>Dockerfile</code> , atau dengan <code>docker pull</code> , seperti yang ditunjukkan di bawah ini: </p><br><ul><li> <code>docker pull mcr.microsoft.com/dotnet/core/runtime:3.0-alpine-arm64v8</code> </li> <li> <code>docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine-arm64v8</code> </li> </ul><br><h2>  Peningkatan Pipa Acara </h2><br><p>  Pipa Acara sekarang mendukung multi-profesionalitas. </p><br><p>  Penghitung kinerja baru ditambahkan: </p><br><ul><li>  % Waktu dalam GC </li><li>  Gen 0 Ukuran Tumpukan </li><li>  Gen 1 Heap Size </li><li>  Gen 2 Heap Size </li><li>  Ukuran Tumpukan LOH </li><li>  Tingkat alokasi </li><li>  Jumlah majelis dimuat </li><li>  Jumlah ThreadPool Threads </li><li>  Tingkat Kontensi Kunci Monitor </li><li>  Antrean Item Pekerjaan ThreadPool </li><li>  Tingkat Item Pekerjaan yang Diselesaikan ThreadPool </li></ul><br><p>  Bergabung profiler sekarang diimplementasikan menggunakan infrastruktur Pipa Acara yang sama. </p><br><p>  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Permainan</a> David Fowler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dengan Penghitung</a> untuk mendapatkan ide tentang apa yang dapat Anda lakukan dengan pipa acara untuk melakukan penelitian kinerja Anda sendiri atau hanya melacak keadaan aplikasi. </p><br><p>  Baca <a href="">dotnet-counter</a> untuk menginstal alat dotnet-counter. </p><br><h2>  Optimalkan Aplikasi .NET Core Anda dengan Gambar ReadyToRun </h2><br><p>  Anda dapat meningkatkan waktu mulai aplikasi .NET Core dengan mengkompilasi pembuatan aplikasi dalam format ReadyToRun (R2R).  R2R adalah bentuk kompilasi terkemuka (AOT). </p><br><p>  Binari R2R meningkatkan kinerja startup dengan mengurangi jumlah pekerjaan yang perlu dilakukan JIT ketika aplikasi dimuat.  Binari berisi kode mesin yang mirip dengan yang dihasilkan oleh JIT, yang memberi JIT istirahat saat kinerja paling penting (saat startup).  Binari dalam format R2R lebih besar karena mengandung kode bahasa perantara (IL), yang masih diperlukan untuk beberapa skenario, dan versi mesin dari kode yang sama untuk meningkatkan startup. </p><br><p>  R2R didukung oleh .NET Core 3.0.  Itu tidak dapat digunakan dengan versi .NET Core sebelumnya. </p><br><h3>  Contoh Angka Kinerja </h3><br><p>  Berikut ini adalah gambar yang menunjukkan kinerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sampel aplikasi WPF</a> .  Aplikasi ini diterbitkan sebagai standalone dan tidak menggunakan tautan tautan (dibahas nanti dalam artikel ini). </p><br><p>  Aplikasi hanya IL: </p><br><ul><li>  Waktu mulai: 1,9 detik </li><li>  Penggunaan Memori: 69.1 MB </li><li>  Ukuran Aplikasi: 150 MB </li></ul><br><p>  Dengan gambar ReadyToRun: </p><br><ul><li>  Waktu mulai: 1,3 detik. </li><li>  Penggunaan memori: 55,7 MB </li><li>  Ukuran Aplikasi: 156 MB </li></ul><br><h2>  Baca lebih lanjut tentang gambar ReadyToRun </h2><br><p>  Anda dapat mengkompilasi R2R baik perpustakaan dan file aplikasi biner.  Saat ini, perpustakaan hanya dapat dikompilasi ke dalam R2R sebagai bagian dari aplikasi, dan tidak untuk pengiriman sebagai paket NuGet.  Kami ingin umpan balik lebih lanjut tentang apakah skenario ini penting. </p><br><p>  Kompilasi majelis AOT telah lama tersedia sebagai konsep untuk .NET, kembali ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">.NET Framework dan NGEN</a> .  Kelemahan utama NGEN adalah kompilasi harus dilakukan pada mesin klien menggunakan alat NGEN.  Tidak mungkin menghasilkan gambar NGEN sebagai bagian dari pembuatan aplikasi Anda. </p><br><p>  Sekarang .NET Core.  Muncul dengan <a href="">crossgen</a> , yang menghasilkan gambar mesin dalam format <a href="">ReadyToRun yang</a> baru.  Nama tersebut menggambarkan nilai intinya, yaitu bahwa gambar-gambar mesin ini dapat dibuat sebagai bagian dari rakitan Anda dan â€œsiap dijalankanâ€ tanpa ada pekerjaan tambahan pada mesin klien.  Ini merupakan peningkatan besar, sekaligus kemenangan penting dalam perang melawan perubahan iklim. </p><br><p>  Dalam hal kompatibilitas, gambar ReadyToRun mirip dengan rakitan IL dengan beberapa perbedaan utama. </p><br><ul><li>  Majelis IL hanya berisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kode IL</a> .  Mereka dapat bekerja di lingkungan runtime yang mendukung infrastruktur target yang ditentukan untuk perakitan ini.  Misalnya, <code>netstandard2.0</code> build dapat berjalan di .NET Framework 4.6+ dan .NET Core 2.0+, pada sistem operasi apa pun yang didukung (Windows, macOS, Linux) dan arsitektur (Intel, ARM, 32-bit, 64-bit). </li><li>  Majelis R2R berisi IL dan kode asli.  Mereka dikompilasi untuk versi minimum spesifik .NET Core runtime dan lingkungan runtime (RID).  misalnya, <code>netstandard2.0</code> build dapat dikompilasi R2R untuk .NET Core 3.0 dan Linux x64.  Ini hanya akan digunakan dalam konfigurasi ini atau yang kompatibel (misalnya, .NET Core 3.1 atau .NET Core 5.0 di Linux x64), karena berisi kode asli yang hanya dapat digunakan dalam lingkungan runtime ini. </li></ul><br><h3>  Instruksi </h3><br><p>  Kompilasi ReadyToRun hanya tersedia untuk publikasi.  Versi pratinjau dirilis dalam .NET Core 3.0 (Pratinjau 5). </p><br><p>  Untuk mengaktifkan kompilasi ReadyToRun, Anda perlu: </p><br><ul><li>  Setel nilai properti <code>PublishReadyToRun</code> menjadi <code>true</code> . </li><li>  Posting menggunakan <code>RuntimeIdentifier</code> tepat. </li></ul><br><p>  Catatan  Ketika build aplikasi dikompilasi, kode asli yang dihasilkan tergantung pada platform dan arsitektur (oleh karena itu, ketika menerbitkan, Anda harus menentukan RuntimeIdentifier yang valid). </p><br><p>  Berikut ini sebuah contoh: </p><br><pre> <code class="cs hljs">&lt;Project Sdk=<span class="hljs-string"><span class="hljs-string">"Microsoft.NET.Sdk"</span></span>&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3<span class="hljs-number"><span class="hljs-number">.0</span></span>&lt;/TargetFramework&gt; &lt;PublishReadyToRun&gt;<span class="hljs-literal"><span class="hljs-literal">true</span></span>&lt;/PublishReadyToRun&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt;</code> </pre> <br><p>  Dan penerbitan menggunakan perintah berikut: </p><br><pre> <code class="cs hljs">dotnet publish -r win-x64 -c Release</code> </pre> <br><p>  Catatan: <code>RuntimeIdentifier</code> dapat diatur dalam file proyek. </p><br><p>  Catatan: ReadyToRun saat ini hanya didukung untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">aplikasi yang berdiri sendiri</a> .  Ini akan ditambahkan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">aplikasi yang bergantung</a> pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kerangka kerja</a> dalam pengumuman nanti. </p><br><p>  <code>PublishReadyToRunEmitSymbols</code> karakter mesin dapat diaktifkan dengan menyetel properti <code>PublishReadyToRunEmitSymbols</code> menjadi <code>true</code> .  Anda tidak perlu membuat karakter mesin untuk keperluan debugging.  Karakter-karakter ini hanya berguna untuk keperluan pembuatan profil. </p><br><p>  Saat ini, SDK mendukung cara untuk mengeluarkan rakitan tertentu dari kompilasi ke dalam gambar ReadyToRun.  Ini dapat berguna dalam kasus-kasus di mana majelis tidak perlu dioptimalkan untuk meningkatkan kinerja.  Tidak termasuk majelis dalam hal ini dapat membantu mengurangi ukuran aplikasi.  Dalam kasus ketika kompiler ReadyToRun gagal mengkompilasi rakitan tertentu, solusinya mungkin juga untuk menghilangkannya. </p><br><p>  Pengecualian dilemparkan menggunakan grup elemen PublishReadyToRunExclude: </p><br><pre> <code class="cs hljs">&lt;ItemGroup&gt; &lt;PublishReadyToRunExclude Include=<span class="hljs-string"><span class="hljs-string">"FilenameOfAssemblyToExclude.dll"</span></span> /&gt; &lt;/ItemGroup&gt;</code> </pre> <br><h2>  Kompilasi lintas platform / arsitektur </h2><br><p>  Kompiler ReadyToRun belum mendukung penargetan silang.  Anda perlu mengkompilasi untuk tujuan yang diberikan.  Misalnya, jika Anda memerlukan gambar R2R untuk Windows x64, Anda harus menjalankan perintah publish di lingkungan ini. </p><br><p>  Pengecualian: </p><br><ul><li>  Windows x64 dapat digunakan untuk mengkompilasi gambar Windows ARM32, ARM64, dan x86. </li><li>  Windows x86 dapat digunakan untuk mengkompilasi gambar Windows ARM32. </li><li>  Linux x64 dapat digunakan untuk mengkompilasi gambar Linux ARM32 dan ARM64. </li></ul><br><h2>  Tata letak perakitan </h2><br><p>  NET core 3.0 SDK dilengkapi dengan alat yang dapat mengurangi ukuran aplikasi dengan menganalisis IL dan menghilangkan build yang tidak digunakan. </p><br><p>  Dengan .NET Core, Anda selalu dapat menerbitkan aplikasi mandiri yang mencakup semua yang Anda perlukan untuk menjalankan kode Anda, tanpa harus menginstal .NET pada target penyebaran.  Dalam beberapa kasus, aplikasi hanya membutuhkan sebagian kecil kerangka kerja, dan bisa dibuat lebih kecil dengan memasukkan hanya perpustakaan yang digunakan. </p><br><p>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembangun IL</a> untuk memindai IL aplikasi Anda untuk menentukan kode apa yang sebenarnya diperlukan, dan kemudian mengecualikan pustaka kerangka kerja yang tidak digunakan.  Ini secara signifikan dapat mengurangi ukuran beberapa aplikasi.  Sebagai aturan, aplikasi konsol kecil seperti alat mendapatkan manfaat terbesar, karena mereka sering menggunakan himpunan bagian kecil dari kerangka kerja dan biasanya cocok untuk tanam. </p><br><p>  Untuk menggunakan alat ini, atur <code>PublishTrimmed=true</code> dalam proyek Anda dan publikasikan aplikasi mandiri: </p><br><pre> <code class="cs hljs">dotnet publish -r &lt;rid&gt; -c Release</code> </pre> <br><p>  Output publikasi akan mencakup subset dari perpustakaan infrastruktur, tergantung pada kode aplikasi mana yang digunakan.  Untuk aplikasi helloworld, tautan mengurangi ukuran dari ~ 68 MB hingga ~ 28 MB. </p><br><p>  Aplikasi atau kerangka kerja (termasuk ASP.NET Core dan WPF) yang menggunakan refleksi atau fungsi dinamis terkait sering rusak ketika memotong karena linker tidak mengetahui perilaku dinamis ini dan biasanya tidak dapat menentukan jenis kerangka kerja apa yang akan diperlukan untuk refleksi saat runtime .  Untuk memangkas aplikasi semacam itu, Anda harus memberi tahu tautan tentang jenis apa saja yang diperlukan untuk refleksi dalam kode Anda dan dalam paket atau lingkungan apa pun yang Anda andalkan.  Pastikan untuk menguji aplikasi Anda setelah memotong. </p><br><p>  Untuk informasi lebih lanjut tentang IL Linker, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dokumentasi</a> atau kunjungi repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mono / linker</a> . </p><br><p>  Catatan: Dalam versi .NET Core sebelumnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">ILLink.Tasks</a> dikirimkan sebagai paket NuGet eksternal dan menyediakan sebagian besar fungsi yang sama.  Tidak lagi didukung - tingkatkan ke SDK 3.0 versi terbaru. </p><br><h2>  Linker dan ReadToRun Linker Sharing </h2><br><p>  Linker Linker dan ReadyToRun Linker dapat digunakan untuk aplikasi yang sama.  Secara umum, penghubung membuat aplikasi Anda lebih kecil, dan kemudian kompiler yang siap dijalankan akan membuatnya sedikit lebih besar lagi, tetapi dengan peningkatan kinerja yang signifikan.  Perlu menguji berbagai konfigurasi untuk memahami efek dari setiap opsi. </p><br><p>  Catatan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnet / sdk # 3257</a> mencegah tautan dan berbagi ReadyToRun untuk aplikasi WPF dan Windows Forms.  Kami sedang berupaya untuk memperbaikinya sebagai bagian dari rilis .NET Core 3.0. </p><br><h2>  Sampel Hosting Asli </h2><br><p>  Baru-baru ini menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sampel Hosting Asli</a> .  Ini menunjukkan pendekatan terbaik untuk hosting .NET Core dalam aplikasi asli. </p><br><p>  Dalam kerangka. NET Core 3.0, kami sekarang menyediakan fungsionalitas umum untuk layanan .NET Core hosting kami sendiri, yang sebelumnya hanya tersedia untuk aplikasi .NET Core yang dikelola melalui layanan hosting Core NET yang disediakan secara resmi.  Fungsionalitas terutama terkait dengan memuat rakitan.  Fungsionalitas ini akan membuatnya lebih mudah untuk membuat layanan hosting Anda sendiri yang dapat menggunakan berbagai fitur .NET Core. </p><br><h2>  Dukungan HTTP / 2 di HttpClient </h2><br><p>  HTTP / 2 adalah versi utama dari protokol HTTP.  Beberapa fitur penting dari HTTP / 2 adalah dukungan kompresi tajuk dan aliran multipleks sepenuhnya melalui satu koneksi.  Meskipun HTTP / 2 mempertahankan semantik HTTP (header HTTP, metode, dll.), Ini berbeda dari HTTP / 1.x dalam cara data dikirim. </p><br><p>  <code>HttpClient</code> sekarang mendukung permintaan HTTP / 2.  Secara default, semuanya juga tetap HTTP / 1.1, tetapi Anda dapat menyisih darinya demi HTTP / 2 dengan menginstal versi menggunakan permintaan HTTP. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// HTTP/1.1 request using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); } // HTTP/2 request using (var request = new HttpRequestMessage(HttpMethod.Get, "/") { Version = new Version(2, 0) }) using (var response = await client.SendAsync(request)) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  Atau, Anda dapat mengirim permintaan HTTP / 2 secara default dengan mengatur <code>DefaultRequestVersion</code> ke <code>HttpClient</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>), DefaultRequestVersion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Version(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// Defaults to HTTP/2 using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  Sebagai akibat dari perubahan ini, server dan klien harus menyetujui versi protokol yang digunakan.  ALPN (Application-Layer Protocol Negotiation) adalah ekstensi TLS yang memungkinkan server dan klien untuk menegosiasikan versi protokol yang digunakan sebagai bagian dari interaksi mereka.  Namun, perlu diingat bahwa sebagian besar server hanya mendukung ALPN sebagai satu-satunya cara untuk membuat koneksi HTTP / 2.  Dengan demikian, HTTP / 2 dinegosiasikan oleh <code>HttpClient</code> hanya melalui koneksi TLS. </p><br><p>  Dalam skenario pengembangan, ketika server dan klien mengetahui apriori bahwa keduanya akan berbicara HTTP / 2 tanpa enkripsi, Anda dapat membuat koneksi HTTP / 2 melalui cleartext dengan mengatur sakelar <code>AppContext</code> atau variabel lingkungan.  ( <code>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT=1</code> ). </p><br><pre> <code class="cs hljs">AppContext.SetSwitch(<span class="hljs-string"><span class="hljs-string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><h2>  Penyelesaian </h2><br><p>  Kami akan sangat senang jika Anda mencoba fitur baru.  Silakan laporkan masalah atau bug yang Anda temukan.  Anda juga dapat mengirim permintaan untuk fitur baru, tetapi implementasinya harus menunggu hingga rilis berikutnya. </p><br><p>  Sekarang kami hampir menyelesaikan pekerjaan pada komponen .NET Core 3.0 dan sekarang kami mengalihkan perhatian tim untuk meningkatkan kualitas rilis.  Kami memiliki waktu beberapa bulan sebelum perbaikan bug dan peningkatan kinerja. </p><br><p>  Ngomong-ngomong, untuk pembaruan besar berikutnya, kita akan mengganti cabang <code>master</code> di repositori .NET Core.  Kemungkinan besar ini akan terjadi segera setelah Pratinjau 7 pada bulan Juli. </p><br><p>  Terima kasih telah menguji .NET Core 3.0.  Kami menghargai bantuan Anda.  Saat ini, kami fokus untuk menjadikan versi final yang paling menarik dan berkualitas tinggi untuk Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456218/">https://habr.com/ru/post/id456218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456206/index.html">Bagaimana Moovit meningkatkan aplikasinya untuk membantu para penyandang cacat naik transit dengan percaya diri</a></li>
<li><a href="../id456208/index.html">90 miliar rubel untuk pengembangan kecerdasan buatan</a></li>
<li><a href="../id456210/index.html">Bagaimana aplikasi seluler membantu siswa dengan masalah penglihatan bergerak di sekitar Moskow</a></li>
<li><a href="../id456214/index.html">Gunakan __main__.py</a></li>
<li><a href="../id456216/index.html">Membuat game retro dari tahun 80-an atau cara memasak mock-up untuk memotong laser</a></li>
<li><a href="../id456220/index.html">Generalisasi masalah Brokar</a></li>
<li><a href="../id456222/index.html">Rekayasa genetika embrio manusia akan menjadi aman dan efektif dalam dua tahun</a></li>
<li><a href="../id456224/index.html">Mengumumkan Pratinjau .NET Core 3.0 6</a></li>
<li><a href="../id456226/index.html">Prediksi hasil sepakbola</a></li>
<li><a href="../id456230/index.html">Iobroker mencari petualangan di game realitas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>