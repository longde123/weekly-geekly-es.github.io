<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔄 🤱🏿 🕵🏾 So stellen Sie Videos für Full Throttle Remastered wieder her. Teil 2 👈🏾 🎆 🙏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Beitrag habe ich darüber gesprochen, wie wir Inhalte aus FMV-Quelldateien extrahiert und Tools zum Analysieren von ca. 67 GB Arch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So stellen Sie Videos für Full Throttle Remastered wieder her. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422367/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1de/374/14c/1de37414cbdd0d9728e11244fd636b5f.png" alt="Bild"></div><br>  In meinem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag habe</a> ich darüber gesprochen, wie wir Inhalte aus FMV-Quelldateien extrahiert und Tools zum Analysieren von ca. 67 GB Archiven auf der Suche nach Zwischenkomponenten zum Erstellen von FMV erstellt haben.  Diese Teile bilden die Grundlage für die Erstellung remasterter FMV-Inhalte und wurden als „Montagezeichnungen“ verwendet, um das Projekt zu starten. <br><br>  Wie im vorherigen Artikel erwähnt, ist der Remastering-Workflow in drei Zweige unterteilt: Remastering von handgezeichneten Frames, Remastering von 3D-Modellen und Sound-Remastering.  Im Folgenden werde ich auf die Funktionen des Workflows und die Tricks eingehen, mit denen wir die Erstellung des Hauptteils des Videos automatisiert haben. <br><a name="habracut"></a><br>  Wir haben die Größe aller handgezeichneten Originalrahmen erhöht, um sie an die Auflösung von 4K (3840 x 2160) anzupassen.  Unter Berücksichtigung der zusätzlichen Breite der überarbeiteten Szene und der Tatsache, dass das Spiel in nicht quadratischen Pixeln angezeigt wurde, mussten alle remasterten Ressourcen mit einer Auflösung von 4440 x 2400 Pixel erstellt werden. <br><br>  Wir haben uns für Adobe Animate entschieden, um alle handgezeichneten FMV-Frames zu remastern, da wir nach der Entwicklung von Day of the Tentacle Remastered bereits einen vorgefertigten Workflow hatten.  Das Künstlerteam hat diesen Prozess gut gemeistert, daher haben wir andere Optionen nicht in Betracht gezogen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/b57/098/3e2b57098e68ff84ee833c7b56a3ad35.gif"></div><br>  <em>Beispiel für das Remastering eines handgezeichneten Rahmens</em> <br><br>  Die ursprünglichen 3D-Modelle aus den Archiven befanden sich in 3D Studio Release 3. Glücklicherweise konnten moderne Versionen von 3D Studio Max alle Daten der Netze und filmischen Keyframes mithilfe eines anderen Automatisierungsskripts importieren.  Danach haben wir diese Zwischendatei in Autodesk Maya konvertiert, wo Künstler ihre Remastering-Magie ausführen. <br><br>  Um den Oberflächen der Netze einen neuen Stil zu verleihen, wurden neue Shader angewendet, hochwertige Texturen angewendet und diese Netze wurden erheblich ergänzt, um dem Modell ein glatteres Aussehen zu verleihen.  Darüber hinaus wurde das Rahmenfenster für alle Videoaufnahmekameras erweitert, um einer Arbeitsauflösung von 4440 x 2400 Pixel zu entsprechen, da die Originalkamera für ein engeres Seitenverhältnis ausgelegt war. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df9/949/7bd/df99497bdfb6c540ef07e330cb9142b8.gif"></div><br>  <em>Beispiel für das Remastering von 3D-Modellen</em> <br><br>  In Bezug auf Audio konnten wir die meisten hochwertigen Originalversionen finden, aber es gab Ausnahmen.  Die Aufnahmen des englischsprachigen Synchronstudios wurden in Archive gepackt, aber das Synchronisieren in anderen Sprachen, die von externen Partnern durchgeführt wurden, stand uns nicht zur Verfügung.  Außerdem haben wir es geschafft, die Originalmusik von The Gone Jackals zu finden, die in FMV verwendet wurde.  Einige Versionen von Soundeffekten (SFX) wurden durch "dichtere" Klänge mit einer ähnlichen Klangart ersetzt. <br><br>  Im Folgenden finden Sie ein Flussdiagramm, in dem grob erläutert wird, wie wir die Quellressourcen verarbeitet und mit remasterten Inhalten verknüpft haben.  Die ursprünglich extrahierten (mit SanExtract.exe) Videobilder wurden als „Quelle“ für den Vergleich mit allen Archivdatendateien verwendet.  Archivmanifestdateien werden mithilfe einer rekursiven Suche aller Archivdaten generiert.  Sie wurden verwendet, um schnell alle eindeutigen Dateien eines bestimmten Typs zu finden. <br><br>  Das SanWrangler-Tool wurde verwendet, um die ursprüngliche „Quelle“ von Frames und archivierten Daten visuell zu vergleichen.  Der Benutzer kann Archivdateien visuell an die Originalrahmen anhängen und diese als Abhängigkeitskarte im XML-Format speichern.  Nach dem Erstellen der Abhängigkeitszuordnung war es ausreichend, ein Python-Skript zu verwenden, um automatisch manuell gezeichnete Rahmen aus den ursprünglichen Ressourcen der Zeichnungsdatei sowie aus Baugruppenzeichnungen für Maya 3D zu generieren.  Diese Dateien wurden zum Ausgangspunkt für das Künstlerteam, das dann mit dem Remastering fortfuhr. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/fa0/30a/c2dfa030a1899e9fb679ebd17caf1ee2.png"></div><br>  <em>Originalressourcen extrahieren und „Montagezeichnungen“ erstellen</em> <br><br>  Dies war der erste von vielen Schritten, die dazu führten, dass wir fertige FMV-Remaster-Versionen erhielten.  Ja, natürlich haben wir jetzt den Ausgangspunkt aller Dateien, die erneut erstellt werden müssen, aber wie können alle diese Fragmente miteinander verbunden werden? <br><br>  Im Folgenden werde ich auf die Automatisierungsmethoden eingehen, die im FMV-Fertigungsworkflow verwendet werden.  Diese Methoden können nicht nur zum Generieren von FMV verwendet werden und gelten nicht nur für ein Spiel.  Ich denke, sie sind ziemlich universell und können in vielen Aspekten der Spieleentwicklung verwendet werden. <br><br>  Wie bei den meisten Workflows zur Grafikerstellung ist dieser Prozess iterativ.  Irgendwo in der Quelldatei kann es einen Fehler geben, der vom Künstler behoben werden muss, und manchmal war es notwendig, ressourcenabhängige Dateien erneut zu exportieren.  Ich denke, wir alle würden es vorziehen, wenn diese Arbeit von einem Computer und nicht von einer fehleranfälligen Person ausgeführt wird. <br><br>  Wir wussten genau, wie das Video für Full Throttle Remastered aussehen und klingen sollte, daher mussten wir nur die Grafik und den Sound verbessern.  Alle Videos mussten Frame für Frame mit den Originalen übereinstimmen, einschließlich Kamerapfaden, Tonlautstärke, Schwenken usw.  Um dies zu erreichen, mussten wir wissen, wie der Workflow beim Erstellen von Original-FMVs aussah.  Und diese 67 GB Daten aus den LucasArts-Archiven enthielten viele Hinweise darauf, wie alles im Original funktionierte.  Sie waren ein großartiger Start für uns. <br><br><h1>  Der Prozess der Erstellung des ursprünglichen FMV </h1><br>  Es mag ein wenig nostalgisch klingen, aber ich denke, es ist wichtig, die Aspekte der „digitalen Archäologie“ dieses Remasters von Spielen zu diskutieren.  Wenn Sie den Prozess der Erstellung des Originals verstehen, können Sie viele Fragen beantworten und Hinweise geben, wie aus Ressourcen ein fertiges Ergebnis wurde.  Und wenn wir neue überarbeitete FMVs erstellen, müssen wir dieselben Transformationen auf unsere ursprünglichen überarbeiteten Ressourcen anwenden, damit das fertige Produkt dem Original so nahe wie möglich kommt.  Einschließlich brauchten wir Folgendes: <br><br><ul><li>  Position der Audiospuren auf der Timeline </li><li>  Lautstärke- und Schwenkeinstellungen für Audiospuren beim Spielen im Spiel </li><li>  Rahmenzusammensetzung und Platzierung jedes Videorahmens im fertigen Produkt </li></ul><br>  Mit einem Tool namens SMUSHFT (SMUSH für Vollgas) konnte der Ersteller von FMV Video- und Audioressourcen auf der Timeline platzieren und dann den resultierenden FMV-Film (im .san-Format) codieren, der von der Spiel-Engine gelesen wurde.  Alle Videos wurden in eine Reihe von Frames unterteilt, die zusammengeklebt wurden, um das Endergebnis zu erzielen.  Mit SMUSHFT konnte der Benutzer diese Ressourcen visuell entlang der Zeitachse verschieben und das Video bei Bedarf wiederholen. <br><br>  Sie können nicht erwähnen, dass ich nicht an der Erstellung des Originalspiels teilgenommen habe.  Ich konnte nur raten, wie die ursprünglichen Ressourcen erstellt wurden, archivierte Daten studierten und Formate und ausführbare Dateien betrachteten, die in diese Daten gepackt waren.  Es scheint, dass 3D-Modelle in Autodesk 3D Studio Release 3 erstellt wurden und handgezeichnete Teile in DeluxePaint Animation v1.0 erstellt wurden.  Ich weiß auch nicht, aus welchen Stufen die Erzeugung von Wellenformdaten für Audio bestand, aber jeder verwendete Audioclip (im .sad-Format) enthält Informationen über die Lautstärke und das Schwenken nach Keyframes, die zum Mischen von Sound während des Spiels verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/921/61a/c0392161ae29aa540fe78d7a6485a232.png"></div><br>  <em>Der Prozess der Erstellung des ursprünglichen FMV</em> <br><br>  Nach dem Erstellen dieser separaten Teile des Rahmens wurde der Prozess des Kombinierens des Rahmens durchgeführt.  Bei diesem Prozess wurden 3D-Frame-Renderings mit handgezeichneten Animationsframes (zusammen mit allem anderen) kombiniert und ein fertiges Produkt erstellt, das vom SMUSHFT-Tool verwendet wird (.nut-Dateien).  Nachdem das Projekt für die Codierung bereit war, wurde das Video verarbeitet und das fertige Ergebnis (.san) konnte bereits in der Spiel-Engine abgespielt werden. <br><br>  SMUSHFT führte die endgültige Codierung des Dateiformats des Originalvideos (.san) durch, und jede Videodatei verfügte über eine Projektdatei (.pro), die die Zusammenstellung des Videos (Ton, Video, Position der Untertitel) beschrieb.  Wir wollten diese Informationen extrahieren, damit wir die Adobe Premiere Pro-Projektdatei generieren und damit die konvertierte Version des Videos in 4K-Auflösung codieren können.  Dazu mussten wir die SMUSHFT-Projektdatei zurückentwickeln. <br><br><h1>  Reverse Engineering-Dateiformate </h1><br>  Es ist großartig, Quellcode zu haben, da Sie ihn einfach studieren und verstehen können, wie die Projektdatei erstellt / gelesen wurde.  Ohne Quellcode müssen Sie die Projektdatei in einem Hex-Editor öffnen und die Muster in der Datei analysieren.  Genau so haben wir nützliche Inhalte aus der SMUSHFT-Projektdatei extrahiert. <br><br>  Da wir die ursprüngliche SMUSHFT in DOSBox ausführen konnten, sahen wir die Benutzeroberfläche des Programms, die uns Hinweise zum Dateiformat gab.  Schauen Sie sich diesen Screenshot zum Öffnen der ursprünglichen .pro-Datei an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/854/63b/cbb85463b67ad09d81d939f442f9fdc0.png"></div><br>  <em>Beispiel für ein SMUSHFT-Projekt</em> <br><br>  Hier können Sie Folgendes feststellen: Die Datei enthält benannte Ressourcen (2027.NUT, 2027.SAD, IN_06A.NUT usw.).  Solche benannten Ressourcen zeigen wahrscheinlich ASCII-Zeichen in der Datei an.  Darüber hinaus befinden sich am oberen Rand der Timeline Frame-Zähler, und links von der Timeline befinden sich zunehmende Layernummern.  Und die letzte - jede Ressource auf der Timeline befindet sich auf einer bestimmten Frame-Nummer und hat eine bestimmte Dauer.  Wenn wir diese Informationen aus den ursprünglichen Projektdateien extrahieren können, erfahren wir, wo automatisch neue Ressourcen in der Adobe Premiere Pro-Zeitleiste platziert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/de5/904/3e5de59049c14a72bb8373a0c72b48a0.png"></div><br>  <em>Beispielprojekt für Adobe Premiere Pro</em> <br><br>  Wenn Sie die ursprüngliche Projektdatei in einem Hex-Editor öffnen, erhalten Sie einige nützliche Informationen.  Schauen Sie sich das obige Beispiel hexadezimal an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/008/054/b5f00805485c3d4a8af811c4dc359063.png"></div><br>  <em>SMUSHFT-Projektdatei im Hex-Editor</em> <br><br>  Wir können die .pro-Datei mit einem Hex-Editor (ich bevorzuge Hexplorer) betrachten und versuchen, nach Mustern zu suchen.  Sie können benannte Ressourcen im ASCII-Format mit einem Null-Byte am Ende leicht finden.  Ungefähr im selben Speicherbereich befindet sich eine Gruppe von Werten, die als Kurzschlüsse gespeichert sind (Doppelbyte-Ganzzahl).  Vergleichen der in SMUSHFT angezeigten Zahlen mit <br>  Die Zahlen aus der Projektdatei im Hex-Format geben uns die Grundlage für die korrekte Konvertierung der ursprünglichen Projektdatei in einen modernen Videoeditor wie Adobe Premiere Pro. <br><br><h1>  Automatisierungs-Toolkit </h1><br>  Der Großteil dieses Workflows war automatisiert und erforderte kein menschliches Eingreifen.  Einer der Gründe dafür war, dass der Inhalt aller Videos vollständig vom Original kopiert wurde.  Tatsächlich haben wir nur den Inhalt aktualisiert.  Daher hatten wir praktisch keine Gelegenheit, das FMV-Format vollständig zu ändern.  Wir mussten nur einen Weg finden, um das Video mit hochauflösenden Ressourcen neu zu erstellen und gleichzeitig den Zeitaufwand für das Produkt zu minimieren. <br><br>  Zunächst muss ich sagen, dass ein ernsthafter erster Schritt vor der Automatisierung des gesamten Prozesses ein Gespräch mit einem Team von Inhaltserstellern (Grafik und Audio) sein sollte.  Der Grund dafür ist, dass bei den meisten Automatisierungsprozessen die Ersteller bestimmte Regeln für die Vorbereitung von Projekten, Speicherorten, verwendeten Tools usw. einhalten müssen.  In unserem Projekt bedeutete dies, dass wir Werkzeuge zum Erstellen des Inhalts von handgezeichneten Rahmen, 3D-Modellen und Sounds diskutieren und dann einen Video-Editor, um all dies zusammenzusetzen.  Es musste auch vereinbart werden, welche Teile des Workflows manuell ausgeführt und welche automatisiert werden. <br><br>  Infolgedessen haben wir Folgendes entschieden: <br><br><ul><li>  Manuell gezeichnete Frames werden in Adobe Animate mit einer Auflösung von 4440 x 2400 Pixel erstellt. </li><li>  3D-Modelle und -Animationen werden in Autodesk Maya erstellt und manuell gerendert, ebenfalls mit einer Auflösung von 4440 x 2400 Pixel </li><li>  Audiodateien werden im WAV-Format mit 48-kHz- und 16-Bit-Parametern erstellt </li><li>  Fragmente des Videos werden zunächst automatisch generiert, und der Künstler kann jeden Teil ändern, den er benötigt (mit einigen Ausnahmen). </li><li>  Die letzten Schritte des Zusammenfügens und Codierens von FMV werden automatisiert </li></ul><br>  Um die Tools so automatisiert wie möglich zu gestalten, haben wir verschiedene Methoden verwendet.  Python wurde als „Klebstoff“ ausgewählt, der alles miteinander verbindet, da es durch verschiedene Bibliotheken gut erweitert wird und der Code einfach zu schreiben und zu warten ist.  Wir haben auch die interne Unterstützung für plattformunabhängige Dateimanipulationen (Kopieren, Verschieben, Löschen) genutzt. <br><br><h2>  Python - Ausführen von ausführbaren Dateien, Erhalten von Ergebnissen </h2><br>  Die Python-Unterprozessbibliothek war ideal für uns, da Sie damit die Ausführung anderer ausführbarer Dateien ändern und sogar auf den Abschluss ihrer Aufgaben warten können.  Sie können den vom Programm zurückgegebenen Code abrufen und auf den Puffer stdout &amp; stderr zugreifen. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-comment"><span class="hljs-comment"># The command to execute command = 'SanExtract.exe -f -i credits.san -o \"C:/output_dir/\" ' # Execute the command via subprocess child = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) # Wait for process to complete, returns stdout &amp; stderr buffers stdout, stderr = child.communicate() # Retrieve the return code from the process return_code = child.returncode</span></span></code> </pre> <br>  <em>Ein Beispiel für die Interaktion mit ausführbaren Dateien in Python</em> <br><br><h2>  Python - Win32 API </h2><br>  Die Win32-API ist sehr nützlich, da sie uns den Zugriff auf die Übertragung von Tastatur- und Mausnachrichten von Windows über ein Skript ermöglichte.  Sie können beispielsweise eine Funktion erstellen, die in bestimmten X- und Y-Koordinaten des Bildschirms mit der Maus klickt: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClickXY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span><span class="hljs-function">:</span></span> win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Beispiel für eine Python-Mausklicksimulation</em> <br><br>  Sie können sogar Tastenanschlagereignisse an die Tastatur senden (mit oder ohne Modifikatoren): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32con <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PressKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code, modifierCode=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) time.sleep(<span class="hljs-number"><span class="hljs-number">0.021</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Beispiel für eine Python-Tastatursimulation</em> <br><br>  Es gibt viele andere Möglichkeiten, aber die obigen Beispiele haben wirklich dazu beigetragen, unsere Ziele zu erreichen.  Sie können Tastaturereignisse an jedes aktive Programm senden, und es beginnt mit der Eingabe, als würden wir etwas über die Tastatur eingeben, einschließlich des Drückens von Tastenkombinationen. <br><br><h2>  Python - Computer Vision zum Klicken auf Schaltflächen </h2><br>  Die einzigartigste Erfahrung war die Verwendung von Computer Vision-Software in Tools, die nicht durch interne Skripte automatisiert werden konnten.  Die meisten modernen Tools unterstützen Skripte, erfordern jedoch immer noch Benutzereingriffe.  Mit 3D Studio Max können Sie beispielsweise MAXScript-Dateien über die Befehlszeile ausführen.  In unserem Fall führen wir das Skript aus, um die 3D-Netzdatei automatisch zu importieren. Anschließend wird 3D Studio Max automatisch gestartet und das Dialogfeld Formimport angezeigt, in dem der Benutzer auf die Schaltflächen klicken muss: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/b3e/4f9/ddcb3e4f9a830a8e72d9697eacf19b74.png"></div><br>  <em>Beispieldialogfeld Formimport</em> <br><br>  Also - wir haben ein Skript für die Automatisierung geschrieben, und jetzt müssen wir vor dem Bildschirm sitzen und die Tasten drücken?  Anstatt an der Tastatur zu sitzen und darauf zu warten, dass das Popup-Fenster angezeigt wird, können wir das Skript einen Screenshot machen lassen, die OpenCV-Bindung an Python verwenden, um die Schaltflächenbildvorlage zu finden und automatisch darauf zu klicken.  So sieht die Bildvorlage für das oben beschriebene Beispiel aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/67c/af3/b1e67caf30b4ea94761063bb6ead063c.png"></div><br>  <em>Bildvorlage für ok_button.png</em> <br><br>  Es ist zu beachten, dass die Bildvorlage zusätzliche Funktionen enthält (Text für „Einzelobjekt“ und „Mehrere Objekte“).  Dies ermöglicht es uns, ein deterministischeres Suchergebnis zu erhalten.  Das folgende Beispiel ist ein Python-Skript, mit dem automatisch auf einen gefundenen Speicherort einer Bildvorlage geklickt wird: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageGrab <span class="hljs-comment"><span class="hljs-comment"># "Constants" TEMPLATE_THRESHOLD = 0.25 CLICK_OFFSET = 20 # Read the template image to search for template_image = cv2.imread('images/ok_button.png', 0) # Screenshot the current desktop and load it to a cv2 format screen = ImageGrab.grab() screen.save('screen.png') screen_image = cv2.imread('screen.png', 0) # Search for the template within the screenshot and retrieve search results match_result = cv2.matchTemplate(screen_image, template_image, cv2.TM_SQDIFF_NORMED) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(match_result) # If below the threshold, it's likely we know where to click if min_val &lt; TEMPLATE_THRESHOLD: ClickXY(min_loc[0]+CLICK_OFFSET, min_loc[1]+CLICK_OFFSET)</span></span></code> </pre> <br>  <em>Ein Beispiel für das Klicken auf ein Anzeigeelement mit OpenCV, geschrieben in Python</em> <br><br>  Alle obigen Beispiele basieren auf Python.  Es gibt jedoch Zeiten, in denen wir eine genauere Kontrolle über das Windows-Betriebssystem-Fenstersystem benötigen.  Dies führte dazu, dass wir native Tools mithilfe der Windows-Automatisierungs-API entwickelten. <br><br><h2>  Windows Native (C ++) - Windows-Automatisierungs-API </h2><br>  Die Windows-Automatisierungs-API bietet Zugriff auf die ältere Microsoft Active Accessibility-API (MSAA) sowie auf die Microsoft UI-Automatisierungs-API.  Weitere Informationen hierzu finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Microsoft-Seite</a> . <br><br>  Als Ergebnis haben wir die Tatsache erreicht, dass wir bestimmte Elemente der Windows-Oberfläche (Schaltflächen, Textfelder, Registerkarten, Menüelemente) anfordern, herausfinden konnten, wo sich diese Elemente räumlich auf dem Bildschirm befinden, und mit ihnen klicken / interagieren konnten.  Das Windows SDK verfügt auch über Testtools, mit denen Sie sehen können, welche Eigenschaften verfügbar sind.  Sie ermöglichten es uns herauszufinden, was in jedem spezifischen Programm automatisiert werden kann. <br><br>  Die Inspect.exe-Anwendung ist sehr nützlich, um die Hierarchie der Programmfensterverwaltung anzuzeigen.  Es bietet eine ungefähre Vorstellung davon, wo sich Objekte wie Menüsteuerelemente befinden und wie mithilfe von Automatisierungs-API-Aufrufen auf Fensterelemente verwiesen wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/d3f/650/0f2d3f650f30c4982f10d9d31b94c35c.png"></div><br>  <em>Beispiel Inspect.exe</em> <br><br>  Nachdem Sie die Steuerelementhierarchie des Windows-Programms kennengelernt haben, erfahren Sie, wie Sie sie im Handle des Hauptfensters finden und wie Sie über die API auf verschiedene Elemente klicken: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Click on a sub-menu item given the Window &amp; Menu handles. void ClickSubMenu(HWND hwnd, HMENU hmenu, const char *pMenuName) { // Iterate through the menu items of the window int menu_item_count = GetMenuItemCount(hmenu); for(int menu_id = 0; menu_id &lt; menu_item_count; ++menu_id) { char menu_name[MAX_PATH]; int len = GetMenuString(hmenu, menu_id, reinterpret_cast&lt;LPSTR&gt;(&amp;menu_name[0]), sizeof(menu_name), MF_BYPOSITION); // Look for the specific menu you're searching for and click it // Make sure to set the window active before doing it... if(!strcmp(pMenuName, menu_name)) { // now get the rect and click the center RECT rect; BOOL success = GetMenuItemRect(hwnd, hmenu, menu_id, &amp;rect); if(success) { SetActiveWindow(hwnd); POINT point = GetMiddlePoint(rect); SetCursorPos(point.x, point.y); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, point.x, point.y, 0, 0); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTUP, point.x, point.y, 0, 0); Sleep(DO_TASK_INTERVAL_WAIT_MS); } } } }</span></span></span></span></code> </pre> <br>  <em>Ein Beispiel für das Verschieben eines Fenstersteuerelements in C ++</em> <br><br>  Das Übergeben von Tastenanschlägen an das aktive Fenster ist natürlich auch einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Type the character string to the given window handle static void TypeCharacters(HWND window_handle, const char *pString) { int len = strlen(pString); for(int count = 0; count &lt; len; ++count) { SendMessage(window_handle, WM_CHAR, (WPARAM)pString[count], (LPARAM)0); Sleep(CHARACTER_REPEAT_INTERVAL_MS); } }</span></span></span></span></code> </pre> <br>  <em>Beispiel für eine C ++ - Tastatursimulation</em> <br><br>  Natürlich haben diese APIs viel mehr Funktionen.  Ich habe festgestellt, dass Sie dank des Tools Inspect.exe Aufschluss darüber geben können, auf welche Elemente des Programmfensters zugegriffen werden kann. <br><br><h2>  Zwischentextformate </h2><br>  Ein Teil unseres Workflows bestand darin, die Dateien in Textform zu speichern und die Werte in diesen Textdateien zu ändern.  Am Ende haben die Werkzeuge eine Benutzeroberfläche zum Ändern des Status der Hilfsdaten.  Und wenn Sie wissen, wie diese Hilfsdaten aussehen sollen, müssen Sie nicht mit dem Tool arbeiten, sondern nur die Hilfsdaten ändern.  Der Trick besteht darin, zu wissen, wie diese unterstützenden Daten manipuliert werden.  Wenn Sie proprietäre Dateiformate ändern, kann dies eine Herausforderung sein.  Wäre es nicht schön, wenn jeder eine einfache Textdatei hätte, mit der Sie arbeiten können? <br><br>  Der Trick besteht darin, einen Weg zu finden, um die proprietären Dateiformate zu umgehen, die von den meisten Tools verwendet werden.  Die Lösung besteht normalerweise darin, die Import- und Exportoptionen zu verwenden, die in den meisten modernen kommerziellen Tools zu finden sind.  Hier einige Beispiele: <br><br>  Adobe Premiere Pro speichert Dateien in einem proprietären Format. Sie können Projekte jedoch als Final Cut Pro XML importieren / exportieren.  Nach dem Export in XML können Sie das XML nach Bedarf ändern und das Projekt wieder in Adobe Premiere Pro importieren. <br><br>  Ein weiteres Beispiel ist die Korrektur von Texturreferenzen, die im veralteten 3D-Netzformat von Autodesk 3D Studio Release 3 verwendet werden. Beim Importieren der ursprünglichen Netzdatei speichern wir das neu konvertierte Netz mithilfe von ASCII-Zeichen in einer .fbx-Zwischendatei.  In diesem Format können Sie eine Textdatei verarbeiten und alle Zeilen von Texturverknüpfungen durch die richtigen ersetzen. <br><br>  Adobe Animate / Flash ist ziemlich lustig, da sich herausstellt, dass .fla-Dateien tatsächlich etwas "kaputte" .zip-Dateien sind.  In unkomprimierter Form werden sie im XFL-Format gespeichert, das auf andere XFL-Objekte (z. B. Bitmaps) aus einem lokalen Ordner verweisen kann.  Oliver Franzke, leitender Ingenieur von Double Fine, hat ein modifiziertes Python-Skript zum Packen / Entpacken von .fla-Dateien mithilfe von ZIP erstellt, damit wir diese Dateien erstellen / ändern können. <br><br><h1>  Anwendungsbeispiele </h1><br><h2>  3D Studio max </h2><br>  Die moderne Version von 3D Studio Max wurde verwendet, um die ursprüngliche PRJ-Datei in die Szene zu importieren und im ASCII-Format .fbx zu speichern.  Für jede .prj-Datei, die konvertiert werden musste, wurde automatisch eine MaxScript-Datei (.ms) aus dem Python-Skript generiert, die ungefähr so ​​aussah: <br><br><pre> <code class="bash hljs">importFile <span class="hljs-string"><span class="hljs-string">"G:\FullThrottle_Backup\FullThrottle_SourceAssets\BENBIKE.PRJ"</span></span> <span class="hljs-comment"><span class="hljs-comment">#noPrompt</span></span></code> </pre> <br>  <em>Beispiel für den Import eines 3D-Modells mit MaxScript</em> <br><br>  Danach wurde diese MS-Datei einfach vom Python-Befehl aufgerufen, um in 3dsmax.exe ausgeführt zu werden: <br><br><pre> <code class="bash hljs">3dsmax.exe -U MAXScript <span class="hljs-string"><span class="hljs-string">"C:\FullThrottleRemastered\import_prj.ms"</span></span></code> </pre> <br>  <em>Ein Beispiel für einen Konsolenbefehl zum Aufrufen einer ausführbaren Datei mit der angegebenen MaxScript-Datei</em> <br><br>  Wie oben erwähnt, öffnete 3D Studio Max in diesem Fall ein Dialogfeld, auf das Sie klicken mussten.  Das OpenCV-Bundle mit Python hat dazu beigetragen, auf die Schaltfläche in diesem Fenster zu klicken, damit die Originaldatei ohne Benutzereingriff importiert wird.  Nach dem Importieren der Datei wurde eine Reihe von Menütasten (unter Verwendung von win32api Python) gedrückt, um eine weitere MAXScript-Datei zu starten, die das Modell als .fbx-Datei im ASCII-Format exportierte.  Da .fbx als reguläre Textdatei gespeichert wurde, wurden alle Abhängigkeiten der Modelltexturabhängigkeiten durch Links zu Bildern in einem modernen Format ersetzt.  Anschließend wurde die geänderte .fbx-Datei erneut automatisch in 3DSMax geladen und als .max-Datei exportiert.  Zu diesem Zeitpunkt könnte die .max-Datei zum Remastering an den Künstler gesendet werden. <br><br><h2>  Adobe Animate / Flash </h2><br>  Adobe Animate / Flash wurde verwendet, um alle handgezeichneten FMV-Ressourcen zu remastern.  Wir haben die vom SanWrangler-Tool gefundenen handgezeichneten Originalrahmen (320 x 200 Pixel groß) als „Montagezeichnungen“ verwendet.  Der Bildmaßstab wurde auf 4440 x 2400 Pixel vergrößert. Anschließend wurde mithilfe eines Python-Skripts automatisch eine .fla-Datei generiert. <br><br>  Dann genügte es, die .fla-Datei automatisch von Grund auf neu zu generieren, wobei wir unser Wissen über das XFL-Format Adobe Animate / Flash nutzten.  Mit dem bereits von Oliver Franzke erstellten Toolkit konnten wir Montagezeichnungen von handgezeichneten Animationsdateien erstellen. <br><br><h2>  Adobe Premiere Pro </h2><br>  Die Windows-Automatisierungs-API hat uns wirklich dabei geholfen, festzustellen, welche Premiere Pro-Steuerelemente auf dem Bildschirm angezeigt werden.  In einigen Fällen hatten sie keine Hotkeys.  Nach dem Empfang der Koordinaten der Menüelemente musste der Cursor auf diese Koordinaten bewegt und ein Mausklickereignis gesendet werden. <br><br>  All dies ist großartig, aber einige Steuerelemente werden auf andere Weise gerendert und sind daher für die Windows-Automatisierungs-API nicht sichtbar.  In diesem Fall haben wir uns für OpenCV und Python entschieden, um OpenCV in einer Skriptumgebung verwenden zu können.  Dies war besonders nützlich, wenn Sie mit Adobe Premiere Pro arbeiten: Obwohl JavaScript-Skripts teilweise unterstützt werden, war die Art der erforderlichen Steuerung über die API nicht verfügbar. <br><br>  Darüber hinaus werden Adobe Premiere Pro-Projektdateien in einem proprietären Binärformat gespeichert.  Daher konnten wir die Premiere Pro-Datei nicht nur auf magische Weise erstellen, sondern auch die Importfunktion verwenden, mit der wir die Daten in die Final Cut Pro-Datei im XML-Format importieren konnten.  Dann genügte es, die richtige XML-Datei zu generieren, alle Ressourcen auf der Timeline entsprechend zu positionieren und diese XML-Datei Final Cut Pro automatisch zu importieren, um sie in das gewünschte Format zu konvertieren.  Dann könnten wir die exportierten Frames in eine automatisierte Warteschlange stellen, um sie zu einem fertigen Video zu kombinieren. <br><br><h1>  Alle Stufen </h1><br>  Unten finden Sie ein verallgemeinertes Blockdiagramm, das alle automatisierten Teile eines neuen Workflows zeigt.  Jedes automatisierte Segment ist von einem abgerundeten Rechteck mit zusätzlichen Informationen zu den verwendeten Automatisierungstechniken umgeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f26/2c7/7cf/f262c77cf9d06f1fb6828e356ce40cc8.png"></div><br>  <em>Vereinfachtes überarbeitetes FMV-Automatisierungsflussdiagramm</em> <br><br>  Sie werden feststellen, dass für die meisten Arbeiten mit Adobe Premiere Pro Python sowie spezieller nativer Windows-Code erforderlich sind.  Der Grund ist die komplexe Struktur von Premiere Pro-Fenstern sowie die Notwendigkeit, die native Windows-Automatisierungs-API zu verwenden, um eine ordnungsgemäße Interaktion mit allen abhängigen untergeordneten Fenstern dieser Anwendung sicherzustellen. <br><br><h1>  Alle zusammen </h1><br>  Mit den oben beschriebenen Methoden konnten wir mehrere Automatisierungsmaschinen konfigurieren, um die Arbeit an allen Videos in Teile aufzuteilen.  Außerdem wurde ein Slack Bot in den Workflow integriert, um je nach Status der Videos, die die Verarbeitungspipeline durchlaufen, Feedback zur Automatisierung an unseren Slack-Kanal zu senden, damit wir wissen, wenn etwas schief geht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/36d/f19/9b536df197475f6235282ac084c2efc8.gif"></div><br>  <em>Beispiel für die Automatisierung von Adobe Premiere Pro</em> <br><br><h1>  Die Probleme, mit denen wir konfrontiert sind </h1><br>  Das klingt alles großartig, aber tatsächlich sind wir bei der Implementierung des Projekts auf Probleme gestoßen.  Ich werde nur die Hauptpunkte auflisten. <br><br>  1) Iteration des Mischens des fertigen Audios.  Das Remastering aller Audiodateien wurde schrittweise durchgeführt.  Als wir zum Beispiel den Soundeffekt „BOOM!“ Hatten, hatte der Toningenieur keine Ahnung, wo er in den Audio-Mix eingefügt werden sollte, und musste warten, bis das Video codiert war, um herauszufinden, was schief gelaufen war. <br><br>  2) Speicherung unkomprimierter Zwischendateien.  Die Frames wurden bis zum letzten Moment der Codierung in das fertige Video im unkomprimierten Format gespeichert.  Daher war es notwendig, eine große Anzahl von Frames im lokalen Speicher zu speichern, von denen einige im Versionskontrollsystem gespeichert waren.  Eine solche Erhöhung des gespeicherten Volumens war sehr auffällig und kann bei Verwendung einiger Versionskontrollsysteme (wir haben Perforce verwendet) recht teuer sein. <br><br>  3) Vorlaufzeit.  Ein fester Teil des Workflows wurde automatisiert, und dies ermöglichte den Ingenieuren, andere Dinge zu tun.  Die Zeit zum Erstellen eines Videos kann jedoch sehr lang sein.  Der zeitaufwändigste Teil ist das Codieren von Frames in 4k-Auflösung.  Wir hatten Möglichkeiten, den Zustand der Ressourcen in Perforce zu untersuchen, um zu verstehen, welche Schritte erneut ausgeführt werden müssen, aber diese Methode war nicht so in Teile unterteilt, wie wir es gerne hätten. <br><br><h1>  Nächste Schritte </h1><br>  Ja, der Artikel erwies sich als umfangreich!  Obwohl unsere Implementierung dieses Workflows für das Projekt sehr spezifisch ist, glaube ich, dass bestimmte Automatisierungsmethoden bei der Entwicklung jedes Spiels verwendet werden können.  Nachdem Sie das Video herausgefunden haben, können Sie ein verwandtes Thema betrachten - das Spielen von FMV während der Spielausführung.  Dies umfasst Probleme wie das Codieren eines mehrsprachigen Audiostreams sowie die Framesynchronisation bei der Wiedergabe von Original-FMV.  Warten Sie auf den dritten Teil des Artikels! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422367/">https://habr.com/ru/post/de422367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422345/index.html">Server in den Clouds: Projektzusammenfassung</a></li>
<li><a href="../de422347/index.html">Migration einer echten Anwendung von eigenständigem MySQL zu Percona XtraDB Cluster</a></li>
<li><a href="../de422351/index.html">Remote-Codeausführung durch Laden von Bildern auf Ihren Server oder lokalen Computer in Ghostscript / Imagick</a></li>
<li><a href="../de422363/index.html">PyCon Russia 2018 Konferenz: Video aller Berichte und Präsentationen</a></li>
<li><a href="../de422365/index.html">Yandex reichte eine Beschwerde gegen eine Gerichtsentscheidung ein, um Links zu Raubkopien zu entfernen</a></li>
<li><a href="../de422369/index.html">Entwerfen von Dashboards für die E-Commerce-Website für Webanalysen. Teil 2: E-Mail-Newsletter. Strategisches Dashboard</a></li>
<li><a href="../de422371/index.html">Bewertung des Elektrofahrrads Twitter TW-E9L</a></li>
<li><a href="../de422373/index.html">Wir laden Sie zu Open Source-Treffen im September ein (Moskau und St. Petersburg).</a></li>
<li><a href="../de422375/index.html">Verträge sind anders oder was Sie unterschrieben haben</a></li>
<li><a href="../de422377/index.html">ESP8266 + FLProg - Benutzersystemparameter und Synchronisation mit dem genauen Zeitserver</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>