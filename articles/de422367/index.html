<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÑ ü§±üèø üïµüèæ So stellen Sie Videos f√ºr Full Throttle Remastered wieder her. Teil 2 üëàüèæ üéÜ üôèüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Beitrag habe ich dar√ºber gesprochen, wie wir Inhalte aus FMV-Quelldateien extrahiert und Tools zum Analysieren von ca. 67 GB Arch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So stellen Sie Videos f√ºr Full Throttle Remastered wieder her. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422367/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1de/374/14c/1de37414cbdd0d9728e11244fd636b5f.png" alt="Bild"></div><br>  In meinem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag habe</a> ich dar√ºber gesprochen, wie wir Inhalte aus FMV-Quelldateien extrahiert und Tools zum Analysieren von ca. 67 GB Archiven auf der Suche nach Zwischenkomponenten zum Erstellen von FMV erstellt haben.  Diese Teile bilden die Grundlage f√ºr die Erstellung remasterter FMV-Inhalte und wurden als ‚ÄûMontagezeichnungen‚Äú verwendet, um das Projekt zu starten. <br><br>  Wie im vorherigen Artikel erw√§hnt, ist der Remastering-Workflow in drei Zweige unterteilt: Remastering von handgezeichneten Frames, Remastering von 3D-Modellen und Sound-Remastering.  Im Folgenden werde ich auf die Funktionen des Workflows und die Tricks eingehen, mit denen wir die Erstellung des Hauptteils des Videos automatisiert haben. <br><a name="habracut"></a><br>  Wir haben die Gr√∂√üe aller handgezeichneten Originalrahmen erh√∂ht, um sie an die Aufl√∂sung von 4K (3840 x 2160) anzupassen.  Unter Ber√ºcksichtigung der zus√§tzlichen Breite der √ºberarbeiteten Szene und der Tatsache, dass das Spiel in nicht quadratischen Pixeln angezeigt wurde, mussten alle remasterten Ressourcen mit einer Aufl√∂sung von 4440 x 2400 Pixel erstellt werden. <br><br>  Wir haben uns f√ºr Adobe Animate entschieden, um alle handgezeichneten FMV-Frames zu remastern, da wir nach der Entwicklung von Day of the Tentacle Remastered bereits einen vorgefertigten Workflow hatten.  Das K√ºnstlerteam hat diesen Prozess gut gemeistert, daher haben wir andere Optionen nicht in Betracht gezogen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/b57/098/3e2b57098e68ff84ee833c7b56a3ad35.gif"></div><br>  <em>Beispiel f√ºr das Remastering eines handgezeichneten Rahmens</em> <br><br>  Die urspr√ºnglichen 3D-Modelle aus den Archiven befanden sich in 3D Studio Release 3. Gl√ºcklicherweise konnten moderne Versionen von 3D Studio Max alle Daten der Netze und filmischen Keyframes mithilfe eines anderen Automatisierungsskripts importieren.  Danach haben wir diese Zwischendatei in Autodesk Maya konvertiert, wo K√ºnstler ihre Remastering-Magie ausf√ºhren. <br><br>  Um den Oberfl√§chen der Netze einen neuen Stil zu verleihen, wurden neue Shader angewendet, hochwertige Texturen angewendet und diese Netze wurden erheblich erg√§nzt, um dem Modell ein glatteres Aussehen zu verleihen.  Dar√ºber hinaus wurde das Rahmenfenster f√ºr alle Videoaufnahmekameras erweitert, um einer Arbeitsaufl√∂sung von 4440 x 2400 Pixel zu entsprechen, da die Originalkamera f√ºr ein engeres Seitenverh√§ltnis ausgelegt war. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df9/949/7bd/df99497bdfb6c540ef07e330cb9142b8.gif"></div><br>  <em>Beispiel f√ºr das Remastering von 3D-Modellen</em> <br><br>  In Bezug auf Audio konnten wir die meisten hochwertigen Originalversionen finden, aber es gab Ausnahmen.  Die Aufnahmen des englischsprachigen Synchronstudios wurden in Archive gepackt, aber das Synchronisieren in anderen Sprachen, die von externen Partnern durchgef√ºhrt wurden, stand uns nicht zur Verf√ºgung.  Au√üerdem haben wir es geschafft, die Originalmusik von The Gone Jackals zu finden, die in FMV verwendet wurde.  Einige Versionen von Soundeffekten (SFX) wurden durch "dichtere" Kl√§nge mit einer √§hnlichen Klangart ersetzt. <br><br>  Im Folgenden finden Sie ein Flussdiagramm, in dem grob erl√§utert wird, wie wir die Quellressourcen verarbeitet und mit remasterten Inhalten verkn√ºpft haben.  Die urspr√ºnglich extrahierten (mit SanExtract.exe) Videobilder wurden als ‚ÄûQuelle‚Äú f√ºr den Vergleich mit allen Archivdatendateien verwendet.  Archivmanifestdateien werden mithilfe einer rekursiven Suche aller Archivdaten generiert.  Sie wurden verwendet, um schnell alle eindeutigen Dateien eines bestimmten Typs zu finden. <br><br>  Das SanWrangler-Tool wurde verwendet, um die urspr√ºngliche ‚ÄûQuelle‚Äú von Frames und archivierten Daten visuell zu vergleichen.  Der Benutzer kann Archivdateien visuell an die Originalrahmen anh√§ngen und diese als Abh√§ngigkeitskarte im XML-Format speichern.  Nach dem Erstellen der Abh√§ngigkeitszuordnung war es ausreichend, ein Python-Skript zu verwenden, um automatisch manuell gezeichnete Rahmen aus den urspr√ºnglichen Ressourcen der Zeichnungsdatei sowie aus Baugruppenzeichnungen f√ºr Maya 3D zu generieren.  Diese Dateien wurden zum Ausgangspunkt f√ºr das K√ºnstlerteam, das dann mit dem Remastering fortfuhr. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/fa0/30a/c2dfa030a1899e9fb679ebd17caf1ee2.png"></div><br>  <em>Originalressourcen extrahieren und ‚ÄûMontagezeichnungen‚Äú erstellen</em> <br><br>  Dies war der erste von vielen Schritten, die dazu f√ºhrten, dass wir fertige FMV-Remaster-Versionen erhielten.  Ja, nat√ºrlich haben wir jetzt den Ausgangspunkt aller Dateien, die erneut erstellt werden m√ºssen, aber wie k√∂nnen alle diese Fragmente miteinander verbunden werden? <br><br>  Im Folgenden werde ich auf die Automatisierungsmethoden eingehen, die im FMV-Fertigungsworkflow verwendet werden.  Diese Methoden k√∂nnen nicht nur zum Generieren von FMV verwendet werden und gelten nicht nur f√ºr ein Spiel.  Ich denke, sie sind ziemlich universell und k√∂nnen in vielen Aspekten der Spieleentwicklung verwendet werden. <br><br>  Wie bei den meisten Workflows zur Grafikerstellung ist dieser Prozess iterativ.  Irgendwo in der Quelldatei kann es einen Fehler geben, der vom K√ºnstler behoben werden muss, und manchmal war es notwendig, ressourcenabh√§ngige Dateien erneut zu exportieren.  Ich denke, wir alle w√ºrden es vorziehen, wenn diese Arbeit von einem Computer und nicht von einer fehleranf√§lligen Person ausgef√ºhrt wird. <br><br>  Wir wussten genau, wie das Video f√ºr Full Throttle Remastered aussehen und klingen sollte, daher mussten wir nur die Grafik und den Sound verbessern.  Alle Videos mussten Frame f√ºr Frame mit den Originalen √ºbereinstimmen, einschlie√ülich Kamerapfaden, Tonlautst√§rke, Schwenken usw.  Um dies zu erreichen, mussten wir wissen, wie der Workflow beim Erstellen von Original-FMVs aussah.  Und diese 67 GB Daten aus den LucasArts-Archiven enthielten viele Hinweise darauf, wie alles im Original funktionierte.  Sie waren ein gro√üartiger Start f√ºr uns. <br><br><h1>  Der Prozess der Erstellung des urspr√ºnglichen FMV </h1><br>  Es mag ein wenig nostalgisch klingen, aber ich denke, es ist wichtig, die Aspekte der ‚Äûdigitalen Arch√§ologie‚Äú dieses Remasters von Spielen zu diskutieren.  Wenn Sie den Prozess der Erstellung des Originals verstehen, k√∂nnen Sie viele Fragen beantworten und Hinweise geben, wie aus Ressourcen ein fertiges Ergebnis wurde.  Und wenn wir neue √ºberarbeitete FMVs erstellen, m√ºssen wir dieselben Transformationen auf unsere urspr√ºnglichen √ºberarbeiteten Ressourcen anwenden, damit das fertige Produkt dem Original so nahe wie m√∂glich kommt.  Einschlie√ülich brauchten wir Folgendes: <br><br><ul><li>  Position der Audiospuren auf der Timeline </li><li>  Lautst√§rke- und Schwenkeinstellungen f√ºr Audiospuren beim Spielen im Spiel </li><li>  Rahmenzusammensetzung und Platzierung jedes Videorahmens im fertigen Produkt </li></ul><br>  Mit einem Tool namens SMUSHFT (SMUSH f√ºr Vollgas) konnte der Ersteller von FMV Video- und Audioressourcen auf der Timeline platzieren und dann den resultierenden FMV-Film (im .san-Format) codieren, der von der Spiel-Engine gelesen wurde.  Alle Videos wurden in eine Reihe von Frames unterteilt, die zusammengeklebt wurden, um das Endergebnis zu erzielen.  Mit SMUSHFT konnte der Benutzer diese Ressourcen visuell entlang der Zeitachse verschieben und das Video bei Bedarf wiederholen. <br><br>  Sie k√∂nnen nicht erw√§hnen, dass ich nicht an der Erstellung des Originalspiels teilgenommen habe.  Ich konnte nur raten, wie die urspr√ºnglichen Ressourcen erstellt wurden, archivierte Daten studierten und Formate und ausf√ºhrbare Dateien betrachteten, die in diese Daten gepackt waren.  Es scheint, dass 3D-Modelle in Autodesk 3D Studio Release 3 erstellt wurden und handgezeichnete Teile in DeluxePaint Animation v1.0 erstellt wurden.  Ich wei√ü auch nicht, aus welchen Stufen die Erzeugung von Wellenformdaten f√ºr Audio bestand, aber jeder verwendete Audioclip (im .sad-Format) enth√§lt Informationen √ºber die Lautst√§rke und das Schwenken nach Keyframes, die zum Mischen von Sound w√§hrend des Spiels verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/921/61a/c0392161ae29aa540fe78d7a6485a232.png"></div><br>  <em>Der Prozess der Erstellung des urspr√ºnglichen FMV</em> <br><br>  Nach dem Erstellen dieser separaten Teile des Rahmens wurde der Prozess des Kombinierens des Rahmens durchgef√ºhrt.  Bei diesem Prozess wurden 3D-Frame-Renderings mit handgezeichneten Animationsframes (zusammen mit allem anderen) kombiniert und ein fertiges Produkt erstellt, das vom SMUSHFT-Tool verwendet wird (.nut-Dateien).  Nachdem das Projekt f√ºr die Codierung bereit war, wurde das Video verarbeitet und das fertige Ergebnis (.san) konnte bereits in der Spiel-Engine abgespielt werden. <br><br>  SMUSHFT f√ºhrte die endg√ºltige Codierung des Dateiformats des Originalvideos (.san) durch, und jede Videodatei verf√ºgte √ºber eine Projektdatei (.pro), die die Zusammenstellung des Videos (Ton, Video, Position der Untertitel) beschrieb.  Wir wollten diese Informationen extrahieren, damit wir die Adobe Premiere Pro-Projektdatei generieren und damit die konvertierte Version des Videos in 4K-Aufl√∂sung codieren k√∂nnen.  Dazu mussten wir die SMUSHFT-Projektdatei zur√ºckentwickeln. <br><br><h1>  Reverse Engineering-Dateiformate </h1><br>  Es ist gro√üartig, Quellcode zu haben, da Sie ihn einfach studieren und verstehen k√∂nnen, wie die Projektdatei erstellt / gelesen wurde.  Ohne Quellcode m√ºssen Sie die Projektdatei in einem Hex-Editor √∂ffnen und die Muster in der Datei analysieren.  Genau so haben wir n√ºtzliche Inhalte aus der SMUSHFT-Projektdatei extrahiert. <br><br>  Da wir die urspr√ºngliche SMUSHFT in DOSBox ausf√ºhren konnten, sahen wir die Benutzeroberfl√§che des Programms, die uns Hinweise zum Dateiformat gab.  Schauen Sie sich diesen Screenshot zum √ñffnen der urspr√ºnglichen .pro-Datei an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/854/63b/cbb85463b67ad09d81d939f442f9fdc0.png"></div><br>  <em>Beispiel f√ºr ein SMUSHFT-Projekt</em> <br><br>  Hier k√∂nnen Sie Folgendes feststellen: Die Datei enth√§lt benannte Ressourcen (2027.NUT, 2027.SAD, IN_06A.NUT usw.).  Solche benannten Ressourcen zeigen wahrscheinlich ASCII-Zeichen in der Datei an.  Dar√ºber hinaus befinden sich am oberen Rand der Timeline Frame-Z√§hler, und links von der Timeline befinden sich zunehmende Layernummern.  Und die letzte - jede Ressource auf der Timeline befindet sich auf einer bestimmten Frame-Nummer und hat eine bestimmte Dauer.  Wenn wir diese Informationen aus den urspr√ºnglichen Projektdateien extrahieren k√∂nnen, erfahren wir, wo automatisch neue Ressourcen in der Adobe Premiere Pro-Zeitleiste platziert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/de5/904/3e5de59049c14a72bb8373a0c72b48a0.png"></div><br>  <em>Beispielprojekt f√ºr Adobe Premiere Pro</em> <br><br>  Wenn Sie die urspr√ºngliche Projektdatei in einem Hex-Editor √∂ffnen, erhalten Sie einige n√ºtzliche Informationen.  Schauen Sie sich das obige Beispiel hexadezimal an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/008/054/b5f00805485c3d4a8af811c4dc359063.png"></div><br>  <em>SMUSHFT-Projektdatei im Hex-Editor</em> <br><br>  Wir k√∂nnen die .pro-Datei mit einem Hex-Editor (ich bevorzuge Hexplorer) betrachten und versuchen, nach Mustern zu suchen.  Sie k√∂nnen benannte Ressourcen im ASCII-Format mit einem Null-Byte am Ende leicht finden.  Ungef√§hr im selben Speicherbereich befindet sich eine Gruppe von Werten, die als Kurzschl√ºsse gespeichert sind (Doppelbyte-Ganzzahl).  Vergleichen der in SMUSHFT angezeigten Zahlen mit <br>  Die Zahlen aus der Projektdatei im Hex-Format geben uns die Grundlage f√ºr die korrekte Konvertierung der urspr√ºnglichen Projektdatei in einen modernen Videoeditor wie Adobe Premiere Pro. <br><br><h1>  Automatisierungs-Toolkit </h1><br>  Der Gro√üteil dieses Workflows war automatisiert und erforderte kein menschliches Eingreifen.  Einer der Gr√ºnde daf√ºr war, dass der Inhalt aller Videos vollst√§ndig vom Original kopiert wurde.  Tats√§chlich haben wir nur den Inhalt aktualisiert.  Daher hatten wir praktisch keine Gelegenheit, das FMV-Format vollst√§ndig zu √§ndern.  Wir mussten nur einen Weg finden, um das Video mit hochaufl√∂senden Ressourcen neu zu erstellen und gleichzeitig den Zeitaufwand f√ºr das Produkt zu minimieren. <br><br>  Zun√§chst muss ich sagen, dass ein ernsthafter erster Schritt vor der Automatisierung des gesamten Prozesses ein Gespr√§ch mit einem Team von Inhaltserstellern (Grafik und Audio) sein sollte.  Der Grund daf√ºr ist, dass bei den meisten Automatisierungsprozessen die Ersteller bestimmte Regeln f√ºr die Vorbereitung von Projekten, Speicherorten, verwendeten Tools usw. einhalten m√ºssen.  In unserem Projekt bedeutete dies, dass wir Werkzeuge zum Erstellen des Inhalts von handgezeichneten Rahmen, 3D-Modellen und Sounds diskutieren und dann einen Video-Editor, um all dies zusammenzusetzen.  Es musste auch vereinbart werden, welche Teile des Workflows manuell ausgef√ºhrt und welche automatisiert werden. <br><br>  Infolgedessen haben wir Folgendes entschieden: <br><br><ul><li>  Manuell gezeichnete Frames werden in Adobe Animate mit einer Aufl√∂sung von 4440 x 2400 Pixel erstellt. </li><li>  3D-Modelle und -Animationen werden in Autodesk Maya erstellt und manuell gerendert, ebenfalls mit einer Aufl√∂sung von 4440 x 2400 Pixel </li><li>  Audiodateien werden im WAV-Format mit 48-kHz- und 16-Bit-Parametern erstellt </li><li>  Fragmente des Videos werden zun√§chst automatisch generiert, und der K√ºnstler kann jeden Teil √§ndern, den er ben√∂tigt (mit einigen Ausnahmen). </li><li>  Die letzten Schritte des Zusammenf√ºgens und Codierens von FMV werden automatisiert </li></ul><br>  Um die Tools so automatisiert wie m√∂glich zu gestalten, haben wir verschiedene Methoden verwendet.  Python wurde als ‚ÄûKlebstoff‚Äú ausgew√§hlt, der alles miteinander verbindet, da es durch verschiedene Bibliotheken gut erweitert wird und der Code einfach zu schreiben und zu warten ist.  Wir haben auch die interne Unterst√ºtzung f√ºr plattformunabh√§ngige Dateimanipulationen (Kopieren, Verschieben, L√∂schen) genutzt. <br><br><h2>  Python - Ausf√ºhren von ausf√ºhrbaren Dateien, Erhalten von Ergebnissen </h2><br>  Die Python-Unterprozessbibliothek war ideal f√ºr uns, da Sie damit die Ausf√ºhrung anderer ausf√ºhrbarer Dateien √§ndern und sogar auf den Abschluss ihrer Aufgaben warten k√∂nnen.  Sie k√∂nnen den vom Programm zur√ºckgegebenen Code abrufen und auf den Puffer stdout &amp; stderr zugreifen. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-comment"><span class="hljs-comment"># The command to execute command = 'SanExtract.exe -f -i credits.san -o \"C:/output_dir/\" ' # Execute the command via subprocess child = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE) # Wait for process to complete, returns stdout &amp; stderr buffers stdout, stderr = child.communicate() # Retrieve the return code from the process return_code = child.returncode</span></span></code> </pre> <br>  <em>Ein Beispiel f√ºr die Interaktion mit ausf√ºhrbaren Dateien in Python</em> <br><br><h2>  Python - Win32 API </h2><br>  Die Win32-API ist sehr n√ºtzlich, da sie uns den Zugriff auf die √úbertragung von Tastatur- und Mausnachrichten von Windows √ºber ein Skript erm√∂glichte.  Sie k√∂nnen beispielsweise eine Funktion erstellen, die in bestimmten X- und Y-Koordinaten des Bildschirms mit der Maus klickt: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClickXY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span><span class="hljs-function">:</span></span> win32api.SetCursorPos((x,y)) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Beispiel f√ºr eine Python-Mausklicksimulation</em> <br><br>  Sie k√∂nnen sogar Tastenanschlagereignisse an die Tastatur senden (mit oder ohne Modifikatoren): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32api <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> win32con <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PressKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code, modifierCode=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) time.sleep(<span class="hljs-number"><span class="hljs-number">0.021</span></span>) win32api.keybd_event(code, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_EXTENDEDKEY | win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modifierCode: win32api.keybd_event(modifierCode, <span class="hljs-number"><span class="hljs-number">0</span></span>, win32con.KEYEVENTF_KEYUP, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <em>Beispiel f√ºr eine Python-Tastatursimulation</em> <br><br>  Es gibt viele andere M√∂glichkeiten, aber die obigen Beispiele haben wirklich dazu beigetragen, unsere Ziele zu erreichen.  Sie k√∂nnen Tastaturereignisse an jedes aktive Programm senden, und es beginnt mit der Eingabe, als w√ºrden wir etwas √ºber die Tastatur eingeben, einschlie√ülich des Dr√ºckens von Tastenkombinationen. <br><br><h2>  Python - Computer Vision zum Klicken auf Schaltfl√§chen </h2><br>  Die einzigartigste Erfahrung war die Verwendung von Computer Vision-Software in Tools, die nicht durch interne Skripte automatisiert werden konnten.  Die meisten modernen Tools unterst√ºtzen Skripte, erfordern jedoch immer noch Benutzereingriffe.  Mit 3D Studio Max k√∂nnen Sie beispielsweise MAXScript-Dateien √ºber die Befehlszeile ausf√ºhren.  In unserem Fall f√ºhren wir das Skript aus, um die 3D-Netzdatei automatisch zu importieren. Anschlie√üend wird 3D Studio Max automatisch gestartet und das Dialogfeld Formimport angezeigt, in dem der Benutzer auf die Schaltfl√§chen klicken muss: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/b3e/4f9/ddcb3e4f9a830a8e72d9697eacf19b74.png"></div><br>  <em>Beispieldialogfeld Formimport</em> <br><br>  Also - wir haben ein Skript f√ºr die Automatisierung geschrieben, und jetzt m√ºssen wir vor dem Bildschirm sitzen und die Tasten dr√ºcken?  Anstatt an der Tastatur zu sitzen und darauf zu warten, dass das Popup-Fenster angezeigt wird, k√∂nnen wir das Skript einen Screenshot machen lassen, die OpenCV-Bindung an Python verwenden, um die Schaltfl√§chenbildvorlage zu finden und automatisch darauf zu klicken.  So sieht die Bildvorlage f√ºr das oben beschriebene Beispiel aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/67c/af3/b1e67caf30b4ea94761063bb6ead063c.png"></div><br>  <em>Bildvorlage f√ºr ok_button.png</em> <br><br>  Es ist zu beachten, dass die Bildvorlage zus√§tzliche Funktionen enth√§lt (Text f√ºr ‚ÄûEinzelobjekt‚Äú und ‚ÄûMehrere Objekte‚Äú).  Dies erm√∂glicht es uns, ein deterministischeres Suchergebnis zu erhalten.  Das folgende Beispiel ist ein Python-Skript, mit dem automatisch auf einen gefundenen Speicherort einer Bildvorlage geklickt wird: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageGrab <span class="hljs-comment"><span class="hljs-comment"># "Constants" TEMPLATE_THRESHOLD = 0.25 CLICK_OFFSET = 20 # Read the template image to search for template_image = cv2.imread('images/ok_button.png', 0) # Screenshot the current desktop and load it to a cv2 format screen = ImageGrab.grab() screen.save('screen.png') screen_image = cv2.imread('screen.png', 0) # Search for the template within the screenshot and retrieve search results match_result = cv2.matchTemplate(screen_image, template_image, cv2.TM_SQDIFF_NORMED) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(match_result) # If below the threshold, it's likely we know where to click if min_val &lt; TEMPLATE_THRESHOLD: ClickXY(min_loc[0]+CLICK_OFFSET, min_loc[1]+CLICK_OFFSET)</span></span></code> </pre> <br>  <em>Ein Beispiel f√ºr das Klicken auf ein Anzeigeelement mit OpenCV, geschrieben in Python</em> <br><br>  Alle obigen Beispiele basieren auf Python.  Es gibt jedoch Zeiten, in denen wir eine genauere Kontrolle √ºber das Windows-Betriebssystem-Fenstersystem ben√∂tigen.  Dies f√ºhrte dazu, dass wir native Tools mithilfe der Windows-Automatisierungs-API entwickelten. <br><br><h2>  Windows Native (C ++) - Windows-Automatisierungs-API </h2><br>  Die Windows-Automatisierungs-API bietet Zugriff auf die √§ltere Microsoft Active Accessibility-API (MSAA) sowie auf die Microsoft UI-Automatisierungs-API.  Weitere Informationen hierzu finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Microsoft-Seite</a> . <br><br>  Als Ergebnis haben wir die Tatsache erreicht, dass wir bestimmte Elemente der Windows-Oberfl√§che (Schaltfl√§chen, Textfelder, Registerkarten, Men√ºelemente) anfordern, herausfinden konnten, wo sich diese Elemente r√§umlich auf dem Bildschirm befinden, und mit ihnen klicken / interagieren konnten.  Das Windows SDK verf√ºgt auch √ºber Testtools, mit denen Sie sehen k√∂nnen, welche Eigenschaften verf√ºgbar sind.  Sie erm√∂glichten es uns herauszufinden, was in jedem spezifischen Programm automatisiert werden kann. <br><br>  Die Inspect.exe-Anwendung ist sehr n√ºtzlich, um die Hierarchie der Programmfensterverwaltung anzuzeigen.  Es bietet eine ungef√§hre Vorstellung davon, wo sich Objekte wie Men√ºsteuerelemente befinden und wie mithilfe von Automatisierungs-API-Aufrufen auf Fensterelemente verwiesen wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/d3f/650/0f2d3f650f30c4982f10d9d31b94c35c.png"></div><br>  <em>Beispiel Inspect.exe</em> <br><br>  Nachdem Sie die Steuerelementhierarchie des Windows-Programms kennengelernt haben, erfahren Sie, wie Sie sie im Handle des Hauptfensters finden und wie Sie √ºber die API auf verschiedene Elemente klicken: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Click on a sub-menu item given the Window &amp; Menu handles. void ClickSubMenu(HWND hwnd, HMENU hmenu, const char *pMenuName) { // Iterate through the menu items of the window int menu_item_count = GetMenuItemCount(hmenu); for(int menu_id = 0; menu_id &lt; menu_item_count; ++menu_id) { char menu_name[MAX_PATH]; int len = GetMenuString(hmenu, menu_id, reinterpret_cast&lt;LPSTR&gt;(&amp;menu_name[0]), sizeof(menu_name), MF_BYPOSITION); // Look for the specific menu you're searching for and click it // Make sure to set the window active before doing it... if(!strcmp(pMenuName, menu_name)) { // now get the rect and click the center RECT rect; BOOL success = GetMenuItemRect(hwnd, hmenu, menu_id, &amp;rect); if(success) { SetActiveWindow(hwnd); POINT point = GetMiddlePoint(rect); SetCursorPos(point.x, point.y); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN, point.x, point.y, 0, 0); mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTUP, point.x, point.y, 0, 0); Sleep(DO_TASK_INTERVAL_WAIT_MS); } } } }</span></span></span></span></code> </pre> <br>  <em>Ein Beispiel f√ºr das Verschieben eines Fenstersteuerelements in C ++</em> <br><br>  Das √úbergeben von Tastenanschl√§gen an das aktive Fenster ist nat√ºrlich auch einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;WinUser.h&gt; #include &lt;UIAutomation.h&gt; // Type the character string to the given window handle static void TypeCharacters(HWND window_handle, const char *pString) { int len = strlen(pString); for(int count = 0; count &lt; len; ++count) { SendMessage(window_handle, WM_CHAR, (WPARAM)pString[count], (LPARAM)0); Sleep(CHARACTER_REPEAT_INTERVAL_MS); } }</span></span></span></span></code> </pre> <br>  <em>Beispiel f√ºr eine C ++ - Tastatursimulation</em> <br><br>  Nat√ºrlich haben diese APIs viel mehr Funktionen.  Ich habe festgestellt, dass Sie dank des Tools Inspect.exe Aufschluss dar√ºber geben k√∂nnen, auf welche Elemente des Programmfensters zugegriffen werden kann. <br><br><h2>  Zwischentextformate </h2><br>  Ein Teil unseres Workflows bestand darin, die Dateien in Textform zu speichern und die Werte in diesen Textdateien zu √§ndern.  Am Ende haben die Werkzeuge eine Benutzeroberfl√§che zum √Ñndern des Status der Hilfsdaten.  Und wenn Sie wissen, wie diese Hilfsdaten aussehen sollen, m√ºssen Sie nicht mit dem Tool arbeiten, sondern nur die Hilfsdaten √§ndern.  Der Trick besteht darin, zu wissen, wie diese unterst√ºtzenden Daten manipuliert werden.  Wenn Sie propriet√§re Dateiformate √§ndern, kann dies eine Herausforderung sein.  W√§re es nicht sch√∂n, wenn jeder eine einfache Textdatei h√§tte, mit der Sie arbeiten k√∂nnen? <br><br>  Der Trick besteht darin, einen Weg zu finden, um die propriet√§ren Dateiformate zu umgehen, die von den meisten Tools verwendet werden.  Die L√∂sung besteht normalerweise darin, die Import- und Exportoptionen zu verwenden, die in den meisten modernen kommerziellen Tools zu finden sind.  Hier einige Beispiele: <br><br>  Adobe Premiere Pro speichert Dateien in einem propriet√§ren Format. Sie k√∂nnen Projekte jedoch als Final Cut Pro XML importieren / exportieren.  Nach dem Export in XML k√∂nnen Sie das XML nach Bedarf √§ndern und das Projekt wieder in Adobe Premiere Pro importieren. <br><br>  Ein weiteres Beispiel ist die Korrektur von Texturreferenzen, die im veralteten 3D-Netzformat von Autodesk 3D Studio Release 3 verwendet werden. Beim Importieren der urspr√ºnglichen Netzdatei speichern wir das neu konvertierte Netz mithilfe von ASCII-Zeichen in einer .fbx-Zwischendatei.  In diesem Format k√∂nnen Sie eine Textdatei verarbeiten und alle Zeilen von Texturverkn√ºpfungen durch die richtigen ersetzen. <br><br>  Adobe Animate / Flash ist ziemlich lustig, da sich herausstellt, dass .fla-Dateien tats√§chlich etwas "kaputte" .zip-Dateien sind.  In unkomprimierter Form werden sie im XFL-Format gespeichert, das auf andere XFL-Objekte (z. B. Bitmaps) aus einem lokalen Ordner verweisen kann.  Oliver Franzke, leitender Ingenieur von Double Fine, hat ein modifiziertes Python-Skript zum Packen / Entpacken von .fla-Dateien mithilfe von ZIP erstellt, damit wir diese Dateien erstellen / √§ndern k√∂nnen. <br><br><h1>  Anwendungsbeispiele </h1><br><h2>  3D Studio max </h2><br>  Die moderne Version von 3D Studio Max wurde verwendet, um die urspr√ºngliche PRJ-Datei in die Szene zu importieren und im ASCII-Format .fbx zu speichern.  F√ºr jede .prj-Datei, die konvertiert werden musste, wurde automatisch eine MaxScript-Datei (.ms) aus dem Python-Skript generiert, die ungef√§hr so ‚Äã‚Äãaussah: <br><br><pre> <code class="bash hljs">importFile <span class="hljs-string"><span class="hljs-string">"G:\FullThrottle_Backup\FullThrottle_SourceAssets\BENBIKE.PRJ"</span></span> <span class="hljs-comment"><span class="hljs-comment">#noPrompt</span></span></code> </pre> <br>  <em>Beispiel f√ºr den Import eines 3D-Modells mit MaxScript</em> <br><br>  Danach wurde diese MS-Datei einfach vom Python-Befehl aufgerufen, um in 3dsmax.exe ausgef√ºhrt zu werden: <br><br><pre> <code class="bash hljs">3dsmax.exe -U MAXScript <span class="hljs-string"><span class="hljs-string">"C:\FullThrottleRemastered\import_prj.ms"</span></span></code> </pre> <br>  <em>Ein Beispiel f√ºr einen Konsolenbefehl zum Aufrufen einer ausf√ºhrbaren Datei mit der angegebenen MaxScript-Datei</em> <br><br>  Wie oben erw√§hnt, √∂ffnete 3D Studio Max in diesem Fall ein Dialogfeld, auf das Sie klicken mussten.  Das OpenCV-Bundle mit Python hat dazu beigetragen, auf die Schaltfl√§che in diesem Fenster zu klicken, damit die Originaldatei ohne Benutzereingriff importiert wird.  Nach dem Importieren der Datei wurde eine Reihe von Men√ºtasten (unter Verwendung von win32api Python) gedr√ºckt, um eine weitere MAXScript-Datei zu starten, die das Modell als .fbx-Datei im ASCII-Format exportierte.  Da .fbx als regul√§re Textdatei gespeichert wurde, wurden alle Abh√§ngigkeiten der Modelltexturabh√§ngigkeiten durch Links zu Bildern in einem modernen Format ersetzt.  Anschlie√üend wurde die ge√§nderte .fbx-Datei erneut automatisch in 3DSMax geladen und als .max-Datei exportiert.  Zu diesem Zeitpunkt k√∂nnte die .max-Datei zum Remastering an den K√ºnstler gesendet werden. <br><br><h2>  Adobe Animate / Flash </h2><br>  Adobe Animate / Flash wurde verwendet, um alle handgezeichneten FMV-Ressourcen zu remastern.  Wir haben die vom SanWrangler-Tool gefundenen handgezeichneten Originalrahmen (320 x 200 Pixel gro√ü) als ‚ÄûMontagezeichnungen‚Äú verwendet.  Der Bildma√üstab wurde auf 4440 x 2400 Pixel vergr√∂√üert. Anschlie√üend wurde mithilfe eines Python-Skripts automatisch eine .fla-Datei generiert. <br><br>  Dann gen√ºgte es, die .fla-Datei automatisch von Grund auf neu zu generieren, wobei wir unser Wissen √ºber das XFL-Format Adobe Animate / Flash nutzten.  Mit dem bereits von Oliver Franzke erstellten Toolkit konnten wir Montagezeichnungen von handgezeichneten Animationsdateien erstellen. <br><br><h2>  Adobe Premiere Pro </h2><br>  Die Windows-Automatisierungs-API hat uns wirklich dabei geholfen, festzustellen, welche Premiere Pro-Steuerelemente auf dem Bildschirm angezeigt werden.  In einigen F√§llen hatten sie keine Hotkeys.  Nach dem Empfang der Koordinaten der Men√ºelemente musste der Cursor auf diese Koordinaten bewegt und ein Mausklickereignis gesendet werden. <br><br>  All dies ist gro√üartig, aber einige Steuerelemente werden auf andere Weise gerendert und sind daher f√ºr die Windows-Automatisierungs-API nicht sichtbar.  In diesem Fall haben wir uns f√ºr OpenCV und Python entschieden, um OpenCV in einer Skriptumgebung verwenden zu k√∂nnen.  Dies war besonders n√ºtzlich, wenn Sie mit Adobe Premiere Pro arbeiten: Obwohl JavaScript-Skripts teilweise unterst√ºtzt werden, war die Art der erforderlichen Steuerung √ºber die API nicht verf√ºgbar. <br><br>  Dar√ºber hinaus werden Adobe Premiere Pro-Projektdateien in einem propriet√§ren Bin√§rformat gespeichert.  Daher konnten wir die Premiere Pro-Datei nicht nur auf magische Weise erstellen, sondern auch die Importfunktion verwenden, mit der wir die Daten in die Final Cut Pro-Datei im XML-Format importieren konnten.  Dann gen√ºgte es, die richtige XML-Datei zu generieren, alle Ressourcen auf der Timeline entsprechend zu positionieren und diese XML-Datei Final Cut Pro automatisch zu importieren, um sie in das gew√ºnschte Format zu konvertieren.  Dann k√∂nnten wir die exportierten Frames in eine automatisierte Warteschlange stellen, um sie zu einem fertigen Video zu kombinieren. <br><br><h1>  Alle Stufen </h1><br>  Unten finden Sie ein verallgemeinertes Blockdiagramm, das alle automatisierten Teile eines neuen Workflows zeigt.  Jedes automatisierte Segment ist von einem abgerundeten Rechteck mit zus√§tzlichen Informationen zu den verwendeten Automatisierungstechniken umgeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f26/2c7/7cf/f262c77cf9d06f1fb6828e356ce40cc8.png"></div><br>  <em>Vereinfachtes √ºberarbeitetes FMV-Automatisierungsflussdiagramm</em> <br><br>  Sie werden feststellen, dass f√ºr die meisten Arbeiten mit Adobe Premiere Pro Python sowie spezieller nativer Windows-Code erforderlich sind.  Der Grund ist die komplexe Struktur von Premiere Pro-Fenstern sowie die Notwendigkeit, die native Windows-Automatisierungs-API zu verwenden, um eine ordnungsgem√§√üe Interaktion mit allen abh√§ngigen untergeordneten Fenstern dieser Anwendung sicherzustellen. <br><br><h1>  Alle zusammen </h1><br>  Mit den oben beschriebenen Methoden konnten wir mehrere Automatisierungsmaschinen konfigurieren, um die Arbeit an allen Videos in Teile aufzuteilen.  Au√üerdem wurde ein Slack Bot in den Workflow integriert, um je nach Status der Videos, die die Verarbeitungspipeline durchlaufen, Feedback zur Automatisierung an unseren Slack-Kanal zu senden, damit wir wissen, wenn etwas schief geht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/36d/f19/9b536df197475f6235282ac084c2efc8.gif"></div><br>  <em>Beispiel f√ºr die Automatisierung von Adobe Premiere Pro</em> <br><br><h1>  Die Probleme, mit denen wir konfrontiert sind </h1><br>  Das klingt alles gro√üartig, aber tats√§chlich sind wir bei der Implementierung des Projekts auf Probleme gesto√üen.  Ich werde nur die Hauptpunkte auflisten. <br><br>  1) Iteration des Mischens des fertigen Audios.  Das Remastering aller Audiodateien wurde schrittweise durchgef√ºhrt.  Als wir zum Beispiel den Soundeffekt ‚ÄûBOOM!‚Äú Hatten, hatte der Toningenieur keine Ahnung, wo er in den Audio-Mix eingef√ºgt werden sollte, und musste warten, bis das Video codiert war, um herauszufinden, was schief gelaufen war. <br><br>  2) Speicherung unkomprimierter Zwischendateien.  Die Frames wurden bis zum letzten Moment der Codierung in das fertige Video im unkomprimierten Format gespeichert.  Daher war es notwendig, eine gro√üe Anzahl von Frames im lokalen Speicher zu speichern, von denen einige im Versionskontrollsystem gespeichert waren.  Eine solche Erh√∂hung des gespeicherten Volumens war sehr auff√§llig und kann bei Verwendung einiger Versionskontrollsysteme (wir haben Perforce verwendet) recht teuer sein. <br><br>  3) Vorlaufzeit.  Ein fester Teil des Workflows wurde automatisiert, und dies erm√∂glichte den Ingenieuren, andere Dinge zu tun.  Die Zeit zum Erstellen eines Videos kann jedoch sehr lang sein.  Der zeitaufw√§ndigste Teil ist das Codieren von Frames in 4k-Aufl√∂sung.  Wir hatten M√∂glichkeiten, den Zustand der Ressourcen in Perforce zu untersuchen, um zu verstehen, welche Schritte erneut ausgef√ºhrt werden m√ºssen, aber diese Methode war nicht so in Teile unterteilt, wie wir es gerne h√§tten. <br><br><h1>  N√§chste Schritte </h1><br>  Ja, der Artikel erwies sich als umfangreich!  Obwohl unsere Implementierung dieses Workflows f√ºr das Projekt sehr spezifisch ist, glaube ich, dass bestimmte Automatisierungsmethoden bei der Entwicklung jedes Spiels verwendet werden k√∂nnen.  Nachdem Sie das Video herausgefunden haben, k√∂nnen Sie ein verwandtes Thema betrachten - das Spielen von FMV w√§hrend der Spielausf√ºhrung.  Dies umfasst Probleme wie das Codieren eines mehrsprachigen Audiostreams sowie die Framesynchronisation bei der Wiedergabe von Original-FMV.  Warten Sie auf den dritten Teil des Artikels! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422367/">https://habr.com/ru/post/de422367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422345/index.html">Server in den Clouds: Projektzusammenfassung</a></li>
<li><a href="../de422347/index.html">Migration einer echten Anwendung von eigenst√§ndigem MySQL zu Percona XtraDB Cluster</a></li>
<li><a href="../de422351/index.html">Remote-Codeausf√ºhrung durch Laden von Bildern auf Ihren Server oder lokalen Computer in Ghostscript / Imagick</a></li>
<li><a href="../de422363/index.html">PyCon Russia 2018 Konferenz: Video aller Berichte und Pr√§sentationen</a></li>
<li><a href="../de422365/index.html">Yandex reichte eine Beschwerde gegen eine Gerichtsentscheidung ein, um Links zu Raubkopien zu entfernen</a></li>
<li><a href="../de422369/index.html">Entwerfen von Dashboards f√ºr die E-Commerce-Website f√ºr Webanalysen. Teil 2: E-Mail-Newsletter. Strategisches Dashboard</a></li>
<li><a href="../de422371/index.html">Bewertung des Elektrofahrrads Twitter TW-E9L</a></li>
<li><a href="../de422373/index.html">Wir laden Sie zu Open Source-Treffen im September ein (Moskau und St. Petersburg).</a></li>
<li><a href="../de422375/index.html">Vertr√§ge sind anders oder was Sie unterschrieben haben</a></li>
<li><a href="../de422377/index.html">ESP8266 + FLProg - Benutzersystemparameter und Synchronisation mit dem genauen Zeitserver</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>