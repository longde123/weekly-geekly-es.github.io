<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚢 👈🏽 ☝🏻 Wir verbinden einen Wasserzähler mit einem Smart Home 🕟 👎🏼 🤴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Früher waren Hausautomationssysteme, oder wie sie oft als „Smart Home“ bezeichnet werden, furchtbar teuer und konnten sich nur reiche Leute leisten. H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir verbinden einen Wasserzähler mit einem Smart Home</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/411259/">  Früher waren Hausautomationssysteme, oder wie sie oft als „Smart Home“ bezeichnet werden, furchtbar teuer und konnten sich nur reiche Leute leisten.  Heutzutage gibt es auf dem Markt recht kostengünstige Kits mit Sensoren, Tasten / Schaltern und Aktuatoren zur Steuerung von Beleuchtung, Steckdosen, Belüftung, Wasserversorgung und anderen Verbrauchern.  Und selbst der <s>krivoruky</s> DIY-Shnik kann sich den schönen anschließen und Geräte für ein Smart Home zu günstigen Preisen sammeln. <br><br><img src="https://habrastorage.org/webt/-a/k2/x6/-ak2x6li6an5gyqbrg2ett_-_au.jpeg"><br><br>  In der Regel sind die vorgeschlagenen Geräte entweder Sensoren oder Aktoren.  Sie erleichtern die Implementierung von Szenarien wie „Schalten Sie das Licht ein, wenn der Bewegungssensor ausgelöst wird“ oder „Der Schalter am Ausgang löscht das Licht in der gesamten Wohnung“.  Aber die Telemetrie hat irgendwie nicht geklappt.  Im besten Fall ist dies ein Diagramm der Temperatur und Luftfeuchtigkeit oder der momentanen Leistung in einer bestimmten Steckdose. <br><br>  Kürzlich habe ich einen Wasserzähler mit Impulsausgang installiert.  Ein Reedschalter wird durch jeden Liter durch das Messgerät ausgelöst und schließt den Kontakt.  Das einzige, was noch übrig bleibt, ist, sich an die Drähte zu klammern und zu versuchen, davon zu profitieren.  Analysieren Sie beispielsweise den Wasserverbrauch nach Stunde und Wochentag.  Wenn es in der Wohnung mehrere Steigleitungen für Wasser gibt, ist es bequemer, alle aktuellen Anzeigen auf einem Bildschirm zu sehen, als schwer zugängliche Nischen mit einer Taschenlampe zu besteigen. <br><br>  Unter dem Schnitt basiert meine Version des Geräts auf dem ESP8266, der Impulse von Wasserzählern zählt und Messwerte über MQTT an den Smart-Home-Server sendet.  Wir werden in Mikropython mit der Uasyncio-Bibliothek programmieren.  Bei der Erstellung der Firmware bin ich auf einige interessante Schwierigkeiten gestoßen, die ich auch in diesem Artikel diskutieren werde.  Lass uns gehen! <br><a name="habracut"></a><br><h3>  Schema </h3><br><img src="https://habrastorage.org/webt/i-/w2/o7/i-w2o7b8mfsommteri_mss88oa8.png"><br><br>  Das Herzstück der gesamten Schaltung ist das Modul des Mikrocontrollers ESP8266.  ESP-12 war ursprünglich geplant, aber meins erwies sich als defekt.  Ich musste mich mit dem verfügbaren ESP-07-Modul zufrieden geben.  Glücklicherweise sind sie sowohl in Bezug auf die Schlussfolgerungen als auch in Bezug auf die Funktionalität gleich. Der Unterschied besteht nur in der Antenne - der ESP-12 verfügt über eine integrierte Antenne und der ESP-07 über eine externe Antenne.  Aber auch ohne WiFi-Antenne wird das Signal in meinem Badezimmer normal empfangen. <br><br>  Die Modulbindung ist Standard: <br><br><ul><li>  Reset-Taste mit Hosenträger und Kondensator (obwohl sich beide bereits im Modul befinden) </li><li>  Aktivierungssignal (CH_PD) an die Stromversorgung gezogen </li><li>  GPIO15 zu Boden gezogen.  Dies ist nur zu Beginn notwendig, aber ich habe immer noch nichts mehr an diesem Bein festzuhalten </li></ul><br>  Um das Modul in den Firmware-Modus zu versetzen, müssen Sie den GPIO2 gegen Masse schließen, und um es bequemer zu machen, habe ich die Boot-Taste bereitgestellt.  Im Normalzustand wird dieser Stift an die Stromversorgung gezogen. <br><br>  Der Status der GPIO2-Leitung wird nur zu Beginn der Arbeit überprüft - beim Einschalten oder unmittelbar nach einem Reset.  Das Modul wird also entweder wie gewohnt geladen oder wechselt in den Firmware-Modus.  Nach dem Laden kann dieser Ausgang als normaler GPIO verwendet werden.  Nun, da es dort bereits eine Schaltfläche gibt, können Sie eine nützliche Funktion darauf setzen. <br><br>  Zum Programmieren und Debuggen werde ich den UART verwenden, der zum Kamm gebracht wurde.  Bei Bedarf stecke ich einfach einen USB-UART-Adapter ein.  Sie müssen sich nur daran erinnern, dass das Modul mit 3,3 V betrieben wird.  Wenn Sie vergessen, den Adapter auf diese Spannung umzuschalten und 5 V anzulegen, brennt das Modul höchstwahrscheinlich aus. <br><br>  Ich habe keine Probleme mit Strom im Badezimmer - die Steckdose befindet sich ungefähr einen Meter von den Zählern entfernt, also werde ich sie mit 220 V versorgen.  Als Stromquelle werde ich einen kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Block HLK-PM03</a> von Tenstar Robot bearbeiten.  Persönlich bin ich eng mit Analog- und Leistungselektronik verbunden, aber hier ist ein fertiges Netzteil in einem kleinen Fall. <br><br>  Um die Betriebsarten zu signalisieren, habe ich eine an GPIO2 angeschlossene LED bereitgestellt.  Ich habe jedoch nicht angefangen, es zu löten, weil  Das ESP-07-Modul verfügt außerdem bereits über eine LED, die an denselben GPIO2 angeschlossen ist.  Aber lass es auf der Platine sein - plötzlich möchte ich diese LED zum Gehäuse bringen. <br><br>  Wir gehen zu den interessantesten über.  Wasserzähler haben keine Logik und können nicht nach aktuellen Messwerten gefragt werden.  Das einzige, was uns zur Verfügung steht, sind Impulse - das Schließen der Kontakte des Reed-Schalters pro Liter.  Die Schlussfolgerungen der Reed-Schalter sind in GPIO12 / GPIO13 festgelegt.  Ich werde den Pull-up-Widerstand programmgesteuert im Modul einschalten. <br><br>  Anfangs habe ich vergessen, die Widerstände R8 und R9 bereitzustellen, und in meiner Version der Platine sind dies nicht der Fall.  Da ich das Programm jedoch bereits öffentlich ausstelle, lohnt es sich, dieses Versehen zu korrigieren.  Es werden Widerstände benötigt, um den Anschluss nicht zu verbrennen, wenn die Firmware fehlerhaft ist und das Gerät auf den Pin setzt, und der Reed-Schalter schließt diese Leitung gegen Masse kurz (maximal 3,3 V / 1000 Ohm = 3,3 mA fließen mit dem Widerstand). <br><br>  Es ist Zeit zu überlegen, was zu tun ist, wenn der Strom ausfällt.  Die erste Möglichkeit besteht darin, den Server beim Start nach ersten Zählern zu fragen.  Dies würde jedoch eine erhebliche Komplikation des Austauschprotokolls erfordern.  Darüber hinaus hängt die Funktionsfähigkeit des Geräts in diesem Fall vom Status des Servers ab.  Wenn der Server nach dem Ausschalten des Lichts nicht gestartet wurde (oder später gestartet wurde), konnte der Wasserzähler die Anfangswerte nicht anfordern und funktionierte nicht ordnungsgemäß. <br><br>  Daher habe ich mich entschlossen, die Speicherung von Zählerwerten in einem über I2C verbundenen Speicherchip zu implementieren.  Ich habe keine besonderen Anforderungen an die Größe des Flash-Speichers - ich muss nur 2 Zahlen speichern (die Anzahl der Liter in Heiß- und Kaltwasserzählern).  Selbst das kleinste Modul reicht aus.  Bei der Anzahl der Aufnahmezyklen müssen Sie jedoch aufpassen.  Für die meisten Module sind dies 100.000 Zyklen, für einige bis zu einer Million. <br><br>  Es scheint, eine Million ist viel.  Aber für 4 Jahre in meiner Wohnung habe ich etwas mehr als 500 Kubikmeter Wasser verbraucht, das sind 500.000 Liter!  Und 500 Tausend Einträge im Blitz.  Und das ist nur kaltes Wasser.  Sie können den Chip natürlich alle paar Jahre löten, aber es stellte sich heraus, dass es FRAM-Chips gibt.  Aus programmtechnischer Sicht ist dies das gleiche I2C-EEPROM, jedoch mit einer sehr großen Anzahl von Umschreibungszyklen (Hunderte von Millionen).  Das ist nur so lange, bis alles mit solchen Chips in irgendeiner Weise in den Laden kommt, also wird der übliche 24LC512 vorerst bestehen bleiben. <br><br><h3>  Leiterplatte </h3><br>  Anfangs wollte ich zu Hause eine Gebühr erheben.  Daher wurde das Board einseitig gestaltet.  Aber nach einer langen Stunde mit einem Lasereisen und einer Lötmaske (ohne dass es irgendwie komisch wäre) entschied ich mich immer noch, Bretter bei den Chinesen zu bestellen. <br><br><img src="https://habrastorage.org/webt/en/si/rz/ensirzhmczp3bs9n7a6a8plmzl4.png"><br><br>  Fast vor der Bestellung der Karte wurde mir klar, dass Sie neben dem Flash-Speicherchip am I2C-Bus noch etwas Nützliches wie ein Display mitnehmen können.  Was genau darauf ausgegeben werden soll, ist noch eine Frage, aber Sie müssen auf dem Brett züchten.  Nun, da ich die Boards im Werk bestellen wollte, machte es keinen Sinn, mich auf ein einseitiges Board zu beschränken, daher sind die Leitungen auf I2C die einzigen auf der Rückseite des Boards. <br><br>  Ein großer Pfosten war auch mit einseitiger Verkabelung verbunden.  Weil  Die Platine wurde auf der einen Seite gezeichnet, die Schienen und SMD-Komponenten sollten auf der einen Seite und die Ausgangskomponenten, Anschlüsse und das Netzteil auf der anderen Seite platziert werden.  Als ich die Boards in einem Monat erhielt, vergaß ich den ursprünglichen Plan und entpackte alle Komponenten auf der Vorderseite.  Und nur beim Löten des Netzteils stellte sich heraus, dass Plus und Minus im Gegenteil geschieden waren.  Ich musste mit Springern Kollektivfarmen betreiben.  Im obigen Bild habe ich die Verkabelung bereits geändert, aber die Masse wird über die Ausgänge der Boot-Taste von einem Teil der Platine zum anderen geworfen (obwohl es möglich wäre, eine Spur auf der zweiten Ebene zu zeichnen). <br><br>  Es stellte sich so heraus <br><br><img src="https://habrastorage.org/webt/au/-d/cs/au-dcsvpehh9p5g9iqyob5hjslu.jpeg"><br><br><h3>  Gehäuse </h3><br>  Der nächste Schritt ist das Gehäuse.  Mit einem 3D-Drucker ist dies kein Problem.  Ich habe mich nicht viel darum gekümmert - ich habe nur eine Schachtel mit der richtigen Größe gezeichnet und an den richtigen Stellen Ausschnitte gemacht.  Die Abdeckung wird mit kleinen Schrauben am Gehäuse befestigt. <br><br><img src="https://habrastorage.org/webt/qq/lu/zp/qqluzptanq4d24dsv4jdlb9uif8.png"><br><br>  Ich habe bereits erwähnt, dass die Boot-Taste als Allzweck-Taste verwendet werden kann - hier bringen wir sie auf die Vorderseite.  Zu diesem Zweck habe ich einen speziellen „Brunnen“ gezeichnet, in dem der Knopf lebt. <br><br><img src="https://habrastorage.org/webt/dv/xg/gn/dvxggnexv-fiqy0jqtptpdk1dvy.png"><br><br>  Im Inneren des Gehäuses befinden sich auch Stümpfe, auf denen die Platine mit einer einzigen M3-Schraube installiert und befestigt wird (auf der Platine war kein Platz mehr). <br><br>  Das Display wurde ausgewählt, als ich die erste passende Version des Gehäuses druckte.  Die Standard-Zweilinie passte nicht in dieses Gehäuse, aber im Gimbal wurde ein OLED-Display SSD1306 128x32 gefunden.  Es ist klein, aber ich muss ihn nicht jeden Tag ansehen - es wird rollen. <br><br>  Ich schätzte beide Richtungen und wie die Drähte von ihm verlegt werden, und beschloss, das Display in die Mitte des Gehäuses zu stecken.  Ergonomie natürlich unter der Fußleiste - ein Knopf oben, ein Display unten.  Aber ich habe bereits gesagt, dass die Idee, das Display zu vermasseln, zu spät kam und es zu faul war, das Board neu anzuordnen, um den Knopf zu bewegen. <br><br>  Das Gerät ist fertig.  Das Anzeigemodul wird auf die Schmelzdüsen geklebt <br><br><img src="https://habrastorage.org/webt/sn/qr/xf/snqrxfyyihzqwiwwwf-1yly545m.jpeg"><br><br><img src="https://habrastorage.org/webt/ow/bh/2o/owbh2oguwv4tiez2basnv11hgvw.jpeg"><br><br>  Das Endergebnis ist auf KDPV zu sehen <br><br><h3>  Firmware </h3><br>  Fahren wir mit dem Softwareteil fort.  Für solch kleine Handwerke verwende ich sehr gerne die Python-Sprache ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micropython</a> ) - der Code ist sehr kompakt und verständlich.  Glücklicherweise ist es nicht erforderlich, auf die Registerebene zu gehen, um Mikrosekunden zu komprimieren - alles kann von Python aus erfolgen. <br><br>  Es scheint alles einfach, aber nicht sehr einfach zu sein - mehrere unabhängige Funktionen sind im Gerät beschrieben: <br><br><ul><li>  Der Benutzer drückt eine Taste und schaut auf das Display </li><li>  Liter ticken und aktualisieren die Werte im Flash-Speicher </li><li>  Das Modul überwacht das WLAN-Signal und stellt bei Bedarf eine neue Verbindung her </li><li>  Nun, ohne ein blinkendes Licht können Sie es überhaupt nicht tun </li></ul><br>  Es ist unmöglich anzunehmen, dass eine Funktion nicht funktioniert hat, wenn die andere aus irgendeinem Grund dumm ist.  Ich habe bereits in anderen Projekten Kakteen gegessen, und jetzt sehe ich Störungen im Stil „einen weiteren Liter verpasst, weil in diesem Moment die Anzeige aktualisiert wurde“ oder „der Benutzer kann nichts tun, während das Modul eine Verbindung zu WiFi herstellt“.  Natürlich können einige Dinge durch Interrupts erledigt werden, aber Sie können auf eine Einschränkung der Dauer, der Verschachtelung von Aufrufen oder der nichtatomaren Änderung von Variablen stoßen.  Nun, der Code, der alles macht und sich sofort schnell in ein Chaos verwandelt. <br><br>  In dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt habe</a> ich das klassische präemptive Multitasking und FreeRTOS ernsthafter verwendet, aber in diesem Fall <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwiesen</a> sich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coroutine-</a> Modell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und die Uasync-Bibliothek</a> als viel geeigneter.  Darüber hinaus ist die Pitonovskiy-Implementierung von Corutin nur eine Bombe - für den Programmierer war alles einfach und bequem erledigt.  Schreiben Sie einfach Ihre eigene Logik und sagen Sie mir, an welchen Stellen Sie zwischen Threads wechseln können. <br><br>  Ich schlage vor, die Unterschiede zwischen Verdrängung und wettbewerbsfähigem Multitasking optional zu untersuchen.  Kommen wir nun endlich zum Code. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Counter class - implements a single water counter on specified pin ##################################### class Counter(): debounce_ms = const(25) def __init__(self, pin_num, value_storage): self._value_storage = value_storage self._value = self._value_storage.read() self._value_changed = False self._pin = Pin(pin_num, Pin.IN, Pin.PULL_UP) loop = asyncio.get_event_loop() loop.create_task(self._switchcheck()) # Thread runs forever</span></span></code> </pre> <br>  Jeder Zähler wird von einer Instanz der Counter-Klasse verarbeitet.  Zunächst wird der Anfangswert des Zählers vom EEPROM (value_storage) abgezogen - auf diese Weise wird die Wiederherstellung nach einem Stromausfall implementiert. <br><br>  Der Pin wird mit einem eingebauten Pull-up zur Stromversorgung initialisiert: Wenn der Reed-Schalter geschlossen ist, ist er Null in der Leitung. Wenn die Leitung offen ist, wird die Leitung an die Stromversorgung gezogen und der Controller liest eins. <br><br>  Außerdem wird hier eine separate Aufgabe gestartet, die den Pin abfragt.  Jeder Zähler führt seine eigene Aufgabe aus.  Hier ist ihr Code <br><br><pre> <code class="python hljs"> <span class="hljs-string"><span class="hljs-string">""" Poll pin and advance value when another litre passed """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_switchcheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> last_checked_pin_state = self._pin.value() <span class="hljs-comment"><span class="hljs-comment"># Get initial state # Poll for a pin change while True: state = self._pin.value() if state != last_checked_pin_state: # State has changed: act on it now. last_checked_pin_state = state if state == 0: self._another_litre_passed() # Ignore further state changes until switch has settled await asyncio.sleep_ms(Counter.debounce_ms)</span></span></code> </pre> <br>  Zum Filtern des Kontaktsprungs ist eine Verzögerung von 25 ms erforderlich, die gleichzeitig regelt, wie oft die Aufgabe aufwacht (während diese Aufgabe schläft, funktionieren andere Aufgaben).  Alle 25 ms wacht die Funktion auf, überprüft den Stift und wenn die Kontakte des Reed-Schalters geschlossen sind, ist ein weiterer Liter durch den Zähler geflossen und dieser muss verarbeitet werden. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_another_litre_passed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._value += <span class="hljs-number"><span class="hljs-number">1</span></span> self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self._value_storage.write(self._value)</code> </pre> <br>  Die Verarbeitung des nächsten Liters ist trivial - der Zähler erhöht sich einfach.  Nun, ein neuer Wert wäre schön, auf ein Flash-Laufwerk zu schreiben. <br><br>  Zur Vereinfachung der Verwendung werden „Accessoren“ bereitgestellt. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self._value = value self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Nun nutzen wir die Freuden von Python und der Uasync-Bibliothek und machen das Gegenobjekt wartbar (wie kann dies ins Russische übersetzt werden? Das, was zu erwarten ist?) <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._value_changed: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.value() __iter__ = __await__</code> </pre> <br>  Dies ist eine so praktische Funktion, die wartet, bis der Zählerwert aktualisiert wird. Die Funktion wird von Zeit zu Zeit aktiviert und überprüft das Flag _value_changed.  Der Witz dieser Funktion ist, dass der aufrufende Code bei einem Aufruf dieser Funktion einschlafen und schlafen kann, bis ein neuer Wert empfangen wird. <br><br><div class="spoiler">  <b class="spoiler_title">Aber was ist mit Interrupts?</b> <div class="spoiler_text">  Ja, an dieser Stelle können Sie mich trollen und sagen, dass er selbst über Unterbrechungen gesprochen hat, aber tatsächlich hat er eine dumme Umfrage über die Stecknadel arrangiert.  In der Tat sind Interrupts das erste, was ich versucht habe.  In ESP8266 können Sie einen Interrupt am Rand organisieren und sogar einen Handler für diesen Interrupt in Python schreiben.  In diesem Interrupt können Sie den Wert einer Variablen aktualisieren.  Wahrscheinlich würde dies ausreichen, wenn der Zähler ein Slave-Gerät wäre - eines, das wartet, bis es nach diesem Wert gefragt wird. <br><br>  Leider (oder zum Glück?) Ist mein Gerät aktiv, es muss Nachrichten mit dem MQTT-Protokoll senden und Daten in das EEPROM schreiben.  Und hier kommen die Einschränkungen bereits ins Spiel - Sie können keinen Speicher zuweisen und keinen großen Stapel in Interrupts verwenden, was bedeutet, dass Sie das Senden von Nachrichten über das Netzwerk vergessen können.  Es gibt Brötchen wie micropython.schedule (), mit denen Sie eine Funktion "sofort" ausführen können, aber die Frage lautet "Was ist der Sinn?".  Plötzlich senden wir gerade eine Art Nachricht, und hier verkeilt und unterbricht der Interrupt die Werte der Variablen.  Oder es ist beispielsweise ein neuer Zählerwert vom Server eingetroffen, während wir den alten noch nicht notiert haben.  Im Allgemeinen müssen Sie die Synchronisation umzäunen oder irgendwie anders raus. <br><br>  Und von Zeit zu Zeit stürzt RuntimeError ab: Zeitplanstapel voll und wer weiß warum? <br><br>  Mit einer expliziten Umfrage und Uasync ist es in diesem Fall irgendwie schöner und zuverlässiger. <br></div></div><br>  Ich habe in einer kleinen Klasse mit EEPROM gearbeitet <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EEPROM</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> i2c_addr = const(<span class="hljs-number"><span class="hljs-number">80</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, i2c)</span></span></span><span class="hljs-function">:</span></span> self.i2c = i2c self.i2c_buf = bytearray(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Avoid creation/destruction of the buffer on each call def read(self, eeprom_addr): self.i2c.readfrom_mem_into(self.i2c_addr, eeprom_addr, self.i2c_buf, addrsize=16) return ustruct.unpack_from("&lt;I", self.i2c_buf)[0] def write(self, eeprom_addr, value): ustruct.pack_into("&lt;I", self.i2c_buf, 0, value) self.i2c.writeto_mem(self.i2c_addr, eeprom_addr, self.i2c_buf, addrsize=16)</span></span></code> </pre> <br>  In Python ist es schwierig, direkt mit Bytes zu arbeiten, aber es sind Bytes, die in den Speicher geschrieben werden.  Ich musste die Konvertierung zwischen Integer und Bytes mithilfe der Ustruct-Bibliothek korrigieren. <br><br>  Um das I2C-Objekt und die Speicherzellenadresse nicht jedes Mal zu übertragen, habe ich alles in einen kleinen und praktischen Klassiker verpackt <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EEPROMValue</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, i2c, eeprom_addr)</span></span></span><span class="hljs-function">:</span></span> self._eeprom = EEPROM(i2c) self._eeprom_addr = eeprom_addr <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._eeprom.read(self._eeprom_addr) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self._eeprom.write(self._eeprom_addr, value)</code> </pre> <br>  Das I2C-Objekt selbst wird mit solchen Parametern erstellt <br><br><pre> <code class="python hljs">i2c = I2C(freq=<span class="hljs-number"><span class="hljs-number">400000</span></span>, scl=Pin(<span class="hljs-number"><span class="hljs-number">5</span></span>), sda=Pin(<span class="hljs-number"><span class="hljs-number">4</span></span>))</code> </pre> <br>  Wir nähern uns dem Interessantesten - der Implementierung der Kommunikation mit dem Server über MQTT.  Nun, das Protokoll selbst muss nicht implementiert werden - eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigte asynchrone Implementierung</a> wurde im Internet gefunden.  Hier werden wir es verwenden. <br><br>  Das Interessanteste ist in der Klasse CounterMQTTClient zusammengefasst, die auf der Bibliothek MQTTClient basiert.  Beginnen wir an der Peripherie <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Class handles both counters and sends their status to MQTT ##################################### class CounterMQTTClient(MQTTClient): blue_led = Pin(2, Pin.OUT, value = 1) button = Pin(0, Pin.IN) hot_counter = Counter(12, EEPROMValue(i2c, EEPROM_ADDR_HOT_VALUE)) cold_counter = Counter(13, EEPROMValue(i2c, EEPROM_ADDR_COLD_VALUE))</span></span></code> </pre> <br>  Hier werden Stifte von Glühbirnen und Knöpfen sowie Objekte von Kalt- und Warmwasserzählern erstellt und konfiguriert. <br><br>  Bei der Initialisierung ist nicht alles so trivial <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.internet_outages = <span class="hljs-number"><span class="hljs-number">0</span></span> self.internet_outage_start = ticks_ms() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"config.txt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config_file: config[<span class="hljs-string"><span class="hljs-string">'ssid'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'wifi_pw'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'server'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'client_id'</span></span>] = config_file.readline().rstrip() self._mqtt_cold_water_theme = config_file.readline().rstrip() self._mqtt_hot_water_theme = config_file.readline().rstrip() self._mqtt_debug_water_theme = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'subs_cb'</span></span>] = self.mqtt_msg_handler config[<span class="hljs-string"><span class="hljs-string">'wifi_coro'</span></span>] = self.wifi_connection_handler config[<span class="hljs-string"><span class="hljs-string">'connect_coro'</span></span>] = self.mqtt_connection_handler config[<span class="hljs-string"><span class="hljs-string">'clean'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> config[<span class="hljs-string"><span class="hljs-string">'clean_init'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> super().__init__(config) loop = asyncio.get_event_loop() loop.create_task(self._heartbeat()) loop.create_task(self._counter_coro(self.cold_counter, self._mqtt_cold_water_theme)) loop.create_task(self._counter_coro(self.hot_counter, self._mqtt_hot_water_theme)) loop.create_task(self._display_coro())</code> </pre> <br>  Um die Parameter der Bibliothek mqtt_as festzulegen, wird ein großes Wörterbuch mit verschiedenen Einstellungen verwendet - config.  Die meisten Standardeinstellungen passen zu uns, aber viele Einstellungen müssen explizit festgelegt werden.  Um die Einstellungen nicht direkt im Code zu registrieren, speichere ich sie in der Textdatei config.txt.  Auf diese Weise können Sie den Code unabhängig von den Einstellungen ändern und mehrere identische Geräte mit unterschiedlichen Parametern nieten. <br><br>  Der letzte Codeblock führt mehrere Coroutinen aus, um verschiedene Funktionen des Systems zu erfüllen.  Hier ist ein Beispiel für eine Coroutine, die Zählern dient <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_counter_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, counter, topic)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Publish initial value value = counter.value() await self.publish(topic, str(value)) # Publish each new value while True: value = await counter await self.publish_msg(topic, str(value))</span></span></code> </pre> <br>  In einem Zyklus wartet Corutin auf einen neuen Zählerwert und sendet, sobald dieser angezeigt wird, eine Nachricht unter Verwendung des MQTT-Protokolls.  Der erste Code sendet den Anfangswert, auch wenn das Wasser nicht durch den Zähler fließt. <br><br>  Die MQTTClient-Basisklasse bedient sich selbst, initiiert eine WiFi-Verbindung und stellt die Verbindung wieder her, wenn die Verbindung unterbrochen wird.  Wenn sich der WiFi-Verbindungsstatus ändert, informiert uns die Bibliothek durch Aufrufen von wifi_connection_handler <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wifi_connection_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, state)</span></span></span><span class="hljs-function">:</span></span> self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state: self.dprint(<span class="hljs-string"><span class="hljs-string">'WiFi is up.'</span></span>) duration = ticks_diff(ticks_ms(), self.internet_outage_start) // <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.publish_debug_msg(<span class="hljs-string"><span class="hljs-string">'ReconnectedAfter'</span></span>, duration) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.internet_outages += <span class="hljs-number"><span class="hljs-number">1</span></span> self.internet_outage_start = ticks_ms() self.dprint(<span class="hljs-string"><span class="hljs-string">'WiFi is down.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Die Funktion wird ehrlich aus den Beispielen geleckt.  In diesem Fall werden die Anzahl der Verbindungsabbrüche (internet_outages) und deren Dauer berücksichtigt.  Wenn eine Verbindung wiederhergestellt wird, werden Ausfallzeiten an den Server gesendet. <br><br>  Übrigens wird der letzte Schlaf nur benötigt, damit die Funktion asynchron wird - in der Bibliothek wird sie über await aufgerufen, und nur Funktionen, in deren Körper sich ein weiteres Warten befindet, können aufgerufen werden. <br><br>  Neben der Verbindung zu WiFi müssen Sie auch eine Verbindung zum MQTT-Broker (Server) herstellen.  Die Bibliothek tut dies auch, aber wir haben die Möglichkeit, etwas Nützliches zu tun, wenn die Verbindung hergestellt wird. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mqtt_connection_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, client)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.subscribe(self._mqtt_cold_water_theme) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.subscribe(self._mqtt_hot_water_theme)</code> </pre> <br>  Hier abonnieren wir mehrere Nachrichten - der Server hat jetzt die Möglichkeit, die aktuellen Zählerwerte durch Senden der entsprechenden Nachricht festzulegen. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mqtt_msg_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, topic, msg)</span></span></span><span class="hljs-function">:</span></span> topicstr = str(topic, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>) self.dprint(<span class="hljs-string"><span class="hljs-string">"Received MQTT message topic={}, msg={}"</span></span>.format(topicstr, msg)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> topicstr == self._mqtt_cold_water_theme: self.cold_counter.set_value(int(msg)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> topicstr == self._mqtt_hot_water_theme: self.hot_counter.set_value(int(msg))</code> </pre> <br>  Diese Funktion verarbeitet eingehende Nachrichten und abhängig vom Thema (Nachrichtenname) werden die Werte eines der Zähler aktualisiert <br><br>  Ein paar Hilfsfunktionen <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Publish a message if WiFi and broker is up, else discard async def publish_msg(self, topic, msg): self.dprint("Publishing message on topic {}: {}".format(topic, msg)) if not self.internet_outage: await self.publish(topic, msg) else: self.dprint("Message was not published - no internet connection")</span></span></code> </pre> <br>  Diese Funktion sendet Nachrichten, wenn eine Verbindung hergestellt wird.  Wenn keine Verbindung besteht, wird die Nachricht ignoriert. <br><br>  Und dies ist nur eine praktische Funktion, die Debugging-Nachrichten generiert und sendet. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publish_debug_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, subtopic, msg)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.publish_msg(<span class="hljs-string"><span class="hljs-string">"{}/{}"</span></span>.format(self._mqtt_debug_water_theme, subtopic), str(msg))</code> </pre><br>  So viel Text, aber wir haben keine LED geblinkt.  Hier <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Blink flash LED if WiFi down async def _heartbeat(self): while True: if self.internet_outage: self.blue_led(not self.blue_led()) # Fast blinking if no connection await asyncio.sleep_ms(200) else: self.blue_led(0) # Rare blinking when connected await asyncio.sleep_ms(50) self.blue_led(1) await asyncio.sleep_ms(5000)</span></span></code> </pre> <br>  Ich habe 2 Blinkmodi bereitgestellt.  Wenn die Verbindung unterbrochen wird (oder gerade hergestellt wird), blinkt das Gerät schnell.  Wenn die Verbindung hergestellt ist, blinkt das Gerät alle 5 Sekunden.  Bei Bedarf können Sie hier andere Blinkmodi implementieren. <br><br>  Aber die LED verwöhnt so.  Wir winkten immer noch zum Display. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_display_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> display = SSD1306_I2C(<span class="hljs-number"><span class="hljs-number">128</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>, i2c) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: display.poweron() display.fill(<span class="hljs-number"><span class="hljs-number">0</span></span>) display.text(<span class="hljs-string"><span class="hljs-string">"COLD: {:.3f}"</span></span>.format(self.cold_counter.value() / <span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) display.text(<span class="hljs-string"><span class="hljs-string">"HOT: {:.3f}"</span></span>.format(self.hot_counter.value() / <span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) display.show() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">3</span></span>) display.poweroff() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.button(): <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">20</span></span>)</code> </pre> <br>  Darüber habe ich gesprochen - wie einfach und bequem mit Coroutinen.  Diese kleine Funktion beschreibt ALLE Benutzerinteraktionen.  Corutin wartet nur auf das Drücken einer Taste und schaltet das Display 3 Sekunden lang ein.  Das Display zeigt die aktuellen Zählerstände an. <br><br>  Es gibt noch ein paar Kleinigkeiten.  Hier ist die Funktion, die die gesamte Farm (re) ausführt.  Der Hauptzyklus behandelt nur das Senden verschiedener Debugging-Informationen einmal pro Minute.  Im Allgemeinen zitiere ich so wie es ist - insbesondere ein Kommentar, denke ich, ist nicht notwendig <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self._connect_to_WiFi() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self._run_main_loop() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: self.dprint(<span class="hljs-string"><span class="hljs-string">'Global communication failure: '</span></span>, e) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_connect_to_WiFi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.dprint(<span class="hljs-string"><span class="hljs-string">'Connecting to WiFi and MQTT'</span></span>) sta_if = network.WLAN(network.STA_IF) sta_if.connect(config[<span class="hljs-string"><span class="hljs-string">'ssid'</span></span>], config[<span class="hljs-string"><span class="hljs-string">'wifi_pw'</span></span>]) conn = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> conn: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.connect() conn = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.dprint(<span class="hljs-string"><span class="hljs-string">'Connected!'</span></span>) self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_run_main_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Loop forever mins = 0 while True: gc.collect() # For RAM stats. mem_free = gc.mem_free() mem_alloc = gc.mem_alloc() try: await self.publish_debug_msg("Uptime", mins) await self.publish_debug_msg("Repubs", self.REPUB_COUNT) await self.publish_debug_msg("Outages", self.internet_outages) await self.publish_debug_msg("MemFree", mem_free) await self.publish_debug_msg("MemAlloc", mem_alloc) except Exception as e: self.dprint("Exception occurred: ", e) mins += 1 await asyncio.sleep(60)</span></span></code> </pre> <br>  Nun, ein paar weitere Einstellungen und Konstanten, um die Beschreibung zu vervollständigen <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Constants and configuration ##################################### config['keepalive'] = 60 config['clean'] = False config['will'] = ('/ESP/Wemos/Water/LastWill', 'Goodbye cruel world!', False, 0) MQTTClient.DEBUG = True EEPROM_ADDR_HOT_VALUE = const(0) EEPROM_ADDR_COLD_VALUE = const(4)</span></span></code> </pre> <br>  Es beginnt so <br><br><pre> <code class="python hljs">client = CounterMQTTClient() loop = asyncio.get_event_loop() loop.run_until_complete(client.main())</code> </pre> <br><br><h3>  Etwas mit meiner Erinnerung ist geworden </h3><br>  Der gesamte Code ist also vorhanden.  Ich habe die Dateien mit dem Dienstprogramm ampy hochgeladen. Dadurch können sie auf das interne Flash-Laufwerk (das in ESP-07 selbst enthalten ist) hochgeladen und dann vom Programm aus wie normale Dateien aufgerufen werden.  Dort habe ich die von mir verwendeten Bibliotheken mqtt_as, uasyncio, ssd1306 und Sammlungen (in mqtt_as verwendet) hochgeladen. <br><br>  Wir starten und ... Wir erhalten MemoryError.  Je mehr ich versuchte, genau zu verstehen, wo der Speicher leckte, desto mehr arrangierte ich das Debuggen von Ausdrucken, desto früher trat dieser Fehler auf.  Ein kurzer Gugelezh führte mich zu dem Verständnis, dass der Mikrocontroller im Prinzip nur 30 KB Speicher hat, in den 65 KB Code (zusammen mit Bibliotheken) in keiner Weise passen. <br><br>  Aber es gibt einen Weg.  Es stellt sich heraus, dass Micropython keinen Code direkt aus der .py-Datei ausführt - diese Datei wird zuerst kompiliert.  Und es kompiliert direkt auf dem Mikrocontroller, verwandelt sich in Bytecode, der dann im Speicher gespeichert wird.  Damit der Compiler funktioniert, benötigen Sie außerdem eine bestimmte Menge an RAM. <br><br>  Der Trick besteht darin, den Mikrocontroller vor einer ressourcenintensiven Kompilierung zu schützen.  Sie können Dateien auf einem großen Computer kompilieren und den fertigen Bytecode in den Mikrocontroller eingeben.  Laden Sie dazu die Micropython-Firmware herunter und erstellen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstprogramm mpy-cross</a> . <br><br>  Ich habe kein Makefile geschrieben, sondern alle erforderlichen Dateien (einschließlich Bibliotheken) wie folgt manuell zusammengestellt und kompiliert <br><br><pre> <code class="bash hljs">mpy-cross water_counter.py</code> </pre> <br>  Es bleibt nur das Hochladen von Dateien mit der Erweiterung .mpy, nicht zu vergessen, zuerst die entsprechende .py aus dem Dateisystem des Geräts zu löschen. <br><br>  Ich habe alle Entwicklungen im Programm (IDE?) ESPlorer durchgeführt.  Sie können Skripte auf den Mikrocontroller hochladen und sofort ausführen.  In meinem Fall befinden sich die gesamte Logik und Erstellung aller Objekte in der Datei water_counter.py (.mpy).  Damit dies alles automatisch startet, muss zu Beginn eine andere Datei mit dem Namen main.py vorhanden sein.  Und es sollte genau .py sein und keine vorkompilierte .mpy.  Hier ist sein trivialer Inhalt <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> water_counter</code> </pre> <br>  Wir fangen an - alles funktioniert.  Aber es gibt gefährlich wenig freien Speicher - ungefähr 1 KB.  Ich habe immer noch Pläne, die Funktionalität des Geräts zu erweitern, und dieser Kilobyte wird mir offensichtlich nicht ausreichen.  Es stellte sich jedoch heraus, dass es für diesen Fall einen Ausweg gibt. <br><br>  Hier ist das Ding.  Obwohl die Dateien in Bytecode kompiliert sind und sich im internen Dateisystem befinden, werden sie tatsächlich immer noch in den RAM geladen und von dort ausgeführt.  Es stellt sich jedoch heraus, dass Micropython Bytecode direkt aus dem Flash-Speicher ausführen kann. Dazu müssen Sie ihn jedoch direkt in die Firmware einbetten.  Dies ist nicht schwierig, obwohl es auf meinem Netbook ziemlich lange gedauert hat (nur dort habe ich Linux). <br><br>  Der Algorithmus ist wie folgt: <br><br><ul><li>  Laden Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP Open SDK</a> herunter und installieren Sie es.  Dieses Ding erstellt einen Compiler und Bibliotheken für Programme unter ESP8266.  Es wird gemäß den Anweisungen auf der Hauptseite des Projekts zusammengestellt (ich habe die Einstellung STANDALONE = yes gewählt). </li><li>  Laden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micropython Sorts</a> herunter </li><li>  Legen Sie die erforderlichen Bibliotheken in den Ports / esp8266 / modules im Micropython-Baum ab </li><li>  Wir bauen die Firmware gemäß den Anweisungen in der <a href="">Datei ports / esp8266 / README.md zusammen</a> </li><li>  Gießen Sie die Firmware in den Mikrocontroller (ich mache dies unter Windows mit ESP8266Flasher-Programmen oder Python esptool) </li></ul><br>  Das war's, jetzt wird 'import ssd1306' den Code direkt von der Firmware abheben und RAM wird dafür nicht ausgegeben.  Mit diesem Trick habe ich nur den Bibliothekscode in die Firmware heruntergeladen, während der Hauptprogrammcode aus dem Dateisystem ausgeführt wird.  Auf diese Weise können Sie das Programm einfach ändern, ohne die Firmware neu zu kompilieren.  Im Moment habe ich ca. 8,5kb RAM frei.  Auf diese Weise können in Zukunft viele verschiedene nützliche Funktionen implementiert werden.  Wenn nicht genügend Speicher vorhanden ist, können Sie das Hauptprogramm auch in die Firmware verschieben. <br><br><h3>  Und was soll ich jetzt damit machen? </h3><br>  Ok, die Hardware ist verlötet, die Firmware ist geschrieben, die Box ist gedruckt, das Gerät klebt an der Wand und blinkt freudig mit einer Glühbirne.  Aber während dies alles eine Black Box ist (im wörtlichen und im übertragenen Sinne) und der Sinn davon immer noch nicht genug ist.  Es ist Zeit, etwas mit MQTT-Nachrichten zu tun, die an den Server gesendet werden. <br><br>  Mein „Smart Home“ dreht sich um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Majordomo-System</a> .  Das MQTT-Modul ist entweder sofort einsatzbereit oder kann einfach über den Add-On-Markt installiert werden. Ich weiß nicht mehr, woher es stammt.  MQTT-Ding ist nicht autark - das sogenannte  Broker - Ein Server, der MQTT-Nachrichten empfängt, sortiert und an Clients umleitet.  Ich benutze Mücken, die (wie Majordomo) alle auf demselben Netbook laufen. <br><br>  Nachdem das Gerät mindestens einmal eine Nachricht gesendet hat, wird der Wert sofort in der Liste angezeigt. <br><br><img src="https://habrastorage.org/webt/hf/ip/db/hfipdb1coxh_lsaaz600mi-39y0.png"><br><br>  Diese Werte können jetzt Systemobjekten zugeordnet, in Automatisierungsskripten verwendet und verschiedenen Analysen unterzogen werden - all dies ist nicht Gegenstand dieses Artikels.  Wer sich für das Majordomo-System interessiert, kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Electronics In Lens-Kanal</a> empfehlen - ein Freund baut auch ein intelligentes Haus und spricht verständlich über die Einrichtung des Systems. <br><br>  Ich werde nur ein paar Grafiken zeigen.  Dies ist ein einfaches Diagramm der Tageswerte. <br><br><img src="https://habrastorage.org/webt/km/hw/xr/kmhwxruql1fk0kmykb1gpcpci_0.png"><br>  Es ist zu sehen, dass fast niemand nachts Wasser benutzte.  Ein paar Mal ging jemand auf die Toilette und es sieht so aus, als würde ein Umkehrosmosefilter ein paar Liter pro Nacht saugen.  Am Morgen steigt der Verbrauch deutlich an.  Normalerweise benutze ich Wasser aus einem Kessel, aber dann wollte ich ein Bad nehmen und vorübergehend auf Stadtheißwasser umstellen - dies ist auch in der unteren Grafik deutlich sichtbar. <br><br>  Aus diesem Zeitplan habe ich gelernt, dass auf die Toilette gehen 6-7 Liter Wasser, Duschen - 20-30 Liter, Geschirr spülen ca. 20 Liter, und um ein Bad zu nehmen, braucht man 160 Liter.  Für einen Tag verbraucht meine Familie ungefähr 500-600l. <br><br>  Für die Neugierigsten können Sie sich die Einträge für jeden einzelnen Wert ansehen <br><br><img src="https://habrastorage.org/webt/8l/8i/su/8l8isu_aiaswajdeeuexytpwffi.png"><br><br>  Von hier aus erfuhr ich, dass bei geöffnetem Wasserhahn das Wasser mit einer Geschwindigkeit von etwa 1 Liter in 5 Sekunden fließt. <br><br>  Aber in dieser Form sind Statistiken wahrscheinlich nicht sehr bequem anzusehen.  In Majordomo besteht weiterhin die Möglichkeit, Verbrauchstabellen nach Tag, Woche und Monat anzuzeigen.  Zum Beispiel ein Diagramm des Verbrauchs in Spalten <br><br><img src="https://habrastorage.org/webt/m3/wa/sf/m3wasfzbvxb2tz1yhemod2ewwdy.png"><br><br>  Bisher habe ich nur Daten für eine Woche.  In einem Monat ist dieses Diagramm aussagekräftiger - eine separate Spalte entspricht jedem Tag.  Anpassungen der von mir manuell eingegebenen Werte beeinträchtigen das Bild ein wenig (die größte Spalte).  Und es ist noch nicht klar, ob ich die ersten Werte fast einen Würfel weniger falsch eingestellt habe oder ob dies ein Fehler in der Firmware ist und nicht alle Liter in die Aufrechnung gingen.  Es dauert länger. <br><br>  Es ist immer noch notwendig, über die Graphen selbst zu zaubern, weiß, Farbe.  Vielleicht werde ich auch ein Diagramm des Speicherverbrauchs für Debugging-Zwecke erstellen - plötzlich tritt dort etwas aus.  Vielleicht zeige ich irgendwie Zeiträume an, in denen das Internet nicht verfügbar war.  Während sich das alles auf der Ebene der Ideen dreht. <br><br><h3>  Fazit </h3><br>  Heute ist meine Wohnung etwas schlauer geworden.  Mit einem so kleinen Gerät ist es für mich bequemer, den Wasserverbrauch im Haus zu überwachen.  Wenn ich früher empört war, "wieder haben sie in einem Monat viel Wasser verbraucht", kann ich jetzt die Quelle dieses Verbrauchs finden. <br><br>  Es erscheint jemandem seltsam, die Messwerte auf dem Bildschirm zu sehen, wenn sie einen Meter vom Messgerät entfernt sind.  Aber in nicht allzu ferner Zukunft plane ich, in eine andere Wohnung zu ziehen, in der es mehrere Steigleitungen geben wird und die Zähler selbst höchstwahrscheinlich auf dem Treppenabsatz liegen werden.  Ein Fernlesegerät wäre also sehr hilfreich. <br><br>  Ich plane auch, die Funktionalität des Geräts zu erweitern.  Ich sehe mir bereits motorisierte Ventile an.  Um jetzt das Wasser in der Kesselstadt zu wechseln, muss ich 3 Wasserhähne in einer unzugänglichen Nische drehen.  Es wäre viel bequemer, dies mit einer Taste mit der entsprechenden Anzeige zu tun.  Natürlich lohnt es sich, einen Leckschutz zu implementieren. <br><br>  In dem Artikel habe ich meine Version des Geräts basierend auf ESP8266 erzählt.  Meiner Meinung nach habe ich eine sehr interessante Version der Micropython-Firmware mit Coroutine erhalten - einfach und hübsch.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe versucht, die vielen Nuancen und Schulen zu beschreiben, denen ich bei der Kampagne begegnet bin. </font><font style="vertical-align: inherit;">Vielleicht habe ich alles zu detailliert beschrieben, für mich persönlich ist es als Leser einfacher, zu viel zu verschwenden, als sich dann auszudenken, was nicht gesagt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie immer bin ich offen für konstruktive Kritik. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode- </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaltungs- und </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platinengehäusemodell</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de411259/">https://habr.com/ru/post/de411259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de411249/index.html">Wie ich meinen Yandex.Transport mit Fahrplänen und Bussen gemacht habe</a></li>
<li><a href="../de411251/index.html">Benutzer senden Chrome-Scandateien auf dem lokalen Laufwerk erneut</a></li>
<li><a href="../de411253/index.html">Die Verschmelzung von Neutronensternen setzte den Alternativen von Dunkler Materie und Dunkler Energie ein Ende</a></li>
<li><a href="../de411255/index.html">Dezentrale Apps für Millionen von Benutzern auf Ethereum</a></li>
<li><a href="../de411257/index.html">In den USA schaffen sie ein Lasersystem, das den Feind mit Geräuschen erschreckt</a></li>
<li><a href="../de411261/index.html">Vibrationsreaktion in Prothesen: Ein neuer Weg, um die Kontrolle über bionische Gliedmaßen zu verbessern</a></li>
<li><a href="../de411263/index.html">Magic Button für LED auf ATtiny4</a></li>
<li><a href="../de411265/index.html">Spionagefälle (Teil 3)</a></li>
<li><a href="../de411267/index.html">Wer steckt wirklich hinter den neuen Smartphones der Marke Nokia?</a></li>
<li><a href="../de411269/index.html">Die drei Komponenten von „LOAD“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>