<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¢ üëàüèΩ ‚òùüèª Wir verbinden einen Wasserz√§hler mit einem Smart Home üïü üëéüèº ü§¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fr√ºher waren Hausautomationssysteme, oder wie sie oft als ‚ÄûSmart Home‚Äú bezeichnet werden, furchtbar teuer und konnten sich nur reiche Leute leisten. H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir verbinden einen Wasserz√§hler mit einem Smart Home</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/411259/">  Fr√ºher waren Hausautomationssysteme, oder wie sie oft als ‚ÄûSmart Home‚Äú bezeichnet werden, furchtbar teuer und konnten sich nur reiche Leute leisten.  Heutzutage gibt es auf dem Markt recht kosteng√ºnstige Kits mit Sensoren, Tasten / Schaltern und Aktuatoren zur Steuerung von Beleuchtung, Steckdosen, Bel√ºftung, Wasserversorgung und anderen Verbrauchern.  Und selbst der <s>krivoruky</s> DIY-Shnik kann sich den sch√∂nen anschlie√üen und Ger√§te f√ºr ein Smart Home zu g√ºnstigen Preisen sammeln. <br><br><img src="https://habrastorage.org/webt/-a/k2/x6/-ak2x6li6an5gyqbrg2ett_-_au.jpeg"><br><br>  In der Regel sind die vorgeschlagenen Ger√§te entweder Sensoren oder Aktoren.  Sie erleichtern die Implementierung von Szenarien wie ‚ÄûSchalten Sie das Licht ein, wenn der Bewegungssensor ausgel√∂st wird‚Äú oder ‚ÄûDer Schalter am Ausgang l√∂scht das Licht in der gesamten Wohnung‚Äú.  Aber die Telemetrie hat irgendwie nicht geklappt.  Im besten Fall ist dies ein Diagramm der Temperatur und Luftfeuchtigkeit oder der momentanen Leistung in einer bestimmten Steckdose. <br><br>  K√ºrzlich habe ich einen Wasserz√§hler mit Impulsausgang installiert.  Ein Reedschalter wird durch jeden Liter durch das Messger√§t ausgel√∂st und schlie√üt den Kontakt.  Das einzige, was noch √ºbrig bleibt, ist, sich an die Dr√§hte zu klammern und zu versuchen, davon zu profitieren.  Analysieren Sie beispielsweise den Wasserverbrauch nach Stunde und Wochentag.  Wenn es in der Wohnung mehrere Steigleitungen f√ºr Wasser gibt, ist es bequemer, alle aktuellen Anzeigen auf einem Bildschirm zu sehen, als schwer zug√§ngliche Nischen mit einer Taschenlampe zu besteigen. <br><br>  Unter dem Schnitt basiert meine Version des Ger√§ts auf dem ESP8266, der Impulse von Wasserz√§hlern z√§hlt und Messwerte √ºber MQTT an den Smart-Home-Server sendet.  Wir werden in Mikropython mit der Uasyncio-Bibliothek programmieren.  Bei der Erstellung der Firmware bin ich auf einige interessante Schwierigkeiten gesto√üen, die ich auch in diesem Artikel diskutieren werde.  Lass uns gehen! <br><a name="habracut"></a><br><h3>  Schema </h3><br><img src="https://habrastorage.org/webt/i-/w2/o7/i-w2o7b8mfsommteri_mss88oa8.png"><br><br>  Das Herzst√ºck der gesamten Schaltung ist das Modul des Mikrocontrollers ESP8266.  ESP-12 war urspr√ºnglich geplant, aber meins erwies sich als defekt.  Ich musste mich mit dem verf√ºgbaren ESP-07-Modul zufrieden geben.  Gl√ºcklicherweise sind sie sowohl in Bezug auf die Schlussfolgerungen als auch in Bezug auf die Funktionalit√§t gleich. Der Unterschied besteht nur in der Antenne - der ESP-12 verf√ºgt √ºber eine integrierte Antenne und der ESP-07 √ºber eine externe Antenne.  Aber auch ohne WiFi-Antenne wird das Signal in meinem Badezimmer normal empfangen. <br><br>  Die Modulbindung ist Standard: <br><br><ul><li>  Reset-Taste mit Hosentr√§ger und Kondensator (obwohl sich beide bereits im Modul befinden) </li><li>  Aktivierungssignal (CH_PD) an die Stromversorgung gezogen </li><li>  GPIO15 zu Boden gezogen.  Dies ist nur zu Beginn notwendig, aber ich habe immer noch nichts mehr an diesem Bein festzuhalten </li></ul><br>  Um das Modul in den Firmware-Modus zu versetzen, m√ºssen Sie den GPIO2 gegen Masse schlie√üen, und um es bequemer zu machen, habe ich die Boot-Taste bereitgestellt.  Im Normalzustand wird dieser Stift an die Stromversorgung gezogen. <br><br>  Der Status der GPIO2-Leitung wird nur zu Beginn der Arbeit √ºberpr√ºft - beim Einschalten oder unmittelbar nach einem Reset.  Das Modul wird also entweder wie gewohnt geladen oder wechselt in den Firmware-Modus.  Nach dem Laden kann dieser Ausgang als normaler GPIO verwendet werden.  Nun, da es dort bereits eine Schaltfl√§che gibt, k√∂nnen Sie eine n√ºtzliche Funktion darauf setzen. <br><br>  Zum Programmieren und Debuggen werde ich den UART verwenden, der zum Kamm gebracht wurde.  Bei Bedarf stecke ich einfach einen USB-UART-Adapter ein.  Sie m√ºssen sich nur daran erinnern, dass das Modul mit 3,3 V betrieben wird.  Wenn Sie vergessen, den Adapter auf diese Spannung umzuschalten und 5 V anzulegen, brennt das Modul h√∂chstwahrscheinlich aus. <br><br>  Ich habe keine Probleme mit Strom im Badezimmer - die Steckdose befindet sich ungef√§hr einen Meter von den Z√§hlern entfernt, also werde ich sie mit 220 V versorgen.  Als Stromquelle werde ich einen kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Block HLK-PM03</a> von Tenstar Robot bearbeiten.  Pers√∂nlich bin ich eng mit Analog- und Leistungselektronik verbunden, aber hier ist ein fertiges Netzteil in einem kleinen Fall. <br><br>  Um die Betriebsarten zu signalisieren, habe ich eine an GPIO2 angeschlossene LED bereitgestellt.  Ich habe jedoch nicht angefangen, es zu l√∂ten, weil  Das ESP-07-Modul verf√ºgt au√üerdem bereits √ºber eine LED, die an denselben GPIO2 angeschlossen ist.  Aber lass es auf der Platine sein - pl√∂tzlich m√∂chte ich diese LED zum Geh√§use bringen. <br><br>  Wir gehen zu den interessantesten √ºber.  Wasserz√§hler haben keine Logik und k√∂nnen nicht nach aktuellen Messwerten gefragt werden.  Das einzige, was uns zur Verf√ºgung steht, sind Impulse - das Schlie√üen der Kontakte des Reed-Schalters pro Liter.  Die Schlussfolgerungen der Reed-Schalter sind in GPIO12 / GPIO13 festgelegt.  Ich werde den Pull-up-Widerstand programmgesteuert im Modul einschalten. <br><br>  Anfangs habe ich vergessen, die Widerst√§nde R8 und R9 bereitzustellen, und in meiner Version der Platine sind dies nicht der Fall.  Da ich das Programm jedoch bereits √∂ffentlich ausstelle, lohnt es sich, dieses Versehen zu korrigieren.  Es werden Widerst√§nde ben√∂tigt, um den Anschluss nicht zu verbrennen, wenn die Firmware fehlerhaft ist und das Ger√§t auf den Pin setzt, und der Reed-Schalter schlie√üt diese Leitung gegen Masse kurz (maximal 3,3 V / 1000 Ohm = 3,3 mA flie√üen mit dem Widerstand). <br><br>  Es ist Zeit zu √ºberlegen, was zu tun ist, wenn der Strom ausf√§llt.  Die erste M√∂glichkeit besteht darin, den Server beim Start nach ersten Z√§hlern zu fragen.  Dies w√ºrde jedoch eine erhebliche Komplikation des Austauschprotokolls erfordern.  Dar√ºber hinaus h√§ngt die Funktionsf√§higkeit des Ger√§ts in diesem Fall vom Status des Servers ab.  Wenn der Server nach dem Ausschalten des Lichts nicht gestartet wurde (oder sp√§ter gestartet wurde), konnte der Wasserz√§hler die Anfangswerte nicht anfordern und funktionierte nicht ordnungsgem√§√ü. <br><br>  Daher habe ich mich entschlossen, die Speicherung von Z√§hlerwerten in einem √ºber I2C verbundenen Speicherchip zu implementieren.  Ich habe keine besonderen Anforderungen an die Gr√∂√üe des Flash-Speichers - ich muss nur 2 Zahlen speichern (die Anzahl der Liter in Hei√ü- und Kaltwasserz√§hlern).  Selbst das kleinste Modul reicht aus.  Bei der Anzahl der Aufnahmezyklen m√ºssen Sie jedoch aufpassen.  F√ºr die meisten Module sind dies 100.000 Zyklen, f√ºr einige bis zu einer Million. <br><br>  Es scheint, eine Million ist viel.  Aber f√ºr 4 Jahre in meiner Wohnung habe ich etwas mehr als 500 Kubikmeter Wasser verbraucht, das sind 500.000 Liter!  Und 500 Tausend Eintr√§ge im Blitz.  Und das ist nur kaltes Wasser.  Sie k√∂nnen den Chip nat√ºrlich alle paar Jahre l√∂ten, aber es stellte sich heraus, dass es FRAM-Chips gibt.  Aus programmtechnischer Sicht ist dies das gleiche I2C-EEPROM, jedoch mit einer sehr gro√üen Anzahl von Umschreibungszyklen (Hunderte von Millionen).  Das ist nur so lange, bis alles mit solchen Chips in irgendeiner Weise in den Laden kommt, also wird der √ºbliche 24LC512 vorerst bestehen bleiben. <br><br><h3>  Leiterplatte </h3><br>  Anfangs wollte ich zu Hause eine Geb√ºhr erheben.  Daher wurde das Board einseitig gestaltet.  Aber nach einer langen Stunde mit einem Lasereisen und einer L√∂tmaske (ohne dass es irgendwie komisch w√§re) entschied ich mich immer noch, Bretter bei den Chinesen zu bestellen. <br><br><img src="https://habrastorage.org/webt/en/si/rz/ensirzhmczp3bs9n7a6a8plmzl4.png"><br><br>  Fast vor der Bestellung der Karte wurde mir klar, dass Sie neben dem Flash-Speicherchip am I2C-Bus noch etwas N√ºtzliches wie ein Display mitnehmen k√∂nnen.  Was genau darauf ausgegeben werden soll, ist noch eine Frage, aber Sie m√ºssen auf dem Brett z√ºchten.  Nun, da ich die Boards im Werk bestellen wollte, machte es keinen Sinn, mich auf ein einseitiges Board zu beschr√§nken, daher sind die Leitungen auf I2C die einzigen auf der R√ºckseite des Boards. <br><br>  Ein gro√üer Pfosten war auch mit einseitiger Verkabelung verbunden.  Weil  Die Platine wurde auf der einen Seite gezeichnet, die Schienen und SMD-Komponenten sollten auf der einen Seite und die Ausgangskomponenten, Anschl√ºsse und das Netzteil auf der anderen Seite platziert werden.  Als ich die Boards in einem Monat erhielt, verga√ü ich den urspr√ºnglichen Plan und entpackte alle Komponenten auf der Vorderseite.  Und nur beim L√∂ten des Netzteils stellte sich heraus, dass Plus und Minus im Gegenteil geschieden waren.  Ich musste mit Springern Kollektivfarmen betreiben.  Im obigen Bild habe ich die Verkabelung bereits ge√§ndert, aber die Masse wird √ºber die Ausg√§nge der Boot-Taste von einem Teil der Platine zum anderen geworfen (obwohl es m√∂glich w√§re, eine Spur auf der zweiten Ebene zu zeichnen). <br><br>  Es stellte sich so heraus <br><br><img src="https://habrastorage.org/webt/au/-d/cs/au-dcsvpehh9p5g9iqyob5hjslu.jpeg"><br><br><h3>  Geh√§use </h3><br>  Der n√§chste Schritt ist das Geh√§use.  Mit einem 3D-Drucker ist dies kein Problem.  Ich habe mich nicht viel darum gek√ºmmert - ich habe nur eine Schachtel mit der richtigen Gr√∂√üe gezeichnet und an den richtigen Stellen Ausschnitte gemacht.  Die Abdeckung wird mit kleinen Schrauben am Geh√§use befestigt. <br><br><img src="https://habrastorage.org/webt/qq/lu/zp/qqluzptanq4d24dsv4jdlb9uif8.png"><br><br>  Ich habe bereits erw√§hnt, dass die Boot-Taste als Allzweck-Taste verwendet werden kann - hier bringen wir sie auf die Vorderseite.  Zu diesem Zweck habe ich einen speziellen ‚ÄûBrunnen‚Äú gezeichnet, in dem der Knopf lebt. <br><br><img src="https://habrastorage.org/webt/dv/xg/gn/dvxggnexv-fiqy0jqtptpdk1dvy.png"><br><br>  Im Inneren des Geh√§uses befinden sich auch St√ºmpfe, auf denen die Platine mit einer einzigen M3-Schraube installiert und befestigt wird (auf der Platine war kein Platz mehr). <br><br>  Das Display wurde ausgew√§hlt, als ich die erste passende Version des Geh√§uses druckte.  Die Standard-Zweilinie passte nicht in dieses Geh√§use, aber im Gimbal wurde ein OLED-Display SSD1306 128x32 gefunden.  Es ist klein, aber ich muss ihn nicht jeden Tag ansehen - es wird rollen. <br><br>  Ich sch√§tzte beide Richtungen und wie die Dr√§hte von ihm verlegt werden, und beschloss, das Display in die Mitte des Geh√§uses zu stecken.  Ergonomie nat√ºrlich unter der Fu√üleiste - ein Knopf oben, ein Display unten.  Aber ich habe bereits gesagt, dass die Idee, das Display zu vermasseln, zu sp√§t kam und es zu faul war, das Board neu anzuordnen, um den Knopf zu bewegen. <br><br>  Das Ger√§t ist fertig.  Das Anzeigemodul wird auf die Schmelzd√ºsen geklebt <br><br><img src="https://habrastorage.org/webt/sn/qr/xf/snqrxfyyihzqwiwwwf-1yly545m.jpeg"><br><br><img src="https://habrastorage.org/webt/ow/bh/2o/owbh2oguwv4tiez2basnv11hgvw.jpeg"><br><br>  Das Endergebnis ist auf KDPV zu sehen <br><br><h3>  Firmware </h3><br>  Fahren wir mit dem Softwareteil fort.  F√ºr solch kleine Handwerke verwende ich sehr gerne die Python-Sprache ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micropython</a> ) - der Code ist sehr kompakt und verst√§ndlich.  Gl√ºcklicherweise ist es nicht erforderlich, auf die Registerebene zu gehen, um Mikrosekunden zu komprimieren - alles kann von Python aus erfolgen. <br><br>  Es scheint alles einfach, aber nicht sehr einfach zu sein - mehrere unabh√§ngige Funktionen sind im Ger√§t beschrieben: <br><br><ul><li>  Der Benutzer dr√ºckt eine Taste und schaut auf das Display </li><li>  Liter ticken und aktualisieren die Werte im Flash-Speicher </li><li>  Das Modul √ºberwacht das WLAN-Signal und stellt bei Bedarf eine neue Verbindung her </li><li>  Nun, ohne ein blinkendes Licht k√∂nnen Sie es √ºberhaupt nicht tun </li></ul><br>  Es ist unm√∂glich anzunehmen, dass eine Funktion nicht funktioniert hat, wenn die andere aus irgendeinem Grund dumm ist.  Ich habe bereits in anderen Projekten Kakteen gegessen, und jetzt sehe ich St√∂rungen im Stil ‚Äûeinen weiteren Liter verpasst, weil in diesem Moment die Anzeige aktualisiert wurde‚Äú oder ‚Äûder Benutzer kann nichts tun, w√§hrend das Modul eine Verbindung zu WiFi herstellt‚Äú.  Nat√ºrlich k√∂nnen einige Dinge durch Interrupts erledigt werden, aber Sie k√∂nnen auf eine Einschr√§nkung der Dauer, der Verschachtelung von Aufrufen oder der nichtatomaren √Ñnderung von Variablen sto√üen.  Nun, der Code, der alles macht und sich sofort schnell in ein Chaos verwandelt. <br><br>  In dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt habe</a> ich das klassische pr√§emptive Multitasking und FreeRTOS ernsthafter verwendet, aber in diesem Fall <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwiesen</a> sich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coroutine-</a> Modell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und die Uasync-Bibliothek</a> als viel geeigneter.  Dar√ºber hinaus ist die Pitonovskiy-Implementierung von Corutin nur eine Bombe - f√ºr den Programmierer war alles einfach und bequem erledigt.  Schreiben Sie einfach Ihre eigene Logik und sagen Sie mir, an welchen Stellen Sie zwischen Threads wechseln k√∂nnen. <br><br>  Ich schlage vor, die Unterschiede zwischen Verdr√§ngung und wettbewerbsf√§higem Multitasking optional zu untersuchen.  Kommen wir nun endlich zum Code. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Counter class - implements a single water counter on specified pin ##################################### class Counter(): debounce_ms = const(25) def __init__(self, pin_num, value_storage): self._value_storage = value_storage self._value = self._value_storage.read() self._value_changed = False self._pin = Pin(pin_num, Pin.IN, Pin.PULL_UP) loop = asyncio.get_event_loop() loop.create_task(self._switchcheck()) # Thread runs forever</span></span></code> </pre> <br>  Jeder Z√§hler wird von einer Instanz der Counter-Klasse verarbeitet.  Zun√§chst wird der Anfangswert des Z√§hlers vom EEPROM (value_storage) abgezogen - auf diese Weise wird die Wiederherstellung nach einem Stromausfall implementiert. <br><br>  Der Pin wird mit einem eingebauten Pull-up zur Stromversorgung initialisiert: Wenn der Reed-Schalter geschlossen ist, ist er Null in der Leitung. Wenn die Leitung offen ist, wird die Leitung an die Stromversorgung gezogen und der Controller liest eins. <br><br>  Au√üerdem wird hier eine separate Aufgabe gestartet, die den Pin abfragt.  Jeder Z√§hler f√ºhrt seine eigene Aufgabe aus.  Hier ist ihr Code <br><br><pre> <code class="python hljs"> <span class="hljs-string"><span class="hljs-string">""" Poll pin and advance value when another litre passed """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_switchcheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> last_checked_pin_state = self._pin.value() <span class="hljs-comment"><span class="hljs-comment"># Get initial state # Poll for a pin change while True: state = self._pin.value() if state != last_checked_pin_state: # State has changed: act on it now. last_checked_pin_state = state if state == 0: self._another_litre_passed() # Ignore further state changes until switch has settled await asyncio.sleep_ms(Counter.debounce_ms)</span></span></code> </pre> <br>  Zum Filtern des Kontaktsprungs ist eine Verz√∂gerung von 25 ms erforderlich, die gleichzeitig regelt, wie oft die Aufgabe aufwacht (w√§hrend diese Aufgabe schl√§ft, funktionieren andere Aufgaben).  Alle 25 ms wacht die Funktion auf, √ºberpr√ºft den Stift und wenn die Kontakte des Reed-Schalters geschlossen sind, ist ein weiterer Liter durch den Z√§hler geflossen und dieser muss verarbeitet werden. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_another_litre_passed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._value += <span class="hljs-number"><span class="hljs-number">1</span></span> self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self._value_storage.write(self._value)</code> </pre> <br>  Die Verarbeitung des n√§chsten Liters ist trivial - der Z√§hler erh√∂ht sich einfach.  Nun, ein neuer Wert w√§re sch√∂n, auf ein Flash-Laufwerk zu schreiben. <br><br>  Zur Vereinfachung der Verwendung werden ‚ÄûAccessoren‚Äú bereitgestellt. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self._value = value self._value_changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Nun nutzen wir die Freuden von Python und der Uasync-Bibliothek und machen das Gegenobjekt wartbar (wie kann dies ins Russische √ºbersetzt werden? Das, was zu erwarten ist?) <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__await__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._value_changed: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.value() __iter__ = __await__</code> </pre> <br>  Dies ist eine so praktische Funktion, die wartet, bis der Z√§hlerwert aktualisiert wird. Die Funktion wird von Zeit zu Zeit aktiviert und √ºberpr√ºft das Flag _value_changed.  Der Witz dieser Funktion ist, dass der aufrufende Code bei einem Aufruf dieser Funktion einschlafen und schlafen kann, bis ein neuer Wert empfangen wird. <br><br><div class="spoiler">  <b class="spoiler_title">Aber was ist mit Interrupts?</b> <div class="spoiler_text">  Ja, an dieser Stelle k√∂nnen Sie mich trollen und sagen, dass er selbst √ºber Unterbrechungen gesprochen hat, aber tats√§chlich hat er eine dumme Umfrage √ºber die Stecknadel arrangiert.  In der Tat sind Interrupts das erste, was ich versucht habe.  In ESP8266 k√∂nnen Sie einen Interrupt am Rand organisieren und sogar einen Handler f√ºr diesen Interrupt in Python schreiben.  In diesem Interrupt k√∂nnen Sie den Wert einer Variablen aktualisieren.  Wahrscheinlich w√ºrde dies ausreichen, wenn der Z√§hler ein Slave-Ger√§t w√§re - eines, das wartet, bis es nach diesem Wert gefragt wird. <br><br>  Leider (oder zum Gl√ºck?) Ist mein Ger√§t aktiv, es muss Nachrichten mit dem MQTT-Protokoll senden und Daten in das EEPROM schreiben.  Und hier kommen die Einschr√§nkungen bereits ins Spiel - Sie k√∂nnen keinen Speicher zuweisen und keinen gro√üen Stapel in Interrupts verwenden, was bedeutet, dass Sie das Senden von Nachrichten √ºber das Netzwerk vergessen k√∂nnen.  Es gibt Br√∂tchen wie micropython.schedule (), mit denen Sie eine Funktion "sofort" ausf√ºhren k√∂nnen, aber die Frage lautet "Was ist der Sinn?".  Pl√∂tzlich senden wir gerade eine Art Nachricht, und hier verkeilt und unterbricht der Interrupt die Werte der Variablen.  Oder es ist beispielsweise ein neuer Z√§hlerwert vom Server eingetroffen, w√§hrend wir den alten noch nicht notiert haben.  Im Allgemeinen m√ºssen Sie die Synchronisation umz√§unen oder irgendwie anders raus. <br><br>  Und von Zeit zu Zeit st√ºrzt RuntimeError ab: Zeitplanstapel voll und wer wei√ü warum? <br><br>  Mit einer expliziten Umfrage und Uasync ist es in diesem Fall irgendwie sch√∂ner und zuverl√§ssiger. <br></div></div><br>  Ich habe in einer kleinen Klasse mit EEPROM gearbeitet <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EEPROM</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> i2c_addr = const(<span class="hljs-number"><span class="hljs-number">80</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, i2c)</span></span></span><span class="hljs-function">:</span></span> self.i2c = i2c self.i2c_buf = bytearray(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Avoid creation/destruction of the buffer on each call def read(self, eeprom_addr): self.i2c.readfrom_mem_into(self.i2c_addr, eeprom_addr, self.i2c_buf, addrsize=16) return ustruct.unpack_from("&lt;I", self.i2c_buf)[0] def write(self, eeprom_addr, value): ustruct.pack_into("&lt;I", self.i2c_buf, 0, value) self.i2c.writeto_mem(self.i2c_addr, eeprom_addr, self.i2c_buf, addrsize=16)</span></span></code> </pre> <br>  In Python ist es schwierig, direkt mit Bytes zu arbeiten, aber es sind Bytes, die in den Speicher geschrieben werden.  Ich musste die Konvertierung zwischen Integer und Bytes mithilfe der Ustruct-Bibliothek korrigieren. <br><br>  Um das I2C-Objekt und die Speicherzellenadresse nicht jedes Mal zu √ºbertragen, habe ich alles in einen kleinen und praktischen Klassiker verpackt <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EEPROMValue</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, i2c, eeprom_addr)</span></span></span><span class="hljs-function">:</span></span> self._eeprom = EEPROM(i2c) self._eeprom_addr = eeprom_addr <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._eeprom.read(self._eeprom_addr) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self._eeprom.write(self._eeprom_addr, value)</code> </pre> <br>  Das I2C-Objekt selbst wird mit solchen Parametern erstellt <br><br><pre> <code class="python hljs">i2c = I2C(freq=<span class="hljs-number"><span class="hljs-number">400000</span></span>, scl=Pin(<span class="hljs-number"><span class="hljs-number">5</span></span>), sda=Pin(<span class="hljs-number"><span class="hljs-number">4</span></span>))</code> </pre> <br>  Wir n√§hern uns dem Interessantesten - der Implementierung der Kommunikation mit dem Server √ºber MQTT.  Nun, das Protokoll selbst muss nicht implementiert werden - eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigte asynchrone Implementierung</a> wurde im Internet gefunden.  Hier werden wir es verwenden. <br><br>  Das Interessanteste ist in der Klasse CounterMQTTClient zusammengefasst, die auf der Bibliothek MQTTClient basiert.  Beginnen wir an der Peripherie <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Class handles both counters and sends their status to MQTT ##################################### class CounterMQTTClient(MQTTClient): blue_led = Pin(2, Pin.OUT, value = 1) button = Pin(0, Pin.IN) hot_counter = Counter(12, EEPROMValue(i2c, EEPROM_ADDR_HOT_VALUE)) cold_counter = Counter(13, EEPROMValue(i2c, EEPROM_ADDR_COLD_VALUE))</span></span></code> </pre> <br>  Hier werden Stifte von Gl√ºhbirnen und Kn√∂pfen sowie Objekte von Kalt- und Warmwasserz√§hlern erstellt und konfiguriert. <br><br>  Bei der Initialisierung ist nicht alles so trivial <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.internet_outages = <span class="hljs-number"><span class="hljs-number">0</span></span> self.internet_outage_start = ticks_ms() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"config.txt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config_file: config[<span class="hljs-string"><span class="hljs-string">'ssid'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'wifi_pw'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'server'</span></span>] = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'client_id'</span></span>] = config_file.readline().rstrip() self._mqtt_cold_water_theme = config_file.readline().rstrip() self._mqtt_hot_water_theme = config_file.readline().rstrip() self._mqtt_debug_water_theme = config_file.readline().rstrip() config[<span class="hljs-string"><span class="hljs-string">'subs_cb'</span></span>] = self.mqtt_msg_handler config[<span class="hljs-string"><span class="hljs-string">'wifi_coro'</span></span>] = self.wifi_connection_handler config[<span class="hljs-string"><span class="hljs-string">'connect_coro'</span></span>] = self.mqtt_connection_handler config[<span class="hljs-string"><span class="hljs-string">'clean'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> config[<span class="hljs-string"><span class="hljs-string">'clean_init'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> super().__init__(config) loop = asyncio.get_event_loop() loop.create_task(self._heartbeat()) loop.create_task(self._counter_coro(self.cold_counter, self._mqtt_cold_water_theme)) loop.create_task(self._counter_coro(self.hot_counter, self._mqtt_hot_water_theme)) loop.create_task(self._display_coro())</code> </pre> <br>  Um die Parameter der Bibliothek mqtt_as festzulegen, wird ein gro√ües W√∂rterbuch mit verschiedenen Einstellungen verwendet - config.  Die meisten Standardeinstellungen passen zu uns, aber viele Einstellungen m√ºssen explizit festgelegt werden.  Um die Einstellungen nicht direkt im Code zu registrieren, speichere ich sie in der Textdatei config.txt.  Auf diese Weise k√∂nnen Sie den Code unabh√§ngig von den Einstellungen √§ndern und mehrere identische Ger√§te mit unterschiedlichen Parametern nieten. <br><br>  Der letzte Codeblock f√ºhrt mehrere Coroutinen aus, um verschiedene Funktionen des Systems zu erf√ºllen.  Hier ist ein Beispiel f√ºr eine Coroutine, die Z√§hlern dient <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_counter_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, counter, topic)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Publish initial value value = counter.value() await self.publish(topic, str(value)) # Publish each new value while True: value = await counter await self.publish_msg(topic, str(value))</span></span></code> </pre> <br>  In einem Zyklus wartet Corutin auf einen neuen Z√§hlerwert und sendet, sobald dieser angezeigt wird, eine Nachricht unter Verwendung des MQTT-Protokolls.  Der erste Code sendet den Anfangswert, auch wenn das Wasser nicht durch den Z√§hler flie√üt. <br><br>  Die MQTTClient-Basisklasse bedient sich selbst, initiiert eine WiFi-Verbindung und stellt die Verbindung wieder her, wenn die Verbindung unterbrochen wird.  Wenn sich der WiFi-Verbindungsstatus √§ndert, informiert uns die Bibliothek durch Aufrufen von wifi_connection_handler <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wifi_connection_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, state)</span></span></span><span class="hljs-function">:</span></span> self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state: self.dprint(<span class="hljs-string"><span class="hljs-string">'WiFi is up.'</span></span>) duration = ticks_diff(ticks_ms(), self.internet_outage_start) // <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.publish_debug_msg(<span class="hljs-string"><span class="hljs-string">'ReconnectedAfter'</span></span>, duration) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.internet_outages += <span class="hljs-number"><span class="hljs-number">1</span></span> self.internet_outage_start = ticks_ms() self.dprint(<span class="hljs-string"><span class="hljs-string">'WiFi is down.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Die Funktion wird ehrlich aus den Beispielen geleckt.  In diesem Fall werden die Anzahl der Verbindungsabbr√ºche (internet_outages) und deren Dauer ber√ºcksichtigt.  Wenn eine Verbindung wiederhergestellt wird, werden Ausfallzeiten an den Server gesendet. <br><br>  √úbrigens wird der letzte Schlaf nur ben√∂tigt, damit die Funktion asynchron wird - in der Bibliothek wird sie √ºber await aufgerufen, und nur Funktionen, in deren K√∂rper sich ein weiteres Warten befindet, k√∂nnen aufgerufen werden. <br><br>  Neben der Verbindung zu WiFi m√ºssen Sie auch eine Verbindung zum MQTT-Broker (Server) herstellen.  Die Bibliothek tut dies auch, aber wir haben die M√∂glichkeit, etwas N√ºtzliches zu tun, wenn die Verbindung hergestellt wird. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mqtt_connection_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, client)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.subscribe(self._mqtt_cold_water_theme) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.subscribe(self._mqtt_hot_water_theme)</code> </pre> <br>  Hier abonnieren wir mehrere Nachrichten - der Server hat jetzt die M√∂glichkeit, die aktuellen Z√§hlerwerte durch Senden der entsprechenden Nachricht festzulegen. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mqtt_msg_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, topic, msg)</span></span></span><span class="hljs-function">:</span></span> topicstr = str(topic, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>) self.dprint(<span class="hljs-string"><span class="hljs-string">"Received MQTT message topic={}, msg={}"</span></span>.format(topicstr, msg)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> topicstr == self._mqtt_cold_water_theme: self.cold_counter.set_value(int(msg)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> topicstr == self._mqtt_hot_water_theme: self.hot_counter.set_value(int(msg))</code> </pre> <br>  Diese Funktion verarbeitet eingehende Nachrichten und abh√§ngig vom Thema (Nachrichtenname) werden die Werte eines der Z√§hler aktualisiert <br><br>  Ein paar Hilfsfunktionen <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Publish a message if WiFi and broker is up, else discard async def publish_msg(self, topic, msg): self.dprint("Publishing message on topic {}: {}".format(topic, msg)) if not self.internet_outage: await self.publish(topic, msg) else: self.dprint("Message was not published - no internet connection")</span></span></code> </pre> <br>  Diese Funktion sendet Nachrichten, wenn eine Verbindung hergestellt wird.  Wenn keine Verbindung besteht, wird die Nachricht ignoriert. <br><br>  Und dies ist nur eine praktische Funktion, die Debugging-Nachrichten generiert und sendet. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publish_debug_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, subtopic, msg)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.publish_msg(<span class="hljs-string"><span class="hljs-string">"{}/{}"</span></span>.format(self._mqtt_debug_water_theme, subtopic), str(msg))</code> </pre><br>  So viel Text, aber wir haben keine LED geblinkt.  Hier <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Blink flash LED if WiFi down async def _heartbeat(self): while True: if self.internet_outage: self.blue_led(not self.blue_led()) # Fast blinking if no connection await asyncio.sleep_ms(200) else: self.blue_led(0) # Rare blinking when connected await asyncio.sleep_ms(50) self.blue_led(1) await asyncio.sleep_ms(5000)</span></span></code> </pre> <br>  Ich habe 2 Blinkmodi bereitgestellt.  Wenn die Verbindung unterbrochen wird (oder gerade hergestellt wird), blinkt das Ger√§t schnell.  Wenn die Verbindung hergestellt ist, blinkt das Ger√§t alle 5 Sekunden.  Bei Bedarf k√∂nnen Sie hier andere Blinkmodi implementieren. <br><br>  Aber die LED verw√∂hnt so.  Wir winkten immer noch zum Display. <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_display_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> display = SSD1306_I2C(<span class="hljs-number"><span class="hljs-number">128</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>, i2c) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: display.poweron() display.fill(<span class="hljs-number"><span class="hljs-number">0</span></span>) display.text(<span class="hljs-string"><span class="hljs-string">"COLD: {:.3f}"</span></span>.format(self.cold_counter.value() / <span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) display.text(<span class="hljs-string"><span class="hljs-string">"HOT: {:.3f}"</span></span>.format(self.hot_counter.value() / <span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) display.show() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">3</span></span>) display.poweroff() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.button(): <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep_ms(<span class="hljs-number"><span class="hljs-number">20</span></span>)</code> </pre> <br>  Dar√ºber habe ich gesprochen - wie einfach und bequem mit Coroutinen.  Diese kleine Funktion beschreibt ALLE Benutzerinteraktionen.  Corutin wartet nur auf das Dr√ºcken einer Taste und schaltet das Display 3 Sekunden lang ein.  Das Display zeigt die aktuellen Z√§hlerst√§nde an. <br><br>  Es gibt noch ein paar Kleinigkeiten.  Hier ist die Funktion, die die gesamte Farm (re) ausf√ºhrt.  Der Hauptzyklus behandelt nur das Senden verschiedener Debugging-Informationen einmal pro Minute.  Im Allgemeinen zitiere ich so wie es ist - insbesondere ein Kommentar, denke ich, ist nicht notwendig <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self._connect_to_WiFi() <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self._run_main_loop() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: self.dprint(<span class="hljs-string"><span class="hljs-string">'Global communication failure: '</span></span>, e) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_connect_to_WiFi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.dprint(<span class="hljs-string"><span class="hljs-string">'Connecting to WiFi and MQTT'</span></span>) sta_if = network.WLAN(network.STA_IF) sta_if.connect(config[<span class="hljs-string"><span class="hljs-string">'ssid'</span></span>], config[<span class="hljs-string"><span class="hljs-string">'wifi_pw'</span></span>]) conn = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> conn: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> self.connect() conn = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.dprint(<span class="hljs-string"><span class="hljs-string">'Connected!'</span></span>) self.internet_outage = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_run_main_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Loop forever mins = 0 while True: gc.collect() # For RAM stats. mem_free = gc.mem_free() mem_alloc = gc.mem_alloc() try: await self.publish_debug_msg("Uptime", mins) await self.publish_debug_msg("Repubs", self.REPUB_COUNT) await self.publish_debug_msg("Outages", self.internet_outages) await self.publish_debug_msg("MemFree", mem_free) await self.publish_debug_msg("MemAlloc", mem_alloc) except Exception as e: self.dprint("Exception occurred: ", e) mins += 1 await asyncio.sleep(60)</span></span></code> </pre> <br>  Nun, ein paar weitere Einstellungen und Konstanten, um die Beschreibung zu vervollst√§ndigen <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##################################### # Constants and configuration ##################################### config['keepalive'] = 60 config['clean'] = False config['will'] = ('/ESP/Wemos/Water/LastWill', 'Goodbye cruel world!', False, 0) MQTTClient.DEBUG = True EEPROM_ADDR_HOT_VALUE = const(0) EEPROM_ADDR_COLD_VALUE = const(4)</span></span></code> </pre> <br>  Es beginnt so <br><br><pre> <code class="python hljs">client = CounterMQTTClient() loop = asyncio.get_event_loop() loop.run_until_complete(client.main())</code> </pre> <br><br><h3>  Etwas mit meiner Erinnerung ist geworden </h3><br>  Der gesamte Code ist also vorhanden.  Ich habe die Dateien mit dem Dienstprogramm ampy hochgeladen. Dadurch k√∂nnen sie auf das interne Flash-Laufwerk (das in ESP-07 selbst enthalten ist) hochgeladen und dann vom Programm aus wie normale Dateien aufgerufen werden.  Dort habe ich die von mir verwendeten Bibliotheken mqtt_as, uasyncio, ssd1306 und Sammlungen (in mqtt_as verwendet) hochgeladen. <br><br>  Wir starten und ... Wir erhalten MemoryError.  Je mehr ich versuchte, genau zu verstehen, wo der Speicher leckte, desto mehr arrangierte ich das Debuggen von Ausdrucken, desto fr√ºher trat dieser Fehler auf.  Ein kurzer Gugelezh f√ºhrte mich zu dem Verst√§ndnis, dass der Mikrocontroller im Prinzip nur 30 KB Speicher hat, in den 65 KB Code (zusammen mit Bibliotheken) in keiner Weise passen. <br><br>  Aber es gibt einen Weg.  Es stellt sich heraus, dass Micropython keinen Code direkt aus der .py-Datei ausf√ºhrt - diese Datei wird zuerst kompiliert.  Und es kompiliert direkt auf dem Mikrocontroller, verwandelt sich in Bytecode, der dann im Speicher gespeichert wird.  Damit der Compiler funktioniert, ben√∂tigen Sie au√üerdem eine bestimmte Menge an RAM. <br><br>  Der Trick besteht darin, den Mikrocontroller vor einer ressourcenintensiven Kompilierung zu sch√ºtzen.  Sie k√∂nnen Dateien auf einem gro√üen Computer kompilieren und den fertigen Bytecode in den Mikrocontroller eingeben.  Laden Sie dazu die Micropython-Firmware herunter und erstellen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstprogramm mpy-cross</a> . <br><br>  Ich habe kein Makefile geschrieben, sondern alle erforderlichen Dateien (einschlie√ülich Bibliotheken) wie folgt manuell zusammengestellt und kompiliert <br><br><pre> <code class="bash hljs">mpy-cross water_counter.py</code> </pre> <br>  Es bleibt nur das Hochladen von Dateien mit der Erweiterung .mpy, nicht zu vergessen, zuerst die entsprechende .py aus dem Dateisystem des Ger√§ts zu l√∂schen. <br><br>  Ich habe alle Entwicklungen im Programm (IDE?) ESPlorer durchgef√ºhrt.  Sie k√∂nnen Skripte auf den Mikrocontroller hochladen und sofort ausf√ºhren.  In meinem Fall befinden sich die gesamte Logik und Erstellung aller Objekte in der Datei water_counter.py (.mpy).  Damit dies alles automatisch startet, muss zu Beginn eine andere Datei mit dem Namen main.py vorhanden sein.  Und es sollte genau .py sein und keine vorkompilierte .mpy.  Hier ist sein trivialer Inhalt <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> water_counter</code> </pre> <br>  Wir fangen an - alles funktioniert.  Aber es gibt gef√§hrlich wenig freien Speicher - ungef√§hr 1 KB.  Ich habe immer noch Pl√§ne, die Funktionalit√§t des Ger√§ts zu erweitern, und dieser Kilobyte wird mir offensichtlich nicht ausreichen.  Es stellte sich jedoch heraus, dass es f√ºr diesen Fall einen Ausweg gibt. <br><br>  Hier ist das Ding.  Obwohl die Dateien in Bytecode kompiliert sind und sich im internen Dateisystem befinden, werden sie tats√§chlich immer noch in den RAM geladen und von dort ausgef√ºhrt.  Es stellt sich jedoch heraus, dass Micropython Bytecode direkt aus dem Flash-Speicher ausf√ºhren kann. Dazu m√ºssen Sie ihn jedoch direkt in die Firmware einbetten.  Dies ist nicht schwierig, obwohl es auf meinem Netbook ziemlich lange gedauert hat (nur dort habe ich Linux). <br><br>  Der Algorithmus ist wie folgt: <br><br><ul><li>  Laden Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP Open SDK</a> herunter und installieren Sie es.  Dieses Ding erstellt einen Compiler und Bibliotheken f√ºr Programme unter ESP8266.  Es wird gem√§√ü den Anweisungen auf der Hauptseite des Projekts zusammengestellt (ich habe die Einstellung STANDALONE = yes gew√§hlt). </li><li>  Laden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micropython Sorts</a> herunter </li><li>  Legen Sie die erforderlichen Bibliotheken in den Ports / esp8266 / modules im Micropython-Baum ab </li><li>  Wir bauen die Firmware gem√§√ü den Anweisungen in der <a href="">Datei ports / esp8266 / README.md zusammen</a> </li><li>  Gie√üen Sie die Firmware in den Mikrocontroller (ich mache dies unter Windows mit ESP8266Flasher-Programmen oder Python esptool) </li></ul><br>  Das war's, jetzt wird 'import ssd1306' den Code direkt von der Firmware abheben und RAM wird daf√ºr nicht ausgegeben.  Mit diesem Trick habe ich nur den Bibliothekscode in die Firmware heruntergeladen, w√§hrend der Hauptprogrammcode aus dem Dateisystem ausgef√ºhrt wird.  Auf diese Weise k√∂nnen Sie das Programm einfach √§ndern, ohne die Firmware neu zu kompilieren.  Im Moment habe ich ca. 8,5kb RAM frei.  Auf diese Weise k√∂nnen in Zukunft viele verschiedene n√ºtzliche Funktionen implementiert werden.  Wenn nicht gen√ºgend Speicher vorhanden ist, k√∂nnen Sie das Hauptprogramm auch in die Firmware verschieben. <br><br><h3>  Und was soll ich jetzt damit machen? </h3><br>  Ok, die Hardware ist verl√∂tet, die Firmware ist geschrieben, die Box ist gedruckt, das Ger√§t klebt an der Wand und blinkt freudig mit einer Gl√ºhbirne.  Aber w√§hrend dies alles eine Black Box ist (im w√∂rtlichen und im √ºbertragenen Sinne) und der Sinn davon immer noch nicht genug ist.  Es ist Zeit, etwas mit MQTT-Nachrichten zu tun, die an den Server gesendet werden. <br><br>  Mein ‚ÄûSmart Home‚Äú dreht sich um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Majordomo-System</a> .  Das MQTT-Modul ist entweder sofort einsatzbereit oder kann einfach √ºber den Add-On-Markt installiert werden. Ich wei√ü nicht mehr, woher es stammt.  MQTT-Ding ist nicht autark - das sogenannte  Broker - Ein Server, der MQTT-Nachrichten empf√§ngt, sortiert und an Clients umleitet.  Ich benutze M√ºcken, die (wie Majordomo) alle auf demselben Netbook laufen. <br><br>  Nachdem das Ger√§t mindestens einmal eine Nachricht gesendet hat, wird der Wert sofort in der Liste angezeigt. <br><br><img src="https://habrastorage.org/webt/hf/ip/db/hfipdb1coxh_lsaaz600mi-39y0.png"><br><br>  Diese Werte k√∂nnen jetzt Systemobjekten zugeordnet, in Automatisierungsskripten verwendet und verschiedenen Analysen unterzogen werden - all dies ist nicht Gegenstand dieses Artikels.  Wer sich f√ºr das Majordomo-System interessiert, kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Electronics In Lens-Kanal</a> empfehlen - ein Freund baut auch ein intelligentes Haus und spricht verst√§ndlich √ºber die Einrichtung des Systems. <br><br>  Ich werde nur ein paar Grafiken zeigen.  Dies ist ein einfaches Diagramm der Tageswerte. <br><br><img src="https://habrastorage.org/webt/km/hw/xr/kmhwxruql1fk0kmykb1gpcpci_0.png"><br>  Es ist zu sehen, dass fast niemand nachts Wasser benutzte.  Ein paar Mal ging jemand auf die Toilette und es sieht so aus, als w√ºrde ein Umkehrosmosefilter ein paar Liter pro Nacht saugen.  Am Morgen steigt der Verbrauch deutlich an.  Normalerweise benutze ich Wasser aus einem Kessel, aber dann wollte ich ein Bad nehmen und vor√ºbergehend auf Stadthei√üwasser umstellen - dies ist auch in der unteren Grafik deutlich sichtbar. <br><br>  Aus diesem Zeitplan habe ich gelernt, dass auf die Toilette gehen 6-7 Liter Wasser, Duschen - 20-30 Liter, Geschirr sp√ºlen ca. 20 Liter, und um ein Bad zu nehmen, braucht man 160 Liter.  F√ºr einen Tag verbraucht meine Familie ungef√§hr 500-600l. <br><br>  F√ºr die Neugierigsten k√∂nnen Sie sich die Eintr√§ge f√ºr jeden einzelnen Wert ansehen <br><br><img src="https://habrastorage.org/webt/8l/8i/su/8l8isu_aiaswajdeeuexytpwffi.png"><br><br>  Von hier aus erfuhr ich, dass bei ge√∂ffnetem Wasserhahn das Wasser mit einer Geschwindigkeit von etwa 1 Liter in 5 Sekunden flie√üt. <br><br>  Aber in dieser Form sind Statistiken wahrscheinlich nicht sehr bequem anzusehen.  In Majordomo besteht weiterhin die M√∂glichkeit, Verbrauchstabellen nach Tag, Woche und Monat anzuzeigen.  Zum Beispiel ein Diagramm des Verbrauchs in Spalten <br><br><img src="https://habrastorage.org/webt/m3/wa/sf/m3wasfzbvxb2tz1yhemod2ewwdy.png"><br><br>  Bisher habe ich nur Daten f√ºr eine Woche.  In einem Monat ist dieses Diagramm aussagekr√§ftiger - eine separate Spalte entspricht jedem Tag.  Anpassungen der von mir manuell eingegebenen Werte beeintr√§chtigen das Bild ein wenig (die gr√∂√üte Spalte).  Und es ist noch nicht klar, ob ich die ersten Werte fast einen W√ºrfel weniger falsch eingestellt habe oder ob dies ein Fehler in der Firmware ist und nicht alle Liter in die Aufrechnung gingen.  Es dauert l√§nger. <br><br>  Es ist immer noch notwendig, √ºber die Graphen selbst zu zaubern, wei√ü, Farbe.  Vielleicht werde ich auch ein Diagramm des Speicherverbrauchs f√ºr Debugging-Zwecke erstellen - pl√∂tzlich tritt dort etwas aus.  Vielleicht zeige ich irgendwie Zeitr√§ume an, in denen das Internet nicht verf√ºgbar war.  W√§hrend sich das alles auf der Ebene der Ideen dreht. <br><br><h3>  Fazit </h3><br>  Heute ist meine Wohnung etwas schlauer geworden.  Mit einem so kleinen Ger√§t ist es f√ºr mich bequemer, den Wasserverbrauch im Haus zu √ºberwachen.  Wenn ich fr√ºher emp√∂rt war, "wieder haben sie in einem Monat viel Wasser verbraucht", kann ich jetzt die Quelle dieses Verbrauchs finden. <br><br>  Es erscheint jemandem seltsam, die Messwerte auf dem Bildschirm zu sehen, wenn sie einen Meter vom Messger√§t entfernt sind.  Aber in nicht allzu ferner Zukunft plane ich, in eine andere Wohnung zu ziehen, in der es mehrere Steigleitungen geben wird und die Z√§hler selbst h√∂chstwahrscheinlich auf dem Treppenabsatz liegen werden.  Ein Fernleseger√§t w√§re also sehr hilfreich. <br><br>  Ich plane auch, die Funktionalit√§t des Ger√§ts zu erweitern.  Ich sehe mir bereits motorisierte Ventile an.  Um jetzt das Wasser in der Kesselstadt zu wechseln, muss ich 3 Wasserh√§hne in einer unzug√§nglichen Nische drehen.  Es w√§re viel bequemer, dies mit einer Taste mit der entsprechenden Anzeige zu tun.  Nat√ºrlich lohnt es sich, einen Leckschutz zu implementieren. <br><br>  In dem Artikel habe ich meine Version des Ger√§ts basierend auf ESP8266 erz√§hlt.  Meiner Meinung nach habe ich eine sehr interessante Version der Micropython-Firmware mit Coroutine erhalten - einfach und h√ºbsch.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe versucht, die vielen Nuancen und Schulen zu beschreiben, denen ich bei der Kampagne begegnet bin. </font><font style="vertical-align: inherit;">Vielleicht habe ich alles zu detailliert beschrieben, f√ºr mich pers√∂nlich ist es als Leser einfacher, zu viel zu verschwenden, als sich dann auszudenken, was nicht gesagt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie immer bin ich offen f√ºr konstruktive Kritik. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode- </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaltungs- und </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platinengeh√§usemodell</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de411259/">https://habr.com/ru/post/de411259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de411249/index.html">Wie ich meinen Yandex.Transport mit Fahrpl√§nen und Bussen gemacht habe</a></li>
<li><a href="../de411251/index.html">Benutzer senden Chrome-Scandateien auf dem lokalen Laufwerk erneut</a></li>
<li><a href="../de411253/index.html">Die Verschmelzung von Neutronensternen setzte den Alternativen von Dunkler Materie und Dunkler Energie ein Ende</a></li>
<li><a href="../de411255/index.html">Dezentrale Apps f√ºr Millionen von Benutzern auf Ethereum</a></li>
<li><a href="../de411257/index.html">In den USA schaffen sie ein Lasersystem, das den Feind mit Ger√§uschen erschreckt</a></li>
<li><a href="../de411261/index.html">Vibrationsreaktion in Prothesen: Ein neuer Weg, um die Kontrolle √ºber bionische Gliedma√üen zu verbessern</a></li>
<li><a href="../de411263/index.html">Magic Button f√ºr LED auf ATtiny4</a></li>
<li><a href="../de411265/index.html">Spionagef√§lle (Teil 3)</a></li>
<li><a href="../de411267/index.html">Wer steckt wirklich hinter den neuen Smartphones der Marke Nokia?</a></li>
<li><a href="../de411269/index.html">Die drei Komponenten von ‚ÄûLOAD‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>