<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèø üòÖ üïò Git innen und au√üen ‚õ∞Ô∏è üñïüèæ üêñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die F√§higkeit, in einem Versionskontrollsystem zu arbeiten, ist eine F√§higkeit, die jeder Programmierer ben√∂tigt. Oft scheint es eine zus√§tzliche Zeit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Git innen und au√üen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/468177/">  Die F√§higkeit, in einem Versionskontrollsystem zu arbeiten, ist eine F√§higkeit, die jeder Programmierer ben√∂tigt.  Oft scheint es eine zus√§tzliche Zeitverschwendung zu sein, sich mit Git zu besch√§ftigen und seine Interna zu verstehen, und grundlegende Aufgaben k√∂nnen durch einen grundlegenden Befehlssatz gel√∂st werden. <br><br>  Das AppsCast-Team wollte nat√ºrlich mehr wissen, und um Ratschl√§ge zur praktischen Anwendung aller Funktionen von Git zu erhalten, wandten sich die Jungs von Square an <b>Yegor Andreyevich</b> . <br><br><img src="https://habrastorage.org/webt/wx/nd/kg/wxndkg7_giwgsbmreljpv-0h5l4.jpeg"><br><a name="habracut"></a><br>  <b>Daniil Popov</b> : Hallo allerseits.  Heute ist Jegor Andreyevich vom Square zu uns gekommen. <br><br>  <b>Egor Andreyevich</b> : Hallo allerseits.  Ich lebe in Kanada und arbeite f√ºr Square, ein Software- und Hardwareunternehmen f√ºr die Finanzindustrie.  Wir haben mit Terminals f√ºr die Annahme von Zahlungen mit Kreditkarten begonnen, jetzt bieten wir Dienstleistungen f√ºr Gesch√§ftsinhaber an.  Ich arbeite an einem Cash App-Produkt.  Dies ist eine mobile Bank, mit der Sie Geld mit Freunden austauschen und eine Debitkarte f√ºr die Zahlung in Gesch√§ften bestellen k√∂nnen.  Das Unternehmen hat viele B√ºros auf der ganzen Welt und das kanadische B√ºro hat ungef√§hr 60 Programmierer. <br><br>  <b>Daniil Popov</b> : In der Umgebung von Android-Entwicklern ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Square</a> f√ºr seine Open-Source-Projekte bekannt, die zu Industriestandards geworden sind: OkHttp, Picasso, Retrofit.  Es ist logisch, dass Sie bei der Entwicklung solcher Tools, die f√ºr alle offen sind, viel mit Git arbeiten.  Wir m√∂chten dar√ºber sprechen. <br><br><h2>  Was ist Schwachkopf? </h2><br>  <b>Egor Andreevich</b> : Ich benutze Git schon lange als Werkzeug und irgendwann wurde ich interessiert, mehr dar√ºber zu erfahren. <br><br><blockquote>  Git ist ein vereinfachtes Dateisystem, zu dem eine Reihe von Operationen f√ºr die Arbeit mit der Versionskontrolle geh√∂ren. <br></blockquote><br>  Mit Git k√∂nnen Sie Dateien in einem bestimmten Format speichern.  Jedes Mal, wenn Sie eine Datei schreiben, gibt Git den Schl√ºssel f√ºr Ihr Objekt zur√ºck - <b>Hash</b> . <br><br>  <b>Daniil Popov</b> : Viele Leute haben bemerkt, dass das Repository ein magisches verstecktes Verzeichnis hat <b>.git</b> .  Warum wird es ben√∂tigt?  Kann ich es l√∂schen oder umbenennen? <br><br>  <b>Egor Andreevich</b> : Das Erstellen eines Repositorys ist √ºber den Befehl <b>git init</b> m√∂glich.  Es erstellt das <b>.git-</b> Verzeichnis, mit dem Git Dateien steuert.  <b>.Git</b> speichert alles, was Sie in Ihrem Projekt tun, nur in einem komprimierten Format.  Daher k√∂nnen Sie das Repository aus diesem Verzeichnis wiederherstellen. <br><br>  <b>Alexei Kudryavtsev</b> : Es stellt sich heraus, dass Ihr Projektordner eine der Versionen des erweiterten Git-Ordners ist? <br><br>  <b>Egor Andreevich</b> : Je nachdem, in welchem ‚Äã‚ÄãZweig Sie sich befinden, stellt git ein Projekt wieder her, mit dem Sie arbeiten k√∂nnen. <br><br>  <b>Alexei Kudryavtsev</b> : Was ist in dem Ordner? <br><br>  <b>Egor Andreevich</b> : Git erstellt bestimmte Ordner und Dateien.  Der wichtigste Ordner ist .git / properties, in dem alle Objekte gespeichert sind.  Das einfachste Objekt ist Blob, im Wesentlichen dasselbe wie eine Datei, jedoch in einem Format, das Git versteht.  Wenn Sie eine Textdatei im Repository speichern m√∂chten, komprimiert Git sie, archiviert sie, f√ºgt Daten hinzu und erstellt einen Blob. <br><br>  Es gibt Verzeichnisse - dies sind Ordner mit Unterordnern, d. H.  Git hat einen Baumobjekttyp, der Verweise auf Blob und andere B√§ume enth√§lt. <br><br><blockquote>  Grunds√§tzlich ist ein Baum eine Momentaufnahme, die den Status Ihres Verzeichnisses an einem bestimmten Punkt beschreibt. </blockquote><br>  Beim Erstellen eines Commits ist ein Link zum Arbeitsverzeichnis fest - Baum. <br><br>  Ein Commit ist ein Link zu einem Baum mit Informationen dar√ºber, wer ihn erstellt hat: E-Mail, Name, Erstellungszeit, Link zum √ºbergeordneten Element (√ºbergeordneter Zweig) und Nachricht.  Git komprimiert und schreibt Commits in das Objektverzeichnis. <br><br>  Um zu sehen, wie dies alles funktioniert, m√ºssen Sie die Unterverzeichnisse √ºber die Befehlszeile auflisten. <br><br><h2>  Vorteile der Arbeit mit Git </h2><br>  <b>Daniil Popov</b> : Wie funktioniert Git?  Warum ist der Aktionsalgorithmus so kompliziert? <br><br>  <b>Egor Andreevich</b> : Wenn Sie Git mit Subversion (SVN) vergleichen, gibt es im ersten System eine Reihe von Funktionen, die Sie verstehen m√ºssen.  Ich beginne mit dem <b>Staging-Bereich</b> , der nicht als Einschr√§nkung von Git, sondern als Funktionen angesehen werden sollte. <br><br>  Es ist bekannt, dass bei der Arbeit mit Code nicht alles sofort funktioniert: Irgendwo m√ºssen Sie das Layout √§ndern, irgendwo, um Fehler zu beheben.  Infolgedessen werden nach einer Arbeitssitzung eine Reihe betroffener Dateien angezeigt, die nicht miteinander verbunden sind.  Wenn Sie alle √Ñnderungen in einem Commit vornehmen, ist dies unpraktisch, da die √Ñnderungen unterschiedlicher Natur sind.  Dann kommt eine Reihe von Commits zur Ausgabe, die nur dank des Staging-Bereichs erstellt werden k√∂nnen.  Beispielsweise werden alle √Ñnderungen an der Layoutdatei an eine Serie gesendet, z. B. Unit-Tests an eine andere.  Wir nehmen mehrere Dateien, verschieben sie in den Staging-Bereich und erstellen nur mit ihrer Teilnahme ein Commit.  Andere Dateien aus dem Arbeitsverzeichnis fallen nicht hinein.  Auf diese Weise teilen Sie alle im Arbeitsverzeichnis ausgef√ºhrten Arbeiten in mehrere Commits auf, von denen jede eine bestimmte Arbeit darstellt. <br><br>  <b>Alexei Kudryavtsev</b> : Wie unterscheidet sich Git von anderen Versionskontrollsystemen? <br><br>  <b>Egor Andreevich</b> : Ich pers√∂nlich habe mit SVN angefangen und bin dann sofort zu Git gewechselt.  Wichtig ist, dass Git ein dezentrales Versionskontrollsystem ist.  Alle Kopien des Git-Repositorys sind genau gleich.  Jedes Unternehmen verf√ºgt √ºber einen Server, auf dem sich die Hauptversion befindet. Dieser unterscheidet sich jedoch nicht von dem Server, den der Entwickler auf dem Computer installiert hat. <br><br>  SVN verf√ºgt √ºber ein zentrales Repository und lokale Kopien.  Dies bedeutet, dass jeder Entwickler das zentrale Repository alleine besch√§digen kann. <br><br>  In Git wird dies nicht passieren.  Wenn der zentrale Server die Repository-Daten verliert, k√∂nnen sie von jeder lokalen Kopie wiederhergestellt werden.  Git ist anders gestaltet und bietet die Vorteile der Geschwindigkeit. <br><br>  <b>Daniil Popov</b> : Git ist ber√ºhmt f√ºr seine Verzweigung, die sp√ºrbar schneller l√§uft als SVN.  Wie macht er das? <br><br>  <b>Egor Andreevich</b> : In SVN ist ein Zweig eine vollst√§ndige Kopie des vorherigen Zweigs.  In Git gibt es keine physische Zweigdarstellung.  Dies ist ein Link zum letzten Commit in einer bestimmten Entwicklungslinie.  Wenn Git Objekte speichert, erstellt es beim Erstellen eines Commits eine Datei mit spezifischen Informationen zum Commit.  Git erstellt eine symbolische Datei - Symlink mit einem Link zu einer anderen Datei.  Wenn Sie viele Zweige haben, verweisen Sie auf verschiedene Commits im Repository.  Um den Verlauf eines Zweigs zu verfolgen, m√ºssen Sie von jedem Commit √ºber den Link zur√ºck zum √ºbergeordneten Commit wechseln. <br><br><h2>  Merjim Zweige </h2><br>  <b>Daniil Popov</b> : Es gibt zwei M√∂glichkeiten, zwei Zweige zu einem zusammenzuf√ºhren - das ist Zusammenf√ºhren und Wiederherstellen.  Wie benutzt du sie? <br><br>  <b>Egor Andreevich</b> : Jede Methode hat ihre Vor- und Nachteile.  <b>Zusammenf√ºhren</b> ist die einfachste Option.  Zum Beispiel gibt es zwei Zweige: Master und das daraus ausgew√§hlte Feature. <br><br>  Zum Zusammenf√ºhren k√∂nnen Sie den Schnellvorlauf verwenden.  Dies ist m√∂glich, wenn ab dem Zeitpunkt, an dem die Arbeit im Feature-Zweig begonnen wurde, keine neuen Commits im Master vorgenommen wurden.  Das hei√üt, das erste Commit in Feature ist das letzte Commit im Master. <br><br>  In diesem Fall ist der Zeiger auf dem Hauptzweig fixiert und wechselt zum letzten Commit im Feature-Zweig.  Auf diese Weise wird die Verzweigung beseitigt, indem der Feature-Zweig mit dem Haupt-Master-Thread verbunden und der unn√∂tige Zweig entfernt wird.  Es stellt sich eine lineare Geschichte heraus, in der alle Commits aufeinander folgen.  In der Praxis kommt diese Option selten vor, da st√§ndig jemand Commits zum Master zusammenf√ºhrt. <br><br>  Es kann auch anders sein.  Git erstellt ein neues Commit - Merge Commit, das zwei Links zu √ºbergeordneten Commits enth√§lt: einen im Master und einen im Feature.  Mit dem neuen Commit werden zwei Zweige verbunden und die Funktion kann wieder gel√∂scht werden. <br><br>  Nach dem Zusammenf√ºhrungs-Commit k√∂nnen Sie sich die Story ansehen und feststellen, dass sie gegabelt ist.  Wenn Sie ein Tool verwenden, das Commits grafisch darstellt, sieht es visuell wie ein Weihnachtsbaum aus.  Dies bricht Git nicht, aber es ist f√ºr einen Entwickler schwierig, eine solche Geschichte zu sehen. <br><br>  Ein weiteres Tool ist <b>Rebase</b> .  Konzeptionell nehmen Sie alle √Ñnderungen aus dem Feature-Zweig und drehen sie √ºber den Master-Zweig.  Das erste Feature-Commit wird zum neuen Commit zus√§tzlich zum letzten Master-Commit. <br><br>  Es gibt einen Haken: Git kann Commits nicht √§ndern.  Es gab ein Commit in der Funktion und wir k√∂nnen es nicht einfach √ºber den Master wickeln, da jedes Commit einen Zeitstempel hat. <br><br>  Im Falle einer Neubasis liest Git alle Commits in der Funktion, speichert sie vor√ºbergehend und erstellt sie dann in der gleichen Reihenfolge im Master neu.  Nach der erneuten Basisung verschwinden die anf√§nglichen Festschreibungen, und neue Festschreibungen mit demselben Inhalt werden √ºber dem Master angezeigt.  Es gibt Probleme.  Wenn Sie versuchen, einen Zweig, mit dem andere Personen arbeiten, neu zu gr√ºnden, k√∂nnen Sie das Repository besch√§digen.  Zum Beispiel, wenn jemand seinen Zweig von einem Commit gestartet hat, das in der Funktion enthalten war, und Sie dieses Commit zerst√∂rt und neu erstellt haben.  Rebase ist besser f√ºr lokale Niederlassungen geeignet. <br><br>  <b>Daniil Popov</b> : Wenn Sie Einschr√§nkungen einf√ºhren, nach denen ausschlie√ülich eine Person an einem Feature-Zweig arbeitet, stimmen Sie zu, dass Sie nicht einen Feature-Zweig von einem anderen trennen k√∂nnen, dann tritt dieses Problem nicht auf.  Aber welchen Ansatz √ºben Sie? <br><br>  <b>Egor Andreevich</b> : Wir verwenden keine Feature-Zweige im direkten Sinne dieses Begriffs.  Jedes Mal, wenn wir eine √Ñnderung vornehmen, erstellen Sie einen neuen Zweig, arbeiten darin und gie√üen ihn sofort in den Master.  Es gibt keine langj√§hrigen Zweige. <br><br>  Dies l√∂st eine gro√üe Anzahl von Problemen beim Zusammenf√ºhren und Wiederherstellen, insbesondere bei Konflikten.  Zweige bestehen f√ºr eine Stunde und es besteht eine hohe Wahrscheinlichkeit, dass der schnelle Vorlauf verwendet wird, da niemand dem Master etwas hinzugef√ºgt hat.  Wenn wir eine Pull-Anforderung zusammenf√ºhren, wird nur das Erstellen eines Zusammenf√ºhrungs-Commits zusammengef√ºhrt <br><br>  <b>Daniil Popov</b> : Wie haben Sie keine Angst davor, eine Master-Leerlauffunktion zusammenzuf√ºhren, weil es oft unrealistisch ist, eine Aufgabe in st√ºndliche Intervalle zu zerlegen? <br><br>  <b>Egor Andreevich</b> : Wir verwenden den <b>Feature-Flags-</b> Ansatz.  Dies sind dynamische Flags, ein spezifisches Merkmal mit unterschiedlichen Zust√§nden.  Beispielsweise ist die Funktion zum Senden von Zahlungen aneinander entweder aktiviert oder deaktiviert.  Wir haben einen Service, der diesen Status dynamisch an Kunden liefert.  Sie erhalten vom Server die Funktion "Wert aus" oder nicht.  Sie k√∂nnen diesen Wert im Code verwenden - schalten Sie die Schaltfl√§che aus, die zum Bildschirm f√ºhrt.  Der Code selbst befindet sich in der Anwendung und kann freigegeben werden, es besteht jedoch kein Zugriff auf diese Funktionalit√§t, da er sich hinter dem Feature-Flag befindet. <br><br>  <b>Daniil Popov</b> : Oft wird Neulingen bei Git gesagt, dass man nach dem Rebase mit Gewalt pushen muss.  Woher kommt es? <br><br>  <b>Egor Andreevich</b> : Wenn Sie nur pushen, kann ein anderes Repository einen Fehler ausl√∂sen: Sie versuchen, einen Zweig auszuf√ºhren, aber Sie haben v√∂llig andere Commits f√ºr diesen Zweig.  Git √ºberpr√ºft alle Informationen, damit Sie das Repository nicht versehentlich besch√§digen.  Wenn Sie <b>git push force</b> sagen, schalten Sie diesen Check aus, weil Sie glauben, dass Sie es besser wissen als er, und fordern Sie, den Zweig neu zu schreiben. <br><br>  Warum wird dies nach dem Rebase ben√∂tigt?  Rebase erstellt Commits neu.  Es stellt sich heraus, dass der Zweig auch aufgerufen wird, sich aber mit anderen Hashes darin festlegt, und Git schw√∂rt auf dich.  In dieser Situation ist es absolut normal, einen Kraftsto√ü auszuf√ºhren, da Sie die Kontrolle √ºber die Situation haben. <br><br>  <b>Daniil Popov</b> : Es gibt immer noch das Konzept der <b>interaktiven Rebase</b> , und viele haben Angst davor. <br><br>  <b>Egor Andreevich</b> : Es gibt nichts Schreckliches.  Aufgrund der Tatsache, dass Git die Story w√§hrend des Rebases neu erstellt, speichert sie sie vor√ºbergehend, bevor sie geworfen wird.  Wenn es tempor√§ren Speicher hat, kann es alles mit Commits machen. <br><br>  Beim erneuten Basieren im interaktiven Modus wird davon ausgegangen, dass Git vor dem erneuten Basieren ein Fenster eines Texteditors √∂ffnet, in dem Sie angeben k√∂nnen, was mit jedem einzelnen Commit getan werden muss.  Es sieht aus wie mehrere Textzeilen, wobei jede Zeile eine der Festschreibungen in der Verzweigung ist.  Vor jedem Commit gibt es einen Hinweis auf die Operation, die es wert ist, ausgef√ºhrt zu werden.  Die einfachste Standardoperation ist <b>pick</b> , d. H.  zu nehmen und in Rebase aufzunehmen.  Am h√§ufigsten wird <b>Squash verwendet</b> , dann √ºbernimmt Git die √Ñnderungen aus diesem Commit und f√ºhrt sie mit den √Ñnderungen aus dem vorherigen zusammen. <br><br>  Oft gibt es ein solches Szenario.  Sie haben lokal in Ihrer Niederlassung gearbeitet und Commits f√ºr das Speichern erstellt.  Das Ergebnis ist eine lange Geschichte von Commits, die f√ºr Sie interessant ist, aber auf die gleiche Weise nicht in die Hauptgeschichte aufgenommen werden sollte.  Dann geben Sie Squash, um das allgemeine Commit umzubenennen. <br><br>  Die Liste der Teams ist lang.  Sie k√∂nnen den Commit- <b>Drop ausl√∂sen</b> und er verschwindet, Sie k√∂nnen die Commit-Nachricht √§ndern usw. <br><br>  <b>Alexei Kudryavtsev</b> : Wenn Sie Konflikte bei der interaktiven Rebase haben, gehen Sie durch alle Kreise der H√∂lle. <br><br>  <b>Egor Andreevich</b> : Ich bin weit davon entfernt, alle Weisheiten des interaktiven Rebases zu verstehen, aber es ist ein m√§chtiges und komplexes Werkzeug. <br><br><h2>  Praktische Git-Anwendung </h2><br>  <b>Daniil Popov</b> : Lass uns weiter √ºben.  Beim Interview frage ich oft: ‚ÄûSie haben tausend Commits.  Am ersten ist alles in Ordnung, am tausendsten Test brach.  Wie kann man mit Hilfe einer Gita die Ver√§nderung finden, die dazu gef√ºhrt hat? ‚Äú <br><br>  <b>Egor Andreevich</b> : In dieser Situation m√ºssen Sie die <b>Halbierung verwenden</b> , obwohl es einfacher ist, die Schuld zu tragen. <br><br>  Beginnen wir mit dem interessanten.  Git bisect ist auf eine Situation anwendbar, in der Sie eine Regression haben - es war funktionsf√§hig, es hat funktioniert, aber es hat pl√∂tzlich aufgeh√∂rt.  Um festzustellen, wann die Funktionalit√§t fehlerhaft ist, k√∂nnen Sie theoretisch nach dem Zufallsprinzip zur vorherigen Version der Anwendung zur√ºckkehren und sich den Code ansehen. Es gibt jedoch ein Tool, mit dem Sie das Problem strukturiert angehen k√∂nnen. <br><br>  Git bisect ist ein interaktives Tool.  Es gibt einen Befehl "git bisect bad bad", mit dem Sie √ºber das Vorhandensein eines fehlerhaften Commits und git bisect good berichten - f√ºr einen funktionierenden Commit.  Jedes Mal, wenn die Anwendung freigegeben wird, erinnern wir uns an den Hash des Commits, aus dem die Freigabe erfolgt ist.  Dieser Hash kann auch verwendet werden, um schlechte und gute Commits anzuzeigen.  Bisect erh√§lt Informationen √ºber das Intervall, in dem eines der Commits die Funktionalit√§t unterbrochen hat, und startet die <b>bin√§re</b> Suchsitzung, in der nach und nach Commits ausgegeben werden, um zu √ºberpr√ºfen, ob sie funktionieren oder nicht. <br><br>  Sie haben die Sitzung gestartet, Git wechselt zu einem der Commits im Intervall und meldet dies.  Bei tausend Commits wird es nicht viele Iterationen geben. <br><br>  Die √úberpr√ºfung muss manuell erfolgen: durch Komponententests oder f√ºhren Sie die Anwendung aus und klicken Sie manuell.  Git bisect ist bequem skriptf√§hig.  Jedes Mal, wenn er ein Commit ausgibt, geben Sie ihm ein Skript, um zu √ºberpr√ºfen, ob der Code funktioniert. <br><br>  Schuld ist ein einfacheres Werkzeug, mit dem Sie anhand seines Namens den "Schuldigen" eines Funktionsfehlers finden k√∂nnen.  Aufgrund dieser negativen Definition m√∂gen es viele in der Schuldgemeinschaft nicht. <br><br>  Was macht er?  Wenn Sie einer bestimmten Datei die Schuld geben, zeigt sie linear in dieser Datei an, welches Commit diese oder jene Zeile ge√§ndert hat.  Ich habe noch nie Git-Schuld von der Kommandozeile aus benutzt.  Dies geschieht in der Regel in IDEA oder Android Studio. Klicken Sie auf und sehen Sie, wer welche Zeile der Datei und in welchem ‚Äã‚ÄãCommit ge√§ndert hat. <br><br>  <b>Daniil Popov</b> : √úbrigens hie√ü es in Android Studio Annotate.  Die negative Konnotation der Schuld wurde entfernt. <br><br>  <b>Alexei Kudryavtsev</b> : Genau, in xCode haben sie es in Autoren umbenannt. <br><br>  <b>Egor Andreevich</b> : Ich habe auch gelesen, dass es ein Utility-Git-Lob gibt - denjenigen zu finden, der diesen hervorragenden Code geschrieben hat. <br><br>  <b>Daniil Popov</b> : Es sollte beachtet werden, dass auf Schuld Vorschl√§ge von Rezensenten auf Pull-Request-Arbeit.  Er sieht sich an, wer eine bestimmte Datei am meisten ber√ºhrt hat, und schl√§gt vor, dass diese Person Ihren Code gut √ºberpr√ºfen kann. <br>  Im Fall von etwa tausend Commits zeigt die Schuld in 99% der F√§lle, was schief gelaufen ist.  Bisect ist bereits der letzte Ausweg. <br><br>  <b>Egor Andreevich</b> : Ja, ich greife extrem selten auf Halbierung zur√ºck, aber ich benutze regelm√§√üig Anmerkungen.  Obwohl es manchmal unm√∂glich ist zu verstehen, warum es in der Codezeile auf Null gesetzt ist, ist w√§hrend des gesamten Commits klar, was der Autor tun wollte. <br><br><h2>  Wie arbeite ich mit gestapelten PRs? </h2><br>  <b>Daniil Popov</b> : Ich habe geh√∂rt, dass Square Stacked Pull Requests (PRs) verwendet. <br><br>  <b>Egor Andreevich</b> : Zumindest in unserem Android-Team verwenden wir sie oft. <br>  Wir verwenden viel Zeit, um die √úberpr√ºfung jeder Pull-Anfrage zu vereinfachen.  Manchmal besteht die Versuchung, schnell zu f√ºttern und die Pr√ºfer zu verstehen.  Wir versuchen, kleine Pull-Anfragen und eine kurze Beschreibung zu erstellen - der Code sollte f√ºr sich selbst sprechen.  Wenn Pull-Anfragen klein sind, ist es einfach und schnell zu br√ºllen. <br><br>  Hier tritt das Problem auf.  Sie arbeiten an einer Funktion, die eine gro√üe Anzahl von √Ñnderungen in der Codebasis erfordert.  Was kannst du tun  Sie k√∂nnen es in eine Pull-Anfrage einf√ºgen, aber dann wird es riesig.  Sie k√∂nnen arbeiten, indem Sie nach und nach eine Pull-Anforderung erstellen. Das Problem besteht jedoch darin, dass Sie einen Zweig erstellt, einige √Ñnderungen hinzugef√ºgt und eine Pull-Anforderung gesendet, an den Master zur√ºckgegeben und der Code, den Sie in der Pull-Anforderung hatten, erst im Master verf√ºgbar sind Zusammenf√ºhrung wird nicht stattfinden.  Wenn Sie auf √Ñnderungen in diesen Dateien angewiesen sind, ist es schwierig, weiter zu arbeiten, da es keinen solchen Code gibt. <br><br>  Wie kommen wir darum herum?  Nachdem wir die erste Pull-Anforderung erstellt haben, arbeiten wir weiter und erstellen einen neuen Zweig aus dem vorhandenen Zweig, den wir vor der Pull-Anforderung verwendet haben.  Jeder Zweig stammt nicht vom Master, sondern vom vorherigen Zweig.  Wenn wir mit der Arbeit an dieser Funktionalit√§t fertig sind, senden wir eine weitere Pull-Anfrage und geben erneut an, dass sie beim Zusammenf√ºhren nicht im Master, sondern im vorherigen Zweig zusammengef√ºhrt wird.  Es stellt sich heraus, dass es eine solche Kette von Pull-Anfragen gibt - gestapelte Prs.  Wenn eine Person √ºberarbeitet, sieht sie die √Ñnderungen, die nur durch diese Funktion vorgenommen wurden, nicht jedoch durch die vorherige. <br><br>  Die Aufgabe besteht darin, jede Pull-Anforderung so klein und klar wie m√∂glich zu gestalten, damit keine √Ñnderungen erforderlich sind.  Denn wenn Sie den Code in den Zweigen √§ndern m√ºssen, die sich in der Mitte des Stapels befinden, wird alles oben kaputt gehen, da Sie eine Neubasis durchf√ºhren m√ºssen.  Wenn Pull-Anforderungen klein sind, versuchen wir, sie so schnell wie m√∂glich einzufrieren. Anschlie√üend werden alle gestapelten Anforderungen Schritt f√ºr Schritt in den Master eingef√ºgt. <br><br>  <b>Daniil Popov</b> : Ich verstehe richtig, dass es am Ende eine letzte Pull-Anfrage geben wird, die alle kleinen Pull-Anfragen enth√§lt.  Sie gie√üen diesen Faden ohne zu schauen? <br><br>  <b>Egor Andreevich</b> : Zusammenf√ºhren kommt von der gestapelten Quelle: Zuerst wird die allererste Pull-Anforderung im Master zusammengef√ºhrt, im n√§chsten √§ndert sich die Basis von Zweig zu Master, und dementsprechend berechnet Git, dass es bereits einige √Ñnderungen im Master gibt, weniger Snapshot. <br><br>  <b>Alexei Kudryavtsev</b> : Haben Sie eine Rennbedingung, wenn der erste Zweig bereits gestoppt hat und erst danach der zweite im ersten gestoppt hat, weil das Ziel nicht ge√§ndert wurde, um es zu meistern? <br><br>  <b>Egor Andreevich</b> : Wir halten es von Hand, es gibt also keine solchen Situationen.  Ich √∂ffne eine Pull-Anfrage, notiere die Kollegen, von denen ich eine Bewertung erhalten m√∂chte, und wenn sie bereit sind, gehe zu Bitbucket und dr√ºcke Merge. <br><br>  <b>Alexei Kudryavtsev</b> : Aber was ist mit der √úberpr√ºfung von CI, dass nichts kaputt ist? <br><br>  <b>Egor Andreevich</b> : Das machen wir nicht.  CI wird auf dem Zweig ausgef√ºhrt, der die Basis f√ºr die Pull-Anforderung darstellt, und nach √úberpr√ºfung √ºberpr√ºfen wir die Basis.  Technisch √§ndert sich nichts, da Sie auch die Anzahl der √Ñnderungen festlegen. <br><br>  <b>Daniil Popov</b> : Dr√§ngst du direkt in den Meister ein oder entwickelst du dich?  Und wenn Sie freigeben, geben Sie explizit das Commit an, von dem gesammelt werden soll? <br><br>  <b>Egor Andreevich</b> : Wir haben uns nicht entwickelt, nur Meister.  Wir werden definitiv alle zwei Wochen ver√∂ffentlichen.  Wenn wir mit der Vorbereitung eines Releases beginnen, √∂ffnen wir einen Release-Zweig und einige letzte Korrekturen gehen sowohl an den Master als auch an diesen Zweig.  Wir verwenden Tags - permanente Links zu einem bestimmten Commit, optional mit einigen Informationen.  Wenn es sich bei einem Commit um ein Release-Commit handelt, w√§re es sch√∂n, in der Historie zu bleiben, dass wir ein Release von diesem Commit erstellt haben.  Ein Tag wird erstellt, Git speichert die Versionsinformationen und Sie k√∂nnen sp√§ter darauf zur√ºckgreifen. <br><br>  <b>Alexei Kudryavtsev</b> : Wo kann man Git unterrichten, was soll man lesen? <br><br>  <b>Egor Andreevich</b> : Git hat ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielles Buch</a> .  Ich mag die Art und Weise, wie es geschrieben steht, es gibt gute Beispiele.  Es gibt ein Kapitel √ºber die Innenseiten, Sie k√∂nnen es gr√ºndlich studieren.  Auf StackOverflow finden Sie viele esoterische Situationen und L√∂sungen.  Sie k√∂nnen auch verwendet werden. <br><br><blockquote>  Wir werden auf der kommenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint AppsConf</a> nicht √ºber Git <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sprechen</a> .  Auf der anderen Seite haben wir uns f√ºr ein Experiment entschieden und dem ereignisreichen Konferenzprogramm Einf√ºhrungsberichte hinzugef√ºgt, in denen Referenten aus verwandten Entwicklungsbranchen Wissen austauschen, um den Horizont eines mobilen Entwicklers zu erweitern.  Wir empfehlen Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf die Pr√§sentation von Nikolai Golov von Avito zu Datenbanken zu achten</a> : Wie Sie keinen Fehler machen und die richtige Datenbank ausw√§hlen, wie Sie sich auf das Wachstum vorbereiten und was 2019 relevant ist. <br><br>  AppsCast wird mittwochs alle zwei Wochen ver√∂ffentlicht. Wenn Sie die Soundversion der Textversion vorziehen, abonnieren Sie uns in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SoundCloud</a> und diskutieren Sie Themen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in unserem Chat</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468177/">https://habr.com/ru/post/de468177/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468163/index.html">Oracle VM Server f√ºr SPARC for Dummies (Anleitung)</a></li>
<li><a href="../de468165/index.html">Wie der Browser zeichnet. Yandex-Bericht</a></li>
<li><a href="../de468167/index.html">Lebe und lerne. Teil 4. W√§hrend der Arbeit lernen?</a></li>
<li><a href="../de468169/index.html">JQuery Geschichte und Erbe</a></li>
<li><a href="../de468175/index.html">Lesenswerte Frontend-Entwicklungsblogs</a></li>
<li><a href="../de468179/index.html">Analyse: Wie die Infrastruktur des russischen Wertpapiermarktes funktioniert</a></li>
<li><a href="../de468181/index.html">Silent Trinity: Erkundung einer neuen Version des Post-Exploitation-Frameworks</a></li>
<li><a href="../de468185/index.html">AWS EC2 Service und arbeiten damit</a></li>
<li><a href="../de468189/index.html">Verbessern Sie die JavaScript-Debugging-F√§higkeiten mithilfe von Konsolentricks</a></li>
<li><a href="../de468191/index.html">RubyRussia 2019: Nikolay Sverchkov √ºber Serverless</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>