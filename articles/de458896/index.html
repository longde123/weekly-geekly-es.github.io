<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï† üé£ üëä Funktionales JavaScript: Was sind Funktionen h√∂herer Ordnung und warum werden sie ben√∂tigt? üë≤üèæ üôÜüèΩ üò±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Funktionen h√∂herer Ordnung" ist eine dieser Phrasen, die oft verstreut sind. Aber selten kann jemand anhalten und erkl√§ren, was es ist. M√∂glicherweis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales JavaScript: Was sind Funktionen h√∂herer Ordnung und warum werden sie ben√∂tigt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/458896/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/le/mw/stlemwjifksb6iqurxqvutclf9s.jpeg"></div><br>  "Funktionen h√∂herer Ordnung" ist eine dieser Phrasen, die oft verstreut sind.  Aber selten kann jemand anhalten und erkl√§ren, was es ist.  M√∂glicherweise kennen Sie bereits Funktionen h√∂herer Ordnung.  Aber wie setzen wir sie in realen Projekten ein?  Wann und warum sind sie hilfreich?  K√∂nnen wir das DOM mit ihrer Hilfe manipulieren?  Oder zeigen sich Leute, die diese Funktionen nutzen, nur?  Vielleicht komplizieren sie den Code sinnlos? <br><br>  Fr√ºher dachte ich, dass Funktionen h√∂herer Ordnung n√ºtzlich sind.  Jetzt halte ich sie f√ºr die wichtigste Eigenschaft von JavaScript als Sprache.  Bevor wir dies diskutieren, wollen wir zun√§chst herausfinden, was genau Funktionen h√∂herer Ordnung sind.  Und wir werden mit Funktionen als Variablen beginnen. <br><a name="habracut"></a><br><h2>  Funktioniert als erstklassige Objekte </h2><br>  In JavaScript gibt es mindestens drei M√∂glichkeiten (es gibt insgesamt mehr), um eine neue Funktion zu schreiben.  Zun√§chst k√∂nnen Sie <i>eine Funktionsdeklaration</i> schreiben: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Take a DOM element and wrap it in a list item element. function itemise(el) { const li = document.createElement('li'); li.appendChild(el); return li; }</span></span></code> </pre> <br>  Ich hoffe du verstehst alles.  Au√üerdem wissen Sie wahrscheinlich, dass Sie einen <i>Funktionsausdruck</i> schreiben <i>k√∂nnen</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemise = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> li = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'li'</span></span>); li.appendChild(el); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> li; }</code> </pre> <br>  Und schlie√ülich gibt es eine andere M√∂glichkeit, dieselbe Funktion zu schreiben - als <i>Pfeilfunktion</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemise = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> li = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'li'</span></span>); li.appendChild(el); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> li; }</code> </pre> <br>  In diesem Fall sind alle drei Methoden gleichwertig.  Obwohl dies nicht immer der Fall ist, weist jede Methode in der Praxis kleine Unterschiede auf, die mit der Magie eines bestimmten Schl√ºsselworts und von Beschriftungen in Stapelspuren zusammenh√§ngen. <br><br>  Beachten Sie jedoch, dass die letzten beiden Beispiele die Funktion einer Variablen zuweisen.  Es sieht aus wie eine Kleinigkeit.  Warum nicht einer Variablen eine Funktion zuweisen?  Aber es ist sehr wichtig.  Funktionen in JavaScript geh√∂ren zur " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Klasse</a> ".  Deshalb k√∂nnen wir: <br><br><ul><li>  Weisen Sie Variablen Funktionen zu. <br></li><li>  √úbergeben Sie Funktionen als Argumente an andere Funktionen. <br></li><li>  Funktionen von anderen Funktionen zur√ºckgeben. <br></li></ul><br>  Das ist wunderbar, aber was hat das alles mit Funktionen h√∂herer Ordnung zu tun?  Achten Sie auf die letzten beiden Punkte.  Bald werden wir zu ihnen zur√ºckkehren, aber jetzt schauen wir uns einige Beispiele an. <br><br>  Wir haben die Zuordnung von Funktionen zu Variablen gesehen.  Was ist mit der √úbergabe als Parameter?  Schreiben wir eine Funktion, die mit DOM-Elementen verwendet werden kann.  Wenn wir <code>document.querySelectorAll()</code> ausf√ºhren, erhalten wir im Gegenzug kein Array, sondern eine <code>NodeList</code> .  <code>NodeList</code> hat keine <code>.map()</code> -Methode wie Arrays, daher schreiben wir <code>.map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Apply a given function to every item in a NodeList and return an array. function elListMap(transform, list) { // list might be a NodeList, which doesn't have .map(), so we convert // it to an array. return [...list].map(transform); } // Grab all the spans on the page with the class 'for-listing'. const mySpans = document.querySelectorAll('span.for-listing'); // Wrap each one inside an &lt;li&gt; element. We re-use the // itemise() function from earlier. const wrappedList = elListMap(itemise, mySpans);</span></span></code> </pre> <br>  Hier √ºbergeben wir die itemise-Funktion als Argument an die <code>elListMap</code> Funktion.  Mit <code>elListMap</code> k√∂nnen wir jedoch nicht nur Listen erstellen.  Mit seiner Hilfe k√∂nnen Sie beispielsweise einer Reihe von Elementen eine Klasse hinzuf√ºgen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSpinnerClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ el.classList.add(<span class="hljs-string"><span class="hljs-string">'spinner'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el; } <span class="hljs-comment"><span class="hljs-comment">// Find all the buttons with class 'loader' const loadButtons = document.querySelectorAll('button.loader'); // Add the spinner class to all the buttons we found. elListMap(addSpinnerClass, loadButtons);</span></span></code> </pre><br>  <code>elLlistMap</code> √ºbernimmt eine andere Funktion als Parameter und konvertiert.  Das hei√üt, wir k√∂nnen <code>elListMap</code> , um verschiedene Probleme zu l√∂sen. <br><br>  Wir haben uns ein Beispiel f√ºr die √úbergabe von Funktionen als Parameter angesehen.  Lassen Sie uns nun √ºber die R√ºckgabe einer Funktion von einer Funktion sprechen.  Wie sieht es aus? <br><br>  Zuerst schreiben wir die √ºbliche alte Funktion.  Wir m√ºssen eine Liste der <code>li</code> Elemente nehmen und in <code>ul</code> einwickeln.  Einfach: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapWithUl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">children</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...children].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">listEl, child</span></span></span><span class="hljs-function">) =&gt;</span></span> { listEl.appendChild(child); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listEl; }, ul); }</code> </pre> <br>  Und wenn wir dann eine Reihe von Absatzelementen haben, die wir in ein <code>div</code> m√∂chten?  Kein Problem, wir werden eine weitere Funktion daf√ºr schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapWithDiv</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">children</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...children].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">divEl, child</span></span></span><span class="hljs-function">) =&gt;</span></span> { divEl.appendChild(child); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> divEl; }, div); }</code> </pre> <br>  Es funktioniert gro√üartig.  Diese beiden Funktionen sind jedoch sehr √§hnlich. Der einzige Unterschied besteht in dem √ºbergeordneten Element, das wir erstellt haben. <br><br>  Jetzt <i>k√∂nnten</i> wir eine Funktion schreiben, die zwei Parameter akzeptiert: den Typ des √ºbergeordneten Elements und die Liste der untergeordneten Elemente.  Es gibt aber noch eine andere Option.  Wir k√∂nnen eine Funktion erstellen, die eine Funktion zur√ºckgibt.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createListWrapperFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementType</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Straight away, we return a function. return function wrap(children) { // Inside our wrap function, we can 'see' the elementType parameter. const parent = document.createElement(elementType); return [...children].reduce((parentEl, child) =&gt; { parentEl.appendChild(child); return parentEl; }, parent); } }</span></span></code> </pre> <br>  Es k√∂nnte auf den ersten Blick etwas kompliziert aussehen, also teilen wir den Code auf.  Wir haben eine Funktion erstellt, die nur eine andere Funktion zur√ºckgibt.  Diese R√ºckgabefunktion <i>merkt sich jedoch</i> den Parameter <code>elementType</code> .  Wenn wir dann die zur√ºckgegebene Funktion aufrufen, wei√ü sie bereits, welches Element erstellt werden soll.  Daher k√∂nnen Sie <code>wrapWithUl</code> und <code>wrapWithDiv</code> erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapWithUl = createListWrapperFunction(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Our wrapWithUl() function now 'remembers' that it creates a ul element. const wrapWithDiv = createListWreapperFunction('div'); // Our wrapWithDiv() function now 'remembers' that it creates a div element.</span></span></code> </pre> <br>  Dieser Trick wird als Abschluss bezeichnet, wenn sich die zur√ºckgegebene Funktion an etwas ‚Äûerinnert‚Äú.  Mehr dar√ºber k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen.  Verschl√ºsse sind unglaublich praktisch, aber im Moment werden wir nicht dar√ºber nachdenken. <br><br>  Also haben wir aussortiert: <br><br><ul><li>  Zuweisen einer Funktion zu einer Variablen. <br></li><li>  √úbergabe einer Funktion als Parameter. <br></li><li>  R√ºckgabe einer Funktion von einer anderen Funktion ... <br></li></ul><br>  Im Allgemeinen sind die Funktionen der ersten Klasse eine angenehme Sache.  Aber was hat <i>die Funktion h√∂herer Ordnung damit zu</i> tun?  Schauen wir uns die Definition an. <br><br><h2>  Was ist eine Funktion h√∂herer Ordnung? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition</a> : <i>Dies ist eine Funktion, die eine Funktion als Argument verwendet oder als Ergebnis eine Funktion zur√ºckgibt.</i> <br><br>  Ist das bekannt?  In JavaScript sind dies erstklassige Funktionen.  Das hei√üt, "Funktionen h√∂herer Ordnung" haben genau die gleichen Vorteile.  Mit anderen Worten, es ist nur ein phantasievoller Name f√ºr eine einfache Idee. <br><br><h2>  Funktionsbeispiele h√∂herer Ordnung </h2><br>  Wenn Sie anfangen zu suchen, bemerken Sie √ºberall Funktionen h√∂herer Ordnung.  Am h√§ufigsten sind Funktionen, die andere Funktionen als Parameter verwenden. <br><br><h3>  Funktionen, die andere Funktionen als Parameter √ºbernehmen </h3><br>  Wenn Sie einen R√ºckruf √ºbergeben, verwenden Sie eine Funktion h√∂herer Ordnung.  In der Front-End-Entwicklung sind sie √ºberall zu finden.  Eine der h√§ufigsten ist die <code>.addEventListener()</code> -Methode.  Wir verwenden es, wenn wir als Reaktion auf bestimmte Ereignisse Aktionen ausf√ºhren m√∂chten.  Zum Beispiel m√∂chte ich eine Schaltfl√§che erstellen, die eine Warnung anzeigt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAlert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Fallacies do not cease to be fallacies because they become fashions'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML += <span class="hljs-string"><span class="hljs-string">`&lt;button type="button" class="js-alertbtn"&gt; Show alert &lt;/button&gt;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> btn = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.js-alertbtn'</span></span>); btn.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, showAlert);</code> </pre> <br>  Hier haben wir eine Funktion erstellt, die eine Warnung anzeigt, der Seite eine Schaltfl√§che hinzugef√ºgt und die Funktion <code>showAlert()</code> als Argument an <code>btn.addEventListener()</code> . <br><br>  Wir sto√üen auch auf Funktionen h√∂herer Ordnung, wenn wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array-Iterationsmethoden verwenden</a> : zum Beispiel <code>.map()</code> , <code>.filter()</code> und <code>.reduce()</code> .  Wie in der Funktion <code>elListMap()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elListMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transform, list</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...list].map(transform); }</code> </pre> <br>  Funktionen h√∂herer Ordnung helfen auch dabei, mit Verz√∂gerungen und Timing zu arbeiten.  Die Funktionen <code>setTimeout()</code> und <code>setInterval()</code> helfen bei der Steuerung, <i>wann</i> Funktionen ausgef√ºhrt werden.  Wenn Sie beispielsweise die <code>highlight</code> nach 30 Sekunden entfernen m√ºssen, k√∂nnen Sie dies folgenderma√üen tun: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHighlights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> highlightedElements = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.highlighted'</span></span>); elListMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.classList.remove(<span class="hljs-string"><span class="hljs-string">'highlighted'</span></span>), highlightedElements); } setTimeout(removeHighlights, <span class="hljs-number"><span class="hljs-number">30000</span></span>);</code> </pre> <br>  Wieder haben wir eine Funktion erstellt und als Argument an eine andere Funktion √ºbergeben. <br><br>  Wie Sie sehen k√∂nnen, verf√ºgt JavaScript h√§ufig √ºber Funktionen, die andere Funktionen akzeptieren.  Und Sie verwenden sie wahrscheinlich bereits. <br><br><h3>  Funktionen R√ºckgabe von Funktionen </h3><br>  Funktionen dieser Art werden nicht so oft gefunden wie die vorherigen.  Sie sind aber auch n√ºtzlich.  Eines der besten Beispiele ist die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maybe ()</a> .  Ich habe eine Variante aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allong√© JavaScript-Buch</a> angepasst: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maybe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_maybe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Note that the == is deliberate. if ((args.length === 0) || args.some(a =&gt; (a == null)) { return undefined; } return fn.apply(this, args); } }</span></span></code> </pre> <br>  Anstatt den Code zu verstehen, wollen wir zun√§chst sehen, wie er angewendet werden kann.  Schauen wir uns noch einmal die Funktion <code>elListMap()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Apply a given function to every item in a NodeList and return an array. function elListMap(transform, list) { // list might be a NodeList, which doesn't have .map(), so we convert // it to an array. return [...list].map(transform); }</span></span></code> </pre> <br>  Was passiert, wenn ich versehentlich null oder einen undefinierten Wert an <code>elListMap()</code> ?  Wir werden einen TypeError und einen Fall der aktuellen Operation erhalten, was auch immer es sein mag.  Dies kann mit der Funktion <code>maybe()</code> vermieden werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> safeElListMap = maybe(elListMap); safeElListMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Ôø© undefined</span></span></code> </pre> <br>  Anstatt zu fallen, gibt die Funktion <code>undefined</code> .  Und wenn wir dies an eine andere Funktion √ºbergeben w√ºrden, die durch <code>maybe()</code> gesch√ºtzt ist, w√ºrden wir wieder <code>undefined</code> .  <code>maybe()</code> eine beliebige Anzahl von Funktionen sch√ºtzen. Es ist viel einfacher, eine Milliarde <code>if</code> zu schreiben. <br><br>  Funktionen, die Funktionen zur√ºckgeben, sind auch in der React-Welt √ºblich.  Zum Beispiel <code>connect()</code> . <br><br><h2>  Und was dann? </h2><br>  Wir haben mehrere Beispiele f√ºr die Verwendung von Funktionen h√∂herer Ordnung gesehen.  Und was dann?  Was k√∂nnen sie uns geben, was wir ohne sie nicht bekommen k√∂nnen? <br><br>  Um diese Frage zu beantworten, schauen wir uns ein anderes Beispiel an - die integrierte Array-Methode <code>.sort()</code> .  Ja, er hat Fehler.  Es √§ndert das Array, anstatt ein neues zur√ºckzugeben.  Aber vergessen wir es jetzt.  Die <code>.sort()</code> -Methode ist eine Funktion h√∂herer Ordnung, die eine andere Funktion als einen der Parameter verwendet. <br><br>  Wie funktioniert es  Wenn wir ein Array von Zahlen sortieren m√∂chten, m√ºssen wir zuerst eine Vergleichsfunktion erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareNumbers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* else */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  Sortieren Sie nun das Array: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nums = [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; nums.sort(compareNumbers); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(nums); <span class="hljs-comment"><span class="hljs-comment">// „Äï[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span></code> </pre> <br>  Sie k√∂nnen Nummernlisten sortieren.  Aber was n√ºtzt es?  Wie oft m√ºssen wir eine Liste mit Nummern sortieren?  Nicht oft.  Normalerweise muss ich eine Reihe von Objekten sortieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> typeaheadMatches = [ { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bogey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bog'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'boggle'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bogey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'toboggan'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bag'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>], } ];</code> </pre> <br>  Angenommen, ich m√∂chte dieses Array nach dem Gewicht jedes Datensatzes sortieren.  Ich <i>k√∂nnte</i> eine neue Sortierfunktion von Grund auf neu schreiben.  Aber warum, wenn Sie eine neue Vergleichsfunktion erstellen k√∂nnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTypeaheadResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word1, word2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> * compareNumbers(word1.weight, word2.weight); } typeaheadMatches.sort(compareTypeaheadResult); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(typeaheadMatches); <span class="hljs-comment"><span class="hljs-comment">// „Äï[{keyword: "bog", weight: 0.5, matchedChars: ["bog"]}, ‚Ä¶ ]</span></span></code> </pre> <br>  Sie k√∂nnen eine Vergleichsfunktion f√ºr jede Art von Array schreiben.  Die <code>.sort()</code> -Methode hilft uns: ‚ÄûWenn Sie mir eine Vergleichsfunktion geben, sortiere ich jedes Array.  Mach dir keine Sorgen √ºber den Inhalt.  Wenn Sie eine Sortierfunktion angeben, werde ich sie sortieren. ‚Äú  Daher m√ºssen wir keinen eigenen Sortieralgorithmus schreiben, sondern konzentrieren uns auf die viel einfachere Aufgabe, zwei Elemente zu vergleichen. <br><br>  Stellen Sie sich nun vor, wir verwenden keine Funktionen h√∂herer Ordnung.  Wir k√∂nnen keine Funktion an die <code>.sort()</code> -Methode √ºbergeben.  Wir m√ºssen jedes Mal eine neue Sortierfunktion schreiben, wenn wir ein Array einer anderen Art sortieren m√ºssen.  Oder Sie m√ºssen dasselbe mit Funktionszeigern oder Objekten neu erfinden.  In jedem Fall wird es sehr unangenehm ausfallen. <br><br>  Wir haben jedoch Funktionen h√∂herer Ordnung, mit denen wir die Sortierfunktion von der Vergleichsfunktion trennen k√∂nnen.  <code>.sort()</code> ein Entwickler eines intelligenten Browsers hat <code>.sort()</code> aktualisiert, um einen schnelleren Algorithmus zu verwenden.  Dann gewinnt Ihr Code nur, unabh√§ngig davon, was sich in den sortierbaren Arrays befindet.  Und dieses Schema gilt f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine ganze Reihe von Funktionen von Arrays h√∂herer Ordnung</a> . <br><br>  Dies f√ºhrt uns zu einer solchen Idee.  Die Methode <code>.sort()</code> <i>abstrahiert</i> die <i>Sortieraufgabe</i> vom <i>Inhalt des</i> Arrays.  Dies wird als Trennung von Bedenken bezeichnet.  Mit Funktionen h√∂herer Ordnung k√∂nnen Sie Abstraktionen erstellen, die ohne sie sehr umst√§ndlich oder sogar unm√∂glich w√§ren.  Und die Erstellung von Abstraktionen macht 80% der Arbeit von Softwareentwicklern aus. <br><br>  Wenn wir den Code umgestalten, um Wiederholungen zu entfernen, erstellen wir Abstraktionen.  Wir sehen das Muster und ersetzen es durch eine abstrakte Darstellung.  Dadurch wird der Code aussagekr√§ftiger und verst√§ndlicher.  Zumindest ist das das Ziel. <br><br>  Funktionen h√∂herer Ordnung sind ein leistungsstarkes Werkzeug zum Erstellen von Abstraktionen.  Und mit Abstraktionen ist ein ganzer Zweig der Mathematik, die Kategorietheorie, verbunden.  Genauer gesagt widmet sich die Kategorietheorie der Suche nach Abstraktionen von Abstraktionen.  Mit anderen Worten, wir sprechen √ºber das Finden von Mustern von Mustern.  Und in den letzten 70 Jahren haben clevere Programmierer viele Ideen von dort ausgeliehen, die sich in die Eigenschaften von Sprachen und Bibliotheken verwandelt haben.  Wenn wir diese Muster lernen, k√∂nnen wir manchmal gro√üe Codeteile ersetzen.  Oder vereinfachen Sie komplexe Probleme zu eleganten Kombinationen einfacher Bausteine.  Diese Bl√∂cke sind Funktionen h√∂herer Ordnung.  Daher sind sie so wichtig, dass sie uns ein leistungsstarkes Werkzeug bieten, um die Komplexit√§t unseres Codes zu bek√§mpfen. <br><br>  Zus√§tzliche Materialien zu Funktionen h√∂herer Ordnung: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen h√∂herer Ordnung</a> : das f√ºnfte Kapitel aus <i>Eloquent JavaScript</i> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen h√∂herer Ordnung</a> : Teil der Artikelserie <i>Composing Sofware</i> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen h√∂herer Ordnung in JavaScript</a> . <br></li></ul><br>  Sie verwenden wahrscheinlich bereits Funktionen h√∂herer Ordnung.  Dies ist in JavaScript so einfach, dass wir nicht einmal dar√ºber nachdenken.  Aber es ist besser zu wissen, wor√ºber die Leute sprechen, wenn sie diesen Satz sagen.  Das ist nicht schwer.  Aber hinter einer einfachen Idee steckt viel Kraft. <br><br>  Wenn Sie Erfahrung in der funktionalen Programmierung haben, werden Sie vielleicht feststellen, dass ich keine reinen Funktionen und einige ... ausf√ºhrliche Funktionsnamen verwendet habe.  Dies liegt nicht daran, dass ich nichts √ºber unreine Funktionen oder die allgemeinen Prinzipien der funktionalen Programmierung geh√∂rt habe.  Und ich schreibe keinen solchen Code in der Produktion.  Ich habe versucht, praktische Beispiele zu finden, die Anf√§ngern klar sind.  Manchmal musste ich Kompromisse eingehen.  Bei Interesse habe ich bereits √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktionale Sauberkeit</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allgemeinen Prinzipien der funktionalen Programmierung geschrieben</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458896/">https://habr.com/ru/post/de458896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458886/index.html">Am n√ºtzlichsten Mail.ru Design Conf √ó Dribbble Meetup 2019 Papers von True Engineering</a></li>
<li><a href="../de458888/index.html">Summer Droid Meetup</a></li>
<li><a href="../de458890/index.html">Stichproben- und Berechnungsgenauigkeit</a></li>
<li><a href="../de458892/index.html">Vorschl√§ge f√ºr Sicherheitsl√ºcken und den Schutz von Modellen f√ºr maschinelles Lernen</a></li>
<li><a href="../de458894/index.html">Typische Menschen und die Netzwerke, in denen sie leben</a></li>
<li><a href="../de458900/index.html">Konsolenpatronen als Modems</a></li>
<li><a href="../de458902/index.html">5 H√§ufige Python-Anf√§ngerfehler</a></li>
<li><a href="../de458904/index.html">Visualisierung der Anzahl der Siege f√ºr NBA-Teams mithilfe animierter Balkendiagramme in R.</a></li>
<li><a href="../de458906/index.html">[Jekaterinburg, Ank√ºndigung] Flutteron - ein Workshop zur Entwicklung von Flutter</a></li>
<li><a href="../de458908/index.html">Scannen von Dokumenten √ºber das Netzwerk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>