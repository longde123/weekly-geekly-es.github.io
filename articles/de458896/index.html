<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕠 🎣 👊 Funktionales JavaScript: Was sind Funktionen höherer Ordnung und warum werden sie benötigt? 👲🏾 🙆🏽 😱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Funktionen höherer Ordnung" ist eine dieser Phrasen, die oft verstreut sind. Aber selten kann jemand anhalten und erklären, was es ist. Möglicherweis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales JavaScript: Was sind Funktionen höherer Ordnung und warum werden sie benötigt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/458896/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/le/mw/stlemwjifksb6iqurxqvutclf9s.jpeg"></div><br>  "Funktionen höherer Ordnung" ist eine dieser Phrasen, die oft verstreut sind.  Aber selten kann jemand anhalten und erklären, was es ist.  Möglicherweise kennen Sie bereits Funktionen höherer Ordnung.  Aber wie setzen wir sie in realen Projekten ein?  Wann und warum sind sie hilfreich?  Können wir das DOM mit ihrer Hilfe manipulieren?  Oder zeigen sich Leute, die diese Funktionen nutzen, nur?  Vielleicht komplizieren sie den Code sinnlos? <br><br>  Früher dachte ich, dass Funktionen höherer Ordnung nützlich sind.  Jetzt halte ich sie für die wichtigste Eigenschaft von JavaScript als Sprache.  Bevor wir dies diskutieren, wollen wir zunächst herausfinden, was genau Funktionen höherer Ordnung sind.  Und wir werden mit Funktionen als Variablen beginnen. <br><a name="habracut"></a><br><h2>  Funktioniert als erstklassige Objekte </h2><br>  In JavaScript gibt es mindestens drei Möglichkeiten (es gibt insgesamt mehr), um eine neue Funktion zu schreiben.  Zunächst können Sie <i>eine Funktionsdeklaration</i> schreiben: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Take a DOM element and wrap it in a list item element. function itemise(el) { const li = document.createElement('li'); li.appendChild(el); return li; }</span></span></code> </pre> <br>  Ich hoffe du verstehst alles.  Außerdem wissen Sie wahrscheinlich, dass Sie einen <i>Funktionsausdruck</i> schreiben <i>können</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemise = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> li = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'li'</span></span>); li.appendChild(el); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> li; }</code> </pre> <br>  Und schließlich gibt es eine andere Möglichkeit, dieselbe Funktion zu schreiben - als <i>Pfeilfunktion</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemise = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> li = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'li'</span></span>); li.appendChild(el); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> li; }</code> </pre> <br>  In diesem Fall sind alle drei Methoden gleichwertig.  Obwohl dies nicht immer der Fall ist, weist jede Methode in der Praxis kleine Unterschiede auf, die mit der Magie eines bestimmten Schlüsselworts und von Beschriftungen in Stapelspuren zusammenhängen. <br><br>  Beachten Sie jedoch, dass die letzten beiden Beispiele die Funktion einer Variablen zuweisen.  Es sieht aus wie eine Kleinigkeit.  Warum nicht einer Variablen eine Funktion zuweisen?  Aber es ist sehr wichtig.  Funktionen in JavaScript gehören zur " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Klasse</a> ".  Deshalb können wir: <br><br><ul><li>  Weisen Sie Variablen Funktionen zu. <br></li><li>  Übergeben Sie Funktionen als Argumente an andere Funktionen. <br></li><li>  Funktionen von anderen Funktionen zurückgeben. <br></li></ul><br>  Das ist wunderbar, aber was hat das alles mit Funktionen höherer Ordnung zu tun?  Achten Sie auf die letzten beiden Punkte.  Bald werden wir zu ihnen zurückkehren, aber jetzt schauen wir uns einige Beispiele an. <br><br>  Wir haben die Zuordnung von Funktionen zu Variablen gesehen.  Was ist mit der Übergabe als Parameter?  Schreiben wir eine Funktion, die mit DOM-Elementen verwendet werden kann.  Wenn wir <code>document.querySelectorAll()</code> ausführen, erhalten wir im Gegenzug kein Array, sondern eine <code>NodeList</code> .  <code>NodeList</code> hat keine <code>.map()</code> -Methode wie Arrays, daher schreiben wir <code>.map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Apply a given function to every item in a NodeList and return an array. function elListMap(transform, list) { // list might be a NodeList, which doesn't have .map(), so we convert // it to an array. return [...list].map(transform); } // Grab all the spans on the page with the class 'for-listing'. const mySpans = document.querySelectorAll('span.for-listing'); // Wrap each one inside an &lt;li&gt; element. We re-use the // itemise() function from earlier. const wrappedList = elListMap(itemise, mySpans);</span></span></code> </pre> <br>  Hier übergeben wir die itemise-Funktion als Argument an die <code>elListMap</code> Funktion.  Mit <code>elListMap</code> können wir jedoch nicht nur Listen erstellen.  Mit seiner Hilfe können Sie beispielsweise einer Reihe von Elementen eine Klasse hinzufügen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSpinnerClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ el.classList.add(<span class="hljs-string"><span class="hljs-string">'spinner'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el; } <span class="hljs-comment"><span class="hljs-comment">// Find all the buttons with class 'loader' const loadButtons = document.querySelectorAll('button.loader'); // Add the spinner class to all the buttons we found. elListMap(addSpinnerClass, loadButtons);</span></span></code> </pre><br>  <code>elLlistMap</code> übernimmt eine andere Funktion als Parameter und konvertiert.  Das heißt, wir können <code>elListMap</code> , um verschiedene Probleme zu lösen. <br><br>  Wir haben uns ein Beispiel für die Übergabe von Funktionen als Parameter angesehen.  Lassen Sie uns nun über die Rückgabe einer Funktion von einer Funktion sprechen.  Wie sieht es aus? <br><br>  Zuerst schreiben wir die übliche alte Funktion.  Wir müssen eine Liste der <code>li</code> Elemente nehmen und in <code>ul</code> einwickeln.  Einfach: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapWithUl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">children</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...children].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">listEl, child</span></span></span><span class="hljs-function">) =&gt;</span></span> { listEl.appendChild(child); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listEl; }, ul); }</code> </pre> <br>  Und wenn wir dann eine Reihe von Absatzelementen haben, die wir in ein <code>div</code> möchten?  Kein Problem, wir werden eine weitere Funktion dafür schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapWithDiv</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">children</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...children].reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">divEl, child</span></span></span><span class="hljs-function">) =&gt;</span></span> { divEl.appendChild(child); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> divEl; }, div); }</code> </pre> <br>  Es funktioniert großartig.  Diese beiden Funktionen sind jedoch sehr ähnlich. Der einzige Unterschied besteht in dem übergeordneten Element, das wir erstellt haben. <br><br>  Jetzt <i>könnten</i> wir eine Funktion schreiben, die zwei Parameter akzeptiert: den Typ des übergeordneten Elements und die Liste der untergeordneten Elemente.  Es gibt aber noch eine andere Option.  Wir können eine Funktion erstellen, die eine Funktion zurückgibt.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createListWrapperFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementType</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Straight away, we return a function. return function wrap(children) { // Inside our wrap function, we can 'see' the elementType parameter. const parent = document.createElement(elementType); return [...children].reduce((parentEl, child) =&gt; { parentEl.appendChild(child); return parentEl; }, parent); } }</span></span></code> </pre> <br>  Es könnte auf den ersten Blick etwas kompliziert aussehen, also teilen wir den Code auf.  Wir haben eine Funktion erstellt, die nur eine andere Funktion zurückgibt.  Diese Rückgabefunktion <i>merkt sich jedoch</i> den Parameter <code>elementType</code> .  Wenn wir dann die zurückgegebene Funktion aufrufen, weiß sie bereits, welches Element erstellt werden soll.  Daher können Sie <code>wrapWithUl</code> und <code>wrapWithDiv</code> erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapWithUl = createListWrapperFunction(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Our wrapWithUl() function now 'remembers' that it creates a ul element. const wrapWithDiv = createListWreapperFunction('div'); // Our wrapWithDiv() function now 'remembers' that it creates a div element.</span></span></code> </pre> <br>  Dieser Trick wird als Abschluss bezeichnet, wenn sich die zurückgegebene Funktion an etwas „erinnert“.  Mehr darüber können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen.  Verschlüsse sind unglaublich praktisch, aber im Moment werden wir nicht darüber nachdenken. <br><br>  Also haben wir aussortiert: <br><br><ul><li>  Zuweisen einer Funktion zu einer Variablen. <br></li><li>  Übergabe einer Funktion als Parameter. <br></li><li>  Rückgabe einer Funktion von einer anderen Funktion ... <br></li></ul><br>  Im Allgemeinen sind die Funktionen der ersten Klasse eine angenehme Sache.  Aber was hat <i>die Funktion höherer Ordnung damit zu</i> tun?  Schauen wir uns die Definition an. <br><br><h2>  Was ist eine Funktion höherer Ordnung? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition</a> : <i>Dies ist eine Funktion, die eine Funktion als Argument verwendet oder als Ergebnis eine Funktion zurückgibt.</i> <br><br>  Ist das bekannt?  In JavaScript sind dies erstklassige Funktionen.  Das heißt, "Funktionen höherer Ordnung" haben genau die gleichen Vorteile.  Mit anderen Worten, es ist nur ein phantasievoller Name für eine einfache Idee. <br><br><h2>  Funktionsbeispiele höherer Ordnung </h2><br>  Wenn Sie anfangen zu suchen, bemerken Sie überall Funktionen höherer Ordnung.  Am häufigsten sind Funktionen, die andere Funktionen als Parameter verwenden. <br><br><h3>  Funktionen, die andere Funktionen als Parameter übernehmen </h3><br>  Wenn Sie einen Rückruf übergeben, verwenden Sie eine Funktion höherer Ordnung.  In der Front-End-Entwicklung sind sie überall zu finden.  Eine der häufigsten ist die <code>.addEventListener()</code> -Methode.  Wir verwenden es, wenn wir als Reaktion auf bestimmte Ereignisse Aktionen ausführen möchten.  Zum Beispiel möchte ich eine Schaltfläche erstellen, die eine Warnung anzeigt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAlert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Fallacies do not cease to be fallacies because they become fashions'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML += <span class="hljs-string"><span class="hljs-string">`&lt;button type="button" class="js-alertbtn"&gt; Show alert &lt;/button&gt;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> btn = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.js-alertbtn'</span></span>); btn.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, showAlert);</code> </pre> <br>  Hier haben wir eine Funktion erstellt, die eine Warnung anzeigt, der Seite eine Schaltfläche hinzugefügt und die Funktion <code>showAlert()</code> als Argument an <code>btn.addEventListener()</code> . <br><br>  Wir stoßen auch auf Funktionen höherer Ordnung, wenn wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array-Iterationsmethoden verwenden</a> : zum Beispiel <code>.map()</code> , <code>.filter()</code> und <code>.reduce()</code> .  Wie in der Funktion <code>elListMap()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elListMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transform, list</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...list].map(transform); }</code> </pre> <br>  Funktionen höherer Ordnung helfen auch dabei, mit Verzögerungen und Timing zu arbeiten.  Die Funktionen <code>setTimeout()</code> und <code>setInterval()</code> helfen bei der Steuerung, <i>wann</i> Funktionen ausgeführt werden.  Wenn Sie beispielsweise die <code>highlight</code> nach 30 Sekunden entfernen müssen, können Sie dies folgendermaßen tun: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHighlights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> highlightedElements = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.highlighted'</span></span>); elListMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.classList.remove(<span class="hljs-string"><span class="hljs-string">'highlighted'</span></span>), highlightedElements); } setTimeout(removeHighlights, <span class="hljs-number"><span class="hljs-number">30000</span></span>);</code> </pre> <br>  Wieder haben wir eine Funktion erstellt und als Argument an eine andere Funktion übergeben. <br><br>  Wie Sie sehen können, verfügt JavaScript häufig über Funktionen, die andere Funktionen akzeptieren.  Und Sie verwenden sie wahrscheinlich bereits. <br><br><h3>  Funktionen Rückgabe von Funktionen </h3><br>  Funktionen dieser Art werden nicht so oft gefunden wie die vorherigen.  Sie sind aber auch nützlich.  Eines der besten Beispiele ist die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maybe ()</a> .  Ich habe eine Variante aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allongé JavaScript-Buch</a> angepasst: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maybe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_maybe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Note that the == is deliberate. if ((args.length === 0) || args.some(a =&gt; (a == null)) { return undefined; } return fn.apply(this, args); } }</span></span></code> </pre> <br>  Anstatt den Code zu verstehen, wollen wir zunächst sehen, wie er angewendet werden kann.  Schauen wir uns noch einmal die Funktion <code>elListMap()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Apply a given function to every item in a NodeList and return an array. function elListMap(transform, list) { // list might be a NodeList, which doesn't have .map(), so we convert // it to an array. return [...list].map(transform); }</span></span></code> </pre> <br>  Was passiert, wenn ich versehentlich null oder einen undefinierten Wert an <code>elListMap()</code> ?  Wir werden einen TypeError und einen Fall der aktuellen Operation erhalten, was auch immer es sein mag.  Dies kann mit der Funktion <code>maybe()</code> vermieden werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> safeElListMap = maybe(elListMap); safeElListMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ￩ undefined</span></span></code> </pre> <br>  Anstatt zu fallen, gibt die Funktion <code>undefined</code> .  Und wenn wir dies an eine andere Funktion übergeben würden, die durch <code>maybe()</code> geschützt ist, würden wir wieder <code>undefined</code> .  <code>maybe()</code> eine beliebige Anzahl von Funktionen schützen. Es ist viel einfacher, eine Milliarde <code>if</code> zu schreiben. <br><br>  Funktionen, die Funktionen zurückgeben, sind auch in der React-Welt üblich.  Zum Beispiel <code>connect()</code> . <br><br><h2>  Und was dann? </h2><br>  Wir haben mehrere Beispiele für die Verwendung von Funktionen höherer Ordnung gesehen.  Und was dann?  Was können sie uns geben, was wir ohne sie nicht bekommen können? <br><br>  Um diese Frage zu beantworten, schauen wir uns ein anderes Beispiel an - die integrierte Array-Methode <code>.sort()</code> .  Ja, er hat Fehler.  Es ändert das Array, anstatt ein neues zurückzugeben.  Aber vergessen wir es jetzt.  Die <code>.sort()</code> -Methode ist eine Funktion höherer Ordnung, die eine andere Funktion als einen der Parameter verwendet. <br><br>  Wie funktioniert es  Wenn wir ein Array von Zahlen sortieren möchten, müssen wir zuerst eine Vergleichsfunktion erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareNumbers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* else */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  Sortieren Sie nun das Array: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nums = [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; nums.sort(compareNumbers); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(nums); <span class="hljs-comment"><span class="hljs-comment">// 〕[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span></code> </pre> <br>  Sie können Nummernlisten sortieren.  Aber was nützt es?  Wie oft müssen wir eine Liste mit Nummern sortieren?  Nicht oft.  Normalerweise muss ich eine Reihe von Objekten sortieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> typeaheadMatches = [ { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bogey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bog'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'boggle'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bogey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'toboggan'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'bog'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">keyword</span></span>: <span class="hljs-string"><span class="hljs-string">'bag'</span></span>, <span class="hljs-attr"><span class="hljs-attr">weight</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchedChars</span></span>: [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>], } ];</code> </pre> <br>  Angenommen, ich möchte dieses Array nach dem Gewicht jedes Datensatzes sortieren.  Ich <i>könnte</i> eine neue Sortierfunktion von Grund auf neu schreiben.  Aber warum, wenn Sie eine neue Vergleichsfunktion erstellen können: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTypeaheadResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word1, word2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> * compareNumbers(word1.weight, word2.weight); } typeaheadMatches.sort(compareTypeaheadResult); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(typeaheadMatches); <span class="hljs-comment"><span class="hljs-comment">// 〕[{keyword: "bog", weight: 0.5, matchedChars: ["bog"]}, … ]</span></span></code> </pre> <br>  Sie können eine Vergleichsfunktion für jede Art von Array schreiben.  Die <code>.sort()</code> -Methode hilft uns: „Wenn Sie mir eine Vergleichsfunktion geben, sortiere ich jedes Array.  Mach dir keine Sorgen über den Inhalt.  Wenn Sie eine Sortierfunktion angeben, werde ich sie sortieren. “  Daher müssen wir keinen eigenen Sortieralgorithmus schreiben, sondern konzentrieren uns auf die viel einfachere Aufgabe, zwei Elemente zu vergleichen. <br><br>  Stellen Sie sich nun vor, wir verwenden keine Funktionen höherer Ordnung.  Wir können keine Funktion an die <code>.sort()</code> -Methode übergeben.  Wir müssen jedes Mal eine neue Sortierfunktion schreiben, wenn wir ein Array einer anderen Art sortieren müssen.  Oder Sie müssen dasselbe mit Funktionszeigern oder Objekten neu erfinden.  In jedem Fall wird es sehr unangenehm ausfallen. <br><br>  Wir haben jedoch Funktionen höherer Ordnung, mit denen wir die Sortierfunktion von der Vergleichsfunktion trennen können.  <code>.sort()</code> ein Entwickler eines intelligenten Browsers hat <code>.sort()</code> aktualisiert, um einen schnelleren Algorithmus zu verwenden.  Dann gewinnt Ihr Code nur, unabhängig davon, was sich in den sortierbaren Arrays befindet.  Und dieses Schema gilt für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine ganze Reihe von Funktionen von Arrays höherer Ordnung</a> . <br><br>  Dies führt uns zu einer solchen Idee.  Die Methode <code>.sort()</code> <i>abstrahiert</i> die <i>Sortieraufgabe</i> vom <i>Inhalt des</i> Arrays.  Dies wird als Trennung von Bedenken bezeichnet.  Mit Funktionen höherer Ordnung können Sie Abstraktionen erstellen, die ohne sie sehr umständlich oder sogar unmöglich wären.  Und die Erstellung von Abstraktionen macht 80% der Arbeit von Softwareentwicklern aus. <br><br>  Wenn wir den Code umgestalten, um Wiederholungen zu entfernen, erstellen wir Abstraktionen.  Wir sehen das Muster und ersetzen es durch eine abstrakte Darstellung.  Dadurch wird der Code aussagekräftiger und verständlicher.  Zumindest ist das das Ziel. <br><br>  Funktionen höherer Ordnung sind ein leistungsstarkes Werkzeug zum Erstellen von Abstraktionen.  Und mit Abstraktionen ist ein ganzer Zweig der Mathematik, die Kategorietheorie, verbunden.  Genauer gesagt widmet sich die Kategorietheorie der Suche nach Abstraktionen von Abstraktionen.  Mit anderen Worten, wir sprechen über das Finden von Mustern von Mustern.  Und in den letzten 70 Jahren haben clevere Programmierer viele Ideen von dort ausgeliehen, die sich in die Eigenschaften von Sprachen und Bibliotheken verwandelt haben.  Wenn wir diese Muster lernen, können wir manchmal große Codeteile ersetzen.  Oder vereinfachen Sie komplexe Probleme zu eleganten Kombinationen einfacher Bausteine.  Diese Blöcke sind Funktionen höherer Ordnung.  Daher sind sie so wichtig, dass sie uns ein leistungsstarkes Werkzeug bieten, um die Komplexität unseres Codes zu bekämpfen. <br><br>  Zusätzliche Materialien zu Funktionen höherer Ordnung: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen höherer Ordnung</a> : das fünfte Kapitel aus <i>Eloquent JavaScript</i> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen höherer Ordnung</a> : Teil der Artikelserie <i>Composing Sofware</i> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen höherer Ordnung in JavaScript</a> . <br></li></ul><br>  Sie verwenden wahrscheinlich bereits Funktionen höherer Ordnung.  Dies ist in JavaScript so einfach, dass wir nicht einmal darüber nachdenken.  Aber es ist besser zu wissen, worüber die Leute sprechen, wenn sie diesen Satz sagen.  Das ist nicht schwer.  Aber hinter einer einfachen Idee steckt viel Kraft. <br><br>  Wenn Sie Erfahrung in der funktionalen Programmierung haben, werden Sie vielleicht feststellen, dass ich keine reinen Funktionen und einige ... ausführliche Funktionsnamen verwendet habe.  Dies liegt nicht daran, dass ich nichts über unreine Funktionen oder die allgemeinen Prinzipien der funktionalen Programmierung gehört habe.  Und ich schreibe keinen solchen Code in der Produktion.  Ich habe versucht, praktische Beispiele zu finden, die Anfängern klar sind.  Manchmal musste ich Kompromisse eingehen.  Bei Interesse habe ich bereits über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktionale Sauberkeit</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allgemeinen Prinzipien der funktionalen Programmierung geschrieben</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458896/">https://habr.com/ru/post/de458896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458886/index.html">Am nützlichsten Mail.ru Design Conf × Dribbble Meetup 2019 Papers von True Engineering</a></li>
<li><a href="../de458888/index.html">Summer Droid Meetup</a></li>
<li><a href="../de458890/index.html">Stichproben- und Berechnungsgenauigkeit</a></li>
<li><a href="../de458892/index.html">Vorschläge für Sicherheitslücken und den Schutz von Modellen für maschinelles Lernen</a></li>
<li><a href="../de458894/index.html">Typische Menschen und die Netzwerke, in denen sie leben</a></li>
<li><a href="../de458900/index.html">Konsolenpatronen als Modems</a></li>
<li><a href="../de458902/index.html">5 Häufige Python-Anfängerfehler</a></li>
<li><a href="../de458904/index.html">Visualisierung der Anzahl der Siege für NBA-Teams mithilfe animierter Balkendiagramme in R.</a></li>
<li><a href="../de458906/index.html">[Jekaterinburg, Ankündigung] Flutteron - ein Workshop zur Entwicklung von Flutter</a></li>
<li><a href="../de458908/index.html">Scannen von Dokumenten über das Netzwerk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>