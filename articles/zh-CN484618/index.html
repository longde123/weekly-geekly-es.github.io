<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👝 🚏 🙎🏼 Angular 9和Ivy：惰性组件加载 ㊙️ 👩🏾‍⚖️ 📑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在Angular中加载延迟组件？ 也许我们正在谈论使用Angular路由器的延迟加载模块？ 不，我们正在谈论组件。 当前版本的Angular仅支持延迟模块加载。 但是Ivy为开发人员提供了使用组件的新机会。 

  

 到目前为止，我们使用的延迟负载：路线 
 延迟加载是一个很好的机制。 在Ang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular 9和Ivy：惰性组件加载</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/484618/"> 在Angular中加载延迟组件？ 也许我们正在谈论使用Angular路由器的延迟加载模块？ 不，我们正在谈论组件。 当前版本的Angular仅支持延迟模块加载。 但是Ivy为开发人员提供了使用组件的新机会。 <br><br> <a href="https://habr.com/ru/company/ruvds/blog/484618/"><img src="https://habrastorage.org/webt/ox/8d/ub/ox8dubshhrdlijoson4_gyjtarw.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">到目前为止，我们使用的延迟负载：路线</font> </h2><br> 延迟加载是一个很好的机制。 在Angular中，您可以通过声明支持延迟加载的路由来使用这种机制，而几乎无需付出任何努力。 这是Angular <a href="https://angular.io/guide/lazy-loading-ngmodules">文档中的</a>一个示例，说明了这一点： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> routes: Routes = [     { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'customer-list'</span></span>,       <span class="hljs-attr"><span class="hljs-attr">loadChildren</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./customers/customers.module'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> m.CustomersModule) }     ];</code> </pre> <br> 由于上面的代码，将为<code>customers.module</code>创建一个单独的片段，当用户沿着<code>customer-list</code>路线导航时将加载该片段。 <br><br> 这是减小项目主捆绑包大小并加快应用程序初始加载速度的一种很好的方法。 <br><br> 但是，尽管如此，能够更准确地控制延迟加载不是很好吗？ 例如，如果我们可以组织各个组件的延迟加载呢？ <br><br> 到目前为止，这还不可能。 但是随着常春藤的出现，这一切都改变了。 <br><br><h2>  <font color="#3AC1EF">常春藤和“地方性”的概念</font> </h2><br> 模块是每个Angular应用程序的基本概念和基本构建块。 这些模块声明组件，指令，管道，服务。 <br><br> 没有模块，现代Angular应用程序将不复存在。 原因之一是ViewEngine将所有必要的元数据添加到模块中。 <br><br> 另一方面，常春藤采取不同的方法。 在Ivy中，没有模块就可以存在组件。 这要归功于本地性的概念。 其实质是所有元数据都位于组件本地。 <br><br> 让我们通过分析使用Ivy生成的es2015捆绑包对此进行解释。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/775/370/02b7753703a0599491c3f9076527168f.png"></div><br>  <i><font color="#999999">使用Ivy生成的ES2015捆绑包</font></i> <br><br> 在“ <code>Component code</code>部分，您可以看到Ivy系统已保存了组件代码。 这里没有什么特别的。 但是随后Ivy将一些元数据添加到代码中。 <br><br> 图中的第一部分元数据显示为<code>Component factory</code> 。 工厂知道如何实例化组件。 在“ <code>Component metadata</code>部分中，Ivy放置了其他属性，例如<code>type</code>和<code>selectors</code> ，即组件在程序执行过程中所需的一切。 <br><br> 值得一提的是，Ivy在此处添加了<code>template</code>功能。 它显示在<code>Compiled version of your template</code>的“ <code>Compiled version of your template</code>部分中。 让我们更详细地讨论这个有趣的事实。 <br><br>  <code>template</code>函数是HTML代码的编译版本。 她遵循Ivy的说明创建DOM。 这与ViewEngine的工作方式不同。 <br><br>  ViewEngine系统采用代码并绕过它。 如果我们使用Angular，它将执行代码。 <br><br> 通过Ivy使用的方法，调用Angular命令的组件将负责所有工作。 此更改允许组件独立存在，这导致了可以将摇树算法应用于Angular基本代码的事实。 <br><br><h2>  <font color="#3AC1EF">延迟组件加载的真实示例</font> </h2><br> 现在我们知道可以进行惰性组件加载了，下面举一个真实的例子来考虑一下。 即，我们将创建一个测验应用程序，向用户询问带​​有答案选项的问题。 <br><br> 该应用程序显示城市图像和选项，您需要从中选择该城市的名称。 一旦用户通过单击相应的按钮选择一个选项，该按钮将立即更改，指示答案是对还是错。 如果按钮的背景变为绿色，则答案是正确的。 如果背景变成红色，则表示答案不正确。 <br><br> 收到当前问题的答案后，程序将显示以下问题。 这是它的外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fc/768/ece/2fc768ecebd5c52399030c0d2dc47c66.gif"></div><br>  <i><font color="#999999">测验演示</font></i> <br><br> 该程序询问用户的问题由<code>QuizCardComponent</code>组件表示。 <br><br><h2>  <font color="#3AC1EF">惰性组件加载概念</font> </h2><br> 让我们首先说明延迟加载<code>QuizCardComponent</code>组件的一般想法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ab/45a/b2b/4ab45ab2b677ce0d886d2f26a5645edb.png"></div><br>  <i><font color="#999999">QuizCardComponent组件过程</font></i> <br><br> 用户通过单击“ <code>Start quiz</code>按钮<code>Start quiz</code> ，我们开始延迟加载组件。 组件处理完毕后，我们将其放入容器中。 <br><br> 我们以<code>questionAnsvered</code>常规组件事件的响应相同的方式对“惰性”组件的<code>questionAnsvered</code>事件做出反应。 即，事件发生后，我们在屏幕上显示带有问题的下一张卡片。 <br><br><h2>  <font color="#3AC1EF">代码分析</font> </h2><br> 为了理解在延迟加载组件期间会发生什么，我们从<code>QuizCardComponent</code>的简化版本开始，该版本显示问题的属性。 <br><br> 然后，我们将在其中使用Angular Material组件来扩展此组件。 最后，我们将调整对组件产生的事件的反应。 <br><br> 让我们组织<code>QuizCardComponent</code>组件的简化版本的延迟加载，该组件具有以下模板： <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Here's the question<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>Image: <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> {{ question.image }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>Possible selections: <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> {{ question.possibleSelections.toString() }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>Correct answer: <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> {{ question.correctAnswer }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 第一步是创建一个容器元素。 为此，我们可以使用诸如<code>&lt;div&gt;</code>类的真实元素，也可以使用<code>ng-container</code> ，这使我们无需额外的HTML代码。 这就是容器元素的声明，其中放置了“惰性”组件： <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-toolbar</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"primary"</span></span></span><span class="hljs-tag">&gt;</span></span>  <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>City quiz<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"!quizStarted"</span></span></span><span class="hljs-tag">        </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mat-raised-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"primary"</span></span></span><span class="hljs-tag">        </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"start-quiz-button"</span></span></span><span class="hljs-tag">        (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"startQuiz()"</span></span></span><span class="hljs-tag">&gt;</span></span>Start quiz<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">quizContainer</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"quiz-card-container"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 在组件中，您需要访问容器。 为此，我们使用<code>@ViewChild</code>批注，让我们知道我们想阅读<code>ViewContainerRef</code> 。 <br><br> 请注意，在Angular 9中， <code>@ViewChild</code>批注中的<code>static</code>属性默认情况下设置为<code>false</code> ： <br><br><pre> <code class="javascript hljs">@ViewChild(<span class="hljs-string"><span class="hljs-string">'quizContainer'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">read</span></span>: ViewContainerRef}) quizContainer: ViewContainerRef;</code> </pre> <br> 现在，我们有一个容器，我们想在其中添加“惰性”组件。 接下来，我们需要<code>ComponentFactoryResolver</code>和<code>Injector</code> 。 可以通过依赖注入的方法来获取它们两者。 <br><br>  <code>ComponentFactoryResolver</code>实体是一个简单的注册表，用于设置组件与自动生成的<code>ComponentFactory</code>类之间的关系，这些类可用于实例化组件： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private quizservice: QuizService,            private cfr: ComponentFactoryResolver,            private injector: Injector) { }</code> </pre> <br> 现在，我们拥有实现目标所需的一切。  <code>startQuiz</code>研究<code>startQuiz</code>方法的内容并组织组件的延迟加载： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {QuizCardComponent} = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./quiz-card/quiz-card.component'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quizCardFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cfr.resolveComponentFactory(QuizCardComponent); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {instance} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.quizContainer.createComponent(quizCardFactory, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.injector); instance.question = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.quizservice.getNextQuestion();</code> </pre> <br> 我们可以使用<code>import</code> ECMAScript命令来组织<code>QuizCardComponent</code>的延迟加载。 导入表达式返回承诺。 您可以使用<code>async/await</code>构造或<code>.then</code>处理程序来使用它。 在解决了诺言之后，我们使用分解来创建组件的实例。 <br><br> 这些天，您必须使用<code>ComponentFactory</code>提供向后兼容性。 将来，不需要相应的行，因为我们将能够直接使用该组件。 <br><br>  <code>ComponentFactory</code>工厂为我们提供了<code>componentRef</code> 。 我们将<code>componentRef</code>和<code>Injector</code>传递给容器的<code>createComponent</code>方法。 <br><br>  <code>createComponent</code>方法返回一个<code>ComponentRef</code> ，其中包含组件实例。 我们使用<code>instance</code>传递组件<code>@Input</code> 。 <br><br> 将来，所有这些可能都可以使用Angular <code>renderComponent</code>方法完成。 此方法仍处于实验阶段。 但是，很有可能会变成常规的Angular方法。  <a href="https://github.com/LayZeeDK/ivy-dynamic-rendering">以下是</a>有关此主题的有用材料。 <br><br> 这是组织组件的延迟加载所需要的全部。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/2bd/4bc/2d42bd4bc38ee01c427c94286e060cbb.png"></div><br>  <i><font color="#999999">惰性组件加载</font></i> <br><br> 按下<code>Start quiz</code>按钮后，组件的延迟加载开始。 如果打开开发人员工具的“ <code>Network</code>标签，则可以看到延迟加载<code>quiz-card-quiz-card-component.js</code>文件表示的代码片段的过程。 在显示了加载和处理组件之后，用户会看到一个问题卡。 <br><br><h2>  <font color="#3AC1EF">组件扩展</font> </h2><br> 当前，我们正在加载<code>QuizCardComponent</code>组件。 很好 但是我们的应用程序还没有特别的功能。 <br><br> 让我们通过添加其他功能和Angular Material组件来解决此问题： <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"quiz-card"</span></span></span><span class="hljs-tag">&gt;</span></span>  <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card-header</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mat-card-avatar</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"quiz-header-image"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card-title</span></span></span><span class="hljs-tag">&gt;</span></span>Which city is this?<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card-title</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card-subtitle</span></span></span><span class="hljs-tag">&gt;</span></span>Click on the correct answer below<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card-subtitle</span></span></span><span class="hljs-tag">&gt;</span></span>  <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card-header</span></span></span><span class="hljs-tag">&gt;</span></span>  <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mat-card-image</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"'assets/' + question.image"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Photo of a Shiba Inu"</span></span></span><span class="hljs-tag">&gt;</span></span>  <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card-actions</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"answer-section"</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">disabled</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"answeredCorrectly !== undefined"</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"let selection of question.possibleSelections"</span></span></span><span class="hljs-tag">            </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mat-stroked-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"primary"</span></span></span><span class="hljs-tag">            [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngClass</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{              'correct': answeredCorrectly &amp;&amp; selection === question.correctAnswer,              'wrong': answeredCorrectly === false &amp;&amp; selection === question.correctAnswer             }"</span></span></span><span class="hljs-tag">            (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"answer(selection)"</span></span></span><span class="hljs-tag">&gt;</span></span>      {{selection}}    <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>  <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card-actions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mat-card</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 我们在组件中包含了一些漂亮的Material组件。 相应的模块呢？ <br><br> 当然可以将它们添加到<code>AppModule</code> 。 但这意味着这些模块将以“贪婪”模式加载。 这不是一个好主意。 此外，该项目的组装将失败，并显示以下消息： <br><br><pre> <code class="javascript hljs">ERROR <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> src/app/quiz-card/quiz-card.component.html:<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> - error TS<span class="hljs-number"><span class="hljs-number">-998001</span></span>: <span class="hljs-string"><span class="hljs-string">'mat-card'</span></span> is not a known element: <span class="hljs-number"><span class="hljs-number">1.</span></span> If <span class="hljs-string"><span class="hljs-string">'mat-card'</span></span> is an Angular component, then verify that it is part <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>. <span class="hljs-number"><span class="hljs-number">2.</span></span> If <span class="hljs-string"><span class="hljs-string">'mat-card'</span></span> is a Web Component then add <span class="hljs-string"><span class="hljs-string">'CUSTOM_ELEMENTS_SCHEMA'</span></span> to the <span class="hljs-string"><span class="hljs-string">'@NgModule.schemas'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> component to suppress <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> message.</code> </pre> <br> 怎么办 如您可能已经了解的，此问题是完全可以解决的。 这可以使用模块来完成。 <br><br> 但是这次我们将使用它们与以前有所不同。 我们将在与<code>QuizCardComponent</code>相同的文件中添加一个小模块（在<code>quizcard.component.ts</code>文件中）： <br><br><pre> <code class="javascript hljs">@NgModule({  <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [QuizCardComponent],  <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, MatCardModule, MatButtonModule] }) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuizCardModule</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br> 请注意，没有<code>export</code>声明。 <br><br> 该模块规范仅属于我们的组件，以延迟模式加载。 结果，模块中唯一声明的组件将是<code>QuizCardComponent</code> 。  <code>import</code>部分仅导入我们组件所需的模块。 <br><br> 我们不会导出新模块，因此以贪婪模式加载的模块无法导入它。 <br><br> 重新启动该应用程序，并查看其在单击“ <code> Start quiz</code>时的行为。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc5/4bf/c60/bc54bfc6057cc6707e4f01a5bf871de9.png"></div><br>  <i><font color="#999999">修改的应用程序分析</font></i> <br><br> 太好了！  <code>QuizCardComponent</code>组件以惰性模式加载，并添加到<code>ViewContainer</code> 。 所有必需的依赖项都随它一起加载。 <br><br> 我们将使用相应的npm模块提供的<code>webpack-bundle-analyze</code>工具来分析应用程序包。 它使您可以可视化Webpack生成的文件的内容并检查生成的方案。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2a/a5a/2aa/d2aa5a2aae380755aca3872db6d068f9.png"></div><br>  <i><font color="#999999">应用程序包分析</font></i> <br><br> 该应用程序的主包大小约为260 Kb。 如果我们将<code>QuizCardComponent</code>组件与它一起下载，那么下载数据的大小将约为270 Kb。 事实证明，我们能够将主捆绑包的大小减少10 Kb，在惰性模式下仅加载一个组件。 好结果！ <br><br>  <code>QuizCardComponent</code>后的<code>QuizCardComponent</code>代码进入一个单独的文件。 如果您分析此文件的内容，结果表明不仅存在<code>QuizCardComponent</code>代码，而且此组件中还使用了Material模块。 <br><br> 即使<code>QuizCardComponent</code>使用<code>MatButtonModule</code>和<code>MatCardModule</code> ，也只有<code>MatCardModule</code>进入完成的代码<code>MatCardModule</code> 。 原因是我们也使用<code>MatButtonModule</code>中的<code>AppModule</code> ，显示“ <code>Start quiz</code>按钮。 结果，相应的代码落入捆绑包的另一个片段中。 <br><br> 现在，我们组织了<code>QuizCardComponent</code>的延迟加载。 该组件显示以材料风格设计的卡片，其中包含图片，问题和带有答案选项的按钮。 如果您单击其中一个按钮，现在会发生什么？ <br><br> 按下该按钮时，该按钮将变为绿色或红色，具体取决于其答案是对还是错。 还有什么事吗？ 没事 而且我们需要在回答一个问题之后，显示另一个问题的卡片。 修复它。 <br><br><h2>  <font color="#3AC1EF">事件处理</font> </h2><br> 当您单击“答案”按钮时，该应用程序不会显示新的问题卡，原因是我们尚未设置机制来响应以惰性模式加载的组件的事件。 我们已经知道<code>QuizCardComponent</code>组件使用<code>EventEmitter</code>生成事件。 如果查看<code>EventEmitter</code>类的定义，您会发现它是<code>Subject</code>的后代： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> declare <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br> 这意味着<code>EventEmitter</code>有一个<code>EventEmitter</code>方法，它允许您配置系统对发生的事件的响应： <br><br><pre> <code class="javascript hljs">instance.questionAnswered.pipe(    takeUntil(instance.destroy$) ).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showNewQuestion());</code> </pre> <br> 在这里，我们订阅<code>questionAnswered</code>流，并调用<code>showNextQuestion</code>方法，该方法执行<code>lazyLoadQuizCard</code>逻辑： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> showNewQuestion() {  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lazyLoadQuizCard(); }</code> </pre> <br> 需要<code>takeUntil(instance.destroy$)</code>构造来清除在销毁组件之后执行的预订。 如果<code>ngOnDestroy</code>了<code>ngOnDestroy</code>组件生命周期的<code>ngOnDestroy</code>挂钩，则使用<code>next</code>和<code>complete</code>调用<code>destroy$</code> 。 <br><br> 由于该组件已经加载，因此系统不会执行其他HTTP请求。 我们使用已经拥有的代码片段的内容，创建一个新组件并将其放入容器中。 <br><br><h2>  <font color="#3AC1EF">组件生命周期挂钩</font> </h2><br> 使用延迟加载技术处理<code>QuizCardComponent</code>组件时，几乎所有组件生命周期挂钩都会自动调用。 但是一个钩子还不够。 能听懂哪一个吗？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ceb/4f7/b2a/ceb4f7b2a34bbed6ced31f69713e4f68.png"></div><br>  <i><font color="#999999">组件生命周期挂钩</font></i> <br><br> 这是<code>ngOnChanges</code>最重要的钩子。 由于我们自己更新了组件实例的输入属性，因此我们还负责调用<code>ngOnChanges</code>生命周期挂钩。 <br><br> 要调用<code>ngOnChanges</code>实例的<code>ngOnChanges</code>挂钩，您需要自己构造一个<code>SimpleChange</code>对象： <br><br><pre> <code class="javascript hljs">(instance <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).ngOnChanges({    <span class="hljs-attr"><span class="hljs-attr">question</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleChange(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, instance.question, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) });</code> </pre> <br> 我们手动调用<code>ngOnChanges</code>组件实例，并将其传递给<code>SimpleChange</code>对象。 该对象指示此更改为第一个更改，先前的值为<code>null</code> ，并且当前值为一个问题。 <br><br> 太好了！ 我们使用第三方模块加载了组件，响应了它生成的事件，并设置了组件生命周期的必要挂钩的调用。 <br><br>  <a href="https://github.com/kreuzerk/city-quiz">这是</a>我们在这里完成的项目<a href="https://github.com/kreuzerk/city-quiz">的</a>源代码。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 惰性组件加载为Angular开发人员提供了优化应用程序性能的绝佳机会。 他可以使用的工具可以非常微调以惰性模式加载的材料的成分。 以前，当可以仅以惰性模式加载路由时，我们没有这种准确性。 <br><br> 不幸的是，在组件中使用第三方模块时，我们还需要照顾好这些模块。 但是，值得记住的是，将来这可能会改变。 <br><br> 常春藤引擎引入了局部性的概念，这归功于组件可以独立存在。 这种变化是Angular未来的基础。 <br><br>  <b>亲爱的读者们！</b> 您打算在Angular项目中使用惰性组件加载技术吗？ <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484618/">https://habr.com/ru/post/zh-CN484618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484604/index.html">新年，新浏览器：Microsoft Edge超出初步评估，现在可以下载</a></li>
<li><a href="../zh-CN484610/index.html">再见干净的代码</a></li>
<li><a href="../zh-CN484612/index.html">项目构建时间优化</a></li>
<li><a href="../zh-CN484614/index.html">开发安全Go应用程序的6条建议</a></li>
<li><a href="../zh-CN484616/index.html">从Node.js服务性能优化经验中学到的6课</a></li>
<li><a href="../zh-CN484620/index.html">适用于Omega Red Emulator的新PS1图形渲染器</a></li>
<li><a href="../zh-CN484624/index.html">间隔禁食和Lifext寿命延长模式</a></li>
<li><a href="../zh-CN484628/index.html">埃里克·西亚拉梅拉（Eric Ciaramella）作为Wikipedia / Google上审查制度的一个例子</a></li>
<li><a href="../zh-CN484630/index.html">2020年CES：出乎意料的时间</a></li>
<li><a href="../zh-CN484634/index.html">Node.js VS Python：哪个更好？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>