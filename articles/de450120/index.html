<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏽 👋🏿 🥣 Suchen Sie nach ähnlichen Bildern und analysieren Sie einen einzelnen Algorithmus 🤶🏽 👨🏾 ↖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich musste kürzlich das Problem der Optimierung der Suche nach doppelten Bildern lösen. 

 Die vorhandene Lösung läuft auf einer ziemlich bekannten Py...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suchen Sie nach ähnlichen Bildern und analysieren Sie einen einzelnen Algorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/450120/"><img src="https://habrastorage.org/webt/ev/fs/n_/evfsn_lnmvjxrekwbkumg6b4l1a.jpeg"><br><br>  Ich musste kürzlich das Problem der Optimierung der Suche nach doppelten Bildern lösen. <br><br>  Die vorhandene Lösung läuft auf einer ziemlich bekannten Python-Bibliothek, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Image Match</a> , basierend auf einer Bildsignatur für jede Art von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bild</a> , verfasst von H. Chi Wong, Marshall Bern und David Goldberg. <br><br>  Aus mehreren Gründen wurde beschlossen, alles in Kotlin umzuschreiben und gleichzeitig den Speicher und die Suche in ElasticSearch aufzugeben, was erheblich mehr eiserne und menschliche Ressourcen für die Unterstützung und Verwaltung erfordert, um im lokalen In-Memory-Cache zu suchen. <br><br>  Um zu verstehen, wie es funktioniert, musste ich mich in den Python-Referenzcode eintauchen, da die ursprüngliche Arbeit manchmal nicht ganz offensichtlich ist und ich mich an einigen Stellen daran erinnere, wie man eine Eule zeichnet.  Eigentlich möchte ich die Ergebnisse dieser Studie teilen und gleichzeitig einige Optimierungen in Bezug auf Datenvolumen und Suchgeschwindigkeit erläutern.  Vielleicht wird jemand nützlich sein. <br><a name="habracut"></a><br>  Haftungsausschluss: Es besteht die Möglichkeit, dass ich irgendwo etwas durcheinander gebracht habe, es falsch gemacht habe oder nicht optimal.  Nun, ich freue mich über Kritik und Kommentare.  :) :) <br><br>  Wie funktioniert es: <br><br><ol><li>  Das Bild wird in das 8-Bit-Schwarzweißformat konvertiert (ein Punkt ist ein Byte im Wert 0-255). </li><li>  Das Bild wird so beschnitten, dass 5% der akkumulierten Differenz (weiter unten) von jeder der vier Seiten verworfen werden.  Zum Beispiel ein schwarzer Rahmen um das Bild. </li><li>  Es wird ein Arbeitsraster ausgewählt (standardmäßig 9 x 9), dessen Knoten als Referenzpunkte für die Bildsignatur dienen. </li><li>  Für jeden Referenzpunkt wird anhand eines bestimmten Bereichs um ihn herum seine Helligkeit berechnet. </li><li>  Für jeden Referenzpunkt wird berechnet, um wie viel er heller / dunkler als seine acht Nachbarn ist.  Es werden fünf Abstufungen verwendet, von -2 (viel dunkler) bis 2 (viel heller). </li><li>  All diese „Freude“ entfaltet sich in einem eindimensionalen Array (Vektor) und wird durch die Bildsignatur aufgerufen. </li></ol><br>  Die Ähnlichkeit der beiden Bilder wird wie folgt überprüft: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cl/yh/m8/clyhm8caq35-td519odrgd95msq.png"></div><br><br>  Je niedriger das d, desto besser.  Tatsächlich ist d &lt;0,3 fast eine Identitätsgarantie. <br><br>  Jetzt genauer. <br><br><h3>  Erster Schritt </h3><br>  Ich denke, dass es wenig Sinn macht, über die Konvertierung in Graustufen zu sprechen. <br><br><h3>  Zweiter Schritt </h3><br>  Nehmen wir an, wir haben ein Bild wie dieses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/fg/m_/ihfgm_-xiyuerpbpntgakzby9ge.png"></div><br>  <i>Es ist zu sehen, dass es rechts und links einen schwarzen Rahmen von 3 Pixeln und oben und unten 2 Pixel gibt, den wir im Vergleich überhaupt nicht brauchen</i> <br><br>  Die Grenzgrenze wird durch den folgenden Algorithmus bestimmt: <br><br><ol><li>  Für jede Spalte berechnen wir die Summe der absoluten Differenzen benachbarter Elemente. <br></li><li>  Wir beschneiden links und rechts die Anzahl der Pixel, deren Beitrag zur kumulierten Gesamtdifferenz weniger als 5% beträgt. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ly/xz/cx/lyxzcxnjphjgjtrwyg0val2iix8.png"></div><br>  Wir machen das gleiche für Spalten. <br><br>  Eine wichtige Klarstellung: Wenn die Abmessungen des resultierenden Bildes für Schritt 4 nicht ausreichen, beschneiden wir nicht! <br><br><h3>  Schritt drei </h3><br>  Nun, hier ist alles ganz einfach, wir teilen das Bild in gleiche Teile und wählen die Knotenpunkte aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/67/kh/-n/67kh-n0mxhjpupyqlqo4rjy7-zk.jpeg"></div><br><h3>  Vierter Schritt </h3><br>  Die Helligkeit des Ankerpunkts wird als durchschnittliche Helligkeit aller Punkte im quadratischen Bereich um ihn herum berechnet.  In der Originalarbeit wird die folgende Formel verwendet, um die Seiten dieses Quadrats zu berechnen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kb/qp/1z/kbqp1zaxngtsxy87lsftecyik5e.png"></div><br><h3>  Fünfter Schritt </h3><br>  Für jeden Referenzpunkt wird der Unterschied in seiner Helligkeit mit der Helligkeit seiner acht Nachbarn berechnet.  Für die Punkte, für die es keine Nachbarn gibt (obere und untere Reihe, linke und rechte Spalte), wird die Differenz als 0 angenommen. <br><br>  Ferner werden diese Unterschiede auf fünf Abstufungen reduziert: <br><br><div class="scrollable-table"><table><tbody><tr><th>  xy </th><th>  Wert </th><th>  Beschreibung </th></tr><tr><td>  -2..2 </td><td>  0 </td><td>  Identisch </td></tr><tr><td>  -50 ..- 3 </td><td>  -1 </td><td>  Dunkler </td></tr><tr><td>  &lt;-50 </td><td>  -2 </td><td>  Viel dunkler </td></tr><tr><td>  3..50 </td><td>  1 </td><td>  Heller </td></tr><tr><td>  &gt; 50 </td><td>  2 </td><td>  Viel heller </td></tr></tbody></table></div><br>  Es stellt sich so etwas wie diese Matrix heraus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/90/2m/_r902m_saq21syujszytqxyy8dk.png"></div><br><h3>  Sechster Schritt </h3><br>  Ich denke, es ist keine Erklärung erforderlich. <br><br><h3>  Und jetzt zur Optimierung </h3><br>  In der Originalarbeit wird zu Recht darauf hingewiesen, dass aus der resultierenden Signatur Nullwerte entlang der Kanten der Matrix vollständig gelöscht werden können, da sie für alle Bilder identisch sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rv/ii/rc/rviircvrfaq65_vrauwnu8kklgq.png"></div><br>  Wenn Sie jedoch genau hinschauen, können Sie feststellen, dass für zwei Nachbarn die gegenseitigen Abstufungen im absoluten Wert gleich sind.  Daher können Sie für jeden Referenzpunkt sicher vier doppelte Werte ausgeben, wodurch die Größe der Signatur um die Hälfte reduziert wird (ohne seitliche Nullen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/de/mb/dc/dembdcwlshe2rflj1_3wacthxmk.png"></div><br>  Offensichtlich gibt es bei der Berechnung der Quadratsumme für jedes <b>x</b> definitiv ein gleiches Modulo <b>x ',</b> und die Formel zur Berechnung der Norm kann ungefähr so ​​geschrieben werden (ohne sich mit der Neuindizierung zu befassen): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/c0/t1/nxc0t10_wggho3gyao9gx8cvan8.png"></div><br>  Dies gilt sowohl für den Zähler als auch für beide Terme des Nenners. <br><br>  Weiter in der ursprünglichen Arbeit wird angemerkt, dass drei Bits ausreichen, um jede Abstufung zu speichern.  Das heißt, im Unsigned Long passen 21 Abstufungen.  Dies ist eine ziemlich große Größenersparnis, erhöht jedoch die Komplexität bei der Berechnung der Summe der Quadrate der Differenz zwischen den beiden Signaturen.  Ich muss sagen, dass mich diese Idee sehr gefesselt hat und sie einige Tage lang nicht losgelassen hat, bis eines Abends klar wurde, wie man <s>einen Fisch isst</s> , ein Ort, an dem man die Berechnung speichern und vereinfachen kann.  Pass auf deine Hände auf. <br><br>  Wir verwenden ein solches Schema für die Speicherung, 4 Bits pro Abstufung: <br><div class="scrollable-table"><table><tbody><tr><th>  Abschluss </th><th>  Speichern als </th></tr><tr><td>  -2 </td><td>  0b1100 </td></tr><tr><td>  -1 </td><td>  0b0100 </td></tr><tr><td>  0 </td><td>  0b0000 </td></tr><tr><td>  1 </td><td>  0b0010 </td></tr><tr><td>  2 </td><td>  0b0011 </td></tr></tbody></table></div><br>  Ja, nur 16 Abstufungen passen in eine vorzeichenlose Länge gegen 21, aber dann wird das Array der Differenz der beiden Signaturen mit einem x oder 15 Verschiebungen nach rechts berechnet, wobei die Anzahl der für jede Iteration der Verschiebung festgelegten Bits berechnet wird.  Das heißt, <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i5/mt/tc/i5mttccaofi_snscaq_lrvecucc.png"></div><br>  <i>Das Vorzeichen spielt für uns keine Rolle, da alle Werte quadriert werden.</i> <br><br>  Wenn der Schwellenwert der Entfernung im Voraus bestimmt wird, dessen Werte für uns nicht mehr interessant sind, können Sie nach einigem Herumtanzen der Berechnungsformel eine ziemlich leichte Filterbedingung für eine einfache Anzahl von gesetzten Bits ableiten. <br><br>  Weitere Details zur Optimierung dieses Algorithmus mit Codebeispielen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> .  Ich empfehle separat, Kommentare dazu zu lesen - der in Chabrowsk ansässige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Masyaman</a> schlug einige ziemlich interessante Methoden zur Berechnung vor, einschließlich Packungsabstufungen in drei Bits mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Bitmagie</a> . <br><br>  Eigentlich ist das alles.  Vielen Dank für Ihre Aufmerksamkeit.  :) :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450120/">https://habr.com/ru/post/de450120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450110/index.html">Geschmacksmuster: Teil zwei (Beispiele von Microsoft, Snapchat, Samsung, Netflix, Airbnb, Tinder)</a></li>
<li><a href="../de450112/index.html">Eh, was ist mit den Koffern passiert ?! Am Beispiel eines Kinderkofferscooters ZINC</a></li>
<li><a href="../de450114/index.html">Über das, was wir dank Ihres Ratschlags in EWM implementiert haben</a></li>
<li><a href="../de450116/index.html">Betriebssysteme: Drei einfache Teile. Teil 5: Planung: Mehrstufige Feedback-Warteschlange (Übersetzung)</a></li>
<li><a href="../de450118/index.html">Streamen Sie den Bildschirm über das Netzwerk auf mehrere Geräte</a></li>
<li><a href="../de450122/index.html">Startup Digest: Genetics (Januar - März 2019)</a></li>
<li><a href="../de450124/index.html">Konfigurieren von OsmAnd-Karten der Strava-Heatmap-Ebene</a></li>
<li><a href="../de450126/index.html">Die Hintertür und der Buhtrap-Verschlüsseler wurden mit Yandex.Direct verteilt</a></li>
<li><a href="../de450128/index.html">Verwendung der Minolta AF-Optik (Sony A-Mount) bei modernen spiegellosen Kameras von Sony</a></li>
<li><a href="../de450130/index.html">Überleben Teams nach dem Hackathon?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>