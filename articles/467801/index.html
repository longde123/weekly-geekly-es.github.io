<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí® ‚òÄÔ∏è ü§µüèæ Automatizaci√≥n para los m√°s peque√±os. Parte 1.1. Conceptos b√°sicos de virtualizaci√≥n üòó üõåüèæ üöú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El art√≠culo anterior analiz√≥ la arquitectura de una red virtualizada, la superposici√≥n subyacente, la ruta del paquete entre m√°quinas virtuales y m√°s....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatizaci√≥n para los m√°s peque√±os. Parte 1.1. Conceptos b√°sicos de virtualizaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467801/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El art√≠culo anterior</a> analiz√≥ la arquitectura de una red virtualizada, la superposici√≥n subyacente, la ruta del paquete entre m√°quinas virtuales y m√°s. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Roman Gorge se</a> inspir√≥ en ella y decidi√≥ escribir un art√≠culo de revisi√≥n sobre la virtualizaci√≥n en general. <br><br>  En este art√≠culo, abordaremos (o trataremos de tocar) las preguntas: c√≥mo se produce realmente la virtualizaci√≥n de las funciones de red, c√≥mo se implementa el back-end de los principales productos para lanzar y administrar m√°quinas virtuales, y c√≥mo funciona la conmutaci√≥n virtual (OVS y el puente de Linux). <br><br>  El tema de la virtualizaci√≥n es amplio y profundo, es imposible explicar todos los detalles del trabajo del hipervisor (y no es necesario).  Nos limitaremos al conjunto m√≠nimo de conocimientos necesarios para comprender el funcionamiento de cualquier soluci√≥n virtualizada, no necesariamente Telco. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6a7/8ec/aa6/6a78ecaa6f26c867f0a37f010511ef7a.png" width="800"></a> <br><br><h1>  Contenido </h1><br><ul><li>  <b>Introducci√≥n y una breve historia de la virtualizaci√≥n.</b> </li><li>  <b>Tipos de recursos virtuales: computaci√≥n, almacenamiento, red</b> </li><li>  <b>Conmutaci√≥n virtual</b> </li><li>  <b>Herramientas de virtualizaci√≥n: libvirt, virsh y m√°s</b> </li><li>  <b>Conclusi√≥n</b> </li></ul><br><hr><br><br><a name="habracut"></a><br><br><h1>  Introducci√≥n y una breve historia de la virtualizaci√≥n. </h1><br><br>  La historia de las tecnolog√≠as modernas de virtualizaci√≥n se remonta a 1999, cuando la joven empresa VMware lanz√≥ un producto llamado VMware Workstation.  Este era un producto de virtualizaci√≥n para aplicaciones de escritorio / cliente.  La virtualizaci√≥n del lado del servidor lleg√≥ un poco m√°s tarde en la forma del producto ESX Server, que luego evolucion√≥ a ESXi (es decir, integrado): este es el mismo producto que se usa universalmente en TI y Telco como hipervisor de aplicaciones de servidor. <br><br>  En el lado de Opensource, dos proyectos importantes han tra√≠do la virtualizaci√≥n a Linux: <br><ul><li>  KVM (m√°quina virtual basada en kernel) es un m√≥dulo de kernel de Linux que permite que el kernel funcione como un hipervisor (crea la infraestructura necesaria para iniciar y administrar m√°quinas virtuales).  Fue agregado en la versi√≥n del kernel 2.6.20 en 2007. </li><li>  QEMU (emulador r√°pido): emula directamente el hardware de una m√°quina virtual (CPU, disco, RAM, cualquier cosa, incluido un puerto USB) y se utiliza junto con KVM para lograr un rendimiento casi "nativo". </li></ul><br><br><blockquote>  De hecho, en este momento, toda la funcionalidad de KVM est√° disponible en QEMU, pero esto no es importante, ya que la mayor√≠a de los usuarios de virtualizaci√≥n de Linux no usan directamente KVM / QEMU, sino que acceden a ellos a trav√©s de al menos un nivel de abstracci√≥n, pero m√°s sobre eso m√°s adelante. <br></blockquote><br><br>  Hoy, VMware ESXi y Linux QEMU / KVM son los dos hipervisores principales que dominan el mercado.  Tambi√©n son representantes de dos tipos diferentes de hipervisores: <br><ul><li>  Tipo 1: el hipervisor se ejecuta directamente en el hardware (bare-metal).  Esto es VMware ESXi, Linux KVM, Hyper-V </li><li>  Tipo 2: el hipervisor se inicia dentro del sistema operativo host (sistema operativo).  Esta es VMware Workstation u Oracle VirtualBox. </li></ul><br><br>  Una discusi√≥n sobre qu√© es mejor y qu√© es peor est√° m√°s all√° del alcance de este art√≠culo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/dfe/fa6/d74dfefa6a9c07a43bca6f4a07db1a3d.gif" width="600"><br><br>  Los productores de hierro tambi√©n tuvieron que hacer su parte para garantizar un rendimiento aceptable. <br><br>  Quiz√°s el m√°s importante y el m√°s utilizado es Intel VT (Tecnolog√≠a de virtualizaci√≥n), un conjunto de extensiones desarrolladas por Intel para sus procesadores x86 que se utilizan para el funcionamiento efectivo del hipervisor (y en algunos casos son necesarios, por ejemplo, KVM no funcionar√° sin VT activado) -x y sin √©l, el hipervisor se ve obligado a realizar una emulaci√≥n puramente de software, sin aceleraci√≥n de hardware). <br>  Dos de estas extensiones son m√°s conocidas: VT-x y VT-d.  El primero es importante para mejorar el rendimiento de la CPU durante la virtualizaci√≥n, ya que proporciona soporte de hardware para algunas de sus funciones (con el c√≥digo VT-x 99.9% Guest OS se ejecuta directamente en el procesador f√≠sico, haciendo salidas para la emulaci√≥n solo en los casos m√°s necesarios), el segundo es para conectar dispositivos f√≠sicos directamente a una m√°quina virtual (para funciones virtuales de reenv√≠o (VF) SRIOV, por ejemplo, VT-d <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">debe estar habilitado</a> ). <br><br>  El siguiente concepto importante es la diferencia entre virtualizaci√≥n completa y para-virtualizaci√≥n. <br>  La virtualizaci√≥n completa es buena, le permite ejecutar cualquier sistema operativo en cualquier procesador, sin embargo, es extremadamente ineficiente y absolutamente no es adecuado para sistemas altamente cargados. <br>  Paravirtualizaci√≥n, en resumen, es cuando Guest OS entiende que se est√° ejecutando en un entorno virtual y coopera con el hipervisor para lograr una mayor eficiencia.  Es decir, aparece la interfaz del hipervisor invitado. <br>  La gran mayor√≠a de los sistemas operativos utilizados hoy en d√≠a tienen soporte para para-virtualizaci√≥n; en el kernel de Linux, esto ha aparecido desde la versi√≥n 2.6.20 del kernel. <br><br>  Para que una m√°quina virtual funcione, no solo se necesitan un procesador virtual (vCPU) y una memoria virtual (RAM); tambi√©n se requiere la emulaci√≥n de dispositivos PCI.  Es decir, de hecho, se requiere un conjunto de controladores para administrar interfaces de red virtual, discos, etc. <br>  En el hipervisor KVM de Linux, esta tarea se resolvi√≥ implementando <b>virtio</b> , un marco para desarrollar y usar dispositivos de E / S virtualizados. <br>  Virtio es un nivel adicional de abstracci√≥n, que le permite emular varios dispositivos de E / S en un hipervisor para-virtualizado, proporcionando una interfaz unificada y estandarizada al lado de la m√°quina virtual.  Esto le permite reutilizar el c√≥digo del controlador virtio para varios dispositivos inherentes.  Virtio consiste en: <br><ul><li>  Controlador de front-end: qu√© hay en la m√°quina virtual </li><li>  Controlador de fondo: qu√© hay en el hipervisor </li><li>  Conductor de transporte: lo que conecta el backend y la interfaz </li></ul><br>  Esta modularidad le permite cambiar las tecnolog√≠as utilizadas en el hipervisor sin afectar los controladores en la m√°quina virtual (este punto es muy importante para las tecnolog√≠as de aceleraci√≥n de red y las soluciones de nube en general, pero m√°s sobre eso m√°s adelante). <br>  Es decir, hay una conexi√≥n de hipervisor invitado cuando el SO hu√©sped "sabe" que se est√° ejecutando en un entorno virtual. <br><blockquote>  Si alguna vez escribi√≥ una pregunta en RFP o respondi√≥ una pregunta en RFP "¬øSe admite virtio en su producto?"  Se trataba solo de soportar el controlador virtio front-end. <br></blockquote><br><br><h1>  Tipos de recursos virtuales: computaci√≥n, almacenamiento, red </h1><br>  ¬øEn qu√© consiste una m√°quina virtual? <br>  Hay tres tipos principales de recursos virtuales: <br><br><ul><li>  calcular - procesador y RAM </li><li>  almacenamiento: disco del sistema de m√°quina virtual y almacenamiento en bloque </li><li>  red - tarjetas de red y dispositivos de entrada / salida </li></ul><br><br><hr><br><br><h1>  Calcular </h1><br><br><h2>  CPU </h2><br>  Te√≥ricamente, QEMU es capaz de emular cualquier tipo de procesador y sus correspondientes banderas y funcionalidades; en la pr√°ctica, usan el modelo host y apagan las banderas de forma puntual antes de transferirlas al sistema operativo invitado, o toman el modelo con nombre y activan / desactivan las banderas de manera puntual. <br><br>  De forma predeterminada, QEMU emular√° un procesador que el SO hu√©sped reconocer√° como CPU virtual QEMU.  Este no es el tipo de procesador m√°s √≥ptimo, especialmente si una aplicaci√≥n que se ejecuta en una m√°quina virtual utiliza indicadores de CPU para su trabajo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Obtenga m√°s informaci√≥n sobre los diferentes modelos de CPU en QEMU</a> . <br><br>  QEMU / KVM tambi√©n le permite controlar la topolog√≠a del procesador, la cantidad de subprocesos, el tama√±o de la memoria cach√©, vincular vCPU al n√∫cleo f√≠sico y mucho m√°s. <br><br>  Si esto es necesario para una m√°quina virtual o no, depende del tipo de aplicaci√≥n que se ejecute en el SO invitado.  Por ejemplo, es un hecho bien conocido que para las aplicaciones que procesan paquetes con un alto PPS, es importante hacer <b>la fijaci√≥n de la CPU</b> , es decir, no permitir que el procesador f√≠sico se transfiera a otras m√°quinas virtuales. <br><br><h2>  Memoria </h2><br>  El siguiente en la l√≠nea es la RAM.  Desde el punto de vista de Host OS, una m√°quina virtual lanzada usando QEMU / KVM no es diferente de cualquier otro proceso que se ejecute en el espacio de usuario del sistema operativo.  En consecuencia, el proceso de asignaci√≥n de memoria a una m√°quina virtual se realiza mediante las mismas llamadas en el sistema operativo host del n√∫cleo, como si se iniciara, por ejemplo, un navegador Chrome. <br><br><blockquote>  Antes de continuar con la historia de RAM en m√°quinas virtuales, debe desviarse y explicar el t√©rmino <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NUMA</a></b> - Acceso no uniforme a la memoria. <br>  La arquitectura de los servidores f√≠sicos modernos implica la presencia de dos o m√°s procesadores (CPU) y est√° asociada con la memoria de acceso aleatorio (RAM).  Tal grupo de procesador + memoria se llama nodo o nodo.  La comunicaci√≥n entre varios nodos NUMA se realiza a trav√©s de un bus especial: <b>QPI</b> (QuickPath Interconnect) <br><br>  El nodo NUMA local se asigna: cuando el proceso que se ejecuta en el sistema operativo usa el procesador y la RAM ubicados en el mismo nodo NUMA, y el nodo NUMA remoto, cuando el proceso que se ejecuta en el sistema operativo usa el procesador y la RAM ubicados en diferentes nodos NUMA, es decir, para la interacci√≥n del procesador y la memoria, se requiere la transferencia de datos a trav√©s del bus QPI. <br></blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea3/360/7e9/ea33607e91282db8bda346d7f63cf9fd.png" width="600"><br><br>  Desde el punto de vista de la m√°quina virtual, la memoria ya estaba asignada al momento de su lanzamiento, pero en realidad no es as√≠, y el sistema operativo host del n√∫cleo asigna nuevas secciones de memoria al proceso QEMU / KVM ya que la aplicaci√≥n en el sistema operativo invitado solicita memoria adicional (aunque tambi√©n puede haber una excepci√≥n si especifica directamente QEMU / KVM para asignar toda la memoria a la m√°quina virtual directamente al inicio). <br><br>  La memoria se asigna no byte a byte, sino por un tama√±o determinado de <b>p√°gina</b> .  El tama√±o de la p√°gina es configurable y, en teor√≠a, puede ser cualquiera, pero en la pr√°ctica el tama√±o es de 4 KB (predeterminado), 2 MB y 1 GB.  Los dos √∫ltimos tama√±os se denominan <b>HugePages</b> y a menudo se utilizan para asignar memoria para m√°quinas virtuales con uso intensivo de memoria.  La raz√≥n para usar HugePages en el proceso de encontrar una coincidencia entre la direcci√≥n virtual de la p√°gina y la memoria f√≠sica en <b>Translation Lookaside Buffer</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TLB</a></b> ), que a su vez es limitada y almacena informaci√≥n solo sobre las √∫ltimas p√°ginas utilizadas.  Si no hay informaci√≥n sobre la p√°gina deseada en el TLB, se produce un proceso llamado <b>miss TLB</b> , y debe utilizar el procesador Host OS para encontrar la celda de memoria f√≠sica correspondiente a la p√°gina deseada. <br><br>  Este proceso es ineficiente y lento, por lo que se utilizan menos p√°ginas de mayor tama√±o. <br>  QEMU / KVM tambi√©n le permite emular varias topolog√≠as NUMA para SO invitado, tomar memoria para una m√°quina virtual solo desde un SO host de nodo NUMA espec√≠fico, y as√≠ sucesivamente.  La pr√°ctica m√°s com√∫n es tomar memoria para una m√°quina virtual desde un nodo NUMA local a los procesadores asignados a la m√°quina virtual.  La raz√≥n es el deseo de evitar cargas innecesarias en el bus <b>QPI</b> que conecta los z√≥calos de la CPU del servidor f√≠sico (por supuesto, esto es l√≥gico si su servidor tiene 2 o m√°s z√≥calos). <br><br><hr><br><br><h1>  Almacenamiento </h1><br>  Como sabe, la RAM se llama memoria operativa porque su contenido desaparece cuando se apaga o se reinicia el sistema operativo.  Para almacenar informaci√≥n, necesita un dispositivo de almacenamiento persistente (ROM) o <b>almacenamiento persistente</b> . <br>  Hay dos tipos principales de almacenamiento persistente: <br><ul><li>  Almacenamiento en bloque: un bloque de espacio en disco que se puede utilizar para instalar el sistema de archivos y crear particiones.  Si es grosero, puede tomarlo como un disco normal. </li><li>  Almacenamiento de objetos: la informaci√≥n solo se puede guardar como un objeto (archivo), accesible a trav√©s de HTTP / HTTPS.  Ejemplos t√≠picos de almacenamiento de objetos son AWS S3 o Dropbox. </li></ul><br><br>  La m√°quina virtual necesita <b>almacenamiento persistente</b> , sin embargo, ¬øc√≥mo hacer esto si la m√°quina virtual "vive" en la RAM del sistema operativo host?  En resumen, cualquier llamada del SO invitado al controlador de disco virtual es interceptada por QEMU / KVM y se transforma en un registro en el disco f√≠sico del SO host.  Este m√©todo es ineficiente y, por lo tanto, aqu√≠, as√≠ como para dispositivos de red, se usa el controlador virtio en lugar de emular completamente un dispositivo IDE o iSCSI.  Lea m√°s sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Por lo tanto, la m√°quina virtual accede a su disco virtual a trav√©s de un controlador virtio, y luego QEMU / KVM hace que la informaci√≥n transferida se escriba en el disco f√≠sico.  Es importante comprender que en el sistema operativo host, un backend de disco se puede implementar como un estante CEPH, NFS o iSCSI. <br><br>  La forma m√°s f√°cil de emular el almacenamiento persistente es usar el archivo en alg√∫n directorio del sistema operativo host como el espacio en disco de una m√°quina virtual.  QEMU / KVM admite muchos formatos diferentes de este tipo de archivo: raw, vdi, vmdk y otros.  Sin embargo, el formato m√°s utilizado es <b>qcow2</b> (QEMU copy-on-write versi√≥n 2).  En general, qcow2 es un archivo estructurado de cierta manera sin ning√∫n sistema operativo.  Una gran cantidad de m√°quinas virtuales se distribuyen en forma de im√°genes qcow2 (im√°genes) y son una copia del disco del sistema de una m√°quina virtual, empaquetada en formato qcow2.  Esto tiene varias ventajas: la codificaci√≥n qcow2 ocupa mucho menos espacio que una copia sin formato de un disco byte a byte, QEMU / KVM puede cambiar el tama√±o de un archivo qcow2, lo que significa que es posible cambiar el tama√±o del disco de una m√°quina virtual, tambi√©n se admite el cifrado AES qcow2 (Esto tiene sentido, ya que la imagen de una m√°quina virtual puede contener propiedad intelectual). <br><br>  Adem√°s, cuando se inicia la m√°quina virtual, QEMU / KVM utiliza el archivo qcow2 como un disco del sistema (omito el proceso de carga de la m√°quina virtual aqu√≠, aunque tambi√©n es una tarea interesante), y la m√°quina virtual tiene la capacidad de leer / escribir datos en el archivo qcow2 a trav√©s de virtio conductor  Por lo tanto, el proceso de tomar im√°genes de m√°quinas virtuales funciona, ya que en cualquier momento el archivo qcow2 contiene una copia completa del disco del sistema de la m√°quina virtual, y la imagen se puede usar para hacer una copia de seguridad, transferirla a otro host, etc. <br><br>  En general, este archivo qcow2 se definir√° en el SO invitado como un <i>dispositivo / dev / vda</i> , y el SO invitado dividir√° el espacio en disco en particiones e instalar√° el sistema de archivos.  De manera similar, los siguientes archivos qcow2 conectados por QEMU / KVM como dispositivos <i>/ dev / vdX</i> se pueden usar como <b>almacenamiento</b> en <b>bloque</b> en una m√°quina virtual para almacenar informaci√≥n (as√≠ es exactamente como funciona el componente Openstack Cinder). <br><hr><br><br><h1>  Red </h1><br>  Los √∫ltimos en nuestra lista de recursos virtuales son las tarjetas de red y los dispositivos de E / S.  Una m√°quina virtual, como un host f√≠sico, necesita un <b>bus PCI / PCIe</b> para conectar dispositivos de E / S.  QEMU / KVM puede emular diferentes tipos de conjuntos de chips: q35 o i440fx (el primero es compatible con PCIe, el segundo es compatible con PCI heredado), as√≠ como varias topolog√≠as de PCI, por ejemplo, crear buses PCI separados (bus de expansi√≥n PCI) para los nodos NUMA del sistema operativo invitado. <br><br>  Despu√©s de crear el bus PCI / PCIe, debe conectarle un dispositivo de E / S.  En general, puede ser cualquier cosa, desde una tarjeta de red a una GPU f√≠sica.  Y, por supuesto, una tarjeta de red, tanto virtualizada (interfaz virtualizada completamente e1000, por ejemplo) como para-virtualizada (virtio, por ejemplo) o una NIC f√≠sica.  La √∫ltima opci√≥n se usa para m√°quinas virtuales de plano de datos donde necesita obtener velocidades de paquetes de velocidad de l√≠nea: enrutadores, firewalls, etc. <br><br>  Aqu√≠ hay dos enfoques principales: <b>PCI passthrough</b> y <b>SR-IOV</b> .  La principal diferencia entre ellos es que para PCI-PT, el controlador se usa solo dentro del sistema operativo invitado, y para SRIOV, el controlador del sistema operativo host (para crear <b>VF - Funciones virtuales</b> ) y el controlador del sistema operativo invitado se usan para controlar SR-IOV VF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Juniper escribi√≥</a> excelentes detalles sobre PCI-PT y SRIOV. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/380/fb7/ff1380fb7061d5294514b79b4a368cfb.png" width="600"><br><br><blockquote>  Para aclarar, vale la pena se√±alar que el paso de PCI y SR-IOV son tecnolog√≠as complementarias.  SR-IOV est√° dividiendo una funci√≥n f√≠sica en funciones virtuales.  Esto se hace a nivel del sistema operativo host.  Al mismo tiempo, Host OS ve las funciones virtuales como otro dispositivo PCI / PCIe.  Lo que haga despu√©s con ellos no es importante. <br><br>  Y PCI-PT es un mecanismo para reenviar cualquier dispositivo PCI del sistema operativo host en el sistema operativo invitado, incluida la funci√≥n virtual creada por el dispositivo SR-IOV <br></blockquote><br><br>  Por lo tanto, examinamos los principales tipos de recursos virtuales y el siguiente paso es comprender c√≥mo la m√°quina virtual se comunica con el mundo exterior a trav√©s de una red. <br><hr><br><br><h1>  Conmutaci√≥n virtual </h1><br><br>  Si hay una m√°quina virtual y hay una interfaz virtual en ella, entonces, obviamente, surge el problema de transferir un paquete de una VM a otra.  En los hipervisores basados ‚Äã‚Äãen Linux (KVM, por ejemplo), este problema se puede resolver utilizando el puente de Linux, sin embargo, el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Open vSwitch</a> (OVS) ha ganado una amplia aceptaci√≥n. <br>  Existen varias funcionalidades centrales que han permitido que OVS se extienda ampliamente y se convierta en el m√©todo de conmutaci√≥n de paquetes primario de facto utilizado en muchas plataformas de computaci√≥n en la nube (como Openstack) y soluciones virtualizadas. <br><ul><li>  Transferencia de estado de red: al migrar una VM entre hipervisores, surge la tarea de transferir ACL, QoS, tablas de reenv√≠o L2 / L3 y m√°s.  Y OVS puede hacerlo. </li><li>  Implementaci√≥n del mecanismo de transferencia de paquetes (ruta de datos) tanto en el n√∫cleo como en el espacio de usuario </li><li>  Arquitectura CUPS (Control / Separaci√≥n del plano de usuario): le permite transferir la funcionalidad del procesamiento de paquetes a un conjunto de chips especializado (el conjunto de chips Broadcom y Marvell, por ejemplo, puede hacer esto), control√°ndolo a trav√©s del OVS del plano de control. </li><li>  Soporte para m√©todos de control de tr√°fico remoto: protocolo OpenFlow (hola, SDN). </li></ul><br><br>  La arquitectura OVS a primera vista parece bastante aterradora, pero es solo a primera vista. <br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/18f/4fa/e1e18f4fa99d66a99a4da3c06e1df33a.png" width="600"><br><br>  Para trabajar con OVS, debe comprender lo siguiente: <br><ul><li>  <b>Ruta de datos</b> : los paquetes se procesan aqu√≠.  La analog√≠a es la estructura del interruptor de un interruptor de hierro.  Datapath incluye recibir paquetes, procesar encabezados, coincidencias coincidentes en la tabla de flujo, que ya est√° programada en Datapath.  Si OVS se ejecuta en el n√∫cleo, se implementa como un m√≥dulo del n√∫cleo.  Si OVS se ejecuta en espacio de usuario, entonces este es un proceso en Linux de espacio de usuario. </li><li>  <b>vswitchd</b> y <b>ovsdb</b> son demonios en el espacio del usuario, que implementa directamente la funcionalidad del conmutador, almacena la configuraci√≥n, establece el flujo a la ruta de datos y la programa. </li><li>  Un conjunto de herramientas para configurar y solucionar problemas de OVS: <b>ovs-vsctl, ovs-dpctl, ovs-ofctl, ovs-appctl</b> .  Todo lo que se necesita para registrar la configuraci√≥n del puerto en ovsdb, registrar a qu√© flujo se debe cambiar, recopilar estad√≠sticas, etc.  Las buenas personas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escribieron un art√≠culo</a> sobre esto. </li></ul><br><br>  <b>¬øC√≥mo termina el dispositivo de red de una m√°quina virtual en OVS?</b> <br><br>  Para resolver este problema, necesitamos interconectar de alguna manera la interfaz virtual ubicada en el espacio de usuario del sistema operativo con la ruta de datos OVS ubicada en el n√∫cleo. <br><br>  En el sistema operativo Linux, los paquetes se transfieren entre el n√∫cleo y los procesos de espacio de usuario a trav√©s de dos interfaces especiales.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambas interfaces usan escritura / lectura de un paquete a / desde un archivo especial para transferir paquetes del proceso de espacio de usuario al kernel y viceversa - descriptor de archivo (FD) (esta es una de las razones del bajo rendimiento de conmutaci√≥n virtual si datapath OVS est√° en el kernel - cada paquete necesita escribir / leer a trav√©s de FD) </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TUN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (t√∫nel): un dispositivo que funciona en modo L3 y le permite escribir / leer solo paquetes IP a / desde FD.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (red tap): lo mismo que la interfaz tun + puede realizar operaciones con tramas Ethernet, es decir </font><font style="vertical-align: inherit;">trabajar en modo L2.</font></font></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a2/3fc/fc8/5a23fcfc86e0c6cbfdf8dc80cc562bbf.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es por eso que cuando la m√°quina virtual se ejecuta en el sistema operativo host, puede ver las interfaces TAP creadas con el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace ip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o el </font><font style="vertical-align: inherit;">comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ifconfig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esta es la parte de "respuesta" de virtio, que es "visible" en el sistema operativo host del n√∫cleo. </font><font style="vertical-align: inherit;">Tambi√©n vale la pena se√±alar que la interfaz TAP tiene la misma direcci√≥n MAC que la interfaz virtio en la m√°quina virtual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La interfaz TAP se puede agregar a OVS utilizando los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comandos ovs-vsctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; luego, cualquier paquete que OVS cambie a la interfaz TAP se transferir√° a la m√°quina virtual mediante un descriptor de archivo.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El procedimiento real para crear una m√°quina virtual puede ser diferente, es decir. </font><font style="vertical-align: inherit;">Primero, puede crear un puente OVS, luego decirle a la m√°quina virtual que cree una interfaz conectada a este OVS, o viceversa.</font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, si necesitamos poder transferir paquetes entre dos o m√°s m√°quinas virtuales que se ejecutan en el mismo hipervisor, solo necesitamos crear un puente OVS y agregarle interfaces TAP usando los comandos ovs-vsctl. Los equipos que se necesitan para esto se pueden buscar f√°cilmente en Google. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede haber varios puentes OVS en el hipervisor, por ejemplo, as√≠ es como funciona Openstack Neutron, o las m√°quinas virtuales pueden estar en diferentes espacios de nombres para implementar la tenencia m√∫ltiple. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øY si las m√°quinas virtuales est√°n en diferentes puentes OVS?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para resolver este problema, hay otra herramienta: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veth pair</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El par Veth se puede representar como un par de interfaces de red conectadas por un cable: todo lo que "vuela" en una interfaz, "vuela" desde otra. </font><font style="vertical-align: inherit;">El par Veth se utiliza para conectar varios puentes OVS o puentes Linux entre s√≠. </font><font style="vertical-align: inherit;">Otro punto importante es que partes del par veth pueden estar en un sistema operativo Linux de espacio de nombres diferente, es decir, el par veth tambi√©n se puede usar para comunicar el espacio de nombres entre s√≠ a nivel de red.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Herramientas de virtualizaci√≥n: libvirt, virsh y m√°s </font></font></h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En los cap√≠tulos anteriores examinamos los fundamentos te√≥ricos de la virtualizaci√≥n, en este cap√≠tulo hablaremos sobre las herramientas que est√°n disponibles para el usuario directamente para iniciar y cambiar m√°quinas virtuales en el hipervisor KVM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consideremos tres componentes principales que cubren el 90 por ciento de todo tipo de operaciones con m√°quinas virtuales:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> libvirt </font></font></li><li> virsh CLI </li><li> virt-install </li></ul><br><br><blockquote> ,      CLI-,    , ,     qemu_system_x86_64    virt manager,    .      Cloud-, Openstack, ,    libvirt. <br></blockquote><br><br><h2> libvirt </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt es un proyecto de c√≥digo abierto a gran escala que desarrolla un conjunto de herramientas y controladores para administrar hipervisores. No solo admite QEMU / KVM, sino tambi√©n ESXi, LXC y mucho m√°s. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La raz√≥n principal de su popularidad es una interfaz estructurada e intuitiva para interactuar a trav√©s de un conjunto de archivos XML, adem√°s de la capacidad de automatizar a trav√©s de una API. Cabe se√±alar que libvirt no describe todas las funciones posibles del hipervisor, solo proporciona una interfaz conveniente para usar las funciones del hipervisor que son </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√∫tiles</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , desde el punto de vista de los participantes del proyecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y s√≠, libvirt es el est√°ndar de facto en el mundo de la virtualizaci√≥n actual. Solo eche un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vistazo a la lista de aplicaciones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que usan libvirt.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6f/115/f2f/b6f115f2f06f3fe06ee4727ec121c865.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La buena noticia sobre libvirt es que todos los paquetes necesarios ya est√°n preinstalados en todos los sistemas operativos host m√°s utilizados: Ubuntu, CentOS y RHEL, por lo que es probable que no tenga que compilar los paquetes necesarios y compilar libvirt. </font><font style="vertical-align: inherit;">En el peor de los casos, tendr√° que usar el instalador por lotes apropiado (apt, yum y similares). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tras la instalaci√≥n inicial y el inicio, libvirt crea Linux bridge virbr0 y su configuraci√≥n m√≠nima de forma predeterminada.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es por eso que al instalar Ubuntu Server, por ejemplo, ver√° en la salida del comando ifconfig Linux bridge virbr0: este es el resultado de ejecutar el demonio libvirtd </font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este puente de Linux no se conectar√° a ninguna interfaz f√≠sica, sin embargo, se puede usar para comunicar m√°quinas virtuales dentro de un √∫nico hipervisor. </font><font style="vertical-align: inherit;">Libvirt ciertamente se puede usar junto con OVS, sin embargo, para esto, el usuario debe crear puentes OVS de forma independiente utilizando los comandos OVS apropiados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquier recurso virtual necesario para crear una m√°quina virtual (c√≥mputo, red, almacenamiento) se representa como un objeto en libvirt. </font><font style="vertical-align: inherit;">Un conjunto de archivos XML diferentes es responsable del proceso de describir y crear estos objetos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tiene mucho sentido describir el proceso de creaci√≥n de redes virtuales y almacenamientos virtuales en detalle, ya que esta aplicaci√≥n est√° bien descrita en la documentaci√≥n de libvirt:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redes</font></font></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Almacenamiento</a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√°quina virtual en s√≠ con todos los dispositivos PCI conectados se llama dominio en la terminolog√≠a de libvirt. Este tambi√©n es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un objeto dentro de libvirt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se describe en un archivo XML separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este archivo XML es, estrictamente hablando, una m√°quina virtual con todos los recursos virtuales: RAM, procesador, dispositivos de red, discos y m√°s. A menudo, este archivo XML se llama libvirt XML o dump XML. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es poco probable que haya una persona que comprenda todos los par√°metros de libvirt XML, sin embargo, esto no es necesario cuando hay documentaci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, libvirt XML para Ubuntu Desktop Guest OS ser√° bastante simple: 40-50 l√≠neas. </font><font style="vertical-align: inherit;">Como toda la optimizaci√≥n del rendimiento tambi√©n se describe en libvirt XML (topolog√≠a NUMA, topolog√≠as de CPU, fijaci√≥n de CPU, etc.), para funciones de red, libvirt XML puede ser muy complejo y contener varios cientos de l√≠neas. </font><font style="vertical-align: inherit;">Cualquier fabricante de dispositivos de red que env√≠e su software como m√°quinas virtuales ha recomendado ejemplos de libvirt XML.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virsh CLI </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La utilidad virsh es una l√≠nea de comando "nativa" para administrar libvirt. </font><font style="vertical-align: inherit;">Su objetivo principal es administrar los objetos libvirt descritos como archivos XML. </font><font style="vertical-align: inherit;">Los ejemplos t√≠picos son iniciar, detener, definir, destruir, etc. </font><font style="vertical-align: inherit;">Es decir, el ciclo de vida de los objetos: gesti√≥n del ciclo de vida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una descripci√≥n de todos los comandos e indicadores de virsh tambi√©n est√° disponible en la documentaci√≥n de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virt-install </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra utilidad que se utiliza para interactuar con libvirt. </font><font style="vertical-align: inherit;">Una de las principales ventajas es que no tiene que lidiar con el formato XML, sino con los indicadores disponibles en virsh-install. </font><font style="vertical-align: inherit;">El segundo punto importante es el mar de ejemplos e informaci√≥n en la Web. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, no importa qu√© utilidad utilice, en √∫ltima instancia, ser√° libvirt lo que controlar√° el hipervisor, por lo que es importante comprender la arquitectura y los principios de su funcionamiento.</font></font><br><hr><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusi√≥n </font></font></h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este art√≠culo, examinamos el conjunto m√≠nimo de conocimientos te√≥ricos necesarios para trabajar con m√°quinas virtuales. </font><font style="vertical-align: inherit;">Intencionalmente no di ejemplos pr√°cticos y conclusiones de los equipos, ya que se pueden encontrar tantos ejemplos como desee en la Web, y no me propuse escribir una "gu√≠a paso a paso". </font><font style="vertical-align: inherit;">Si est√° interesado en un tema o tecnolog√≠a espec√≠ficos, deje sus comentarios y escriba preguntas.</font></font><br><hr><br><br><h1>  Enlaces utiles </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprender los dispositivos QEMU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVM / SR-IOV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><hr><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gracias </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Shalimov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mi colega y experto en el desarrollo de redes virtuales. </font><font style="vertical-align: inherit;">Para comentarios y ediciones.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yevgeny Yakovlev, mi colega y experto en el campo de la virtualizaci√≥n, para comentarios y correcciones. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467801/">https://habr.com/ru/post/467801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467789/index.html">Acaba de llegar Java 13. ZGC ha comenzado a compartir memoria, el propio CDS recuerda las clases y otras maravillas t√©cnicas.</a></li>
<li><a href="../467791/index.html">An√°lisis de desplazamiento de p√°gina en Google Data Studio</a></li>
<li><a href="../467793/index.html">Pila de tecnolog√≠a aburrida de la compa√±√≠a de internet de un solo hombre</a></li>
<li><a href="../467795/index.html">Nota sobre criptomonedas y regulaci√≥n estatal</a></li>
<li><a href="../467797/index.html">"R√≠ete por el bien de": ¬øpor qu√© podr√≠as necesitar herramientas de software que no tienen una aplicaci√≥n de "combate"?</a></li>
<li><a href="../467803/index.html">Simulaci√≥n elemental de interacci√≥n f√≠sica personalizada en python + matplotlib</a></li>
<li><a href="../467807/index.html">Compra y venta de criptomonedas en Rusia: m√©todos, legalizaci√≥n, riesgos.</a></li>
<li><a href="../467811/index.html">Arquitectura y programaci√≥n Fairchild Channel F</a></li>
<li><a href="../467813/index.html">Revisi√≥n de los cambios en el orden 17 del FSTEC</a></li>
<li><a href="../467815/index.html">Los medios de comunicaci√≥n generaron p√°nico porque "las direcciones IP se est√°n agotando en Rusia". Como realmente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>