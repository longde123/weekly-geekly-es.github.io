<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏿 👩🏿‍🤝‍👩🏻 ♑️ Outils de développement Node.js. Appel de procédure à distance sur les sockets Web 😽 🔡 ⏮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les histoires d'horreur parlent souvent de la technologie Websocket, par exemple, qu'elle n'est pas prise en charge par les navigateurs Web ou que les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Outils de développement Node.js. Appel de procédure à distance sur les sockets Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459978/"> Les histoires d'horreur parlent souvent de la technologie Websocket, par exemple, qu'elle n'est pas prise en charge par les navigateurs Web ou que les fournisseurs / administrateurs suppriment le trafic Websocket - elle ne peut donc pas être utilisée dans les applications.  D'un autre côté, les développeurs ne prévoient pas toujours les pièges de la technologie Websocket, comme toute autre technologie.  En ce qui concerne les limitations alléguées, je dirai tout de suite que 96,8% des navigateurs Web prennent en charge la technologie Websocket aujourd'hui.  On peut dire que 3,2% restant à la mer, c'est beaucoup, ce sont des millions d'utilisateurs.  Je suis totalement d'accord avec toi.  Seul tout est connu en comparaison.  Le même XmlHttpRequest, que tout le monde utilise en Ajax depuis de nombreuses années, prend en charge 97,17% des navigateurs Web (pas beaucoup plus, non?), Et récupère en général, 93,08% des navigateurs Web.  Contrairement à websocket, un tel pourcentage (et auparavant encore plus bas) n'a arrêté personne depuis longtemps lors de l'utilisation de la technologie Ajax.  Donc, utiliser le repli sur les longs sondages n'a actuellement aucun sens.  Si ce n'est que parce que les navigateurs Web qui ne prennent pas en charge WebSocket sont les mêmes navigateurs Web qui ne prennent pas en charge XmlHttpRequest, et en réalité, aucune solution de secours ne se produira. <br><br>  La deuxième histoire d'horreur, interdisant sur le Websocket des fournisseurs ou des administrateurs de réseaux d'entreprise, est également déraisonnable, car maintenant tout le monde utilise le protocole https, et il est impossible de comprendre que la connexion Websocket est ouverte (sans casser https). <br><br>  Quant aux vraies limitations et aux moyens de les surmonter, je vous en parlerai dans cet article, sur l'exemple du développement de la zone d'administration web de l'application. <br><a name="habracut"></a><br>  Ainsi, l'objet WebSocket dans le navigateur Web a, franchement, un ensemble de méthodes très concis: send () et close (), ainsi que les méthodes addEventListener (), removeEventListener () et dispatchEvent () héritées de l'objet EventTarget.  Par conséquent, le développeur doit utiliser des bibliothèques (généralement) ou indépendamment (presque impossible) pour résoudre plusieurs problèmes. <br><br>  Commençons par la tâche la plus compréhensible.  La connexion au serveur est interrompue périodiquement.  La reconnexion est assez simple.  Mais si vous vous souvenez que les messages du client et du serveur continuent de circuler à ce moment, tout devient immédiatement et beaucoup plus compliqué.  En général, un message peut être perdu si un mécanisme de confirmation pour le message reçu n'est pas fourni, ou remis (même plusieurs fois) si le mécanisme de confirmation est fourni, mais l'échec s'est produit juste au moment après la réception et avant la confirmation du message. <br><br>  Si vous avez besoin d'une livraison de message garantie et / ou d'une livraison de message sans prise, il existe des protocoles spéciaux pour l'implémentation, par exemple, AMQP et MQTT, qui fonctionnent avec le transport websocket.  Mais aujourd'hui, nous ne les considérerons pas. <br><br>  La plupart des bibliothèques pour travailler avec websocket prennent en charge la transparence pour que le programmeur se reconnecte au serveur.  L'utilisation d'une telle bibliothèque est toujours plus fiable que le développement de votre implémentation. <br><br>  Ensuite, vous devez implémenter l'infrastructure d'envoi et de réception de messages asynchrones.  Pour ce faire, utilisez le gestionnaire d'événements onmessage «nu» sans liaison supplémentaire, une tâche ingrate.  Une telle infrastructure peut être, par exemple, un appel de procédure à distance (RPC).  L'id id a été introduit dans la spécification json-rpc, spécifiquement pour travailler avec le transport websocket, qui vous permet de mapper l'appel de procédure distante par le client au message de réponse du serveur web.  Je préférerais ce protocole à toutes les autres possibilités, mais jusqu'à présent, je n'ai pas trouvé d'implémentation réussie de ce protocole pour la partie serveur sur node.js. <br><br>  Et enfin, vous devez implémenter la mise à l'échelle.  Rappelez-vous que la connexion entre le client et le serveur se produit périodiquement.  Si la puissance d'un serveur ne nous suffit pas, nous pouvons augmenter plusieurs serveurs.  Dans ce cas, une fois la connexion déconnectée, la connexion au même serveur n'est pas garantie.  En règle générale, un serveur Redis ou un cluster de serveurs Redis est utilisé pour coordonner plusieurs serveurs WebSocket. <br><br>  Et, malheureusement, tôt ou tard, nous rencontrerons de toute façon les performances du système, car les capacités de node.js dans le nombre de connexions Websocket qui sont ouvertes simultanément (ne confondez pas cela avec les performances) sont nettement inférieures à celles des serveurs spécialisés tels que les files d'attente de messages et les courtiers.  Et la nécessité d'un échange croisé entre toutes les instances de serveurs WebSocket via le cluster de serveurs Redis, après un certain point critique, n'entraînera pas une augmentation significative du nombre de connexions ouvertes.  La façon de résoudre ce problème consiste à utiliser des serveurs spécialisés, tels que AMQP et MQTT, qui fonctionnent, y compris avec le transport Websocket.  Mais aujourd'hui, nous ne les considérerons pas. <br><br>  Comme vous pouvez le voir dans la liste des tâches répertoriées, faire du vélo tout en travaillant avec websocket prend beaucoup de temps, et même impossible si vous avez besoin de faire évoluer la solution sur plusieurs serveurs websocket. <br><br>  Par conséquent, je propose de considérer plusieurs bibliothèques populaires qui implémentent le travail avec websocket. <br><br>  Je vais immédiatement exclure de la considération les bibliothèques qui mettent en œuvre exclusivement le repli sur les modes de transport obsolètes, car aujourd'hui cette fonctionnalité n'est pas pertinente, et les bibliothèques qui implémentent une fonctionnalité plus large, en règle générale, implémentent également le repli sur les modes de transport obsolètes. <br><br>  Je vais commencer par la bibliothèque la plus populaire - socket.io.  Vous pouvez maintenant entendre l'opinion, très probablement juste, que cette bibliothèque est lente et coûteuse en termes de ressources.  C'est probablement le cas, et cela fonctionne plus lentement que le Websocket natif.  Cependant, c'est aujourd'hui la bibliothèque la plus développée par ses moyens.  Et, encore une fois, lorsque vous travaillez avec websocket, le principal facteur limitant n'est pas la vitesse, mais le nombre de connexions ouvertes simultanément avec des clients uniques.  Et cette question est déjà mieux résolue en établissant des connexions avec les clients vers des serveurs spécialisés. <br><br>  Ainsi, soket.io implémente une récupération fiable lors de la déconnexion du serveur et de la mise à l'échelle à l'aide d'un serveur ou d'un cluster de serveurs redis.  socket.io, en fait, implémente son propre protocole de messagerie individuel, qui vous permet d'implémenter la messagerie entre le client et le serveur sans être lié à un langage de programmation spécifique. <br><br>  Une caractéristique intéressante de socket.io est la confirmation du traitement des événements, dans lequel un objet arbitraire peut être renvoyé du serveur au client, ce qui permet des appels de procédure à distance (bien qu'il ne soit pas conforme à la norme json-rpc). <br><br>  Aussi, préliminaire, j'ai examiné deux autres bibliothèques intéressantes, dont je vais brièvement parler ci-dessous. <br><br>  Bibliothèque Faye <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">faye.jcoglan.com</a> .  Il implémente le protocole bayeux, qui a été développé dans le cadre du projet CometD et implémente l'abonnement / distribution de messages aux canaux de messages.  Ce projet prend également en charge la mise à l'échelle à l'aide d'un serveur ou d'un cluster de serveurs redis.  Une tentative pour trouver un moyen d'implémenter RPC a échoué car il ne cadrait pas avec le schéma du protocole de Bayeux. <br><br>  Dans le projet socketcluster <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">socketcluster.io</a> , l'accent est mis sur la mise à l'échelle du serveur websocket.  Dans le même temps, le cluster de serveurs websocket n'est pas créé sur la base du serveur redis, comme dans les deux premières bibliothèques mentionnées, mais sur la base de node.js.  À cet égard, lors du déploiement du cluster, il a été nécessaire de lancer une infrastructure assez complexe de courtiers et de travailleurs. <br><br>  Passons maintenant à l'implémentation de RPC sur socket.io.  Comme je l'ai dit plus haut, cette bibliothèque a déjà implémenté la possibilité d'échanger des objets entre le client et le serveur: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remoteCall = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, data, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>).createServer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(server, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span> }); io.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, (socket) =&gt; { socket.on(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (data, callback) =&gt; { handleRemoteCall(socket, data, callback); }); }); server.listen(<span class="hljs-number"><span class="hljs-number">5000</span></span>, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'dashboard backend listening on *:5000'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleRemoteCall = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">socket, data, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response =... callback(response) }</code> </pre><br>  C'est le schéma général.  Nous allons maintenant considérer chacune des parties par rapport à une application spécifique.  Pour construire le panneau d'administration, j'ai utilisé la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">react</a> -admin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/marmelab/react-admin</a> .  L'échange de données avec le serveur de cette bibliothèque est mis en œuvre à l'aide d'un fournisseur de données, qui a un schéma très pratique, presque une sorte de standard.  Par exemple, pour obtenir une liste, la méthode est appelée: <br><br><pre> <code class="javascript hljs">dataProvider( <span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, { <span class="hljs-attr"><span class="hljs-attr">pagination</span></span>: { <span class="hljs-attr"><span class="hljs-attr">page</span></span>: {int}, <span class="hljs-attr"><span class="hljs-attr">perPage</span></span>: {int} }, <span class="hljs-attr"><span class="hljs-attr">sort</span></span>: { <span class="hljs-attr"><span class="hljs-attr">field</span></span>: {string}, <span class="hljs-attr"><span class="hljs-attr">order</span></span>: {string} }, <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> } }</code> </pre><br>  Cette méthode dans une réponse asynchrone renvoie un objet: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [  ], <span class="hljs-attr"><span class="hljs-attr">total</span></span>:      }</code> </pre><br>  Il existe actuellement un nombre impressionnant d'implémentations de fournisseurs de données React-Admin pour divers serveurs et frameworks (par exemple Firebase, Spring Boot, Graphql, etc.).  Dans le cas de RPC, l'implémentation s'est avérée être la plus concise, puisque l'objet est transféré dans sa forme d'origine à l'appel de fonction emit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (action, collection, payload = {}) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, {action, collection, payload}, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre><br>  Malheureusement, un peu plus de travail a dû être fait côté serveur.  Pour organiser le mappage des fonctions qui gèrent l'appel distant, un routeur similaire à express.js a été développé.  Ce n'est qu'au lieu de la signature du middleware (req, res, next) que l'implémentation s'appuie sur la signature (socket, payload, callback).  En conséquence, nous avons tous obtenu le code habituel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Router = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./router'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = Router(); router.use(<span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, (socket, payload, callback) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> limit = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(payload.pagination.perPage); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">(payload.pagination.page</span></span></span><span class="hljs-function">) - 1) * </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">limit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{data: users.slice(offset, offset + limit </span></span></span><span class="hljs-function">), </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">}); }); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">router</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">use</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'GET_ONE'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (socket, payload, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id]}); }); router.use(<span class="hljs-string"><span class="hljs-string">'UPDATE'</span></span>, (socket, payload, callback) =&gt; { users[payload.id] = payload.data <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id] }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { users.push({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`name of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>}); }</code> </pre><br>  Les détails de la mise en œuvre du routeur peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le référentiel du projet.</a> <br><br>  Il ne reste plus qu'à assigner un fournisseur pour le composant Admin: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Admin, Resource, EditGuesser } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-admin'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserList <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./UserList'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wsProvider'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Admin dataProvider={dataProvider}&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Resource</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">list</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{UserList}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">edit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{EditGuesser}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Admin</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App;</code> </pre><br><br>  Liens utiles <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.www.infoq.com/articles/Web-Sockets-Proxy-Servers</a> <br><br>  apapacy@gmail.com <br>  14 juillet 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459978/">https://habr.com/ru/post/fr459978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459964/index.html">8 astuces UI simples pour dynamiser la conception d'un prototype sans recourir à l'animation</a></li>
<li><a href="../fr459968/index.html">Qu'est-il vraiment arrivé au Boeing malaisien disparu (partie 3/3)</a></li>
<li><a href="../fr459970/index.html">Promise.allSettled</a></li>
<li><a href="../fr459972/index.html">Développement pour Docker. Environnement local. Partie 1</a></li>
<li><a href="../fr459976/index.html">Nouvelle version gratuite de Nemesida WAF pour NGINX</a></li>
<li><a href="../fr459980/index.html">Lettres nigérianes de haute technologie</a></li>
<li><a href="../fr459982/index.html">Analyseurs de Roslyn. Comment écrire du code rapidement et avec précision</a></li>
<li><a href="../fr459984/index.html">Construire une infrastructure en tant que code avec GitLab et Ansible</a></li>
<li><a href="../fr459988/index.html">Le chien a mangé sur des réseaux de neurones</a></li>
<li><a href="../fr459990/index.html">Immersion in Move - le langage de programmation de la chaîne de blocs Libra de Facebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>