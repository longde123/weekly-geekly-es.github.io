<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 👎🏼 🐎 FPGA Cyclone IV的Snake游戏（带有VGA和SPI游戏杆） 🚡 ⛓️ 👗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


 您还记得童年时代的蛇游戏吗？那条蛇在屏幕上奔跑试图吃一个苹果？ 本文介绍了我们在FPGA 1上实现游戏的方法。 



 图1.游戏玩法 


 首先，让我们自我介绍并解释我们为何从事该项目的理由。 我们共有3个人： Tymur Lysenko ， Daniil Manakovskiy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FPGA Cyclone IV的Snake游戏（带有VGA和SPI游戏杆）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431226/"><h2 id="introduction"> 引言 </h2><br><p> 您还记得童年时代的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">蛇游戏</a>吗？那条蛇在屏幕上奔跑试图吃一个苹果？ 本文介绍了我们在FPGA <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1</a></sup>上实现游戏的方法。 </p><br><p><img src="https://github.com/Sitiritis/SnakeGame_FPGA/blob/master/text/img/gameplay.gif?raw=true" alt="Gameplay.gif"><br>  <strong>图1.</strong>游戏玩法 </p><a name="habracut"></a><br><p> 首先，让我们自我介绍并解释我们为何从事该项目的理由。 我们共有3个人： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tymur Lysenko</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Daniil Manakovskiy</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sergey Makarov</a> 。 作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Innopolis大学的</a>一年级学生，我们开设了“计算机体系结构”课程，该课程经过专业教授，使学习者能够理解计算机的低级结构。 在课程中的某些时候，讲师为我们提供了开发FPGA项目的机会，以增加课程中的要点。 我们的动机不仅在于成绩，还在于我们希望获得更多的硬件设计经验，分享成果并最终拥有一个令人愉悦的游戏。 </p><br><p> 现在，让我们进入黑暗的深层细节。 </p><br><h2 id="project-overview"> 项目概况 </h2><br><p> 对于我们的项目，我们选择了一个易于实现且有趣的游戏，即“ Snake”。 该实现的结构如下：首先，从SPI游戏杆获取输入，然后进行处理，最后，将图片输出到VGA监视器，并在7段显示器（以十六进制显示）上显示得分。 尽管游戏逻辑直观直观，但是VGA和操纵杆却是有趣的挑战，它们的实现带来了良好的游戏体验。 </p><br><p> 该游戏具有以下规则。 玩家从一条蛇的头开始。 目的是要吃苹果，苹果是在吃完上一个苹果之后在屏幕上随机产生的。 此外，在满足饥饿感之后，蛇被延长了一条尾巴。 尾巴一个接一个地移动，跟随头部。 蛇总是在移动。 如果到达屏幕边界，则说明蛇正在转移到屏幕的另一侧。 如果头撞到尾巴，则游戏结束。 </p><br><h2 id="tools-used"> 使用的工具 </h2><br><ul><li>  Altera Cyclone IV（EP4CE6E22C8N）具有6272个逻辑元素，板载50 MHz时钟，3位彩色VGA，8位7段显示器。  FPGA无法将模拟输入带到其引脚。 </li><li>  SPI游戏杆（KY-023） </li><li> 一个支持60 Hz刷新率的VGA监视器 </li><li>  Quartus Prime Lite Edition 18.0.0内部版本614 </li><li>  Verilog HDL IEEE 1364-2001 </li><li> 面包板 </li><li> 电气元件： <br><ul><li>  8个公-母连接器 </li><li>  1个母-母连接器 </li><li>  1个公-公连接器 </li><li>  4个电阻（4.7KΩ） </li></ul></li></ul><br><h2 id="architecture-overview"> 架构概述 </h2><br><p> 项目的体系结构是要考虑的重要因素。 图2从顶级角度显示了该架构： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c92/2a4/4b2/c922a44b20cdc085b7061e7b5c5f8cd4.png" alt="Design.png"><br>  <strong>图2.设计的</strong>顶层视图（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pdf</a> ） </p><br><p> 如您所见，有很多输入，输出和一些模块。 本节将描述每个元素的含义，并指定板上的端口使用哪些引脚。 </p><br><h3 id="main-inputs"> 主要输入 </h3><br><p> 实现所需的主要输入是<em>res_x_one</em> ， <em>res_x_two</em> ， <em>res_y_one</em> ， <em>res_y_two</em> ，用于接收操纵杆的当前方向。 图3显示了它们的值和方向之间的映射。 </p><br><table><thead><tr><th> 输入值 </th><th> 向左 </th><th> 对啊 </th><th> 上 </th><th> 往下 </th><th> 方向不变 </th></tr></thead><tbody><tr><td>  res_x_one（PIN_30） </td><td>  1个 </td><td>  0 </td><td>  X </td><td>  X </td><td>  1个 </td></tr><tr><td>  res_x_two（PIN_52） </td><td>  1个 </td><td>  0 </td><td>  X </td><td>  X </td><td>  0 </td></tr><tr><td>  res_y_one（PIN_39） </td><td>  X </td><td>  X </td><td>  1个 </td><td>  0 </td><td>  1个 </td></tr><tr><td>  res_y_two（PIN_44） </td><td>  X </td><td>  X </td><td>  1个 </td><td>  0 </td><td>  0 </td></tr></tbody></table><br><p>  <strong>图3.</strong>操纵杆输入和方向的映射 </p><br><h3 id="other-inputs"> 其他投入 </h3><br><ul><li>  clk-板钟（PIN_23） </li><li>  <em>重置</em> -重置游戏并停止打印的信号（PIN_58） </li><li>  color-当为1时，所有可能的颜色都会输出到屏幕上，并且仅用于演示目的（PIN_68） </li></ul><br><h3 id="main-modules"> 主要模块 </h3><br><h4 id="joystick_input">  joystick_input </h4><br><p>  <em>joystick_input</em>用于根据操纵杆的输入产生方向代码。 </p><br><h4 id="game_logic">  game_logic </h4><br><p>  <em>game_logic</em>包含玩游戏所需的所有逻辑。 该模块沿给定方向移动蛇。 此外，它还负责苹果进食和碰撞检测。 此外，它接收屏幕上像素的当前x和y坐标，并返回放置在该位置的实体。 </p><br><h4 id="vga_draw">  VGA_绘图 </h4><br><p> 抽屉根据当前位置（ <em>iVGA_X，iVGA_Y</em> ）和当前实体（ <em>ent</em> ）将像素的颜色设置为特定值。 </p><br><h4 id="vga_ctrl">  VGA_Ctrl </h4><br><p> 生成控制位<em>流到</em> VGA输出（ <em>V_Sync，H_Sync，R，G，B</em> ）。 </p><br><h4 id="sseg_displaysup22sup">  SSEG_Display <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2</a></sup> </h4><br><p>  <em>SSEG_Display</em>是一个驱动程序，用于在7段显示器上输出当前分数。 </p><br><h4 id="vga_clk">  Vga_clk </h4><br><p>  <em>VGA_clk</em>接收50MHz时钟并将其降低到25.175MHz。 </p><br><h4 id="game_upd_clk">  game_upd_clk </h4><br><p>  <em>game_upd_clk</em>是一个模块，可生成触发游戏状态更新的特殊时钟。 </p><br><h3 id="outputs"> 产出 </h3><br><ul><li>  <em>VGA_B</em> -VGA蓝色针（PIN_144） </li><li>  <em>VGA_G</em> -VGA绿色针（PIN_1） </li><li>  <em>VGA_R</em> -VGA红色引脚（PIN_2） </li><li>  <em>VGA_HS</em> -VGA水平同步（PIN_142） </li><li>  <em>VGA_VS</em> -VGA垂直同步（PIN_143） </li><li>  <em>sseg_a_to_dp-</em>指定要点亮的8个段中的哪一个（PIN_115，PIN_119，PIN_120，PIN_121，PIN_124，PIN_125，PIN_126，PIN_127） </li><li>  <em>sseg_an-</em>指定要使用4个7段显示器中的哪一个（PIN_128，PIN_129，PIN_132，PIN_133） </li></ul><br><h2 id="implementation"> 实作 </h2><br><h3 id="input-with-spi-joystick"> 通过SPI游戏杆输入 </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e3f/4ab/fc4/e3f4abfc45c5a87151db34738e9c3a92.jpg" alt="stick.jpg"></p><br><p>  <strong>图4.</strong> SPI游戏杆（KY-023） </p><br><p> 在实现输入模块时，我们发现操纵杆会产生一个模拟信号。 操纵杆每个轴有3个位置： </p><br><ul><li> 顶部-〜5V输出 </li><li> 中-〜2.5V输出 </li><li> 低-〜0V输出 </li></ul><br><p>输入与三元系统非常相似：对于X轴，我们有<code>true</code> （左）， <code>false</code> （右）和<code>undetermined</code>状态，操纵杆既不在左侧也不在右侧。 问题在于FPGA板只能处理数字输入。 因此，我们不能仅通过编写一些代码就将这种三元逻辑转换为二进制。 提出的第一个解决方案是找到一个模数转换器，但随后我们决定利用我们在物理领域的知识，并实施分压器<sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3</a></sup> 。 要定义这三种状态，我们将需要两个位：00为<code>false</code> ，01为<code>undefined</code>和11为<code>true</code> 。 经过一些测量，我们发现板上的零和一之间的边界约为1.7V。 因此，我们构建了以下方案（使用circuitlab <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4</a></sup>创建的图像）： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/009/36c/a43/00936ca435f219d64f7078bec64e9b8c.png" alt="Stick_connection.png"></p><br><p>  <strong>图5.</strong>用于操纵杆的ADC电路 </p><br><p> 物理实现是使用Arduino套件项目构建的，如下所示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3eb/34b/c9e/3eb34bc9e0210b8f336a7fd8ba89f1a9.jpg" alt="stick_imp"></p><br><p>  <strong>图6.</strong> ADC实现 </p><br><p> 我们的电路为每个轴输入一个输入，并产生两个输出：第一个直接来自操纵杆，只有在操纵杆输出为<code>zero</code>时才变为<code>zero</code> 。 第二个是0（处于<code>undetermined</code>状态），而1仍然为<code>true</code> 。 这是我们期望的确切结果。 </p><br><p> 输入模块的逻辑是： </p><br><ol><li> 我们将每个方向的三元逻辑转换为简单的二进制线。 </li><li> 在每个时钟周期，我们检查是否只有一个方向<code>true</code> （蛇不能沿对角线走）； </li><li> 我们将新方向与上一个方向进行比较，以防止玩家不允许将方向更改为相反方向，从而防止蛇吃掉自己。 </li></ol><br><div class="spoiler">  <b class="spoiler_title">输入模块代码的一部分</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">reg left, right, up, down; initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> direction = `TOP_DIR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> //<span class="hljs-number"><span class="hljs-number">1</span></span> left = two_resistors_x; right = ~one_resistor_x; up = two_resistors_y; down = ~one_resistor_y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left + right + up + down == <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b001</span></span>) //<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &amp;&amp; (direction != `RIGHT_DIR)) //<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> direction = `LEFT_DIR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> //same code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> other directions <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="output-to-vga"> 输出到VGA </h3><br><p> 我们决定在以60 FPS运行的60Hz屏幕上输出分辨率为640x480的输出。 </p><br><p>  VGA模块包括2个主要部分： <strong>驱动器</strong>和<strong>抽屉</strong> 。 驱动程序生成由垂直，水平同步信号和提供给VGA输出的颜色组成的位流。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@SlavikMIPT</a>撰写的文章<sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5</a></sup>描述了使用VGA的基本原理。 我们已将驱动程序从本文改编为我们的董事会。 </p><br><p> 我们决定将屏幕分成40x30的元素网格，该网格由16x16像素的正方形组成。 每个元素代表一个游戏实体：一个苹果，一条蛇的头，一条尾巴或什么都没有。 </p><br><p> 我们实现的下一步是为实体创建精灵。 </p><br><p>  Cyclone IV只有3位来表示VGA上的颜色（红色代表1，绿色代表1，蓝色代表1）。 由于这样的限制，我们需要实现一个转换器，以使图像的颜色适合可用的颜色。 为此，我们创建了一个python脚本，该脚本将每个像素的RGB值除以128。 </p><br><div class="spoiler">  <b class="spoiler_title">python脚本</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageDraw filename = <span class="hljs-string"><span class="hljs-string">"snake_head"</span></span> index = <span class="hljs-number"><span class="hljs-number">1</span></span> im = Image.open(filename + <span class="hljs-string"><span class="hljs-string">".png"</span></span>) n = Image.new(<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)) d = ImageDraw.Draw(n) pix = im.load() size = im.size data = [] code = <span class="hljs-string"><span class="hljs-string">"sp["</span></span> + str(index) + <span class="hljs-string"><span class="hljs-string">"][{i}][{j}] = 3'b{RGB};\\\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"code_"</span></span> + filename + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size[<span class="hljs-number"><span class="hljs-number">0</span></span>]): tmp = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size[<span class="hljs-number"><span class="hljs-number">1</span></span>]): clr = im.getpixel((i, j)) vg = <span class="hljs-string"><span class="hljs-string">"{0}{1}{2}"</span></span>.format(int(clr[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-number"><span class="hljs-number">128</span></span>), <span class="hljs-comment"><span class="hljs-comment"># an array representation for pixel int(clr[1] / 128), # since clr[*] in range [0, 255], int(clr[2] / 128)) # clr[*]/128 is either 0 or 1 tmp.append(vg) f.write(code.format(i=i, j=j, RGB=vg)) # Verilog code to initialization d.point((i, j), tuple([int(vg[0]) * 255, int(vg[1]) * 255, int(vg[2]) * 255])) # Visualize final image data.append(tmp) n.save(filename + "_3bit.png") for el in data: print(" ".join(el))</span></span></code> </pre></div></div><br><table><tbody><tr><td align="center"> 原版 </td><td align="center"> 脚本后 </td></tr><tr><td align="center" width="150"><img src="https://habrastorage.org/getpro/habr/post_images/720/34d/b40/72034db4092a25711654562bc4523661.png" width="128" height="128"><br></td><td align="center" width="150"><img src="https://habrastorage.org/getpro/habr/post_images/529/254/02e/52925402e158986901bc6278d7d0bb28.png" width="128" height="128"><br></td></tr></tbody></table><br><p>  <strong>图7.</strong>输入和输出之间的比较 </p><br><p> 抽屉的主要目的是根据当前位置（ <em>iVGA_X，iVGA_Y</em> ）和当前实体（ <em>ent</em> ）向VGA发送像素的颜色。 所有子画面都是硬编码的，但是可以使用上面的脚本生成新代码来轻松更改。 </p><br><div class="spoiler">  <b class="spoiler_title">抽屉逻辑</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">always @(posedge iVGA_CLK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> oRed &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; oGreen &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; oBlue &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // DRAW CURRENT STATE <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ent == `ENT_NOTHING) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> oRed &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; oGreen &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; oBlue &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Drawing a particular pixel from sprite oRed &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">0</span></span>]; oGreen &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">1</span></span>]; oBlue &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="output-to-the-7-segment-display"> 输出到7段显示器 </h3><br><p> 为了使玩家能够看到自己的分数，我们决定将游戏分数输出到7段显示器。 由于时间有限，我们使用了EP4CE6入门板文档<sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2中</a></sup>的代码。 该模块将十六进制数输出到显示器。 </p><br><h3 id="game-logic"> 游戏逻辑 </h3><br><p> 在开发过程中，我们尝试了几种方法，但是最后我们得到了一种方法，该方法需要最少的内存，易于在硬件中实现并且可以从并行计算中受益。 </p><br><p> 该模块执行多种功能。 当VGA在每个时钟周期从左上角开始移动到右下角时绘制一个像素时，负责为像素产生颜色的VGA_Draw模块需要确定用于当前坐标的颜色。 那就是游戏逻辑模块应该输出的-给定坐标的实体代码。 <br> 而且，仅在绘制全屏后才必须更新游戏状态。  <em>game_upd_clk</em>模块产生的信号用于确定何时更新。 </p><br><h4 id="game-state"> 游戏状态 </h4><br><p> 游戏状态包括： </p><br><ul><li> 蛇头的坐标 </li><li> 蛇尾巴的坐标数组。 在我们的实现中，数组受128个元素限制 </li><li> 尾数 </li><li> 苹果的坐标 </li><li> 游戏结束标志 </li><li> 比赛获胜标志 </li></ul><br><p> 游戏状态的更新包括以下几个阶段： </p><br><ol><li> 根据给定的方向将蛇的头移动到新坐标。 如果发现坐标在其边缘上并且需要进一步更改，则头部必须跳到屏幕的另一边缘。 例如，方向设置为左侧，当前X坐标为0。因此，新的X坐标应等于最后一个水平地址。 </li><li> 将蛇头的新坐标与苹果坐标进行测试： <br>  2.1。 如果它们相等且数组未满，请在数组中添加新尾部并增加尾部计数器。 当计数器达到最高值（在本例中为128）时，将设置游戏获胜标志，这意味着蛇不再能够生长，并且游戏仍在继续。 新的尾巴将放置在蛇头的先前坐标上。  X和Y的随机坐标应放置一个苹果。 <br>  2.2。 如果它们不相等，则顺序交换相邻尾巴的坐标。 如果第n个尾部在第（n +1）个之前添加，则（n +1）个第尾部应接收第n个坐标。 第一条尾巴接收头部的旧坐标。 </li><li> 检查蛇头的新坐标是否与任何尾巴的坐标一致。 在这种情况下，游戏结束标志会升起，游戏会停止。 </li></ol><br><h4 id="random-coordinate-generation"> 随机坐标生成 </h4><br><p> 通过取由6位<em>线性反馈移位移位寄存器（LFSR）</em> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6</a></sup>生成的随机位产生的随机数。 为了将数字拟合到屏幕中，将它们除以游戏网格的尺寸，然后取余数。 </p><br><h2 id="conclusion"> 结论 </h2><br><p> 经过8周的工作，该项目成功实施。 我们在游戏开发方面具有一定的经验，最终为FPGA开发了一个令人愉快的“蛇”游戏版本。 该游戏具有可玩性，并且我们在编程，设计体系结构和软技能方面的技能得到了提高。 </p><br><h2 id="acknowledgments"> 确认的细分 </h2><br><p> 我们要特别感谢和感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">穆罕默德·法希姆</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Muhammad Fahim）</a>教授和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">亚历山大·托马索夫</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexander Tormasov）</a>教授， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">他们</a>为我们提供了丰富的知识和将其付诸实践的机会。 我们衷心感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">弗拉迪斯拉夫·奥斯坦科维奇</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vladislav Ostankovich）</a>为我们提供了该项目中使用的必要硬件，并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">感谢Temur Kholmatov</a>帮助调试。 我们不会忘记记得<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Anastassiya Boiko</a>为游戏绘制漂亮的精灵。 另外，我们还要向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rabab Marouf</a>致以诚挚的敬意，以便对本文进行校对和编辑。 </p><br><p> 感谢所有帮助我们测试游戏并尝试创造记录的人。 希望你喜欢玩！ </p><br><h2 id="references"> 参考文献 </h2><br><p>  [1]： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Github上的项目</a> <br>  [2]： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[FPGA] EP4CE6入门板文档</a> <br>  [3]： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分压器</a> <br>  [4]： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电路建模工具</a> <br>  [5]： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用于FPGA Altera Cyclone III的VGA适配器</a> <br>  [6]： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维基百科上的线性反馈移位寄存器（LFSR）</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FPGA中的LFSR-VHDL和Verilog代码</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">苹果质地</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">产生随机数的想法</a> <br>  Palnitkar，S。（2003）。  <em>Verilog HDL：数字设计和综合指南，第二版。</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431226/">https://habr.com/ru/post/zh-CN431226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431212/index.html">在Android中缓存分页</a></li>
<li><a href="../zh-CN431216/index.html">Snom D345 IP电话评论</a></li>
<li><a href="../zh-CN431218/index.html">我是如何制作Lovecraft漫画游戏的</a></li>
<li><a href="../zh-CN431220/index.html">生物学家看我们衰老的根源</a></li>
<li><a href="../zh-CN431222/index.html">网站存档</a></li>
<li><a href="../zh-CN431228/index.html">光的障碍物：液晶助您一臂之力</a></li>
<li><a href="../zh-CN431230/index.html">HPC基础架构的存储，或者我们如何在理研日本研究中心收集65 PB的存储</a></li>
<li><a href="../zh-CN431232/index.html">我们在Node.js上生成漂亮的SVG占位符</a></li>
<li><a href="../zh-CN431234/index.html">12月11日，莫斯科-Alfa JS MeetUp</a></li>
<li><a href="../zh-CN431236/index.html">如何在2018年用Objective-C编写 第一部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>