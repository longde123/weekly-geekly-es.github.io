<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍✈️ 🚫 🐭 Dua Z80s per satu mesin: bagaimana perbedaan mesin arcade 8-bit dari komputer di rumah? 🍑 👩🏿‍🌾 🕑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang saya pelajari tentang mesin arcade Jack Bom dalam proses menciptakan emulatornya 


 Baru-baru ini saya menulis sebuah emulator mesin Bomb Ja...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dua Z80s per satu mesin: bagaimana perbedaan mesin arcade 8-bit dari komputer di rumah?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426291/"><h2>  Apa yang saya pelajari tentang mesin arcade Jack Bom dalam proses menciptakan emulatornya </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ea/be5/eae/7eabe5eaeb49a7c8a77b543628df89bf.png"></div><br>  Baru-baru ini saya menulis sebuah emulator mesin Bomb Jack kecil, terutama untuk mencari tahu bagaimana mesin arcade 8-bit pertama ini berbeda dalam desain dari komputer rumahan 8-bit. <br><br>  Seperti yang saya ketahui kemudian, pertemuan di sebuah pameran musim panas di kota kelahiran saya dengan mesin-mesin arcade seperti Bomb Jack adalah salah satu momen yang mengubah nasib saya.  Pada hari musim panas yang normal, setelah menghabiskan seluruh persediaan koin saya di mesin arcade, saya kembali ke rumah, dan kepala saya dipenuhi dengan bunga dan efek suara.  Saya mencoba memahami bagaimana permainan ini bekerja.  Dan kemudian sampai akhir tahun saya menghabiskan seluruh waktu saya sepulang sekolah untuk membuat salinan game arcade yang agak pudar di komputer rumah saya.  Saya seperti penggemar kultus kargo dari pulau-pulau di Samudra Pasifik, yang ingin membuat stasiun radio militer Amerika dari tongkat. <br><br>  Pada awalnya saya berpikir tentang ide membuat emulator <em>Pengo</em> , karena otak remaja saya jauh lebih terkesan dengan permainan ini daripada Bomb Jack (omong-omong, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi Pengo kargo-kultus</a> saya).  Tetapi peralatan arcade Pengo akan membutuhkan penciptaan emulator chip baru untuk audio dan video, dan untuk Bomb Jack ada cukup banyak bagian yang sudah saya miliki (Z80 sebagai CPU dan AY-3-8910 untuk suara), jadi saya yang pertama kali mengambil Bomb Jack. <br><a name="habracut"></a><br>  Selain itu, Bomb Jack adalah kesempatan besar untuk akhirnya menambahkan dukungan NMI (non-maskable interrupt) ke emulator Z80 saya.  Tidak satu pun dari mesin berbasis Z80 yang sebelumnya saya tiru menggunakan NMI, dan oleh karena itu tidak ada gunanya menciptakan kembali fungsi ini - saya masih tidak dapat memeriksa operasinya. <br><br>  Jika Anda tidak tahu apa itu Bomb Jack, maka game ini terlihat seperti ini (tidak yakin apakah saya memilih rasio aspek yang tepat): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af7/79a/9ae/af779a9ae761839ee041300bc817c7f6.png" alt="Tangkapan Layar Bom Jack"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_jJzasm63DE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Versi emulator di WebAssembly dapat ditemukan di sini: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://floooh.github.io/tiny8bit/bombjack.html</a> <br><br>  Setelah prosedur pemuatan selesai dan tabel skor tinggi muncul, tekan <strong>1</strong> untuk menjatuhkan koin, lalu <strong>Enter</strong> (atau tombol lainnya kecuali panah dan spasi) untuk memulai permainan. <br><br>  Di dalam gim, gunakan <strong>tombol panah</strong> untuk mengubah arah dan <strong>bilah spasi</strong> untuk melompat.  Saat berada di udara, tekan <strong>bilah spasi</strong> untuk memperlambat jatuh. <br><br>  Kode sumber ada di sini: <br><br>  <a href="">https://github.com/floooh/chips-test/blob/master/examples/sokol/bombjack.c</a> <br><br>  Ia menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chip header</a> untuk memberikan emulasi Z80 dan AY-3-8910, serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">header sokol</a> sebagai pembungkus lintas platform (untuk memasuki aplikasi, rendering, input dan suara). <br><br><h2>  Langkah 1: Penelitian </h2><br>  "Penelitian" adalah kata yang terlalu besar: Saya baru saja menekan "spesifikasi perangkat keras arcade Bombjack" Google. <br><br>  Dibandingkan dengan komputer rumah tahun 80-an yang populer (atau bahkan komputer Eropa Timur yang misterius, yang sering masih memiliki komunitas aktif), ada sangat sedikit informasi tentang Bom Jack di Internet. <br><br>  Saya menemukan dua informasi yang sangat penting: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram rangkaian</a> mesin dan, tentu saja, <a href="">kode sumber emulator MAME</a> . <br><br>  Ada juga proyek yang mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bom Jack pada FGPA</a> , dari sumber VHDL yang saya berhasil mencari tahu detail yang tidak ada dalam diagram rangkaian. <br><br>  Memahami kode sumber MAME akan sulit, karena emulator mesin arcade biasanya hanya sekelompok makro yang menggambarkan bagaimana berbagai bagian peralatan berinteraksi, tetapi tidak ada banyak <em>kode sumber</em> . <br><br>  Namun demikian, deskripsi makro dari peralatan, dan terutama komentar, ternyata masih sangat berguna untuk memahami pengoperasian perangkat keras, dan di mana mereka menjadi terlalu samar (misalnya, <a href="">bagian pada decoding video</a> ), percobaan dan kesalahan sudah cukup, serta studi rinci tentang konsep. <br><br><h2>  Ikhtisar Perangkat Keras </h2><br>  Yang paling menarik tentang perangkat keras Bomb Jack adalah bahwa sebenarnya <strong>dua komputer</strong> terhubung satu sama lain dengan pita listrik: ada <strong>papan utama</strong> dengan CPU Z80 dan peralatan decoding video dan <strong>kartu suara</strong> terpisah dengan CPU Z80 sendiri dan tiga (ya, tiga!) chip suara AY-3-8910. <br><br>  Peralatan pengodean video tidak diimplementasikan sebagai sirkuit terpadu - ini hanya banyak chip untuk keperluan umum kecil (sirkuit mereka membutuhkan 6 dari 10 halaman diagram sirkuit perangkat).  Ketika membuat emulator, saya memutuskan untuk mengambil jalan pendek: alih-alih meniru bagian tertentu dari peralatan decoding video, saya hanya meniru perilakunya, menciptakan output yang sesuai dari data input dan tidak benar-benar mengkhawatirkan tentang bagaimana peralatan itu sendiri bekerja di tengah. <br><br>  Solusi yang disederhanakan seperti ini sangat cocok untuk mesin arcade yang terpisah, yang dirancang untuk menjalankan hanya satu program.  Jika permainan dimulai dan bekerja dengan benar, maka emulasi dapat dianggap "cukup baik." <br><br>  Selain itu, pendekatan yang disederhanakan ini merupakan perbedaan penting dari emulasi sebagian besar komputer di rumah: beberapa game memerlukan emulasi yang lebih akurat daripada yang lain, misalnya, mesin seperti C64 atau Amstrad CPC perlu emulasi yang sangat tepat hingga siklus clock, sehingga sistem video dari beberapa game dan grafik demo bekerja dengan benar. <br><br>  Ini juga berarti bahwa CPU saya yang sudah jadi dan emulator chip suara sebenarnya merupakan pekerjaan tambahan untuk Bomb Jack, misalnya, bekerja dengan CPU Z80 dengan implementasi fraksinasi siklus mesin adalah pembunuhan yang berlebihan, fragmentasi yang lebih sederhana dan lebih cepat pada level instruksi sudah cukup. <br><br><h2>  Papan utama </h2><br>  Biasanya hal pertama yang saya coba cari tahu ketika menulis emulator baru adalah skema alokasi memori (di mana area ROM dan RAM, memori video dan alamat khusus atau port input / output). <br><br>  Hanya ada satu chip "menarik" di papan utama Bomb Jack - CPU Z80 yang beroperasi pada 4 MHz.  Semua ruang yang tersisa di papan utama ditempati oleh peralatan decoding video (dengan pengecualian sepasang RAM dan chip ROM). <br><br>  Ruang alamat 16-bit adalah sebagai berikut: <br><br><ul><li>  <strong>0000..7FFF</strong> : ROM 32 KB </li><li>  <strong>8000..8FFF</strong> : 4 KB dari RAM tujuan umum </li><li>  <strong>9000..93FF</strong> : Memori video 1 KB </li><li>  <strong>9400..97FF</strong> : RAM warna 1 KB </li><li>  <strong>9820..987F</strong> : 96 byte RAM sprite </li><li>  <strong>9C00..9CFF</strong> : 256 palet warna RAM </li><li>  <strong>9E00, B000..B005, B800</strong> : port input-output </li><li>  <strong>C000..DFFF</strong> : ROM <strong>8KB</strong> </li></ul><br>  Area port I / O adalah sebagai berikut.  Beberapa port hanya untuk menulis, beberapa hanya untuk read-only, dan beberapa memiliki fungsi yang berbeda saat membaca dan menulis kepada mereka: <br><br><ul><li>  <strong>9E00</strong> : tulis: nomor gambar latar belakang saat ini, baca: - </li><li>  <strong>B000</strong> : baca: status joystick pemain 1, tulis: aktifkan / nonaktifkan topeng NMI </li><li>  <strong>B001</strong> : baca: status pemain 2 joystick, tulis: - </li><li>  <strong>B002</strong> : baca: koin dan tombol Mulai, tulis: - </li><li>  <strong>B003</strong> : baca: pengawas CPU, tulis: ??? </li><li>  <strong>B004</strong> : baca: sakelar dip 1, tulis: sakelar layar </li><li>  <strong>B005</strong> : baca: sakelar dip 2, tulis: - </li><li>  <strong>B800</strong> : tulis: perintah kartu suara, baca: - </li></ul><br>  Berikut ini layak disebutkan di sini: <br><br><ul><li>  Perangkat ini memiliki BANYAK ROM (40 Kbytes), dan sangat sedikit RAM (sekitar 7 Kbytes, dan hanya 4 Kbytes di antaranya adalah "RAM untuk keperluan umum") </li><li>  Hanya 2 Kbytes yang dialokasikan untuk RAM tampilan, dibagi menjadi dua fragmen 1 Kbyte, yang tampaknya sangat kecil untuk tampilan penuh warna 256x256, di mana, tampaknya, warna-warna tersebut diatur pixel demi pixel </li><li>  Ini adalah sistem I / O dalam skema alokasi memori! </li></ul><br>  I / O dalam skema alokasi memori sedikit tidak biasa untuk mesin Z80, karena salah satu keunggulan Z80 adalah ruang alamat 16-bit yang terpisah untuk I / O.  Ini dilakukan untuk menghemat ruang alamat memori yang berharga.  I / O dalam skema alokasi memori biasanya ditemukan di komputer dengan prosesor 6502. <br><br>  Melihat diagram sirkuit menegaskan ini: pin IORQ tidak terdeteksi pada CPU papan utama, hanya pin MREQ yang terhubung (yang digunakan untuk menginisialisasi membaca atau menulis ke memori): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/99e/3d8/a5899e3d8384702517d0c7fe6c0de436.png" alt="Bom jack iorq"></div><br>  Ini berarti bahwa kita tidak perlu khawatir tentang permintaan I / O untuk fungsi pengatur waktu CPU dari papan utama di emulator, tetapi hanya berurusan dengan permintaan memori. <br><br>  Setelah mempelajari diagram sirkuit, saya menemukan detail menarik lainnya tentang CPU dari papan utama: <br><br>  Hanya pin NMI yang terhubung, sedangkan pin INT selalu mempertahankan sinyal clock tingkat tinggi / tetap tidak aktif (ini berarti bahwa interupsi bertopeng "biasa" tidak dieksekusi, dan hanya interupsi tanpa topeng yang terjadi): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/393/acf/cb8/393acfcb88d846cc868e2fa0e490fbbd.png" alt="Bom jack iorq"></div><br>  Ini juga cukup tidak biasa untuk mobil dengan Z80.  Di semua komputer rumahan berbasis Z80 yang saya gunakan untuk menangani, yang terjadi adalah sebaliknya - mereka hanya menggunakan interupsi maskable dan tidak pernah menggunakan yang non-maskable.  Z80 interupsi bertopeng adalah peningkatan yang sangat fleksibel dan serius dibandingkan dengan sistem interupsi primitif dari "ayah tidak sah" -nya - Intel 8080, atau pesaingnya - MOS 6502. Tetapi peningkatan fleksibilitas ini juga lebih sulit untuk diterapkan dalam peralatan (kecuali sebagai sumber interupsi chip lain dari keluarga Z80 digunakan, di mana sudah ada protokol interupsi built-in yang kompleks ketika dihubungkan dengan bus). <br><br>  Oh well, cukup detail tentang peralatannya, ayo beralih ke emulator! <br><br><h2>  Prosedur boot </h2><br>  Langkah selanjutnya setelah menentukan konfigurasi memori adalah menyambungkan CPU yang diemulasi ke skema alokasi memori yang diemulasi, merekam beberapa jenis visualisasi dari isi memori video, dan memulai siklus CPU. <br><br>  Anehnya, pendekatan kasar semacam itu sering cukup untuk melalui prosedur pemuatan dan menampilkan <em>sesuatu</em> di layar.  Saat merancang emulator Bom Jack, saya hanya mengambil konten memori video 1KB dalam rentang dari 0x9000 hingga 0x93FF sebagai matriks 32x32 byte.  Ketika byte adalah 0, saya membuat blok piksel hitam 8x8, dan sebaliknya - blok piksel putih. <br><br>  Lalu saya hanya menjalankan CPU yang ditiru dan berharap yang terbaik.  Lihat!  Beberapa jenis gambar yang dapat dibaca muncul: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17d/7c2/198/17d7c2198881dbfd40978e26d832aaca.png" alt="Booting jack bom 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3b/e04/b97/d3be04b970ff2c8b5905ed3f7f757a51.png" alt="Booting jack bom 2"></div><br>  Gambar atas terlihat seperti layar pengujian perangkat keras saat boot, dan bagian bawah terlihat seperti layar catatan skor yang muncul setelah prosedur boot selesai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f6/5ae/4b9/0f65ae4b9d00fa43e2da7582b9ceb5f3.png" alt="Booting jack bom 3"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/649/5c8/db1/6495c8db1d035484ef03e32902f28cdf.png" alt="Booting jack bom 4"></div><br>  ... tetapi diputar 90 derajat (yang logis, karena layar mesin arcade sering dalam orientasi "potret" vertikal). <br><br>  Hebat, awalnya menjanjikan! <br><br>  Langkah selanjutnya adalah mencari cara mengubah blok putih ini menjadi piksel warna ... (dan ini adalah langkah besar, detailnya dijelaskan di bawah ini pada bagian tentang decoding video). <br><br>  Pada awalnya semuanya berjalan cukup cepat, pada layar tes, piksel dan warna ditampilkan selama pemuatan (kemudian saya perhatikan bahwa decoding warna benar-benar salah, namun ...): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/ecd/757/2c3ecd757e603194698f6f93b71e3127.png" alt="Booting jack bom 5"></div><br>  Tapi ketika layar rekam muncul, saya mendapat layar hitam.  Meretas warna latar belakang sehingga "bukan hitam", saya menemukan bahwa piksel diberikan, tetapi seluruh palet warna hitam.  Hmm ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e81/dac/2e4/e81dac2e4796b7bf90d43a711a52f37e.png" alt="Booting jack bom 5"></div><br>  Setelah melihat layar ini selama beberapa menit, saya ingat bahwa beberapa warna pada layar highscore adalah animasi, dan ketika ada animasi, harus ada semacam pengatur waktu.  Sumber logis waktu dalam konfigurasi peralatan ini adalah sinyal tampilan VSYNC, dan VSYNC terhubung ke pin NMI CPU (atau lebih tepatnya, bukan VSYNC, tetapi VBLANK, yang merupakan momen singkat antara sinyal VSYNC dan berkas sinar katoda yang bergerak ke sudut kiri atas). <br><br>  Dan saya belum menerapkan semua ini ... <br><br>  Malam berikutnya, ketika saya menambahkan versi pertama pemrosesan NMI ke emulasi Z80 dan menghubungkannya ke counter pertama vsync / vblank dalam fungsi pengatur waktu CPU papan utama, banyak hal tiba-tiba mulai terjadi! <br><br>  Pertama, warna muncul di layar rekaman, dan beberapa di antaranya dianimasikan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/163/661/72d/16366172d4eb6b8e2342acbbd74a64ac.png" alt="Bom Jack NMI 1"></div><br>  Setelah beberapa detik, sesuatu yang lebih menarik dimulai!  Skor tinggi menghilang dan visualisasi aneh dari peta pertama ditampilkan.  Sudah jelas bahwa ini adalah mode demo dari mesin arcade untuk menarik perhatian - saya melihat beberapa bom dengan animasi warna yang menghilang ketika Bom Jack imajiner melompat pada peta yang mengumpulkan bom-bom ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/cd6/81d/d60cd681dedbdfbf4329410e0014f9f0.png" alt="Bom Jack NMI 2"></div><br>  Warnanya masih benar-benar salah, namun PROGRESS! <br><br>  Ini adalah waktu yang tepat untuk melakukan decoding video lainnya: <br><br><h2>  Besi video </h2><br>  Pada pandangan pertama, peralatan pemrosesan video di Bomb Jack tampak sangat kuat untuk mesin 8-bit dari tahun 1984: meskipun resolusi hanya 256x256 piksel, secara bersamaan dapat menampilkan 128 (dari 4096) warna, dan membuat hingga 24 sprite perangkat keras (ukuran 16x16) atau 32x32) dengan warna piksel demi piksel. <br><br>  Komputer rumahan 8-bit pada waktu itu memiliki resolusi layar yang kira-kira sama, tetapi mereka memiliki banyak batasan warna.  Pembatasan ini sangat jelas terlihat ketika membandingkan versi Bomb Jack untuk ZX Spectrum dan Amstrad CPC dengan versi untuk mesin arcade: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi untuk ZX Spectrum</a> memiliki resolusi piksel yang cukup baik (256x192), tetapi sangat sedikit warna, dan itu menderita dari efek "konflik warna" khas Spectrum (meskipun pengembang melakukan yang terbaik untuk membuat ini tidak begitu terlihat): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46d/176/fff/46d176fffb8404ad696883849dd880d1.png" alt="Jack bom zx"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi untuk Amstrad CPC</a> lebih penuh warna, tetapi untuk mendapatkan lebih banyak warna, pengembang harus beralih ke mode tampilan resolusi rendah (160x200).  Sebagai akibatnya, Jack dan monster-monster berubah menjadi sekelompok piksel yang tak terbaca: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/f33/3d8/bbdf333d8e4d8d44735047f99e53b49c.png" alt="Bom jack cpc"></div><br>  Bandingkan ini dengan versi untuk mesin arcade, yang memiliki resolusi piksel yang sama dengan ZX Spectrum, tetapi dengan lebih banyak warna <em>dan</em> peningkatan resolusi warna piksel-demi-piksel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/112/ac5/69f/112ac569f11f32d6c1ed4836bb8c2b51.png" alt="Bom jack arcade"></div><br>  Yang menarik di sini adalah bahwa versi arcade memiliki grafik yang lebih baik, bukan karena ia bekerja pada perangkat keras yang lebih kuat (memiliki lebih banyak ROM untuk menyimpan lebih banyak data grafik, tetapi "daya komputasi" hampir sama), tetapi karena pengembang perangkat dapat fokus pada pembuatan mesin khusus untuk satu jenis permainan tertentu dan mereka tidak perlu membuat komputer rumah universal untuk penggunaan umum. <br><br>  Berikut cara kerja perangkat keras layar (setidaknya dalam interpretasi tingkat tinggi saya): <br><br><h2>  Tampilan tiga lapis </h2><br>  Sinyal video Bomb Jack yang sudah jadi digabungkan dari tiga lapisan: lapisan latar belakang, lapisan depan dan lapisan sprite. <br><br>  Sistem lapisan seperti itu memiliki dua keunggulan utama: <br><br><ul><li>  Ini mengimplementasikan kompresi gambar perangkat keras yang agak rumit untuk menghasilkan gambar penuh warna "resolusi tinggi" dari sejumlah kecil data. </li><li>  Ini secara signifikan mengurangi jumlah pekerjaan CPU yang diperlukan untuk memperbarui elemen layar dinamis (bahkan pada frekuensi 4 MHz, CPU 8-bit tidak memiliki daya yang cukup untuk memindahkan sejumlah objek pada layar 256x256 dengan frekuensi 60 Hz) </li></ul><br>  Video besi sangat berbeda dari yang saya lihat di komputer rumahan 8-bit, tetapi di kelas tambahan MAME umum untuk jenis peralatan ini diterapkan, jadi saya dapat berasumsi bahwa itu sangat umum di mesin arcade. <br><br><h3>  Lapisan latar belakang </h3><br>  Lapisan latar belakang dapat membuat 1 dari 5 gambar latar belakang tertanam dalam ROM.  Gambar latar belakang dipilih dengan menulis nilai dari 1 hingga 5 di alamat 0x9E00 (tampaknya nilai 0 khusus dan menjadikan latar belakang yang benar-benar hitam). <br><br>  Bahkan, tampaknya peralatan tersebut mampu membuat 7 gambar yang berbeda, tetapi hanya 5 yang digunakan dalam permainan. Diam-diam, saya berharap untuk menemukan data gambar yang sebelumnya tidak terdeteksi dalam ROM.  Namun sayang, mereka tidak ada di sana (ya, mungkin saya bukan yang pertama mencari mereka di sana). <br><br>  Inilah yang tampak seperti lapisan latar belakang peta pertama tanpa dua lapisan lainnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afe/75a/2c7/afe75a2c7386bb48fb3e90e2a24a655e.png" alt="Latar belakang jack bom"></div><br>  Lapisan latar belakang dirakit dari ubin <strong>16x16</strong> piksel. <br><br>  Keuntungan membangun gambar latar belakang dari ubin adalah ubin yang sama dapat digunakan beberapa kali, sehingga lebih sedikit data yang dapat disimpan dalam ROM.  Perhatikan bahwa langit biru, bagian piramida, dan pasir di bawah piramida menggunakan ubin yang sama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/613/0ee/4226130ee4b597ccbeccebbce664dbdf.png" alt="Ubin latar belakang jack bom"></div><br>  Untuk menghemat memori, peralatan lapisan latar menerapkan trik lain - ubin dapat diputar secara horizontal.  Saya hampir melewatkan ini dalam implementasi saya karena saya berasumsi bahwa perangkat lunak tidak menggunakan fungsi perangkat keras ini, tetapi melihat bug kecil di latar belakang kartu ketiga: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/397/d5c/22d397d5c5b984b8a7b1e7c53e5abd34.png" alt="Latar belakang jack bom 3"></div><br>  Saya menggunakan trik yang sama pada peta kelima, tetapi di sini agak sulit untuk diperhatikan jika Anda tidak tahu apa yang harus dicari: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/82d/430/4af82d430deab8804a795ac9fb142b87.png" alt="Latar belakang jack bom 5"></div><br><br><h3>  Lapisan depan: </h3><br>  Di atas lapisan latar belakang adalah "lapisan depan", yang menjadikan semua bagian layar tetap, yang harus diperbarui oleh CPU (terutama teks, platform, dan bom).  Tata letak dibaca dari RAM (dari fragmen RAM 1-KB dan RAM warna 1-KB). <br><br>  Inilah tampilan lapisan depan terisolasi dari peta pertama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/874/5ac/fa8/8745acfa89c446ba9b5a9d9e719c8d31.png" alt="Latar depan jack bom"></div><br>  Lapisan depan juga terdiri dari ubin (serta latar belakang), tetapi menggunakan ubin 8x8 yang lebih kecil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/e26/f94/5a9e26f94d1d9e0df0f50f4f1d1beb78.png" alt="Ubin latar belakang jack bom"></div><br>  Keuntungan utama membagi latar belakang dan depan menjadi lapisan-lapisan terpisah adalah bahwa CPU tidak perlu khawatir tentang menyimpan dan mengembalikan piksel latar belakang saat membuat atau menghapus elemen depan. <br><br><h3>  Lapisan sprite </h3><br>  Akhirnya, sprite perangkat keras ditampilkan di atas lapisan depan.  Segala sesuatu yang bergerak di sekitar layar diimplementasikan dalam sprite.  Peralatan Bom Jack dapat membuat hingga 24 sprite, dan setiap sprite dapat memiliki ukuran 16x16 atau 32x32 piksel.  Dalam hal ini, sprite dapat diposisikan dengan akurasi pixel-by-pixel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/66e/5a0/27666e5a0a266d28babf72dafe2e66bc.png" alt="Sprite jack bom"></div><br><br><h2>  8x8 decoder ubin </h2><br>  Inti dari peralatan decoding video adalah palet warna dengan 128 elemen dan decoder ubin 8x8 piksel.  Tugas decoder ubin adalah untuk menghasilkan indeks palet warna 7-bit untuk masing-masing 64 piksel ubin. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubin 8x8 ini adalah blok bangunan untuk semua yang ada di layar - ubin latar 16x16, ubin lapisan depan 8x8, dan sprite perangkat keras 16x16 atau 32x32. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah diagram blok decoder ubin 8x8 ini untuk menampilkan lapisan depan (seperti yang saya mengerti):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/d6e/5d9/e79d6e5d9b5019923a37bc14658e8ec4.jpg" alt="Dekode Bom Jack Tile"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penjelasan diagram blok top-down: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses decoding dimulai di atas dengan membaca byte "kode ubin" dari memori video (disusun sebagai matriks kode ubin 32x32) dan byte terpisah dari RAM warna (juga matriks 32x32). </font><font style="vertical-align: inherit;">Mendapatkan kode ubin dan warna dari memori video hanya terjadi untuk lapisan depan, tetapi saya menambahkannya untuk membuat gambar secara keseluruhan lebih dimengerti. </font><font style="vertical-align: inherit;">Decoder ubin 8x8 itu sendiri hanya membutuhkan ubin dan kode warna pada input.</font></font></li><li>             .         (         ).         ,       ,    (       ). </li><li>       8   ,     8  (   ).            ,  ,       8x8  24    (3   ). </li><li>    64    7- .  3         ,   4  —    .  ,  ,           16 «»,     8 .        8     . </li><li>  7- ,        ,    12-  RGB-    (4    ).            (  ,  ,       ;   ,          ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah skema decoding ubin umum yang digunakan oleh masing-masing dari tiga lapisan tampilan, tetapi decoding dari setiap lapisan sedikit berbeda: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lapisan depan sebenarnya dapat membuat 512 ubin 8x8 berbeda. </font><font style="vertical-align: inherit;">Ini membutuhkan kode ubin 9-bit, tetapi memori video hanya menyediakan 8 bit per ubin. </font><font style="vertical-align: inherit;">Bit kesembilan "dipinjam" dari bit kelima dari nilai warna (karena hanya 4 bit dari nilai warna yang digunakan untuk membangun indeks palet warna, 4 bit lagi tetap untuk keperluan lain). </font><font style="vertical-align: inherit;">Jika semua 3 bit dari lapisan bit ubin 8x8 sama dengan nol, maka piksel depan dianggap transparan, dan piksel latar belakang “bersinar melalui” itu.</font></font></li><li>      16x16,     16x16=256     256           (512   ).    ,     16x16      8x8,        .   ,      ;      «»   :   7   ,    . </li><li>       16x16   32x32 ,       4  16   8x8    .  ,    16x16  96 ,    32x32 —    384    .       ,   3      ,    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk lebih memahami bagaimana lapisan bit ubin terlihat, saya menulis sebuah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">program C</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kecil </font><font style="vertical-align: inherit;">yang mengubah ubin ROM ke file PNG (3 bit per piksel dikonversi ke 8 level abu-abu). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini menunjukkan ubin ROM dari lapisan depan. </font><font style="vertical-align: inherit;">Kami melihat angka dan data font teks, ubin platform, bom (dibagi dua), bagian logo dari screensaver Bom Jack, dan jumlah pengganda skor yang muncul di bagian atas layar (omong-omong, semuanya diputar 90 derajat, karena seluruh layar juga diputar ):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/681/ca4/fec/681ca4fec37418dffeb4d601b9e787cf.png" alt="ROM Bom Jack Foreground Tile"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, pertimbangkan ubin ROM latar belakang. </font><font style="vertical-align: inherit;">Itu tidak terlihat sangat jelas, karena apa yang kami amati sebenarnya decoding 16x16 ubin menjadi 8x8 ubin. </font><font style="vertical-align: inherit;">Setiap ubin 16x16 dibuat dari empat ubin 8x8 yang berdekatan. </font><font style="vertical-align: inherit;">Tetapi Anda dapat mengenali bagian dari kuil Yunani dari peta 2, kastil dari peta 3 dan gedung pencakar langit dari peta 4.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/fa9/86d/ebcfa986da9add0a45acc02b54bcb69e.png" alt="ROM Latar Belakang Tile Bom Jack"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan akhirnya, ubin sprite ROM. </font><font style="vertical-align: inherit;">Sprite 16x16 menempati bagian atas, dan 32x32 sprite menempati bagian bawah.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/974/01e/44497401e4d25c7915f1c15c9fb9f4ac.png" alt="ROM Bom Jack Sprite Tile"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retasan menarik screen saver Bomb Jack adalah bahwa logo tersebut dirangkai dari ubin depan dan sprite. </font><font style="vertical-align: inherit;">Saya pikir para pengembang kehabisan ROM ubin depan, tetapi ada sedikit ruang tersisa di ROM sprite:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/939/bd5/b69/939bd5b6999622ee26e337f033087234.png" alt="Bom Jack Splash 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d9/fef/f2a/6d9feff2acdd4ee2aaa63b8dc4226692.png" alt="Bom Jack Splash 2"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/bb9/072/819bb90727322463b2c8a9196f6f74c2.png" alt="Bom Jack Splash 3"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peralatan sprite </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peralatan sprite Bomb Jack sangat kuat dibandingkan dengan apa yang digunakan di komputer rumah pada waktu itu: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu bisa membuat hingga 24 sprite perangkat keras. </font><font style="vertical-align: inherit;">Tampaknya tidak ada batasan jumlah sprite per baris pemindaian.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprite dapat memiliki ukuran 16x16 piksel atau 32x32 piksel </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setiap sprite dapat memilih satu dari 16 slot 8 warna dalam palet warna yang sama </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprite memiliki resolusi warna pixel-by-pixel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setiap sprite dapat diputar secara vertikal atau horizontal </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setiap sprite dapat memilih salah satu dari 128 gambar sprite yang di-flash dalam ROM. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat mendekode piksel dan sprite dari sistem sprite, ubin dasar 8x8 yang sama digunakan seperti pada latar belakang dan lapisan depan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribut sprite terletak di kisaran alamat dari 0x9820 hingga 0x987F - 96 byte, 4 byte per sprite. </font><font style="vertical-align: inherit;">Sejauh yang saya lihat, area ini hanya untuk merekam; </font><font style="vertical-align: inherit;">setidaknya CPU tidak melakukan akses baca ke rentang memori ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap sprite dijelaskan oleh 4 byte:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : jika diatur, maka ini adalah sprite 32x32, jika tidak 16x16</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 6..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 7 bit untuk mengatur kode ubin sprite yang digunakan untuk mencari lapisan bit dari gambar sprite di ubin ROM.</font></font></li></ul></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : jika diatur, sprite terbalik secara horizontal</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 6</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : jika diatur, sprite dibalik secara vertikal</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 3..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 4 bit untuk mengatur nilai warna untuk decoder ubin</font></font></li></ul><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Posisi sprite sumbu-X pada layar</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : posisi sprite pada layar di sepanjang sumbu Y</font></font></li></ul><br>  Tidak jelas apa yang dilakukan bit 4 dan 5 dari byte 1, komentar di MAME mengatakan ini: <br><br> <code>e ? (,    ) <br> f ? (,     (B)?)</code> <br> <br><h2>  Port Memori I / O </h2><br>  Beberapa catatan tentang port input / output papan utama.  Seperti yang dinyatakan di atas, port I / O terlihat seperti ini: <br><br><ul><li>  <strong>9E00</strong> : tulis: nomor gambar latar belakang saat ini, baca: - </li><li>  <strong>B000</strong> : baca: status joystick pemain 1, tulis: aktifkan / nonaktifkan topeng NMI </li><li>  <strong>B001</strong> : baca: status pemain 2 joystick, tulis: - </li><li>  <strong>B002</strong> : baca: koin dan tombol Mulai, tulis: - </li><li>  <strong>B003</strong> : baca: pengawas CPU, tulis: ??? </li><li>  <strong>B004</strong> : baca: sakelar dip 1, tulis: sakelar layar </li><li>  <strong>B005</strong> : baca: sakelar dip 2, tulis: - </li><li>  <strong>B800</strong> : tulis: perintah kartu suara, baca: - </li></ul><br>  Alamat 0x9E00 (pemilihan gambar latar belakang) yang telah kita pertimbangkan di atas, dan alamat 0xB800 (kartu suara perintah) akan kita bahas di bagian selanjutnya.  Tetap alamat dari 0xB000 hingga 0xB005: <br><br>  Membaca dari alamat 0xB000 dan 0xB001 mengembalikan keadaan saat ini dari dua joystick.  Set byte yang menunjukkan sakelar joystick tertutup: <br><br><ul><li>  <strong>bit 0</strong> : arah yang benar </li><li>  <strong>bit 1</strong> : arah kiri </li><li>  <strong>bit 2</strong> : arah ke atas </li><li>  <strong>bit 3</strong> : arah bawah </li><li>  <strong>bit 4</strong> : tombol melompat ditekan </li></ul><br>  3 bit yang tersisa diabaikan. <br><br>  Membaca dari 0xB002 mengembalikan status akseptor koin dan tombol Mulai: <br><br><ul><li>  <strong>bit 0</strong> : pemain 1 koin dilemparkan </li><li>  <strong>bit 1</strong> : pemain 2 koin dilemparkan </li><li>  <strong>bit 2</strong> : tombol mulai pemain 1 </li><li>  <strong>bit 3</strong> : tombol mulai 2 pemain </li></ul><br>  Membaca dari alamat 0xB004 dan 0xB005 mengembalikan status dip switch yang digunakan untuk mengkonfigurasi perilaku mesin arcade: <br><br><ul><li>  <strong>B004</strong> : <br><ul><li>  <strong>bit 0,1</strong> : berapa banyak "permainan" yang diberikan untuk satu koin (1, 2, 3 atau 5) </li><li>  <strong>bit 2,3</strong> : sama untuk pemain 2 </li><li>  <strong>bits 4,5</strong> : berapa banyak nyawa per game (3, 4, 5 atau 2) </li><li>  <strong>bit 6</strong> : lokasi mesin arcade: "meja koktail" atau "vertikal". </li><li>  <strong>bit 7</strong> : apakah akan memutar suara dalam mode siaga </li></ul></li><li>  <strong>B005</strong> : <br><ul><li>  <strong>bit 3.4</strong> : tingkat kesulitan 1 (kecepatan burung) </li><li>  <strong>bits 5,6</strong> : kesulitan 2 (jumlah dan kecepatan musuh) </li><li>  <strong>bit 7</strong> : frekuensi kemunculan koin tertentu </li></ul></li></ul><br>  Akhirnya, membaca dari alamat <strong>B003</strong> mengimplementasikan pengawas perangkat lunak.  CPU harus sering membaca dari alamat ini, jika tidak mesin arcade akan melakukan reset perangkat keras.  Jika karena alasan tertentu game mogok, peralatan akan secara otomatis reboot. <br><br>  Anda dapat menulis ke beberapa alamat port I / O: <br><br><ul><li>  <strong>B000</strong> : apakah akan menghasilkan NMI selama vblank;  tampaknya dinonaktifkan hanya selama prosedur booting </li><li>  <strong>B004</strong> : balikkan seluruh layar;  Saya belum pernah bertemu penggunaan fungsi ini, tapi saya punya teori tentang hal itu (lihat di bawah) </li></ul><br>  Fungsinya membalik layar agak membingungkan, karena ketika bermain game, saya tidak pernah melihat penggunaannya.  Namun, saya punya firasat tentang apa yang dia lakukan, tetapi untuk mengkonfirmasinya, Anda perlu menulis kode.  Ketika mesin arcade berada dalam konfigurasi "meja koktail", dua pemain duduk saling berhadapan.  Oleh karena itu, saya menyarankan bahwa ketika permainan beralih dari pemain 1 ke pemain 2, fungsi ini membalik layar.  Namun, saya belum menerapkan mode dua pemain di emulator. <br><br><h2>  Papan suara </h2><br>  Kartu suara itu sendiri adalah komputer berfitur lengkap dengan CPU Z80 (beroperasi pada frekuensi 3 MHz), tiga chip suara (AY-38910 beroperasi pada frekuensi 1,5 MHz), serta RAM dan ROM.  Skema alokasi memori kartu suara terlihat cukup sederhana: <br><br><ul><li>  <strong>0000..2000</strong> : 8 Kbytes ROM </li><li>  <strong>4000..4400</strong> : 1 KB RAM </li><li>  <strong>6000</strong> : perintah suara dari papan utama </li></ul><br>  Karena tidak ada yang menarik dalam skema alokasi memori di atas alamat 0x8000, kontak alamat paling atas dari CPU bahkan tidak terhubung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2f/4ea/35e/b2f4ea35ee4d2861ea1baa502da10837.png" alt="Bom Jack Sound A15"></div><br>  Alamat khusus 0x6000 adalah port I / O (kait 8-bit) yang terletak di memori, yang tidak sesuai dengan RAM nyata.  Ini adalah port yang sama yang terletak di papan utama di 0xB800.  Ini adalah saluran komunikasi antara kartu utama dan kartu suara. <br><br>  Tiga chip suara dikendalikan oleh instruksi output Z80 ini, bukan melalui port memori.  AY-3-8910 hanya memiliki dua port I / O terbuka, yang pertama digunakan untuk menyimpan nomor register, dan yang kedua digunakan untuk menulis atau membaca isi register yang ditentukan oleh port pertama. <br><br>  Rangkaian I / O adalah sebagai berikut: <br><br><ul><li>  <strong>0x00</strong> : chip suara pertama: daftar pilihan </li><li>  <strong>0x01</strong> : chip suara pertama: akses ke register yang dipilih </li><li>  <strong>0x10</strong> : chip suara kedua: daftar pilihan </li><li>  <strong>0x11</strong> : chip suara kedua: akses ke register yang dipilih </li><li>  <strong>0x80</strong> : chip suara ketiga: pilihan register </li><li>  <strong>0x81</strong> : chip suara ketiga: akses ke register yang dipilih </li></ul><br>  Beberapa kata tentang chip suara AY-3-8910: <br><br>  Ini adalah perangkat yang cukup standar, sangat populer di komputer rumah pada waktu itu (misalnya, di Amstrad CPC, ZX Spectrum 128, di komputer MSX dan banyak lainnya).  AY-3-8910 melahirkan banyak variasi dan klon (misalnya, Yamaha YM2149, yang dengan sendirinya menjadi dasar dari seluruh keluarga chip suara yang lebih kuat). <br><br>  AY-3-8910 memiliki 3 saluran sinyal persegi panjang, satu generator derau yang dapat dicampur dengan tiga saluran, dan satu generator amplop.  Karena hanya ada satu generator amplop untuk ketiga saluran, itu tidak terlalu berguna, dan sebagian besar permainan menggunakan CPU untuk memodulasi nada dan volume. <br><br>  Ini berarti bahwa chip AY-3-8910 memerlukan lebih banyak intervensi CPU untuk membuat suara berkualitas tinggi (tidak seperti chip SID yang lebih berdiri sendiri, misalnya, di komputer C64). <br><br>  Sungguh menakjubkan melihat apa yang dapat dilakukan pada tiga chip suara yang cukup sederhana dan CPU yang mengontrolnya.  Musik dan efek suara dari Bomb Jack jauh lebih kaya daripada yang saya dengar di kebanyakan game komputer rumahan. <br><br>  Satu-satunya hal yang sangat menarik dalam kartu suara ini adalah cara ia menerima perintah dari papan utama. <br><br><h2>  Kait perintah suara </h2><br>  "Sound latch" adalah penyimpanan byte tunggal (latch 8-bit) yang umum untuk kartu utama dan kartu suara.  Kait terikat ke alamat 0xB800 di papan utama dan ke alamat 0x6000 pada kartu suara. <br><br>  Ketika interupsi NMI dinyalakan menggunakan VSYNC, kartu suara melakukan rutinitas layanan interupsi yang sangat sederhana, yang membaca kait perangkat keras, menulisnya ke alamat memori normal dan menetapkan "bit sinyal", yang memberi tahu "loop utama" bahwa perintah suara baru telah diterima: <br><br><pre> <code class="plaintext hljs"> ex af,af' ;0066 exx ;0067 ld hl,04390h ;0068 set 0,(hl) ;006b ld a,(06000h) ;006d ld (04391h),a ;0070 exx ;0073 ex af,af' ;0074 retn ;0075</code> </pre> <br>  Metode aktivasi kontak NMI sedikit berbeda dari metode papan utama: <br><br>  Di papan utama, pin NMI menjadi aktif selama VBLANK run time. <br><br>  Namun, pada kartu suara, NMI diaktifkan ketika VSYNC dipicu, dan tetap aktif tidak selama VBLANK, tetapi sampai prosedur layanan interupsi membaca data dari kait di 0x6000. <br><br>  Ketika peralatan mengenali pembacaan dari alamat 0x6000, ia melakukan dua operasi kode keras: <br><br><ul><li>  isi klip suara diatur ulang ke 0 </li><li>  Kontak NMI menjadi tidak aktif </li></ul><br>  Bahkan, ini adalah penghapusan sederhana dari bouncing kontak, yang tidak memungkinkan satu perintah suara dieksekusi dua kali. <br><br>  Satu-satunya pertanyaan tetap: seberapa sering papan utama menulis perintah baru (karena cara untuk menerapkan persaingan dua papan tergantung pada ini). <br><br>  Setelah debugging dengan printf, saya menemukan bahwa papan utama merekam paling banyak satu perintah suara per 60 Hz frame.  Ini sangat menyederhanakan struktur "siklus utama" dari emulator. <br><br>  Masalah kerja bersama dari dua komputer yang dicontoh terpisah yang harus saling bertukar data adalah bahwa emulasi satu komputer hanya efektif jika dapat melakukan banyak siklus pada satu waktu tanpa gangguan. <br><br>  Misalnya, kasus terburuk adalah: <br><br><ul><li>  kami menjalankan satu instruksi di komputer 1 </li><li>  kami menjalankan satu instruksi di komputer 2 </li><li>  ulangi ... </li></ul><br>  Emulator Z80 saya tidak dioptimalkan untuk keluar dan memasukkan emulasi untuk setiap instruksi, karena dalam hal ini ia harus masuk ke memori dan memuat dari memori keadaan CPU pada awal dan akhir setiap instruksi.  Jika CPU dapat memproses banyak instruksi tanpa gangguan, maka Anda dapat menyimpan (sebagian besar) status CPU dalam register dan mengatur ulang status ke memori pada instruksi terakhir. <br><br>  Yaitu, situasi ideal adalah ini: kami melakukan sistem yang ditiru tanpa gangguan di seluruh kerangka sistem host (untuk CPU dengan frekuensi 4 MHz dan pada 60 Hz ini berarti sekitar 67 ribu siklus per frame, atau di suatu tempat dari 3 ribu hingga 16 ribu instruksi Z80). <br><br>  Ketika bekerja dengan Bomb Jack, saya perlu memastikan bahwa papan utama tidak merekam perintah baru sebelum kartu suara dapat membaca perintah terakhir.  Sebelum saya mengetahui bahwa papan utama mencatat tidak lebih dari satu perintah per frame, saya menganggap perlunya membuat antrian perintah yang kompleks yang akan mencegat rekaman di kait suara papan utama dan menyimpan nomor siklus dan byte perintah dalam antrian. <br><br>  Kemudian, pada saat kartu suara mengeksekusi frame-nya, itu akan mengambil perintah baru dari antrian perintah ketika nomor siklus perintah tercapai. <br><br>  Sistem seperti itu akan bekerja dan menjadi "benar", tetapi akan sangat meningkatkan kompleksitas kode. <br><br>  Pada akhirnya, saya memutuskan untuk menggunakan solusi yang lebih sederhana tanpa antrian.  Karena papan utama hanya mencatat satu perintah per frame, saya menjalankan eksekusi secara bergantian pada dua komputer sehingga masing-masing melakukan dua irisan waktu per frame: <br><br><ul><li>  lakukan paruh pertama frame pada papan utama </li><li>  lakukan paruh pertama frame pada kartu suara </li><li>  lakukan paruh kedua frame pada papan utama </li><li>  lakukan paruh kedua frame pada kartu suara </li></ul><br>  Ini memastikan bahwa kartu suara dengan benar melihat setiap perintah yang direkam oleh papan utama, dan pada saat yang sama dapat menjalankan setiap emulasi untuk ribuan siklus. <br><br>  Tentu saja, fakta bahwa sistem host beroperasi pada frame rate 60 Hz adalah asumsi yang sangat berani :) <br><br><h2>  Dan yang terakhir ... </h2><br>  Fakta menarik terakhir tentang versi emulator di WebAssembly: <br><br>  Ukuran terkompresi dari semua file yang diunduh saat menjalankan emulator di WebAssembly <br>  kira-kira sama dengan 113 Kbytes: <br><br><ul><li>  sekitar 2,5 Kbytes untuk HTML, CSS, dan "tulisan tangan" JS </li><li>  26,8 kb per file JS runtime emscripten </li><li>  83,7 KB per file .wasm </li></ul><br>  File WASM berisi ROM built-in dari mesin arcade. <br><br>  Terkompresi, ROM ini menempati 112 Kbytes. <br><br>  Artinya, <strong>seluruh</strong> emulator terkompresi dengan ROM terintegrasi menempati volume yang hampir sama dengan ROM yang tidak terkompresi :) <br><br>  ROM 112-kilobyte dikompresi hingga sekitar 57 KB, yaitu ukuran sebenarnya dari kode terkompresi dalam WASM tanpa data ROM kurang dari 30 KB (84-57). <br><br>  Menurut saya cukup bagus untuk emulator penuh sistem 8-bit;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426291/">https://habr.com/ru/post/id426291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426281/index.html">Pendiri Amazon, Google, Microsoft dan Facebook kehilangan lebih dari $ 30 miliar selama jatuhnya pasar saham</a></li>
<li><a href="../id426283/index.html">WeChat di India: dari peluncuran yang kuat hingga hilangnya minat sepenuhnya</a></li>
<li><a href="../id426285/index.html">Di salah satu lokakarya AvtoVAZ ditemukan sebuah peternakan untuk ditambang</a></li>
<li><a href="../id426287/index.html">Mengirim ke bulan</a></li>
<li><a href="../id426289/index.html">Otentikasi asp .net inti melalui IdentityServer4</a></li>
<li><a href="../id426293/index.html">Sepeda apa yang harus dipilih untuk perjalanan kota, negara, dan ekstrem - tinjauan umum tentang model Airwheel dan Twitter</a></li>
<li><a href="../id426295/index.html">Seperti yang saya lihat browser yang sempurna</a></li>
<li><a href="../id426297/index.html">Kenapa saya tidak suka web modern</a></li>
<li><a href="../id426299/index.html">[Psikologi Desain] - Psikologi Desain</a></li>
<li><a href="../id426301/index.html">Apakah begitu di Eropa, ketika mereka menulis tentang itu?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>