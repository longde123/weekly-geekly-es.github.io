<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òëÔ∏è üßöüèø üç≥ Plug-in Java sans douleur üëø üîö üëâüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je voudrais vous expliquer comment cr√©er rapidement et facilement un framework d'application Java avec prise en charge du chargement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plug-in Java sans douleur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479478/">  Dans cet article, je voudrais vous expliquer comment cr√©er rapidement et facilement un framework d'application Java avec prise en charge du chargement dynamique de plugins.  Le lecteur pensera probablement imm√©diatement qu'une telle t√¢che a √©t√© r√©solue depuis longtemps, et vous pouvez simplement utiliser des frameworks pr√™ts √† l'emploi ou √©crire votre chargeur de classe, mais rien de tout cela ne sera requis dans la solution que je propose: <br><br><ul><li>  Nous n'avons pas besoin de biblioth√®ques ou de frameworks sp√©ciaux ( <a href="https://www.youtube.com/watch%3Fv%3DE3A6Z02TIjg">OSGi</a> , Guice, etc.) </li><li>  Nous n'utiliserons pas l'analyse de bytecode avec ASM et des biblioth√®ques similaires. </li><li>  Nous n'√©crirons pas notre chargeur de classe. </li><li>  Nous n'utiliserons pas de r√©flexion et d'annotations. </li><li>  Pas besoin de s'occuper du chemin de classe pour trouver des plugins.  Nous ne toucherons pas du tout au chemin de classe. </li><li> De plus, nous n'utiliserons pas XML, YAML ou tout autre langage d√©claratif pour d√©crire les points d'extension (points d'extension dans les plugins). </li></ul><br>  Cependant, il y a encore une exigence - une telle solution ne fonctionnera que sur Java 9 ou sup√©rieur.  Parce qu'il sera bas√© sur des <a href="https://www.youtube.com/watch%3Fv%3DJ1fHBhFvmco">modules et des services</a> . <br><a name="habracut"></a><br>  Commen√ßons donc.  Nous formulons le probl√®me plus sp√©cifiquement: <br><blockquote> Vous devez impl√©menter un cadre d'application minimal qui, au d√©marrage, chargera les plugins utilisateur √† partir du dossier <code>plugins</code> . </blockquote><br>  Autrement dit, l'application assembl√©e devrait ressembler √† ceci: <br><br><pre> <code class="bash hljs">plugin-app/ plugins/ plugin1.jar plugin2.jar ... core.jar ‚Ä¶</code> </pre> <br>  Commen√ßons par le module de <code>core</code> .  Ce module est au c≈ìur de notre application, c'est-√†-dire en fait notre framework. <br><br><div class="spoiler">  <b class="spoiler_title">Pour ceux qui appr√©cient le temps, le projet termin√© est disponible sur GitHub.</b>  <b class="spoiler_title">Instructions de montage.</b> <div class="spoiler_text">  <a href="https://github.com/orionll/plugin-app">Lien</a> <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/orionll/plugin-app <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> plugin-app mvn verify <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> core/target java --module-path core-1.0-SNAPSHOT.jar --module core</code> </pre> </div></div><br>  Cr√©ez les 4 fichiers Java suivants dans le module: <br><br><pre> <code class="bash hljs">core/ src/main/java/ org/example/pluginapp/core/ IService.java BasicService.java Main.java module-info.java</code> </pre> <br>  Le premier fichier, <code>IService.java</code> est le fichier qui d√©crit notre point d'extension.  D'autres plugins pourront alors contribuer √† ce point d'expansion (¬´contribution¬ª).  Il s'agit du principe standard de cr√©ation d'applications plug-in, appel√© <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">principe d'inversion de d√©pendance</a> (Dependency Inversion).  Ce principe est bas√© sur le fait que le noyau ne d√©pend pas de classes sp√©cifiques, mais d'interfaces. <br><br>  J'ai donn√© au point d'extension le nom abstrait <code>IService</code> , car je d√©montre maintenant un concept exclusivement.  En r√©alit√©, il peut s'agir de n'importe quel point d'extension sp√©cifique, par exemple, si vous √©crivez un √©diteur graphique, cela peut √™tre l'effet du traitement d'image, par exemple <code>IEffectProvider</code> , <code>IEffectContribution</code> ou autre chose, selon la fa√ßon dont vous pr√©f√©rez nommer les points d'extension.  Dans le m√™me temps, l'application elle-m√™me contiendra un ensemble d'effets de base, et les d√©veloppeurs tiers pourront √©crire des effets suppl√©mentaires plus sophistiqu√©s et les fournir sous forme de plug-ins.  L'utilisateur n'a qu'√† placer ces effets dans le dossier des <code>plugins</code> et red√©marrer l'application. <br><br>  Le fichier <code>IService.java</code> est le suivant: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;IService&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModuleLayer layer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServiceLoader .load(layer, IService.class) .stream() .map(Provider::get) .collect(Collectors.toList()); } }</code> </pre> <br>  Ainsi, <code>IService</code> n'est qu'une interface qui fait un travail abstrait <code>doJob()</code> (je le r√©p√®te, les d√©tails ne sont pas importants, en r√©alit√© ce sera quelque chose de concret). <br><br>  <code>getServices()</code> √©galement attention √† la deuxi√®me m√©thode <code>getServices()</code> .  Cette m√©thode renvoie toutes les impl√©mentations de l'interface <code>IService</code> trouv√©es dans cette couche de module et ses parents.  Nous en parlerons plus en d√©tail plus tard. <br><br>  Le deuxi√®me fichier, <code>BasicService.java</code> , est l'impl√©mentation de base de l'interface <code>IService</code> .  Il sera toujours pr√©sent, m√™me s'il n'y a pas de plugins dans l'application.  En d'autres termes, le <code>core</code> n'est pas seulement le noyau, mais aussi en m√™me temps un plugin pour lui-m√™me, qui sera toujours charg√©.  Le fichier <code>BasicService.java</code> ressemble √† ceci: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Basic service"</span></span>); } }</code> </pre> <br>  Pour plus de simplicit√©, <code>doJob()</code> simplement la cha√Æne <code>"Basic service"</code> et c'est tout. <br><br>  Ainsi, pour le moment, nous avons l'image suivante: <br><br><img src="https://habrastorage.org/webt/du/0f/fd/du0ffdkzy6bqmyc6rvqj6p-jw7w.png"><br><br>  Le troisi√®me fichier, <code>Main.java</code> , est l'endroit o√π la m√©thode <code>main()</code> est impl√©ment√©e.  Il y a un peu de magie dedans, pour comprendre ce dont vous avez besoin pour savoir ce qu'est une couche de module. <br><br><h2>  √Ä propos des couches de modules </h2><br>  Lorsque Java lance l'application, tous les modules de la plate-forme + modules r√©pertori√©s dans l'argument <code>--module-path</code> (et √©galement le <code>--module-path</code> , le cas √©ch√©ant) tombent dans la couche dite de <code>Boot</code> .  Dans notre cas, si nous compilons le module core.jar et <code>java --module-path core.jar --module core</code> partir de la ligne de commande, alors au moins les modules <code>java.base</code> et <code>core</code> seront dans la couche <code>Boot</code> : <br><br><img src="https://habrastorage.org/webt/z5/ar/n-/z5arn-jtfurxwqjja-fxrbdfjbu.png"><br><br>  La couche de <code>Boot</code> est toujours pr√©sente dans n'importe quelle application Java, et c'est la configuration la plus petite possible.  La plupart des applications existent dans une seule couche de modules.  Cependant, dans notre cas, nous voulons faire un chargement dynamique des plugins depuis le dossier <code>plugins</code> .  Nous pourrions simplement forcer l'utilisateur √† corriger la ligne de lancement de l'application afin qu'il ajoute lui-m√™me les plugins n√©cessaires √† <code>--module-path</code> , mais ce ne sera pas la meilleure solution.  Surtout les gens qui ne sont pas programmeurs et ne comprennent pas pourquoi ils doivent grimper quelque part et r√©parer quelque chose pour une chose aussi simple. <br><br>  Heureusement, il existe une solution: Java vous permet de cr√©er vos propres couches de modules lors de l'ex√©cution, ce qui chargera les modules de l'endroit dont nous avons besoin.  Pour nos besoins, une nouvelle couche pour les plugins sera suffisante, qui aura une couche de <code>Boot</code> tant que parent (toute couche doit avoir un parent): <br><br><img src="https://habrastorage.org/webt/1-/yd/5i/1-yd5ikax42qfadybbu1uqbnkgo.png"><br><br>  Le fait que la couche plug-in ait la couche <code>Boot</code> comme parent signifie que les modules de la couche plug-in peuvent r√©f√©rencer les modules de la couche <code>Boot</code> , mais pas l'inverse. <br><br>  Donc, sachant maintenant ce qu'est une couche de module, vous pouvez enfin regarder le contenu du fichier <code>Main.java</code> : <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Path pluginsDir = Paths.get(<span class="hljs-string"><span class="hljs-string">"plugins"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      plugins ModuleFinder pluginsFinder = ModuleFinder.of(pluginsDir); //  ModuleFinder      plugins       List&lt;String&gt; plugins = pluginsFinder .findAll() .stream() .map(ModuleReference::descriptor) .map(ModuleDescriptor::name) .collect(Collectors.toList()); //  ,      (   ) Configuration pluginsConfiguration = ModuleLayer .boot() .configuration() .resolve(pluginsFinder, ModuleFinder.of(), plugins); //      ModuleLayer layer = ModuleLayer .boot() .defineModulesWithOneLoader(pluginsConfiguration, ClassLoader.getSystemClassLoader()); //     IService       Boot List&lt;IService&gt; services = IService.getServices(layer); for (IService service : services) { service.doJob(); } } }</span></span></code> </pre> <br>  Si c'est la premi√®re fois que vous regardez ce code, cela peut sembler tr√®s compliqu√©, mais c'est une fausse sensation en raison du grand nombre de nouvelles classes inconnues.  Si vous comprenez un peu la signification des <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/ModuleFinder.html">classes ModuleFinder</a> , <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/Configuration.html">Configuration</a> et <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html">ModuleLayer</a> , alors tout se met en place.  Et puis, il n'y a que quelques dizaines de lignes!  C'est toute la logique qui est √©crite une fois. <br><br><h2>  Descripteur de module </h2><br>  Il y a un autre (quatri√®me) fichier que nous n'avons pas consid√©r√©: <code>module-info.java</code> .  Il s'agit du fichier le plus court contenant la d√©claration de notre module et une description des services (points d'extension): <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> core { <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> org.example.pluginapp.core; uses IService; provides IService with BasicService; }</code> </pre> <br>  La signification des lignes de ce fichier doit √™tre √©vidente: <br><br><ul><li>  Premi√®rement, le module exporte le package <code>org.example.pluginapp.core</code> que les plugins puissent h√©riter de l'interface <code>IService</code> (sinon <code>IService</code> ne serait pas accessible en dehors du module <code>core</code> ). </li><li>  Deuxi√®mement, il annonce qu'il utilise l' <code>IService</code> . </li><li>  Troisi√®mement, il dit qu'il fournit une impl√©mentation du service <code>IService</code> via la classe <code>BasicService</code> . </li></ul><br>  La d√©claration du module √©tant √©crite en Java, nous b√©n√©ficions d'avantages tr√®s importants: <i>v√©rifications du compilateur et garanties statiques</i> .  Par exemple, si nous avions fait une erreur dans le nom des types ou indiqu√© un paquet inexistant, nous l'aurions obtenu tout de suite.  Dans le cas de certains OSGi, nous n'aurions aucun contr√¥le au moment de la compilation, car la d√©claration des points d'extension serait √©crite en XML. <br><br>  Ainsi, le cadre est pr√™t.  Essayons de l'ex√©cuter: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Basic service</code> </pre> <br>  Qu'est-il arriv√©? <br><br><ol><li>  Java a essay√© de trouver les modules dans le dossier des <code>plugins</code> et n'en a trouv√© aucun. </li><li>  Un calque vide a √©t√© cr√©√©. </li><li>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader a</a> commenc√© √† rechercher toutes les impl√©mentations d' <code>IService</code> . </li><li>  Dans la couche vide, il n'a trouv√© aucune impl√©mentation de service, car il n'y a pas de modules. </li><li>  Apr√®s cette couche, il a poursuivi sa recherche dans la couche parent (c'est-√†-dire la couche de <code>Boot</code> ) et a trouv√© une impl√©mentation de <code>BasicService</code> dans le module <code>core</code> . </li><li>  Toutes les impl√©mentations trouv√©es avaient la m√©thode <code>doJob()</code> appel√©e.  Puisqu'une seule impl√©mentation a √©t√© trouv√©e, seul le <code>"Basic service"</code> √©t√© imprim√©. </li></ol><br><h2>  √âcrire un plugin </h2><br>  Apr√®s avoir √©crit le c≈ìur de notre application, il est temps d'essayer d'√©crire des plugins pour cela.  <code>plugin1</code> deux plugins <code>plugin1</code> et <code>plugin2</code> : laissez le premier imprimer <code>"Service 1"</code> , le second - <code>"Service 2"</code> .  Pour ce faire, vous devez fournir deux impl√©mentations <code>plugin1</code> <code>plugin2</code> respectivement dans <code>plugin1</code> et <code>plugin2</code> : <br><br><img src="https://habrastorage.org/webt/-o/3n/4v/-o3n4vlwhx-vwqxn7jpkunlamjq.png"><br><br>  Cr√©ez le premier plugin avec deux fichiers: <br><br><pre> <code class="bash hljs">plugin1/ src/main/java/ org/example/pluginapp/plugin1/ Service1.java module-info.java</code> </pre> <br>  Fichier <code>Service1.java</code> : <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Service 1"</span></span>); } }</code> </pre> <br>  Fichier <code>module-info.java</code> : <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> plugin1 { <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> core; provides IService with Service1; }</code> </pre> <br>  Notez que <code>plugin1</code> d√©pend du <code>core</code> .  C'est le principe d'inversion de d√©pendance que j'ai mentionn√© plus t√¥t: le noyau ne d√©pend pas des plugins, mais vice versa. <br><br>  Le deuxi√®me plugin est compl√®tement similaire au premier, donc je ne le donnerai pas ici. <br><br>  Maintenant, collectons les plugins, mettons-les dans le dossier des <code>plugins</code> et ex√©cutons l'application: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Service 1 Service 2 Basic service</code> </pre> <br>  Hourra, les plugins ont √©t√© r√©cup√©r√©s!  Comment est-ce arriv√©: <br><br><ol><li>  Java a trouv√© deux modules dans le dossier <code>plugins</code> . </li><li>  Une couche a √©t√© cr√©√©e avec deux modules <code>plugins1</code> et <code>plugins2</code> . </li><li>  ServiceLoader a commenc√© √† rechercher toutes les impl√©mentations d' <code>IService</code> . </li><li>  Dans la couche plugin, il a trouv√© deux impl√©mentations du service <code>IService</code> . </li><li>  Apr√®s cela, il a continu√© √† rechercher dans la couche parent (c'est-√†-dire la couche de <code>Boot</code> ) et a trouv√© une impl√©mentation de <code>BasicService</code> dans le module <code>core</code> . </li><li>  Toutes les impl√©mentations trouv√©es avaient la m√©thode <code>doJob()</code> appel√©e. </li></ol><br>  Notez que c'est pr√©cis√©ment parce que la recherche de fournisseurs de services commence par les couches enfants, puis passe aux couches parentes, puis <code>"Service 1"</code> et <code>"Service 2"</code> imprim√©s en premier, puis <code>"Basic Service"</code> .  Si vous souhaitez que les services soient tri√©s de mani√®re √† ce que les services de base passent en premier, puis les plugins, vous pouvez modifier la m√©thode <code>IService.getServices()</code> en y ajoutant le tri (vous devrez peut-√™tre ajouter la <code>int getOrdering()</code> √† l'interface <code>IService</code> ). <br><br><h2>  R√©sum√© </h2><br>  J'ai donc montr√© comment organiser rapidement et efficacement une application plug-in Java qui poss√®de les propri√©t√©s suivantes: <br><br><ul><li>  <b>Simplicit√©:</b> pour les points d'extension et leurs liaisons, seules les fonctionnalit√©s Java de base (interfaces, classes et <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> ) sont utilis√©es, sans frameworks, r√©flexion, annotations et chargeurs de classe. </li><li>  <b>D√©clarabilit√©: les</b> points d'extension sont d√©crits dans les descripteurs de module.  Regardez simplement <code>module-info.java</code> et comprenez quels points d'extension existent et quels plugins contribuent √† ces points. </li><li>  <b>Garanties statiques:</b> en cas d'erreur dans les descripteurs de module, le programme ne compilera pas.  De plus, en bonus, si vous utilisez IntelliJ IDEA, vous recevrez des avertissements suppl√©mentaires (par exemple, si vous avez oubli√© d'utiliser <code>uses</code> et d'utiliser <code>ServiceLoader.load()</code> ) </li><li>  <b>S√©curit√©: le</b> syst√®me Java modulaire v√©rifie au d√©marrage que la configuration des modules est correcte et refuse d'ex√©cuter le programme en cas d'erreur. </li></ul><br>  Je le r√©p√®te, je n'ai montr√© que l'id√©e.  Dans une v√©ritable application de plug-in, il y aurait des dizaines √† des centaines de modules et des centaines √† des milliers de points d'extension. <br><br>  J'ai d√©cid√© de soulever ce sujet car depuis 7 ans, j'√©cris une application modulaire utilisant Eclipse RCP, dans laquelle le fameux OSGi est utilis√© comme syst√®me de plug-in et les descripteurs de plug-in sont √©crits en XML.  Nous avons plus d'une centaine de plugins et nous sommes toujours assis sur Java 8. Mais m√™me si nous passons √† une nouvelle version de Java, il est peu probable que nous utilisions des modules Java, car ils sont fortement li√©s √† OSGi. <br><br>  Mais si vous √©crivez une application plug-in √† partir de z√©ro, les modules Java sont l'une des options possibles pour sa mise en ≈ìuvre.  N'oubliez pas que les modules ne sont qu'un outil et non un objectif. <br><br><h2>  En bref sur moi </h2><br>  Je programme depuis plus de 10 ans (dont 8 en Java), je r√©ponds √† <a href="https://stackoverflow.com/users/706317/zhekakozlov">StackOverflow</a> et dirige mon propre <a href="https://t.me/miniJUG">canal en Telegram</a> d√©di√© √† Java. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479478/">https://habr.com/ru/post/fr479478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479462/index.html">S√©rialisation en C ++</a></li>
<li><a href="../fr479464/index.html">Tuyaux et filtres. Exemple d'application et d'impl√©mentation √† l'aide de Spring</a></li>
<li><a href="../fr479466/index.html">Habraiting 2019: statistiques et classement des meilleurs articles pour 2019</a></li>
<li><a href="../fr479468/index.html">Edge of Honesty et John Doe</a></li>
<li><a href="../fr479474/index.html">Pourquoi l'auto-organisation des √©quipes est-elle si importante dans Scrum et pourquoi il ne peut y avoir de managers</a></li>
<li><a href="../fr479480/index.html">SDK SARIF et ses erreurs</a></li>
<li><a href="../fr479482/index.html">SDK SARIF et ses erreurs</a></li>
<li><a href="../fr479486/index.html">Programmation h√©t√©rog√®ne et oneAPI Toolkit. Une conf√©rence improvis√©e d'experts Intel r√©pond √† vos questions</a></li>
<li><a href="../fr479488/index.html">D'un ordinateur portable - un serveur domestique avec alimentation redondante au routeur Mikrotik</a></li>
<li><a href="../fr479492/index.html">Informatique sans serveur bas√©e sur OpenWhisk, partie 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>