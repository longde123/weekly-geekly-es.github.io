<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèø üôçüèø ‚è±Ô∏è D√©bogage et d√©pannage dans la r√©plication de streaming PostgreSQL üìπ üåá üóæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La r√©plication de flux, apparue en 2010, est devenue l'une des fonctionnalit√©s r√©volutionnaires de PostgreSQL et √† l'heure actuelle, presque aucune in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©bogage et d√©pannage dans la r√©plication de streaming PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414111/">  La r√©plication de flux, apparue en 2010, est devenue l'une des fonctionnalit√©s r√©volutionnaires de PostgreSQL et √† l'heure actuelle, presque aucune installation n'est compl√®te sans l'utilisation de la r√©plication en streaming.  Il est fiable, facile √† configurer et peu exigeant pour les ressources.  Cependant, malgr√© toutes ses qualit√©s positives, au cours de son fonctionnement, divers probl√®mes et situations d√©sagr√©ables peuvent survenir. <br><br>  <strong>Alexey Lesovsky</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@lesovsky</a> ) √† Highload ++ 2017 a expliqu√© comment <strong>diagnostiquer divers types de probl√®mes √† l'</strong> aide d'outils int√©gr√©s et tiers <strong>et comment les r√©soudre</strong> .  Sous les coupes, le d√©codage de ce rapport, construit sur un principe en spirale: d'abord, nous listons tous les outils de diagnostic possibles, puis passons √† la liste des probl√®mes communs et √† leur diagnostic, puis voyons quelles mesures d'urgence peuvent √™tre prises, et enfin comment y faire face de mani√®re radicale. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/on2yVvKejwc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√Ä propos de l'orateur</strong> : Alexei Lesovsky, administrateur de base de donn√©es chez Data Egret.  L'un des sujets pr√©f√©r√©s d'Alexey dans PostgreSQL est la r√©plication en streaming et le travail avec les statistiques, donc le rapport de Highload ++ 2017 √©tait consacr√© √† la fa√ßon de trouver des probl√®mes en utilisant des statistiques et quelles m√©thodes utiliser pour les r√©soudre. <br><br><h2>  Plan <br></h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un peu de th√©orie, ou comment fonctionne la r√©plication dans PostgreSQL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Outils de d√©pannage ou ce que PostgreSQL et la communaut√© ont</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©pannage des cas:</a> <br><ul><li>  probl√®mes: leurs sympt√¥mes et diagnostic </li><li>  les d√©cisions </li><li>  mesures √† prendre pour que ces probl√®mes ne se posent pas. </li></ul></li></ol><br>  <strong>Pourquoi tout √ßa?</strong>  Cet article vous aidera √† mieux comprendre la r√©plication en streaming, √† d√©couvrir comment trouver et r√©soudre rapidement les probl√®mes afin de r√©duire le temps de r√©action aux incidents d√©sagr√©ables. <br><a name="habracut"></a><a name="replicationSql"></a><br><h2>  Un peu de th√©orie <br></h2><br>  PostgreSQL poss√®de une entit√© telle que Write-Ahead Log (XLOG), un journal des transactions.  <em>Presque</em> toutes les modifications apport√©es aux donn√©es et aux m√©tadonn√©es dans la base de donn√©es sont enregistr√©es dans ce journal.  Si un accident se produit soudainement, PostgreSQL d√©marre, lit le journal des transactions et restaure les modifications enregistr√©es des donn√©es.  Cela garantit la fiabilit√© - l'une des propri√©t√©s les plus importantes de tout SGBD et PostgreSQL. <br><br>  Le journal des transactions peut √™tre rempli de deux mani√®res: <br><br><ol><li>  Par d√©faut, lorsque les backends apportent des modifications √† la base de donn√©es (INSERT, UPDATE, DELETE, etc.), toutes les modifications sont enregistr√©es de mani√®re <strong>synchrone</strong> dans le journal des transactions: <br><ul><li>  Le client a envoy√© une commande COMMIT pour confirmer les donn√©es. <br></li><li>  Les donn√©es sont enregistr√©es dans le journal des transactions. <br></li><li>  Une fois la fixation effectu√©e, le contr√¥le est donn√© au backend et il peut continuer √† recevoir des commandes du client. <br></li></ul></li><li>  La deuxi√®me option est l' <strong>√©criture asynchrone</strong> dans le journal des transactions, lorsqu'un processus d'√©criture WAL d√©di√© distinct √©crit les modifications dans le journal des transactions avec un certain intervalle de temps.  De ce fait, une augmentation des performances du backend est obtenue, car il n'est pas n√©cessaire d'attendre la fin de la commande COMMIT. <br></li></ol><br>  Plus important encore, la r√©plication en streaming est bas√©e sur ce journal de transactions.  Nous avons plusieurs membres de r√©plication en streaming: <br><br><ul><li>  ma√Ætriser o√π tous les changements ont lieu; <br></li><li>  plusieurs r√©pliques qui acceptent le journal des transactions du ma√Ætre et reproduisent toutes ces modifications sur leurs donn√©es locales.  Il s'agit de la r√©plication en streaming. <br></li></ul><br>  Il convient de rappeler que tous ces journaux de transactions sont stock√©s dans le r√©pertoire pg_xlog dans $ DATADIR - le r√©pertoire contenant les principaux fichiers de donn√©es du SGBD.  Dans la 10√®me version de PostgreSQL, ce r√©pertoire a √©t√© renomm√© pg_wal /, car il n'est pas rare que pg_xlog / occupe beaucoup d'espace, et les d√©veloppeurs ou administrateurs qui le confondent sans le savoir avec les journaux, le suppriment n√©gligemment et tout devient mauvais. <br><br>  PostgreSQL dispose de plusieurs services d'arri√®re-plan impliqu√©s dans la r√©plication en streaming.  Regardons-les du point de vue du syst√®me d'exploitation. <br><br><ul><li>  Du c√¥t√© du processus ma√Ætre - exp√©diteur WAL.  Il s'agit d'un processus qui envoie des journaux de transactions aux r√©pliques, chaque r√©plique aura son propre exp√©diteur WAL. <br></li><li>  La r√©plique, √† son tour, ex√©cute le processus WAL Receiver, qui re√ßoit les journaux de transactions sur la connexion r√©seau de l'exp√©diteur WAL et les transmet au processus de d√©marrage. <br></li><li>  Le processus de d√©marrage lit les journaux et reproduit sur le r√©pertoire de donn√©es toutes les modifications enregistr√©es dans le journal des transactions. <br></li></ul><br><img src="https://habrastorage.org/webt/ek/g2/rd/ekg2rdtwkvfjw8hlpj0rhhzhogu.jpeg"><br>  Sch√©matiquement, cela ressemble √† ceci: <br><br><ul><li>  Les modifications sont √©crites dans les tampons WAL, qui seront ensuite √©crites dans le journal des transactions; <br></li><li>  Les journaux sont stock√©s dans le r√©pertoire pg_wal /; <br></li><li>  WAL Sender lit le journal des transactions √† partir du r√©f√©rentiel et les transmet sur le r√©seau; <br></li><li>  Le r√©cepteur WAL re√ßoit et stocke dans son stockage - dans le local pg_wal /; <br></li><li>  Le processus de d√©marrage lit tout ce qui est accept√© et se reproduit. <br></li></ul><br>  Le sch√©ma est simple.  La r√©plication de flux fonctionne de mani√®re assez fiable et a √©t√© parfaitement exploit√©e pendant de nombreuses ann√©es. <br><a name="tools"></a><br><h2>  Outils de d√©pannage <br></h2><br>  Voyons quels outils et utilitaires la communaut√© et PostgreSQL proposent pour √©tudier les probl√®mes rencontr√©s avec la r√©plication en streaming. <br><br><h3>  Outils tiers <br></h3><br>  Commen√ßons par des outils tiers.  Ces utilitaires sont d'un <strong>plan</strong> plut√¥t <strong>universel</strong> ; ils peuvent √™tre utilis√©s non seulement pour enqu√™ter sur les incidents li√©s √† la r√©plication en streaming.  Ce sont g√©n√©ralement des <strong>utilitaires de tout administrateur syst√®me</strong> . <br><br><ul><li>  <strong>haut</strong> du package procps.  En remplacement de top, vous pouvez utiliser tous les utilitaires tels que atop, htop et similaires.  Ils offrent des fonctionnalit√©s similaires. </li></ul><br>  Avec l'aide de top, nous examinons: l'utilisation des processeurs (CPU), la charge moyenne (charge moyenne) et l'utilisation de la m√©moire et de l'espace d'√©change. <br><br><ul><li>  iostat de sysstat et iotop.  Ces utilitaires indiquent l'utilisation des unit√©s de disque et les E / S cr√©√©es par les processus du syst√®me d'exploitation. </li></ul><br>  Avec l'aide d'iostat, nous examinons: l'utilisation du stockage, combien d'iops en ce moment, quel d√©bit sur les p√©riph√©riques, quels retards lors du traitement des demandes d'E / S (latence).  Ces informations assez d√©taill√©es sont extraites du syst√®me de fichiers procfs et sont fournies √† l'utilisateur sous forme visuelle. <br><br><ul><li>  nicstat est un analogue d'iostat, uniquement pour les interfaces r√©seau.  Dans cet utilitaire, vous pouvez observer l'utilisation des interfaces. </li></ul><br>  En utilisant nicstat, nous regardons: de m√™me, l'utilisation des interfaces, certaines erreurs qui se produisent sur les interfaces, le d√©bit est √©galement un utilitaire tr√®s utile. <br><br><ul><li>  pgCenter est un utilitaire pour travailler uniquement avec PostgreSQL.  Il affiche les statistiques PostgreSQL dans une interface de type sup√©rieur, et vous pouvez √©galement y voir des statistiques li√©es √† la r√©plication en streaming. </li></ul><br>  Avec l'aide de pgCenter, nous regardons: des statistiques sur la r√©plication.  Vous pouvez observer le d√©calage de r√©plication, l'√©valuer d'une mani√®re ou d'une autre et pr√©voir le travail futur. <br><br><ul><li>  perf est un utilitaire pour une enqu√™te plus approfondie sur les causes des "cliquetis souterrains", quand en fonctionnement il y a des probl√®mes √©tranges au niveau du code PostgreSQL. </li></ul><br>  Avec l'aide de la perf, nous recherchons: des coups souterrains.  Pour que perf fonctionne pleinement avec PostgreSQL, ce dernier doit √™tre compil√© avec des caract√®res de d√©bogage, afin que vous puissiez regarder la pile de fonctions dans les processus et quelles fonctions prennent le plus de temps CPU. <br><br>  Tous ces utilitaires sont n√©cessaires pour <strong>tester les hypoth√®ses</strong> qui surviennent lors du d√©pannage - o√π et ce qui ralentit, o√π et ce que vous devez corriger, v√©rifiez.  Ces utilitaires permettent de s'assurer que nous sommes sur la bonne voie. <br><br><h3>  Outils int√©gr√©s <br></h3><br>  Que propose PostgreSQL lui-m√™me? <br><br><h4>  Vues syst√®me <br></h4><br>  En g√©n√©ral, il existe de nombreux outils pour travailler avec PostgreSQL.  Chaque fournisseur qui fournit un support PostgreSQL propose ses propres outils.  Mais, en r√®gle g√©n√©rale, ces outils sont bas√©s sur des statistiques PostgreSQL internes.  √Ä cet √©gard, PostgreSQL fournit des vues syst√®me dans lesquelles vous pouvez effectuer diverses s√©lections et obtenir les informations dont vous avez besoin.  Autrement dit, en utilisant un client standard, g√©n√©ralement psql, nous pouvons effectuer des requ√™tes et voir ce qui se passe dans les statistiques. <br><br>  Il existe plusieurs vues du syst√®me.  Pour travailler avec la r√©plication en streaming et enqu√™ter sur les probl√®mes, nous n'avons besoin que de: pg_stat_replication, pg_stat_wal_receiver, pg_stat_databases, pg_stat_databases_conflicts et auxiliaire pg_stat_activity et pg_stat_archiver. <br><br>  Il y en a peu, mais cet ensemble suffit pour v√©rifier s'il y a des probl√®mes. <br><br><h4>  Fonctions d'assistance <br></h4><br>  En utilisant des fonctions auxiliaires, vous pouvez prendre des donn√©es √† partir de repr√©sentations du syst√®me statistique et les transformer en une forme plus pratique pour vous.  Les fonctions auxiliaires ne sont √©galement que quelques pi√®ces. <br><br><ul><li>  pg_current_wal_lsn () (l'ancien analogue de pg_current_xlog_location ()) est la fonction la plus n√©cessaire qui vous permet de voir la position actuelle dans le journal des transactions.  Un journal des transactions est une s√©quence continue de donn√©es.  En utilisant cette fonction, vous pouvez voir le dernier point, obtenir la position o√π le journal des transactions s'est arr√™t√© maintenant. <br></li><li>  pg_last_wal_receive_lsn (), pg_last_xlog_receive_location () est une fonction similaire √† ce qui pr√©c√®de, uniquement pour les r√©pliques.  La r√©plique re√ßoit le journal des transactions et vous pouvez voir la derni√®re position du journal des transactions re√ßue; <br></li><li>  pg_wal_lsn_diff (), pg_xlog_location_diff () est une autre fonction utile.  Nous lui donnons deux positions du journal des transactions, et elle montre diff - la distance entre ces deux points en octets.  Cette fonction est toujours utile pour d√©terminer le d√©calage entre le ma√Ætre et les r√©pliques en octets. <br></li></ul><br>  Une liste compl√®te des fonctions peut √™tre obtenue avec la m√©ta-commande psql: \ df * (wal | xlog | lsn | location) *. <br><br>  Vous pouvez le taper dans psql et voir toutes les fonctions que contiennent wal, xlog, Isn, location.  Il y aura environ 20 √† 30 fonctions de ce type et elles fourniront √©galement diverses informations sur le journal des transactions.  Je vous recommande de vous familiariser. <br><br><h4>  Utilitaire Pg_waldump <br></h4><br>  Avant la version 10.0, il s'appelait pg_xlogdump.  L'utilitaire pg_waldump est n√©cessaire lorsque nous voulons examiner les segments du journal des transactions, savoir quels enregistrements de ressources y sont arriv√©s et ce que PostgreSQL y a √©crit, c'est-√†-dire pour une √©tude plus d√©taill√©e. <br><br><blockquote>  Dans la version 10.0, toutes les vues syst√®me, fonctions et utilitaires qui comprenaient le mot xlog ont √©t√© renomm√©s.  Toutes les occurrences des mots xlog et location ont √©t√© remplac√©es respectivement par les mots wal et lsn.  La m√™me chose a √©t√© faite avec le r√©pertoire pg_xlog qui est devenu le r√©pertoire pg_wal. <br></blockquote><br>  L'utilitaire pg_waldump d√©code simplement le contenu des segments XLOG dans un format lisible par l'homme.  Vous pouvez voir ce que les soi-disant enregistrements de ressources tombent dans les journaux de segment pendant le travail de PostgreSQL, quels index et fichiers de tas ont √©t√© modifi√©s, quelles informations destin√©es √† la r√©serve y sont arriv√©es.  Ainsi, de nombreuses informations peuvent √™tre consult√©es √† l'aide de pg_waldump. <br><br><blockquote>  Mais il y a une clause de non-responsabilit√© qui est √©crite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> : pg_waldump peut afficher des donn√©es l√©g√®rement incorrectes lorsque PostgreSQL est en cours d'ex√©cution (peut donner des r√©sultats erron√©s lorsque le serveur est en cours d'ex√©cution - quoi que cela signifie) </blockquote><br>  Vous pouvez utiliser la commande: <br><br><pre><code class="sql hljs">pg_waldump -f - /wal_10 \ $(psql -qAtX - "<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_walfile_name(pg_current_wal_lsn())<span class="hljs-string"><span class="hljs-string">")</span></span></code> </pre> <br>  Il s'agit d'un analogue de la commande tail -f pour les journaux de transactions uniquement.  Cette commande affiche la fin du journal des transactions qui se produit en ce moment.  Vous pouvez ex√©cuter cette commande, elle trouvera le dernier segment avec l'entr√©e de journal de transactions la plus r√©cente, se connectera √† elle et commencera √† afficher le contenu du journal de transactions.  Une √©quipe un peu d√©licate, mais √ßa marche quand m√™me.  Je l'utilise souvent. <br><a name="cases"></a><br><h2>  D√©pannage des cas <br></h2><br>  Ici, nous examinons les probl√®mes les plus courants qui se posent dans la pratique des consultants, quels sympt√¥mes peuvent √™tre et comment les diagnostiquer: <br><br>  <strong>Les retards de r√©plication sont le probl√®me le plus courant</strong> .  Plus r√©cemment, nous avons eu une correspondance avec le client: <br><br><blockquote>  - <em>Nous avons interrompu la r√©plication ma√Ætre-esclave entre les deux serveurs.</em> <br><br>  - D√©calage d√©tect√© de 2 heures, pg_dump a d√©marr√©. <br><br>  - D' <em>accord, je vois.</em>  <em>Quel est notre d√©calage admissible?</em> <br><br>  - 16 heures √† max_standby_streaming_delay. <br><br>  <em>- Que se passera-t-il lorsque ce d√©calage sera d√©pass√©?</em>  <em>Sir√®ne hurlante?</em> <br><br>  - Non, les transactions seront battues et le rouleau WAL reprendra. <br></blockquote><br>  Nous avons des probl√®mes de d√©calage de r√©plication tout le temps, et presque chaque semaine nous les r√©solvons. <br><br>  <strong>Le gonflement du r√©pertoire pg_wal /</strong> o√π les segments du journal des transactions sont stock√©s est un probl√®me qui se produit moins fr√©quemment.  Mais dans ce cas, il est n√©cessaire de prendre des mesures imm√©diates afin que le probl√®me ne se transforme pas en situation d'urgence lorsque les r√©pliques tombent. <br><br>  <strong>Les longues requ√™tes</strong> qui s'ex√©cutent sur le r√©plica entra√Ænent des <strong>conflits lors de la r√©cup√©ration</strong> .  Il s'agit d'une situation o√π nous commen√ßons une sorte de chargement sur la r√©plique, vous pouvez ex√©cuter des requ√™tes de lecture sur les r√©pliques, et √† ce moment ces requ√™tes interf√®rent avec la reproduction du journal des transactions.  Il y a un conflit et PostgreSQL doit d√©cider d'attendre la fin de la requ√™te ou de la terminer et de continuer √† lire le journal des transactions.  Il s'agit d'un conflit de r√©plication ou d'un conflit de r√©cup√©ration. <br><br>  <strong>Processus de r√©cup√©ration: 100% d'utilisation du processeur - Le</strong> processus de r√©cup√©ration d'un journal des transactions sur les r√©pliques prend 100% du temps du processeur.  C'est aussi une situation rare, mais plut√¥t d√©sagr√©able, car  conduit √† une augmentation du retard de r√©plication et est g√©n√©ralement difficile √† √©tudier. <br><br><h3>  Retards de r√©plication <br></h3><br>  Les d√©calages de r√©plication se produisent lorsque la m√™me demande, ex√©cut√©e sur le ma√Ætre et sur la r√©plique, renvoie des donn√©es diff√©rentes.  Cela signifie que les donn√©es sont incoh√©rentes entre le ma√Ætre et les r√©pliques et qu'il y a un certain d√©calage.  La r√©plique doit reproduire une partie des journaux de transactions afin de rattraper l'assistant.  Le sympt√¥me principal ressemble exactement √† ceci: il y a une requ√™te et ils retournent des r√©sultats diff√©rents. <br><br>  <strong>Comment rechercher de tels probl√®mes?</strong> <br><br><ul><li>  Il existe une vue de base sur l'assistant et sur les r√©pliques - <strong>pg_stat_replication</strong> .  Il affiche des informations sur tous les exp√©diteurs WAL, c'est-√†-dire sur les processus qui envoient des journaux de transactions.  Chaque r√©plique aura une ligne distincte qui affiche des statistiques pour cette r√©plique particuli√®re. <br></li><li>  La fonction auxiliaire <strong>pg_wal_lsn_diff ()</strong> vous permet de comparer diff√©rentes positions dans le journal des transactions et de calculer le m√™me d√©calage.  Avec son aide, nous pouvons obtenir des chiffres sp√©cifiques et d√©terminer o√π nous avons un grand d√©calage, o√π est un petit et d√©j√† r√©pondre en quelque sorte au probl√®me. <br></li><li>  La fonction <strong>pg_last_xact_replay_timestamp ()</strong> fonctionne uniquement sur la r√©plique et vous permet de voir l'heure √† laquelle la derni√®re transaction perdue a √©t√© effectu√©e.  Il existe une fonction now () bien connue qui montre l'heure actuelle, nous soustrayons l'heure qui nous est montr√©e par la fonction pg_last_xact_replay_timestamp () de la fonction now () et obtenons le d√©calage temporel. <br></li></ul><br>  Dans la 10√®me version de pg_stat_replication, des champs suppl√©mentaires sont apparus qui montrent le d√©calage d√©j√† sur l'assistant, donc cette m√©thode est d√©j√† obsol√®te, mais, n√©anmoins, elle peut √™tre utilis√©e. <br><br>  Il y a un petit pi√®ge.  S'il n'y a pas de transactions sur l'Assistant pendant une longue p√©riode et qu'il ne g√©n√®re pas de journaux de transactions, la derni√®re fonction affichera un d√©calage croissant.  En fait, le syst√®me est tout simplement inactif, il n'y a aucune activit√© dessus, mais en surveillant, nous pouvons voir que le d√©calage augmente.  Cet √©cueil m√©rite d'√™tre rappel√©. <br><br>  La vue est la suivante. <br><br><img src="https://habrastorage.org/webt/sb/jg/6k/sbjg6kswtdtymuecundldk180r8.jpeg"><br><br>  Il contient des informations sur chaque exp√©diteur WAL et plusieurs champs qui sont importants pour nous.  Il s'agit principalement de <strong>client_addr</strong> - l'adresse r√©seau de la r√©plique connect√©e (g√©n√©ralement une adresse IP) et un ensemble de champs <strong>lsn</strong> (dans les anciennes versions, il est appel√© emplacement), je vais en parler un peu plus loin. <br><br>  Dans la 10e version, des champs de <strong>d√©calage</strong> sont apparus - il s'agit d'un d√©calage exprim√© dans le temps, c'est-√†-dire un format plus lisible par l'homme.  Le d√©calage peut √™tre exprim√© en octets ou en temps - vous pouvez choisir ce que vous pr√©f√©rez. <br><br>  En r√®gle g√©n√©rale, j'utilise cette demande. <br><br><img src="https://habrastorage.org/webt/ff/8g/kv/ff8gkvz-kzdihuxabphcb0rfd4e.jpeg"><br><br>  Ce n'est pas la requ√™te la plus complexe que pg_stat_replication imprime dans un format plus pratique et compr√©hensible.  Ici, j'utilise les fonctions suivantes: <br><br><ul><li>  <strong>pg_wal_lsn_diff ()</strong> pour lire les diffs.  Mais entre quoi je pense que les diff√©rences sont?  Nous avons plusieurs champs - sent_lsn, write_lsn, flush_lsn, replay_lsn.  En calculant la diff√©rence entre le champ actuel et le champ pr√©c√©dent, nous pouvons comprendre avec pr√©cision o√π nous avons pris du retard, o√π exactement le retard se produit. <br></li><li>  <strong>pg_current_wal_lsn ()</strong> , qui montre la position actuelle du journal des transactions.  Nous regardons ici la distance entre la position actuelle dans le journal et celle envoy√©e - combien de journaux de transactions ont √©t√© g√©n√©r√©s mais pas envoy√©s. <br></li><li>  <strong>sent_lsn</strong> , <strong>write_lsn</strong> - c'est la quantit√© envoy√©e √† la r√©plique, mais non enregistr√©e.  Autrement dit, il est maintenant situ√© quelque part sur le r√©seau, ou il a √©t√© re√ßu par une r√©plique, mais n'a pas encore √©t√© √©crit des tampons r√©seau vers le stockage sur disque. <br></li><li>  <strong>write_lsn, flush_lsn</strong> - ceci est √©crit, mais n'a pas √©t√© √©mis par la commande fsync - comme s'il √©tait √©crit, mais peut √™tre situ√© quelque part dans la RAM, dans le cache de pages du syst√®me d'exploitation.  D√®s que nous faisons fsync, les donn√©es sont synchronis√©es avec le disque, acc√®dent au stockage persistant et tout semble fiable. <br></li><li>  <strong>replay_lsn, flush_lsn</strong> - donn√©es sauvegard√©es, fsync ex√©cut√©, mais pas r√©pliqu√©. <br></li><li>  <strong>current_wal_lsn</strong> et <strong>replay_lsn</strong> est une sorte de d√©calage total qui inclut toutes les positions pr√©c√©dentes. <br></li></ul><br><h4>  <strong>Quelques exemples</strong> <br></h4><br><img src="https://habrastorage.org/webt/7c/9n/tt/7c9nttg6yp-uyimrxa4ji3ll1ha.jpeg"><br><br>  La r√©plique 10.6.6.8 est mise en √©vidence ci-dessus.  Elle a un <strong>d√©calage en attente</strong> , elle a g√©n√©r√© des journaux de transactions, mais ils ne sont toujours pas envoy√©s et reposent sur le ma√Ætre.  Tr√®s probablement, il y a une sorte de probl√®me avec les performances du r√©seau.  Nous v√©rifierons cela en utilisant l'utilitaire nicstat. <br><br>  Nous lancerons nicstat, voir l'utilisation de l'interface, s'il y a des probl√®mes et des erreurs.  Nous pouvons donc tester cette hypoth√®se. <br><br><img src="https://habrastorage.org/webt/co/-m/fj/co-mfjznunlrsuurikvz7xy9gh0.jpeg"><br><br>  Le <strong>d√©calage d'√©criture est</strong> indiqu√© ci-dessus.  En fait, ce d√©calage est assez rare, je ne le vois presque pas comme grand.  Le probl√®me peut √™tre li√© aux disques, et nous utilisons l'utilitaire iostat ou iotop - nous examinons l'utilisation des stockages sur disque, dont les E / S sont cr√©√©es par les processus, puis nous d√©couvrons pourquoi. <br><br><img src="https://habrastorage.org/webt/to/xw/2j/toxw2jutr7yaof38fwbohph9lva.jpeg"><br><br>  <strong>Purger et relire les d√©calages</strong> - le plus souvent, le d√©calage se produit l√† lorsque le p√©riph√©rique de disque sur la r√©plique n'a pas le temps de simplement perdre toutes les modifications qui arrivent du ma√Ætre. <br><br>  Avec les utilitaires iostat et iotop, nous examinons √©galement ce qui se passe avec l'utilisation du disque et pourquoi les freins. <br><br>  Et le dernier <strong>total_lag</strong> est une m√©trique utile pour surveiller les syst√®mes.  Si notre seuil total_lag est d√©pass√©, une case √† cocher est lev√©e dans la surveillance, et nous commen√ßons √† enqu√™ter sur ce qui s'y passe. <br><br><h4>  <strong>Test d'hypoth√®se</strong> <br></h4><br>  Vous devez maintenant d√©terminer comment approfondir un probl√®me particulier.  J'ai d√©j√† dit que s'il s'agit d'un d√©calage r√©seau, nous devons v√©rifier si tout est en ordre avec le r√©seau. <br><br>  Maintenant, presque tous les h√©bergeurs fournissent 1 Gb / s ou m√™me 10 Gb / s, donc une <strong>bande passante obstru√©e est le sc√©nario le plus improbable</strong> .  En r√®gle g√©n√©rale, vous devez examiner les erreurs.  nicstat contient des informations sur les erreurs sur les interfaces, vous pouvez constater qu'il y a des probl√®mes avec les pilotes, soit avec la carte r√©seau elle-m√™me, soit avec les c√¢bles. <br><br>  Nous √©tudions <strong>les probl√®mes de stockage en</strong> utilisant iostat et iotop.  iostat est n√©cessaire pour visualiser l'image g√©n√©rale du stockage sur disque: recyclage des p√©riph√©riques, bande passante des p√©riph√©riques, latence.  iotop - pour une recherche plus pr√©cise, lorsque nous devons identifier le processus qui charge le sous-syst√®me de disque.  S'il s'agit d'une sorte de processus tiers, il peut simplement √™tre d√©tect√©, termin√© et peut-√™tre que le probl√®me dispara√Ætra. <br><br>  Tout d'abord, nous examinons <strong>les d√©lais de r√©cup√©ration et les conflits de r√©plication</strong> via top ou pg_stat_activity: quels processus sont en cours d'ex√©cution, quelles requ√™tes sont en cours d'ex√©cution, leur temps d'ex√©cution, leur dur√©e d'ex√©cution.  S'il s'agit de longues requ√™tes, nous examinons pourquoi elles fonctionnent longtemps, les photographions, les comprenons et les <strong>optimisons</strong> - nous examinerons les requ√™tes elles-m√™mes. <br><br>  S'il s'agit d'une <strong>grande quantit√© de journaux de transactions</strong> g√©n√©r√©s par l'assistant, nous pouvons le d√©tecter par <strong>pg_stat_activity</strong> .  Peut-√™tre que certains processus de sauvegarde y sont d√©marr√©s, une sorte de vide a √©t√© d√©marr√© (pg_stat_progress_vacuum) ou un point de contr√¥le est en cours d'ex√©cution.  Autrement dit, si trop de journaux de transactions sont g√©n√©r√©s et que la r√©plique n'a tout simplement pas le temps de la traiter, √† un moment donn√©, elle risque de tomber, et ce sera un probl√®me pour nous. <br><br>  Et bien s√ªr, <strong>pg_wal_lsn_diff ()</strong> pour d√©terminer le d√©calage et d√©terminer o√π nous avons le d√©calage sp√©cifiquement - sur le r√©seau, sur les disques ou sur les processeurs. <br><br><h4>  <strong>Options de solution</strong> <br></h4><br>  <strong>Probl√®mes de r√©seau / stockage</strong> <br><br>  Tout est assez simple ici, mais du point de vue de la configuration, cela n'est g√©n√©ralement pas r√©solu.  Vous pouvez serrer certains √©crous, mais en g√©n√©ral, il y a 2 options: <br><br><ul><li>  V√©rifier la charge de travail </li></ul><br>  V√©rifiez quelles demandes sont en cours d'ex√©cution.  Peut-√™tre que certaines migrations sont lanc√©es qui g√©n√®rent beaucoup de journaux de transactions, ou cela peut √™tre un transfert, une suppression ou une insertion de donn√©es.  <strong>Tout processus qui g√©n√®re des journaux de transactions peut entra√Æner un retard de transaction</strong> .  Toutes les donn√©es de l'assistant sont g√©n√©r√©es le plus rapidement possible, nous avons modifi√© les donn√©es, les avons envoy√©es √† la r√©plique et la r√©plique peut s'adapter ou √©chouer - cela ne concerne pas l'assistant.  Un d√©calage peut appara√Ætre ici et vous devez en faire quelque chose. <br><br><ul><li>  Mettre √† niveau le mat√©riel <br></li></ul><br>  L'option la plus stupide - peut-√™tre que nous avons rencontr√© les performances du fer, et vous avez juste besoin de le changer.  Il peut s'agir de vieux disques ou de SSD de mauvaise qualit√©, ou d'un plug in dans les performances d'un contr√¥leur RAID.  Ici, nous n'explorons plus la base elle-m√™me, mais v√©rifions les performances de nos glandes. <br><br>  <strong>D√©lais de r√©cup√©ration</strong> <br><br>  Si nous avons des conflits de r√©plication en raison de longues demandes, entra√Ænant une augmentation du d√©lai de relecture, la <strong>premi√®re chose que</strong> nous faisons est de <strong>tirer de longues demandes</strong> qui s'ex√©cutent sur la r√©plique, car elles retardent la lecture des journaux de transactions. <br><br>  Si les longues requ√™tes sont li√©es √† la non-optimalit√© de la requ√™te SQL elle-m√™me (nous le d√©couvrons en utilisant EXPLAIN ANALYZE), il vous suffit d'approcher cette requ√™te diff√©remment et de la r√©√©crire.  Ou il existe une option pour configurer une <strong>r√©plique distincte pour les requ√™tes de rapport</strong> .  Si nous faisons des rapports qui fonctionnent depuis longtemps, ils doivent √™tre soumis √† une r√©plique distincte. <br><br>  Il y a toujours la possibilit√© d' <strong>attendre</strong> .  Si nous avons une sorte de d√©calage au niveau de quelques kilo-octets ou m√™me des dizaines de m√©gaoctets, mais nous pensons que cela est acceptable, nous attendons simplement que la demande soit termin√©e et le d√©calage se r√©soudra automatiquement.  C'est aussi une option, et il arrive souvent qu'elle soit acceptable. <br><br>  <strong>WAL haut volume</strong> <br><br>  Si nous g√©n√©rons un grand volume de journaux de transactions, nous devons r√©duire ce <strong>volume par unit√© de temps</strong> , pour que la r√©plique doive moins m√¢cher les journaux de transactions. <br><br>  Cela se fait g√©n√©ralement <strong>via la configuration</strong> .  Solution partielle en d√©finissant le param√®tre full_page_writes = off.  Cette option active / d√©sactive l'enregistrement d'images compl√®tes de pages changeantes dans le journal des transactions.  Cela signifie que lorsque nous avons eu l'op√©ration de service d'√©criture d'un point de contr√¥le (CHECKPOINT), la prochaine fois que nous changerons un bloc de donn√©es dans la zone des tampons partag√©s, l'image compl√®te de cette page ira dans le journal des transactions, et pas seulement la modification elle-m√™me.  Avec toutes les modifications ult√©rieures sur la m√™me page, seules les modifications seront enregistr√©es dans le journal des transactions.  Et ainsi de suite jusqu'au prochain point de contr√¥le. <br><br>  Apr√®s le point de contr√¥le, nous enregistrons l'image compl√®te de la page, ce qui affecte le volume du journal des transactions enregistr√©.  S'il y a beaucoup de points de contr√¥le par unit√© de temps, disons que 4 points de contr√¥le sont effectu√©s par heure, et qu'il y aura beaucoup d'images en pleine page, ce sera un probl√®me.  Vous pouvez d√©sactiver l'enregistrement d'images compl√®tes et cela affectera le volume du WAL.  Mais encore une fois, c'est une demi-mesure. <br><br>  <i>Remarque: La recommandation de d√©sactiver full_page_writes doit √™tre soigneusement √©tudi√©e, car l'auteur a oubli√© de pr√©ciser lors du rapport que la d√©sactivation d'un param√®tre peut, dans certaines circonstances, se produire dans des situations d'urgence (endommagement du syst√®me de fichiers ou de son journal, √©criture partielle sur des blocs, etc.) fichiers de base de donn√©es potentiellement corrompus.</i>  <i>Par cons√©quent, soyez prudent, la d√©sactivation du param√®tre peut augmenter le risque de corruption des donn√©es dans les situations d'urgence.</i> <br><br>  Une autre demi-mesure consiste √† <strong>augmenter l'intervalle entre les points de contr√¥le</strong> .  Par d√©faut, le point de contr√¥le est effectu√© toutes les 5 minutes, ce qui est assez courant.  En r√®gle g√©n√©rale, cet intervalle est augment√© √† 30-60 minutes - c'est un temps tout √† fait acceptable pour lequel toutes les pages sales parviennent √† se synchroniser sur le disque. <br><br>  Mais la principale solution est, bien s√ªr, d' <strong>examiner notre charge de travail</strong> - quel type d'op√©rations lourdes se d√©roulent l√†-bas, associ√©es √† la modification des donn√©es, et, peut-√™tre, d'essayer de faire ces changements par lots. <br><br>  Supposons que nous ayons une table, nous voulons en supprimer plusieurs millions d'enregistrements.  La meilleure option n'est pas de supprimer ces millions √† la fois avec une seule demande, mais de les diviser en paquets de 100 √† 200 000 afin que, premi√®rement, de petites quantit√©s de WAL soient g√©n√©r√©es, deuxi√®mement, le vide a le temps de passer √† travers les donn√©es supprim√©es, et donc le d√©calage n'√©tait pas si grand et critique. <br><br><h3>  Gonflement pg_wal / <br></h3><br>  Maintenant, parlons de la fa√ßon dont vous pouvez constater que le r√©pertoire pg_wal / est enfl√©. <br><br>  En th√©orie, PostgreSQL le maintient toujours dans un √©tat optimal pour lui-m√™me au niveau de certains fichiers de configuration, et, en r√®gle g√©n√©rale, il ne doit pas d√©passer certaines limites. <br><br>  Il existe un param√®tre max_wal_size, qui d√©termine la valeur maximale.  De plus, il y a le param√®tre wal_keep_segments - un nombre suppl√©mentaire de segments que le ma√Ætre stocke pour la r√©plique si la r√©plique est soudainement indisponible pendant une longue p√©riode. <br><br>  Apr√®s avoir calcul√© la somme de max_wal_size et wal_keep_segments, nous pouvons approximativement estimer l'espace que le r√©pertoire pg_wal / occupera.  Si elle cro√Æt rapidement et occupe beaucoup plus d'espace que la valeur calcul√©e, cela signifie qu'il y a un probl√®me et que vous devez faire quelque chose. <br><br><h4>  Comment d√©tecter de tels probl√®mes? <br></h4><br>  Sur le syst√®me d'exploitation Linux, il existe la <strong>commande du -csh</strong> .  Nous pouvons simplement surveiller la valeur et surveiller le nombre de journaux de transactions que nous avons l√†-bas;  Gardez une √©tiquette calcul√©e, combien il doit et combien il prend r√©ellement, et r√©pondez en quelque sorte aux changements de nombres. <br><br>  Un autre endroit que nous regardons est les <strong>vues</strong> <strong>pg_replication_slots</strong> et <strong>pg_stat_archiver</strong> .  Les raisons les plus courantes pour lesquelles pg_wal / occupe beaucoup d'espace sont les emplacements de r√©plication oubli√©s ou l'archivage interrompu.  D'autres raisons ont √©galement leur place, mais dans ma pratique, elles √©taient tr√®s rares. <br><br>  Et, bien s√ªr, il y a toujours des erreurs dans les journaux PostgreSQL associ√©s √† la commande archive.  Malheureusement, il n'y aura pas d'autres raisons li√©es √† pg_wal / overflow.  Nous ne pouvons y d√©tecter que des erreurs d'archivage. <br><br><h4>  Options pour les probl√®mes: <br></h4><br>  <strong>CRUD</strong> lourd - lourdes op√©rations de rafra√Æchissement des donn√©es - lourd INSERT, DELETE, UPDATE, associ√© √† la modification de plusieurs millions de lignes.  Si PostgreSQL doit effectuer une telle op√©ration, il est clair qu'une grande quantit√© de journal des transactions sera g√©n√©r√©e.  Il sera stock√© dans pg_wal /, et cela augmentera l'espace occup√©.  C'est, encore une fois, comme je l'ai dit plus t√¥t, c'est une bonne pratique de simplement les diviser en packs et de mettre √† jour non pas la totalit√© de la baie, mais 100, 200, 300 000 chacun. <br><br>  <strong>Un emplacement de r√©plication oubli√© ou inutilis√©</strong> est un autre probl√®me courant.  Les gens utilisent souvent la r√©plication logique pour certaines de leurs t√¢ches: ils configurent des bus qui envoient des donn√©es √† Kafka, envoient des donn√©es √† une application tierce qui d√©code la r√©plication logique dans un autre format et les traite en quelque sorte.  <strong>La r√©plication logique fonctionne g√©n√©ralement via des emplacements</strong> .  Il se trouve que nous avons configur√© un emplacement de r√©plication, jou√© avec l'application, r√©alis√© que cette application ne nous convenait pas, d√©sactiv√© l'application, supprim√©e <strong>et les emplacements de r√©plication continuent de vivre</strong> . <br><br>  PostgreSQL pour chaque emplacement de r√©plication enregistre des segments du journal des transactions au cas o√π une application distante ou une r√©plique se connecte √† nouveau √† cet emplacement, puis l'assistant peut leur envoyer ces journaux des transactions. <br><br>  Mais le temps passe, personne ne se connecte √† l'emplacement, les journaux de transactions s'accumulent et occupent √† un moment donn√© 90% de l'espace.  Nous devons d√©couvrir ce que c'est, pourquoi tant d'espace est pris.  En r√®gle g√©n√©rale, cet emplacement oubli√© et inutilis√© doit simplement √™tre supprim√© et le probl√®me sera r√©solu.  Mais plus √† ce sujet plus tard. <br><br>  Une autre option pourrait √™tre une <strong>archive_command cass√©e</strong> .  Lorsque nous avons une sorte de r√©f√©rentiel de journal de transactions externe que nous conservons pour les t√¢ches de reprise apr√®s sinistre, une commande d'archivage est g√©n√©ralement configur√©e, moins souvent pg_receivexlog est configur√©.  La commande enregistr√©e dans archive_command est tr√®s souvent une commande distincte ou un script qui prend des segments du journal des transactions de pg_wal / et le copie dans le stockage d'archive. <br><br>  Il arrive que nous ayons effectu√© une sorte de mise √† niveau des packages syst√®me, par exemple, dans rsync, la version a chang√©, les indicateurs ont √©t√© mis √† jour ou modifi√©s, ou dans une autre commande qui a √©t√© utilis√©e dans la commande archive, le format a √©galement chang√© - et le script ou le programme lui-m√™me qui est sp√©cifi√© dans archive_command se casse.  Par cons√©quent, les archives cessent d'√™tre copi√©es. <br><br>  Si la commande archive a fonctionn√© avec une sortie diff√©rente de 0, un message √† ce sujet sera √©crit dans le journal et le segment restera dans le r√©pertoire pg_wal /.  <strong>Jusqu'√† ce que nous constations que notre √©quipe d'archives est en panne, les segments s'accumuleront</strong> et le lieu se terminera √©galement √† un moment donn√©. <br><br>  <strong>Ensemble de mesures d'urgence (100% d'espace utilis√©):</strong> <br><br> 1. <strong>   CRUD </strong> ,        ‚Äî pg_terminate_backend(). <br>    -  ,  , ,      ..       ,      pg_wal/,     . <br><br> 2. <strong>    </strong>    root ‚Äî reserved space ratio (ext filesystems). <br>       ext      ext     5%.  ,         ,  5% ‚Äî  . ,   ,     1%  ,     tune2fs -m 1.       PostgreSQL     ,    .      100%     . <br><br> 3. <strong>  </strong> (LVM, ZFS,...). <br>    LVM  ZFS,        LVM  ZFS,            ,   ,           .       ,   . <br><br> 4.    ‚Äî <strong>, , HE    pg_wal/</strong> . <br>          ,     ,   ,   .     ! PostgreSQL     ,   .     ,  ,   ,    . <br><br> , pg_xlog/   pg_wal/     ‚Äî  log    ,   , , ,  -   ‚Äî  ! <br><br><h4>    <br></h4><br>  ,         100%  CPU,      . <br><br>   <strong> workload  </strong> .    ,       ?  ,     - ,      -.         :   ,   tablespace,    tablespace. <br><br>   <strong> </strong> .       ,  ,    ,    , ,  ,            . <strong>   ‚Äî      .</strong> <br><br>   <strong>  checkpoints_segments/max_wal_size, wal_keep_segments</strong> .  ,    ,      ‚Äî 10-20   wal_keep_segments,     max_wal_size.  ,        .  PostgreSQL       pg_wal/  . <br><br>  <strong>  </strong>   pg_replication_slots ‚Äî     .   ,   <strong> </strong> ,        ‚Äî      .   ,    ,    .    . <br><br>      WAL,       ,  <strong>    pg_stat_archiver</strong> ,    . ,  <strong>  </strong> , ,    ,    . <br><br>    <strong>   checkpoint</strong> .       ,        ,      . , PostgreSQL        . <strong>   ,    checkpoint</strong> . <br><br><h3>       <br></h3><br>    ,   ,   ‚Äî        .   -             ,       .      ,         . <br><br> <strong> </strong> ‚Äî    PostgreSQL  : <br><br><ul><li> User was holding shared bufer pin for too long. <br></li><li> User query might have needed to see row versions that must be removed. <br></li><li> User was holding a relation lock for too long. <br></li><li> User was or might have been using table space that must be dropped. <br></li><li> User transaction caused bufer deadlock with recovery. <br></li><li> User was connected to a database that must be dropped. <br></li></ul><br>  2  ‚Äî    ,       ,      .   :  ,   ,      .        (  30 ),  <strong>PostgreSQL       </strong> ‚Äî  . <br><br>    .  ,    ,             .    -    ,     timeout     .     ‚Äî    ALTER,    ,    . <br><br>     .     ,  tablespace     ,            tablespace.   ,    ,  -   ‚Äî   . <br><br><h4> <strong> ?</strong> <br></h4><br>       <strong>pg_stat_databases, pg_stat_databases_conflicts</strong> .         ,    .     ,    . <br><br>  <strong>  </strong> ,       <strong> </strong> .  ,      .   ,    . ,       ,    ,    . <br><br><h4>  <strong>Que faire</strong> <br></h4><br>   ,    ‚Äî    : <br><br><ol><li> <strong> max_standby_streaming_delay</strong> (  ).     ,       .    <strong>   </strong> . <br></li><li> <strong> hot_stadby_feedback</strong> (  /).  ,  vacuum   - ,       .     <strong> bloat  </strong> .     ,    ,  ,   hot_stadby_feedback  . <br></li><li>     DBA     ‚Äî  <strong>  </strong> .   <strong> </strong> ,    .  ,    ,     ,   -    ,  . <br></li><li>  , ,  ,   ,  DBA ‚Äî  <strong>     </strong> , ,  .    max_standby_streaming_delay  .       ,   .      ,  ,    ,  .  <strong>   </strong> ‚Äî    ,     . <br></li></ol><br><h2> Recovery process: 100% CPU usage <br></h2><br>  ,  ,    , <strong> 100%   </strong> .  ,      ,      100%.  ,    pg_stat_replication,  ,     replay,       ,    . <br><br> <strong></strong>  : <br><br><ul><li> <strong>top</strong> ‚Äî       ‚Äî    100% CPU usage  recovery process; <br></li><li> <strong>pg_stat_replication</strong> ‚Äî  ,   ,     . <br></li></ul><br><h4> <strong>   </strong> <br></h4><br>      ,    .  ,     : <br><br><ul><li> perf top/record/report ( debug‚Äî); <br></li><li> GDB; <br></li><li>  pg_waldump. <br></li></ul><br>  ,   ,       .     workload,   <strong>        </strong> .  ,    , PostgreSQL     shared buffers       ( ).        . <br><br><h4>  <strong>Solution</strong> <br></h4><br>    ,      <strong>   </strong> . -   workload, - , -    : ¬´      ,  -  ¬ª. <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pgsql-hackers</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pgsql-bugs</a> ,   ,   .  ,    . <br><br>     ‚Äî <strong>-   ,  , </strong> . <br><br><h2>  <br></h2><br> <strong>      </strong> .  ,             ,    ,      . <br><br> <strong>     </strong> .    , ,  ,    ,   ,   ‚Äî . <br><br>  , <strong>  </strong> ,   ‚Äî .   ,   ,  ,         . <br><br>  ,    ,  <strong>  </strong> ‚Äî  ,      ,   . <br><br><h3>   <br></h3><br><ul><li> PostgreSQL official documentation ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Statistics Collector</a> </li><li> PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mailing Lists</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">general</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">performance</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hackers</a> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PostgreSQL-Consulting company blog</a> </li></ul><br><blockquote>             , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Highload++ Siberia</a> ,   <strong>25  26   </strong> .   ,     ,  . <br><br><ul><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>     MySQL  ClickHouse. </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,            Oracle. </li><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>    ,     ,  ‚Äî  ,       . </li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,   VK  ClickHouse,   ,   . </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414111/">https://habr.com/ru/post/fr414111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414095/index.html">[Fran√ßais] Elasticsearch 6.3.0 est publi√©</a></li>
<li><a href="../fr414097/index.html">Les ordinateurs Apple corrigent une vuln√©rabilit√© de micrologiciel trouv√©e par des experts de Positive Technologies</a></li>
<li><a href="../fr414103/index.html">Webinaire ouvert: ¬´R√©seaux de neurones pour les t√¢ches pharmaceutiques¬ª</a></li>
<li><a href="../fr414105/index.html">Pr√©dire les r√©sultats de la Coupe du monde 2018 en utilisant l'algorithme des for√™ts al√©atoires</a></li>
<li><a href="../fr414109/index.html">Utilisation de Docker pour cr√©er et ex√©cuter un projet C ++</a></li>
<li><a href="../fr414115/index.html">Qu'est-ce que Lazy FP State Restore: une nouvelle vuln√©rabilit√© d√©couverte dans les processeurs Intel</a></li>
<li><a href="../fr414117/index.html">Format binaire d√©cimal mixte vs IEEE754</a></li>
<li><a href="../fr414119/index.html">L'opportunit√© s'est endormie en raison d'une temp√™te de sable sur Mars. On ne sait pas si le rover sera en mesure de travailler √† nouveau</a></li>
<li><a href="../fr414121/index.html">Drone autonome bricolage avec contr√¥le Internet</a></li>
<li><a href="../fr414123/index.html">Nous mettons √† niveau les protocoles de texte en binaire et combattons le code h√©rit√© lors d'une r√©union du groupe d'utilisateurs C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>