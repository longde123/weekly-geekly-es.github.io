<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎰 👩‍👩‍👦 🤠 MVCC dans PostgreSQL-7. Autovacuum 🦊 👨‍✈️ 👨‍👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour vous rappeler, nous avons commencé par des problèmes liés à l' isolement , fait une digression sur la structure des données de bas niveau , discu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-7. Autovacuum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/486104/">  Pour vous rappeler, nous avons commencé par des problèmes liés à l' <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolement</a> , fait une digression sur <a href="https://habr.com/ru/company/postgrespro/blog/469087/">la structure des données de bas niveau</a> , discuté en détail des <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versions de ligne</a> et observé comment <a href="https://habr.com/ru/company/postgrespro/blog/479512/">les instantanés de données</a> sont obtenus à partir des versions de ligne. <br><br>  Ensuite, nous avons exploré le <a href="https://habr.com/ru/company/postgrespro/blog/483768/">vide sur la page (et les mises à jour HOT)</a> et le <a href="https://habr.com/ru/company/postgrespro/blog/484106/">vide</a> .  Nous allons maintenant examiner l'autovacuum. <br><br><h1>  Autovacuum </h1><br>  Nous avons déjà mentionné que normalement (c.-à-d., Lorsque rien ne tient l'horizon des transactions pendant longtemps), VACUUM fait généralement son travail.  Le problème est de savoir à quelle fréquence l'appeler. <br><br>  Si nous aspirons trop rarement une table à langer, sa taille augmentera plus que souhaité.  En outre, une prochaine opération de vide peut nécessiter plusieurs passages dans les index si trop de changements ont été effectués. <br><br>  Si nous aspirons la table trop souvent, le serveur effectuera constamment de la maintenance plutôt qu'un travail utile - et ce n'est pas bon non plus. <br><br>  Notez que le lancement de VACUUM dans les délais prévus ne résout en aucun cas le problème car la charge de travail peut changer avec le temps.  Si la table commence à changer plus intensément, elle doit être aspirée plus souvent. <br><br>  Autovacuum est exactement la technique qui nous permet de lancer l'aspirateur en fonction de l'intensité des changements de table. <br><a name="habracut"></a><br>  Lorsque autovacuum est activé (l'ensemble de paramètres de configuration <em>autovacuum</em> ), le processus du démon <strong>lanceur autovacuum</strong> est démarré, ce qui planifie le travail.  L'aspiration est effectuée par <strong>des</strong> processus de <strong>travail à vide automatique</strong> , dont plusieurs instances peuvent s'exécuter en parallèle. <br><br>  Le processus du <strong>lanceur à vide automatique</strong> compose une liste de bases de données où n'importe quelle activité a lieu.  L'activité est déterminée à partir de statistiques et pour la collecter, le paramètre <em>track_counts</em> doit être défini.  Ne désactivez jamais <em>autovacuum</em> et <em>track_counts</em> , sinon la fonction autovacuum ne fonctionnera pas. <br><br>  Une fois toutes les secondes <strong>autovacuum_naptime, le lanceur autovacuum</strong> démarre (à l'aide du processus <strong>postmaster</strong> ) un processus de travail pour chaque base de données de la liste.  En d'autres termes, s'il y a une activité dans une base de données, les processus de travail lui seront envoyés à un intervalle de secondes <em>autovacuum_naptime</em> .  À cette fin, si quelques (N) bases de données actives sont disponibles, les processus de travail sont lancés N fois aussi souvent que toutes les secondes <em>autovacuum_naptime</em> .  Mais le nombre total de processus de travail exécutés simultanément est limité par le paramètre <em>autovacuum_max_workers</em> . <br><br>  Au démarrage, un processus de travail se connecte à la base de données qui lui est affectée et commence par composer une liste de: <br><br><ul><li>  Toutes les tables, vues matérialisées et tables TOAST qui nécessitent une aspiration. </li><li>  Toutes les tables et vues matérialisées qui nécessitent une analyse (les tables TOAST ne sont pas analysées car elles sont toujours atteintes avec l'accès à l'index). </li></ul><br>  Ensuite, le processus de traitement vide et / ou analyse les objets de la liste un par un et se termine lorsque l'aspiration est terminée. <br><br>  Si le processus n'a pas pu effectuer tout le travail prévu en secondes <em>autovacuum_naptime</em> , le processus de <strong>lancement autovacuum</strong> enverra un processus de travail supplémentaire à cette base de données et ils travailleront ensemble.  «Ensemble» signifie simplement que le deuxième processus établira sa propre liste et y travaillera.  Ainsi, seules différentes tables seront traitées en parallèle, mais il n'y a pas de parallélisme au niveau d'une table - si l'un des processus de travail gère déjà une table, un autre processus la sautera et poursuivra. <br><br>  Maintenant, clarifions plus en détail ce que l'on entend par «nécessite un aspirateur» et «nécessite une analyse». <br><br><blockquote>  Récemment, le <a href="https://commitfest.postgresql.org/23/1774/">correctif a</a> été validé pour permettre au vide de traiter les index en parallèle avec les travailleurs en arrière-plan. <br></blockquote><br><h1>  Quelles tables nécessitent un aspirateur? </h1><br>  L'aspiration est considérée comme nécessaire si le nombre de tuples morts (c'est-à-dire obsolètes) dépasse le seuil spécifié.  Le collecteur de statistiques garde en permanence le nombre de tuples morts, qui est stocké dans la table <code>pg_stat_all_tables</code> .  Et deux paramètres spécifient le seuil: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> définit une valeur absolue (le nombre de tuples). </li><li>  <em>autovacuum_vacuum_scale_factor</em> définit la part des lignes dans la table. </li></ul><br>  En résumé: l'aspiration est requise si <code>pg_stat_all_tables.n_dead_tup</code> &gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Avec les paramètres par défaut, <em>autovacuum_vacuum_threshold</em> = 50 et <em>autovacuum_vacuum_scale_factor</em> = 0,2.  <em>autovacuum_vacuum_scale_factor</em> est certainement le plus important ici - c'est ce paramètre qui est critique pour les grandes tables (et c'est à eux que les problèmes possibles sont associés).  La valeur de 20% semble indûment élevée et, très probablement, elle devra être considérablement réduite. <br><br>  Les valeurs optimales des paramètres peuvent varier pour différentes tables et dépendent de la taille des tables et des spécificités des modifications.  Il est judicieux de définir des valeurs généralement appropriées et, si besoin est, d'effectuer des réglages spéciaux des paramètres au niveau de certaines tables au moyen de paramètres de stockage: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> et <em>toast.autovacuum_vacuum_threshold</em> . </li><li>  <em>autovacuum_vacuum_scale_factor</em> et <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Pour éviter toute confusion, il est raisonnable de le faire uniquement pour quelques tableaux qui se distinguent parmi les autres par la quantité et l'intensité des modifications et uniquement lorsque les valeurs définies globalement ne fonctionnent pas correctement. <br><br>  De plus, vous pouvez désactiver l'autovacuum au niveau de la table (bien que nous ne puissions guère penser à une raison pour laquelle cela pourrait être nécessaire): <br><br><ul><li>  <em>autovacuum_enabled</em> et <em>toast.autovacuum_enabled</em> . </li></ul><br>  Par exemple, la dernière fois que nous avons créé la table <code>vac</code> avec le vide automatique désactivé afin de contrôler manuellement le vide à des fins de démonstration.  Le paramètre de stockage peut être modifié comme suit: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre><br>  Pour formaliser tout ce qui précède, créons une vue qui montre quelles tables doivent être nettoyées à ce stade.  Il utilisera la fonction qui renvoie la valeur actuelle du paramètre et tient compte du fait que la valeur peut être redéfinie au niveau de la table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">if</span></span></span><span class="ruby"> the storage parameter is set, we take its value (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">for</span></span></span><span class="ruby"> TOAST tables, the parameter name differs WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), -- otherwise, we take the value of the configuration parameter current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Et voici la vue: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Quels tableaux nécessitent une analyse? </h1><br>  La situation avec l'analyse automatique est similaire.  Ces tables sont considérées comme nécessitant une analyse dont le nombre de tuples mis à jour (depuis la dernière analyse) dépasse le seuil spécifié par deux paramètres similaires: <code>pg_stat_all_tables.n_mod_since_analyze</code> &gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Les paramètres par défaut de l'analyse automatique sont quelque peu différents: <em>autovacuum_analyze_threshold</em> = 50 et <em>autovacuum_analyze_scale_factor</em> = 0,1.  Ils peuvent également être définis au niveau des paramètres de stockage de tables distinctes: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Comme les tables TOAST ne sont pas analysées, elles n'ont pas de tels paramètres. <br><br>  Créons également une vue pour l'analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Exemple </h1><br>  Définissons les valeurs de paramètres suivantes pour les expériences: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- to aviod waiting long =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Créons maintenant un tableau similaire à celui utilisé la dernière fois et y insérons mille lignes.  Autovacuum est désactivé au niveau de la table, et nous allons l'activer par nous-mêmes.  Sans cela, les exemples ne seront pas reproductibles car la purge automatique peut être déclenchée à un mauvais moment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Voici ce que notre vision de l'aspirateur montrera: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Il convient ici de prêter attention à deux choses.  Tout d'abord, <code>max_dead_tup</code> = 0 bien que 3% des 1000 lignes font 30 lignes.  Le fait est que nous n'avons pas encore de statistiques sur la table car INSERT ne la met pas à jour d'elle-même.  Jusqu'à ce que la table soit analysée, les zéros resteront puisque <code>pg_class.reltuples</code> = 0. Mais regardons la deuxième vue pour l'analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Étant donné que 1000 lignes ont été modifiées (ajoutées) dans le tableau, ce qui est supérieur à zéro, une analyse automatique doit être déclenchée.  Vérifions ceci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Après une courte pause, nous pouvons voir que le tableau a été analysé et que 20 lignes correctes sont affichées dans <code>max_dead_tup</code> au lieu de zéros: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Revenons à la purge automatique: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Comme nous pouvons le voir, <code>max_dead_tup</code> a déjà été corrigé.  Une autre chose à laquelle faire attention est que <code>dead_tup</code> = 0. Les statistiques montrent que la table n'a pas de tuples morts ..., et c'est vrai.  Il n'y a encore rien à aspirer dans le tableau.  Toute table utilisée exclusivement en mode ajout uniquement ne sera pas mise à vide et, par conséquent, la carte de visibilité ne sera pas mise à jour pour elle.  Mais cela rend impossible l'utilisation de l'analyse uniquement par index. <br><br>  (La prochaine fois, nous verrons que passer l'aspirateur atteindra tôt ou tard une table avec ajout uniquement, mais cela se produira trop rarement.) <br><br>  Une leçon apprise: si l'analyse par index uniquement est critique, il peut être nécessaire d'appeler manuellement un processus de vide. <br><br>  Désactivons maintenant le vide automatique et mettons à jour 31 lignes, soit une ligne de plus que le seuil. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  La condition de déclenchement sous vide est maintenant remplie.  Allumons le vide automatique et après une courte pause, nous verrons que la table a été traitée: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Limitation de charge </h1><br>  VACUUM ne bloque pas les autres processus car il fonctionne page par page, mais il produit une charge supplémentaire sur le système et peut affecter de manière significative les performances. <br><br><h2>  Limitation du vide </h2><br>  Pour pouvoir contrôler l'intensité du vide et donc son effet sur le système, le processus alterne travail et attente.  Le processus fera sur les unités de travail conventionnelles de <em>vacuum_cost_limit</em> et ensuite il dormira pendant ms de <em>vacuum_cost_delay</em> . <br><br>  Les paramètres par défaut sont <em>vacuum_cost_limit</em> = 200 et <em>vacuum_cost_delay</em> = 0. Le dernier zéro signifie en fait que VACUUM ne dort pas, donc une valeur spécifique de <em>vacuum_cost_limit</em> n'a pas d'importance du tout.  Le raisonnement derrière cela est que si un administrateur devait lancer manuellement VACUUM, il souhaiterait probablement que l'aspirateur soit effectué le plus rapidement possible. <br><br>  Néanmoins, si nous définissons le temps de sommeil, la quantité de travail spécifiée dans <em>vacuum_cost_limit</em> sera composée des coûts de travail avec les pages dans le cache de tampon.  L'accès à chaque page est estimé comme suit: <br><br><ul><li>  Si la page se trouve dans le cache de tampon, <em>vacuum_cost_page_hit</em> = 1. </li><li>  S'il n'a pas été trouvé, <em>vacuum_cost_page_miss</em> = 10. </li><li>  S'il n'a pas été trouvé et qu'une page sale a dû en outre être <em>supprimée du</em> cache de tampon, <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Autrement dit, avec les paramètres par défaut de <em>vacuum_cost_limit</em> , 200 pages de cache ou 20 pages de disque ou 10 pages avec expulsion peuvent être traitées en une seule fois.  Il est clair que ces chiffres sont assez provisoires, mais il n'est pas logique de sélectionner des chiffres plus précis. <br><br><h2>  Limitation de la purge automatique </h2><br>  Pour les processus sous vide, l'étranglement de charge fonctionne de la même manière que pour le VIDE.  Mais pour les processus autovacuum et VACUUM lancé manuellement pour fonctionner avec une intensité différente, autovacuum a ses propres paramètres: <em>autovacuum_vacuum_cost_limit</em> et <em>autovacuum_vacuum_cost_delay</em> .  Si ces paramètres ont la valeur -1, la valeur de <em>vacuum_cost_limit</em> et / ou <em>vacuum_cost_delay</em> est utilisée. <br><br>  Par défaut, <em>autovacuum_vacuum_cost_limit</em> = -1 ( <em>c'est-à</em> - <em>dire que</em> la valeur de <em>vacuum_cost_limit</em> = 200 est utilisée) et <em>autovacuum_vacuum_cost_delay</em> = 20 ms.  Sur le matériel moderne, le vide automatique sera vraiment lent. <br><br>  Dans la version 12, la valeur de <em>autovacuum_vacuum_cost_delay</em> est réduite à 2 ms, ce qui peut être pris pour une première approximation plus appropriée. <br><br>  En outre, nous devons noter que la limite spécifiée par ces paramètres est commune à tous les processus de travail.  En d'autres termes, lorsque le nombre de processus de travail simultanés est modifié, la charge globale reste inchangée.  Ainsi, pour augmenter les performances de l'autovacuum, lors de l'ajout de processus de travail, il est logique d'augmenter également <em>autovacuum_vacuum_cost_limit</em> . <br><br><h2>  Utilisation de la mémoire et surveillance </h2><br>  <a href="https://habr.com/ru/company/postgrespro/blog/484106/">La dernière fois,</a> nous avons observé comment VACUUM utilisait de la mémoire RAM de taille <em>maintenance_work_mem</em> pour stocker les données à nettoyer. <br><br>  Autovacuum fait absolument la même chose.  Mais il peut y avoir de nombreux processus de travail simultanés si <em>autovacuum_max_workers</em> est défini sur une grande valeur.  De plus, toute la mémoire est allouée à la fois plutôt que lorsque le besoin s'en fait sentir.  Par conséquent, pour un processus de travail, sa propre limitation peut être définie au moyen du paramètre <em>autovacuum_work_mem</em> .  La valeur par défaut de ce paramètre est -1, c'est-à-dire qu'il n'est pas utilisé. <br><br>  Comme déjà mentionné, VACUUM peut également fonctionner avec une taille de mémoire minimale.  Mais si des index sont créés sur la table, une petite valeur de <em>maintenance_work_mem</em> peut entraîner des analyses d'index répétées.  Il en va de même pour l'autovacuum.  Idéalement, <em>autovacuum_work_mem</em> devrait avoir une valeur minimale telle qu'aucune analyse répétée ne se produise. <br><br>  Nous avons vu que pour surveiller VACUUM, l'option VERBOSE peut être utilisée (qui ne peut pas être spécifiée pour autovacuum) ou la vue <code>pg_stat_progress_vacuum</code> (qui, cependant, n'affiche que les informations actuelles).  Par conséquent, le principal moyen de surveiller la mise sous vide automatique consiste à utiliser le paramètre <em>log_autovacuum_min_duration</em> , qui <em>génère</em> les informations dans le journal des messages du serveur.  Il est désactivé par défaut (défini sur -1).  Il est raisonnable d'activer ce paramètre (avec la valeur 0, des informations sur tous les cycles de vide automatique seront produites) et de regarder les chiffres. <br><br>  Voici à quoi ressemblent les informations de sortie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Toutes les informations nécessaires sont disponibles ici. <br><br>  Pour vous rappeler, il est souvent judicieux d'abaisser le seuil de déclenchement sous vide afin de traiter moins de données à la fois plutôt que d'augmenter la taille de la mémoire. <br><br>  Il peut également être raisonnable d'utiliser les vues ci-dessus pour surveiller la longueur de la liste des tables qui nécessitent une aspiration.  L'augmentation de la longueur de la liste indiquera que les processus de vide automatique manquent de temps pour faire leur travail et que les paramètres doivent être modifiés. <br><br>  À suivre. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr486104/">https://habr.com/ru/post/fr486104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486066/index.html">Dans la zone d'accès. Trouvez la distance d'un point à une zone et réduisez les demandes de géocodage inversé</a></li>
<li><a href="../fr486070/index.html">Les commutateurs ACL en détail</a></li>
<li><a href="../fr486080/index.html">Permettez-moi de vous présenter: Veeam Availability Suite v10</a></li>
<li><a href="../fr486084/index.html">Remplacement de disques plus petits par des disques plus grands sous Linux</a></li>
<li><a href="../fr486094/index.html">Un démocrate se bat contre la Silicon Valley</a></li>
<li><a href="../fr486106/index.html">Rétroéclairage adaptatif pour téléviseur Raspberry Pi - Ambilight Analog</a></li>
<li><a href="../fr486114/index.html">Des scientifiques de premier plan dans le domaine des neurosciences se réuniront lors du congrès annuel du Neuronet Industry Union</a></li>
<li><a href="../fr486116/index.html">Tests de simplicité de Fermat et Miller-Rabin</a></li>
<li><a href="../fr486120/index.html">Normalisation de la déviance. Comment les mauvaises pratiques deviennent la norme dans notre industrie</a></li>
<li><a href="../fr486122/index.html">Child ReactJS avec 135 lignes de code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>