<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∞ üë©‚Äçüë©‚Äçüë¶ ü§† MVCC dans PostgreSQL-7. Autovacuum ü¶ä üë®‚Äç‚úàÔ∏è üë®‚Äçüë®‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour vous rappeler, nous avons commenc√© par des probl√®mes li√©s √† l' isolement , fait une digression sur la structure des donn√©es de bas niveau , discu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-7. Autovacuum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/486104/">  Pour vous rappeler, nous avons commenc√© par des probl√®mes li√©s √† l' <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolement</a> , fait une digression sur <a href="https://habr.com/ru/company/postgrespro/blog/469087/">la structure des donn√©es de bas niveau</a> , discut√© en d√©tail des <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versions de ligne</a> et observ√© comment <a href="https://habr.com/ru/company/postgrespro/blog/479512/">les instantan√©s de donn√©es</a> sont obtenus √† partir des versions de ligne. <br><br>  Ensuite, nous avons explor√© le <a href="https://habr.com/ru/company/postgrespro/blog/483768/">vide sur la page (et les mises √† jour HOT)</a> et le <a href="https://habr.com/ru/company/postgrespro/blog/484106/">vide</a> .  Nous allons maintenant examiner l'autovacuum. <br><br><h1>  Autovacuum </h1><br>  Nous avons d√©j√† mentionn√© que normalement (c.-√†-d., Lorsque rien ne tient l'horizon des transactions pendant longtemps), VACUUM fait g√©n√©ralement son travail.  Le probl√®me est de savoir √† quelle fr√©quence l'appeler. <br><br>  Si nous aspirons trop rarement une table √† langer, sa taille augmentera plus que souhait√©.  En outre, une prochaine op√©ration de vide peut n√©cessiter plusieurs passages dans les index si trop de changements ont √©t√© effectu√©s. <br><br>  Si nous aspirons la table trop souvent, le serveur effectuera constamment de la maintenance plut√¥t qu'un travail utile - et ce n'est pas bon non plus. <br><br>  Notez que le lancement de VACUUM dans les d√©lais pr√©vus ne r√©sout en aucun cas le probl√®me car la charge de travail peut changer avec le temps.  Si la table commence √† changer plus intens√©ment, elle doit √™tre aspir√©e plus souvent. <br><br>  Autovacuum est exactement la technique qui nous permet de lancer l'aspirateur en fonction de l'intensit√© des changements de table. <br><a name="habracut"></a><br>  Lorsque autovacuum est activ√© (l'ensemble de param√®tres de configuration <em>autovacuum</em> ), le processus du d√©mon <strong>lanceur autovacuum</strong> est d√©marr√©, ce qui planifie le travail.  L'aspiration est effectu√©e par <strong>des</strong> processus de <strong>travail √† vide automatique</strong> , dont plusieurs instances peuvent s'ex√©cuter en parall√®le. <br><br>  Le processus du <strong>lanceur √† vide automatique</strong> compose une liste de bases de donn√©es o√π n'importe quelle activit√© a lieu.  L'activit√© est d√©termin√©e √† partir de statistiques et pour la collecter, le param√®tre <em>track_counts</em> doit √™tre d√©fini.  Ne d√©sactivez jamais <em>autovacuum</em> et <em>track_counts</em> , sinon la fonction autovacuum ne fonctionnera pas. <br><br>  Une fois toutes les secondes <strong>autovacuum_naptime, le lanceur autovacuum</strong> d√©marre (√† l'aide du processus <strong>postmaster</strong> ) un processus de travail pour chaque base de donn√©es de la liste.  En d'autres termes, s'il y a une activit√© dans une base de donn√©es, les processus de travail lui seront envoy√©s √† un intervalle de secondes <em>autovacuum_naptime</em> .  √Ä cette fin, si quelques (N) bases de donn√©es actives sont disponibles, les processus de travail sont lanc√©s N fois aussi souvent que toutes les secondes <em>autovacuum_naptime</em> .  Mais le nombre total de processus de travail ex√©cut√©s simultan√©ment est limit√© par le param√®tre <em>autovacuum_max_workers</em> . <br><br>  Au d√©marrage, un processus de travail se connecte √† la base de donn√©es qui lui est affect√©e et commence par composer une liste de: <br><br><ul><li>  Toutes les tables, vues mat√©rialis√©es et tables TOAST qui n√©cessitent une aspiration. </li><li>  Toutes les tables et vues mat√©rialis√©es qui n√©cessitent une analyse (les tables TOAST ne sont pas analys√©es car elles sont toujours atteintes avec l'acc√®s √† l'index). </li></ul><br>  Ensuite, le processus de traitement vide et / ou analyse les objets de la liste un par un et se termine lorsque l'aspiration est termin√©e. <br><br>  Si le processus n'a pas pu effectuer tout le travail pr√©vu en secondes <em>autovacuum_naptime</em> , le processus de <strong>lancement autovacuum</strong> enverra un processus de travail suppl√©mentaire √† cette base de donn√©es et ils travailleront ensemble.  ¬´Ensemble¬ª signifie simplement que le deuxi√®me processus √©tablira sa propre liste et y travaillera.  Ainsi, seules diff√©rentes tables seront trait√©es en parall√®le, mais il n'y a pas de parall√©lisme au niveau d'une table - si l'un des processus de travail g√®re d√©j√† une table, un autre processus la sautera et poursuivra. <br><br>  Maintenant, clarifions plus en d√©tail ce que l'on entend par ¬´n√©cessite un aspirateur¬ª et ¬´n√©cessite une analyse¬ª. <br><br><blockquote>  R√©cemment, le <a href="https://commitfest.postgresql.org/23/1774/">correctif a</a> √©t√© valid√© pour permettre au vide de traiter les index en parall√®le avec les travailleurs en arri√®re-plan. <br></blockquote><br><h1>  Quelles tables n√©cessitent un aspirateur? </h1><br>  L'aspiration est consid√©r√©e comme n√©cessaire si le nombre de tuples morts (c'est-√†-dire obsol√®tes) d√©passe le seuil sp√©cifi√©.  Le collecteur de statistiques garde en permanence le nombre de tuples morts, qui est stock√© dans la table <code>pg_stat_all_tables</code> .  Et deux param√®tres sp√©cifient le seuil: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> d√©finit une valeur absolue (le nombre de tuples). </li><li>  <em>autovacuum_vacuum_scale_factor</em> d√©finit la part des lignes dans la table. </li></ul><br>  En r√©sum√©: l'aspiration est requise si <code>pg_stat_all_tables.n_dead_tup</code> &gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Avec les param√®tres par d√©faut, <em>autovacuum_vacuum_threshold</em> = 50 et <em>autovacuum_vacuum_scale_factor</em> = 0,2.  <em>autovacuum_vacuum_scale_factor</em> est certainement le plus important ici - c'est ce param√®tre qui est critique pour les grandes tables (et c'est √† eux que les probl√®mes possibles sont associ√©s).  La valeur de 20% semble ind√ªment √©lev√©e et, tr√®s probablement, elle devra √™tre consid√©rablement r√©duite. <br><br>  Les valeurs optimales des param√®tres peuvent varier pour diff√©rentes tables et d√©pendent de la taille des tables et des sp√©cificit√©s des modifications.  Il est judicieux de d√©finir des valeurs g√©n√©ralement appropri√©es et, si besoin est, d'effectuer des r√©glages sp√©ciaux des param√®tres au niveau de certaines tables au moyen de param√®tres de stockage: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> et <em>toast.autovacuum_vacuum_threshold</em> . </li><li>  <em>autovacuum_vacuum_scale_factor</em> et <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Pour √©viter toute confusion, il est raisonnable de le faire uniquement pour quelques tableaux qui se distinguent parmi les autres par la quantit√© et l'intensit√© des modifications et uniquement lorsque les valeurs d√©finies globalement ne fonctionnent pas correctement. <br><br>  De plus, vous pouvez d√©sactiver l'autovacuum au niveau de la table (bien que nous ne puissions gu√®re penser √† une raison pour laquelle cela pourrait √™tre n√©cessaire): <br><br><ul><li>  <em>autovacuum_enabled</em> et <em>toast.autovacuum_enabled</em> . </li></ul><br>  Par exemple, la derni√®re fois que nous avons cr√©√© la table <code>vac</code> avec le vide automatique d√©sactiv√© afin de contr√¥ler manuellement le vide √† des fins de d√©monstration.  Le param√®tre de stockage peut √™tre modifi√© comme suit: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre><br>  Pour formaliser tout ce qui pr√©c√®de, cr√©ons une vue qui montre quelles tables doivent √™tre nettoy√©es √† ce stade.  Il utilisera la fonction qui renvoie la valeur actuelle du param√®tre et tient compte du fait que la valeur peut √™tre red√©finie au niveau de la table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">if</span></span></span><span class="ruby"> the storage parameter is set, we take its value (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">for</span></span></span><span class="ruby"> TOAST tables, the parameter name differs WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), -- otherwise, we take the value of the configuration parameter current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Et voici la vue: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Quels tableaux n√©cessitent une analyse? </h1><br>  La situation avec l'analyse automatique est similaire.  Ces tables sont consid√©r√©es comme n√©cessitant une analyse dont le nombre de tuples mis √† jour (depuis la derni√®re analyse) d√©passe le seuil sp√©cifi√© par deux param√®tres similaires: <code>pg_stat_all_tables.n_mod_since_analyze</code> &gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Les param√®tres par d√©faut de l'analyse automatique sont quelque peu diff√©rents: <em>autovacuum_analyze_threshold</em> = 50 et <em>autovacuum_analyze_scale_factor</em> = 0,1.  Ils peuvent √©galement √™tre d√©finis au niveau des param√®tres de stockage de tables distinctes: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Comme les tables TOAST ne sont pas analys√©es, elles n'ont pas de tels param√®tres. <br><br>  Cr√©ons √©galement une vue pour l'analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Exemple </h1><br>  D√©finissons les valeurs de param√®tres suivantes pour les exp√©riences: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- to aviod waiting long =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Cr√©ons maintenant un tableau similaire √† celui utilis√© la derni√®re fois et y ins√©rons mille lignes.  Autovacuum est d√©sactiv√© au niveau de la table, et nous allons l'activer par nous-m√™mes.  Sans cela, les exemples ne seront pas reproductibles car la purge automatique peut √™tre d√©clench√©e √† un mauvais moment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Voici ce que notre vision de l'aspirateur montrera: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Il convient ici de pr√™ter attention √† deux choses.  Tout d'abord, <code>max_dead_tup</code> = 0 bien que 3% des 1000 lignes font 30 lignes.  Le fait est que nous n'avons pas encore de statistiques sur la table car INSERT ne la met pas √† jour d'elle-m√™me.  Jusqu'√† ce que la table soit analys√©e, les z√©ros resteront puisque <code>pg_class.reltuples</code> = 0. Mais regardons la deuxi√®me vue pour l'analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  √âtant donn√© que 1000 lignes ont √©t√© modifi√©es (ajout√©es) dans le tableau, ce qui est sup√©rieur √† z√©ro, une analyse automatique doit √™tre d√©clench√©e.  V√©rifions ceci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Apr√®s une courte pause, nous pouvons voir que le tableau a √©t√© analys√© et que 20 lignes correctes sont affich√©es dans <code>max_dead_tup</code> au lieu de z√©ros: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Revenons √† la purge automatique: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Comme nous pouvons le voir, <code>max_dead_tup</code> a d√©j√† √©t√© corrig√©.  Une autre chose √† laquelle faire attention est que <code>dead_tup</code> = 0. Les statistiques montrent que la table n'a pas de tuples morts ..., et c'est vrai.  Il n'y a encore rien √† aspirer dans le tableau.  Toute table utilis√©e exclusivement en mode ajout uniquement ne sera pas mise √† vide et, par cons√©quent, la carte de visibilit√© ne sera pas mise √† jour pour elle.  Mais cela rend impossible l'utilisation de l'analyse uniquement par index. <br><br>  (La prochaine fois, nous verrons que passer l'aspirateur atteindra t√¥t ou tard une table avec ajout uniquement, mais cela se produira trop rarement.) <br><br>  Une le√ßon apprise: si l'analyse par index uniquement est critique, il peut √™tre n√©cessaire d'appeler manuellement un processus de vide. <br><br>  D√©sactivons maintenant le vide automatique et mettons √† jour 31 lignes, soit une ligne de plus que le seuil. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  La condition de d√©clenchement sous vide est maintenant remplie.  Allumons le vide automatique et apr√®s une courte pause, nous verrons que la table a √©t√© trait√©e: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Limitation de charge </h1><br>  VACUUM ne bloque pas les autres processus car il fonctionne page par page, mais il produit une charge suppl√©mentaire sur le syst√®me et peut affecter de mani√®re significative les performances. <br><br><h2>  Limitation du vide </h2><br>  Pour pouvoir contr√¥ler l'intensit√© du vide et donc son effet sur le syst√®me, le processus alterne travail et attente.  Le processus fera sur les unit√©s de travail conventionnelles de <em>vacuum_cost_limit</em> et ensuite il dormira pendant ms de <em>vacuum_cost_delay</em> . <br><br>  Les param√®tres par d√©faut sont <em>vacuum_cost_limit</em> = 200 et <em>vacuum_cost_delay</em> = 0. Le dernier z√©ro signifie en fait que VACUUM ne dort pas, donc une valeur sp√©cifique de <em>vacuum_cost_limit</em> n'a pas d'importance du tout.  Le raisonnement derri√®re cela est que si un administrateur devait lancer manuellement VACUUM, il souhaiterait probablement que l'aspirateur soit effectu√© le plus rapidement possible. <br><br>  N√©anmoins, si nous d√©finissons le temps de sommeil, la quantit√© de travail sp√©cifi√©e dans <em>vacuum_cost_limit</em> sera compos√©e des co√ªts de travail avec les pages dans le cache de tampon.  L'acc√®s √† chaque page est estim√© comme suit: <br><br><ul><li>  Si la page se trouve dans le cache de tampon, <em>vacuum_cost_page_hit</em> = 1. </li><li>  S'il n'a pas √©t√© trouv√©, <em>vacuum_cost_page_miss</em> = 10. </li><li>  S'il n'a pas √©t√© trouv√© et qu'une page sale a d√ª en outre √™tre <em>supprim√©e du</em> cache de tampon, <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Autrement dit, avec les param√®tres par d√©faut de <em>vacuum_cost_limit</em> , 200 pages de cache ou 20 pages de disque ou 10 pages avec expulsion peuvent √™tre trait√©es en une seule fois.  Il est clair que ces chiffres sont assez provisoires, mais il n'est pas logique de s√©lectionner des chiffres plus pr√©cis. <br><br><h2>  Limitation de la purge automatique </h2><br>  Pour les processus sous vide, l'√©tranglement de charge fonctionne de la m√™me mani√®re que pour le VIDE.  Mais pour les processus autovacuum et VACUUM lanc√© manuellement pour fonctionner avec une intensit√© diff√©rente, autovacuum a ses propres param√®tres: <em>autovacuum_vacuum_cost_limit</em> et <em>autovacuum_vacuum_cost_delay</em> .  Si ces param√®tres ont la valeur -1, la valeur de <em>vacuum_cost_limit</em> et / ou <em>vacuum_cost_delay</em> est utilis√©e. <br><br>  Par d√©faut, <em>autovacuum_vacuum_cost_limit</em> = -1 ( <em>c'est-√†</em> - <em>dire que</em> la valeur de <em>vacuum_cost_limit</em> = 200 est utilis√©e) et <em>autovacuum_vacuum_cost_delay</em> = 20 ms.  Sur le mat√©riel moderne, le vide automatique sera vraiment lent. <br><br>  Dans la version 12, la valeur de <em>autovacuum_vacuum_cost_delay</em> est r√©duite √† 2 ms, ce qui peut √™tre pris pour une premi√®re approximation plus appropri√©e. <br><br>  En outre, nous devons noter que la limite sp√©cifi√©e par ces param√®tres est commune √† tous les processus de travail.  En d'autres termes, lorsque le nombre de processus de travail simultan√©s est modifi√©, la charge globale reste inchang√©e.  Ainsi, pour augmenter les performances de l'autovacuum, lors de l'ajout de processus de travail, il est logique d'augmenter √©galement <em>autovacuum_vacuum_cost_limit</em> . <br><br><h2>  Utilisation de la m√©moire et surveillance </h2><br>  <a href="https://habr.com/ru/company/postgrespro/blog/484106/">La derni√®re fois,</a> nous avons observ√© comment VACUUM utilisait de la m√©moire RAM de taille <em>maintenance_work_mem</em> pour stocker les donn√©es √† nettoyer. <br><br>  Autovacuum fait absolument la m√™me chose.  Mais il peut y avoir de nombreux processus de travail simultan√©s si <em>autovacuum_max_workers</em> est d√©fini sur une grande valeur.  De plus, toute la m√©moire est allou√©e √† la fois plut√¥t que lorsque le besoin s'en fait sentir.  Par cons√©quent, pour un processus de travail, sa propre limitation peut √™tre d√©finie au moyen du param√®tre <em>autovacuum_work_mem</em> .  La valeur par d√©faut de ce param√®tre est -1, c'est-√†-dire qu'il n'est pas utilis√©. <br><br>  Comme d√©j√† mentionn√©, VACUUM peut √©galement fonctionner avec une taille de m√©moire minimale.  Mais si des index sont cr√©√©s sur la table, une petite valeur de <em>maintenance_work_mem</em> peut entra√Æner des analyses d'index r√©p√©t√©es.  Il en va de m√™me pour l'autovacuum.  Id√©alement, <em>autovacuum_work_mem</em> devrait avoir une valeur minimale telle qu'aucune analyse r√©p√©t√©e ne se produise. <br><br>  Nous avons vu que pour surveiller VACUUM, l'option VERBOSE peut √™tre utilis√©e (qui ne peut pas √™tre sp√©cifi√©e pour autovacuum) ou la vue <code>pg_stat_progress_vacuum</code> (qui, cependant, n'affiche que les informations actuelles).  Par cons√©quent, le principal moyen de surveiller la mise sous vide automatique consiste √† utiliser le param√®tre <em>log_autovacuum_min_duration</em> , qui <em>g√©n√®re</em> les informations dans le journal des messages du serveur.  Il est d√©sactiv√© par d√©faut (d√©fini sur -1).  Il est raisonnable d'activer ce param√®tre (avec la valeur 0, des informations sur tous les cycles de vide automatique seront produites) et de regarder les chiffres. <br><br>  Voici √† quoi ressemblent les informations de sortie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Toutes les informations n√©cessaires sont disponibles ici. <br><br>  Pour vous rappeler, il est souvent judicieux d'abaisser le seuil de d√©clenchement sous vide afin de traiter moins de donn√©es √† la fois plut√¥t que d'augmenter la taille de la m√©moire. <br><br>  Il peut √©galement √™tre raisonnable d'utiliser les vues ci-dessus pour surveiller la longueur de la liste des tables qui n√©cessitent une aspiration.  L'augmentation de la longueur de la liste indiquera que les processus de vide automatique manquent de temps pour faire leur travail et que les param√®tres doivent √™tre modifi√©s. <br><br>  √Ä suivre. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr486104/">https://habr.com/ru/post/fr486104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486066/index.html">Dans la zone d'acc√®s. Trouvez la distance d'un point √† une zone et r√©duisez les demandes de g√©ocodage invers√©</a></li>
<li><a href="../fr486070/index.html">Les commutateurs ACL en d√©tail</a></li>
<li><a href="../fr486080/index.html">Permettez-moi de vous pr√©senter: Veeam Availability Suite v10</a></li>
<li><a href="../fr486084/index.html">Remplacement de disques plus petits par des disques plus grands sous Linux</a></li>
<li><a href="../fr486094/index.html">Un d√©mocrate se bat contre la Silicon Valley</a></li>
<li><a href="../fr486106/index.html">R√©tro√©clairage adaptatif pour t√©l√©viseur Raspberry Pi - Ambilight Analog</a></li>
<li><a href="../fr486114/index.html">Des scientifiques de premier plan dans le domaine des neurosciences se r√©uniront lors du congr√®s annuel du Neuronet Industry Union</a></li>
<li><a href="../fr486116/index.html">Tests de simplicit√© de Fermat et Miller-Rabin</a></li>
<li><a href="../fr486120/index.html">Normalisation de la d√©viance. Comment les mauvaises pratiques deviennent la norme dans notre industrie</a></li>
<li><a href="../fr486122/index.html">Child ReactJS avec 135 lignes de code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>