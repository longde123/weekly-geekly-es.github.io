<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♿️ 👧🏽 🦍 Kami mempercepat pemrosesan terdistribusi grafik besar menggunakan struktur data probabilistik dan tidak hanya 🔛 🖕🏼 🐏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu sumber daya paling berharga dari jejaring sosial mana pun adalah "grafik pertemanan" - informasi disebarluaskan melalui koneksi di kolom in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mempercepat pemrosesan terdistribusi grafik besar menggunakan struktur data probabilistik dan tidak hanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/465985/"><p><img src="https://habrastorage.org/webt/u1/y0/hk/u1y0hkslkriigc-z1_wkrilk2bm.jpeg"></p><br><p>  Salah satu sumber daya paling berharga dari jejaring sosial mana pun adalah "grafik pertemanan" - informasi disebarluaskan melalui koneksi di kolom ini, konten menarik dikirimkan kepada pengguna, dan umpan balik yang konstruktif dikirim ke penulis konten.  Pada saat yang sama, grafik juga merupakan sumber informasi penting yang memungkinkan Anda untuk lebih memahami pengguna dan terus meningkatkan layanan.  Namun, dalam kasus-kasus ketika grafik tumbuh, secara teknis semakin sulit untuk mengambil informasi darinya.  Pada artikel ini kita akan berbicara tentang beberapa trik yang digunakan untuk memproses grafik besar di OK.ru. </p><a name="habracut"></a><br><p>  Untuk memulai, pertimbangkan tugas sederhana dari dunia nyata: tentukan usia pengguna.  Mengetahui usia memungkinkan jaringan sosial untuk memilih konten yang lebih relevan dan lebih baik beradaptasi dengan orang tersebut.  Tampaknya usia sudah diindikasikan saat membuat halaman di jejaring sosial, tetapi pada kenyataannya, cukup sering, pengguna licik dan menunjukkan usia yang berbeda dari yang asli.  Grafik sosial dapat membantu memperbaiki situasi :). </p><br><p> Ambil contoh, Bob (semua karakter dalam artikel adalah fiksi, setiap kebetulan dengan kenyataan adalah hasil dari kreativitas rumah acak): </p><br><p><img src="https://habrastorage.org/webt/wq/ht/tp/wqhttpoxzxunnad14b4csy9owhe.png"></p><br><p>  Di satu sisi, setengah dari teman Bob adalah remaja, menunjukkan bahwa Bob juga remaja.  Tetapi dia juga memiliki teman-teman yang lebih tua, jadi kepercayaan terhadap jawabannya rendah.  Informasi tambahan dari grafik sosial dapat membantu menjelaskan jawabannya: </p><br><p><img src="https://habrastorage.org/webt/w5/ef/ku/w5efku89o5lqu0hrv0kbrl9nte8.png"></p><br><p>  Menambah pertimbangan tidak hanya busur di mana Bob terlibat langsung, tetapi juga busur di antara teman-temannya, kita dapat melihat bahwa Bob adalah bagian dari komunitas remaja yang padat, yang memungkinkan kita untuk membuat kesimpulan tentang usianya dengan tingkat kepercayaan yang lebih besar. </p><br><p>  Struktur data seperti itu dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jaringan ego</a> atau subgraf ego; telah digunakan sejak lama dan berhasil digunakan dalam memecahkan banyak masalah: mencari komunitas, mengidentifikasi bot dan spam, merekomendasikan teman dan konten, dll.  Namun, perhitungan ego dari subgraph untuk <strong>semua</strong> pengguna dalam grafik dengan ratusan juta node dan puluhan miliar busur penuh dengan sejumlah "kesulitan teknis kecil" :). </p><br><p>  Masalah utama adalah ketika mempertimbangkan informasi tentang "langkah kedua" dalam grafik, ledakan kuadrat dari jumlah koneksi terjadi.  Misalnya, untuk pengguna dengan 150 tautan ego langsung, sebuah subgraf dapat mencakup hingga <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2">150</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-4">150</span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mn" id="MJXp-Span-6">149</span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-9">2</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-11"><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-13">11.32</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> 150 + 150 * 149/2 = $ 11.32</script>  tautan, dan untuk pengguna aktif dengan 5.000 teman, subgraf ego dapat tumbuh hingga lebih dari 12.000.000 tautan. </p><br><p>  Komplikasi tambahan adalah kenyataan bahwa grafik disimpan dalam lingkungan terdistribusi, dan tidak ada simpul yang memiliki gambar lengkap grafik dalam memori.  Pengerjaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">partisi graph seimbang</a> dilakukan baik di akademi dan di industri, tetapi bahkan hasil paling top ketika mengumpulkan ego subgraf mengarah ke komunikasi "semua dengan semua": untuk mendapatkan informasi tentang teman-teman teman pengguna, Anda harus pergi ke semua "partisi" dalam banyak kasus. </p><br><p>  Salah satu alternatif yang berfungsi dalam hal ini adalah duplikasi data paksa (misalnya, algoritma 3 dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel dari Google</a> ), tetapi duplikasi ini juga tidak gratis.  Mari kita coba mencari tahu apa yang bisa diperbaiki dalam proses ini. </p><br><h3 id="naivnyy-algoritm">  Algoritma naif </h3><br><p>  Untuk memulai, pertimbangkan algoritma "naif" untuk membuat subgraf ego: </p><br><p><img src="https://habrastorage.org/webt/1o/zn/qz/1oznqzgjwr2iadbhoko7vgvp7hm.png"></p><br><p>  Algoritme mengasumsikan bahwa grafik asli disimpan sebagai daftar adjacency, mis.  Informasi tentang semua teman pengguna disimpan dalam satu catatan dengan ID pengguna di kunci dan daftar ID teman di nilai.  Untuk mengambil langkah kedua dan mendapatkan informasi tentang teman yang Anda butuhkan: </p><br><ol><li>  Konversi grafik ke daftar tepi, di mana setiap tepi adalah entri yang terpisah. </li><li>  Buat daftar tepi bergabung dengan dirinya sendiri, yang akan memberikan semua jalur dalam grafik panjang 2. </li><li>  Kelompokkan dengan memulai jalur. </li></ol><br><p>  Pada output untuk setiap pengguna, kami mendapatkan daftar jalur dengan panjang 2 untuk setiap pengguna.  Perlu dicatat di sini bahwa struktur yang dihasilkan sebenarnya adalah lingkungan <strong>dua langkah dari pengguna</strong> , sedangkan subgraf ego adalah bagiannya.  Oleh karena itu, untuk menyelesaikan prosesnya, kita perlu memfilter semua busur yang keluar dari teman dekat. </p><br><p>  Algoritma ini bagus karena diimplementasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua baris pada Scala di</a> bawah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Spark</a> .  Tetapi keuntungannya berakhir di sana: untuk grafik ukuran industri, volume komunikasi jaringan di luar batas dan waktu operasi diukur dalam beberapa hari.  Kesulitan utama dibuat oleh dua operasi acak yang terjadi ketika kita bergabung dan mengelompokkan.  Apakah mungkin untuk mengurangi jumlah data yang dikirim? </p><br><h3 id="ego-podgraf-v-odin-shuffle">  Ego subgraph dalam satu acak </h3><br><p>  Mengingat grafik persahabatan kami simetris, Anda dapat menggunakan pengoptimalan yang diusulkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tomas Schank</a> : </p><br><ol><li>  Anda bisa mendapatkan semua jalur dengan panjang 2 tanpa bergabung - jika Bob memiliki teman Alice dan Harry, maka ada jalur Alice-Bob-Harry dan Harry-Bob-Alice. </li><li>  Saat pengelompokan, dua jalur di pintu masuk sesuai dengan tepi baru yang sama.  Jalur Bob-Alice-Dave dan Bob-Dave-Alice berisi informasi yang sama untuk Bob, yang berarti Anda hanya dapat mengirim setiap jalur kedua, menyortir pengguna berdasarkan ID mereka. </li></ol><br><p>  Setelah menerapkan optimasi, skema kerja akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/zp/jx/da/zpjxdat-xtd9tqukfqt9tta8n0i.png"></p><br><ol><li>  Pada tahap generasi pertama, kami mendapatkan daftar jalur panjang 2 dengan filter ID pesanan. </li><li>  Pada hari kedua, kami mengelompokkan berdasarkan pengguna pertama di jalan. </li></ol><br><p>  Dalam pengaturan ini, algoritma memenuhi satu operasi acak, dan ukuran data yang dikirim melalui jaringan menjadi setengahnya.  :) </p><br><h3 id="raskladyvaem-ego-podgraf-v-pamyati">  Susun subgraf ego dalam ingatan </h3><br><p>  Masalah penting yang belum kita pertimbangkan adalah bagaimana menguraikan data dalam ego subgraph ke dalam memori.  Untuk menyimpan grafik secara keseluruhan, kami menggunakan daftar adjacency.  Struktur ini nyaman untuk tugas-tugas di mana perlu untuk melalui grafik yang telah selesai secara keseluruhan, tetapi itu mahal jika kita ingin membuat grafik dari potongan-potongan dan melakukan analisis yang lebih halus.  Struktur ideal untuk tugas kita harus secara efektif melakukan operasi berikut: </p><br><ol><li>  Penyatuan dua grafik diperoleh dari partisi yang berbeda. </li><li>  Mendapatkan semua teman manusia. </li><li>  Memeriksa apakah dua orang terhubung. </li><li>  Penyimpanan dalam memori tanpa tinju overhead. </li></ol><br><p>  Salah satu format yang paling cocok untuk persyaratan ini adalah analog dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matriks CSR yang jarang</a> : </p><br><p><img src="https://habrastorage.org/webt/nm/rl/ch/nmrlchko5kxd5cslkvu2kh37vkq.png"></p><br><p>  Grafik dalam hal ini disimpan dalam bentuk tiga array: </p><br><ol><li>  pengguna - array yang diurutkan dengan ID dari semua pengguna yang berpartisipasi dalam grafik. </li><li>  index - array dengan ukuran yang sama dengan pengguna, di mana untuk setiap pengguna disimpan sebuah pointer-indeks ke awal informasi tentang hubungan pengguna dalam array ketiga. </li><li>  teman - array ukuran sama dengan jumlah tepi dalam grafik, di mana ID pengguna terkait ditampilkan secara berurutan untuk ID yang sesuai dari pengguna.  Array diurutkan untuk kecepatan pemrosesan dalam informasi tentang tautan dari satu pengguna. </li></ol><br><p>  Dalam format ini, operasi penggabungan dua grafik dilakukan dalam waktu linier, dan operasi memperoleh informasi tentang pengguna tertentu atau pada sepasang pengguna per logaritma dari jumlah simpul.  Dalam hal ini, overhead dalam memori tidak tergantung pada ukuran grafik, karena jumlah array yang tetap digunakan.  Dengan menambahkan susunan data keempat dengan ukuran yang sama dengan ukuran teman, Anda dapat menyimpan informasi tambahan yang terkait dengan hubungan dalam grafik. </p><br><p>  Menggunakan properti grafik simetri, Anda dapat menyimpan hanya setengah dari busur "segitiga atas" (ketika busur disimpan hanya dari ID yang lebih kecil ke yang lebih besar), tetapi dalam kasus ini, rekonstruksi semua koneksi pengguna tunggal akan memakan waktu linier.  Kompromi yang baik dalam hal ini mungkin merupakan pendekatan yang menggunakan pengkodean "segitiga atas" untuk penyimpanan dan transfer antar node, dan pengkodean simetris saat memuat ego subgraph ke dalam memori untuk dianalisis. </p><br><h3 id="umenshaem-shuffle">  Kurangi shuffle </h3><br><p>  Namun, bahkan setelah menerapkan semua optimasi yang disebutkan di atas, tugas membangun semua subgraf ego masih bekerja terlalu lama.  Dalam kasus kami, sekitar 6 jam dengan pemanfaatan cluster yang tinggi.  Pandangan yang lebih dekat menunjukkan bahwa sumber utama kerumitan masih operasi acak, sementara bagian penting dari data yang terlibat dalam acak tersebut dilempar keluar pada tahapan berikut.  Faktanya adalah bahwa pendekatan yang dijelaskan membangun lingkungan dua langkah lengkap untuk setiap pengguna, sedangkan subgraf ego hanya sebagian kecil dari lingkungan ini yang hanya mengandung busur <em>internal</em> . </p><br><p>  Misalnya, jika, dengan memproses tetangga langsung Bob - Harry dan Frank - kami tahu bahwa mereka bukan teman satu sama lain, maka sudah pada langkah pertama kami bisa menyaring jalur eksternal seperti itu.  Tetapi untuk mengetahui bagi semua Gary dan Frenkov apakah mereka teman, Anda harus menyeret grafik persahabatan ke memori di semua node komputasi atau membuat panggilan jarak jauh saat memproses setiap catatan, yang, sesuai dengan kondisi tugas, tidak mungkin. </p><br><p>  Namun demikian, ada solusi jika kita membiarkan diri kita, dalam persentase kecil kasus, untuk membuat kesalahan ketika kita menemukan persahabatan di mana sebenarnya tidak ada.  Ada seluruh keluarga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur data probabilistik</a> yang memungkinkan untuk mengurangi konsumsi memori selama penyimpanan data dengan perintah besarnya, sambil memungkinkan sejumlah kesalahan.  Struktur yang paling terkenal dari jenis ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">filter Bloom</a> , yang selama bertahun-tahun telah berhasil digunakan dalam database industri untuk mengkompensasi kesalahan dalam cache "ekor panjang". </p><br><p>  Tugas utama filter Bloom adalah menjawab pertanyaan "apakah elemen ini termasuk dalam banyak elemen yang sebelumnya terlihat?"  Selain itu, jika filter menjawab "tidak", maka elemen tersebut mungkin tidak termasuk dalam set, tetapi jika itu menjawab "ya" - ada kemungkinan kecil bahwa elemen tersebut masih tidak ada. </p><br><p>  Dalam kasus kami, "elemen" akan menjadi pasangan pengguna, dan "set" akan menjadi semua sisi grafik.  Kemudian filter Bloom dapat berhasil diterapkan untuk mengurangi ukuran shuffle: </p><br><p><img src="https://habrastorage.org/webt/eo/_e/ua/eo_eua9cf1wxdkxttwevejawbje.png"></p><br><p>  Setelah menyiapkan filter Bloom terlebih dahulu dengan informasi tentang grafik, kita dapat melihat melalui teman-teman Harry untuk mengetahui bahwa Bob dan Ilona bukan teman, yang berarti bahwa kita tidak perlu mengirim informasi Bob tentang koneksi antara Gary dan Ilona.  Namun, informasi bahwa Harry dan Bob adalah teman mereka sendiri masih harus dikirim sehingga Bob dapat sepenuhnya mengembalikan grafik persahabatannya setelah pengelompokan. </p><br><h3 id="ubiraem-shuffle">  Hapus acak </h3><br><p>  Setelah menerapkan filter, jumlah data yang dikirim berkurang sekitar 80%, dan tugas selesai dalam 1 jam dengan beban gugusan sedang, memungkinkan Anda untuk dengan bebas melakukan tugas-tugas lain secara paralel.  Dalam mode ini, itu sudah bisa diambil "ke dalam operasi" dan diletakkan setiap hari, tetapi masih ada potensi untuk optimasi. </p><br><p>  Paradoksikal kedengarannya, masalah dapat diselesaikan tanpa menggunakan shuffle, jika Anda membiarkan diri Anda persentase kesalahan tertentu.  Dan filter Bloom dapat membantu kami dengan ini: </p><br><p><img src="https://habrastorage.org/webt/el/zv/ya/elzvyazgijeu9ew7yt8te-xvmm8.png"></p><br><p>  Jika melihat melalui daftar teman Bob menggunakan filter, kami mengetahui bahwa Alice dan Charlie <em>hampir pasti adalah</em> teman, kami dapat segera menambahkan busur yang sesuai ke subgraf ego Bob.  Seluruh proses dalam kasus ini akan memakan waktu kurang dari 15 menit dan tidak akan memerlukan transfer data melalui jaringan, namun, persentase tertentu dari busur, tergantung pada pengaturan filter, mungkin tidak ada dalam kenyataan. </p><br><p>  Busur tambahan yang ditambahkan oleh filter tidak menimbulkan distorsi yang signifikan untuk beberapa tugas: misalnya, ketika menghitung segitiga, kita dapat dengan mudah memperbaiki hasilnya, dan ketika menyiapkan atribut untuk algoritma pembelajaran mesin, koreksi ML itu sendiri dapat dipelajari pada langkah berikutnya. </p><br><p>  Tetapi dalam beberapa tugas, busur tambahan menyebabkan kerusakan fatal dalam kualitas hasil: misalnya, ketika mencari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen yang terhubung</a> dalam subgraph ego dengan ego jarak jauh (tanpa titik sudut pengguna), kemungkinan "jembatan hantu" antara komponen tumbuh secara kuadrat relatif terhadap ukurannya, yang mengarah ke bahwa hampir di mana-mana kita mendapatkan satu komponen besar. </p><br><p>  Ada area perantara di mana efek negatif dari busur tambahan perlu dievaluasi secara eksperimental: misalnya, beberapa algoritma pencarian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas</a> dapat berhasil mengatasi sedikit kebisingan, mengembalikan struktur komunitas yang hampir identik. </p><br><h3 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h3><br><p>  Subgraf pengguna Ego adalah sumber informasi penting yang secara aktif digunakan dalam OK untuk meningkatkan kualitas rekomendasi, memperbaiki demografi, dan memerangi spam, tetapi perhitungan mereka penuh dengan sejumlah kesulitan. </p><br><p>  Dalam artikel tersebut, kami memeriksa evolusi pendekatan untuk tugas membangun subgraf ego untuk semua pengguna jejaring sosial dan mampu meningkatkan waktu kerja dari 20 jam awal hingga 1 jam, dan dalam kasus persentase kesalahan yang kecil, hingga 10-15 menit. </p><br><p>  Tiga "pilar" yang menjadi dasar keputusan akhir adalah: </p><br><ol><li>  Menggunakan properti grafik simetri dan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tomas Schank</a> . </li><li>  Secara efisien menyimpan subgraf ego menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matriks CSR yang jarang</a> . </li><li>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">filter Bloom</a> untuk mengurangi transfer data melalui jaringan. </li></ol><br><p>  Contoh bagaimana kode algoritma telah berevolusi dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">notebook Zeppelin</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465985/">https://habr.com/ru/post/id465985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465975/index.html">Panduan SQL: Cara Menulis Pertanyaan dengan Lebih Baik (Bagian 2)</a></li>
<li><a href="../id465977/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 31. CDP, Syslog dan NTP</a></li>
<li><a href="../id465979/index.html">Ingat semua ^ W hanya yang Anda butuhkan. Pengalaman menggunakan Anki. Bagian 1 (pengantar, kedua dari belakang)</a></li>
<li><a href="../id465981/index.html">Pengalaman administrasi IBM DB2 Express-C saya ketika digunakan dengan 1C: Enterprise</a></li>
<li><a href="../id465983/index.html">Intel Comet Lake: sedikit 14 nm pada generasi kesepuluh</a></li>
<li><a href="../id465987/index.html">Bayan telah mendarat. Pengumuman buku "Pembelajaran mendalam generatif"</a></li>
<li><a href="../id465989/index.html">Strategi produk dan strategi organisasi dalam hal rekayasa sistem</a></li>
<li><a href="../id465991/index.html">Pekerja Arsitektur Swift Bersih</a></li>
<li><a href="../id465993/index.html">Tidak perlu menghemat keamanan digital</a></li>
<li><a href="../id465995/index.html">LDC - Ekskursi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>