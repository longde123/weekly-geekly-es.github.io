<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≥ üë©üèº‚Äçüé® üåßÔ∏è Extension d'UObject dans Unreal Engine 4 üëåüèæ üêª üë®üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Je m'appelle Alexander, je travaille avec Unreal Engine depuis plus de 5 ans, et presque tout ce temps - avec des projets de r√©seau. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Extension d'UObject dans Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/475622/"><p>  Bonjour √† tous!  Je m'appelle Alexander, je travaille avec Unreal Engine depuis plus de 5 ans, et presque tout ce temps - avec des projets de r√©seau. <br><br>  √âtant donn√© que les projets de r√©seau diff√®rent dans leurs exigences de d√©veloppement et de performances, il est souvent n√©cessaire de travailler avec des objets plus simples, tels que les classes UObject, mais leur fonctionnalit√© est initialement tronqu√©e, ce qui peut cr√©er un cadre solide.  Dans cet article, je vais vous expliquer comment activer diverses fonctions dans la classe de base UObject dans Unreal Engine 4. <br><br><img src="https://habrastorage.org/webt/fe/7o/ui/fe7ouisyxz09hjfen72lsdvx5ae.png"><br><br></p><p>  En fait, j'ai plut√¥t √©crit l'article comme r√©f√©rence.  La plupart des informations sont extr√™mement difficiles √† trouver dans la documentation ou la communaut√©, et ici vous pouvez rapidement ouvrir le lien et copier le code souhait√©.  J'ai d√©cid√© en m√™me temps de partager avec vous!  L'article s'adresse √† ceux qui connaissent d√©j√† un peu UE4.  Le code C ++ sera consid√©r√©, bien qu'il ne soit pas n√©cessaire de le conna√Ætre.  Vous pouvez simplement suivre les instructions si vous avez besoin de parler de quelque chose.  De plus, il n'est pas n√©cessaire de tout copier, vous pouvez coller le code de la section avec les propri√©t√©s n√©cessaires et cela devrait fonctionner. <a name="habracut"></a></p><br><br><h2>  Un peu sur UObject </h2><br>  <b>UObject</b> est la classe de base de presque tout ce qui se trouve dans Unreal Engine 4. La grande majorit√© des objets cr√©√©s dans votre monde ou simplement en m√©moire en sont h√©rit√©s: objets sur la sc√®ne (AActor), composants (UActorComponent), diff√©rents types de travail avec donn√©es et autres. <br><br>  La classe elle-m√™me, bien que plus simple que les d√©riv√©s, est en m√™me temps assez fonctionnelle.  Par exemple, il contient de nombreux √©v√©nements utiles, tels que la modification des valeurs des variables dans l'√©diteur et des fonctions de base du r√©seau, qui ne sont pas actives par d√©faut. <br><br>  Les objets cr√©√©s par cette classe ne peuvent pas √™tre sur sc√®ne et existent exclusivement en m√©moire.  Ils ne peuvent pas √™tre ajout√©s en tant que composants aux acteurs, bien qu'il puisse s'agir d'une sorte de composant si vous impl√©mentez vous-m√™me les fonctionnalit√©s n√©cessaires. <br><br><p>  Pourquoi ai-je besoin d'UObject si AActor prend d√©j√† en charge tout ce dont j'ai besoin?  En g√©n√©ral, il existe de nombreux exemples d'utilisation.  Le plus simple est les articles en inventaire.  Sur sc√®ne, quelque part dans le ciel, leur stockage est impossible, vous pouvez donc les stocker en m√©moire sans charger le rendu et sans cr√©er de propri√©t√©s inutiles.  Pour ceux qui aiment les comparaisons techniques, AActor prend un kilo-octet (1016 octets) et un UObject vide ne fait que 56 octets. </p><br><br><h2>  Qu'est-ce qu'un probl√®me UObject? </h2><br>  Il n'y a pas de probl√®mes en g√©n√©ral, eh bien, ou je ne les ai tout simplement pas rencontr√©s.  Tout ce qui agace UObject, c'est le manque de fonctionnalit√©s diverses qui sont disponibles par d√©faut dans AActor ou dans les composants.  Voici les probl√®mes que j'ai identifi√©s pour ma pratique: <br><br><ul><li>  Les UObjects ne sont pas r√©pliqu√©s sur le r√©seau; </li><li>  en raison du premier point, nous ne pouvons pas d√©clencher d'√©v√©nements RPC; </li><li>  Vous ne pouvez pas utiliser un ensemble complet de fonctions qui n√©cessitent un lien vers le monde dans Blueprints; </li><li>  ils n'ont pas d'√©v√©nements standard comme BeginPlay et Tick; </li><li>  vous ne pouvez pas ajouter de composants d'UObjects √† AActor dans Blueprints. </li></ul><br><p>  La plupart des choses peuvent √™tre facilement r√©solues.  Mais certains devront bricoler. </p><br><br><h2>  Cr√©ation d'UObject </h2><br>  Avant d'√©tendre notre classe avec des fonctionnalit√©s, nous devons la cr√©er.  Utilisons l'√©diteur pour que le g√©n√©rateur √©crive automatiquement tout ce qui est n√©cessaire pour travailler dans l'en-t√™te (.h). <br><br>  Nous pouvons cr√©er une nouvelle classe dans l'√©diteur de navigateur de contenu en cliquant sur le bouton <i>Nouveau</i> et en s√©lectionnant <i>Nouvelle classe C ++</i> . <br><br><img src="https://habrastorage.org/webt/x3/7r/8d/x37r8d1ahvstuxtpdnafshrnp9m.png"><br><br>  Ensuite, nous devons choisir la classe elle-m√™me.  Il peut ne pas √™tre dans la liste g√©n√©rale, par cons√©quent, ouvrez-le et s√©lectionnez UObject. <br><br><img src="https://habrastorage.org/webt/p2/7d/dh/p27ddhbtq9bxgmjzobmozoa1tlk.png"><br><br>  Nommez votre classe et s√©lectionnez dans quel dossier elle sera stock√©e.  Lorsque nous avons cr√©√© la classe, vous pouvez entrer dans le studio, la trouver et commencer √† int√©grer toutes les fonctions n√©cessaires. <br><br>  <i>D√©butants, notez que deux fichiers sont cr√©√©s: .h et .ccp.</i>  <i>En .h, vous d√©clarerez des variables et des fonctions, et en .cpp vous d√©finirez leur logique.</i>  <i>Recherchez les deux fichiers dans votre projet.</i>  <i>Si vous n'avez pas modifi√© le chemin, ils doivent se trouver dans Projet / Source / Projet /.</i> <br><br>  Jusqu'√† ce que nous continuions, √©crivons le param√®tre <i>Blueprintable</i> dans la macro UCLASS () au-dessus de la d√©claration de classe.  Vous devriez obtenir quelque chose comme ceci: <br><br>  <b>.h</b> <br><br><pre><code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() }</code> </pre> <br><p>  Gr√¢ce √† cela, vous pouvez cr√©er des Blueprints qui h√©riteront de tout ce que nous faisons avec cet objet. </p><br><br><h2>  R√©plication UObject </h2><br>  Par d√©faut, les UObjects ne sont pas r√©pliqu√©s sur le r√©seau.  Comme je l'ai d√©crit ci-dessus, un certain nombre de restrictions sont cr√©√©es lorsque vous devez synchroniser des donn√©es ou une logique entre les parties, mais ne stockez pas de d√©chets dans le monde. <br><br>  Dans Unreal Engine 4, la r√©plication a lieu pr√©cis√©ment en raison des objets du monde.  Cela signifie que la simple cr√©ation d'un objet en m√©moire et sa r√©plication √©choueront.  Dans tous les cas, vous aurez besoin d'un propri√©taire qui g√©rera le transfert des donn√©es d'objet entre le serveur et les clients.  Par exemple, si votre objet est la comp√©tence d'un personnage, alors le personnage lui-m√™me devrait devenir le propri√©taire.  Il sera √©galement chef d'orchestre pour la transmission d'informations sur le r√©seau. <br><br>  Pr√©parez notre objet pour la r√©plication.  Jusqu'√† pr√©sent dans l'en-t√™te, nous devons d√©finir une seule fonction: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }</code> </pre><br>  <i>IsSupportedForNetworking ()</i> d√©terminera que l'objet prend en charge le r√©seau et peut √™tre r√©pliqu√©. <br><br>  Cependant, tout n'est pas si simple.  Comme je l'ai √©crit ci-dessus, vous avez besoin d'un propri√©taire qui contr√¥le le transfert de l'objet.  Pour rendre l'exp√©rience propre, cr√©ez un AActor qui le reproduira.  Cela peut √™tre fait exactement de la m√™me mani√®re que UObject, seule la classe parente, naturellement, AActor. <br><br>  <i>D√©butants, si vous devez r√©pliquer un objet dans un personnage, un contr√¥leur ou ailleurs, cr√©ez la classe de base appropri√©e via l'√©diteur, ajoutez-y la logique n√©cessaire et h√©ritez d√©j√† de cette classe dans Blueprints.</i> <br><br>  √Ä l'int√©rieur, nous avons besoin de 3 fonctions: un constructeur, une fonction pour r√©pliquer des sous-objets, une fonction qui d√©termine ce qui est r√©pliqu√© √† l'int√©rieur de cet AActor (variables, r√©f√©rences d'objet, etc.) et l'endroit o√π nous cr√©ons notre objet. <br><br>  N'oubliez pas de cr√©er une variable par laquelle notre objet sera stock√©: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AMyActor(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplicateSubobjects</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginPlay</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; UPROPERTY(Replicated, BlueprintReadOnly, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObject</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br>  Dans le fichier source, nous devons tout √©crire: <br><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyActor.h" #include "Net/UnrealNetwork.h" #include "Engine/World.h" #include "Engine/ActorChannel.h" #include "   UObject/MyObject.h" AMyActor::AMyActor() { //  Actor  . bReplicates = true // . NetCullDistanceSquared = 99999; //  (  ). NetUpdateFrequency = 1.f; } void AMyActor::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //       .           . DOREPLIFETIME(AMyActor, MyObject); } bool AMyActor::ReplicateSubobjects(UActorChannel * Channel, FOutBunch * Bunch, FReplicationFlags * RepFlags) { bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags); //   . if (MyObject ) WroteSomething |= Channel-&gt;ReplicateSubobject(MyObject , *Bunch, *RepFlags); return WroteSomething; } AMyActor::BeginPlay() { /*       (  )  .    this.        . ,       ,     . */ if(HasAuthority()) { MyObject = NewObject&lt;UMyObject&gt;(this); //       if(MyObject) UE_LOG(LogTemp, Log, TEXT("%s created"), *MyObject-&gt;GetName()); } }</span></span></code> </pre><br><p>  Maintenant, votre objet sera r√©pliqu√© avec cet acteur.  Vous pouvez afficher son nom sur la coche, mais d√©j√† sur le client.  Veuillez noter que sur Begin Play, il est peu probable qu'un objet arrive avant le client, il est donc inutile d'√©crire un journal dessus. </p><br><br><h2>  R√©plication de variables dans UObject </h2><br>  Dans la plupart des cas, il est inutile de r√©pliquer un objet s'il ne contient pas d'informations qui seront √©galement synchronis√©es entre le serveur et les clients.  Puisque notre objet est d√©j√† r√©pliqu√©, passer des variables n'est pas difficile.  Cela se fait de la m√™me mani√®re qu'√† l'int√©rieur de notre acteur: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; UPROPERTY(Replicated, BlueprintReadWrite, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MyInteger; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyObject.h" #include "Net/UnrealNetwork.h" UMyObject ::UMyObject () { //  Object  .     . bReplicates = true //       ,     . } void UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //   Integer  . DOREPLIFETIME(UMyObject, MyInteger); } }</span></span></code> </pre><br>  En ajoutant une variable et en la marquant pour la r√©plication, nous pouvons la r√©pliquer.  Tout est simple et identique √† celui d'AActor. <br><br>  Cependant, il y a un petit pi√®ge qui n'est pas imm√©diatement visible, mais peut √™tre trompeur.  Cela sera particuli√®rement visible si vous cr√©ez votre UObject non pas pour travailler en C ++, mais le pr√©parez pour l'h√©ritage et travaillez dans Blueprints. <br><br>  L'essentiel est que les variables cr√©√©es dans l'h√©ritier des Blueprints ne seront pas r√©pliqu√©es.  Le moteur ne les marque pas automatiquement et la modification d'un param√®tre sur le serveur dans le BP ne change rien dans la valeur sur le client.  Mais il existe un rem√®de √† cela.  Pour la r√©plication correcte des variables BP, vous devez les marquer √† l'avance.  Ajoutez quelques lignes √† GetLifetimeReplicatedProps (): <br><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); <span class="hljs-comment"><span class="hljs-comment">//   Integer  . DOREPLIFETIME(UMyObject, MyInteger); //       UBlueprintGeneratedClass* BPClass = Cast&lt;UBlueprintGeneratedClass&gt;(GetClass()); if (BPClass) BPClass-&gt;GetLifetimeBlueprintReplicationList(OutLifetimeProps); }</span></span></code> </pre><br><p>  Les variables des classes Blueprint enfants se r√©pliqueront d√©sormais comme pr√©vu. </p><br><br><h2>  √âv√©nements RPC dans UObject </h2><br>  Les √©v√©nements RPC (Remote Procedure Call) sont des fonctions sp√©ciales appel√©es de l'autre c√¥t√© de l'interaction r√©seau d'un projet.  En les utilisant, vous pouvez appeler la fonction depuis le serveur sur d'autres clients et depuis le client sur le serveur.  Tr√®s utile et souvent utilis√© lors de la r√©daction de projets de r√©seau. <br><br>  <i>Si vous ne les connaissez pas, je vous recommande de lire un article.</i>  <i>Il d√©crit l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisation en C ++ et en Blueprints</a> .</i> <br><br>  Bien qu'il n'y ait aucun probl√®me dans Actor ou dans les composants avec leur appel, dans les √©v√©nements UObject, ils se d√©clenchent du m√™me c√¥t√© que celui o√π ils ont √©t√© appel√©s, ce qui rend impossible de faire un appel √† distance lorsque cela est n√©cessaire. <br><br>  En regardant le code du composant (UActorComponent), nous pouvons trouver plusieurs fonctions qui vous permettent de transf√©rer des appels sur le r√©seau.  Comme UActorComponent est h√©rit√© d'UObject, nous pouvons simplement copier les sections n√©cessaires de code et coller dans notre objet afin qu'il fonctionne comme il se doit: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/EngineTypes.h" UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() public: virtual bool CallRemoteFunction (UFunction * Function, void * Parms, struct FOutParmRec * OutParms, FFrame * Stack) override; virtual int32 GetFunctionCallspace (UFunction* Function, void* Parameters, FFrame* Stack) override; //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/NetDriver.h" //       . bool UMyObject::CallRemoteFunction(UFunction * Function, void * Parms, FOutParmRec * OutParms, FFrame * Stack) { if (!GetOuter()) return false; UNetDriver* NetDriver = GetOuter()-&gt;GetNetDriver(); if (!NetDriver) return false; NetDriver-&gt;ProcessRemoteFunction(GetOuter(), Function, Parms, OutParms, Stack, this); return true; } int32 UMyObject::GetFunctionCallspace(UFunction * Function, void * Parameters, FFrame * Stack) { return (GetOuter() ? GetOuter()-&gt;GetFunctionCallspace(Function, Parameters, Stack) : FunctionCallspace::Local); }</span></span></code> </pre><br>  Avec ces fonctions, nous serons en mesure de d√©clencher des √©v√©nements RPC non seulement dans le code, mais aussi dans les plans. <br><br><p>  Veuillez noter que pour d√©clencher des √©v√©nements Client ou Serveur, vous avez besoin d'un propri√©taire dont le Propri√©taire est notre joueur.  Par exemple, l'objet appartient au personnage de l'utilisateur ou √† l'objet dont le propri√©taire est le contr√¥leur du joueur. </p><br><br><h2>  Fonctionnalit√©s globales dans les plans directeurs </h2><br>  Si vous avez d√©j√† cr√©√© un plan d'objet, vous avez peut-√™tre remarqu√© que vous ne pouvez pas appeler des fonctions globales (statiques, mais pour plus de clart√©, nous l'appelons) qui sont disponibles dans d'autres classes, par exemple, GetGamemode ().  Il semble que vous ne pouvez tout simplement pas faire de classes dans les classes d'objets, √† cause desquelles vous devez soit passer tous les liens lors de la cr√©ation, soit pervertir, et parfois le choix tombe compl√®tement sur la classe Actor qui est cr√©√©e sur la sc√®ne et prend en charge tout. <br><br>  Mais en C ++, bien s√ªr, il n'y a pas de tels probl√®mes.  Cependant, le game designer, qui joue avec les param√®tres et ajoute diff√©rentes petites choses, ne peut pas dire que vous devez ouvrir Visual Studio, trouver la classe appropri√©e et obtenir le mode de jeu dans la fonction doSomething () en changeant les points.  Par cons√©quent, il est imp√©ratif que le concepteur puisse se connecter √† Bluprint et en deux clics faire son travail.  √âconomisez son temps et le v√¥tre.  Cependant, les Blueprints ont √©t√© invent√©s pour cela. <br><br>  L'essentiel est que lorsque vous recherchez ou appelez des fonctions dans le menu contextuel de Bluprint, ces m√™mes fonctions globales qui n√©cessitent une r√©f√©rence au monde essaient d'appeler une fonction √† l'int√©rieur de votre objet qui s'y r√©f√®re.  Et si l'√©diteur voit qu'il n'y a pas de fonction, il comprend qu'il ne peut pas l'utiliser et ne l'affiche pas dans la liste. <br><br><img src="https://habrastorage.org/webt/bb/mj/gu/bbmjguakea7gkb-roirojnwnrsg.png"><br><br>  Cependant, il existe un rem√®de √† cela.  M√™me deux. <br><br>  Consid√©rons d'abord une option pour une utilisation plus pratique dans l'√©diteur.  Nous devrons red√©finir une fonction qui renvoie un lien vers le monde, puis l'√©diteur comprendra que dans le jeu lui-m√™me, cela peut fonctionner: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//  GetWorld()    . virtual UWorld* GetWorld() const override; //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs">UWorld* UMyObject::GetWorld() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       ,    . if (GIsEditor &amp;&amp; !GIsPlayInEditorWorld) return nullptr; else if (GetOuter()) return GetOuter()-&gt;GetWorld(); else return nullptr; }</span></span></code> </pre><br>  Maintenant, il est d√©fini et l'√©diteur comprendra qu'en g√©n√©ral l'objet est capable d'obtenir le pointeur souhait√© (bien qu'il ne soit pas valide) et d'utiliser des fonctions globales dans le BP. <br><br>  <i>Veuillez noter que le propri√©taire (GetOuter ()) doit √©galement avoir acc√®s au monde.</i>  <i>Il peut s'agir d'un autre UObject avec un objet GetWorld (), un composant ou un acteur sp√©cifique dans la sc√®ne.</i> <br><br><img src="https://habrastorage.org/webt/7x/wu/w3/7xwuw3u7qkekz9m6-bnhdfd0o10.png"><br><br>  Il y a une autre fa√ßon.  Il suffit d'ajouter une √©tiquette √† la macro UCLASS () lors de la d√©claration de la classe selon laquelle le param√®tre WorldContextObject sera ajout√© aux fonctions statiques du BP, dans lequel tout objet servant de conducteur au "monde" et aux fonctions globales du moteur est aliment√©.  Cette option convient √† ceux qui dans le projet peuvent avoir plusieurs mondes en m√™me temps (par exemple, le monde du jeu et le monde pour le spectateur): <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   WorldContext      UCLASS(Blueprintable, meta=(ShowWorldContextPin)) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() //   }</span></span></code> </pre><br>  Si vous entrez GetGamemode dans la recherche dans le BP, il appara√Ætra dans la liste, comme d'autres fonctions similaires, et le param√®tre sera WorldContextObject, dans lequel vous devez passer un lien vers Actor. <br><br><img src="https://habrastorage.org/webt/nn/uo/xg/nnuoxgsfj912bnoa5fheedsz3yk.png"><br><br>  Soit dit en passant, vous pouvez simplement y d√©poser le propri√©taire de notre propri√©t√©.  Je recommande de cr√©er une fonction sur Actor, elle sera toujours utile pour l'objet: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable, meta=(ShowWorldContextPin)) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      ,     . public: UFUNCTION(BlueprintPure) AActor* GetOwner() const {return Cast&lt;AActor&gt;(GetOuter());}; //   }</span></span></code> </pre><br>  Maintenant, vous pouvez simplement utiliser les fonctions globales en combinaison avec notre fonction Pure pour obtenir le propri√©taire. <br><br><img src="https://habrastorage.org/webt/ux/22/7w/ux227wpx_b6yp8l8vnlutwxywu8.png"><br><br>  Si vous d√©clarez √©galement GetWorld () dans la deuxi√®me variante comme dans la premi√®re variante, vous pouvez vous soumettre une r√©f√©rence (Self ou This) dans le param√®tre WorldContextObject. <br><br><p><img src="https://habrastorage.org/webt/op/jh/mb/opjhmbcmm5jsktm_gtxk-jkgzyy.png"></p><br><br><h2>  √âv√©nements BeginPlay et Tick </h2><br>  Un autre probl√®me que les d√©veloppeurs de Blueprint peuvent rencontrer est qu'il n'y a aucun √©v√©nement BeginPlay et Tick dans la classe Object.  Bien s√ªr, vous pouvez les cr√©er vous-m√™me et appeler depuis une autre classe.  Mais vous devez admettre que c'est beaucoup plus pratique lorsque tout fonctionne hors de la bo√Æte. <br><br>  Commen√ßons par comprendre comment lancer Begin Play.  Nous pouvons cr√©er une fonction disponible pour la r√©√©criture dans le BP et l'appeler dans le constructeur de la classe, mais il y a un certain nombre de probl√®mes, car au moment du constructeur votre objet n'a pas encore √©t√© compl√®tement initialis√©. <br><br>  Dans toutes les classes, il existe la fonction PostInitProperties (), qui est appel√©e apr√®s l'initialisation de la plupart des param√®tres et l'enregistrement de l'objet dans divers syst√®mes internes, par exemple pour le garbage collector.  Dans ce document, vous pouvez simplement appeler notre √©v√©nement, qui sera utilis√© dans les Blueprints: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      . virtual void PostInitProperties() override; // ,      . UFUNCTION(BlueprintImplementableEvent) void BeginPlay(); //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::PostInitProperties() { Super::PostInitProperties(); <span class="hljs-comment"><span class="hljs-comment">//   ,   .   BeginPlay    if(GetOuter() &amp;&amp; GetOuter()-&gt;GetWorld()) BeginPlay(); }</span></span></code> </pre><br>  <i>Au lieu de if (GetOuter () &amp;&amp; GetOuter () -&gt; GetWorld ()), vous pouvez simplement mettre if (GetWorld ()) si vous l'avez d√©j√† red√©fini.</i> <i><br><br></i>  <i>Faites attention!</i>  <i>Par d√©faut, PostInitProperties () est √©galement appel√© dans l'√©diteur.</i> <i><br></i> <br>  Maintenant, nous pouvons aller dans notre objet BP et appeler l'√©v√©nement BeginPlay.  Il sera appel√© lors de la cr√©ation de l'objet. <br><br>  Passons √† l'√©v√©nement Tick.  Il n'y a pas de fonction simple pour nous.  Cochez les objets dans le moteur appelle un gestionnaire sp√©cial, auquel vous devez en quelque sorte ramasser.  Cependant, il existe une astuce tr√®s pratique ici - l'h√©ritage suppl√©mentaire de FTickableGameObject.  Cela vous permettra de faire automatiquement tout ce dont vous avez besoin, puis il vous suffira de choisir les fonctions n√©cessaires: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Tickable.h" //   c FTickableGameObject UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject, public FTickableGameObject { GENERATED_BODY() public: //   virtual void Tick(float DeltaTime) override; virtual bool IsTickable() const override; virtual TStatId GetStatId() const override; protected: //     UFUNCTION(BlueprintImplementableEvent) void EventTick(float DeltaTime); //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::Tick(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime) { <span class="hljs-comment"><span class="hljs-comment">//       . EventTick(DeltaTime); //     . } //     bool UMyObject::IsTickable() const { return true; } TStatId UMyObject::GetStatId() const { return TStatId(); }</span></span></code> </pre><br><p>  Si vous h√©ritez de votre objet et cr√©ez une classe BP, un √©v√©nement EventTick sera disponible, ce qui provoquera une logique pour chaque trame. </p><br><br><h2>  Ajout de composants √† partir d'UObjects </h2><br>  Dans les plans directeurs UObject, vous ne pouvez pas g√©n√©rer de composants pour les acteurs.  Le m√™me probl√®me est inh√©rent aux plans directeurs d'ActorComponent.  La logique d'Epic Games n'est pas tr√®s claire, car en C ++ cela peut √™tre fait.  De plus, vous pouvez ajouter un composant Actor √† un autre objet Actor en sp√©cifiant simplement un lien.  Mais cela ne peut pas √™tre fait. <br><br>  Malheureusement, je n'ai pas pu comprendre cet article.  Si quelqu'un a des instructions sur la fa√ßon de proc√©der, je serai heureux de le publier ici. <br><br><p>  La seule option que je peux offrir pour le moment est de cr√©er un wrapper dans la classe UObject, donnant acc√®s √† une simple addition de composants.  Ainsi, il sera possible d'ajouter des composants √† l'Actor, mais vous n'aurez pas de param√®tres d'entr√©e cr√©√©s dynamiquement du spawn.  Souvent, cela peut √™tre n√©glig√©. </p><br><br><h2>  Configuration d'une instance via l'√©diteur </h2><br>  Dans UE4, il existe une autre ¬´fonctionnalit√©¬ª pratique pour travailler avec des objets: il s'agit de la possibilit√© de cr√©er une instance lors de l'initialisation et de modifier ses param√®tres via l'√©diteur, d√©finissant ainsi ses propri√©t√©s, sans cr√©er de classe enfant uniquement √† des fins de param√©trage.  Particuli√®rement utile pour les concepteurs de jeux. <br><br>  Supposons que vous ayez un gestionnaire de modificateurs pour un personnage et que les modificateurs eux-m√™mes soient repr√©sent√©s par des classes qui d√©crivent les effets superpos√©s.  Le game designer a cr√©√© une paire de modificateurs et indique dans le gestionnaire ceux qui sont utilis√©s. <br><br>  Dans une situation normale, cela ressemblerait √† ceci: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere) TSubclassOf&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObjectClass</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br><img src="https://habrastorage.org/webt/hd/rx/zc/hdrxzc1qsu2d9htiydsmgfy1t-0.png"><br><br>  Cependant, il y a un probl√®me en ce qu'il ne peut pas configurer de modificateurs et vous devez cr√©er une classe suppl√©mentaire pour d'autres valeurs.  D'accord, ce n'est pas tr√®s pratique d'avoir des dizaines de classes dans le navigateur de contenu qui ne diff√®rent que par des valeurs.  Il est facile de r√©soudre ce probl√®me.  Vous pouvez ajouter quelques champs dans USTRUCT (), et √©galement indiquer dans l'objet conteneur que nos objets seront des instances, et pas seulement des r√©f√©rences √† des objets ou des classes inexistants: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable, DefaultToInstanced, EditInlineNew) <span class="hljs-comment"><span class="hljs-comment">//  -        class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() UPROPERTY(EditAnywhere) //       uint8 MyValue; // ,    //   }</span></span></code> </pre><br>  Cela seul ne suffit pas, il faut maintenant indiquer que la m√™me variable avec la classe sera une instance.  Cela est d√©j√† fait o√π vous stockez l'objet, par exemple, dans le gestionnaire de modificateurs de caract√®res: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere, Instanced) <span class="hljs-comment"><span class="hljs-comment">//   Instanced    class UMyObject* MyObject; //    }</span></span></code> </pre><br>  Veuillez noter que nous utilisons la r√©f√©rence √† l'objet, et non √† la classe, car l'instance sera cr√©√©e imm√©diatement lors de l'initialisation.  Maintenant, nous pouvons aller dans la fen√™tre de l'√©diteur pour s√©lectionner une classe et ajuster les valeurs √† l'int√©rieur de l'instance.  C'est beaucoup plus pratique et plus flexible. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ee4/1cd/e76/ee41cde76aed943c03f0a15ff2e903f6.png" alt="image"></p><br><br><h2>  Info </h2><br>  Il existe une autre classe int√©ressante dans Unreal Engine.  C'est AInfo.  Une classe h√©rit√©e d'AActor qui n'a pas de repr√©sentation visuelle dans le monde.  Info utilise des classes telles que: mode de jeu, GameState, PlayerState et autres.  Autrement dit, les classes qui prennent en charge diff√©rentes puces d'AActor, par exemple, la r√©plication, mais ne sont pas plac√©es sur la sc√®ne. <br><br>  Si vous devez cr√©er un gestionnaire global suppl√©mentaire qui devrait prendre en charge le r√©seau et toutes les classes d'acteurs r√©sultantes, vous pouvez l'utiliser.  Vous n'avez pas besoin de manipuler la classe UObject comme d√©crit ci-dessus pour la forcer, par exemple, √† r√©pliquer des donn√©es. <br><br><p>  Cependant, gardez √† l'esprit que m√™me si l'objet n'a pas de coordonn√©es, pas de composants visuels et qu'il ne s'affiche pas √† l'√©cran, il est toujours un descendant de la classe Actor, ce qui signifie qu'il est aussi lourd que le parent.  Raisonnablement utilis√© en petites quantit√©s et pour plus de commodit√©. </p><br><br><h2>  Conclusion </h2><br>  UObject est tr√®s souvent n√©cessaire, et je vous conseille de l'utiliser chaque fois que l'acteur n'est pas vraiment n√©cessaire.  C'est dommage que ce soit un peu limit√©, mais c'est aussi un plus.  Parfois, vous devez bricoler lorsque vous devez utiliser un mod√®le personnalis√©, mais surtout, toutes les principales restrictions peuvent √™tre supprim√©es. <br><br>         ,            ,      UObject,   ,      ,           . <br><br> ,    ,      Unreal Engine 4.   -   ,          .    ,  -    ,   UObject. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475622/">https://habr.com/ru/post/fr475622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475608/index.html">Google Tag Manager: param√®tres de d√©clenchement non √©vidents et utiles</a></li>
<li><a href="../fr475610/index.html">Lampes de table LED s√ªres qui conservent la vision</a></li>
<li><a href="../fr475612/index.html">√âtant donn√©, quand, les affirmations et la confiance dans la mise en ≈ìuvre</a></li>
<li><a href="../fr475614/index.html">Automatisation pour les plus petits. Deuxi√®me partie. Conception du r√©seau</a></li>
<li><a href="../fr475618/index.html">Comment √©crire un contrat Python intelligent sur le r√©seau Ontology. Partie 2: API de stockage</a></li>
<li><a href="../fr475624/index.html">PHP-Watcher: un outil qui simplifie le d√©veloppement d'applications √† longue dur√©e de vie</a></li>
<li><a href="../fr475626/index.html">Les autotests peuvent-ils remplacer une personne √† la recherche de vuln√©rabilit√©s: entretien avec Alexandra Svatikova</a></li>
<li><a href="../fr475630/index.html">Knative - une plate-forme bas√©e sur k8s en tant que service avec prise en charge sans serveur</a></li>
<li><a href="../fr475636/index.html">Incr√©menter les √©l√©ments vectoriels</a></li>
<li><a href="../fr475640/index.html">Si vous cr√©ez quelque chose, √©vitez le calendrier du responsable.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>