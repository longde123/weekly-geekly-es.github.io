<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏼 😊 🎫 bytes.Buffer in Go: optimisations qui ne fonctionnent pas 🕵🏿 💆🏽 🧘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreux programmeurs Go connaissent les octets.Buffer . L'un de ses avantages est qu'il vous permet d'éviter d'allouer de la mémoire sur le tas de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bytes.Buffer in Go: optimisations qui ne fonctionnent pas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/422447/"><p>  De nombreux programmeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Go</a> connaissent les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octets.Buffer</a> .  L'un de ses avantages est qu'il vous permet d'éviter d'allouer de la mémoire sur le tas de la même manière que " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petite mémoire tampon / optimisation de la taille</a> ": </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [<span class="hljs-number"><span class="hljs-number">64</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-comment"><span class="hljs-comment">//        // ...   }</span></span></code> </pre> <br><p>  Il n'y a qu'un seul problème.  Cette optimisation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne fonctionne pas</a> . </p><br><p>  À la fin de cet article, vous découvrirez pourquoi cette optimisation ne fonctionne pas et ce que nous pouvons y faire. </p><a name="habracut"></a><br><h1 id="kak-bylo-po-zadumke-small-buffer-optimization">  Comme prévu, "petite optimisation du tampon" </h1><br><p>  Introduisons une définition légèrement simplifiée des <code>bytes.Buffer</code> . </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smallBufSize <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> buf []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> }</code> </pre> <br><p>  Lorsque nous effectuons des actions sur le <code>Buffer</code> , par exemple, appelons la méthode <code>Buffer.Write</code> , l'enregistrement est toujours effectué dans <code>buf</code> , cependant, avant cet enregistrement, <code>Buffer.grow(n)</code> lancé à l'intérieur de chaque méthode similaire, ce qui garantit qu'il y a suffisamment d'espace dans cette tranche pour <code>n</code> octets suivants. </p><br><p>  Grow peut ressembler à ceci: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//         bytes.Buffer. l := len(b.buf) //   Buffer need := n + l have := cap(b.buf) - l if have &gt;= need { b.buf = b.buf[:need] return } if need &lt;= smallBufSize { //     , //   . b.buf = b.bootstrap[:] } else { // growFactor -     . //     need  need*2. newBuf := make([]byte, need, growFactor(need)) copy(newBuf, b.buf) b.buf = newBuf } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hypothèses utilisées dans notre implémentation de Buffer.grow</b> <div class="spoiler_text"><hr><br><p>  Nous <code>len(b.buf)</code> que <code>len(b.buf)</code> est la longueur réelle des données dans Buffer, ce qui nécessiterait que <code>Write</code> utilise des méthodes d'ajout pour ajouter de nouveaux octets à la tranche.  Ce n'est pas le cas dans <code>bytes.Buffer</code> de la bibliothèque standard, mais par exemple, c'est un détail d'implémentation sans importance. </p><br><hr></div></div><br><p>  Si <code>b</code> alloué sur la pile, le <code>bootstrap</code> intérieur est alloué sur la pile, ce qui signifie que la tranche <code>b.buf</code> réutilisera la mémoire à l'intérieur de <code>b</code> sans nécessiter d'allocation supplémentaire. </p><br><p>  Lorsque <code>grow</code> révèle que le tableau d' <code>bootstrap</code> est déjà insuffisant, une nouvelle tranche «réelle» sera créée, où les éléments du stockage précédent (du «petit tampon») seront ensuite copiés.  Après cela, <code>Buffer.bootstrap</code> perdra sa pertinence.  Si <code>Buffer.Reset</code> est <code>Buffer.Reset</code> , <code>cap(b.buf)</code> restera le même et il n'y aura plus besoin d'un tableau d' <code>bootstrap</code> . </p><br><h1 id="pamyat-ubegayuschaya-v-heap">  La mémoire s'enfuit en tas </h1><br><p>  Il est en outre prévu que le lecteur soit au moins superficiellement familier avec ce qu'est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyse d'échappement</a> dans Go. </p><br><p>  Considérez la situation suivante: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer <span class="hljs-comment"><span class="hljs-comment">// leak.go:11:6: moved to heap: b return &amp;b // leak.go:12:9: &amp;b escapes to heap }</span></span></code> </pre> <br><p>  Ici <code>b</code> sera alloué sur le tas.  La raison en est le pointeur qui fuit vers <code>b</code> : </p><br><pre> <code class="bash hljs">$ go tool compile -m leak.go leak.go:12:9: &amp;b escapes to heap leak.go:11:6: moved to heap: b</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Terminologie</b> <div class="spoiler_text"><hr><br><p>  Dans cet article, «fuite» et «évasions» sont utilisés de manière presque synonyme. </p><br><p>  Il y a une certaine différence dans le compilateur lui-même, par exemple, la valeur «échappe au tas», mais les paramètres de la fonction sont «fuite x param». </p><br><p>  Un paramètre qui fuit signifie que l'argument passé pour ce paramètre sera alloué sur le tas.  En d'autres termes, le paramètre de fuite provoque l'échappement des arguments dans un tas. </p><br><hr></div></div><br><p>  Ce qui précède était un cas évident, mais qu'en est-il: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() }</code> </pre> <br><p>  Ici, nous n'avons besoin que d'un octet, tout tient dans le <code>bootstrap</code> , le tampon lui-même est local et ne "s'échappe" pas de la fonction.  Vous serez peut-être surpris, mais le résultat sera le même, l'allocation <code>b</code> sur le tas. </p><br><img src="https://habrastorage.org/webt/_d/3w/jr/_d3wjrildbyauunsvvv5oq7zqpo.jpeg"><br><p>  Pour être sûr, vous pouvez vérifier cela en utilisant le benchmark: </p><br><pre> <code class="hljs powershell">BenchmarkLength<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">90.1</span></span> ns/op <span class="hljs-number"><span class="hljs-number">112</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Liste de référence</b> <div class="spoiler_text"><hr><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = length() } }</code> </pre> <br><hr></div></div><br><div class="spoiler">  <b class="spoiler_title">Explication 112 B / op</b> <div class="spoiler_text"><hr><br><p>  Lorsque le runtime demande à l'allocateur <code>N</code> octets, il n'est pas nécessaire que exactement <code>N</code> octets soient alloués. </p><br><blockquote>  Tous les résultats ci-dessous concernent la combinaison de <code>GOOS=linux</code> et <code>GOARCH=AMD64</code> . </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:noinline func alloc9() []byte { return make([]byte, 9) } func BenchmarkAlloc9(b *testing.B) { for i := 0; i &lt; bN; i++ { _ = alloc9() } }</span></span></code> </pre> <br><p>  Si vous exécutez <code>go test -bench=. -benchmem</code>  <code>go test -bench=. -benchmem</code> avec ce test: </p><br><pre> <code class="hljs powershell">BenchmarkAlloc9<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-number"><span class="hljs-number">33.5</span></span> ns/op <span class="hljs-number"><span class="hljs-number">16</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><p>  9 octets demandés, 16 alloués. Revenons maintenant aux <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs">fmt.Println(unsafe.Sizeof(bytes.Buffer{})) =&gt; <span class="hljs-number"><span class="hljs-number">104</span></span></code> </pre> <br><p>  Regardons <a href="">$ GOROOT / src / runtime / sizeclasses.go</a> : </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ class bytes/obj</span></span> bytes/span objects tail waste max waste /<span class="hljs-regexp"><span class="hljs-regexp">/ 1 8 8192 1024 0 87.50% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 16 8192 512 0 43.75% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3 32 8192 256 0 46.88% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 4 48 8192 170 32 31.52% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5 64 8192 128 0 23.44% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 6 80 8192 102 32 19.07% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 7 96 8192 85 32 15.95% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 8 112 8192 73 16 13.56% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... </span></span></code> </pre> <br><p>  Il ne tient pas dans 96 octets, 112 est sélectionné. </p><br><hr></div></div><br><p>  Mais pourquoi cela se produit-il? </p><br><h1 id="chto-proishodit-i-pochemu">  Que se passe-t-il et pourquoi </h1><br><p>  Une analyse de la situation peut être trouvée dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">numéro</a> mentionné au tout début. <br>  Il y a aussi un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simple reproducteur</a> . </p><br><p>  La place du problème se trouve juste dans l'affectation <code>b.buf = b.bootstrap[:]</code> .  Ce code fait que l'analyse d'échappement suppose que <code>b.bootstrap</code> "s'enfuit", et puisqu'il s'agit d'un tableau, il est stocké à l'intérieur de l'objet lui-même, ce qui signifie que tous les <code>b</code> doivent être alloués sur le tas. </p><br><p>  Si le bootstrap était une tranche, pas un tableau, cela ne se produirait pas, car il existe une optimisation ad hoc pour attribuer des tranches de l'objet à l'objet lui-même: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     , // object      . object.buf1 = object.buf2[a:b]</span></span></code> </pre> <br><p>  La réponse pour laquelle cette optimisation ne fonctionne pas pour les tableaux a déjà été formulée ci-dessus, mais voici un extrait de <a href="">esc.go # L835-L866 lui-même</a> (tout le code d'optimisation est mis en évidence par référence): </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Note, this optimization does not apply to OSLICEARR, // because it does introduce a new pointer into b that was not already there // (pointer to b itself). After such assignment, if b contents escape, // b escapes as well. If we ignore such OSLICEARR, we will conclude // that b does not escape when b contents do.</span></span></code> </pre> <br><p>  Il convient d'ajouter ici que pour l'analyseur de pointeur, il existe plusieurs niveaux de "fuites", les principaux d'entre eux: </p><br><ol><li>  L'objet lui-même s'échappe (b s'échappe).  Dans ce cas, l'objet lui-même doit être alloué sur le tas. </li><li>  Les éléments de l'objet (b contenu s'échappent) s'échappent.  Dans ce cas, les pointeurs de l'objet sont considérés comme s'échappant. </li></ol><br><p>  Le cas avec le tableau est spécial en ce que si le tableau fuit, l'objet qui le contient doit également fuir. </p><br><p>  L'analyse d'échappement décide s'il est possible ou non de placer un objet sur la pile, en se basant uniquement sur les informations disponibles dans le corps de la fonction analysée.  La méthode <code>Buffer.grow</code> prend <code>b</code> par pointeur, elle doit donc calculer un emplacement approprié à placer.  Étant donné que dans le cas d'un tableau, nous ne pouvons pas distinguer <code>"b escape"</code> de <code>"b contents escape"</code> , nous devons être plus pessimistes et arriver à la conclusion que <code>b</code> pas sûr à placer sur la pile. </p><br><p>  Supposons le contraire, que le modèle d' <code>self-assignment</code> résout la même chose pour les tableaux que pour les tranches: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> bad <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { array [<span class="hljs-number"><span class="hljs-number">10</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> slice []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *bad)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b.slice = b.array[:] <span class="hljs-comment"><span class="hljs-comment">// ignoring self-assignment to b.slice sink = b.array // b.array escapes to heap // b does not escape }</span></span></code> </pre> <br><p>  La décision de placer <code>b</code> sur la pile dans cette situation entraînera un désastre: après avoir quitté la fonction à l'intérieur de laquelle <code>b</code> été créé, la mémoire à laquelle se réfèrera le récepteur ne sera rien de plus que des ordures. </p><br><h1 id="ukazateli-na-massivy">  Pointeurs de tableau </h1><br><p>  Imaginez que notre <code>Buffer</code> été déclaré un peu différemment: </p><br><pre> <code class="diff hljs">const smallBufSize int = 64 type Buffer struct { - bootstrap [smallBufSize]byte + bootstrap *[smallBufSize]byte buf []byte }</code> </pre> <br><p>  Contrairement à un tableau normal, un pointeur sur un tableau ne stockera pas tous les éléments à l'intérieur du <code>Buffer</code> lui-même.  Cela signifie que si l'allocation d' <code>bootstrap</code> sur le tas n'entraîne pas <code>Buffer</code> allocation de <code>Buffer</code> sur le tas.  Étant donné que l'analyse d'échappement peut allouer des champs de pointeur sur la pile lorsque cela est possible, nous pouvons supposer qu'une telle définition de <code>Buffer</code> est plus efficace. </p><br><p>  Mais c'est en théorie.  En pratique, un pointeur vers un tableau n'a pas beaucoup de traitement et tombe dans la même catégorie qu'une tranche d'un tableau normal, ce qui n'est pas tout à fait correct.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CL133375: cmd / compile / internal / gc: gérer la tranche de tableau auto-affectée dans esc.go</a> vise à corriger cette situation. </p><br><p>  Supposons que cette modification ait été acceptée dans le compilateur Go. </p><br><h1 id="zero-value-kotoryy-my-poteryali">  Zéro valeur que nous avons perdue </h1><br><p>  Malheureusement, la transition de <code>[64]byte</code> à <code>*[64]byte</code> a un problème: maintenant nous ne pouvons pas utiliser le <code>bootstrap</code> sans l'initialiser explicitement, une valeur nulle de <code>Buffer</code> cesse d'être utile, nous avons besoin d'un constructeur. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer{bootstrap: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(*[smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)} }</code> </pre> <br><p>  Nous <code>Buffer</code> , pas <code>*Buffer</code> , pour éviter des problèmes avec l'analyse des pointeurs (c'est très conservateur dans Go), et compte tenu du fait que <code>NewBuffer</code> toujours intégré à l'endroit d'un appel, il n'y aura pas de copie inutile. </p><br><p>  Après avoir <code>NewBuffer</code> corps <code>NewBuffer</code> à la place de l'appel d'échappement, l'analyse peut essayer de prouver que le <code>new(*[smallBufSize]byte)</code> ne dépasse pas la durée de vie de la trame de la fonction dans laquelle il est appelé.  Si c'est le cas, alors l'allocation sera sur la pile. </p><br><h1 id="intel-bytebuf">  Intel bytebuf </h1><br><p>  L'optimisation décrite ci-dessus est appliquée dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package intel-go / bytebuf</a> . </p><br><p>  Cette bibliothèque exporte le type <code>bytebuf.Buffer</code> , qui duplique 99,9% <code>bytes.Buffer</code> .  Toutes les modifications sont réduites à l'introduction d'un constructeur ( <code>bytebuf.New</code> ) et d'un pointeur vers un tableau au lieu d'un tableau normal: </p><br><pre> <code class="diff hljs">type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at &amp;buf[off], write at &amp;buf[len(buf)] - bootstrap [64]byte // helps small buffers avoid allocation. + bootstrap *[64]byte // helps small buffers avoid allocation. lastRead readOp // last read operation (for Unread*). }</code> </pre> <br><p>  Voici une comparaison des performances avec les <code>bytes.Buffer</code> : </p><br><pre> <code class="hljs powershell">name old time/op new time/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">138</span></span>ns ±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-number"><span class="hljs-number">24</span></span>ns ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-82</span></span>.<span class="hljs-number"><span class="hljs-number">94</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">186</span></span>ns ±<span class="hljs-number"><span class="hljs-number">11</span></span>% <span class="hljs-number"><span class="hljs-number">60</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-67</span></span>.<span class="hljs-number"><span class="hljs-number">82</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">225</span></span>ns ±<span class="hljs-number"><span class="hljs-number">10</span></span>% <span class="hljs-number"><span class="hljs-number">108</span></span>ns ± <span class="hljs-number"><span class="hljs-number">6</span></span>% <span class="hljs-literal"><span class="hljs-literal">-52</span></span>.<span class="hljs-number"><span class="hljs-number">26</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">474</span></span>ns ±<span class="hljs-number"><span class="hljs-number">17</span></span>% <span class="hljs-number"><span class="hljs-number">338</span></span>ns ±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-literal"><span class="hljs-literal">-28</span></span>.<span class="hljs-number"><span class="hljs-number">57</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">889</span></span>ns ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">740</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-16</span></span>.<span class="hljs-number"><span class="hljs-number">78</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old alloc/op new alloc/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">112</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>B <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">117</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">5</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-95</span></span>.<span class="hljs-number"><span class="hljs-number">73</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">176</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">64</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-63</span></span>.<span class="hljs-number"><span class="hljs-number">64</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">368</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">256</span></span>B ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-30</span></span>.<span class="hljs-number"><span class="hljs-number">43</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.16</span></span>kB ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.05</span></span>kB ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-5</span></span>.<span class="hljs-number"><span class="hljs-number">19</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old allocs/op new allocs/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0.00</span></span> <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> ± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  Toutes les autres informations sont disponibles dans <a href="">README</a> . </p><br><p>  En raison de l'impossibilité d'utiliser la valeur zéro et la liaison à la fonction de construction <code>New</code> , il n'est pas possible d'appliquer cette optimisation à <code>bytes.Buffer</code> . </p><br><p>  Est-ce la seule façon de faire des <code>bytes.Buffer</code> plus <code>bytes.Buffer</code> ?  La réponse est non.  Mais c'est certainement une méthode qui nécessite des changements minimes dans la mise en œuvre. </p><br><h1 id="plany-na-escape-analysis">  Plans d'analyse d'échappement </h1><br><p>  Dans sa forme actuelle, l'analyse d'échappement dans Go est assez faible.  Presque toute opération avec des valeurs de pointeur conduit à des allocations sur le tas, même si ce n'est pas une décision raisonnable. </p><br><p>  Je vais essayer de diriger la plupart du temps que je consacre au projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">golang / go</a> pour résoudre ces problèmes, donc certaines améliorations sont possibles dans la prochaine version (1.12). </p><br><p>  Vous pouvez lire les résultats et les détails de la structure interne de cette partie du compilateur dans l'un de mes prochains articles.  J'essaierai de fournir un ensemble de recommandations qui aideront dans certains cas à structurer le code afin qu'il ait moins d'allocations de mémoire indésirables. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422447/">https://habr.com/ru/post/fr422447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422437/index.html">Jeux d'expérience utilisateur et vitesse du site Web et des applications</a></li>
<li><a href="../fr422439/index.html">Le combat avec Yandex: comment j'ai passé plus d'un an pour amener le site au top</a></li>
<li><a href="../fr422441/index.html">Trouvé une formule pour une transition indolore vers .Net Core</a></li>
<li><a href="../fr422443/index.html">Corona SDK Precise Timer</a></li>
<li><a href="../fr422445/index.html">Implémentation de BottomAppBar. Partie 3: Comportement pour Android</a></li>
<li><a href="../fr422449/index.html">Sénateurs contre Amazon: ce qu'a fait une boutique en ligne</a></li>
<li><a href="../fr422451/index.html">Pour écouter le marketing de jeu et la place d'un scénariste dans l'industrie du jeu le 26 septembre chez VShBI</a></li>
<li><a href="../fr422453/index.html">SmartData 2018: première conférence du groupe JUG.ru annulée</a></li>
<li><a href="../fr422455/index.html">EPAM + universités: comment nous travaillons avec les universités ukrainiennes</a></li>
<li><a href="../fr422457/index.html">«Cela n'a aucun sens pour nous d'utiliser Retrofit»: à propos du développement Android sur Sberbank Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>